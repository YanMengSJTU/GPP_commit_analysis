diff --git a/.gitignore b/.gitignore
index f05f56746..7de7142f7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,3 +27,5 @@ obj
 .DS_Store
 
 dependency-reduced-pom.xml
+
+test_runs/
diff --git a/README.md b/README.md
index 5f4ee00af..3c0e8bc13 100644
--- a/README.md
+++ b/README.md
@@ -35,7 +35,7 @@ instructions and other useful information.  Substantial usage information can be
 found in the [API documentation][20api].
 
 You can also learn more from [the original proposal][proposal], 
-[this talk by Greg Kick][gaktalk], and on discussions on the dagger-discuss@googlegroups.com
+[this talk by Greg Kick][gaktalk], and on the dagger-discuss@googlegroups.com
 mailing list. 
 
 Installation
@@ -46,9 +46,9 @@ In order to activate code generation and generate implementations to manage
 your graph you will need to include `dagger-compiler-2.0.1.jar` in your build
 at compile time.
 
-In a Maven project, one would include the `dagger` artifact in the dependencies section
-of your `pom.xml` and the `dagger-compiler` artifact as either  an `optional` or `provided`
-dependency:
+In a Maven project, include the `dagger` artifact in the dependencies section
+of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
+`provided` dependency:
 
 ```xml
 <dependencies>
@@ -67,7 +67,7 @@ dependency:
 ```
 
 If you use the beta `dagger-producers` extension (which supplies parallelizable execution graphs),
-then you should add this to your maven configuration:
+then add this to your maven configuration:
 
 ```xml
 <dependencies>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 3a0530f81..1eca20c14 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -46,6 +46,13 @@ limitations under the License.
       <version>${auto.value.version}</version>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <!-- For map-bindings -->
+      <groupId>com.google.auto.factory</groupId>
+      <artifactId>auto-factory</artifactId>
+      <version>${auto.factory.version}</version>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
new file mode 100644
index 000000000..6ffe1e07d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+@Component
+interface ComponentDependsOnGeneratedCode {
+  NeedsFactory needsFactory();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 7fd73c139..05542a40d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -35,5 +35,15 @@
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
-  Map<TestKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<TestStringKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<Class<? extends Number>, String> numberClassKeyMap();
+  Map<Class<?>, String> classKeyMap();
+  Map<Long, String> longKeyMap();
+  Map<Integer, String> integerKeyMap();
+  Map<Short, String> shortKeyMap();
+  Map<Byte, String> byteKeyMap();
+  Map<Boolean, String> booleanKeyMap();
+  Map<Character, String> characterKeyMap();
+  Map<TestStringKey, String> unwrappedAnnotationKeyMap();
+  Map<TestWrappedAnnotationKey, String> wrappedAnnotationKeyMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 311ac1bd6..73d53fef3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -17,6 +17,8 @@
 
 import dagger.Module;
 import dagger.Provides;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
@@ -27,11 +29,15 @@
 
 @Module
 class MultibindingModule {
-  @Provides(type = MAP) @TestKey("foo") String provideFooKey(double doubleDependency) {
+  @Provides(type = MAP)
+  @TestStringKey("foo")
+  String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
-  @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
+  @Provides(type = MAP)
+  @TestStringKey("bar")
+  String provideBarKey() {
     return "bar value";
   }
 
@@ -51,11 +57,98 @@
     return map.values();
   }
 
-  @Provides(type = MAP) @TestKey.NestedWrappedKey(Integer.class) String valueForInteger() {
+  @Provides(type = MAP)
+  @TestStringKey.NestedWrappedKey(Integer.class)
+  String valueForInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP) @TestKey.NestedWrappedKey(Long.class) String valueForLong() {
+  @Provides(type = MAP)
+  @TestStringKey.NestedWrappedKey(Long.class)
+  String valueForLong() {
     return "long";
   }
+
+  @Provides(type = MAP)
+  @TestClassKey(Integer.class)
+  String valueForClassInteger() {
+    return "integer";
+  }
+
+  @Provides(type = MAP)
+  @TestClassKey(Long.class)
+  String valueForClassLong() {
+    return "long";
+  }
+
+  @Provides(type = MAP)
+  @TestNumberClassKey(BigDecimal.class)
+  String valueForNumberClassBigDecimal() {
+    return "bigdecimal";
+  }
+
+  @Provides(type = MAP)
+  @TestNumberClassKey(BigInteger.class)
+  String valueForNumberClassBigInteger() {
+    return "biginteger";
+  }
+
+  @Provides(type = MAP)
+  @TestLongKey(longValue = 100)
+  String valueFor100Long() {
+    return "100 long";
+  }
+
+  @Provides(type = MAP)
+  @TestIntKey(100)
+  String valueFor100Int() {
+    return "100 int";
+  }
+
+  @Provides(type = MAP)
+  @TestShortKey(100)
+  String valueFor100Short() {
+    return "100 short";
+  }
+
+  @Provides(type = MAP)
+  @TestByteKey(100)
+  String valueFor100Byte() {
+    return "100 byte";
+  }
+
+  @Provides(type = MAP)
+  @TestBooleanKey(true)
+  String valueForTrue() {
+    return "true";
+  }
+
+  @Provides(type = MAP)
+  @TestCharKey('a')
+  String valueForA() {
+    return "a char";
+  }
+
+  @Provides(type = MAP)
+  @TestCharKey('\n')
+  String valueForNewline() {
+    return "newline char";
+  }
+
+  @Provides(type = MAP)
+  @TestUnwrappedAnnotationKey(@TestStringKey("foo\n"))
+  String valueForUnwrappedAnnotationKeyFoo() {
+    return "foo annotation";
+  }
+
+  @Provides(type = MAP)
+  @TestWrappedAnnotationKey(
+    value = @TestStringKey("foo"),
+    integers = {1, 2, 3},
+    annotations = {},
+    classes = {Long.class, Integer.class}
+  )
+  String valueForWrappedAnnotationKeyFoo() {
+    return "wrapped foo annotation";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
new file mode 100644
index 000000000..b78907382
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
@@ -0,0 +1,27 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.auto.factory.AutoFactory;
+import javax.inject.Inject;
+
+class NeedsFactory {
+  @Inject NeedsFactory(NeedsFactory_SomethingFactory somethingFactory) {}
+
+  @AutoFactory
+  static class Something {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
new file mode 100644
index 000000000..a4883459a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestBooleanKey {
+  boolean value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
new file mode 100644
index 000000000..7ad25c4a2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestByteKey {
+  byte value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
new file mode 100644
index 000000000..a727551de
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestCharKey {
+  char value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
new file mode 100644
index 000000000..921259781
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestClassKey {
+  Class<?> value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
new file mode 100644
index 000000000..14b25cf5d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestIntKey {
+  int value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
new file mode 100644
index 000000000..ba06ad0e1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestLongKey {
+  long longValue(); // Tests that the unwrapped member can have any name.
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
new file mode 100644
index 000000000..884c75e19
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestNumberClassKey {
+  Class<? extends Number> value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
new file mode 100644
index 000000000..a74f21041
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestShortKey {
+  short value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
index 645af788a..a0e89ed71 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
@@ -18,7 +18,7 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestKey {
+@interface TestStringKey {
   String value();
 
   @MapKey(unwrapValue = false)
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
new file mode 100644
index 000000000..a00372890
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestUnwrappedAnnotationKey {
+  TestStringKey value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
new file mode 100644
index 000000000..13c059058
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
@@ -0,0 +1,26 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = false)
+@interface TestWrappedAnnotationKey {
+  TestStringKey value();
+  int[] integers();
+  TestClassKey[] annotations();
+  Class<? extends Number>[] classes();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
new file mode 100644
index 000000000..3c884159f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage;
+
+import dagger.Component;
+import java.util.Set;
+import test.multipackage.a.AModule;
+import test.multipackage.sub.FooChildComponent;
+
+/**
+ * A component that tests the interaction between subcomponents, multiple packages, and
+ * multibindings. Specifically, we want:
+ * <ul>
+ * <li>A set binding with some contributions in the parent component, and some in the subcomponent.
+ * <li>The contributions come from different packages, but not the package of either component.
+ * <li>The set binding is requested in the subcomponent through a binding from a separate package.
+ * <li>No binding in the subcomponent, that's in the subcomponent's package, directly uses any
+ *     binding from the component's package.
+ * </ul>
+ */
+// NOTE(beder): Be careful about changing any bindings in either this component or the subcomponent.
+// Even adding a binding might stop this test from testing what it's supposed to test.
+@Component(modules = {AModule.class})
+interface FooComponent {
+  Set<String> setOfString();
+
+  FooChildComponent fooChildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
new file mode 100644
index 000000000..d62506a56
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+public final class AModule {
+  @Provides(type = SET) String provideString() {
+    return "a";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
new file mode 100644
index 000000000..4d817f153
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.b;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+public final class BModule {
+  @Provides(type = SET) String provideString() {
+    return "b";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
new file mode 100644
index 000000000..e608afb2c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.c;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Set;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+public final class CModule {
+  @Provides(type = SET) String provideString() {
+    return "c";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
new file mode 100644
index 000000000..51f8ace76
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.d;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Set;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+public final class DModule {
+  @Provides(type = SET) String provideString() {
+    return "d";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
new file mode 100644
index 000000000..35f5862ad
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.foo;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class Foo<T> {
+  public final Set<String> strings;
+
+  @Inject Foo(Set<String> strings) {
+    this.strings = strings;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
new file mode 100644
index 000000000..16a61dd54
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.grandsub;
+
+import dagger.Subcomponent;
+import test.multipackage.d.DModule;
+import test.multipackage.foo.Foo;
+
+@Subcomponent(modules = DModule.class)
+public interface FooGrandchildComponent {
+  Foo<FooGrandchildComponent> foo();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
new file mode 100644
index 000000000..9050fcd72
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.sub;
+
+import dagger.Subcomponent;
+import test.multipackage.b.BModule;
+import test.multipackage.c.CModule;
+import test.multipackage.foo.Foo;
+import test.multipackage.grandsub.FooGrandchildComponent;
+
+@Subcomponent(modules = {BModule.class, CModule.class})
+public interface FooChildComponent {
+  Foo<FooChildComponent> foo();
+
+  FooGrandchildComponent fooGrandchildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
new file mode 100644
index 000000000..0310df6ef
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class DependsOnGeneratedCodeTest {
+  @Test public void testComponentDependsOnGeneratedCode() {
+    assertThat(DaggerComponentDependsOnGeneratedCode.create().needsFactory()).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 8172ced27..66a429be1 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,6 +15,8 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableMap;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Map;
 import javax.inject.Provider;
 import org.junit.Before;
@@ -64,12 +66,97 @@
             nestedWrappedKey(Long.class), "long"));
   }
 
+  @Test
+  public void unwrappedAnnotationKeyMap() {
+    assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
+        .isEqualTo(ImmutableMap.of(testStringKey("foo\n"), "foo annotation"));
+  }
+
+  @Test
+  public void wrappedAnnotationKeyMap() {
+    @SuppressWarnings("unchecked")
+    Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
+    assertThat(multibindingComponent.wrappedAnnotationKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                testWrappedAnnotationKey(
+                    testStringKey("foo"), new int[] {1, 2, 3}, new TestClassKey[] {}, classes),
+                "wrapped foo annotation"));
+  }
+
+  @Test
+  public void booleanKeyMap() {
+    assertThat(multibindingComponent.booleanKeyMap()).isEqualTo(ImmutableMap.of(true, "true"));
+  }
+
+  @Test
+  public void byteKeyMap() {
+    assertThat(multibindingComponent.byteKeyMap())
+        .isEqualTo(ImmutableMap.of((byte) 100, "100 byte"));
+  }
+
+  @Test
+  public void charKeyMap() {
+    assertThat(multibindingComponent.characterKeyMap())
+        .isEqualTo(ImmutableMap.of('a', "a char", '\n', "newline char"));
+  }
+
+  @Test
+  public void classKeyMap() {
+    assertThat(multibindingComponent.classKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                Integer.class, "integer",
+                Long.class, "long"));
+  }
+
+  @Test
+  public void numberClassKeyMap() {
+    assertThat(multibindingComponent.numberClassKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                BigDecimal.class, "bigdecimal",
+                BigInteger.class, "biginteger"));
+  }
+
+  @Test
+  public void intKeyMap() {
+    assertThat(multibindingComponent.integerKeyMap()).isEqualTo(ImmutableMap.of(100, "100 int"));
+  }
+
+  @Test
+  public void longKeyMap() {
+    assertThat(multibindingComponent.longKeyMap())
+        .isEqualTo(ImmutableMap.of((long) 100, "100 long"));
+  }
+
+  @Test
+  public void shortKeyMap() {
+    assertThat(multibindingComponent.shortKeyMap())
+        .isEqualTo(ImmutableMap.of((short) 100, "100 short"));
+  }
+
   @Test public void setBindings() {
     assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
   }
 
   @AutoAnnotation
-  static TestKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+  static TestStringKey testStringKey(String value) {
+    return new AutoAnnotation_MultibindingTest_testStringKey(value);
+  }
+
+  @AutoAnnotation
+  static TestStringKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
     return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
+
+  @AutoAnnotation
+  static TestWrappedAnnotationKey testWrappedAnnotationKey(
+      TestStringKey value,
+      int[] integers,
+      TestClassKey[] annotations,
+      Class<? extends Number>[] classes) {
+    return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
+        value, integers, annotations, classes);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
new file mode 100644
index 000000000..fd670f266
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with a component or production component
+ * as part of the {@link ComponentProcessor}.
+ */
+abstract class AbstractComponentProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
+
+  AbstractComponentProcessingStep(
+      Messager messager,
+      BindingGraphValidator bindingGraphValidator,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
+    this.messager = messager;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public final ImmutableSet<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
+    for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
+      try {
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentDescriptor.componentDefinitionType());
+      }
+    }
+    return rejectedElements.build();
+  }
+
+  /**
+   * Returns a {@link ComponentDescriptor} for each valid component element for which an
+   * implementation class should be generated.
+   */
+  protected abstract Set<ComponentDescriptor> componentDescriptors(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 80e6c1187..68da53502 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -18,44 +18,38 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Provides;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
-
+import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.Executor;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -64,19 +58,29 @@
  */
 @AutoValue
 abstract class BindingGraph {
-  enum ModuleStrategy {
-    PASSED,
-    CONSTRUCTED,
-  }
-
   abstract ComponentDescriptor componentDescriptor();
-  abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
+  /**
+   * Returns the set of types necessary to implement the component, but are not part of the injected
+   * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
+   * {@link ProductionComponent}.
+   */
+  ImmutableSet<TypeElement> componentRequirements() {
+    return FluentIterable.from(componentDescriptor().transitiveModules())
+        .transform(new Function<ModuleDescriptor, TypeElement>() {
+          @Override public TypeElement apply(ModuleDescriptor input) {
+            return input.moduleElement();
+          }
+        })
+        .append(componentDescriptor().dependencies())
+        .append(componentDescriptor().executorDependency().asSet())
+        .toSet();
+  }
+
   static final class Factory {
     private final Elements elements;
-    private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
@@ -84,14 +88,12 @@
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
-        Types types,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
-      this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
@@ -109,7 +111,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           ImmutableSet.builder();
       ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
           ImmutableSet.builder();
-      AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
@@ -144,28 +145,15 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
         }
       }
 
-      // Collect transitive modules provisions.
-      ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
-
-      ImmutableMap.Builder<TypeElement, ModuleStrategy> transitiveModules = ImmutableMap.builder();
-      for (TypeElement module : getTransitiveModules(types, elements, moduleTypes)) {
-        transitiveModules.put(module,
-            (componentCanMakeNewInstances(module) && module.getTypeParameters().isEmpty())
-                ? ModuleStrategy.CONSTRUCTED
-                : ModuleStrategy.PASSED);
-
-        // traverse the modules, collect the bindings
-        List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
-        for (ExecutableElement moduleMethod : moduleMethods) {
-          if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            explicitProvisionBindingsBuilder.add(
-                provisionBindingFactory.forProvidesMethod(moduleMethod, module.asType()));
+      // Collect transitive module bindings.
+      for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
+        for (ContributionBinding binding : moduleDescriptor.bindings()) {
+          if (binding instanceof ProvisionBinding) {
+            explicitProvisionBindingsBuilder.add((ProvisionBinding) binding);
+          }
+          if (binding instanceof ProductionBinding) {
+            explicitProductionBindingsBuilder.add((ProductionBinding) binding);
           }
-          if (isAnnotationPresent(moduleMethod, Produces.class)) {
-            explicitProductionBindingsBuilder.add(
-                productionBindingFactory.forProducesMethod(moduleMethod, module.asType()));
-           }
         }
       }
 
@@ -191,7 +179,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          transitiveModules.build(),
           requestResolver.getResolvedBindings(),
           subgraphsBuilder.build());
     }
@@ -212,7 +199,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
-      final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
+      final Deque<BindingKey> cycleStack = new ArrayDeque<>();
 
       RequestResolver(Optional<RequestResolver> parentResolver,
           Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 74080ff8e..2b38b5ab6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -38,7 +38,6 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
-import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -46,7 +45,6 @@
 import java.util.Formatter;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
@@ -108,395 +106,630 @@
     this.keyFormatter = keyFormatter;
   }
 
-  @Override
-  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
-    final ValidationReport.Builder<BindingGraph> reportBuilder =
-        ValidationReport.Builder.about(subject);
-    return validate(subject, reportBuilder);
-  }
+  private class Validation {
+    final BindingGraph topLevelGraph;
+    final ValidationReport.Builder<BindingGraph> reportBuilder;
 
-  private ValidationReport<BindingGraph> validate(final BindingGraph subject,
-      final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-
-    validateComponentScope(subject, reportBuilder, resolvedBindings);
-    validateDependencyScopes(subject, reportBuilder);
-    validateBuilders(subject, reportBuilder);
-
-    for (ComponentMethodDescriptor componentMethod :
-        subject.componentDescriptor().componentMethods()) {
-      Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
-      if (entryPoint.isPresent()) {
-        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
-            Sets.<BindingKey>newHashSet(), subject, reportBuilder,
-            Sets.<DependencyRequest>newHashSet());
-      }
+    Validation(BindingGraph topLevelGraph) {
+      this.topLevelGraph = topLevelGraph;
+      this.reportBuilder = ValidationReport.Builder.about(topLevelGraph);
     }
 
-    validateSubcomponents(subject, reportBuilder);
-    return reportBuilder.build();
-  }
-
-  private void traverseRequest(
-      DependencyRequest request,
-      Deque<ResolvedRequest> bindingPath,
-      Set<BindingKey> keysInPath,
-      BindingGraph graph,
-      ValidationReport.Builder<BindingGraph> reportBuilder,
-      Set<DependencyRequest> resolvedRequests) {
-    verify(bindingPath.size() == keysInPath.size(),
-        "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
-    BindingKey requestKey = request.bindingKey();
-    if (keysInPath.contains(requestKey)) {
-      reportCycle(request, bindingPath, reportBuilder);
-      return;
+    ValidationReport<BindingGraph> buildReport() {
+      return reportBuilder.build();
     }
 
-     // If request has already been resolved, avoid re-traversing the binding path.
-    if (resolvedRequests.add(request)) {
-      ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
-      bindingPath.push(resolvedRequest);
-      keysInPath.add(requestKey);
-      validateResolvedBinding(bindingPath, resolvedRequest.binding(), reportBuilder);
-
-      for (Binding binding : resolvedRequest.binding().bindings()) {
-        for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-          traverseRequest(nextRequest, bindingPath, keysInPath, graph, reportBuilder,
-              resolvedRequests);
+    void validateSubgraph(BindingGraph subject) {
+      validateComponentScope(subject);
+      validateDependencyScopes(subject);
+      validateBuilders(subject);
+
+      for (ComponentMethodDescriptor componentMethod :
+           subject.componentDescriptor().componentMethods()) {
+        Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
+        if (entryPoint.isPresent()) {
+          traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
+              Sets.<BindingKey>newHashSet(), subject,
+              Sets.<DependencyRequest>newHashSet());
         }
       }
-      bindingPath.poll();
-      keysInPath.remove(requestKey);
-    }
-  }
-
-  private void validateSubcomponents(BindingGraph graph,
-      ValidationReport.Builder<BindingGraph> reportBuilder) {
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
-      validate(subgraphEntry.getValue(), reportBuilder);
-    }
-  }
 
-  /**
-   * Validates that the set of bindings resolved is consistent with the type of the binding, and
-   * returns true if the bindings are valid.
-   */
-  private boolean validateResolvedBinding(
-      Deque<ResolvedRequest> path,
-      ResolvedBindings resolvedBinding,
-      Builder<BindingGraph> reportBuilder) {
-    if (resolvedBinding.bindings().isEmpty()) {
-      reportMissingBinding(path, reportBuilder);
-      return false;
+      for (BindingGraph subgraph : subject.subgraphs().values()) {
+        validateSubgraph(subgraph);
+      }
     }
 
-    ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
-        ImmutableSet.builder();
-    ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
-        ImmutableSet.builder();
-    ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
-        ImmutableSet.builder();
-    for (Binding binding : resolvedBinding.bindings()) {
-      if (binding instanceof ProvisionBinding) {
-        provisionBindingsBuilder.add((ProvisionBinding) binding);
-      }
-      if (binding instanceof ProductionBinding) {
-        productionBindingsBuilder.add((ProductionBinding) binding);
+    private void traverseRequest(
+        DependencyRequest request,
+        Deque<ResolvedRequest> bindingPath,
+        Set<BindingKey> keysInPath,
+        BindingGraph graph,
+        Set<DependencyRequest> resolvedRequests) {
+      verify(bindingPath.size() == keysInPath.size(),
+          "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
+      BindingKey requestKey = request.bindingKey();
+      if (keysInPath.contains(requestKey)) {
+        reportCycle(request, bindingPath);
+        return;
       }
-      if (binding instanceof MembersInjectionBinding) {
-        membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
+
+      // If request has already been resolved, avoid re-traversing the binding path.
+      if (resolvedRequests.add(request)) {
+        ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
+        bindingPath.push(resolvedRequest);
+        keysInPath.add(requestKey);
+        validateResolvedBinding(bindingPath, resolvedRequest.binding());
+
+        for (Binding binding : resolvedRequest.binding().bindings()) {
+          for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+            traverseRequest(nextRequest, bindingPath, keysInPath, graph, resolvedRequests);
+          }
+        }
+        bindingPath.poll();
+        keysInPath.remove(requestKey);
       }
     }
-    ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
-    ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
-    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-        membersInjectionBindingsBuilder.build();
-
-    switch (resolvedBinding.bindingKey().kind()) {
-      case CONTRIBUTION:
-        if (!membersInjectionBindings.isEmpty()) {
-          throw new IllegalArgumentException(
-              "contribution binding keys should never have members injection bindings");
-        }
-        Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
-        if (!validateNullability(path.peek().request(), combined, reportBuilder)) {
-          return false;
-        }
-        if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
-          reportProviderMayNotDependOnProducer(path, reportBuilder);
-          return false;
-        }
-        if ((provisionBindings.size() + productionBindings.size()) <= 1) {
-          return true;
-        }
-        ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-            ContributionBinding.bindingTypesFor(
-                Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
-        if (bindingsByType.keySet().size() > 1) {
-          reportMultipleBindingTypes(path, reportBuilder);
-          return false;
-        } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-          reportDuplicateBindings(path, reportBuilder);
-          return false;
+
+    /**
+     * Validates that the set of bindings resolved is consistent with the type of the binding, and
+     * returns true if the bindings are valid.
+     */
+    private boolean validateResolvedBinding(
+        Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
+      if (resolvedBinding.bindings().isEmpty()) {
+        reportMissingBinding(path);
+        return false;
+      }
+
+      ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
+          ImmutableSet.builder();
+      ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
+          ImmutableSet.builder();
+      ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
+          ImmutableSet.builder();
+      for (Binding binding : resolvedBinding.bindings()) {
+        if (binding instanceof ProvisionBinding) {
+          provisionBindingsBuilder.add((ProvisionBinding) binding);
         }
-        break;
-      case MEMBERS_INJECTION:
-        if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
-          throw new IllegalArgumentException(
-              "members injection binding keys should never have contribution bindings");
+        if (binding instanceof ProductionBinding) {
+          productionBindingsBuilder.add((ProductionBinding) binding);
         }
-        if (membersInjectionBindings.size() > 1) {
-          reportDuplicateBindings(path, reportBuilder);
-          return false;
+        if (binding instanceof MembersInjectionBinding) {
+          membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
         }
-        if (membersInjectionBindings.size() == 1) {
-          MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
-          if (!validateMembersInjectionBinding(binding, path, reportBuilder)) {
+      }
+      ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
+      ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
+      ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+          membersInjectionBindingsBuilder.build();
+
+      switch (resolvedBinding.bindingKey().kind()) {
+        case CONTRIBUTION:
+          if (!membersInjectionBindings.isEmpty()) {
+            throw new IllegalArgumentException(
+                "contribution binding keys should never have members injection bindings");
+          }
+          Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
+          if (!validateNullability(path.peek().request(), combined)) {
             return false;
           }
-        }
-        break;
-      default:
-        throw new AssertionError();
+          if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+            reportProviderMayNotDependOnProducer(path);
+            return false;
+          }
+          if ((provisionBindings.size() + productionBindings.size()) <= 1) {
+            return true;
+          }
+          ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+              ContributionBinding.bindingTypesFor(
+                  Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
+          if (bindingsByType.keySet().size() > 1) {
+            reportMultipleBindingTypes(path);
+            return false;
+          } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+            reportDuplicateBindings(path);
+            return false;
+          }
+          break;
+        case MEMBERS_INJECTION:
+          if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
+            throw new IllegalArgumentException(
+                "members injection binding keys should never have contribution bindings");
+          }
+          if (membersInjectionBindings.size() > 1) {
+            reportDuplicateBindings(path);
+            return false;
+          }
+          if (membersInjectionBindings.size() == 1) {
+            MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
+            if (!validateMembersInjectionBinding(binding, path)) {
+              return false;
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+      return true;
     }
-    return true;
-  }
 
-  /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-  private boolean validateNullability(DependencyRequest request,
-      Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
-    boolean valid = true;
-    if (!request.isNullable()) {
-      String typeName = null;
-      for (ContributionBinding binding : bindings) {
-        if (binding.nullableType().isPresent()) {
-          String methodSignature;
-          if (binding instanceof ProvisionBinding) {
-            ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-            methodSignature = provisionBindingFormatter.format(provisionBinding);
-          } else {
-            ProductionBinding productionBinding = (ProductionBinding) binding;
-            methodSignature = productionBindingFormatter.format(productionBinding);
-          }
-          // Note: the method signature will include the @Nullable in it!
-          // TODO(sameb): Sometimes javac doesn't include the Element in its output.
-          // (Maybe this happens if the code was already compiled before this point?)
-          // ... we manually print ouf the request in that case, otherwise the error
-          // message is kind of useless.
-          if (typeName == null) {
-            typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+    /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
+    private boolean validateNullability(
+        DependencyRequest request, Set<ContributionBinding> bindings) {
+      boolean valid = true;
+      if (!request.isNullable()) {
+        String typeName = null;
+        for (ContributionBinding binding : bindings) {
+          if (binding.nullableType().isPresent()) {
+            String methodSignature;
+            if (binding instanceof ProvisionBinding) {
+              ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+              methodSignature = provisionBindingFormatter.format(provisionBinding);
+            } else {
+              ProductionBinding productionBinding = (ProductionBinding) binding;
+              methodSignature = productionBindingFormatter.format(productionBinding);
+            }
+            // Note: the method signature will include the @Nullable in it!
+            // TODO(sameb): Sometimes javac doesn't include the Element in its output.
+            // (Maybe this happens if the code was already compiled before this point?)
+            // ... we manually print ouf the request in that case, otherwise the error
+            // message is kind of useless.
+            if (typeName == null) {
+              typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+            }
+            reportBuilder.addItem(
+                String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
+                + "\n at: " + dependencyRequestFormatter.format(request),
+                nullableValidationType,
+                request.requestElement());
+            valid = false;
           }
-          reportBuilder.addItem(
-              String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
-              + "\n at: " + dependencyRequestFormatter.format(request),
-              nullableValidationType,
-              request.requestElement());
-          valid = false;
         }
       }
+      return valid;
     }
-    return valid;
-  }
 
-  /**
-   * Validates a members injection binding, returning false (and reporting the error) if it wasn't
-   * valid.
-   */
-  private boolean validateMembersInjectionBinding(MembersInjectionBinding binding,
-      final Deque<ResolvedRequest> path, final Builder<BindingGraph> reportBuilder) {
-    return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-        reportBuilder.addItem("Invalid members injection request.",
-            path.peek().request().requestElement());
-        return false;
-      }
+    /**
+     * Validates a members injection binding, returning false (and reporting the error) if it wasn't
+     * valid.
+     */
+    private boolean validateMembersInjectionBinding(
+        MembersInjectionBinding binding, final Deque<ResolvedRequest> path) {
+      return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+          reportBuilder.addItem("Invalid members injection request.",
+              path.peek().request().requestElement());
+          return false;
+        }
+
+        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+          // If the key has type arguments, validate that each type argument is declared.
+          // Otherwise the type argument may be a wildcard (or other type), and we can't
+          // resolve that to actual types.  If the arg was an array, validate the type
+          // of the array.
+          for (TypeMirror arg : type.getTypeArguments()) {
+            boolean declared;
+            switch (arg.getKind()) {
+              case ARRAY:
+                declared = MoreTypes.asArray(arg).getComponentType().accept(
+                    new SimpleTypeVisitor6<Boolean, Void>() {
+                      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+                        return false;
+                      }
 
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        // If the key has type arguments, validate that each type argument is declared.
-        // Otherwise the type argument may be a wildcard (or other type), and we can't
-        // resolve that to actual types.  If the arg was an array, validate the type
-        // of the array.
-        for (TypeMirror arg : type.getTypeArguments()) {
-          boolean declared;
-          switch (arg.getKind()) {
-            case ARRAY:
-              declared = MoreTypes.asArray(arg).getComponentType().accept(
-                  new SimpleTypeVisitor6<Boolean, Void>() {
-                    @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-                      return false;
-                    }
-
-                    @Override public Boolean visitDeclared(DeclaredType t, Void p) {
-                      for (TypeMirror arg : t.getTypeArguments()) {
-                        if (!arg.accept(this, null)) {
-                          return false;
+                      @Override public Boolean visitDeclared(DeclaredType t, Void p) {
+                        for (TypeMirror arg : t.getTypeArguments()) {
+                          if (!arg.accept(this, null)) {
+                            return false;
+                          }
                         }
+                        return true;
                       }
-                      return true;
-                    }
-
-                    @Override public Boolean visitArray(ArrayType t, Void p) {
-                      return t.getComponentType().accept(this, null);
-                    }
-
-                    @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                      return true;
-                    }
-                  }, null);
-              break;
-            case DECLARED:
-              declared = true;
-              break;
-            default:
-              declared = false;
+
+                      @Override public Boolean visitArray(ArrayType t, Void p) {
+                        return t.getComponentType().accept(this, null);
+                      }
+
+                      @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                        return true;
+                      }
+                    }, null);
+                break;
+              case DECLARED:
+                declared = true;
+                break;
+              default:
+                declared = false;
+            }
+            if (!declared) {
+              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                  .transform(dependencyRequestFormatter)
+                  .filter(Predicates.not(Predicates.equalTo("")))
+                  .toList()
+                  .reverse();
+              reportBuilder.addItem(
+                  String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                      arg.toString(),
+                      type.toString(),
+                      Joiner.on('\n').join(printableDependencyPath)),
+                      path.peek().request().requestElement());
+              return false;
+            }
           }
-          if (!declared) {
-            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                .transform(dependencyRequestFormatter)
-                .filter(Predicates.not(Predicates.equalTo("")))
-                .toList()
-                .reverse();
+
+          TypeElement element = MoreElements.asType(type.asElement());
+          // Also validate that the key is not the erasure of a generic type.
+          // If it is, that means the user referred to Foo<T> as just 'Foo',
+          // which we don't allow.  (This is a judgement call -- we *could*
+          // allow it and instantiate the type bounds... but we don't.)
+          if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+              && types.isSameType(types.erasure(element.asType()), type)) {
+              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                  .transform(dependencyRequestFormatter)
+                  .filter(Predicates.not(Predicates.equalTo("")))
+                  .toList()
+                  .reverse();
             reportBuilder.addItem(
-                String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                    arg.toString(),
+                String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
                     type.toString(),
                     Joiner.on('\n').join(printableDependencyPath)),
-                    path.peek().request().requestElement());
+                path.peek().request().requestElement());
             return false;
           }
-        }
 
-        TypeElement element = MoreElements.asType(type.asElement());
-        // Also validate that the key is not the erasure of a generic type.
-        // If it is, that means the user referred to Foo<T> as just 'Foo',
-        // which we don't allow.  (This is a judgement call -- we *could*
-        // allow it and instantiate the type bounds... but we don't.)
-        if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-            && types.isSameType(types.erasure(element.asType()), type)) {
-            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                .transform(dependencyRequestFormatter)
-                .filter(Predicates.not(Predicates.equalTo("")))
-                .toList()
-                .reverse();
-          reportBuilder.addItem(
-              String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                  type.toString(),
-                  Joiner.on('\n').join(printableDependencyPath)),
-              path.peek().request().requestElement());
-          return false;
+          return true; // valid
         }
+      }, null);
+    }
 
-        return true; // valid
-      }
-    }, null);
-  }
-
-  /**
-   * Validates that among the dependencies are at most one scoped dependency,
-   * that there are no cycles within the scoping chain, and that singleton
-   * components have no scoped dependencies.
-   */
-  private void validateDependencyScopes(BindingGraph subject,
-      Builder<BindingGraph> reportBuilder) {
-    ComponentDescriptor descriptor = subject.componentDescriptor();
-    Optional<AnnotationMirror> scope = subject.componentDescriptor().scope();
-    ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
-    if (scope.isPresent()) {
-      // Dagger 1.x scope compatibility requires this be suppress-able.
-      if (scopeCycleValidationType.diagnosticKind().isPresent()
-          && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
-        // Singleton is a special-case representing the longest lifetime, and therefore
-        // @Singleton components may not depend on scoped components
-        if (!scopedDependencies.isEmpty()) {
-          StringBuilder message = new StringBuilder(
-              "This @Singleton component cannot depend on scoped components:\n");
+    /**
+     * Validates that among the dependencies are at most one scoped dependency,
+     * that there are no cycles within the scoping chain, and that singleton
+     * components have no scoped dependencies.
+     */
+    private void validateDependencyScopes(BindingGraph subject) {
+      ComponentDescriptor descriptor = subject.componentDescriptor();
+      Optional<AnnotationMirror> scope = descriptor.scope();
+      ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
+      if (scope.isPresent()) {
+        // Dagger 1.x scope compatibility requires this be suppress-able.
+        if (scopeCycleValidationType.diagnosticKind().isPresent()
+            && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+          // Singleton is a special-case representing the longest lifetime, and therefore
+          // @Singleton components may not depend on scoped components
+          if (!scopedDependencies.isEmpty()) {
+            StringBuilder message = new StringBuilder(
+                "This @Singleton component cannot depend on scoped components:\n");
+            appendIndentedComponentsList(message, scopedDependencies);
+            reportBuilder.addItem(message.toString(),
+                scopeCycleValidationType.diagnosticKind().get(),
+                descriptor.componentDefinitionType(),
+                descriptor.componentAnnotation());
+          }
+        } else if (scopedDependencies.size() > 1) {
+          // Scoped components may depend on at most one scoped component.
+          StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+              .append(' ')
+              .append(descriptor.componentDefinitionType().getQualifiedName())
+              .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           reportBuilder.addItem(message.toString(),
-              scopeCycleValidationType.diagnosticKind().get(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
+        } else {
+          // Dagger 1.x scope compatibility requires this be suppress-able.
+          if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
+            validateScopeHierarchy(descriptor.componentDefinitionType(),
+                descriptor.componentDefinitionType(),
+                new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+                new ArrayDeque<TypeElement>());
+          }
         }
-      } else if (scopedDependencies.size() > 1) {
-        // Scoped components may depend on at most one scoped component.
-        StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
-            .append(' ')
-            .append(descriptor.componentDefinitionType().getQualifiedName())
-            .append(" depends on more than one scoped component:\n");
-        appendIndentedComponentsList(message, scopedDependencies);
-        reportBuilder.addItem(message.toString(),
-            descriptor.componentDefinitionType(),
-            descriptor.componentAnnotation());
       } else {
-        // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
-          validateScopeHierarchy(descriptor.componentDefinitionType(),
+        // Scopeless components may not depend on scoped components.
+        if (!scopedDependencies.isEmpty()) {
+          StringBuilder message =
+              new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
+                  .append(" (unscoped) cannot depend on scoped components:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          reportBuilder.addItem(message.toString(),
               descriptor.componentDefinitionType(),
-              reportBuilder,
-              new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
-              new ArrayDeque<TypeElement>());
+              descriptor.componentAnnotation());
+        }
+      }
+    }
+
+    private void validateBuilders(BindingGraph subject) {
+      ComponentDescriptor componentDesc = subject.componentDescriptor();
+      if (!componentDesc.builderSpec().isPresent()) {
+        // If no builder, nothing to validate.
+        return;
+      }
+
+      Set<TypeElement> allDependents = subject.componentRequirements();
+      Set<TypeElement> requiredDependents =
+          Sets.filter(allDependents, new Predicate<TypeElement>() {
+            @Override public boolean apply(TypeElement input) {
+              return !Util.componentCanMakeNewInstances(input);
+            }
+          });
+      final BuilderSpec spec = componentDesc.builderSpec().get();
+      Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+
+      ErrorMessages.ComponentBuilderMessages msgs =
+          ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
+      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+      if (!extraSetters.isEmpty()) {
+        Collection<ExecutableElement> excessMethods =
+            Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
+        Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
+            new Function<ExecutableElement, String>() {
+              @Override public String apply(ExecutableElement input) {
+                return methodSignatureFormatter.format(input,
+                    Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
+              }});
+        reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
+            spec.builderDefinitionType());
+      }
+
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+      if (!missingSetters.isEmpty()) {
+        reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
+            spec.builderDefinitionType());
+      }
+    }
+
+    /**
+     * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
+     * components are in a hierarchical relationship terminating with Singleton.
+     *
+     * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
+     * themselves, since a component's presence within its own dependency path implies a cyclical
+     * relationship between scopes.
+     */
+    private void validateScopeHierarchy(TypeElement rootComponent,
+        TypeElement componentType,
+        Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+        Deque<TypeElement> scopedDependencyStack) {
+      Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+      if (scope.isPresent()) {
+        Equivalence.Wrapper<AnnotationMirror> wrappedScope =
+            AnnotationMirrors.equivalence().wrap(scope.get());
+        if (scopeStack.contains(wrappedScope)) {
+          scopedDependencyStack.push(componentType);
+          // Current scope has already appeared in the component chain.
+          StringBuilder message = new StringBuilder();
+          message.append(rootComponent.getQualifiedName());
+          message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+          appendIndentedComponentsList(message, scopedDependencyStack);
+          if (scopeCycleValidationType.diagnosticKind().isPresent()) {
+            reportBuilder.addItem(message.toString(),
+                scopeCycleValidationType.diagnosticKind().get(),
+                rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+          }
+          scopedDependencyStack.pop();
+        } else {
+          Optional<AnnotationMirror> componentAnnotation =
+              getAnnotationMirror(componentType, Component.class);
+          if (componentAnnotation.isPresent()) {
+            ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+                MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
+            if (scopedDependencies.size() == 1) {
+              // empty can be ignored (base-case), and > 1 is a different error reported separately.
+              scopeStack.push(wrappedScope);
+              scopedDependencyStack.push(componentType);
+              validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                  scopeStack, scopedDependencyStack);
+              scopedDependencyStack.pop();
+              scopeStack.pop();
+            }
+          } // else: we skip component dependencies which are not components
         }
       }
-    } else {
-      // Scopeless components may not depend on scoped components.
-      if (!scopedDependencies.isEmpty()) {
-        StringBuilder message =
-            new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
-                .append(" (unscoped) cannot depend on scoped components:\n");
-        appendIndentedComponentsList(message, scopedDependencies);
-        reportBuilder.addItem(message.toString(),
-            descriptor.componentDefinitionType(),
-            descriptor.componentAnnotation());
+    }
+
+    /**
+     * Validates that the scope (if any) of this component are compatible with the scopes of the
+     * bindings available in this component
+     */
+    void validateComponentScope(final BindingGraph subject) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+      Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
+          subject.componentDescriptor().wrappedScope();
+      ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
+      for (ResolvedBindings bindings : resolvedBindings.values()) {
+        if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+          for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
+            if (contributionBinding instanceof ProvisionBinding) {
+              ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+              if (provisionBinding.scope().isPresent()
+                  && !componentScope.equals(provisionBinding.wrappedScope())) {
+                // Scoped components cannot reference bindings to @Provides methods or @Inject
+                // types decorated by a different scope annotation. Unscoped components cannot
+                // reference to scoped @Provides methods or @Inject types decorated by any
+                // scope annotation.
+                switch (provisionBinding.bindingKind()) {
+                  case PROVISION:
+                    ExecutableElement provisionMethod =
+                        MoreElements.asExecutable(provisionBinding.bindingElement());
+                    incompatiblyScopedMethodsBuilder.add(
+                        methodSignatureFormatter.format(provisionMethod));
+                    break;
+                  case INJECTION:
+                    incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
+                        provisionBinding.scope().get().toString()) + " class "
+                            + provisionBinding.bindingTypeElement().getQualifiedName());
+                    break;
+                  default:
+                    throw new IllegalStateException();
+                }
+              }
+            }
+          }
+        }
+      }
+      ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
+      if (!incompatiblyScopedMethods.isEmpty()) {
+        TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
+        StringBuilder message = new StringBuilder(componentType.getQualifiedName());
+        if (componentScope.isPresent()) {
+          message.append(" scoped with ");
+          message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
+          message.append(" may not reference bindings with different scopes:\n");
+        } else {
+          message.append(" (unscoped) may not reference scoped bindings:\n");
+        }
+        for (String method : incompatiblyScopedMethods) {
+          message.append(ErrorMessages.INDENT).append(method).append("\n");
+        }
+        reportBuilder.addItem(message.toString(), componentType,
+            subject.componentDescriptor().componentAnnotation());
       }
     }
-  }
 
-  private void validateBuilders(BindingGraph subject, Builder<BindingGraph> reportBuilder) {
-    ComponentDescriptor componentDesc = subject.componentDescriptor();
-    if (!componentDesc.builderSpec().isPresent()) {
-      // If no builder, nothing to validate.
-      return;
+    @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
+      StringBuilder errorMessage = new StringBuilder();
+      if (path.size() == 1) {
+        new Formatter(errorMessage).format(
+            ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+            keyFormatter.format(path.peek().request().key()));
+      } else {
+        ImmutableSet<ProvisionBinding> dependentProvisions =
+            provisionsDependingOnLatestRequest(path);
+        // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
+        // that, should we display all productions that depend on them also?
+        new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+            keyFormatter.format(dependentProvisions.iterator().next().key()));
+      }
+      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    Set<TypeElement> allDependents =
-        Sets.union(
-            Sets.union(
-                subject.transitiveModules().keySet(),
-                componentDesc.dependencies()),
-            componentDesc.executorDependency().asSet());
-    Set<TypeElement> requiredDependents =
-        Sets.filter(allDependents, new Predicate<TypeElement>() {
-          @Override public boolean apply(TypeElement input) {
-            return !Util.componentCanMakeNewInstances(input);
+    private void reportMissingBinding(Deque<ResolvedRequest> path) {
+      Key key = path.peek().request().key();
+      BindingKey bindingKey = path.peek().request().bindingKey();
+      TypeMirror type = key.type();
+      String typeName = TypeNames.forTypeMirror(type).toString();
+      boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
+      boolean requiresProvision = doesPathRequireProvisionOnly(path);
+      StringBuilder errorMessage = new StringBuilder();
+      String requiresErrorMessageFormat = requiresContributionMethod
+          ? requiresProvision
+              ? REQUIRES_PROVIDER_FORMAT
+              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
+          : requiresProvision
+              ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+              : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+      errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
+      if (key.isValidMembersInjectionKey()
+          && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
+              .isEmpty()) {
+        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+      }
+      ImmutableList<String> printableDependencyPath =
+          FluentIterable.from(path)
+              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+              .transform(dependencyRequestFormatter)
+              .filter(Predicates.not(Predicates.equalTo("")))
+              .toList()
+              .reverse();
+      for (String dependency :
+          printableDependencyPath.subList(1, printableDependencyPath.size())) {
+        errorMessage.append('\n').append(dependency);
+      }
+      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph, bindingKey)) {
+        errorMessage.append('\n').append(suggestion);
+      }
+      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+    }
+
+    private static final int DUPLICATE_SIZE_LIMIT = 10;
+
+    @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
+      ResolvedBindings resolvedBinding = path.peek().binding();
+      StringBuilder builder = new StringBuilder();
+      new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+          keyFormatter.format(path.peek().request().key()));
+      for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
+        builder.append('\n').append(INDENT);
+        // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
+        if (binding instanceof ProvisionBinding) {
+          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+        } else if (binding instanceof ProductionBinding) {
+          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
+        }
+      }
+      int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
+      if (numberOfOtherBindings > 0) {
+        builder.append('\n').append(INDENT)
+            .append("and ").append(numberOfOtherBindings).append(" other");
+      }
+      if (numberOfOtherBindings > 1) {
+        builder.append('s');
+      }
+      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
+      ResolvedBindings resolvedBinding = path.peek().binding();
+      StringBuilder builder = new StringBuilder();
+      new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+          keyFormatter.format(path.peek().request().key()));
+      ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+          ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
+      for (BindingType type :
+          Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+        builder.append(INDENT);
+        builder.append(formatBindingType(type));
+        builder.append(" bindings:\n");
+        for (ContributionBinding binding : bindingsByType.get(type)) {
+          builder.append(INDENT).append(INDENT);
+          if (binding instanceof ProvisionBinding) {
+            builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+          } else if (binding instanceof ProductionBinding) {
+            builder.append(productionBindingFormatter.format((ProductionBinding) binding));
           }
-        });
-    final BuilderSpec spec = componentDesc.builderSpec().get();
-    Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
-
-    ErrorMessages.ComponentBuilderMessages msgs =
-        ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-    Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
-    if (!extraSetters.isEmpty()) {
-      Collection<ExecutableElement> excessMethods =
-          Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
-      Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
-          new Function<ExecutableElement, String>() {
-            @Override public String apply(ExecutableElement input) {
-              return methodSignatureFormatter.format(input,
-                  Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
-            }});
-      reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
-          spec.builderDefinitionType());
+          builder.append('\n');
+        }
+      }
+      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
     }
 
-    Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
-    if (!missingSetters.isEmpty()) {
-      reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
-          spec.builderDefinitionType());
+    private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path) {
+      ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
+          .add(request)
+          .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
+          .build();
+      ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
+          .transform(dependencyRequestFormatter)
+          .filter(Predicates.not(Predicates.equalTo("")))
+          .toList()
+          .reverse();
+      DependencyRequest rootRequest = path.getLast().request();
+      TypeElement componentType =
+          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+      // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
+      reportBuilder.addItem(
+          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+              componentType.getQualifiedName(),
+              rootRequest.requestElement().getSimpleName(),
+              Joiner.on("\n")
+                  .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+          rootRequest.requestElement());
     }
   }
 
+  @Override
+  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+    Validation validation = new Validation(subject);
+    validation.validateSubgraph(subject);
+    return validation.buildReport();
+  }
+
   /**
    * Append and format a list of indented component types (with their scope annotations)
    */
@@ -524,169 +757,6 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
     }).toSet();
   }
 
-  /**
-   * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
-   * components are in a hierarchical relationship terminating with Singleton.
-   *
-   * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
-   * themselves, since a component's presence within its own dependency path implies a cyclical
-   * relationship between scopes.
-   */
-  private void validateScopeHierarchy(TypeElement rootComponent,
-      TypeElement componentType,
-      Builder<BindingGraph> reportBuilder,
-      Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
-      Deque<TypeElement> scopedDependencyStack) {
-    Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
-    if (scope.isPresent()) {
-      Equivalence.Wrapper<AnnotationMirror> wrappedScope =
-          AnnotationMirrors.equivalence().wrap(scope.get());
-      if (scopeStack.contains(wrappedScope)) {
-        scopedDependencyStack.push(componentType);
-        // Current scope has already appeared in the component chain.
-        StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
-        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
-        appendIndentedComponentsList(message, scopedDependencyStack);
-        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
-          reportBuilder.addItem(message.toString(),
-              scopeCycleValidationType.diagnosticKind().get(),
-              rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
-        }
-        scopedDependencyStack.pop();
-      } else {
-        Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
-        if (componentAnnotation.isPresent()) {
-          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
-          if (scopedDependencies.size() == 1) {
-            // empty can be ignored (base-case), and > 1 is a different error reported separately.
-            scopeStack.push(wrappedScope);
-            scopedDependencyStack.push(componentType);
-            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                reportBuilder, scopeStack, scopedDependencyStack);
-            scopedDependencyStack.pop();
-            scopeStack.pop();
-          }
-        } // else: we skip component dependencies which are not components
-      }
-    }
-  }
-
-  /**
-   * Validates that the scope (if any) of this component are compatible with the scopes of the
-   * bindings available in this component
-   */
-  void validateComponentScope(final BindingGraph subject,
-      final ValidationReport.Builder<BindingGraph> reportBuilder,
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings) {
-    Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
-        subject.componentDescriptor().wrappedScope();
-    ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
-    for (ResolvedBindings bindings : resolvedBindings.values()) {
-      if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-          if (contributionBinding instanceof ProvisionBinding) {
-            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-            if (provisionBinding.scope().isPresent()
-                && !componentScope.equals(provisionBinding.wrappedScope())) {
-              // Scoped components cannot reference bindings to @Provides methods or @Inject
-              // types decorated by a different scope annotation. Unscoped components cannot
-              // reference to scoped @Provides methods or @Inject types decorated by any
-              // scope annotation.
-              switch (provisionBinding.bindingKind()) {
-                case PROVISION:
-                  ExecutableElement provisionMethod =
-                      MoreElements.asExecutable(provisionBinding.bindingElement());
-                  incompatiblyScopedMethodsBuilder.add(
-                      methodSignatureFormatter.format(provisionMethod));
-                  break;
-                case INJECTION:
-                  incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
-                      provisionBinding.scope().get().toString()) + " class "
-                          + provisionBinding.bindingTypeElement().getQualifiedName());
-                  break;
-                default:
-                  throw new IllegalStateException();
-              }
-            }
-          }
-        }
-      }
-    }
-    ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
-    if (!incompatiblyScopedMethods.isEmpty()) {
-      TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
-      StringBuilder message = new StringBuilder(componentType.getQualifiedName());
-      if (componentScope.isPresent()) {
-        message.append(" scoped with ");
-        message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
-        message.append(" may not reference bindings with different scopes:\n");
-      } else {
-        message.append(" (unscoped) may not reference scoped bindings:\n");
-      }
-      for (String method : incompatiblyScopedMethods) {
-        message.append(ErrorMessages.INDENT).append(method).append("\n");
-      }
-      reportBuilder.addItem(message.toString(), componentType,
-          subject.componentDescriptor().componentAnnotation());
-    }
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportProviderMayNotDependOnProducer(
-      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
-    StringBuilder errorMessage = new StringBuilder();
-    if (path.size() == 1) {
-      new Formatter(errorMessage).format(
-          ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
-    } else {
-      ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
-      // TODO(user): Consider displaying all dependent provisions in the error message. If we do
-      // that, should we display all productions that depend on them also?
-      new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-          keyFormatter.format(dependentProvisions.iterator().next().key()));
-    }
-    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
-  }
-
-  private void reportMissingBinding(
-      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
-    Key key = path.peek().request().key();
-    TypeMirror type = key.type();
-    String typeName = TypeNames.forTypeMirror(type).toString();
-    boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
-    boolean requiresProvision = doesPathRequireProvisionOnly(path);
-    StringBuilder errorMessage = new StringBuilder();
-    String requiresErrorMessageFormat = requiresContributionMethod
-        ? requiresProvision
-            ? REQUIRES_PROVIDER_FORMAT
-            : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
-        : requiresProvision
-            ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-            : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-    errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
-    if (key.isValidMembersInjectionKey()
-        && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
-            .isEmpty()) {
-      errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
-    }
-    ImmutableList<String> printableDependencyPath =
-        FluentIterable.from(path)
-            .transform(REQUEST_FROM_RESOLVED_REQUEST)
-            .transform(dependencyRequestFormatter)
-            .filter(Predicates.not(Predicates.equalTo("")))
-            .toList()
-            .reverse();
-    for (String dependency :
-        printableDependencyPath.subList(1, printableDependencyPath.size())) {
-      errorMessage.append("\n").append(dependency);
-    }
-    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
-  }
-
   /**
    * Returns whether the given dependency path would require the most recent request to be resolved
    * by only provision bindings.
@@ -735,62 +805,6 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     return bindings;
   }
 
-  private static final int DUPLICATE_SIZE_LIMIT = 10;
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportDuplicateBindings(
-      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ResolvedBindings resolvedBinding = path.peek().binding();
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-        keyFormatter.format(path.peek().request().key()));
-    for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
-      builder.append('\n').append(INDENT);
-      // TODO(user): Refactor the formatters so we don't need these instanceof checks.
-      if (binding instanceof ProvisionBinding) {
-        builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-      } else if (binding instanceof ProductionBinding) {
-        builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-      }
-    }
-    int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
-    if (numberOfOtherBindings > 0) {
-      builder.append('\n').append(INDENT)
-          .append("and ").append(numberOfOtherBindings).append(" other");
-    }
-    if (numberOfOtherBindings > 1) {
-      builder.append('s');
-    }
-    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportMultipleBindingTypes(
-      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ResolvedBindings resolvedBinding = path.peek().binding();
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-        keyFormatter.format(path.peek().request().key()));
-    ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-        ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
-    for (BindingType type :
-        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
-      builder.append(INDENT);
-      builder.append(formatBindingType(type));
-      builder.append(" bindings:\n");
-      for (ContributionBinding binding : bindingsByType.get(type)) {
-        builder.append(INDENT).append(INDENT);
-        if (binding instanceof ProvisionBinding) {
-          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-        } else if (binding instanceof ProductionBinding) {
-          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-        }
-        builder.append('\n');
-      }
-    }
-    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
-  }
-
   private String formatBindingType(BindingType type) {
     switch(type) {
       case MAP:
@@ -804,30 +818,6 @@ private String formatBindingType(BindingType type) {
     }
   }
 
-  private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path,
-      final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
-        .add(request)
-        .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
-        .build();
-    ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
-        .transform(dependencyRequestFormatter)
-        .filter(Predicates.not(Predicates.equalTo("")))
-        .toList()
-        .reverse();
-    DependencyRequest rootRequest = path.getLast().request();
-    TypeElement componentType =
-        MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-    // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
-    reportBuilder.addItem(
-        String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-            componentType.getQualifiedName(),
-            rootRequest.requestElement().getSimpleName(),
-            Joiner.on("\n")
-                .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
-        rootRequest.requestElement());
-  }
-
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 6c514f99c..906be8a57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -31,8 +31,10 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -51,6 +53,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
@@ -84,7 +87,7 @@
     Class<? extends Annotation> annotationType() {
       return annotationType;
     }
-    
+
     Class<? extends Annotation> builderAnnotationType() {
       return builderType;
     }
@@ -105,6 +108,26 @@
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  abstract ImmutableSet<ModuleDescriptor> modules();
+
+  ImmutableSet<ModuleDescriptor> transitiveModules() {
+    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
+    for (ModuleDescriptor module : modules()) {
+      addTransitiveModules(transitiveModules, module);
+    }
+    return ImmutableSet.copyOf(transitiveModules);
+  }
+
+  private static Set<ModuleDescriptor> addTransitiveModules(
+      Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
+    if (transitiveModules.add(module)) {
+      for (ModuleDescriptor includedModule : module.includedModules()) {
+        addTransitiveModules(transitiveModules, includedModule);
+      }
+    }
+    return transitiveModules;
+  }
+
   /**
    * An index of the type to which this component holds a reference (the type listed in
    * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the
@@ -153,9 +176,9 @@
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
   }
-  
+
   @AutoValue
-  static abstract class BuilderSpec {    
+  static abstract class BuilderSpec {
     abstract TypeElement builderDefinitionType();
     abstract Map<TypeElement, ExecutableElement> methodMap();
     abstract ExecutableElement buildMethod();
@@ -166,11 +189,17 @@
     private final Elements elements;
     private final Types types;
     private final DependencyRequest.Factory dependencyRequestFactory;
+    private final ModuleDescriptor.Factory moduleDescriptorFactory;
 
-    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(
+        Elements elements,
+        Types types,
+        DependencyRequest.Factory dependencyRequestFactory,
+        ModuleDescriptor.Factory moduleDescriptorFactory) {
       this.elements = elements;
       this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.moduleDescriptorFactory = moduleDescriptorFactory;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -210,6 +239,11 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
               ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
               : Optional.<TypeElement>absent();
 
+      ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
+      for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
+        modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
+      }
+
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
 
@@ -237,14 +271,14 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
             break;
           default: // nothing special to do for other methods.
         }
-        
+
       }
-      
+
       ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
           ? ImmutableList.<DeclaredType>of()
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
-          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));        
+          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
@@ -252,6 +286,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
+          modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 3886ba1d8..1584945ae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -34,10 +33,8 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.google.common.collect.Sets.SetView;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
-import dagger.MapKey;
 import dagger.MembersInjector;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
@@ -67,7 +64,6 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -75,9 +71,6 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -89,7 +82,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -97,9 +89,10 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
@@ -108,6 +101,8 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.getKeyTypeOfMap;
+import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -218,17 +213,8 @@ Snippet getSnippetFor(ClassName usingClass) {
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
-    switch (componentDefinitionType.getKind()) {
-      case CLASS:
-        checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
-        componentWriter.setSuperType(componentDefinitionTypeName);
-        break;
-      case INTERFACE:
-        componentWriter.addImplementedType(componentDefinitionTypeName);
-        break;
-      default:
-        throw new IllegalStateException();
-    }
+    checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
+    componentWriter.setSupertype(componentDefinitionType);
 
     Set<JavaWriter> javaWriters = Sets.newHashSet();
     javaWriters.add(writer);
@@ -278,17 +264,7 @@ private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
     builderWriter.addConstructor().addModifiers(PRIVATE);
     if (builderSpec.isPresent()) {
       builderWriter.addModifiers(PRIVATE);
-      TypeElement builderType = builderSpec.get().builderDefinitionType();
-      switch (builderType.getKind()) {
-        case CLASS:
-          builderWriter.setSuperType(builderType);
-          break;
-        case INTERFACE:
-          builderWriter.addImplementedType(builderType);
-          break;
-        default:
-          throw new IllegalStateException("not a class or interface: " + builderType);
-      }
+      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
     } else {
       builderWriter.addModifiers(PUBLIC);
     }
@@ -296,11 +272,7 @@ private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(
-                Sets.union(
-                    input.transitiveModules().keySet(),
-                    input.componentDescriptor().dependencies()),
-                input.componentDescriptor().executorDependency().asSet()),
+            input.componentRequirements(),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -385,14 +357,8 @@ private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
 
   /** Returns true if the graph has any dependents that can't be automatically constructed. */
   private boolean requiresUserSuppliedDependents(BindingGraph input) {
-    Set<TypeElement> allDependents =
-        Sets.union(
-            Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
-            input.componentDescriptor().executorDependency().asSet());
     Set<TypeElement> userRequiredDependents =
-        Sets.filter(allDependents, new Predicate<TypeElement>() {
+        Sets.filter(input.componentRequirements(), new Predicate<TypeElement>() {
           @Override public boolean apply(TypeElement input) {
             return !Util.componentCanMakeNewInstances(input);
           }
@@ -426,7 +392,6 @@ private boolean requiresUserSuppliedDependents(BindingGraph input) {
         componentWriter,
         proxyWriters,
         memberSelectSnippetsBuilder,
-        ImmutableMap.<ContributionBinding, Snippet>of(),
         multibindingContributionSnippetsBuilder,
         enumBindingKeysBuilder,
         packageProxies);
@@ -519,19 +484,9 @@ private void writeSubcomponent(ClassWriter componentWriter,
     componentMethod.addModifiers(PUBLIC);
     componentMethod.annotate(Override.class);
 
-    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
-    Element subcomponentElement = MoreTypes.asElement(subcomponentType);
-    switch (subcomponentElement.getKind()) {
-      case CLASS:
-        checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
-        subcomponentWriter.setSuperType(subcomponentTypeName);
-        break;
-      case INTERFACE:
-        subcomponentWriter.addImplementedType(subcomponentTypeName);
-        break;
-      default:
-        throw new IllegalStateException();
-    }
+    TypeElement subcomponentElement = MoreTypes.asTypeElement(subcomponentType);
+    checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
+    subcomponentWriter.setSupertype(subcomponentElement);
 
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
@@ -544,7 +499,6 @@ private void writeSubcomponent(ClassWriter componentWriter,
         subcomponentWriter,
         proxyWriters,
         memberSelectSnippetsBuilder,
-        parentMultibindingContributionSnippets,
         multibindingContributionSnippetsBuilder,
         enumBindingKeysBuilder,
         packageProxies);
@@ -601,7 +555,6 @@ private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFacto
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
       TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
-      verify(subgraph.transitiveModules().containsKey(moduleTypeElement));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
       if (!componentContributionFields.containsKey(moduleTypeElement)) {
         String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
@@ -625,8 +578,12 @@ private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFacto
       }
     }
 
-    SetView<TypeElement> uninitializedModules = Sets.difference(
-        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    ImmutableSet<TypeElement> uninitializedModules =
+        FluentIterable.from(subgraph.componentDescriptor().transitiveModules())
+            .transform(ModuleDescriptor.getModuleElement())
+            .filter(Predicates.not(Predicates.in(componentContributionFields.keySet())))
+            .toSet();
+
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
           moduleType.getSimpleName().toString());
@@ -651,7 +608,6 @@ private void writeFields(BindingGraph input,
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
       Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
       Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
       ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
       Map<String, ProxyClassAndField> packageProxies) {
@@ -660,7 +616,6 @@ private void writeFields(BindingGraph input,
           componentWriter,
           proxyWriters,
           memberSelectSnippetsBuilder,
-          parentMultibindingContributionSnippetsBuilder,
           multibindingContributionSnippetsBuilder,
           enumBindingKeysBuilder,
           packageProxies,
@@ -672,7 +627,6 @@ private void writeField(
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
       Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
       Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
       ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
       Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
@@ -772,7 +726,7 @@ private void writeField(
         for (ContributionBinding contributionBinding : contributionBindings) {
           if (!contributionBinding.isSyntheticBinding()) {
             contributionNumber++;
-            if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+            if (resolvedBindings.ownedBindings().contains(contributionBinding)) {
               FrameworkField contributionBindingField =
                   frameworkFieldForSyntheticContributionBinding(
                         bindingKey, contributionNumber, contributionBinding);
@@ -959,7 +913,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                   ImmutableSet<ProvisionBinding> provisionBindings =
                       (ImmutableSet<ProvisionBinding>) bindings;
                   for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding)
+                    if (!isNonProviderMap(provisionBinding.key().type())
                         && multibindingContributionSnippets.containsKey(provisionBinding)) {
                       Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
                       initializeMethod.body().addSnippet("this.%s = %s;",
@@ -1370,137 +1324,44 @@ private Snippet initializeMapBinding(
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
       Set<ProvisionBinding> bindings) {
-    Iterator<ProvisionBinding> iterator = bindings.iterator();
-    // get type information from first binding in iterator
-    ProvisionBinding firstBinding = iterator.next();
-    if (isNonProviderMap(firstBinding)) {
-      return Snippet.format("%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(
-              Iterables.getOnlyElement(firstBinding.dependencies()).bindingKey())
-                  .getSnippetFor(componentName));
-    } else {
-      DeclaredType mapType = asDeclared(firstBinding.key().type());
-      TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
-      TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
-      StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
-      for (int i = 0; i < bindings.size(); i++) {
-        snippetFormatBuilder.append("\n    .put(%s, %s)");
-      }
-      snippetFormatBuilder.append("\n    .build()");
-
-      List<Object> argsBuilder = Lists.newArrayList();
-      argsBuilder.add(ClassName.fromClass(MapProviderFactory.class));
-      argsBuilder.add(TypeNames.forTypeMirror(mapKeyType));
-      argsBuilder.add(TypeNames.forTypeMirror(mapValueType));
-      argsBuilder.add(bindings.size());
-
-      writeEntry(argsBuilder, firstBinding, multibindingContributionSnippets.get(firstBinding));
-      while (iterator.hasNext()) {
-        ProvisionBinding binding = iterator.next();
-        writeEntry(argsBuilder, binding, multibindingContributionSnippets.get(binding));
-      }
+    // Get type information from the first binding.
+    ProvisionBinding firstBinding = bindings.iterator().next();
+    DeclaredType mapType = asDeclared(firstBinding.key().type());
 
-      return Snippet.format(snippetFormatBuilder.toString(),
-          argsBuilder.toArray(new Object[0]));
+    if (isNonProviderMap(mapType)) {
+      return Snippet.format(
+          "%s.create(%s)",
+          ClassName.fromClass(MapFactory.class),
+          memberSelectSnippets
+              .get(getOnlyElement(firstBinding.dependencies()).bindingKey())
+              .getSnippetFor(componentName));
     }
-  }
 
-  // add one map entry for map Provider in Constructor
-  private void writeEntry(List<Object> argsBuilder, Binding binding,
-      Snippet factory) {
-    AnnotationMirror mapKeyAnnotationMirror =
-        Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
-    Map<? extends ExecutableElement, ? extends AnnotationValue> map =
-        mapKeyAnnotationMirror.getElementValues();
-    MapKey mapKey =
-        mapKeyAnnotationMirror.getAnnotationType().asElement().getAnnotation(MapKey.class);
-    if (!mapKey.unwrapValue()) {// wrapped key case
-      FluentIterable<AnnotationValue> originIterable = FluentIterable.from(
-          AnnotationMirrors.getAnnotationValuesWithDefaults(mapKeyAnnotationMirror).values());
-      FluentIterable<Snippet> annotationValueNames =
-          originIterable.transform(new Function<AnnotationValue, Snippet>() {
-            @Override
-            public Snippet apply(AnnotationValue value) {
-              return getValueSnippet(value);
-            }
-          });
-      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-      for (Snippet snippet : annotationValueNames) {
-        snippets.add(snippet);
-      }
-      argsBuilder.add(Snippet.format("%s.create(%s)",
-          Util.getMapKeyCreatorClassName(
-              MoreTypes.asTypeElement(mapKeyAnnotationMirror.getAnnotationType())),
-          Snippet.makeParametersSnippet(snippets.build())));
-      argsBuilder.add(factory);
-    } else { // unwrapped key case
-      argsBuilder.add(Iterables.getOnlyElement(map.entrySet()).getValue());
-      argsBuilder.add(factory);
+    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
+        ImmutableList.builder();
+    snippets.add(
+        Snippet.format(
+            "%s.<%s, %s>builder(%d)",
+            ClassName.fromClass(MapProviderFactory.class),
+            TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
+            TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
+            bindings.size()));
+
+    for (ProvisionBinding binding : bindings) {
+      snippets.add(
+          Snippet.format(
+              "    .put(%s, %s)",
+              getMapKeySnippet(binding.bindingElement()),
+              multibindingContributionSnippets.get(binding)));
     }
-  }
 
-  // Get the Snippet representation of a Annotation Value
-  // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
-  private Snippet getValueSnippet(AnnotationValue value) {
-    AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
-        new SimpleAnnotationValueVisitor6<Snippet, Void>() {
-          @Override
-          public Snippet visitEnumConstant(VariableElement c, Void p) {
-            return Snippet.format("%s.%s",
-                TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
-          }
-
-          @Override
-          public Snippet visitAnnotation(AnnotationMirror a, Void p) {
-            if (a.getElementValues().isEmpty()) {
-              return Snippet.format("@%s", TypeNames.forTypeMirror(a.getAnnotationType()));
-            } else {
-              Map<ExecutableElement, AnnotationValue> map =
-                  AnnotationMirrors.getAnnotationValuesWithDefaults(a);
-              // build "@Annotation(a = , b = , c = ))
-              ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-              for (Entry<ExecutableElement, AnnotationValue> entry : map.entrySet()) {
-                snippets.add(Snippet.format("%s = %s",
-                    TypeNames.forTypeMirror(entry.getKey().asType()),
-                    getValueSnippet(entry.getValue())));
+    snippets.add(Snippet.format("    .build()"));
 
-              }
-              return Snippet.format("@%s(%s)", TypeNames.forTypeMirror(a.getAnnotationType()),
-                  Snippet.makeParametersSnippet(snippets.build()));
-            }
-          }
-
-          @Override
-          public Snippet visitType(TypeMirror t, Void p) {
-            return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
-          }
-
-          @Override
-          public Snippet visitString(String s, Void p) {
-            return Snippet.format("\"%s\"", s);
-          }
-
-          @Override
-          protected Snippet defaultAction(Object o, Void v) {
-            return Snippet.format("%s", o);
-          }
-
-          @Override
-          public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
-            ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-            for (int i = 0; i < values.size(); i++) {
-              snippets.add(values.get(i).accept(this, null));
-            }
-            return Snippet.format("[%s]", Snippet.makeParametersSnippet(snippets.build()));
-          }
-        };
-    return value.accept(mapKeyVisitor, null);
+    return Snippet.join(Joiner.on('\n'), snippets.build());
   }
 
-  private boolean isNonProviderMap(Binding binding) {
-    TypeMirror bindingType = binding.key().type();
-    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
+  private boolean isNonProviderMap(TypeMirror type) {
+    return MoreTypes.isTypeOf(Map.class, type) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index a7f486897..18636fe18 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -37,16 +37,13 @@
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep implements ProcessingStep {
+final class ComponentProcessingStep extends AbstractComponentProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator componentBuilderValidator;
   private final BuilderValidator subcomponentBuilderValidator;
-  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
 
   ComponentProcessingStep(
       Messager messager,
@@ -58,15 +55,17 @@
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
+    super(
+        messager,
+        bindingGraphValidator,
+        bindingGraphFactory,
+        componentGenerator);
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
     this.componentBuilderValidator = componentBuilderValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
   }
 
   @Override
@@ -76,19 +75,34 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
         processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
-    Set<? extends Element> subcomponentBuilderElements =
-        elementsByAnnotation.get(Subcomponent.Builder.class);
+    Set<Element> subcomponentBuilderElements = elementsByAnnotation.get(Subcomponent.Builder.class);
     Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
         processSubcomponentBuilders(subcomponentBuilderElements);
-    Set<? extends Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+    Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-    Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
-    processComponents(componentElements, builderReportsByComponent, subcomponentElements,
-        reportsBySubcomponent, subcomponentBuilderElements, builderReportsBySubcomponent);
+    Set<Element> componentElements = elementsByAnnotation.get(Component.class);
+
+    ImmutableSet.Builder<ComponentDescriptor> builder = ImmutableSet.builder();
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ComponentValidationReport report = componentValidator.validate(
+          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      if (isClean(
+          report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
+        try {
+          builder.add(componentDescriptorFactory.forComponent(componentTypeElement));
+        } catch (TypeNotPresentException e) {
+          // just skip it and get it later
+        }
+      }
+    }
+    return builder.build();
   }
 
   private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
@@ -128,37 +142,6 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
     return reportsBySubcomponent;
   }
 
-  private void processComponents(
-      Set<? extends Element> componentElements,
-      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
-      Set<? extends Element> subcomponentElements,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Set<? extends Element> subcomponentBuilderElements,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ComponentValidationReport report = componentValidator.validate(
-          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      if (isClean(report, builderReportsByComponent, reportsBySubcomponent,
-          builderReportsBySubcomponent)) {
-        ComponentDescriptor componentDescriptor =
-            componentDescriptorFactory.forComponent(componentTypeElement);
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<BindingGraph> graphReport =
-            bindingGraphValidator.validate(bindingGraph);
-        graphReport.printMessagesTo(messager);
-        if (graphReport.isClean()) {
-          try {
-            componentGenerator.generate(bindingGraph);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
-          }
-        }
-      }
-    }
-  }
-
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
    * referenced subcomponent reports & subcomponent builder reports are clean.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 1214684ec..3152c3fd1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -59,7 +59,10 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY, NULLABLE_VALIDATION_KEY);
+    return ImmutableSet.of(
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        NULLABLE_VALIDATION_KEY
+    );
   }
 
   @Override
@@ -123,12 +126,19 @@ public SourceVersion getSupportedSourceVersion() {
     this.injectBindingRegistry = new InjectBindingRegistry(
         elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
 
-    ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
+    ModuleDescriptor.Factory moduleDescriptorFactory = new ModuleDescriptor.Factory(
+        elements, provisionBindingFactory, productionBindingFactory);
+
+    ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
+        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements, types, injectBindingRegistry, keyFactory,
-        dependencyRequestFactory, provisionBindingFactory, productionBindingFactory);
+        elements,
+        injectBindingRegistry,
+        keyFactory,
+        dependencyRequestFactory,
+        provisionBindingFactory,
+        productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
@@ -145,6 +155,7 @@ public SourceVersion getSupportedSourceVersion() {
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
+            types,
             mapKeyValidator,
             mapKeyGenerator),
         new InjectProcessingStep(
@@ -199,29 +210,28 @@ protected void postProcess() {
   private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
       "dagger.disableInterComponentScopeValidation";
 
-  private static final String NULLABLE_VALIDATION_KEY =
-      "dagger.nullableValidation";
+  private static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
 
   private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
-    return validationTypeFor(processingEnv,
+    return valueOf(processingEnv,
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
         ValidationType.ERROR,
         EnumSet.allOf(ValidationType.class));
   }
 
   private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
-    return validationTypeFor(processingEnv,
+    return valueOf(processingEnv,
         NULLABLE_VALIDATION_KEY,
         ValidationType.ERROR,
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
-  private static ValidationType validationTypeFor(ProcessingEnvironment processingEnv, String key,
-      ValidationType defaultValue, Set<ValidationType> validValues) {
+  private static <T extends Enum<T>> T valueOf(ProcessingEnvironment processingEnv, String key,
+      T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
     if (options.containsKey(key)) {
       try {
-        ValidationType type = ValidationType.valueOf(options.get(key).toUpperCase());
+        T type = Enum.valueOf(defaultValue.getDeclaringClass(), options.get(key).toUpperCase());
         if (!validValues.contains(type)) {
           throw new IllegalArgumentException(); // let handler below print out good msg.
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 469b37591..a2a5eac22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -72,7 +72,7 @@
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
-  
+
   private ComponentValidator(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -97,7 +97,7 @@ private ComponentValidator(Elements elements,
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
-  
+
   static ComponentValidator createForComponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -109,7 +109,7 @@ static ComponentValidator createForComponent(Elements elements,
         subcomponentValidator,
         subcomponentBuilderValidator);
   }
-  
+
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -119,7 +119,7 @@ static ComponentValidator createForSubcomponent(Elements elements,
         moduleValidator,
         subcomponentBuilderValidator);
   }
-  
+
   @AutoValue
   static abstract class ComponentValidationReport {
     abstract Set<Element> referencedSubcomponents();
@@ -140,7 +140,7 @@ public ComponentValidationReport validate(final TypeElement subject,
       builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
           componentType.annotationType().getSimpleName()), subject);
     }
-    
+
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
@@ -148,7 +148,7 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
           subject);
     }
-    
+
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
     // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
@@ -212,7 +212,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         }
       }
     }
-    
+
     for (Map.Entry<Element, Collection<ExecutableElement>> entry :
         referencedSubcomponents.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
@@ -228,7 +228,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         getAnnotationMirror(subject, componentType.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
-    
+
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
     // TODO(sameb): If subcomponents refer to each other and both aren't in
@@ -243,7 +243,7 @@ public ComponentValidationReport validate(final TypeElement subject,
       builder.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
-    
+
     return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
         builder.build());
   }
@@ -257,6 +257,9 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     ImmutableSet<TypeElement> moduleTypes =
         MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
 
+    // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
+    // subcomponents and their modules separately from how it is done in ComponentDescriptor and
+    // ModuleDescriptor
     ImmutableSet<TypeElement> transitiveModules =
         getTransitiveModules(types, elements, moduleTypes);
 
@@ -334,7 +337,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
       builder.addItem(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
-    
+
     // If we haven't already validated the subcomponent builder itself, validate it now.
     TypeElement builderElement = MoreTypes.asTypeElement(returnType);
     if (!validatedSubcomponentBuilders.contains(builderElement)) {
@@ -345,7 +348,6 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  
   private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
       final Class<? extends Annotation> annotation) {
     return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 176755d3f..50e343543 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
@@ -23,20 +22,21 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Queues;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.ArrayDeque;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -44,6 +44,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -92,10 +93,6 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
-  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
-    return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
-  }
-
   /** Returns the first type that specifies this' nullability, or absent if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
@@ -107,27 +104,67 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     return Optional.absent();
   }
 
+  /**
+   * Extracts the list of types that is the value of the annotation member {@code elementName} of
+   * {@code annotationMirror}.
+   *
+   * @throws IllegalArgumentException if no such member exists on {@code annotationMirror}, or it
+   *     exists but is not an array
+   * @throws TypeNotPresentException if any of the values cannot be converted to a type
+   */
   static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
-      AnnotationMirror annotationMirror, final String elementName) {
-    @SuppressWarnings("unchecked") // that's the whole point of this method
-    List<? extends AnnotationValue> listValue = (List<? extends AnnotationValue>)
-        getAnnotationValue(annotationMirror, elementName).getValue();
-    return FluentIterable.from(listValue).transform(new Function<AnnotationValue, TypeMirror>() {
-      @Override public TypeMirror apply(AnnotationValue typeValue) {
-        return (TypeMirror) typeValue.getValue();
-      }
-    }).toList();
+      AnnotationMirror annotationMirror, String elementName) {
+    return TO_LIST_OF_TYPES.visit(getAnnotationValue(annotationMirror, elementName), elementName);
   }
 
+  private static final AnnotationValueVisitor<ImmutableList<TypeMirror>, String> TO_LIST_OF_TYPES =
+      new SimpleAnnotationValueVisitor6<ImmutableList<TypeMirror>, String>() {
+        @Override
+        public ImmutableList<TypeMirror> visitArray(
+            List<? extends AnnotationValue> vals, String elementName) {
+          return FluentIterable.from(vals)
+              .transform(
+                  new Function<AnnotationValue, TypeMirror>() {
+                    @Override
+                    public TypeMirror apply(AnnotationValue typeValue) {
+                      return TO_TYPE.visit(typeValue);
+                    }
+                  })
+              .toList();
+        }
+
+        @Override
+        protected ImmutableList<TypeMirror> defaultAction(Object o, String elementName) {
+          throw new IllegalArgumentException(elementName + " is not an array: " + o);
+        }
+      };
+
+  private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
+      new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
+        @Override
+        public TypeMirror visitType(TypeMirror t, Void p) {
+          return t;
+        }
+
+        @Override
+        protected TypeMirror defaultAction(Object o, Void p) {
+          throw new TypeNotPresentException(o.toString(), null);
+        }
+      };
+
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
+   *
+   * @deprecated Use {@link ComponentDescriptor#transitiveModules}.
    */
+  @Deprecated
   static ImmutableSet<TypeElement> getTransitiveModules(
       Types types, Elements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
-    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+    Queue<TypeElement> moduleQueue = new ArrayDeque<>();
+    Iterables.addAll(moduleQueue, seedModules);
     Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
@@ -153,7 +190,7 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     }
     return ImmutableSet.copyOf(moduleElements);
   }
-  
+
   /** Returns the enclosed elements annotated with the given annotation type. */
   static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
       final Class<? extends Annotation> annotation) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 2fbb507c2..7097b9991 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -107,6 +107,12 @@ BindingKey bindingKey() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
+  /**
+   * Factory for {@link DependencyRequest}s.
+   *
+   * <p>Any factory method may throw {@link TypeNotPresentException} if a type is not available,
+   * which may mean that the type will be generated in a later round of processing.
+   */
   static final class Factory {
     private final Key.Factory keyFactory;
 
@@ -260,9 +266,16 @@ private DependencyRequest newDependencyRequest(Element requestElement,
 
     /**
      * Extracts the correct requesting type & kind out a request type. For example, if a user
-     * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
+     * requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER}, {@code Foo}).
+     *
+     * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
+     *     mean that the type will be generated in a later round of processing
      */
     static KindAndType extractKindAndType(TypeMirror type) {
+      if (type.getKind().equals(TypeKind.ERROR)) {
+        throw new TypeNotPresentException(type.toString(), null);
+      }
+
       // We must check TYPEVAR explicitly before the below checks because calling
       // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
       // represented as a Class).
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 5e5e57478..12da8deae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -142,7 +142,7 @@
       "Modules with type parameters must be abstract";
 
   static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
-      "%s is listed as a module, but is abstract";
+      "%s is listed as a module, but is an abstract class or interface";
 
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
       "%s is listed as a module, but is not annotated with @%s";
@@ -160,8 +160,14 @@
       "Cannot use more than one @Qualifier on a @Provides or @Produces method";
 
   /* mapKey errors*/
-  static final String MAPKEY_WITHOUT_FIELDS =
-      "Map key annotation does not have fields";
+  static final String MAPKEY_WITHOUT_MEMBERS =
+      "Map key annotations must have members";
+
+  static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS=
+      "Map key annotations with unwrapped values must have exactly one member";
+
+  static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER =
+      "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
   static final String MULTIPLE_BINDING_TYPES_FORMAT =
@@ -211,7 +217,7 @@
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
-  
+
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -227,101 +233,101 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
     protected String process(String s) { return s; }
-    
+
     /** Errors for component builders. */
     final String moreThanOne() {
       return process("@Component has more than one @Component.Builder: %s");
     }
-    
+
     final String cxtorOnlyOneAndNoArgs() {
       return process("@Component.Builder classes must have exactly one constructor,"
           + " and it must not have any parameters");
     }
-    
+
     final String generics() {
       return process("@Component.Builder types must not have any generic types");
     }
-    
+
     final String mustBeInComponent() {
       return process("@Component.Builder types must be nested within a @Component");
     }
-    
+
     final String mustBeClassOrInterface() {
       return process("@Component.Builder types must be abstract classes or interfaces");
     }
-    
+
     final String isPrivate() {
       return process("@Component.Builder types must not be private");
     }
-    
+
     final String mustBeStatic() {
       return process("@Component.Builder types must be static");
     }
-    
+
     final String mustBeAbstract() {
       return process("@Component.Builder types must be abstract");
     }
-    
+
     final String missingBuildMethod() {
       return process("@Component.Builder types must have exactly one no-args method that "
           + " returns the @Component type");
     }
-    
+
     final String manyMethodsForType() {
       return process("@Component.Builder types must not have more than one setter method per type,"
           + " but %s is set by %s");
     }
-    
+
     final String extraSetters() {
       return process(
           "@Component.Builder has setters for modules or components that aren't required: %s");
     }
-    
+
     final String missingSetters() {
       return process(
           "@Component.Builder is missing setters for required modules or components: %s");
     }
-    
+
     final String twoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
           + " method must return the @Component type. Already found: %s");
     }
-    
+
     final String inheritedTwoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
           + " method must return the @Component type. Found %s and %s");
     }
-    
+
     final String buildMustReturnComponentType() {
       return process(
           "@Component.Builder methods that have no arguments must return the @Component type");
     }
-    
+
     final String inheritedBuildMustReturnComponentType() {
       return process(
           "@Component.Builder methods that have no arguments must return the @Component type"
           + " Inherited method: %s");
     }
-    
+
     final String methodsMustTakeOneArg() {
       return process("@Component.Builder methods must not have more than one argument");
     }
-    
+
     final String inheritedMethodsMustTakeOneArg() {
       return process(
           "@Component.Builder methods must not have more than one argument. Inherited method: %s");
     }
-    
+
     final String methodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + " or a supertype of the builder");
     }
-    
+
     final String inheritedMethodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + "or a supertype of the builder. Inherited method: %s");
     }
-    
+
     final String methodsMayNotHaveTypeParameters() {
       return process("@Component.Builder methods must not have type parameters");
     }
@@ -335,7 +341,7 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
-    
+
     @Override protected String process(String s) {
       return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
     }
@@ -343,7 +349,7 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
     String builderMethodRequiresNoArgs() {
       return "Methods returning a @Subcomponent.Builder must have no arguments";
     }
-    
+
     String moreThanOneRefToSubcomponent() {
       return "Only one method can create a given subcomponent. %s is created by: %s";
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 09a7f1b21..071ce6982 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -23,11 +23,11 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
 import dagger.internal.codegen.writer.ClassName;
+import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
@@ -63,7 +63,7 @@
 
   final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
-    private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
+    private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<B> materializedBindings = Sets.newLinkedHashSet();
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
@@ -95,7 +95,7 @@ void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
       tryToCacheBinding(binding);
       tryToGenerateBinding(binding, factoryName, explicit);
     }
-    
+
     /**
      * Tries to generate a binding, not generating if it already is generated. For resolved
      * bindings, this will try to generate the unresolved version of the binding.
@@ -111,22 +111,22 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
         }
       }
     }
-    
+
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.hasNonDefaultTypeParameters()
           && elements.getTypeElement(factoryName.canonicalName()) == null
           && !materializedBindings.contains(binding)
           && !bindingsRequiringGeneration.contains(binding);
-        
+
     }
 
     /** Caches the binding for future lookups by key. */
     private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.hasNonDefaultTypeParameters()          
-          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {        
+      if (binding.hasNonDefaultTypeParameters()
+          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
         checkState(previousValue == null || binding.equals(previousValue),
@@ -220,7 +220,7 @@ private MembersInjectionBinding registerBinding(
     if (binding != null) {
       return Optional.of(binding);
     }
-    
+
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
     List<ExecutableElement> constructors =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index faa69dc5f..708763b8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -69,7 +69,8 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     // TODO(gak): instead, we should collect reports by type and check later
@@ -133,5 +134,6 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     for (ProvisionBinding binding : provisions.build()) {
       injectBindingRegistry.registerBinding(binding);
     }
+    return ImmutableSet.of();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index ca01668b7..cd7579659 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -48,12 +48,12 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
@@ -187,9 +187,7 @@ Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
-          MoreTypes.equivalence().wrap(returnType));
+      return forMethod(componentMethod, returnType);
     }
 
     Key forProductionComponentMethod(ExecutableElement componentMethod) {
@@ -200,99 +198,93 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
-          MoreTypes.equivalence().wrap(keyType));
+      return forMethod(componentMethod, keyType);
     }
 
-    Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      Provides providesAnnotation = e.getAnnotation(Provides.class);
+    Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
+      checkNotNull(method);
+      checkArgument(method.getKind().equals(METHOD));
+      Provides providesAnnotation = method.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
       TypeMirror returnType = normalize(types, executableType.getReturnType());
-      switch (providesAnnotation.type()) {
-        case UNIQUE:
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(returnType));
-        case SET:
-          TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(setType));
-        case MAP:
-          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
-          MapKey mapKey =
-              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-          TypeElement keyTypeElement =
-              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
-                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
-          TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
-          TypeMirror mapType =
-              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(mapType));
-        case SET_VALUES:
-          // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(returnType.getKind().equals(DECLARED));
-          checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(returnType));
-        default:
-          throw new AssertionError();
-      }
+      TypeMirror keyType =
+          providesOrProducesKeyType(
+              returnType,
+              method,
+              Optional.of(providesAnnotation.type()),
+              Optional.<Produces.Type>absent());
+      return forMethod(method, keyType);
     }
 
     // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
-    Key forProducesMethod(ExecutableType executableType, ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      Produces producesAnnotation = e.getAnnotation(Produces.class);
+    Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
+      checkNotNull(method);
+      checkArgument(method.getKind().equals(METHOD));
+      Produces producesAnnotation = method.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
       TypeMirror returnType = normalize(types, executableType.getReturnType());
-      TypeMirror keyType = returnType;
+      TypeMirror unfuturedType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+        unfuturedType =
+            Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
-      switch (producesAnnotation.type()) {
+      TypeMirror keyType =
+          providesOrProducesKeyType(
+              unfuturedType,
+              method,
+              Optional.<Provides.Type>absent(),
+              Optional.of(producesAnnotation.type()));
+      return forMethod(method, keyType);
+    }
+
+    private TypeMirror providesOrProducesKeyType(
+        TypeMirror returnType,
+        ExecutableElement method,
+        Optional<Provides.Type> providesType,
+        Optional<Produces.Type> producesType) {
+      switch (providesType.isPresent()
+          ? providesType.get()
+          : Provides.Type.valueOf(producesType.get().name())) {
         case UNIQUE:
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(keyType));
+          return returnType;
         case SET:
-          TypeMirror setType = types.getDeclaredType(getSetElement(), keyType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(setType));
+          return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
-          MapKey mapKey =
-              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-          TypeElement keyTypeElement =
-              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
-                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
-          TypeMirror valueType = types.getDeclaredType(getProducerElement(), keyType);
-          TypeMirror mapType =
-              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(mapType));
+          return mapOfFactoryType(
+              method,
+              returnType,
+              providesType.isPresent() ? getProviderElement() : getProducerElement());
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(keyType.getKind().equals(DECLARED));
-          checkArgument(((DeclaredType) keyType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(keyType));
+          checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
+          return returnType;
         default:
           throw new AssertionError();
       }
     }
 
+    private TypeMirror mapOfFactoryType(
+        ExecutableElement method, TypeMirror valueType, TypeElement factoryType) {
+      TypeMirror mapKeyType = mapKeyType(method);
+      TypeMirror mapValueFactoryType = types.getDeclaredType(factoryType, valueType);
+      return types.getDeclaredType(getMapElement(), mapKeyType, mapValueFactoryType);
+    }
+
+    private TypeMirror mapKeyType(ExecutableElement method) {
+      AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
+      MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+      return mapKey.unwrapValue()
+          ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
+          : mapKeyAnnotation.getAnnotationType();
+    }
+
+    private Key forMethod(ExecutableElement method, TypeMirror keyType) {
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
+          MoreTypes.equivalence().wrap(keyType));
+    }
+
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index e0be1493a..8d72e5e48 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -15,88 +15,162 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Joiner;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.MapKey;
+import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.SimpleTypeVisitor6;
 
+import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * Generates implementations to create {@link MapKey} instances
+ * Generates classes that create annotations required to instantiate {@link MapKey}s.
  *
- * @author Chenying Hou
  * @since 2.0
  */
-final class MapKeyGenerator extends SourceFileGenerator<Element> {
+final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+
+  /**
+   * Specification of the {@link MapKey} annotation and the annotation type to generate.
+   */
+  @AutoValue
+  abstract static class MapKeyCreatorSpecification {
+    /**
+     * The {@link MapKey}-annotated annotation.
+     */
+    abstract TypeElement mapKeyElement();
+
+    /**
+     * The annotation type to write create methods for. For wrapped {@link MapKey}s, this is
+     * {@link #mapKeyElement()}. For unwrapped {@code MapKey}s whose single element is an
+     * annotation, this is that annotation element.
+     */
+    abstract TypeElement annotationElement();
+
+    /**
+     * Returns a specification for a wrapped {@link MapKey}-annotated annotation.
+     */
+    static MapKeyCreatorSpecification wrappedMapKey(TypeElement mapKeyElement) {
+      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(mapKeyElement, mapKeyElement);
+    }
+
+    /**
+     * Returns a specification for an unwrapped {@link MapKey}-annotated annotation whose single
+     * element is a nested annotation.
+     */
+    static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
+        TypeElement mapKeyElement, TypeElement annotationElement) {
+      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(
+          mapKeyElement, annotationElement);
+    }
+  }
+
   MapKeyGenerator(Filer filer) {
     super(filer);
   }
 
   @Override
-  ClassName nameGeneratedType(Element e) {
-    return Util.getMapKeyCreatorClassName((TypeElement) e);
+  ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
+    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  Iterable<? extends Element> getOriginatingElements(Element e) {
-    return ImmutableSet.of(e);
+  Iterable<? extends Element> getOriginatingElements(MapKeyCreatorSpecification mapKeyCreatorType) {
+    return ImmutableSet.of(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(Element e) {
-    return Optional.of(e);
+  Optional<? extends Element> getElementForErrorReporting(
+      MapKeyCreatorSpecification mapKeyCreatorType) {
+    return Optional.of(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
+  ImmutableSet<JavaWriter> write(
+      ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    TypeWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
-    mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    mapKeyWriter.addModifiers(PUBLIC);
-
-    //create map key create method, which will return an instance of map key
-    MethodWriter getMethodWriter = mapKeyWriter.addMethod(e.asType(), "create");
-    //get parameter list of create method
-    List<? extends Element> enclosingElements = e.getEnclosedElements();
-    List<String> paraList = new ArrayList<String>();
-
-    //Using AutoAnnotation to generate mapkey creator files later
-    getMethodWriter.annotate(AutoAnnotation.class);
-    getMethodWriter.addModifiers(PUBLIC, STATIC);
-
-    for (Element element : enclosingElements) {
-      if (element instanceof ExecutableElement) {
-        ExecutableElement executableElement = (ExecutableElement) element;
-        Name parameterName = executableElement.getSimpleName();
-        getMethodWriter.addParameter(
-            (TypeElement) ((DeclaredType) (executableElement.getReturnType())).asElement(),
-            parameterName.toString());
-        paraList.add(parameterName.toString());
-      } else {
-        throw new IllegalStateException();
-      }
-    }
+    TypeWriter mapKeyCreatorWriter = writer.addClass(generatedTypeName.simpleName());
+    mapKeyCreatorWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    mapKeyCreatorWriter.addModifiers(PUBLIC, FINAL);
 
-    getMethodWriter.body().addSnippet(
-        "return new AutoAnnotation_" + generatedTypeName.simpleName() + "_create(%s);",
-        Joiner.on(", ").join(paraList));
+    for (TypeElement annotationElement :
+        nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
+      writeCreateMethod(mapKeyCreatorWriter, annotationElement);
+    }
 
     return ImmutableSet.of(writer);
   }
+
+  private void writeCreateMethod(TypeWriter mapKeyCreatorWriter, TypeElement annotationElement) {
+    MethodWriter createMethod =
+        mapKeyCreatorWriter.addMethod(
+            annotationElement.asType(), "create" + annotationElement.getSimpleName());
+
+    createMethod.annotate(AutoAnnotation.class);
+    createMethod.addModifiers(PUBLIC, STATIC);
+
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (ExecutableElement annotationMember : methodsIn(annotationElement.getEnclosedElements())) {
+      String parameterName = annotationMember.getSimpleName().toString();
+      TypeName parameterType = TypeNames.forTypeMirror(annotationMember.getReturnType());
+      createMethod.addParameter(parameterType, parameterName);
+      parameters.add(Snippet.format("%s", parameterName));
+    }
+
+    ClassName autoAnnotationClass = mapKeyCreatorWriter.name().peerNamed(
+        "AutoAnnotation_" + mapKeyCreatorWriter.name().simpleName() + "_" + createMethod.name());
+    createMethod.body().addSnippet(
+        "return new %s(%s);", autoAnnotationClass, makeParametersSnippet(parameters.build()));
+  }
+
+  private static Set<TypeElement> nestedAnnotationElements(TypeElement annotationElement) {
+    return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
+  }
+
+  private static Set<TypeElement> nestedAnnotationElements(
+      TypeElement annotationElement, Set<TypeElement> annotationElements) {
+    if (annotationElements.add(annotationElement)) {
+      for (ExecutableElement method : methodsIn(annotationElement.getEnclosedElements())) {
+        TRAVERSE_NESTED_ANNOTATIONS.visit(method.getReturnType(), annotationElements);
+      }
+    }
+    return annotationElements;
+  }
+
+  private static final SimpleTypeVisitor6<Void, Set<TypeElement>> TRAVERSE_NESTED_ANNOTATIONS =
+      new SimpleTypeVisitor6<Void, Set<TypeElement>>() {
+        @Override
+        public Void visitDeclared(DeclaredType t, Set<TypeElement> p) {
+          TypeElement typeElement = MoreTypes.asTypeElement(t);
+          if (typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {
+            nestedAnnotationElements(typeElement, p);
+          }
+          return null;
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 488f031c1..c4a264aa6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -16,13 +16,23 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
+import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
+import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
@@ -33,12 +43,17 @@
  */
 public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
+  private final Types types;
   private final MapKeyValidator mapKeyValidator;
   private final MapKeyGenerator mapKeyGenerator;
 
-  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator,
+  MapKeyProcessingStep(
+      Messager messager,
+      Types types,
+      MapKeyValidator mapKeyValidator,
       MapKeyGenerator mapKeyGenerator) {
     this.messager = messager;
+    this.types = types;
     this.mapKeyValidator = mapKeyValidator;
     this.mapKeyGenerator = mapKeyGenerator;
   }
@@ -49,21 +64,35 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.get(MapKey.class)) {
       ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
       mapKeyReport.printMessagesTo(messager);
 
       if (mapKeyReport.isClean()) {
         MapKey mapkey = element.getAnnotation(MapKey.class);
-        if (!mapkey.unwrapValue()) {
-          try {
-            mapKeyGenerator.generate(element);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        if (mapkey.unwrapValue()) {
+          DeclaredType keyType =
+              getUnwrappedMapKeyType(MoreTypes.asDeclared(element.asType()), types);
+          if (keyType.asElement().getKind() == ElementKind.ANNOTATION_TYPE) {
+            writeCreatorClass(
+                unwrappedMapKeyWithAnnotationValue(
+                    MoreElements.asType(element), MoreTypes.asTypeElement(keyType)));
           }
+        } else {
+          writeCreatorClass(wrappedMapKey(MoreElements.asType(element)));
         }
       }
     }
+    return ImmutableSet.of();
+  }
+
+  private void writeCreatorClass(MapKeyCreatorSpecification mapKeyCreatorType) {
+    try {
+      mapKeyGenerator.generate(mapKeyCreatorType);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 8411b20fb..01b0951a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -16,23 +16,37 @@
 package dagger.internal.codegen;
 
 import dagger.MapKey;
+import java.util.List;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeKind;
 
-import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_FIELDS;
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * A {@link Validator} for {@link MapKey} Annotation.
+ * A {@link Validator} for {@link MapKey} annotations.
  *
  * @author Chenying Hou
  * @since 2.0
  */
+// TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
 final class MapKeyValidator implements Validator<Element> {
   @Override
   public ValidationReport<Element> validate(Element element) {
     ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
-    if (((TypeElement) element).getEnclosedElements().isEmpty()) {
-      builder.addItem(MAPKEY_WITHOUT_FIELDS, element);
+    List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
+    if (members.isEmpty()) {
+      builder.addItem(MAPKEY_WITHOUT_MEMBERS, element);
+    } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
+      if (members.size() > 1) {
+        builder.addItem(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+      } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
+        builder.addItem(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+      }
     }
     return builder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
new file mode 100644
index 000000000..f378bbb26
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.transform;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * Methods for extracting {@link MapKey} annotations and key snippets from binding elements.
+ */
+final class MapKeys {
+
+  /**
+   * If {@code bindingElement} is annotated with a {@link MapKey} annotation, returns it.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
+   *     annotation
+   */
+  static Optional<? extends AnnotationMirror> getMapKey(Element bindingElement) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
+    return mapKeys.isEmpty()
+        ? Optional.<AnnotationMirror>absent()
+        : Optional.of(getOnlyElement(mapKeys));
+  }
+
+  /**
+   * Returns all of the {@link MapKey} annotations that annotate {@code bindingElement}.
+   */
+  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element bindingElement) {
+    return getAnnotatedAnnotations(bindingElement, MapKey.class);
+  }
+
+  /**
+   * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
+   * type is primitive, returns the boxed type.
+   *
+   * @throws IllegalArgumentException if {@code mapKeyAnnotationType} is not an annotation type or
+   *     has more than one member, or if its single member is an array
+   * @throws NoSuchElementException if the annotation has no members
+   */
+  public static DeclaredType getUnwrappedMapKeyType(
+      final DeclaredType mapKeyAnnotationType, final Types types) {
+    checkArgument(
+        MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
+        "%s is not an annotation type",
+        mapKeyAnnotationType);
+
+    final ExecutableElement onlyElement =
+        getOnlyElement(methodsIn(mapKeyAnnotationType.asElement().getEnclosedElements()));
+
+    SimpleTypeVisitor6<DeclaredType, Void> keyTypeElementVisitor =
+        new SimpleTypeVisitor6<DeclaredType, Void>() {
+
+          @Override
+          public DeclaredType visitArray(ArrayType t, Void p) {
+            throw new IllegalArgumentException(
+                mapKeyAnnotationType + "." + onlyElement.getSimpleName() + " cannot be an array");
+          }
+
+          @Override
+          public DeclaredType visitPrimitive(PrimitiveType t, Void p) {
+            return MoreTypes.asDeclared(types.boxedClass(t).asType());
+          }
+
+          @Override
+          public DeclaredType visitDeclared(DeclaredType t, Void p) {
+            return t;
+          }
+        };
+    return keyTypeElementVisitor.visit(onlyElement.getReturnType());
+  }
+
+  /**
+   * Returns the name of the generated class that contains the static {@code create} methods for a
+   * {@link MapKey} annotation type.
+   */
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
+    return enclosingClassName
+        .topLevelClassName()
+        .peerNamed(enclosingClassName.classFileName() + "Creator");
+  }
+
+  /**
+   * Returns a snippet for the map key specified by the {@link MapKey} annotation on
+   * {@code bindingElement}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
+   *     annotation
+   * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
+   *     annotation
+   */
+  static Snippet getMapKeySnippet(Element bindingElement) {
+    AnnotationMirror mapKey = getMapKey(bindingElement).get();
+    TypeElement mapKeyAnnotationType = MoreTypes.asTypeElement(mapKey.getAnnotationType());
+    ClassName mapKeyCreator = MapKeys.getMapKeyCreatorClassName(mapKeyAnnotationType);
+    if (mapKeyAnnotationType.getAnnotation(MapKey.class).unwrapValue()) {
+      AnnotationValue memberToUnwrap = getOnlyElement(mapKey.getElementValues().values());
+      return new MapKeySnippetExceptArrays(mapKeyCreator).visit(memberToUnwrap, memberToUnwrap);
+    } else {
+      return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
+    }
+  }
+
+  /**
+   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
+   * static creation methods for all nested annotation types.
+   *
+   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
+   * <em>when used in an annotation</em>, which is not always the same as the representation needed
+   * when creating the value in a method body.
+   *
+   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
+   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
+   */
+  private static class MapKeySnippet
+      extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
+
+    final ClassName mapKeyCreator;
+
+    MapKeySnippet(ClassName mapKeyCreator) {
+      this.mapKeyCreator = mapKeyCreator;
+    }
+
+    @Override
+    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
+      return Snippet.format(
+          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+    }
+
+    @Override
+    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+      return annotationSnippet(a, this);
+    }
+
+    @Override
+    public Snippet visitType(TypeMirror t, AnnotationValue p) {
+      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+    }
+
+    @Override
+    public Snippet visitString(String s, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitByte(byte b, AnnotationValue p) {
+      return Snippet.format("(byte) %s", b);
+    }
+
+    @Override
+    public Snippet visitChar(char c, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitDouble(double d, AnnotationValue p) {
+      return Snippet.format("%sD", d);
+    }
+
+    @Override
+    public Snippet visitFloat(float f, AnnotationValue p) {
+      return Snippet.format("%sF", f);
+    }
+
+    @Override
+    public Snippet visitInt(int i, AnnotationValue p) {
+      return Snippet.format("(int) %s", i);
+    }
+
+    @Override
+    public Snippet visitLong(long i, AnnotationValue p) {
+      return Snippet.format("%sL", i);
+    }
+
+    @Override
+    public Snippet visitShort(short s, AnnotationValue p) {
+      return Snippet.format("(short) %s", s);
+    }
+
+    @Override
+    protected Snippet defaultAction(Object o, AnnotationValue p) {
+      return Snippet.format("%s", o);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (int i = 0; i < values.size(); i++) {
+        snippets.add(this.visit(values.get(i), p));
+      }
+      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
+    }
+  }
+
+  /**
+   * Returns a snippet for the visited value. Expects its parameter to be a class with static
+   * creation methods for all nested annotation types.
+   *
+   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
+   */
+  private static class MapKeySnippetExceptArrays extends MapKeySnippet {
+
+    MapKeySnippetExceptArrays(ClassName mapKeyCreator) {
+      super(mapKeyCreator);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      throw new IllegalArgumentException("Cannot unwrap arrays");
+    }
+  }
+
+  /**
+   * Returns a snippet that calls a static method on {@code mapKeySnippet.mapKeyCreator} to create
+   * an annotation from {@code mapKeyAnnotation}.
+   */
+  private static Snippet annotationSnippet(
+      AnnotationMirror mapKeyAnnotation, final MapKeySnippet mapKeySnippet) {
+    return Snippet.format(
+        "%s.create%s(%s)",
+        mapKeySnippet.mapKeyCreator,
+        mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
+        makeParametersSnippet(
+            transform(
+                getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
+                  @Override
+                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                    return ARRAY_LITERAL_PREFIX.visit(
+                        entry.getKey().getReturnType(),
+                        mapKeySnippet.visit(entry.getValue(), entry.getValue()));
+                  }
+                })));
+  }
+
+  /**
+   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
+   * {@code T} is the raw array component type.
+   */
+  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<Snippet, Snippet>() {
+
+        @Override
+        public Snippet visitArray(ArrayType t, Snippet p) {
+          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        }
+
+        @Override
+        protected Snippet defaultAction(TypeMirror e, Snippet p) {
+          return p;
+        }
+      };
+
+  /**
+   * If the visited type is an array, returns the name of its raw component type; otherwise returns
+   * the name of the type itself.
+   */
+  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
+      new SimpleTypeVisitor6<TypeName, Void>() {
+        @Override
+        public TypeName visitDeclared(DeclaredType t, Void p) {
+          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
+        }
+
+        @Override
+        protected TypeName defaultAction(TypeMirror e, Void p) {
+          return TypeNames.forTypeMirror(e);
+        }
+      };
+
+  private MapKeys() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
new file mode 100644
index 000000000..dcabab52d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.util.ArrayDeque;
+import java.util.Deque;
+
+/**
+ * Utility code that looks for bindings matching a key in all subcomponents in a binding graph so
+ * that a user is advised that a binding exists elsewhere when it is not found in the current
+ * subgraph. If a binding matching a key exists in a sub- or sibling component, that is often what
+ * the user actually wants to use.
+ */
+class MissingBindingSuggestions {
+  /**
+   * Searches the entire binding graph from the top-level graph for a binding matching
+   * {@code key}.
+   */
+  static ImmutableList<String> forKey(BindingGraph topLevelGraph, BindingKey key) {
+    ImmutableList.Builder<String> resolutions = new ImmutableList.Builder<>();
+    Deque<BindingGraph> graphsToTry = new ArrayDeque<>();
+
+    graphsToTry.add(topLevelGraph);
+    do {
+      BindingGraph graph = graphsToTry.removeLast();
+      ResolvedBindings bindings = graph.resolvedBindings().get(key);
+      if ((bindings == null) || bindings.bindings().isEmpty()) {
+        graphsToTry.addAll(graph.subgraphs().values());
+      } else {
+        resolutions.add("A binding with matching key exists in component: "
+            + graph.componentDescriptor().componentDefinitionType().getQualifiedName());
+      }
+    } while (!graphsToTry.isEmpty());
+
+    return resolutions.build();
+  }
+
+  private MissingBindingSuggestions() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
new file mode 100644
index 000000000..f5e33b59d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -0,0 +1,122 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+@AutoValue
+abstract class ModuleDescriptor {
+  static final Function<ModuleDescriptor, TypeElement> getModuleElement() {
+    return new Function<ModuleDescriptor, TypeElement>() {
+      @Override public TypeElement apply(ModuleDescriptor input) {
+        return input.moduleElement();
+      }
+    };
+  }
+
+  abstract AnnotationMirror moduleAnnotation();
+
+  abstract TypeElement moduleElement();
+
+  abstract ImmutableSet<ModuleDescriptor> includedModules();
+
+  abstract ImmutableSet<? extends ContributionBinding> bindings();
+
+  enum DefaultCreationStrategy {
+    PASSED,
+    CONSTRUCTED,
+  }
+
+  abstract DefaultCreationStrategy defaultCreationStrategy();
+
+  static final class Factory {
+    private final Elements elements;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final ProductionBinding.Factory productionBindingFactory;
+
+    Factory(
+        Elements elements,
+        ProvisionBinding.Factory provisionBindingFactory,
+        ProductionBinding.Factory productionBindingFactory) {
+      this.elements = elements;
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.productionBindingFactory = productionBindingFactory;
+    }
+
+    ModuleDescriptor create(TypeElement moduleElement) {
+      AnnotationMirror moduleAnnotation = getModuleAnnotation(moduleElement).get();
+
+      ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
+      for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
+        if (isAnnotationPresent(moduleMethod, Provides.class)) {
+          bindings.add(
+              provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement.asType()));
+        }
+        if (isAnnotationPresent(moduleMethod, Produces.class)) {
+          bindings.add(
+              productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
+        }
+      }
+
+      DefaultCreationStrategy defaultCreationStrategy =
+          (componentCanMakeNewInstances(moduleElement)
+              && moduleElement.getTypeParameters().isEmpty())
+                  ? ModuleDescriptor.DefaultCreationStrategy.CONSTRUCTED
+                  : ModuleDescriptor.DefaultCreationStrategy.PASSED;
+
+      return new AutoValue_ModuleDescriptor(
+          moduleAnnotation,
+          moduleElement,
+          ImmutableSet.copyOf(
+              collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
+          bindings.build(),
+          defaultCreationStrategy);
+    }
+
+    private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
+      return getAnnotationMirror(moduleElement, Module.class)
+          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+    }
+
+    private Set<ModuleDescriptor> collectIncludedModules(
+        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+      TypeMirror superclass = moduleElement.getSuperclass();
+      if (!superclass.getKind().equals(NONE)) {
+        verify(superclass.getKind().equals(DECLARED));
+        TypeElement superclassElement = MoreTypes.asTypeElement(superclass);
+        if (!superclassElement.getQualifiedName().contentEquals(Object.class.getCanonicalName())) {
+          collectIncludedModules(includedModules, superclassElement);
+        }
+      }
+      Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
+      if (moduleAnnotation.isPresent()) {
+        for (TypeMirror moduleIncludesType : getModuleIncludes(moduleAnnotation.get())) {
+          includedModules.add(create(MoreTypes.asTypeElement(moduleIncludesType)));
+        }
+      }
+      return includedModules;
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 423848868..1afda7d90 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -70,7 +70,8 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
     ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
     for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
@@ -130,5 +131,6 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
       }
       processedModuleElements.add(moduleElement);
     }
+    return ImmutableSet.of();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index f30ef9133..f2116b110 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -35,6 +35,7 @@
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -101,7 +102,9 @@
       
     validateModuleVisibility(subject, builder);
     validateMethodsWithSameName(builder, bindingMethodsByName);
-    validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+    if (subject.getKind() != ElementKind.INTERFACE) {
+      validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+    }
     validateModifiers(subject, builder);    
     validateReferencedModules(subject, builder);
     
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index d4d55f8d3..10565a1b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -120,7 +120,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC);
     factoryWriter.addModifiers(FINAL);
-    factoryWriter.setSuperType(
+    factoryWriter.setSuperclass(
         ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
 
     MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 3e7d81dc6..cc167e599 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -71,7 +71,8 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all produces methods
     ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
     for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
@@ -135,5 +136,6 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
         processedModuleElements.add(moduleElement);
       }
     }
+    return ImmutableSet.of();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index cf4b43ec7..a6e77a712 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -35,7 +35,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
@@ -48,6 +47,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
@@ -108,10 +108,9 @@ private TypeElement getSetElement() {
 
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
-        && (getMapKeys(producesMethodElement) != null
-            && !getMapKeys(producesMethodElement).isEmpty())) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
-          producesMethodElement);
+        && !getMapKeys(producesMethodElement).isEmpty()) {
+      builder.addItem(
+          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
     ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
@@ -123,18 +122,17 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateSingleReturnType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
-            getMapKeys(producesMethodElement);
-        switch (annotationMirrors.size()) {
+        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
+        switch (mapKeys.size()) {
           case 0:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
-                producesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
-                producesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
             break;
         }
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index 187cecd73..a424d12b4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -32,13 +32,10 @@
  *
  * @author Jesse Beder
  */
-final class ProductionComponentProcessingStep implements ProcessingStep {
+final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
   private final Messager messager;
   private final ProductionComponentValidator componentValidator;
-  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
 
   ProductionComponentProcessingStep(
       Messager messager,
@@ -47,12 +44,14 @@
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
+    super(
+        messager,
+        bindingGraphValidator,
+        bindingGraphFactory,
+        componentGenerator);
     this.messager = messager;
     this.componentValidator = componentValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
   }
 
   @Override
@@ -61,29 +60,20 @@
   }
 
   @Override
-  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    Set<? extends Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
-
+  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ComponentDescriptor> componentDescriptors = ImmutableSet.builder();
+    Set<Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
       ValidationReport<TypeElement> componentReport =
           componentValidator.validate(componentTypeElement);
       componentReport.printMessagesTo(messager);
       if (componentReport.isClean()) {
-        ComponentDescriptor componentDescriptor =
-            componentDescriptorFactory.forProductionComponent(componentTypeElement);
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<BindingGraph> graphReport =
-            bindingGraphValidator.validate(bindingGraph);
-        graphReport.printMessagesTo(messager);
-        if (graphReport.isClean()) {
-          try {
-            componentGenerator.generate(bindingGraph);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
-          }
-        }
+        componentDescriptors.add(
+            componentDescriptorFactory.forProductionComponent(componentTypeElement));
       }
     }
+    return componentDescriptors.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 535c5fa26..af2e1f0d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -33,7 +33,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
@@ -47,9 +46,9 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -84,7 +83,7 @@ private TypeElement getSetElement() {
       builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
           providesMethodElement);
     }
-    
+
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
           providesMethodElement);
@@ -105,13 +104,12 @@ private TypeElement getSetElement() {
       builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
           providesMethodElement);
     }
-  
+
     // check mapkey is right
-    if (!providesAnnotation.type().equals(Provides.Type.MAP) 
-        && (getMapKeys(providesMethodElement) != null
-            && getMapKeys(providesMethodElement).size() > 0)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
-          providesMethodElement);
+    if (!providesAnnotation.type().equals(Provides.Type.MAP)
+        && !getMapKeys(providesMethodElement).isEmpty()) {
+      builder.addItem(
+          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
     }
 
     validateMethodQualifiers(builder, providesMethodElement);
@@ -123,18 +121,17 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateKeyType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
-            getMapKeys(providesMethodElement);
-        switch (annotationMirrors.size()) {
+        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
+        switch (mapKeys.size()) {
           case 0:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
-                providesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
-                providesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
             break;
         }
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 3adf6f6bd..1eca18f68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -26,28 +26,23 @@
 import com.google.common.collect.ImmutableSet.Builder;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.ClassName;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -82,46 +77,6 @@ public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
     return MoreTypes.asDeclared(mapArgs.get(0));
   }
 
-  /**
-   * Returns the unwrapped key's {@link TypeElement} for a {@link Map} given the
-   * {@link AnnotationMirror} of the key.
-   */
-  public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
-    Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
-    // TODO(user) Support literals other than String and Enum
-    AnnotationValueVisitor<TypeElement, Void> mapKeyVisitor =
-        new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
-          @Override
-          public TypeElement visitEnumConstant(VariableElement c, Void p) {
-            return MoreElements.asType(c.getEnclosingElement()) ;
-          }
-
-          @Override
-          public TypeElement visitString(String s, Void p) {
-            return elements.getTypeElement(String.class.getCanonicalName());
-          }
-
-          @Override
-          protected TypeElement defaultAction(Object o, Void v) {
-            throw new IllegalStateException(
-                "Non-supported key type for map binding " + o.getClass().getCanonicalName());
-          }
-        };
-    TypeElement keyTypeElement =
-        Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
-    return keyTypeElement;
-  }
-
-  /**
-   * Returns the name of the generated class that contains the static {@code create} method for a
-   * {@code @MapKey} annotation type.
-   */
-  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
-    return enclosingClassName.topLevelClassName().peerNamed(
-        enclosingClassName.classFileName() + "Creator");
-  }
-
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
@@ -184,7 +139,8 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
 
     for (Element enclosed : typeElement.getEnclosedElements()) {
       if (enclosed.getKind().equals(CONSTRUCTOR)
-          && ((ExecutableElement) enclosed).getParameters().isEmpty()) {
+          && ((ExecutableElement) enclosed).getParameters().isEmpty()
+          && !enclosed.getModifiers().contains(PRIVATE)) {
         return true;
       }
     }
@@ -205,8 +161,11 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return ImmutableList.copyOf(methods);
   }
 
-  private static void findLocalAndInheritedMethodsRecursive(TypeElement objectType,
-      Elements elements, TypeElement type, List<ExecutableElement> methods) {
+  private static void findLocalAndInheritedMethodsRecursive(
+      TypeElement objectType,
+      Elements elements,
+      TypeElement type,
+      List<ExecutableElement> methods) {
     if (objectType.equals(type)) {
       return;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 20b373f40..95ddf0c39 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.base.Function;
+import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
@@ -25,35 +26,61 @@
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
 
+import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 public final class ClassWriter extends TypeWriter {
+  private Optional<TypeName> superclass;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeParameters;
 
   ClassWriter(ClassName className) {
     super(className);
+    this.superclass = Optional.absent();
     this.constructorWriters = Lists.newArrayList();
     this.typeParameters = Lists.newArrayList();
   }
 
+  public void setSuperclass(TypeName typeReference) {
+    checkState(!superclass.isPresent());
+    superclass = Optional.of(typeReference);
+  }
+
+  /**
+   * If {@code supertype} is a class, makes this class extend it; if it is an interface, makes this
+   * class implement it.
+   */
+  public void setSupertype(TypeElement supertype) {
+    switch (supertype.getKind()) {
+      case CLASS:
+        setSuperclass(ClassName.fromTypeElement(supertype));
+        break;
+      case INTERFACE:
+        addImplementedType(supertype);
+        break;
+      default:
+        throw new IllegalArgumentException(supertype + " must be a class or interface");
+    }
+  }
+
   public ConstructorWriter addConstructor() {
     ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
     constructorWriters.add(constructorWriter);
     return constructorWriter;
   }
-  
+
   public void addTypeParameter(TypeVariableName typeVariableName) {
     this.typeParameters.add(typeVariableName);
   }
-  
+
   public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
     Iterables.addAll(typeParameters, typeVariableNames);
   }
-  
+
   public List<TypeVariableName> typeParameters() {
     return ImmutableList.copyOf(typeParameters);
   }
@@ -70,9 +97,9 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
     Writables.join(", ", typeParameters, "<", ">", appendable, context);
-    if (supertype.isPresent()) {
+    if (superclass.isPresent()) {
       appendable.append(" extends ");
-      supertype.get().write(appendable, context);
+      superclass.get().write(appendable, context);
     }
     Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
     appendable.append(" {");
@@ -114,7 +141,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
     @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, supertype.asSet(), annotations, typeParameters);
+            methodWriters, implementedTypes, superclass.asSet(), annotations, typeParameters);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
index f3dcd9a12..cb0d75e73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -126,8 +126,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
     @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
-            constructorWriters,
-            methodWriters, implementedTypes, supertype.asSet(), annotations);
+            constructorWriters, methodWriters, implementedTypes, annotations);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index 0db9ff864..5eac8a9ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -52,13 +52,9 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
       Joiner.on(", ").appendTo(appendable, typeVariables);
       appendable.append('>');
     }
-    if (supertype.isPresent()) {
-      appendable.append(" extends ");
-      supertype.get().write(appendable, context);
-    }
     Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
     if (implementedTypesIterator.hasNext()) {
-      appendable.append(" implements ");
+      appendable.append(" extends ");
       implementedTypesIterator.next().write(appendable, context);
       while (implementedTypesIterator.hasNext()) {
         appendable.append(", ");
@@ -82,8 +78,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
   public Set<ClassName> referencedClasses() {
     @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),
-            annotations);
+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, annotations);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index a13c98164..4fa5a3fc9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -25,11 +25,11 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.io.Closer;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
 import java.util.Set;
@@ -125,7 +125,7 @@ public Appendable write(Appendable appendable) throws IOException {
         .toSet();
 
     ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
-    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);
+    Deque<TypeWriter> declaredTypes = new ArrayDeque<>(typeWriters);
     while (!declaredTypes.isEmpty()) {
       TypeWriter currentType = declaredTypes.pop();
       declaredSimpleNamesBuilder.add(currentType.name().simpleName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 52aeb44b0..50dc91838 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -129,4 +129,46 @@ public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets)
     }
     return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
   }
+
+  /**
+   * A snippet that concatenates its arguments.
+   */
+  public static Snippet concat(Iterable<Snippet> snippets) {
+    return join(Joiner.on(""), snippets);
+  }
+
+  /**
+   * A snippet that joins its arguments with {@code joiner}.
+   */
+  public static Snippet join(Joiner joiner, Iterable<Snippet> snippets) {
+    FluentIterable<Snippet> fluentSnippets = FluentIterable.from(snippets);
+    return new Snippet(
+        fluentSnippets
+            .transform(
+                new Function<Snippet, String>() {
+                  @Override
+                  public String apply(Snippet snippet) {
+                    return snippet.format;
+                  }
+                })
+            .join(joiner),
+        fluentSnippets
+            .transformAndConcat(
+                new Function<Snippet, ImmutableSet<TypeName>>() {
+                  @Override
+                  public ImmutableSet<TypeName> apply(Snippet snippet) {
+                    return snippet.types;
+                  }
+                })
+            .toSet(),
+        fluentSnippets
+            .transformAndConcat(
+                new Function<Snippet, ImmutableList<Object>>() {
+                  @Override
+                  public ImmutableList<Object> apply(Snippet snippet) {
+                    return snippet.args;
+                  }
+                })
+            .toList());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index 364b3a239..b13d0831e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.util.List;
@@ -23,15 +22,12 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.base.Preconditions.checkState;
-
 /**
  * Only named types. Doesn't cover anonymous inner classes.
  */
 public abstract class TypeWriter /* ha ha */ extends Modifiable
     implements Writable, HasTypeName, HasClassReferences {
   final ClassName name;
-  Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
   final List<MethodWriter> methodWriters;
   final List<TypeWriter> nestedTypeWriters;
@@ -39,7 +35,6 @@
 
   TypeWriter(ClassName name) {
     this.name = name;
-    this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
     this.methodWriters = Lists.newArrayList();
     this.nestedTypeWriters = Lists.newArrayList();
@@ -91,15 +86,6 @@ public void addImplementedType(TypeElement typeElement) {
     implementedTypes.add(ClassName.fromTypeElement(typeElement));
   }
 
-  public void setSuperType(TypeName typeReference) {
-    checkState(!supertype.isPresent());
-    supertype = Optional.of(typeReference);
-  }
-
-  public void setSuperType(TypeElement typeElement) {
-    setSuperType(ClassName.fromTypeElement(typeElement));
-  }
-
   public FieldWriter addField(Class<?> type, String name) {
     return addField(ClassName.fromClass(type), name);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index c5841c8db..f7e79da29 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,9 +15,18 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.writer.StringLiteral;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -92,14 +101,14 @@
         .withErrorContaining("is not annotated with @Module");
   }
 
-  @Test public void cannotReferToAbstractModules() {
+  private void checkCannotReferToModuleOfType(String moduleType) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "",
         "@Module",
-        "abstract class TestModule {}");
+        moduleType + " TestModule {}");
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
         "package test;",
         "",
@@ -114,6 +123,14 @@
             String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
   }
 
+  @Test public void cannotReferToAbstractClassModules() {
+    checkCannotReferToModuleOfType("abstract class");
+  }
+
+  @Test public void cannotReferToInterfaceModules() {
+    checkCannotReferToModuleOfType("interface");
+  }
+
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -614,11 +631,11 @@
         "",
         "  public static final class Builder {",
         "    private TestModule testModule;",
-        "    private DepModule depModule;",
-        "    private AlwaysIncluded alwaysIncluded;",
         "    private ParentTestIncluded parentTestIncluded;",
-        "    private RefByDep refByDep;",
+        "    private AlwaysIncluded alwaysIncluded;",
+        "    private DepModule depModule;",
         "    private ParentDepIncluded parentDepIncluded;",
+        "    private RefByDep refByDep;",
         "",
         "    private Builder() {",
         "    }",
@@ -627,21 +644,21 @@
         "      if (testModule == null) {",
         "        this.testModule = new TestModule();",
         "      }",
-        "      if (depModule == null) {",
-        "        this.depModule = new DepModule();",
+        "      if (parentTestIncluded == null) {",
+        "        this.parentTestIncluded = new ParentTestIncluded();",
         "      }",
         "      if (alwaysIncluded == null) {",
         "        this.alwaysIncluded = new AlwaysIncluded();",
         "      }",
-        "      if (parentTestIncluded == null) {",
-        "        this.parentTestIncluded = new ParentTestIncluded();",
-        "      }",
-        "      if (refByDep == null) {",
-        "        this.refByDep = new RefByDep();",
+        "      if (depModule == null) {",
+        "        this.depModule = new DepModule();",
         "      }",
         "      if (parentDepIncluded == null) {",
         "        this.parentDepIncluded = new ParentDepIncluded();",
         "      }",
+        "      if (refByDep == null) {",
+        "        this.refByDep = new RefByDep();",
+        "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
@@ -653,11 +670,11 @@
         "      return this;",
         "    }",
         "",
-        "    public Builder depModule(DepModule depModule) {",
-        "      if (depModule == null) {",
-        "        throw new NullPointerException(\"depModule\");",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      if (parentTestIncluded == null) {",
+        "        throw new NullPointerException(\"parentTestIncluded\");",
         "      }",
-        "      this.depModule = depModule;",
+        "      this.parentTestIncluded = parentTestIncluded;",
         "      return this;",
         "    }",
         "",
@@ -669,19 +686,11 @@
         "      return this;",
         "    }",
         "",
-        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
-        "      if (parentTestIncluded == null) {",
-        "        throw new NullPointerException(\"parentTestIncluded\");",
-        "      }",
-        "      this.parentTestIncluded = parentTestIncluded;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder refByDep(RefByDep refByDep) {",
-        "      if (refByDep == null) {",
-        "        throw new NullPointerException(\"refByDep\");",
+        "    public Builder depModule(DepModule depModule) {",
+        "      if (depModule == null) {",
+        "        throw new NullPointerException(\"depModule\");",
         "      }",
-        "      this.refByDep = refByDep;",
+        "      this.depModule = depModule;",
         "      return this;",
         "    }",
         "",
@@ -692,6 +701,14 @@
         "      this.parentDepIncluded = parentDepIncluded;",
         "      return this;",
         "    }",
+        "",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      if (refByDep == null) {",
+        "        throw new NullPointerException(\"refByDep\");",
+        "      }",
+        "      this.refByDep = refByDep;",
+        "      return this;",
+        "    }",
         "  }",
         "}");
     assertAbout(javaSources())
@@ -709,6 +726,41 @@
         .and().generatesSources(generatedComponent);
   }
 
+  @Test
+  public void generatedTransitiveModule() {
+    JavaFileObject rootModule = JavaFileObjects.forSourceLines("test.RootModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = GeneratedModule.class)",
+        "final class RootModule {}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = RootModule.class)",
+        "interface TestComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(rootModule, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(rootModule, component))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedModule",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "",
+                "@Module",
+                "final class GeneratedModule {}"))
+        .compilesWithoutError();
+  }
+
   @Test public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
@@ -1747,6 +1799,43 @@
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
 
+  @Test
+  public void componentImplicitlyDependsOnGeneratedType() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(GeneratedType generatedType) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor("test.GeneratedType",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "final class GeneratedType {",
+                "  @Inject GeneratedType() {}",
+                "}"))
+        .compilesWithoutError();
+  }
+
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
   @SuppressWarnings("unused")
@@ -1838,4 +1927,37 @@ public void genericTestToLetMeDebugInEclipse() {
          .compilesWithoutError()
          .and().generatesSources(generatedComponent);
    }
+
+  /**
+   * A simple {@link Processor} that generates one source file.
+   */
+  private static final class GeneratingProcessor extends AbstractProcessor {
+    private final String generatedClassName;
+    private final String generatedSource;
+    private boolean processed;
+
+    GeneratingProcessor(String generatedClassName, String... source) {
+      this.generatedClassName = generatedClassName;
+      this.generatedSource = Joiner.on("\n").join(source);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      if (!processed) {
+        processed = true;
+        try (Writer writer =
+                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
+          writer.append(generatedSource);
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+      return false;
+    }
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 74f33aeaa..cf5a94a2f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -144,9 +144,9 @@ public void mapBindingsWithEnumKey() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(test.PathEnum.ADMIN,",
+        "            .put(PathEnum.ADMIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(test.PathEnum.LOGIN,",
+        "            .put(PathEnum.LOGIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
@@ -477,8 +477,10 @@ public void mapBindingsWithWrappedKey() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<ClassKey, Handler>builder(2)",
-        "            .put(ClassKeyCreator.create(Integer.class), mapOfClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(ClassKeyCreator.create(Long.class), mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "            .put(ClassKeyCreator.createClassKey(Integer.class),",
+        "                mapOfClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(ClassKeyCreator.createClassKey(Long.class),",
+        "                mapOfClassKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
@@ -647,9 +649,9 @@ public void mapBindingsWithNonProviderValue() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(test.PathEnum.ADMIN,",
+        "            .put(PathEnum.ADMIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(test.PathEnum.LOGIN,",
+        "            .put(PathEnum.LOGIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "    this.mapOfPathEnumAndHandlerProvider =",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index b003a4fef..531ae722b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -55,10 +55,10 @@ public void mapKeyCreatorFile() {
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public class PathKeyCreator {",
+        "public final class PathKeyCreator {",
         "  @com.google.auto.value.AutoAnnotation",
-        "  public static PathKey create(PathEnum value, String relativePath) {",
-        "    return new AutoAnnotation_PathKeyCreator_create(value, relativePath);",
+        "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+        "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
         "  }",
         "}");
     assert_().about(javaSources())
@@ -102,10 +102,11 @@ public void nestedMapKeyCreatorFile() {
             "import test.Container.PathKey",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-            "public class Container$PathKeyCreator {",
+            "public final class Container$PathKeyCreator {",
             "  @com.google.auto.value.AutoAnnotation",
-            "  public static PathKey create(PathEnum value, String relativePath) {",
-            "    return new AutoAnnotation_Container$PathKeyCreator_create(value, relativePath);",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container$PathKeyCreator_createPathKey(",
+            "        value, relativePath);",
             "  }",
             "}");
     assert_().about(javaSources())
@@ -231,9 +232,9 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
@@ -405,9 +406,9 @@ public void mapKeyComponentFileWithDefaultField() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
new file mode 100644
index 000000000..0ae01b40c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MissingBindingSuggestionsTest {
+  private static JavaFileObject injectable(String className, String constructorParams) {
+    return JavaFileObjects.forSourceLines("test." + className,
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class " + className +" {",
+        "  @Inject " + className + "(" + constructorParams + ") {}",
+        "}");
+  }
+
+  private static JavaFileObject emptyInterface(String interfaceName) {
+    return JavaFileObjects.forSourceLines("test." + interfaceName,
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface " + interfaceName +" {}");
+  }
+
+  @Test public void suggestsBindingInSeparateComponent() {
+    JavaFileObject fooComponent = JavaFileObjects.forSourceLines("test.FooComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface FooComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject barModule = JavaFileObjects.forSourceLines("test.BarModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class BarModule {",
+        "  @Provides Bar provideBar() {return null;}",
+        "}");
+    JavaFileObject barComponent = JavaFileObjects.forSourceLines("test.BarComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {BarModule.class})",
+        "interface BarComponent {",
+        "  Bar getBar();",
+        "}");
+    JavaFileObject foo = injectable("Foo", "Bar bar");
+    JavaFileObject bar = emptyInterface("Bar");
+
+    JavaFileObject topComponent = JavaFileObjects.forSourceLines("test.TopComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TopComponent {",
+        "  FooComponent getFoo();",
+        "  BarComponent getBar(BarModule barModule);",
+        "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            fooComponent, barComponent, topComponent, foo, bar, barModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("A binding with matching key exists in component: test.BarComponent");
+  }
+
+  @Test public void suggestsBindingInNestedSubcomponent() {
+    JavaFileObject fooComponent = JavaFileObjects.forSourceLines("test.FooComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface FooComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject barComponent = JavaFileObjects.forSourceLines("test.BarComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent()",
+        "interface BarComponent {",
+        "  BazComponent getBaz();",
+        "}");
+    JavaFileObject bazModule = JavaFileObjects.forSourceLines("test.BazModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class BazModule {",
+        "  @Provides Baz provideBaz() {return null;}",
+        "}");
+    JavaFileObject bazComponent = JavaFileObjects.forSourceLines("test.BazComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {BazModule.class})",
+        "interface BazComponent {",
+        "  Baz getBaz();",
+        "}");
+    JavaFileObject foo = injectable("Foo", "Baz baz");
+    JavaFileObject baz = emptyInterface("Baz");
+
+    JavaFileObject topComponent = JavaFileObjects.forSourceLines("test.TopComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TopComponent {",
+        "  FooComponent getFoo();",
+        "  BarComponent getBar();",
+        "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("A binding with matching key exists in component: test.BazComponent");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 0ec5f8083..1eeda25e3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -44,7 +44,7 @@
   private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
       "package test;",
       "public @interface Nullable {}");
-  
+
   private static final StringLiteral NPE_LITERAL =
       StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
@@ -890,7 +890,7 @@ public void publicModuleNonPublicIncludes() {
             + "test.NonPublicModule1 and test.NonPublicModule2 public.")
         .in(publicModuleFile).onLine(8);
   }
-  
+
   @Test
   public void genericSubclassedModule() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
@@ -944,40 +944,40 @@ public void genericSubclassedModule() {
         "}");
     JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
         "test.ParentModule_ProvidesListBFactory",
-        "package test;", 
-        "", 
+        "package test;",
+        "",
         "import dagger.internal.Factory;",
-        "import java.util.List;", 
-        "import javax.annotation.Generated;", 
-        "import javax.inject.Provider;", 
-        "", 
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")", 
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
-        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {", 
-        "  private final ParentModule<A, B, C> module;", 
-        "  private final Provider<B> bProvider;", 
-        "", 
+        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
+        "  private final ParentModule<A, B, C> module;",
+        "  private final Provider<B> bProvider;",
+        "",
         "  public ParentModule_ProvideListBFactory(",
-        "        ParentModule<A, B, C> module, Provider<B> bProvider) {", 
-        "    assert module != null;", 
-        "    this.module = module;", 
-        "    assert bProvider != null;", 
-        "    this.bProvider = bProvider;", 
-        "  }", 
-        "", 
-        "  @Override", 
-        "  public List<B> get() {  ", 
+        "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public List<B> get() {  ",
         "    List<B> provided = module.provideListB(bProvider.get());",
         "    if (provided == null) {",
         "      throw new NullPointerException(" + NPE_LITERAL + ");",
         "    }",
-        "    return provided;", 
-        "  }", 
-        "", 
+        "    return provided;",
+        "  }",
+        "",
         "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
         "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);", 
-        "  }", 
+        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
+        "  }",
         "}");
     JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
         "test.ChildNumberModule_ProvideNumberFactory",
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index fcde154ce..3ebd13b31 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -19,19 +19,20 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.util.Map;
 
 import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides#Type#MAP map}.
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides.Type#MAP map}.
  *
  * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
  * with {@code @MapKey}.
  *
- * <p>Typically, the key annotation has a single member element, whose value is used as the map key.
+ * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
  * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
  * an annotation called {@code @StringKey}:
@@ -59,9 +60,8 @@
  * }
  * </code></pre>
  *
- * <p><b>Note:</b> Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed,
- * if {@code unwrapValue} is true, the annotation's single element must be a {@code String} or
- * enumerated type.
+ * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
+ * array.
  *
  * <h2>Annotations as keys</h2>
  *
@@ -93,7 +93,7 @@
  * </code></pre>
  *
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
- * order to call {@link Map#get()} on the provided map.)
+ * order to call {@link Map#get(Object)} on the provided map.)
  */
 @Documented
 @Target(ANNOTATION_TYPE)
@@ -101,11 +101,10 @@
 @Beta
 public @interface MapKey {
   /**
-   * True to use the value of the single element of the annotated annotation as the map key; false
+   * True to use the value of the single member of the annotated annotation as the map key; false
    * to use the annotation instance as the map key.
    *
-   * <p>Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed, if true
-   * the single element must be a {@code String} or an enumerated type.
+   * <p>If true, the single member must not be an array.
    */
   boolean unwrapValue() default true;
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
index c08ccc390..430838e83 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
@@ -23,7 +23,7 @@
  * A base component upon which fragment's components may depend.  Activity-level components
  * should extend this component.
  */
-@PerActivity // Subtypes of ActivityComponent should be decorated with @PerActivity.
+@PerActivity // Subtypes of AbstractActivityComponent should be decorated with @PerActivity.
 @Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
 public interface AbstractActivityComponent {
   Activity activity(); // Expose the activity to sub-graphs.
diff --git a/pom.xml b/pom.xml
index 840752f68..940176873 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,7 +46,8 @@
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.5.0</javawriter.version>
-    <auto.common.version>0.4</auto.common.version>
+    <auto.common.version>1.0-SNAPSHOT</auto.common.version>
+    <auto.factory.version>1.0-SNAPSHOT</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
     <guava.version>18.0</guava.version>
diff --git a/util/mvn-deploy.sh b/util/mvn-deploy.sh
index c812b1378..ec4b7a0d2 100755
--- a/util/mvn-deploy.sh
+++ b/util/mvn-deploy.sh
@@ -3,9 +3,8 @@ if [ $# -lt 1 ]; then
   echo "usage $0 <ssl-key> [<param> ...]"
   exit 1;
 fi
-key=${1}
+key=$1
 shift
-params=${@}
 
 #validate key
 keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
@@ -14,7 +13,9 @@ if [ "${keystatus}" != "pub" ]; then
   echo -n "Available keys from: "
   gpg --list-keys | grep --invert-match '^sub'
 
-  exit 1
+  exit 64
 fi
 
-mvn ${params} -P '!examples' -P sonatype-oss-release clean site:jar -Dgpg.skip=false -Dgpg.keyname=${key} deploy
+mvn "$@" -P '!examples' -P sonatype-oss-release \
+    -Dgpg.skip=false -Dgpg.keyname=${key} \
+    clean site:jar deploy
