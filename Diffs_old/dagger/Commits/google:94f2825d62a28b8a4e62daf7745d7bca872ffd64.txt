diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a03782159..68da53502 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -18,7 +18,9 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -27,35 +29,27 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Provides;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.Executor;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -64,19 +58,29 @@
  */
 @AutoValue
 abstract class BindingGraph {
-  enum ModuleStrategy {
-    PASSED,
-    CONSTRUCTED,
-  }
-
   abstract ComponentDescriptor componentDescriptor();
-  abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
+  /**
+   * Returns the set of types necessary to implement the component, but are not part of the injected
+   * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
+   * {@link ProductionComponent}.
+   */
+  ImmutableSet<TypeElement> componentRequirements() {
+    return FluentIterable.from(componentDescriptor().transitiveModules())
+        .transform(new Function<ModuleDescriptor, TypeElement>() {
+          @Override public TypeElement apply(ModuleDescriptor input) {
+            return input.moduleElement();
+          }
+        })
+        .append(componentDescriptor().dependencies())
+        .append(componentDescriptor().executorDependency().asSet())
+        .toSet();
+  }
+
   static final class Factory {
     private final Elements elements;
-    private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
@@ -84,14 +88,12 @@
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
-        Types types,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
-      this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
@@ -109,7 +111,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           ImmutableSet.builder();
       ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
           ImmutableSet.builder();
-      AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
@@ -144,28 +145,15 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
         }
       }
 
-      // Collect transitive modules provisions.
-      ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
-
-      ImmutableMap.Builder<TypeElement, ModuleStrategy> transitiveModules = ImmutableMap.builder();
-      for (TypeElement module : getTransitiveModules(types, elements, moduleTypes)) {
-        transitiveModules.put(module,
-            (componentCanMakeNewInstances(module) && module.getTypeParameters().isEmpty())
-                ? ModuleStrategy.CONSTRUCTED
-                : ModuleStrategy.PASSED);
-
-        // traverse the modules, collect the bindings
-        List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
-        for (ExecutableElement moduleMethod : moduleMethods) {
-          if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            explicitProvisionBindingsBuilder.add(
-                provisionBindingFactory.forProvidesMethod(moduleMethod, module.asType()));
+      // Collect transitive module bindings.
+      for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
+        for (ContributionBinding binding : moduleDescriptor.bindings()) {
+          if (binding instanceof ProvisionBinding) {
+            explicitProvisionBindingsBuilder.add((ProvisionBinding) binding);
+          }
+          if (binding instanceof ProductionBinding) {
+            explicitProductionBindingsBuilder.add((ProductionBinding) binding);
           }
-          if (isAnnotationPresent(moduleMethod, Produces.class)) {
-            explicitProductionBindingsBuilder.add(
-                productionBindingFactory.forProducesMethod(moduleMethod, module.asType()));
-           }
         }
       }
 
@@ -191,7 +179,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          transitiveModules.build(),
           requestResolver.getResolvedBindings(),
           subgraphsBuilder.build());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 129a3d255..2b38b5ab6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -45,7 +45,6 @@
 import java.util.Formatter;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
@@ -392,7 +391,7 @@ private boolean validateMembersInjectionBinding(
      */
     private void validateDependencyScopes(BindingGraph subject) {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Optional<AnnotationMirror> scope = subject.componentDescriptor().scope();
+      Optional<AnnotationMirror> scope = descriptor.scope();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (scope.isPresent()) {
         // Dagger 1.x scope compatibility requires this be suppress-able.
@@ -449,18 +448,13 @@ private void validateBuilders(BindingGraph subject) {
         return;
       }
 
-      Set<TypeElement> allDependents =
-          Sets.union(
-              Sets.union(
-                  subject.transitiveModules().keySet(),
-                  componentDesc.dependencies()),
-              componentDesc.executorDependency().asSet());
+      Set<TypeElement> allDependents = subject.componentRequirements();
       Set<TypeElement> requiredDependents =
           Sets.filter(allDependents, new Predicate<TypeElement>() {
             @Override public boolean apply(TypeElement input) {
               return !Util.componentCanMakeNewInstances(input);
             }
-          });    
+          });
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
@@ -480,7 +474,7 @@ private void validateBuilders(BindingGraph subject) {
             spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());    
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
         reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
             spec.builderDefinitionType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 6c514f99c..906be8a57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -31,8 +31,10 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -51,6 +53,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
@@ -84,7 +87,7 @@
     Class<? extends Annotation> annotationType() {
       return annotationType;
     }
-    
+
     Class<? extends Annotation> builderAnnotationType() {
       return builderType;
     }
@@ -105,6 +108,26 @@
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  abstract ImmutableSet<ModuleDescriptor> modules();
+
+  ImmutableSet<ModuleDescriptor> transitiveModules() {
+    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
+    for (ModuleDescriptor module : modules()) {
+      addTransitiveModules(transitiveModules, module);
+    }
+    return ImmutableSet.copyOf(transitiveModules);
+  }
+
+  private static Set<ModuleDescriptor> addTransitiveModules(
+      Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
+    if (transitiveModules.add(module)) {
+      for (ModuleDescriptor includedModule : module.includedModules()) {
+        addTransitiveModules(transitiveModules, includedModule);
+      }
+    }
+    return transitiveModules;
+  }
+
   /**
    * An index of the type to which this component holds a reference (the type listed in
    * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the
@@ -153,9 +176,9 @@
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
   }
-  
+
   @AutoValue
-  static abstract class BuilderSpec {    
+  static abstract class BuilderSpec {
     abstract TypeElement builderDefinitionType();
     abstract Map<TypeElement, ExecutableElement> methodMap();
     abstract ExecutableElement buildMethod();
@@ -166,11 +189,17 @@
     private final Elements elements;
     private final Types types;
     private final DependencyRequest.Factory dependencyRequestFactory;
+    private final ModuleDescriptor.Factory moduleDescriptorFactory;
 
-    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(
+        Elements elements,
+        Types types,
+        DependencyRequest.Factory dependencyRequestFactory,
+        ModuleDescriptor.Factory moduleDescriptorFactory) {
       this.elements = elements;
       this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.moduleDescriptorFactory = moduleDescriptorFactory;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -210,6 +239,11 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
               ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
               : Optional.<TypeElement>absent();
 
+      ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
+      for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
+        modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
+      }
+
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
 
@@ -237,14 +271,14 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
             break;
           default: // nothing special to do for other methods.
         }
-        
+
       }
-      
+
       ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
           ? ImmutableList.<DeclaredType>of()
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
-          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));        
+          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
@@ -252,6 +286,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
+          modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 046b70cd6..1584945ae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -33,7 +33,6 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.google.common.collect.Sets.SetView;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.MembersInjector;
@@ -273,11 +272,7 @@ private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(
-                Sets.union(
-                    input.transitiveModules().keySet(),
-                    input.componentDescriptor().dependencies()),
-                input.componentDescriptor().executorDependency().asSet()),
+            input.componentRequirements(),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -362,14 +357,8 @@ private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
 
   /** Returns true if the graph has any dependents that can't be automatically constructed. */
   private boolean requiresUserSuppliedDependents(BindingGraph input) {
-    Set<TypeElement> allDependents =
-        Sets.union(
-            Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
-            input.componentDescriptor().executorDependency().asSet());
     Set<TypeElement> userRequiredDependents =
-        Sets.filter(allDependents, new Predicate<TypeElement>() {
+        Sets.filter(input.componentRequirements(), new Predicate<TypeElement>() {
           @Override public boolean apply(TypeElement input) {
             return !Util.componentCanMakeNewInstances(input);
           }
@@ -566,7 +555,6 @@ private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFacto
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
       TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
-      verify(subgraph.transitiveModules().containsKey(moduleTypeElement));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
       if (!componentContributionFields.containsKey(moduleTypeElement)) {
         String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
@@ -590,8 +578,12 @@ private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFacto
       }
     }
 
-    SetView<TypeElement> uninitializedModules = Sets.difference(
-        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    ImmutableSet<TypeElement> uninitializedModules =
+        FluentIterable.from(subgraph.componentDescriptor().transitiveModules())
+            .transform(ModuleDescriptor.getModuleElement())
+            .filter(Predicates.not(Predicates.in(componentContributionFields.keySet())))
+            .toSet();
+
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
           moduleType.getSimpleName().toString());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 461dcd7fb..18636fe18 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -87,13 +87,22 @@
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
     Set<Element> componentElements = elementsByAnnotation.get(Component.class);
 
-    return componentDescriptors(
-        componentElements,
-        builderReportsByComponent,
-        subcomponentElements,
-        reportsBySubcomponent,
-        subcomponentBuilderElements,
-        builderReportsBySubcomponent);
+    ImmutableSet.Builder<ComponentDescriptor> builder = ImmutableSet.builder();
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ComponentValidationReport report = componentValidator.validate(
+          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      if (isClean(
+          report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
+        try {
+          builder.add(componentDescriptorFactory.forComponent(componentTypeElement));
+        } catch (TypeNotPresentException e) {
+          // just skip it and get it later
+        }
+      }
+    }
+    return builder.build();
   }
 
   private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
@@ -133,28 +142,6 @@
     return reportsBySubcomponent;
   }
 
-  private ImmutableSet<ComponentDescriptor> componentDescriptors(
-      Set<Element> componentElements,
-      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
-      Set<Element> subcomponentElements,
-      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
-      Set<Element> subcomponentBuilderElements,
-      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
-    ImmutableSet.Builder<ComponentDescriptor> componentDescriptors = ImmutableSet.builder();
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ComponentValidationReport report =
-          componentValidator.validate(
-              componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      if (isClean(
-          report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
-        componentDescriptors.add(componentDescriptorFactory.forComponent(componentTypeElement));
-      }
-    }
-    return componentDescriptors.build();
-  }
-
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
    * referenced subcomponent reports & subcomponent builder reports are clean.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 35112668c..3152c3fd1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -126,12 +126,19 @@ public SourceVersion getSupportedSourceVersion() {
     this.injectBindingRegistry = new InjectBindingRegistry(
         elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
 
-    ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
+    ModuleDescriptor.Factory moduleDescriptorFactory = new ModuleDescriptor.Factory(
+        elements, provisionBindingFactory, productionBindingFactory);
+
+    ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
+        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements, types, injectBindingRegistry, keyFactory,
-        dependencyRequestFactory, provisionBindingFactory, productionBindingFactory);
+        elements,
+        injectBindingRegistry,
+        keyFactory,
+        dependencyRequestFactory,
+        provisionBindingFactory,
+        productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 469b37591..a2a5eac22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -72,7 +72,7 @@
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
-  
+
   private ComponentValidator(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -97,7 +97,7 @@ private ComponentValidator(Elements elements,
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
-  
+
   static ComponentValidator createForComponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -109,7 +109,7 @@ static ComponentValidator createForComponent(Elements elements,
         subcomponentValidator,
         subcomponentBuilderValidator);
   }
-  
+
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
@@ -119,7 +119,7 @@ static ComponentValidator createForSubcomponent(Elements elements,
         moduleValidator,
         subcomponentBuilderValidator);
   }
-  
+
   @AutoValue
   static abstract class ComponentValidationReport {
     abstract Set<Element> referencedSubcomponents();
@@ -140,7 +140,7 @@ public ComponentValidationReport validate(final TypeElement subject,
       builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
           componentType.annotationType().getSimpleName()), subject);
     }
-    
+
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
@@ -148,7 +148,7 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
           subject);
     }
-    
+
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
     // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
@@ -212,7 +212,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         }
       }
     }
-    
+
     for (Map.Entry<Element, Collection<ExecutableElement>> entry :
         referencedSubcomponents.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
@@ -228,7 +228,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         getAnnotationMirror(subject, componentType.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
-    
+
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
     // TODO(sameb): If subcomponents refer to each other and both aren't in
@@ -243,7 +243,7 @@ public ComponentValidationReport validate(final TypeElement subject,
       builder.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
-    
+
     return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
         builder.build());
   }
@@ -257,6 +257,9 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     ImmutableSet<TypeElement> moduleTypes =
         MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
 
+    // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
+    // subcomponents and their modules separately from how it is done in ComponentDescriptor and
+    // ModuleDescriptor
     ImmutableSet<TypeElement> transitiveModules =
         getTransitiveModules(types, elements, moduleTypes);
 
@@ -334,7 +337,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
       builder.addItem(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
-    
+
     // If we haven't already validated the subcomponent builder itself, validate it now.
     TypeElement builderElement = MoreTypes.asTypeElement(returnType);
     if (!validatedSubcomponentBuilders.contains(builderElement)) {
@@ -345,7 +348,6 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  
   private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
       final Class<? extends Annotation> annotation) {
     return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 55649f750..50e343543 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -156,7 +156,10 @@ protected TypeMirror defaultAction(Object o, Void p) {
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
+   *
+   * @deprecated Use {@link ComponentDescriptor#transitiveModules}.
    */
+  @Deprecated
   static ImmutableSet<TypeElement> getTransitiveModules(
       Types types, Elements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
new file mode 100644
index 000000000..f5e33b59d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -0,0 +1,122 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+@AutoValue
+abstract class ModuleDescriptor {
+  static final Function<ModuleDescriptor, TypeElement> getModuleElement() {
+    return new Function<ModuleDescriptor, TypeElement>() {
+      @Override public TypeElement apply(ModuleDescriptor input) {
+        return input.moduleElement();
+      }
+    };
+  }
+
+  abstract AnnotationMirror moduleAnnotation();
+
+  abstract TypeElement moduleElement();
+
+  abstract ImmutableSet<ModuleDescriptor> includedModules();
+
+  abstract ImmutableSet<? extends ContributionBinding> bindings();
+
+  enum DefaultCreationStrategy {
+    PASSED,
+    CONSTRUCTED,
+  }
+
+  abstract DefaultCreationStrategy defaultCreationStrategy();
+
+  static final class Factory {
+    private final Elements elements;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final ProductionBinding.Factory productionBindingFactory;
+
+    Factory(
+        Elements elements,
+        ProvisionBinding.Factory provisionBindingFactory,
+        ProductionBinding.Factory productionBindingFactory) {
+      this.elements = elements;
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.productionBindingFactory = productionBindingFactory;
+    }
+
+    ModuleDescriptor create(TypeElement moduleElement) {
+      AnnotationMirror moduleAnnotation = getModuleAnnotation(moduleElement).get();
+
+      ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
+      for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
+        if (isAnnotationPresent(moduleMethod, Provides.class)) {
+          bindings.add(
+              provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement.asType()));
+        }
+        if (isAnnotationPresent(moduleMethod, Produces.class)) {
+          bindings.add(
+              productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
+        }
+      }
+
+      DefaultCreationStrategy defaultCreationStrategy =
+          (componentCanMakeNewInstances(moduleElement)
+              && moduleElement.getTypeParameters().isEmpty())
+                  ? ModuleDescriptor.DefaultCreationStrategy.CONSTRUCTED
+                  : ModuleDescriptor.DefaultCreationStrategy.PASSED;
+
+      return new AutoValue_ModuleDescriptor(
+          moduleAnnotation,
+          moduleElement,
+          ImmutableSet.copyOf(
+              collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
+          bindings.build(),
+          defaultCreationStrategy);
+    }
+
+    private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
+      return getAnnotationMirror(moduleElement, Module.class)
+          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+    }
+
+    private Set<ModuleDescriptor> collectIncludedModules(
+        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+      TypeMirror superclass = moduleElement.getSuperclass();
+      if (!superclass.getKind().equals(NONE)) {
+        verify(superclass.getKind().equals(DECLARED));
+        TypeElement superclassElement = MoreTypes.asTypeElement(superclass);
+        if (!superclassElement.getQualifiedName().contentEquals(Object.class.getCanonicalName())) {
+          collectIncludedModules(includedModules, superclassElement);
+        }
+      }
+      Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
+      if (moduleAnnotation.isPresent()) {
+        for (TypeMirror moduleIncludesType : getModuleIncludes(moduleAnnotation.get())) {
+          includedModules.add(create(MoreTypes.asTypeElement(moduleIncludesType)));
+        }
+      }
+      return includedModules;
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index ff5df098b..1eca18f68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -23,6 +23,8 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSet.Builder;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
@@ -40,6 +42,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -136,7 +139,8 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
 
     for (Element enclosed : typeElement.getEnclosedElements()) {
       if (enclosed.getKind().equals(CONSTRUCTOR)
-          && ((ExecutableElement) enclosed).getParameters().isEmpty()) {
+          && ((ExecutableElement) enclosed).getParameters().isEmpty()
+          && !enclosed.getModifiers().contains(PRIVATE)) {
         return true;
       }
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f204258b1..f7e79da29 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -631,11 +631,11 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "  public static final class Builder {",
         "    private TestModule testModule;",
-        "    private DepModule depModule;",
-        "    private AlwaysIncluded alwaysIncluded;",
         "    private ParentTestIncluded parentTestIncluded;",
-        "    private RefByDep refByDep;",
+        "    private AlwaysIncluded alwaysIncluded;",
+        "    private DepModule depModule;",
         "    private ParentDepIncluded parentDepIncluded;",
+        "    private RefByDep refByDep;",
         "",
         "    private Builder() {",
         "    }",
@@ -644,21 +644,21 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "      if (testModule == null) {",
         "        this.testModule = new TestModule();",
         "      }",
-        "      if (depModule == null) {",
-        "        this.depModule = new DepModule();",
+        "      if (parentTestIncluded == null) {",
+        "        this.parentTestIncluded = new ParentTestIncluded();",
         "      }",
         "      if (alwaysIncluded == null) {",
         "        this.alwaysIncluded = new AlwaysIncluded();",
         "      }",
-        "      if (parentTestIncluded == null) {",
-        "        this.parentTestIncluded = new ParentTestIncluded();",
-        "      }",
-        "      if (refByDep == null) {",
-        "        this.refByDep = new RefByDep();",
+        "      if (depModule == null) {",
+        "        this.depModule = new DepModule();",
         "      }",
         "      if (parentDepIncluded == null) {",
         "        this.parentDepIncluded = new ParentDepIncluded();",
         "      }",
+        "      if (refByDep == null) {",
+        "        this.refByDep = new RefByDep();",
+        "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
@@ -670,11 +670,11 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "      return this;",
         "    }",
         "",
-        "    public Builder depModule(DepModule depModule) {",
-        "      if (depModule == null) {",
-        "        throw new NullPointerException(\"depModule\");",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      if (parentTestIncluded == null) {",
+        "        throw new NullPointerException(\"parentTestIncluded\");",
         "      }",
-        "      this.depModule = depModule;",
+        "      this.parentTestIncluded = parentTestIncluded;",
         "      return this;",
         "    }",
         "",
@@ -686,19 +686,11 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "      return this;",
         "    }",
         "",
-        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
-        "      if (parentTestIncluded == null) {",
-        "        throw new NullPointerException(\"parentTestIncluded\");",
-        "      }",
-        "      this.parentTestIncluded = parentTestIncluded;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder refByDep(RefByDep refByDep) {",
-        "      if (refByDep == null) {",
-        "        throw new NullPointerException(\"refByDep\");",
+        "    public Builder depModule(DepModule depModule) {",
+        "      if (depModule == null) {",
+        "        throw new NullPointerException(\"depModule\");",
         "      }",
-        "      this.refByDep = refByDep;",
+        "      this.depModule = depModule;",
         "      return this;",
         "    }",
         "",
@@ -709,6 +701,14 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "      this.parentDepIncluded = parentDepIncluded;",
         "      return this;",
         "    }",
+        "",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      if (refByDep == null) {",
+        "        throw new NullPointerException(\"refByDep\");",
+        "      }",
+        "      this.refByDep = refByDep;",
+        "      return this;",
+        "    }",
         "  }",
         "}");
     assertAbout(javaSources())
