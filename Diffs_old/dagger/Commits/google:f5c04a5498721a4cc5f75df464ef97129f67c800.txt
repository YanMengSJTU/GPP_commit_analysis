diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 2f6240451..d17a65b82 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -55,6 +55,7 @@
 import dagger.Subcomponent;
 import dagger.model.DependencyRequest;
 import dagger.model.Scope;
+import dagger.producers.CancellationPolicy;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import dagger.releasablereferences.CanReleaseReferences;
@@ -369,6 +370,16 @@ private static boolean doesComponentMethodMatch(
   private static final Traverser<ComponentDescriptor> SUBCOMPONENT_TRAVERSER =
       Traverser.forTree(ComponentDescriptor::subcomponents);
 
+  /**
+   * Returns the {@link CancellationPolicy} for this component, or an empty optional if either the
+   * component is not a production component or no {@code CancellationPolicy} annotation is present.
+   */
+  Optional<CancellationPolicy> cancellationPolicy() {
+    return kind().isProducer()
+        ? Optional.ofNullable(componentDefinitionType().getAnnotation(CancellationPolicy.class))
+        : Optional.empty();
+  }
+
   /** A function that returns all {@link #scopes()} of its input. */
   @AutoValue
   abstract static class ComponentMethodDescriptor {
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index 01d70a971..83216faa7 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -32,6 +32,8 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ProducerNodeInstanceBindingExpression.MAY_INTERRUPT_IF_RUNNING;
+import static dagger.producers.CancellationPolicy.Propagation.IGNORE;
+import static dagger.producers.CancellationPolicy.Propagation.PROPAGATE;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -51,6 +53,7 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.producers.CancellationPolicy;
 import dagger.producers.internal.CancellationListener;
 import java.util.List;
 import java.util.Optional;
@@ -278,9 +281,17 @@ private void addCancellationListenerImplementation() {
       }
     }
 
+    addCancelParentStatement(methodBuilder);
+
     generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
   }
 
+  protected void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
+    // Does nothing by default. Overridden in subclass(es) to add a statement if and only if the
+    // component being generated is a concrete subcomponent implementation with a parent that allows
+    // cancellation to propagate to it from subcomponents.
+  }
+
   private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
     return MethodSignature.forComponentMethod(
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
@@ -578,6 +589,27 @@ private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
     private DeclaredType parentType() {
       return asDeclared(parent.graph.componentType().asType());
     }
+
+    @Override
+    protected void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
+      if (shouldPropagateCancellationToParent()) {
+        methodBuilder.addStatement(
+            "$T.this.$L($L)",
+            parent.generatedComponentModel.name(),
+            CANCELLATION_LISTENER_METHOD_NAME,
+            MAY_INTERRUPT_IF_RUNNING);
+      }
+    }
+
+    private boolean shouldPropagateCancellationToParent() {
+      return parent
+          .generatedComponentModel
+          .componentDescriptor()
+          .cancellationPolicy()
+          .map(CancellationPolicy::fromSubcomponents)
+          .orElse(IGNORE)
+          .equals(PROPAGATE);
+    }
   }
 
   /** Builds the model for abstract implementations of a subcomponent. */
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 51adcbe53..f4a779aaf 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -18,6 +18,7 @@
 
 import static com.google.auto.common.MoreElements.asType;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Verify.verify;
@@ -37,7 +38,6 @@
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.FluentIterable;
@@ -54,6 +54,7 @@
 import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
+import dagger.producers.CancellationPolicy;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -127,6 +128,12 @@ public ComponentValidationReport validate(
     ComponentDescriptor.Kind componentKind =
         ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
 
+    if (isAnnotationPresent(subject, CancellationPolicy.class) && !componentKind.isProducer()) {
+      report.addError(
+          "@CancellationPolicy may only be applied to production components and subcomponents",
+          subject);
+    }
+
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       report.addError(
@@ -388,8 +395,7 @@ private void validateSubcomponentMethod(
                 @Override
                 public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
                   for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
-                    if (MoreElements.isAnnotationPresent(
-                        t.asElement(), moduleKind.moduleAnnotation())) {
+                    if (isAnnotationPresent(t.asElement(), moduleKind.moduleAnnotation())) {
                       return Optional.of(MoreTypes.asTypeElement(t));
                     }
                   }
diff --git a/java/dagger/producers/CancellationPolicy.java b/java/dagger/producers/CancellationPolicy.java
new file mode 100644
index 000000000..70f4a43d8
--- /dev/null
+++ b/java/dagger/producers/CancellationPolicy.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a production component or subcomponent to specify its policy when a child component is
+ * cancelled.
+ *
+ * <p>When a future returned from an entry point on a production component is cancelled, the
+ * component is cancelled: all producers in the component (including those for other entry points)
+ * are cancelled.
+ *
+ * <p>When a child component is cancelled, its parent component <i>is not</i> cancelled unless the
+ * parent component is annotated with {@code @CancellationPolicy(fromSubcomponents = PROPAGATE)}. If
+ * that parent component has a parent (the grandparent of the cancelled child component), it will
+ * not be cancelled unless it also has a {@code @CancellationPolicy} annotation allowing
+ * cancellation to propagate to it from subcomponents.
+ */
+@Documented
+@Target(TYPE)
+@Retention(CLASS)
+@Beta
+public @interface CancellationPolicy {
+  /**
+   * Defines whether the annotated production component is cancelled when a child component is
+   * cancelled.
+   *
+   * <p>The default, if no cancellation policy annotation is provided, is {@link
+   * Propagation#IGNORE}.
+   */
+  Propagation fromSubcomponents();
+
+  /**
+   * Enumeration of the options for what happens to a parent component when one of its child
+   * components is cancelled.
+   */
+  enum Propagation {
+    /** Cancel the annotated component when a child component is cancelled. */
+    PROPAGATE,
+
+    /** Do not cancel the annotated component when a child component is cancelled. */
+    IGNORE
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java b/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java
new file mode 100644
index 000000000..936072a48
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationPolicyTest.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.BindsInstance;
+import dagger.producers.CancellationPolicy;
+import dagger.producers.CancellationPolicy.Propagation;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for parent production components with a {@code CancellationPolicy} that allows subcomponent
+ * cancellation to propagate to them
+ */
+@RunWith(JUnit4.class)
+public final class CancellationPolicyTest {
+
+  @ProducerModule(subcomponents = Child.class)
+  static class ParentModule {
+    private final ProducerTester tester;
+
+    ParentModule(ProducerTester tester) {
+      this.tester = tester;
+    }
+
+    @Produces
+    @Named("a")
+    ListenableFuture<String> produceA() {
+      return tester.start("a");
+    }
+  }
+
+  interface Parent {
+    @Named("a")
+    ListenableFuture<String> a();
+
+    Child.Builder childBuilder();
+
+    interface Builder<P extends Parent, B extends Builder<P, B>> {
+      B module(ParentModule module);
+
+      @BindsInstance
+      B executor(@Production Executor executor);
+
+      P build();
+    }
+  }
+
+  @CancellationPolicy(fromSubcomponents = Propagation.PROPAGATE)
+  @ProductionComponent(modules = ParentModule.class)
+  interface PropagatingParent extends Parent {
+    @ProductionComponent.Builder
+    interface Builder extends Parent.Builder<PropagatingParent, Builder> {}
+  }
+
+  @CancellationPolicy(fromSubcomponents = Propagation.IGNORE)
+  @ProductionComponent(modules = ParentModule.class)
+  interface NonPropagatingParent extends Parent {
+    @ProductionComponent.Builder
+    interface Builder extends Parent.Builder<NonPropagatingParent, Builder> {}
+  }
+
+  @ProducerModule
+  static class ChildModule {
+    private final ProducerTester tester;
+
+    ChildModule(ProducerTester tester) {
+      this.tester = tester;
+    }
+
+    @Produces
+    @Named("b")
+    ListenableFuture<String> b(@Named("a") String a) {
+      return tester.start("b");
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildModule.class)
+  interface Child {
+    @Named("b")
+    ListenableFuture<String> b();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder module(ChildModule module);
+
+      Child build();
+    }
+  }
+
+  private final ProducerTester tester = new ProducerTester();
+
+  @Test
+  public void propagatingParent_childCancellationPropagatesToParent() {
+    PropagatingParent parent =
+        DaggerCancellationPolicyTest_PropagatingParent.builder()
+            .module(new ParentModule(tester))
+            .executor(MoreExecutors.directExecutor())
+            .build();
+    ListenableFuture<String> a = parent.a();
+
+    Child child = parent.childBuilder().module(new ChildModule(tester)).build();
+
+    ListenableFuture<String> b = child.b();
+
+    tester.assertStarted("a").only();
+
+    assertThat(a.isDone()).isFalse();
+    assertThat(b.isDone()).isFalse();
+
+    assertThat(b.cancel(true)).isTrue();
+    assertThat(b.isCancelled()).isTrue();
+
+    tester.assertCancelled("a");
+
+    assertThat(a.isCancelled()).isTrue();
+  }
+
+  @Test
+  public void nonPropagatingParent_childCancellationDoesNotPropagateToParent() throws Exception {
+    // This test is basically just checking that when the parent has fromSubcomponents = IGNORE, it
+    // behaves the same as having no @CancellationPolicy at all (as tested in
+    // ProducerSubcomponentCancellationTester)
+    NonPropagatingParent parent =
+        DaggerCancellationPolicyTest_NonPropagatingParent.builder()
+            .module(new ParentModule(tester))
+            .executor(MoreExecutors.directExecutor())
+            .build();
+    ListenableFuture<String> a = parent.a();
+
+    Child child = parent.childBuilder().module(new ChildModule(tester)).build();
+
+    ListenableFuture<String> b = child.b();
+
+    tester.assertStarted("a").only();
+
+    assertThat(a.isDone()).isFalse();
+    assertThat(b.isDone()).isFalse();
+
+    assertThat(b.cancel(true)).isTrue();
+    assertThat(b.isCancelled()).isTrue();
+
+    tester.assertNotCancelled("a");
+
+    assertThat(a.isDone()).isFalse();
+
+    tester.complete("a");
+    assertThat(a.isDone()).isTrue();
+    assertThat(a.get(1, MILLISECONDS)).isEqualTo("completed");
+
+    tester.assertNotStarted("b");
+  }
+}
