diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
index 0e01f5f7e..c50e3451b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -16,22 +16,24 @@
 package test;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
 class GenericParent<X, Y> {
   
-  X registeredX;
+  Provider<X> registeredX;
   Y registeredY;
   B registeredB;
   
-  
   @Inject GenericParent() {}
   
-  @Inject X x;
+  @Inject Provider<X> x;
   @Inject Y y;
   @Inject B b;
   
-  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject
+  void registerX(Provider<X> x) {
+    this.registeredX = x;
+  }
   @Inject void registerY(Y y) { this.registeredY = y; }
   @Inject void registerB(B b) { this.registeredB = b; }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 8c202d320..a97a59eb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -59,14 +59,11 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
@@ -800,7 +797,7 @@ private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBin
 
     ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
     if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
-      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
       initializationSnippets.add(
           initializeMember(
               resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
@@ -814,7 +811,7 @@ private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindi
 
     MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
     if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(initializeDelegateFactoriesForUninitializedDependencies(binding));
       initializationSnippets.add(
           initializeMember(
               resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)));
@@ -823,16 +820,17 @@ private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindi
     return Snippet.concat(initializationSnippets.build());
   }
 
-  private Snippet initializeDelegateFactories(Binding binding) {
+  /**
+   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
+   * because of a dependency cycle.
+   */
+  private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    for (Collection<DependencyRequest> requestsForKey :
-        indexDependenciesByUnresolvedKey(types, binding.dependencies()).asMap().values()) {
-      BindingKey dependencyKey =
-          Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                  .toSet());
+    for (BindingKey dependencyKey :
+        FluentIterable.from(binding.implicitDependencies())
+            .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+            .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
         initializationSnippets.add(
@@ -960,7 +958,8 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
           }
-          parameters.addAll(getDependencyParameters(binding, DependencyRequestMapper.FOR_PROVIDER));
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER));
 
           Snippet factorySnippet =
               Snippet.format(
@@ -1006,7 +1005,8 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           parameters.add(
               getComponentContributionSnippet(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(getDependencyParameters(binding, DependencyRequestMapper.FOR_PRODUCER));
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PRODUCER));
 
           return Snippet.format(
               "new %s(%s)",
@@ -1041,7 +1041,7 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
       case INJECT_MEMBERS:
         List<Snippet> parameters =
-            getDependencyParameters(binding, DependencyRequestMapper.FOR_PROVIDER);
+            getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER);
         return Snippet.format(
             "%s.create(%s)",
             membersInjectorNameForType(binding.bindingElement()),
@@ -1051,56 +1051,37 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     }
   }
 
-  private List<Snippet> getDependencyParameters(
+  /**
+   * The snippets that represent factory arguments for the dependencies of a binding.
+   */
+  private List<Snippet> getDependencyParameterSnippets(
       Binding binding, DependencyRequestMapper dependencyRequestMapper) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    Set<Key> keysSeen = new HashSet<>();
-    for (Collection<DependencyRequest> requestsForKey :
-        indexDependenciesByUnresolvedKey(types, binding.implicitDependencies()).asMap().values()) {
-      Set<BindingKey> requestedBindingKeys = new HashSet<>();
-      for (DependencyRequest dependencyRequest : requestsForKey) {
-        Element requestElement = dependencyRequest.requestElement();
-        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
-        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
-        if (keysSeen.add(key)) {
-          requestedBindingKeys.add(dependencyRequest.bindingKey());
-        }
-      }
-      if (!requestedBindingKeys.isEmpty()) {
-        Class<?> frameworkClass = dependencyRequestMapper.getFrameworkClass(requestsForKey);
-        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
-        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
-        Snippet frameworkSnippet = getMemberSelect(key).getSnippetWithRawTypeCastFor(name);
-        if (resolvedBindings.frameworkClass().equals(Provider.class)
-            && frameworkClass.equals(Producer.class)) {
-          parameters.add(
-              Snippet.format(
-                  "%s.producerFromProvider(%s)",
-                  ClassName.fromClass(Producers.class),
-                  frameworkSnippet));
-        } else {
-          parameters.add(frameworkSnippet);
-        }
+    for (Collection<DependencyRequest> dependencyRequestsForUnresolvedKey :
+        indexDependenciesByUnresolvedKey(binding).asMap().values()) {
+      BindingKey requestedKey =
+          Iterables.getOnlyElement(
+              FluentIterable.from(dependencyRequestsForUnresolvedKey)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .toSet());
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetWithRawTypeCastFor(name);
+      if (resolvedBindings.frameworkClass().equals(Provider.class)
+          && dependencyRequestMapper
+              .getFrameworkClass(dependencyRequestsForUnresolvedKey)
+              .equals(Producer.class)) {
+        parameters.add(
+            Snippet.format(
+                "%s.producerFromProvider(%s)",
+                ClassName.fromClass(Producers.class),
+                frameworkSnippet));
+      } else {
+        parameters.add(frameworkSnippet);
       }
     }
     return parameters.build();
   }
 
-  // TODO(dpb): Investigate use of asMemberOf here. Why aren't the dependency requests already
-  // resolved?
-  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
-    TypeMirror requestType = requestElement.asType();
-    if (requestType.getKind() == TypeKind.TYPEVAR) {
-      return types.asMemberOf(
-          MoreTypes.asDeclared(bindingTypeElement.asType()),
-          (requestElement.getKind() == ElementKind.PARAMETER)
-              ? MoreTypes.asElement(requestType)
-              : requestElement);
-    } else {
-      return requestType;
-    }
-  }
-
   private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
     MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
     ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index e53fc2de7..26d3b61d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -142,10 +142,11 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   }
 
   /**
-   * Returns true if this is a binding for a key that has a different type parameter list than the
-   * element it's providing.
+   * if this binding's key's type parameters are different from those of the
+   * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
+   * unresolved type.
    */
-  abstract boolean hasNonDefaultTypeParameters();
+  abstract Optional<? extends Binding> unresolved();
 
   /**
    * The scope of this binding.
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 5ba5635cd..b12a854d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import dagger.Lazy;
 import javax.inject.Provider;
@@ -37,12 +38,15 @@ public String apply(DependencyRequest dependency) {
       return dependency.overriddenVariableName().get();
     }
     String variableName = dependency.requestElement().getSimpleName().toString();
+    if (Ascii.isUpperCase(variableName.charAt(0))) {
+      variableName = toLowerCamel(variableName);
+    }
     switch (dependency.kind()) {
       case INSTANCE:
         return variableName;
       case LAZY:
         return variableName.startsWith("lazy") && !variableName.equals("lazy")
-            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            ? toLowerCamel(variableName.substring(4))
             : variableName;
       case PROVIDER:
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
@@ -54,7 +58,7 @@ public String apply(DependencyRequest dependency) {
             : variableName;
       case PRODUCED:
         return variableName.startsWith("produced") && !variableName.equals("produced")
-            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            ? toLowerCamel(variableName.substring(8))
             : variableName;
       case PRODUCER:
         return variableName.endsWith("Producer") && !variableName.equals("Producer")
@@ -64,4 +68,8 @@ public String apply(DependencyRequest dependency) {
         throw new AssertionError();
     }
   }
+
+  private String toLowerCamel(String name) {
+    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 2a99d529a..65419786a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MembersInjector;
 import dagger.internal.Factory;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -103,7 +102,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.unresolved().isPresent());
 
     TypeMirror keyType =
         binding.contributionType().equals(ContributionType.MAP)
@@ -160,19 +159,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    if (binding.membersInjectionRequest().isPresent()) {
-      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, providedTypeName);
-      factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
-      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.get().body()
-          .addSnippet("assert membersInjector != null;")
-          .addSnippet("this.membersInjector = membersInjector;");
-    }
-
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
@@ -269,7 +257,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     } else if (binding.membersInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
-      getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
+      getMethodWriter
+          .body()
+          .addSnippet(
+              "%s.injectMembers(instance);",
+              fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
       getMethodWriter.body().addSnippet("return instance;");
     } else {
       getMethodWriter.body()
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 664d2db57..70c548c97 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -71,7 +71,7 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
-        checkState(!binding.hasNonDefaultTypeParameters());
+        checkState(!binding.unresolved().isPresent());
         generator.generate(binding);
         materializedBindingKeys.add(binding.key());
       }
@@ -109,7 +109,7 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean warnIfNotAlr
 
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
-      return !binding.hasNonDefaultTypeParameters()
+      return !binding.unresolved().isPresent()
           && elements.getTypeElement(factoryName.canonicalName()) == null
           && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
@@ -120,7 +120,7 @@ private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
     private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.hasNonDefaultTypeParameters()
+      if (binding.unresolved().isPresent()
           || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
@@ -174,9 +174,9 @@ private ProvisionBinding registerBinding(
       ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
     ClassName factoryName = generatedClassNameForBinding(binding);
     provisionBindings.tryRegisterBinding(binding, factoryName, warnIfNotAlreadyGenerated);
-    if (binding.hasNonDefaultTypeParameters()) {
+    if (binding.unresolved().isPresent()) {
       provisionBindings.tryToGenerateBinding(
-          provisionBindingFactory.unresolve(binding), factoryName, warnIfNotAlreadyGenerated);
+          binding.unresolved().get(), factoryName, warnIfNotAlreadyGenerated);
     }
     return binding;
   }
@@ -204,11 +204,9 @@ private MembersInjectionBinding registerBinding(
     ClassName membersInjectorName = generatedClassNameForBinding(binding);
     membersInjectionBindings.tryRegisterBinding(
         binding, membersInjectorName, warnIfNotAlreadyGenerated);
-    if (binding.hasNonDefaultTypeParameters()) {
+    if (binding.unresolved().isPresent()) {
       membersInjectionBindings.tryToGenerateBinding(
-          membersInjectionBindingFactory.unresolve(binding),
-          membersInjectorName,
-          warnIfNotAlreadyGenerated);
+          binding.unresolved().get(), membersInjectorName, warnIfNotAlreadyGenerated);
     }
     return binding;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 398f4bddc..53d15ee8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -61,11 +61,19 @@
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
+  @Override
+  abstract Optional<MembersInjectionBinding> unresolved();
+
   @Override
   TypeElement bindingElement() {
     return MoreElements.asType(super.bindingElement());
   }
-        
+
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    return dependencies();
+  }
+
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
@@ -166,13 +174,6 @@ private InjectionSite injectionSiteForInjectField(
                   containingType, fieldElement, resolved)));
     }
 
-    /** Returns an unresolved version of this binding. */
-    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
-      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
-    }
-
     /** Returns true if the type has some injected members in itself or any of its super classes. */
     boolean hasInjectedMembers(DeclaredType declaredType) {
       return !getInjectionSites(declaredType).isEmpty();
@@ -224,9 +225,12 @@ public Key apply(DeclaredType superclass) {
           SourceElement.forElement(typeElement),
           key,
           dependencies,
-          dependencies,
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(typeElement, key.type(), types),
+          hasNonDefaultTypeParameters(typeElement, key.type(), types)
+              ? Optional.of(
+                  forInjectedType(
+                      MoreTypes.asDeclared(typeElement.asType()), Optional.<TypeMirror>absent()))
+              : Optional.<MembersInjectionBinding>absent(),
           injectionSites,
           parentKey);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index beb637682..46d913437 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -116,7 +116,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     Set<String> delegateMethods = new HashSet<>();
 
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters()); 
+    checkState(!binding.unresolved().isPresent());
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -144,8 +144,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "}"));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index d66a865ba..154372b77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -108,8 +108,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     constructorWriter.addModifiers(PUBLIC);
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.implicitDependencies());
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
     constructorWriter
         .body()
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 2e920d639..391d804e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -50,7 +50,12 @@
   public BindingType bindingType() {
     return BindingType.PRODUCTION;
   }
-  
+
+  @Override
+  Optional<ProductionBinding> unresolved() {
+    return Optional.absent();
+  }
+
   @Override
   Provides.Type provisionType() {
     return Provides.Type.valueOf(productionType().name());
@@ -113,7 +118,6 @@ ProductionBinding forProducesMethod(
           key,
           dependencies,
           findBindingPackage(key),
-          false,
           ConfigurationAnnotations.getNullableType(producesMethod),
           Optional.<DependencyRequest>absent(),
           kind,
@@ -136,7 +140,6 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           mapOfValueRequest.key(),
           ImmutableSet.of(implicitMapOfProducerRequest),
           findBindingPackage(mapOfValueRequest.key()),
-          false,
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
@@ -155,7 +158,6 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false,
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 2106c63e3..7b2fb5d8e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -54,12 +54,15 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
-  
+
   @Override
   public BindingType bindingType() {
     return BindingType.PROVISION;
   }
-  
+
+  @Override
+  abstract Optional<ProvisionBinding> unresolved();
+
   @Override
   abstract Scope scope();
   
@@ -77,13 +80,6 @@ public BindingType bindingType() {
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    /** Returns an unresolved version of this binding. */
-    ProvisionBinding unresolve(ProvisionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
-          Optional.<TypeMirror>absent());
-    }
-
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
      * will return a resolved binding, with the key & type resolved to the given type (using
@@ -128,11 +124,13 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           key,
           dependencies,
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
+          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
+              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
+              : Optional.<ProvisionBinding>absent(),
           scope);
     }
 
@@ -175,11 +173,11 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           key,
           dependencies,
           findBindingPackage(key),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
+          Optional.<ProvisionBinding>absent(),
           scope);
     }
     
@@ -199,11 +197,11 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           mapOfValueRequest.key(),
           ImmutableSet.of(implicitMapOfProviderRequest),
           findBindingPackage(mapOfValueRequest.key()),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
@@ -214,11 +212,11 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           Scope.unscoped());
     }
 
@@ -232,11 +230,11 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           scope);
     }
 
@@ -251,11 +249,11 @@ ProvisionBinding forSubcomponentBuilderMethod(
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
           Scope.unscoped());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 69543eca3..d5612ccaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,6 +14,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -21,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.writer.ClassName;
@@ -32,10 +35,10 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -66,71 +69,77 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   };
 
   /**
-   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
-   * to requests.  This is used when generating component's initialize()
-   * methods (and in members injectors) in order to instantiate dependent
-   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
-   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
-   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
-   * if it was referenced as {@code Foo<A>}, we need to make sure we still
-   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
-   * we would have passed a single {@code aProvider}.
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   *
+   * <p>Consider a generic type {@code Foo<T>} with a constructor {@code Foo(T t, T t1, A a, A a1)}.
+   * Its factory's {@code create} method should take only two parameters:
+   * {@code create(Provider<T> tProvider, Provider<A> aProvider)}. However, if the component
+   * initializes a factory for {@code Foo<A>}, it really has only one dependency:
+   * both arguments should be the same {@code Provider<A>}. In order to get the right number of
+   * arguments, we have to index resolved binding's dependencies by their keys in the unresolved
+   * version of the binding.
    */
-  // TODO(beder): Refactor these indexing methods so that the binding itself knows what sort of
-  // binding keys and framework classes that it needs.
+  // TODO(dpb): Move this to DependencyRequest.
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Types types, Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      BindingKey resolved = dependency.bindingKey();
-      // To get the proper unresolved type, we have to extract the proper type from the
-      // request type again (because we're looking at the actual element's type).
-      TypeMirror unresolvedType =
-          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
-      BindingKey unresolved =
-          BindingKey.create(resolved.kind(), resolved.key().withType(types, unresolvedType));
-      dependenciesByKeyBuilder.put(unresolved, dependency);
+      Binding binding) {
+    // If the binding is already fully resolved, just index the dependencies by binding key.
+    if (!binding.unresolved().isPresent()) {
+      return indexDependenciesByKey(binding, Functions.<DependencyRequest>identity());
     }
-    return dependenciesByKeyBuilder.build();
+    
+    // Index the unresolved dependencies, replacing each one with its resolved version by looking it
+    // up by request element.
+    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
+        Maps.uniqueIndex(
+            binding.implicitDependencies(),
+            new Function<DependencyRequest, Element>() {
+              @Override
+              public Element apply(DependencyRequest dependencyRequest) {
+                return dependencyRequest.requestElement();
+              }
+            });
+    return indexDependenciesByKey(
+        binding.unresolved().get(),
+        new Function<DependencyRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
+            return resolvedDependencies.get(unresolvedRequest.requestElement());
+          }
+        });
   }
 
   /**
-   * Allows dependency requests to be grouped by the key they're requesting.
-   * This is used by factory generation in order to minimize the number of parameters
-   * required in the case where a given key is requested more than once.  This expects
-   * unresolved dependency requests, otherwise we may generate factories based on
-   * a particular usage of a class as opposed to the generic types of the class.
+   * Groups a binding's dependency requests by their binding key.
+   *
+   * @param transformer applied to each dependency before inserting into the multimap
    */
-  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
-      Iterable<? extends DependencyRequest> dependencies) {
+  private static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
+      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), dependency);
+        ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : binding.implicitDependencies()) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
     }
-    return dependenciesByKeyBuilder.build();
+    return dependenciesByKeyBuilder.orderValuesBy(DEPENDENCY_ORDERING).build();
   }
 
   /**
-   * This method generates names and keys for the framework classes necessary for all of the
-   * bindings. It is responsible for the following:
+   * Generates names and keys for the factory class fields needed to hold the framework classes for
+   * all of the dependencies of {@code binding}. It is responsible for choosing a name that
+   *
    * <ul>
-   * <li>Choosing a name that associates the binding with all of the dependency requests for this
-   * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
-   * <li>Ensuring that no two bindings end up with the same name.
+   * <li>represents all of the dependency requests for this key
+   * <li>is <i>probably</i> associated with the type being bound
+   * <li>is unique within the class
    * </ul>
    *
-   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
+   * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
-      DependencyRequestMapper dependencyRequestMapper,
-      Iterable<? extends DependencyRequest> dependencies) {
+      DependencyRequestMapper dependencyRequestMapper, Binding binding) {
     ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByKey(dependencies);
+        indexDependenciesByUnresolvedKey(binding);
     Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
@@ -143,7 +152,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
           FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
-
+    
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index c915f3358..3e8fde831 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -173,34 +173,37 @@
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
-        "",
-        "  public GenericClass_Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    return new GenericClass_Factory<A, B>(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
+            "",
+            "  public GenericClass_Factory(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    assert genericClassMembersInjector != null;",
+            "    this.genericClassMembersInjector = genericClassMembersInjector;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+            "    genericClassMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    return new GenericClass_Factory<A, B>(genericClassMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -753,42 +756,44 @@
         "  @Inject AllInjections(String s) {}",
         "  @Inject void s(String s) {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.AllInjections_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class AllInjections_Factory ",
-        "    implements Factory<AllInjections> {",
-        "",
-        "  private final MembersInjector<AllInjections> membersInjector;",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections_Factory(MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public AllInjections get() {",
-        "    AllInjections instance = new AllInjections(sProvider.get());",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<AllInjections> create(",
-        "      MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    return new AllInjections_Factory(membersInjector, sProvider);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.AllInjections_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class AllInjections_Factory ",
+            "    implements Factory<AllInjections> {",
+            "",
+            "  private final MembersInjector<AllInjections> allInjectionsMembersInjector;",
+            "  private final Provider<String> sProvider;",
+            "",
+            "  public AllInjections_Factory(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    assert allInjectionsMembersInjector != null;",
+            "    this.allInjectionsMembersInjector = allInjectionsMembersInjector;",
+            "    assert sProvider != null;",
+            "    this.sProvider = sProvider;",
+            "  }",
+            "",
+            "  @Override public AllInjections get() {",
+            "    AllInjections instance = new AllInjections(sProvider.get());",
+            "    allInjectionsMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<AllInjections> create(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    return new AllInjections_Factory(allInjectionsMembersInjector, sProvider);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -808,34 +813,35 @@
         "class B extends A {",
         "  @Inject B() {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.B_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class B_Factory implements Factory<B> {",
-        "",
-        "  private final MembersInjector<B> membersInjector;",
-        "",
-        "  public B_Factory(MembersInjector<B> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override public B get() {",
-        "    B instance = new B();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
-        "    return new B_Factory(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.B_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class B_Factory implements Factory<B> {",
+            "",
+            "  private final MembersInjector<B> bMembersInjector;",
+            "",
+            "  public B_Factory(MembersInjector<B> bMembersInjector) {",
+            "    assert bMembersInjector != null;",
+            "    this.bMembersInjector = bMembersInjector;",
+            "  }",
+            "",
+            "  @Override public B get() {",
+            "    B instance = new B();",
+            "    bMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<B> create(MembersInjector<B> bMembersInjector) {",
+            "    return new B_Factory(bMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
