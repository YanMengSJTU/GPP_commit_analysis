diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 6a0ac5507..6845c5951 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -64,6 +64,11 @@ limitations under the License.
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java b/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
new file mode 100644
index 000000000..84b1bb1e4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static test.ReleasableReferencesComponents.Thing.thing;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntoMap;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Retention;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Scope;
+
+final class ReleasableReferencesComponents {
+
+  interface ThingComponent {
+    /**
+     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
+     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
+     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
+     * ChildModule ChildModule.class}.
+     */
+    Map<Class<?>, Thing> things();
+  }
+
+  @ParentRegularScope
+  @ParentReleasableScope1
+  @ParentReleasableScope2
+  @Component(modules = ParentModule.class)
+  interface Parent extends ThingComponent {
+
+    Set<ReleasableReferenceManager> managers();
+
+    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
+
+    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
+
+    @ForReleasableReferences(ParentReleasableScope1.class)
+    ReleasableReferenceManager parentReleasableScope1Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    ReleasableReferenceManager parentReleasableScope2Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
+
+    @ForReleasableReferences(ChildReleasableScope1.class)
+    ReleasableReferenceManager childReleasableScope1Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    ReleasableReferenceManager childReleasableScope2Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
+
+    Child child();
+  }
+
+  // TODO(ronshapiro): investigate the maven-compiler-plugin bug that is blocking javac from
+  // recognizing @AutoValue when it is imported instead of fully-qualified
+  // http://bugs.java.com/view_bug.do?bug_id=7101822
+  @com.google.auto.value.AutoValue
+  abstract static class Thing {
+    abstract int count();
+
+    static Thing thing(int count) {
+      return new AutoValue_ReleasableReferencesComponents_Thing(count);
+    }
+  }
+
+  @ChildRegularScope
+  @ChildReleasableScope1
+  @ChildReleasableScope2
+  @ChildReleasableScope3
+  @Subcomponent(modules = ChildModule.class)
+  interface Child extends ThingComponent {}
+
+  @CanReleaseReferences
+  @interface Metadata1 {
+    String value();
+  }
+
+  @CanReleaseReferences
+  @interface Metadata2 {
+    String value();
+  }
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ParentRegularScope {}
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ChildRegularScope {}
+
+  @Retention(RUNTIME)
+  @CanReleaseReferences
+  @Scope
+  @interface ParentReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ParentReleasableScope2")
+  @Scope
+  @interface ParentReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata2("ChildReleasableScope1")
+  @Scope
+  @interface ChildReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope2.1")
+  @Metadata2("ChildReleasableScope2.2")
+  @Scope
+  @interface ChildReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope3.1")
+  @Metadata2("ChildReleasableScope3.2")
+  @CanReleaseReferences
+  @Scope
+  @interface ChildReleasableScope3 {}
+
+  @Module
+  static final class ParentModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentModule.class)
+    Thing parentUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentRegularScope.class)
+    @ParentRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope1.class)
+    @ParentReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope2.class)
+    @ParentReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+
+  @Module
+  static final class ChildModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildModule.class)
+    Thing childUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildRegularScope.class)
+    @ChildRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope1.class)
+    @ChildReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope2.class)
+    @ChildReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
new file mode 100644
index 000000000..5d46da763
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.ReleasableReferencesComponents.Thing.thing;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import com.google.common.testing.GcFinalization;
+import com.google.common.testing.GcFinalization.FinalizationPredicate;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.ReleasableReferencesComponents.Child;
+import test.ReleasableReferencesComponents.ChildModule;
+import test.ReleasableReferencesComponents.ChildRegularScope;
+import test.ReleasableReferencesComponents.ChildReleasableScope1;
+import test.ReleasableReferencesComponents.ChildReleasableScope2;
+import test.ReleasableReferencesComponents.ChildReleasableScope3;
+import test.ReleasableReferencesComponents.Metadata1;
+import test.ReleasableReferencesComponents.Parent;
+import test.ReleasableReferencesComponents.ParentModule;
+import test.ReleasableReferencesComponents.ParentRegularScope;
+import test.ReleasableReferencesComponents.ParentReleasableScope1;
+import test.ReleasableReferencesComponents.ParentReleasableScope2;
+import test.ReleasableReferencesComponents.Thing;
+import test.ReleasableReferencesComponents.ThingComponent;
+
+@RunWith(JUnit4.class)
+public final class ReleasableReferencesComponentsTest {
+
+  private Parent component;
+  private ParentAsserts parentAsserts;
+  private ChildAsserts childAsserts;
+
+  @Before
+  public void setUp() {
+    component = DaggerReleasableReferencesComponents_Parent.create();
+    parentAsserts = new ParentAsserts(component);
+    childAsserts = parentAsserts.newChildAsserts();
+  }
+
+  @Test
+  public void releasableReferenceManagers() {
+    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
+        Maps.uniqueIndex(
+            component.managers(),
+            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
+              @Override
+              public Class<? extends Annotation> apply(
+                  ReleasableReferenceManager releasableReferenceManager) {
+                return releasableReferenceManager.scope();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
+    // Should contain a manager for ChildReleasableScope3 even though
+    // @ForReleasableReferences(Scope5.class) isn't needed.
+    assertThat(managers).containsKey(ChildReleasableScope3.class);
+  }
+
+  @Test
+  public void setOfTypedReleasableReferenceManagers() {
+    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
+        Multimaps.transformValues(
+            Multimaps.index(
+                component.typedReleasableReferenceManagers1(),
+                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
+                  @Override
+                  public Class<? extends Annotation> apply(
+                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
+                    return releasableReferenceManager.scope();
+                  }
+                }),
+            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
+              @Override
+              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
+                return manager.metadata();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
+  }
+
+  @AutoAnnotation
+  static Metadata1 metadata1(String value) {
+    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
+  }
+
+  @Test
+  public void basicScopingWorks() {
+    assertBindingCallCounts();
+    // assert again to make sure that the scoped bindings aren't called again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenGc() {
+    assertBindingCallCounts();
+    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+
+    // Releasing again and GCing again means the binding is executed again.
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenGc() {
+    assertBindingCallCounts();
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void twoInstancesOfSameSubcomponent() {
+    // Two instances of the same subcomponent.
+    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
+    childAsserts.assertBindingCallCounts();
+    child2Asserts.assertBindingCallCounts();
+
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
+    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    childAsserts.assertBindingCallCounts(); // when calling child.things()
+    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
+    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
+  }
+
+  private void assertBindingCallCounts() {
+    parentAsserts.assertBindingCallCounts();
+    childAsserts.assertBindingCallCounts();
+  }
+
+  /**
+   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
+   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
+   * keys} to be cleared.
+   */
+  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
+    GcFinalization.awaitDone(
+        new FinalizationPredicate() {
+          @Override
+          public boolean isDone() {
+            for (Class<?> key : keys) {
+              if (parentAsserts.weakThingReferenceUncollected(key)
+                  || childAsserts.weakThingReferenceUncollected(key)) {
+                return false;
+              }
+            }
+            return true;
+          }
+        });
+  }
+
+  /**
+   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
+   * also tell when certain values in the map have been finalized.
+   */
+  private abstract static class ThingAsserts {
+
+    private final ThingComponent component;
+    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
+
+    protected ThingAsserts(ThingComponent component) {
+      this.component = component;
+    }
+
+    /**
+     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
+     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
+     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
+     */
+    final void assertBindingCallCounts() {
+      Map<Class<?>, Thing> things = component.things();
+      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
+      weakThings =
+          ImmutableMap.copyOf(
+              Maps.transformValues(
+                  things,
+                  new Function<Thing, WeakReference<Thing>>() {
+                    @Override
+                    public WeakReference<Thing> apply(Thing thing) {
+                      return new WeakReference<>(thing);
+                    }
+                  }));
+    }
+
+    /** Returns the expected map. */
+    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
+
+    /**
+     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
+     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
+     */
+    boolean weakThingReferenceUncollected(Object key) {
+      WeakReference<Thing> weakThing = weakThings.get(key);
+      return weakThing != null && weakThing.get() != null;
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
+  private static final class ParentAsserts extends ThingAsserts {
+    final Parent parent;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForParentUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForParentRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope2Thing = 1;
+
+    ParentAsserts(Parent parent) {
+      super(parent);
+      this.parent = parent;
+    }
+
+    /**
+     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
+     * Child#things()}.
+     */
+    ChildAsserts newChildAsserts() {
+      return new ChildAsserts(this, parent.child());
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
+      return ImmutableMap.of(
+          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
+          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
+          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
+          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
+  private static final class ChildAsserts extends ThingAsserts {
+    final ParentAsserts parentAsserts;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForChildUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope2Thing = 1;
+
+    ChildAsserts(ParentAsserts parentAsserts, Child child) {
+      super(child);
+      this.parentAsserts = parentAsserts;
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
+      return new ImmutableMap.Builder<Class<?>, Thing>()
+          .putAll(parentAsserts.expectedThingMap())
+          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
+          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
+          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
+          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
+          .build();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 2bdea0086..80a2bd6bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -18,11 +18,13 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
@@ -31,6 +33,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -58,12 +61,16 @@
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
 import static dagger.internal.codegen.TypeNames.SET_FACTORY;
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.STRING;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
+import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.requiresAPassedInstance;
@@ -91,6 +98,7 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
@@ -99,6 +107,7 @@
 import dagger.internal.MapProviderFactory;
 import dagger.internal.Preconditions;
 import dagger.internal.SetFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produced;
@@ -107,12 +116,19 @@
 import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -165,6 +181,12 @@
    */
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
+  /**
+   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
+   * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
+   */
+  private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
+
   AbstractComponentWriter(
       Types types,
       Elements elements,
@@ -272,6 +294,14 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+    return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
+  }
+
   /**
    * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
    * This is only intended to be called once (and will throw on successive invocations). If the
@@ -282,6 +312,7 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     decorateComponent();
     addBuilder();
     addFactoryMethods();
+    addReferenceReleasingProviderManagerFields();
     addFrameworkFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
@@ -487,10 +518,78 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
+  /**
+   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
+   * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
+   * #requiresReleasableReferences(Scope) one is required}.
+   */
+  private void addReferenceReleasingProviderManagerFields() {
+    ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
+    for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
+      if (requiresReleasableReferences(scope)) {
+        FieldSpec field = referenceReleasingProxyManagerField(scope);
+        component.addField(field);
+        fields.put(scope, localField(name, field.name));
+      }
+    }
+    referenceReleasingProviderManagerFields = fields.build();
+  }
+
+  /**
+   * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
+   * references} and there is a dependency request in the component for any of
+   *
+   * <ul>
+   * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
+   * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
+   *     {@code M} is the releasable-references metatadata type for {@code scope}
+   * <li>{@code Set<ReleasableReferenceManager>}
+   * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
+   *     the scope
+   * </ul>
+   */
+  private boolean requiresReleasableReferences(Scope scope) {
+    if (!scope.canReleaseReferences()) {
+      return false;
+    }
+
+    if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
+        || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
+      return true;
+    }
+
+    for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+      if (graphHasContributionBinding(
+              keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
+          || graphHasContributionBinding(
+              keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
   private boolean graphHasContributionBinding(Key key) {
     return graph.resolvedBindings().containsKey(contribution(key));
   }
 
+  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
+    return componentField(
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            UPPER_CAMEL.to(
+                LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References"))
+        .addModifiers(PRIVATE, FINAL)
+        .initializer(
+            "new $T($T.class)",
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            scope.scopeAnnotationElement())
+        .addJavadoc(
+            "The manager that releases references for the {@link $T} scope.\n",
+            scope.scopeAnnotationElement())
+        .build();
+  }
+
   private void addFrameworkFields() {
     graph.resolvedBindings().values().forEach(this::addField);
   }
@@ -1110,6 +1209,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case SYNTHETIC_MULTIBOUND_MAP:
         return initializeFactoryForMapMultibinding(binding);
 
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
+
       case SYNTHETIC_OPTIONAL_BINDING:
         return initializeFactoryForSyntheticOptionalBinding(binding);
 
@@ -1123,10 +1228,18 @@ private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
   }
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
+    if (requiresReleasableReferences(scope)) {
+      return CodeBlock.of(
+          "$T.create($L, $L)",
+          REFERENCE_RELEASING_PROVIDER,
+          factoryCreate,
+          getReferenceReleasingProviderManagerExpression(scope));
+    } else {
       return CodeBlock.of(
           "$T.provider($L)",
           scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
           factoryCreate);
+    }
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
@@ -1258,6 +1371,122 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
     return CodeBlock.of("($T) $L", classToCast, notCasted);
   }
 
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              getReferenceReleasingProviderManagerExpression(scope),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Map.Entry<Scope, MemberSelect> entry :
+        referenceReleasingProviderManagerFields.entrySet()) {
+      Scope scope = entry.getKey();
+      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T($L, $L)",
+        ParameterizedTypeName.get(
+            TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+            TypeName.get(metadata.getAnnotationType())),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(typeValue(annotation, "value")).asElement()));
+  }
+
   /**
    * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
    * binding.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 8eca2f06d..839d038bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -19,6 +19,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
@@ -41,6 +43,11 @@
   private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
       immutableEnumSet(EXECUTABLE, DECLARED);
 
+  private static final ImmutableSet<ContributionBinding.Kind>
+      FORMATTABLE_ELEMENTLESS_BINDING_KINDS =
+          immutableEnumSet(
+              SYNTHETIC_RELEASABLE_REFERENCE_MANAGER, SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS);
+
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final KeyFormatter keyFormatter;
 
@@ -56,6 +63,8 @@
    * <ul>
    * <li>Those with {@linkplain BindingDeclaration#bindingElement() binding elements} that are
    *     methods, constructors, or types.
+   * <li>{@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} bindings.
+   * <li>{@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} bindings.
    * </ul>
    */
   boolean canFormat(BindingDeclaration bindingDeclaration) {
@@ -63,6 +72,10 @@ boolean canFormat(BindingDeclaration bindingDeclaration) {
       return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
           bindingDeclaration.bindingElement().get().asType().getKind());
     }
+    if (bindingDeclaration instanceof ContributionBinding) {
+      ContributionBinding contributionBinding = (ContributionBinding) bindingDeclaration;
+      return FORMATTABLE_ELEMENTLESS_BINDING_KINDS.contains(contributionBinding.bindingKind());
+    }
     return false;
   }
 
@@ -71,6 +84,23 @@ public String format(BindingDeclaration bindingDeclaration) {
     if (bindingDeclaration instanceof SubcomponentDeclaration) {
       return formatSubcomponentDeclaration((SubcomponentDeclaration) bindingDeclaration);
     }
+
+    if (bindingDeclaration instanceof ContributionBinding) {
+      ContributionBinding binding = (ContributionBinding) bindingDeclaration;
+      switch (binding.bindingKind()) {
+        case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+          return String.format(
+              "binding for %s from the scope declaration",
+              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+        case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+          return String.format(
+              "Dagger-generated binding for %s",
+              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+        default:
+          break;
+      }
+    }
+
     checkArgument(
         bindingDeclaration.bindingElement().isPresent(),
         "Cannot format bindings without source elements: %s",
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a1f9c688e..9648135fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -258,6 +258,34 @@ private BindingGraph create(
         optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
       }
 
+      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
+      // none?
+      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
+        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.provideReleasableReferenceManager(scope));
+
+        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
+         * once, each instance will be equal to the rest. Since they're being added to a set, there
+         * will be only one instance. */
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.provideSetOfReleasableReferenceManagers());
+
+        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.provideTypedReleasableReferenceManager(
+                  scope, metadata.getAnnotationType()));
+
+          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
+           * than once, each instance will be equal to the rest. Since they're being added to a set,
+           * there will be only one instance. */
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
+                  metadata.getAnnotationType()));
+        }
+      }
+
       final Resolver requestResolver =
           new Resolver(
               parentResolver,
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 7209c6e08..a0e018c97 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -17,9 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -27,6 +30,7 @@
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
@@ -51,10 +55,14 @@
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.isAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
@@ -83,11 +91,16 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -820,6 +833,9 @@ private StringBuilder requiresErrorMessageBase() {
       }
 
       private void reportMissingBinding() {
+        if (reportMissingReleasableReferenceManager()) {
+          return;
+        }
         StringBuilder errorMessage = requiresErrorMessageBase().append(formatDependencyTrace());
         for (String suggestion :
             MissingBindingSuggestions.forKey(rootGraph, dependencyRequest().bindingKey())) {
@@ -828,6 +844,70 @@ private void reportMissingBinding() {
         reportErrorAtEntryPoint(rootGraph, errorMessage.toString());
       }
 
+      /**
+       * If the current dependency request is missing a binding because it's an invalid
+       * {@code @ForReleasableReferences} request, reports that.
+       *
+       * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or
+       * {@link TypedReleasableReferenceManager}, and whose scope:
+       *
+       * <ul>
+       *   <li>does not annotate any component in the hierarchy, or
+       *   <li>is not annotated with the metadata annotation type that is the {@link
+       *       TypedReleasableReferenceManager}'s type argument
+       * </ul>
+       *
+       * @return {@code true} if the request was invalid and an error was reported
+       */
+      private boolean reportMissingReleasableReferenceManager() {
+        Key key = dependencyRequest().key();
+        if (!key.qualifier().isPresent()
+            || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
+            || !isType(key.type())) {
+          return false;
+        }
+
+        Optional<DeclaredType> metadataType;
+        if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
+          metadataType = Optional.absent();
+        } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
+          List<? extends TypeMirror> typeArguments =
+              MoreTypes.asDeclared(key.type()).getTypeArguments();
+          if (typeArguments.size() != 1
+              || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
+            return false;
+          }
+          metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
+        } else {
+          return false;
+        }
+
+        Scope scope =
+            Scope.scope(MoreTypes.asTypeElement(typeValue(key.qualifier().get(), "value")));
+        String missingRequestKey = formatCurrentDependencyRequestKey();
+        if (!rootGraph.componentDescriptor().releasableReferencesScopes().contains(scope)) {
+          reportErrorAtEntryPoint(
+              rootGraph,
+              referenceReleasingScopeNotInComponentHierarchy(missingRequestKey, scope, rootGraph));
+          return true;
+        }
+        if (metadataType.isPresent()) {
+          if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
+            reportErrorAtEntryPoint(
+                rootGraph,
+                referenceReleasingScopeNotAnnotatedWithMetadata(
+                    missingRequestKey, scope, metadataType.get()));
+          }
+          if (!isAnnotationPresent(metadataType.get().asElement(), CanReleaseReferences.class)) {
+            reportErrorAtEntryPoint(
+                rootGraph,
+                referenceReleasingScopeMetadataMissingCanReleaseReferences(
+                    missingRequestKey, metadataType.get()));
+          }
+        }
+        return false;
+      }
+
       @SuppressWarnings("resource") // Appendable is a StringBuilder.
       private void reportDependsOnProductionExecutor() {
         reportErrorAtEntryPoint(
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
new file mode 100644
index 000000000..52a31c166
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Scope;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Processes annotations annotated with {@link CanReleaseReferences}. For each one that is not also
+ * a {@link Scope}, generates a class that can create instances at runtime.
+ */
+final class CanReleaseReferencesProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+  private final CanReleaseReferencesValidator canReleaseReferencesValidator;
+  private final AnnotationCreatorGenerator annotationCreatorGenerator;
+
+  CanReleaseReferencesProcessingStep(
+      Messager messager,
+      CanReleaseReferencesValidator canReleaseReferencesValidator,
+      AnnotationCreatorGenerator annotationCreatorGenerator) {
+    this.messager = messager;
+    this.canReleaseReferencesValidator = canReleaseReferencesValidator;
+    this.annotationCreatorGenerator = annotationCreatorGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(CanReleaseReferences.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement annotatedElement :
+        typesIn(elementsByAnnotation.get(CanReleaseReferences.class))) {
+      ValidationReport<TypeElement> report =
+          canReleaseReferencesValidator.validate(annotatedElement);
+      report.printMessagesTo(messager);
+      if (report.isClean() && !isAnnotationPresent(annotatedElement, Scope.class)) {
+        annotationCreatorGenerator.generate(annotatedElement, messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
new file mode 100644
index 000000000..fad76705b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import com.google.common.base.Optional;
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.SimpleAnnotationValueVisitor7;
+
+/**
+ * Validates that {@link CanReleaseReferences} are applied only to valid annotations.
+ *
+ * <p>They must not annotate annotations that have {@link RetentionPolicy#SOURCE}-level retention.
+ */
+final class CanReleaseReferencesValidator {
+
+  ValidationReport<TypeElement> validate(TypeElement annotatedElement) {
+    ValidationReport.Builder<TypeElement> report = ValidationReport.about(annotatedElement);
+    checkNoSourceRetention(annotatedElement, report);
+    return report.build();
+  }
+
+  private void checkNoSourceRetention(
+      TypeElement annotatedElement, ValidationReport.Builder<TypeElement> report) {
+    Optional<AnnotationMirror> retention = getAnnotationMirror(annotatedElement, Retention.class);
+    if (retention.isPresent() && getRetentionPolicy(retention.get()).equals(SOURCE)) {
+      report.addError(
+          CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
+          report.getSubject(),
+          retention.get());
+    }
+  }
+
+  // TODO(dpb): Move the ability to get an annotation type's retention policy somewhere common.
+  private RetentionPolicy getRetentionPolicy(AnnotationMirror retention) {
+    return getAnnotationValue(retention, "value")
+        .accept(
+            new SimpleAnnotationValueVisitor7<RetentionPolicy, Void>() {
+              @Override
+              public RetentionPolicy visitEnumConstant(VariableElement element, Void p) {
+                return RetentionPolicy.valueOf(element.getSimpleName().toString());
+              }
+            },
+            null);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index be3a2ced6..d8a77d6aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -43,6 +43,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.common.collect.TreeTraverser;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
@@ -52,6 +53,7 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
+import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
@@ -333,6 +335,29 @@ private static void addTransitiveModules(
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
 
+  /**
+   * For {@link Component @Component}s, all {@link CanReleaseReferences @CanReleaseReferences}
+   * scopes associated with this component or any subcomponent. Otherwise empty.
+   */
+  ImmutableSet<Scope> releasableReferencesScopes() {
+    return kind().equals(Kind.COMPONENT)
+        ? SUBCOMPONENT_TRAVERSER
+            .breadthFirstTraversal(this)
+            .transformAndConcat(ComponentDescriptor::scopes)
+            .filter(Scope::canReleaseReferences)
+            .toSet()
+        : ImmutableSet.<Scope>of();
+  }
+
+  /** {@link TreeTraverser} for the subcomponent tree. */
+  private static final TreeTraverser<ComponentDescriptor> SUBCOMPONENT_TRAVERSER =
+      new TreeTraverser<ComponentDescriptor>() {
+        @Override
+        public Iterable<ComponentDescriptor> children(ComponentDescriptor node) {
+          return node.subcomponents();
+        }
+      };
+
   /** A function that returns all {@link #scopes()} of its input. */
   @AutoValue
   abstract static class ComponentMethodDescriptor {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 2e70a9cef..80648b717 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -173,6 +173,8 @@ public SourceVersion getSupportedSourceVersion() {
         new AnnotationCreatorGenerator(filer, elements);
     UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
         new UnwrappedMapKeyGenerator(filer, elements);
+    CanReleaseReferencesValidator canReleaseReferencesValidator =
+        new CanReleaseReferencesValidator();
     ComponentHierarchyValidator componentHierarchyValidator =
         new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
@@ -191,6 +193,9 @@ public SourceVersion getSupportedSourceVersion() {
     return ImmutableList.of(
         new MapKeyProcessingStep(
             messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+        new ForReleasableReferencesValidator(messager),
+        new CanReleaseReferencesProcessingStep(
+            messager, canReleaseReferencesValidator, annotationCreatorGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 61f1a1b51..25936ad8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -96,6 +96,18 @@
      */
     SYNTHETIC_DELEGATE_BINDING,
 
+    /**
+     * A binding for a {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
+     * dagger.releasablereferences.TypedReleasableReferenceManager} object for a scope.
+     */
+    SYNTHETIC_RELEASABLE_REFERENCE_MANAGER,
+
+    /**
+     * A binding for a set of {@link dagger.releasablereferences.ReleasableReferenceManager} or
+     * {@link dagger.releasablereferences.TypedReleasableReferenceManager} objects.
+     */
+    SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS,
+
     /**
      * A synthetic binding for {@code Optional} of a type or a {@link javax.inject.Provider}, {@link
      * dagger.Lazy}, or {@code Provider} of {@code Lazy} of a type. Generated by a {@link
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index efdf5f761..50e831627 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,16 +18,20 @@
 
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
 import dagger.Provides;
 import dagger.multibindings.Multibinds;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -328,6 +332,61 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     }
   }
 
+  static final String CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION =
+      "@CanReleaseReferences annotations must not have SOURCE retention";
+
+  static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType,
+        String.format(
+            "@%s and @%s",
+            javax.inject.Scope.class.getCanonicalName(),
+            CanReleaseReferences.class.getCanonicalName()));
+  }
+
+  static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
+  }
+
+  private static String forReleasableReferencesValueNeedsAnnotation(
+      TypeElement scopeType, String annotations) {
+    return String.format(
+        "The value of @%s must be a reference-releasing scope. "
+            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
+        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
+  }
+
+  static String referenceReleasingScopeNotInComponentHierarchy(
+      String formattedKey, Scope scope, BindingGraph topLevelGraph) {
+    return String.format(
+        "There is no binding for %s because no component in %s's component hierarchy is "
+            + "annotated with %s. The available reference-releasing scopes are %s.",
+        formattedKey,
+        topLevelGraph.componentType().getQualifiedName(),
+        scope.getReadableSource(),
+        topLevelGraph
+            .componentDescriptor()
+            .releasableReferencesScopes()
+            .stream()
+            .map(Scope::getReadableSource)
+            .collect(toList()));
+  }
+
+  static String referenceReleasingScopeMetadataMissingCanReleaseReferences(
+      String formattedKey, DeclaredType metadataType) {
+    return String.format(
+        "There is no binding for %s because %s is not annotated with @%s.",
+        formattedKey, metadataType, CanReleaseReferences.class.getCanonicalName());
+  }
+
+  static String referenceReleasingScopeNotAnnotatedWithMetadata(
+      String formattedKey, Scope scope, TypeMirror metadataType) {
+    return String.format(
+        "There is no binding for %s because %s is not annotated with @%s.",
+        formattedKey, scope.getQualifiedName(), metadataType);
+  }
+
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
new file mode 100644
index 000000000..4566bc589
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ConfigurationAnnotations.typeValue;
+import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
+import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
+import static dagger.internal.codegen.Scope.isScope;
+import static dagger.internal.codegen.Scope.scope;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.ForReleasableReferences;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/** Validates uses of {@link ForReleasableReferences @ForReleasableReferences}. */
+final class ForReleasableReferencesValidator implements ProcessingStep {
+
+  private final Messager messager;
+
+  ForReleasableReferencesValidator(Messager messager) {
+    this.messager = messager;
+  }
+
+  ValidationReport<Element> validateAnnotatedElement(Element annotatedElement) {
+    checkArgument(isAnnotationPresent(annotatedElement, ForReleasableReferences.class));
+    ValidationReport.Builder<Element> report = ValidationReport.about(annotatedElement);
+    AnnotationMirror annotation =
+        getAnnotationMirror(annotatedElement, ForReleasableReferences.class).get();
+    TypeElement scopeType = MoreTypes.asTypeElement(typeValue(annotation, "value"));
+    if (!isScope(scopeType)) {
+      report.addError(
+          forReleasableReferencesValueNotAScope(scopeType), annotatedElement, annotation);
+    } else if (!scope(scopeType).canReleaseReferences()) {
+      report.addError(
+          forReleasableReferencesValueCannotReleaseReferences(scopeType),
+          annotatedElement,
+          annotation);
+    }
+    return report.build();
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ForReleasableReferences.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    elementsByAnnotation
+        .get(ForReleasableReferences.class)
+        .stream()
+        .map(this::validateAnnotatedElement)
+        .forEach(report -> report.printMessagesTo(messager));
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 12dc991ed..4b8c07b80 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -41,6 +41,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -53,6 +54,9 @@
 import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
 import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executor;
@@ -117,7 +121,7 @@
    * <p>Absent except for multibinding contributions.
    */
   abstract Optional<MultibindingContributionIdentifier> multibindingContributionIdentifier();
-
+  
   abstract Builder toBuilder();
 
   @Memoized
@@ -161,7 +165,7 @@ abstract Builder multibindingContributionIdentifier(
 
     abstract Key build();
   }
-
+  
   /**
    * An object that identifies a multibinding contribution method and the module class that
    * contributes it to the graph.
@@ -305,7 +309,7 @@ public String toString() {
   static final class Factory {
     private final Types types;
     private final Elements elements;
-
+    
     Factory(Types types, Elements elements) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
@@ -334,6 +338,11 @@ private TypeMirror mapOfFrameworkType(
       return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
     }
 
+    private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
+      return types.getDeclaredType(
+          getClassElement(TypedReleasableReferenceManager.class), metadataType);
+    }
+
     Key forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       return forMethod(componentMethod, componentMethod.getReturnType());
@@ -677,5 +686,41 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
       return Optional.of(key.toBuilder().type(underlyingType).build());
     }
+
+    /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
+    Key forReleasableReferenceManager(Scope scope) {
+      return forQualifiedType(
+          Optional.of(forReleasableReferencesAnnotationMirror(scope)),
+          getClassElement(ReleasableReferenceManager.class).asType());
+    }
+
+    /**
+     * Returns a key for a {@code @ForReleasableReferences(scope)
+     * TypedReleasableReferenceManager<metadataType>}
+     */
+    Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
+      return builder(typedReleasableReferenceManagerOf(metadataType))
+          .qualifier(forReleasableReferencesAnnotationMirror(scope))
+          .build();
+    }
+
+    /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
+    Key forSetOfReleasableReferenceManagers() {
+      return builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
+    }
+
+    /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
+    Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+      return forQualifiedType(
+          Optional.<AnnotationMirror>absent(),
+          setOf(typedReleasableReferenceManagerOf(metadataType)));
+    }
+
+    private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
+      return SimpleAnnotationMirror.of(
+          getClassElement(ForReleasableReferences.class),
+          ImmutableMap.of(
+              "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index c3a3e88ea..70b207c0d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -82,7 +82,7 @@ private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
         .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
-
+  
   abstract Builder toBuilder();
 
   @AutoValue.Builder
@@ -313,6 +313,50 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
     }
 
+    /**
+     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+     * ReleasableReferenceManager} that provides the component-instantiated object.
+     */
+    ProvisionBinding provideReleasableReferenceManager(Scope scope) {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(keyFactory.forReleasableReferenceManager(scope))
+          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+     * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
+     * object.
+     */
+    ContributionBinding provideTypedReleasableReferenceManager(
+        Scope scope, DeclaredType metadataType) {
+      return provideReleasableReferenceManager(scope)
+          .toBuilder()
+          .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
+          .build();
+    }
+
+    /** Returns a synthetic binding for {@code Set<ReleasableReferenceManager>}. */
+    ProvisionBinding provideSetOfReleasableReferenceManagers() {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(keyFactory.forSetOfReleasableReferenceManagers())
+          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
+     */
+    ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+      return provideSetOfReleasableReferenceManagers()
+          .toBuilder()
+          .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
+          .build();
+    }
+
     /**
      * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
      * component with no binding for the underlying key.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index fc3470600..d4ab29a23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
@@ -32,11 +33,13 @@
 import com.google.common.collect.Iterables;
 import dagger.Reusable;
 import dagger.producers.ProductionScope;
+import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 /** A javax.inject.Scope. */
@@ -65,7 +68,7 @@ static boolean isScope(AnnotationMirror scopeAnnotation) {
   static boolean isScope(TypeElement scopeAnnotationType) {
     return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);
   }
-
+  
   /**
    * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
    */
@@ -115,6 +118,37 @@ static Scope reusableScope(Elements elements) {
     return scope(elements, Reusable.class);
   }
 
+  /**
+   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
+   * other annotation that is itself annotated with {@link CanReleaseReferences}.
+   */
+  boolean canReleaseReferences() {
+    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
+        || !releasableReferencesMetadata().isEmpty();
+  }
+
+  /**
+   * Returns the set of annotations on the scope that are themselves annotated with {@link
+   * CanReleaseReferences}. These annotations are used as metadata for {@link
+   * dagger.releasablereferences.TypedReleasableReferenceManager}.
+   */
+  ImmutableSet<? extends AnnotationMirror> releasableReferencesMetadata() {
+    return getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class);
+  }
+
+  /**
+   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
+   * annotation of the given type, if there is one for this scope.
+   */
+  Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
+    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
+      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
+        return Optional.of(metadata);
+      }
+    }
+    return Optional.absent();
+  }
+
   /**
    * Returns the readable source representation (name with @ prefix) of the annotation type.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 050b6bc77..d55fadcd6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -97,6 +97,11 @@ public MemberSelect getMemberSelect(BindingKey key) {
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
 
+  @Override
+  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+    return parent.getReferenceReleasingProviderManagerExpression(scope);
+  }
+
   private ExecutableType resolvedSubcomponentFactoryMethod() {
     checkState(
         subcomponentFactoryMethod.isPresent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 9899952bd..6003cc128 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -33,8 +33,11 @@
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.ProviderOfLazy;
+import dagger.internal.ReferenceReleasingProvider;
+import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.SetFactory;
 import dagger.internal.SingleCheck;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -46,6 +49,8 @@
 import dagger.producers.internal.SetProducer;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
@@ -82,13 +87,22 @@
       ClassName.get(ProductionComponentMonitor.Factory.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
-
+  static final ClassName REFERENCE_RELEASING_PROVIDER =
+      ClassName.get(ReferenceReleasingProvider.class);
+  static final ClassName REFERENCE_RELEASING_PROVIDER_MANAGER =
+      ClassName.get(ReferenceReleasingProviderManager.class);
+  static final ClassName RELEASABLE_REFERENCE_MANAGER =
+      ClassName.get(ReleasableReferenceManager.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
+  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER =
+      ClassName.get(TypedReleasableReferenceManager.class);
+  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR =
+      ClassName.get(TypedReleasableReferenceManagerDecorator.class);
 
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
@@ -142,6 +156,6 @@ static ParameterizedTypeName providerOf(TypeName typeName) {
   static ParameterizedTypeName setOf(TypeName elementType) {
     return ParameterizedTypeName.get(SET, elementType);
   }
-
+  
   private TypeNames() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
new file mode 100644
index 000000000..bdaea7ec5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link CanReleaseReferencesValidator}. */
+@RunWith(JUnit4.class)
+public final class CanReleaseReferencesValidatorTest {
+  @Test
+  public void annotatesSourceRetainedAnnotation() {
+    JavaFileObject annotation =
+        JavaFileObjects.forSourceLines(
+            "test.Metadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import java.lang.annotation.RetentionPolicy;",
+            "",
+            "@CanReleaseReferences",
+            "@Retention(RetentionPolicy.SOURCE)",
+            "@interface Metadata {}");
+    assertAbout(javaSource())
+        .that(annotation)
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .failsToCompile()
+        .withErrorContaining("SOURCE")
+        .in(annotation)
+        .onLine(8);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
new file mode 100644
index 000000000..05f849f21
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests validation of {@code @ForReleasableRefernces}. */
+@RunWith(JUnit4.class)
+public class ForReleasableReferencesValidatorTest {
+  @Test
+  public void notAScope() {
+    JavaFileObject notAScope =
+        JavaFileObjects.forSourceLines(
+            "test.NotAScope", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface NotAScope {}");
+    JavaFileObject injects =
+        JavaFileObjects.forSourceLines(
+            "test.Injects",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "interface Injects {",
+            "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(notAScope, injects))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "The value of @ForReleasableReferences must be a reference-releasing scope. "
+                + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
+                + "@dagger.releasablereferences.CanReleaseReferences?")
+        .in(injects)
+        .onLine(7)
+        .atColumn(3);
+  }
+
+  @Test
+  public void notAReferenceReleasingScope() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@Retention(RUNTIME)",
+            "@Scope",
+            "@interface TestScope {}");
+    JavaFileObject injects =
+        JavaFileObjects.forSourceLines(
+            "test.Injects",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "interface Injects {",
+            "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(testScope, injects))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "The value of @ForReleasableReferences must be a reference-releasing scope. "
+                + "Did you mean to annotate test.TestScope with "
+                + "@dagger.releasablereferences.CanReleaseReferences?")
+        .in(injects)
+        .onLine(7)
+        .atColumn(3);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 34f77ea46..83ad31d98 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -2259,6 +2259,275 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
         .onLine(4);
   }
 
+  @Test
+  public void missingReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@BadMetadata",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject otherScope =
+        JavaFileObjects.forSourceLines(
+            "test.OtherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface OtherScope {}");
+    JavaFileObject yetAnotherScope =
+        JavaFileObjects.forSourceLines(
+            "test.YetAnotherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface YetAnotherScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+    JavaFileObject badMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.BadMetadata", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface BadMetadata {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@YetAnotherScope",
+            "@Component",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(OtherScope.class)",
+            "  ReleasableReferenceManager otherManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
+                + "dagger.releasablereferences.ReleasableReferenceManager "
+                + "because no component in test.TestComponent's component hierarchy is annotated "
+                + "with @test.OtherScope. "
+                + "The available reference-releasing scopes are "
+                + "[@test.TestScope, @test.YetAnotherScope].")
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
+                + "because test.TestScope is not annotated with @test.TestMetadata")
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
+                + "because test.BadMetadata is not annotated with "
+                + "@dagger.releasablereferences.CanReleaseReferences")
+        .in(component)
+        .onLine(19);
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static ReleasableReferenceManager rrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<ReleasableReferenceManager> rrmSet() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  ReleasableReferenceManager testManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  Set<ReleasableReferenceManager> managers();",
+            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "test.TestModule.typedRrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            error(
+                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "is bound multiple times:",
+                "@Provides "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "test.TestModule.rrmSet()",
+                "Dagger-generated binding for "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
+        .in(component)
+        .onLine(18)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "is bound multiple times:",
+                    "@Provides "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "test.TestModule.typedRrmSet()",
+                    "Dagger-generated binding for "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(19);
+  }
+
   private String error(String... lines) {
     return Joiner.on("\n      ").join(lines);
   }
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
new file mode 100644
index 000000000..4f89253b3
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that can exchange its strong reference to the stored object for
+ * a {@link WeakReference}.
+ *
+ * <p>The provider can be in any one of four states at a time:
+ *
+ * <ul>
+ * <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
+ *     both {@code null}.
+ * <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's value
+ *     is {@code null}.
+ * <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
+ *     weak reference is {@code null}.
+ * <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
+ *     reference's value is not {@code null}.
+ * </ul>
+ *
+ * <p>The provider starts in <b>uninitialized</b> state.
+ *
+ * <p>{@link #get()} transitions to <b>strong-reference</b> state when in <b>uninitialized</b> or
+ * <b>cleared</b> state.
+ *
+ * <p>{@link #releaseStrongReference()} transitions to <b>weak-reference</b> state when in
+ * <b>strong-reference</b> state, unless the stored value is {@code null}.
+ *
+ * <p>{@link #restoreStrongReference()} transitions to <b>strong-reference</b> state when in
+ * <b>weak-reference</b> state.
+ *
+ * <p>If garbage collection clears the weak reference while in <b>weak-reference</b> state, the
+ * provider transitions to <b>cleared</b> state.
+ *
+ * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ * @since 2.NEXT
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProvider<T> implements Provider<T> {
+  private static final Object NULL = new Object(); // sentinel used when provider.get() returns null
+
+  private final Provider<T> provider;
+  private volatile Object strongReference;
+  private volatile WeakReference<T> weakReference;
+
+  private ReferenceReleasingProvider(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  /**
+   * Releases the strong reference to the object previously returned by {@link #get()}, and creates
+   * a {@link WeakReference} to that object, unless the stored value is {@code null}.
+   */
+  public void releaseStrongReference() {
+    Object value = strongReference;
+    if (value != null && value != NULL) {
+      synchronized (this) {
+        @SuppressWarnings("unchecked") // values other than NULL come from the provider
+        T storedValue = (T) value;
+        weakReference = new WeakReference<T>(storedValue);
+        strongReference = null;
+      }
+    }
+  }
+
+  /**
+   * Restores the strong reference that was previously {@linkplain #releaseStrongReference()
+   * released} if the {@link WeakReference} has not yet been cleared during garbage collection.
+   */
+  public void restoreStrongReference() {
+    Object value = strongReference;
+    if (weakReference != null && value == null) {
+      synchronized (this) {
+        value = strongReference;
+        if (weakReference != null && value == null) {
+          value = weakReference.get();
+          if (value != null) {
+            strongReference = value;
+            weakReference = null;
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns the result of calling {@link Provider#get()} on the underlying {@link Provider}.
+   *
+   * <p>Calling {@code get()} in <b>uninitialized</b> or <b>cleared</b> state calls {@code get()}
+   * on the underlying provider, sets the strong reference to the returned value, and returns it,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>strong-reference</b> state simply returns the strong reference,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>weak-reference</b> state returns the {@link WeakReference}'s
+   * value, leaving the provider in <b>weak-reference</b> state.
+   */
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
+  @Override
+  public T get() {
+    Object value = currentValue();
+    if (value == null) {
+      synchronized (this) {
+        value = currentValue();
+        if (value == null) {
+          value = provider.get();
+          if (value == null) {
+            value = NULL;
+          }
+          strongReference = value;
+        }
+      }
+    }
+    return value == NULL ? null : (T) value;
+  }
+
+  private Object currentValue() {
+    Object value = strongReference;
+    if (value != null) {
+      return value;
+    }
+    if (weakReference != null) {
+      return weakReference.get();
+    }
+    return null;
+  }
+
+  /**
+   * Returns a {@link Provider} that stores the value from the given delegate provider and is
+   * managed by {@code references}.
+   */
+  public static <T> ReferenceReleasingProvider<T> create(
+      Provider<T> delegate, ReferenceReleasingProviderManager references) {
+    ReferenceReleasingProvider<T> provider =
+        new ReferenceReleasingProvider<T>(checkNotNull(delegate));
+    references.addProvider(provider);
+    return provider;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
new file mode 100644
index 000000000..504aa8a68
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
+ * {@link ReferenceReleasingProvider}s.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ * @since 2.NEXT
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
+
+  private final Class<? extends Annotation> scope;
+  private final Queue<WeakReference<ReferenceReleasingProvider<?>>> providers =
+      new ConcurrentLinkedQueue<WeakReference<ReferenceReleasingProvider<?>>>();
+
+  public ReferenceReleasingProviderManager(Class<? extends Annotation> scope) {
+    this.scope = checkNotNull(scope);
+  }
+
+  /**
+   * Adds a weak reference to {@code provider}.
+   */
+  public void addProvider(ReferenceReleasingProvider<?> provider) {
+    providers.add(new WeakReference<ReferenceReleasingProvider<?>>(provider));
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return scope;
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#releaseStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void releaseStrongReferences() {
+    execute(Operation.RELEASE);
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#restoreStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void restoreStrongReferences() {
+    execute(Operation.RESTORE);
+  }
+
+  private void execute(Operation operation) {
+    Iterator<WeakReference<ReferenceReleasingProvider<?>>> iterator = providers.iterator();
+    while (iterator.hasNext()) {
+      ReferenceReleasingProvider<?> provider = iterator.next().get();
+      if (provider == null) {
+        iterator.remove();
+      } else {
+        operation.execute(provider);
+      }
+    }
+  }
+
+  private enum Operation {
+    RELEASE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.releaseStrongReference();
+      }
+    },
+    RESTORE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.restoreStrongReference();
+      }
+    },
+    ;
+
+    abstract void execute(ReferenceReleasingProvider<?> provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
new file mode 100644
index 000000000..a1167ef8e
--- /dev/null
+++ b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link TypedReleasableReferenceManager} that decorates another {@link
+ * ReleasableReferenceManager} with a metadata annotation.
+ *
+ * <p>For each scope that requires a {@link ReleasableReferenceManager}, the generated component
+ * implementation has a field that implements that manager. For every {@link
+ * TypedReleasableReferenceManager} that is required for that scope, the component uses this class
+ * to decorate the field with the metadata annotation.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@GwtIncompatible
+public final class TypedReleasableReferenceManagerDecorator<M extends Annotation>
+    implements TypedReleasableReferenceManager<M> {
+
+  private final ReleasableReferenceManager delegate;
+  private final M metadata;
+
+  /**
+   * Constructs a manager that delegates {@link #releaseStrongReferences()} and {@link
+   * #releaseStrongReferences()} to {@code delegate}.
+   */
+  public TypedReleasableReferenceManagerDecorator(ReleasableReferenceManager delegate, M metadata) {
+    this.delegate = checkNotNull(delegate);
+    this.metadata = checkNotNull(metadata);
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return delegate.scope();
+  }
+
+  @Override
+  public M metadata() {
+    return metadata;
+  }
+
+  @Override
+  public void releaseStrongReferences() {
+    delegate.releaseStrongReferences();
+  }
+
+  @Override
+  public void restoreStrongReferences() {
+    delegate.restoreStrongReferences();
+  }
+}
diff --git a/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
new file mode 100644
index 000000000..c1f1ebd44
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
+ * objects stored within that scope can be <a
+ * href="http://google.github.io/dagger/users-guide.html#releasable-references">released</a> during
+ * the lifetime of the scope.
+ *
+ * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
+ * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * or:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {}
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.NEXT
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target(ANNOTATION_TYPE)
+public @interface CanReleaseReferences {}
diff --git a/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
new file mode 100644
index 000000000..accce23d2
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Qualifier;
+
+/**
+ * A {@link Qualifier} to inject a {@link ReleasableReferenceManager} or {@link
+ * TypedReleasableReferenceManager} object for a particular scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   {@literal public @interface} MyScope {}
+ *
+ *   {@literal @CanReleaseReferences}
+ *   {@literal public @interface} MyMetadata {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @MyMetadata}(15)
+ *   {@literal @Scope}
+ *   {@literal public @interface YourScope} {}
+ *
+ *   class MyClass {
+ *     {@literal @Inject}
+ *     MyClass(
+ *         {@literal @ForReleasableReferences(MyScope.class)}
+ *         ReleasableReferenceManager myScopeReferenceManager,
+ *         {@literal @ForReleasableReferences(YourScope.class)}
+ *         {@literal TypedReleasableReferenceManager<MyMetadata>} yourScopeReferenceManager) {
+ *       // …
+ *     }
+ *   }
+ * </pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ * @since 2.NEXT
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target({FIELD, PARAMETER, METHOD})
+@Retention(RUNTIME)
+@Qualifier
+public @interface ForReleasableReferences {
+  /** The {@linkplain CanReleaseReferences reference-releasing} scope annotation type. */
+  Class<? extends Annotation> value();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
new file mode 100644
index 000000000..f774e6618
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * An object that can <a
+ * href="http://google.github.io/dagger/users-guide.html#releasable-references">release or restore
+ * strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
+ *
+ * <p>Your top-level component can provide a {@link
+ * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
+ * object for any {@link CanReleaseReferences @CanReleaseReferences}-annotated scope {@code Foo}
+ * anywhere in your component hierarchy.
+ *
+ * <p>It can also provide a {@code Set<ReleasableReferenceManager>} that contains all such objects.
+ *
+ * <p>Each provider in the {@link CanReleaseReferences @CanReleaseReferences} {@link #scope()} can
+ * be in any one of four states at a time:
+ *
+ * <ul>
+ * <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link WeakReference}
+ *     are both {@code null}.
+ * <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
+ *     WeakReference}'s value is {@code null}.
+ * <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached value,
+ *     and its {@link WeakReference} is {@code null}.
+ * <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
+ *     {@link WeakReference}'s value is not {@code null}.
+ * </ul>
+ *
+ * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
+ *
+ * <p>Calling {@link Provider#get()} on a provider within {@link #scope()} transitions it to
+ * <b>strong-reference</b> state if it was in <b>uninitialized</b> or <b>empty</b> state.
+ *
+ * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
+ * in <b>strong-reference</b> state to <b>weak-reference</b> state.
+ *
+ * <p>{@link #restoreStrongReference()} transitions all providers within {@link #scope()} that are
+ * in <b>weak-reference</b> state to <b>strong-reference</b> state.
+ *
+ * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
+ * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
+ * state.
+ *
+ * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png">
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @since 2.NEXT
+ */
+@Beta
+@GwtIncompatible
+public interface ReleasableReferenceManager {
+
+  /** The scope whose references are managed by this object. */
+  Class<? extends Annotation> scope();
+
+  /**
+   * Releases the strong references held by all providers in this {@linkplain #scope() scope} to the
+   * objects previously returned by {@link Provider#get()}, leaving only {@link WeakReference}s.
+   *
+   * <p>If any such {@link WeakReference} is cleared during garbage collection, the next call to
+   * that {@link Provider#get()} will execute the underlying binding again, and the provider will
+   * hold a strong reference to the new returned value.
+   *
+   * <p>Calls to {@link Provider#get()} on any such provider return the weakly-referenced object
+   * until the {@link WeakReference} is cleared or {@link #restoreStrongReferences()} is called.
+   */
+  void releaseStrongReferences();
+
+  /**
+   * Restores strong references for all providers in this {@linkplain #scope() scope} that were
+   * previously {@linkplain #releaseStrongReferences() released} but whose {@link WeakReference} has
+   * not yet been cleared during garbage collection.
+   */
+  void restoreStrongReferences();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
new file mode 100644
index 000000000..aa067c5bb
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link ReleasableReferenceManager} for a scope that is annotated with an annotation that itself
+ * is annotated with {@link CanReleaseReferences}. That annotation is available as {@link
+ * #metadata()} and may be useful at runtime to decide when to release references held by the scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}(15)
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}
+ *
+ *   // In a component that is (or has a subcomponent) annotated with {@literal @MyScope}:
+ *   {@literal @Inject}
+ *   void manager(
+ *       {@literal @ForReferenceReleasingScope(MyScope.class)}
+ *       {@literal TypedReferenceReleasingScope<SomeAnnotation>} manager) {
+ *     manager.metadata().value(); // returns 15
+ *   }</pre>
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@Beta
+@GwtIncompatible
+public interface TypedReleasableReferenceManager<M extends Annotation>
+    extends ReleasableReferenceManager {
+
+  /**
+   * Returns the annotation on {@link #scope()} that is annotated with {@link CanReleaseReferences}.
+   */
+  M metadata();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/package-info.java b/core/src/main/java/dagger/releasablereferences/package-info.java
new file mode 100644
index 000000000..52779fe3b
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the API by which Dagger allows you
+ * <a href="http://google.github.io/dagger/users-guide.html#releasable-references">release
+ * references</a> held within some scopes.
+ * 
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.NEXT
+ */
+
+package dagger.releasablereferences;
diff --git a/pom.xml b/pom.xml
index 01c529abe..21217f5b8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -42,6 +42,7 @@
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <android.support.version>24.2.0</android.support.version>
   </properties>
 
   <scm>
@@ -150,6 +151,23 @@
         <artifactId>javapoet</artifactId>
         <version>1.7.0</version>
       </dependency>
+
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>4.1.1.4</version>
+      </dependency>
+      <dependency>
+        <groupId>com.android.support</groupId>
+        <artifactId>support-v4</artifactId>
+        <version>${android.support.version}</version>
+        <type>aar</type>
+      </dependency>
+      <dependency>
+        <groupId>com.android.support</groupId>
+        <artifactId>support-annotations</artifactId>
+        <version>${android.support.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -201,6 +219,12 @@
           <additionalparam>-Xdoclint:html,reference,syntax</additionalparam>
         </configuration>
       </plugin>
+
+      <plugin>
+        <groupId>com.simpligility.maven.plugins</groupId>
+        <artifactId>android-maven-plugin</artifactId>
+        <version>4.4.3</version>
+      </plugin>
     </plugins>
   </build>
 
