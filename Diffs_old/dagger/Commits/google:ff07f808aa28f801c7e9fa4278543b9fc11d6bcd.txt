diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index fd670f266..4c2e44d37 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -22,6 +22,7 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -52,7 +53,7 @@
     for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
       try {
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
+        ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
         graphReport.printMessagesTo(messager);
         if (graphReport.isClean()) {
           try {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index e1105682c..604c59f5d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -76,7 +76,7 @@
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 
-public class BindingGraphValidator implements Validator<BindingGraph> {
+public class BindingGraphValidator {
 
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
@@ -111,21 +111,28 @@
 
   private class Validation {
     final BindingGraph topLevelGraph;
-    final ValidationReport.Builder<BindingGraph> reportBuilder;
+    final BindingGraph subject;
+    final ValidationReport.Builder<TypeElement> reportBuilder;
 
-    Validation(BindingGraph topLevelGraph) {
+    Validation(BindingGraph topLevelGraph, BindingGraph subject) {
       this.topLevelGraph = topLevelGraph;
-      this.reportBuilder = ValidationReport.Builder.about(topLevelGraph);
+      this.subject = subject;
+      this.reportBuilder =
+          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
     }
 
-    ValidationReport<BindingGraph> buildReport() {
+    Validation(BindingGraph topLevelGraph) {
+      this(topLevelGraph, topLevelGraph);
+    }
+
+    ValidationReport<TypeElement> buildReport() {
       return reportBuilder.build();
     }
 
-    void validateSubgraph(BindingGraph subject) {
-      validateComponentScope(subject);
-      validateDependencyScopes(subject);
-      validateBuilders(subject);
+    void validateSubgraph() {
+      validateComponentScope();
+      validateDependencyScopes();
+      validateBuilders();
 
       for (ComponentMethodDescriptor componentMethod :
            subject.componentDescriptor().componentMethods()) {
@@ -138,7 +145,10 @@ void validateSubgraph(BindingGraph subject) {
       }
 
       for (BindingGraph subgraph : subject.subgraphs().values()) {
-        validateSubgraph(subgraph);
+        Validation subgraphValidation =
+            new Validation(topLevelGraph, subgraph);
+        subgraphValidation.validateSubgraph();
+        reportBuilder.addSubreport(subgraphValidation.buildReport());
       }
     }
 
@@ -298,93 +308,112 @@ private boolean validateNullability(
      */
     private boolean validateMembersInjectionBinding(
         MembersInjectionBinding binding, final Deque<ResolvedRequest> path) {
-      return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-          reportBuilder.addItem("Invalid members injection request.",
-              path.peek().request().requestElement());
-          return false;
-        }
-
-        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-          // If the key has type arguments, validate that each type argument is declared.
-          // Otherwise the type argument may be a wildcard (or other type), and we can't
-          // resolve that to actual types.  If the arg was an array, validate the type
-          // of the array.
-          for (TypeMirror arg : type.getTypeArguments()) {
-            boolean declared;
-            switch (arg.getKind()) {
-              case ARRAY:
-                declared = MoreTypes.asArray(arg).getComponentType().accept(
-                    new SimpleTypeVisitor6<Boolean, Void>() {
-                      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-                        return false;
-                      }
-
-                      @Override public Boolean visitDeclared(DeclaredType t, Void p) {
-                        for (TypeMirror arg : t.getTypeArguments()) {
-                          if (!arg.accept(this, null)) {
-                            return false;
-                          }
-                        }
-                        return true;
-                      }
-
-                      @Override public Boolean visitArray(ArrayType t, Void p) {
-                        return t.getComponentType().accept(this, null);
-                      }
-
-                      @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                        return true;
-                      }
-                    }, null);
-                break;
-              case DECLARED:
-                declared = true;
-                break;
-              default:
-                declared = false;
-            }
-            if (!declared) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-              reportBuilder.addItem(
-                  String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                      arg.toString(),
-                      type.toString(),
-                      Joiner.on('\n').join(printableDependencyPath)),
-                      path.peek().request().requestElement());
-              return false;
-            }
-          }
-
-          TypeElement element = MoreElements.asType(type.asElement());
-          // Also validate that the key is not the erasure of a generic type.
-          // If it is, that means the user referred to Foo<T> as just 'Foo',
-          // which we don't allow.  (This is a judgement call -- we *could*
-          // allow it and instantiate the type bounds... but we don't.)
-          if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-              && types.isSameType(types.erasure(element.asType()), type)) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-            reportBuilder.addItem(
-                String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                    type.toString(),
-                    Joiner.on('\n').join(printableDependencyPath)),
-                path.peek().request().requestElement());
-            return false;
-          }
+      return binding
+          .key()
+          .type()
+          .accept(
+              new SimpleTypeVisitor6<Boolean, Void>() {
+                @Override
+                protected Boolean defaultAction(TypeMirror e, Void p) {
+                  reportBuilder.addError(
+                      "Invalid members injection request.", path.peek().request().requestElement());
+                  return false;
+                }
 
-          return true; // valid
-        }
-      }, null);
+                @Override
+                public Boolean visitDeclared(DeclaredType type, Void ignored) {
+                  // If the key has type arguments, validate that each type argument is declared.
+                  // Otherwise the type argument may be a wildcard (or other type), and we can't
+                  // resolve that to actual types.  If the arg was an array, validate the type
+                  // of the array.
+                  for (TypeMirror arg : type.getTypeArguments()) {
+                    boolean declared;
+                    switch (arg.getKind()) {
+                      case ARRAY:
+                        declared =
+                            MoreTypes.asArray(arg)
+                                .getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor6<Boolean, Void>() {
+                                      @Override
+                                      protected Boolean defaultAction(TypeMirror e, Void p) {
+                                        return false;
+                                      }
+
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                        break;
+                      case DECLARED:
+                        declared = true;
+                        break;
+                      default:
+                        declared = false;
+                    }
+                    if (!declared) {
+                      ImmutableList<String> printableDependencyPath =
+                          FluentIterable.from(path)
+                              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                              .transform(dependencyRequestFormatter)
+                              .filter(Predicates.not(Predicates.equalTo("")))
+                              .toList()
+                              .reverse();
+                      reportBuilder.addError(
+                          String.format(
+                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                              arg.toString(),
+                              type.toString(),
+                              Joiner.on('\n').join(printableDependencyPath)),
+                          path.peek().request().requestElement());
+                      return false;
+                    }
+                  }
+
+                  TypeElement element = MoreElements.asType(type.asElement());
+                  // Also validate that the key is not the erasure of a generic type.
+                  // If it is, that means the user referred to Foo<T> as just 'Foo',
+                  // which we don't allow.  (This is a judgement call -- we *could*
+                  // allow it and instantiate the type bounds... but we don't.)
+                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                      && types.isSameType(types.erasure(element.asType()), type)) {
+                    ImmutableList<String> printableDependencyPath =
+                        FluentIterable.from(path)
+                            .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                            .transform(dependencyRequestFormatter)
+                            .filter(Predicates.not(Predicates.equalTo("")))
+                            .toList()
+                            .reverse();
+                    reportBuilder.addError(
+                        String.format(
+                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
+                            type.toString(),
+                            Joiner.on('\n').join(printableDependencyPath)),
+                        path.peek().request().requestElement());
+                    return false;
+                  }
+
+                  return true; // valid
+                }
+              },
+              null);
     }
 
     /**
@@ -392,7 +421,7 @@ private boolean validateMembersInjectionBinding(
      * that there are no cycles within the scoping chain, and that singleton
      * components have no scoped dependencies.
      */
-    private void validateDependencyScopes(BindingGraph subject) {
+    private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
       Optional<AnnotationMirror> scope = descriptor.scope();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
@@ -418,7 +447,8 @@ private void validateDependencyScopes(BindingGraph subject) {
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         } else {
@@ -437,14 +467,15 @@ private void validateDependencyScopes(BindingGraph subject) {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders(BindingGraph subject) {
+    private void validateBuilders() {
       ComponentDescriptor componentDesc = subject.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
@@ -473,14 +504,14 @@ private void validateBuilders(BindingGraph subject) {
                 return methodSignatureFormatter.format(input,
                     Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
               }});
-        reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
       Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
       }
     }
 
@@ -537,7 +568,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      * Validates that the scope (if any) of this component are compatible with the scopes of the
      * bindings available in this component
      */
-    void validateComponentScope(final BindingGraph subject) {
+    void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
       Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
           subject.componentDescriptor().wrappedScope();
@@ -587,8 +618,8 @@ void validateComponentScope(final BindingGraph subject) {
         for (String method : incompatiblyScopedMethods) {
           message.append(ErrorMessages.INDENT).append(method).append("\n");
         }
-        reportBuilder.addItem(message.toString(), componentType,
-            subject.componentDescriptor().componentAnnotation());
+        reportBuilder.addError(
+            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
       }
     }
 
@@ -607,7 +638,7 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
         new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
             keyFormatter.format(dependentProvisions.iterator().next().key()));
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
     private void reportMissingBinding(Deque<ResolvedRequest> path) {
@@ -645,7 +676,7 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph, bindingKey)) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
     private static final int DUPLICATE_SIZE_LIMIT = 10;
@@ -673,7 +704,7 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       if (numberOfOtherBindings > 1) {
         builder.append('s');
       }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
@@ -699,7 +730,7 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
           builder.append('\n');
         }
       }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> bindingPath) {
@@ -717,8 +748,8 @@ private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> bindi
           MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
       Kind kind = cycleHasProviderOrLazy(pathElements) ? Kind.WARNING : Kind.ERROR;
       Element requestElement = rootRequest.requestElement();
-      if (kind == Kind.WARNING 
-          && (suppressCycleWarnings(requestElement) 
+      if (kind == Kind.WARNING
+          && (suppressCycleWarnings(requestElement)
               || suppressCycleWarnings(requestElement.getEnclosingElement()))) {
         return;
       }
@@ -749,10 +780,9 @@ private boolean suppressCycleWarnings(Element requestElement) {
     return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
   }
 
-  @Override
-  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+  ValidationReport<TypeElement> validate(BindingGraph subject) {
     Validation validation = new Validation(subject);
-    validation.validateSubgraph(subject);
+    validation.validateSubgraph();
     return validation.buildReport();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 3bb85e3f9..ba96ebfd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -43,33 +43,33 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
-/** 
+/**
  * Validates {@link dagger.Component.Builder} annotations.
- * 
- * @author sameb@google.com (Sam Berlin)  
+ *
+ * @author sameb@google.com (Sam Berlin)
  */
-class BuilderValidator implements Validator<TypeElement> {
+class BuilderValidator {
   private final Elements elements;
   private final Types types;
   private final ComponentDescriptor.Kind componentType;
-  
+
   BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
     this.elements = elements;
     this.types = types;
     this.componentType = componentType;
   }
 
-  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     Element componentElement = subject.getEnclosingElement();
     ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
     Class<? extends Annotation> componentAnnotation = componentType.annotationType();
     Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
-    
+
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
-      builder.addItem(msgs.mustBeInComponent(), subject);
+      builder.addError(msgs.mustBeInComponent(), subject);
     }
 
     switch (subject.getKind()) {
@@ -77,37 +77,36 @@
         List<? extends Element> allElements = subject.getEnclosedElements();
         List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
         if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
-          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
+          builder.addError(msgs.cxtorOnlyOneAndNoArgs(), subject);
         }
         break;
       case INTERFACE:
         break;
       default:
         // If not the correct type, exit early since the rest of the messages will be bogus.
-        builder.addItem(msgs.mustBeClassOrInterface(), subject);
-        return builder.build(); 
-    }    
+        builder.addError(msgs.mustBeClassOrInterface(), subject);
+        return builder.build();
+    }
 
-    
     if (!subject.getTypeParameters().isEmpty()) {
-      builder.addItem(msgs.generics(), subject);
+      builder.addError(msgs.generics(), subject);
     }
 
     Set<Modifier> modifiers = subject.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(msgs.isPrivate(), subject);
+      builder.addError(msgs.isPrivate(), subject);
     }
     if (!modifiers.contains(STATIC)) {
-      builder.addItem(msgs.mustBeStatic(), subject);
+      builder.addError(msgs.mustBeStatic(), subject);
     }
     // Note: Must be abstract, so no need to check for final.
     if (!modifiers.contains(ABSTRACT)) {
-      builder.addItem(msgs.mustBeAbstract(), subject);
+      builder.addError(msgs.mustBeAbstract(), subject);
     }
-    
+
     ExecutableElement buildMethod = null;
     Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
-        LinkedHashMultimap.create();    
+        LinkedHashMultimap.create();
     for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -141,33 +140,33 @@
                 Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
             method);
       }
-      
+
       if (!method.getTypeParameters().isEmpty()) {
         error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
             msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
-    
+
     if (buildMethod == null) {
-      builder.addItem(msgs.missingBuildMethod(), subject);
+      builder.addError(msgs.missingBuildMethod(), subject);
     }
-    
+
     // Go back through each recorded method per param type.  If we had more than one method
     // for a given param, fail.
     for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
         methodsPerParam.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         TypeMirror type = entry.getKey().get();
-        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
+        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
       }
     }
-    
+
     // Note: there's more validation in BindingGraphValidator,
     // specifically to make sure the setter methods mirror the deps.
 
     return builder.build();
   }
-  
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -182,19 +181,23 @@
    * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
    * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
    * failure.
-   * 
+   *
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
-      String enclosedError, String inheritedError, Object... extraArgs) {
+  private void error(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedError,
+      String inheritedError,
+      Object... extraArgs) {
     if (method.getEnclosingElement().equals(builder.getSubject())) {
-      builder.addItem(String.format(enclosedError, extraArgs), method);
+      builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
       Object[] newArgs = new Object[extraArgs.length + 1];
       newArgs[0] = method;
       System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+      builder.addError(String.format(inheritedError, newArgs), builder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index a2a5eac22..58fe1ca0c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -133,18 +133,21 @@ static ComponentValidator createForSubcomponent(Elements elements,
   public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
-          componentType.annotationType().getSimpleName()), subject);
+      builder.addError(
+          String.format(
+              "@%s may only be applied to an interface or abstract class",
+              componentType.annotationType().getSimpleName()),
+          subject);
     }
 
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
-      builder.addItem(
+      builder.addError(
           String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
           subject);
     }
@@ -197,16 +200,16 @@ public ComponentValidationReport validate(final TypeElement subject,
               TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
               if (!(returnType.getKind().equals(VOID)
                   || types.isSameType(returnType, onlyParameter))) {
-                builder.addItem(
-                    "Members injection methods may only return the injected type or void.",
-                    method);
+                builder.addError(
+                    "Members injection methods may only return the injected type or void.", method);
               }
               break;
             default:
               // this isn't any method that we know how to implement...
-              builder.addItem(
+              builder.addError(
                   "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method", method);
+                      + "subcomponent factory method. Dagger cannot implement this method",
+                  method);
               break;
           }
         }
@@ -216,10 +219,11 @@ public ComponentValidationReport validate(final TypeElement subject,
     for (Map.Entry<Element, Collection<ExecutableElement>> entry :
         referencedSubcomponents.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
-        builder.addItem(
+        builder.addError(
             String.format(
                 ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(), entry.getValue()),
+                entry.getKey(),
+                entry.getValue()),
             subject);
       }
     }
@@ -291,14 +295,15 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
           }, null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "A module may only occur once an an argument in a Subcomponent factory "
                       + "method, but %s was already passed.",
-                  moduleType.get().getQualifiedName()), parameter);
+                  moduleType.get().getQualifiedName()),
+              parameter);
         }
         if (!transitiveModules.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "%s is present as an argument to the %s factory method, but is not one of the"
                       + " modules used to implement the subcomponent.",
@@ -308,7 +313,7 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
         }
         variableTypes.add(moduleType.get());
       } else {
-        builder.addItem(
+        builder.addError(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
                 parameterType),
@@ -319,7 +324,7 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     SetView<TypeElement> missingModules =
         Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
     if (!missingModules.isEmpty()) {
-      builder.addItem(
+      builder.addError(
           String.format(
               "%s requires modules which have no visible default constructors. "
                   + "Add the following modules as parameters to this method: %s",
@@ -334,7 +339,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
-      builder.addItem(
+      builder.addError(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index ac4f914e3..11cd066fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -44,29 +44,28 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} constructors.
+ * A {@linkplain ValidationReport validator} for {@link Inject} constructors.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(constructorElement);
+final class InjectConstructorValidator {
+  ValidationReport<TypeElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<TypeElement> builder =
+        ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
     }
 
     for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
-      builder.addItem(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
         }
       }
     }
@@ -76,16 +75,16 @@
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
     if (typeModifiers.contains(PRIVATE)) {
-      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+      builder.addError(INJECT_INTO_PRIVATE_CLASS, constructorElement);
     }
 
     if (typeModifiers.contains(ABSTRACT)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
     }
 
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
     }
 
     // This is computationally expensive, but probably preferable to a giant index
@@ -98,13 +97,13 @@
             });
 
     if (injectConstructors.size() > 1) {
-      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
     }
 
     ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
     if (scopes.size() > 1) {
       for (AnnotationMirror scope : scopes) {
-        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope);
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index 1841290ea..8bc471c22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -30,29 +30,27 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 /**
- * A {@link Validator} for {@link Inject} fields.
+ * A {@linkplain ValidationReport validator} for {@link Inject} fields.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectFieldValidator implements Validator<VariableElement> {
-  @Override
-  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder =
-        ValidationReport.Builder.about(fieldElement);
+final class InjectFieldValidator {
+  ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
-      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+      builder.addError(FINAL_INJECT_FIELD, fieldElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+      builder.addError(PRIVATE_INJECT_FIELD, fieldElement);
     }
 
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index 9454f230e..aeb62299c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -32,34 +32,32 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 /**
- * A {@link Validator} for {@link Inject} methods.
+ * A {@linkplain ValidationReport validator} for {@link Inject} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectMethodValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(methodElement);
+final class InjectMethodValidator {
+  ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+      builder.addError(PRIVATE_INJECT_METHOD, methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+      builder.addError(GENERIC_INJECT_METHOD, methodElement);
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 708763b8c..e52567ada 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -26,6 +26,7 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -80,16 +81,16 @@
       injectElement.accept(
           new ElementKindVisitor6<Void, Void>() {
             @Override
-            public Void visitExecutableAsConstructor(
-                ExecutableElement constructorElement, Void v) {
-              ValidationReport<ExecutableElement> report =
+            public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
+              ValidationReport<TypeElement> report =
                   constructorValidator.validate(constructorElement);
 
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
-                    Optional.<TypeMirror>absent()));
+                provisions.add(
+                    provisionBindingFactory.forInjectConstructor(
+                        constructorElement, Optional.<TypeMirror>absent()));
               }
 
               return null;
@@ -111,8 +112,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
 
             @Override
             public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report =
-                  methodValidator.validate(methodElement);
+              ValidationReport<ExecutableElement> report = methodValidator.validate(methodElement);
 
               report.printMessagesTo(messager);
 
@@ -123,7 +123,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
               return null;
             }
-          }, null);
+          },
+          null);
     }
 
     for (DeclaredType injectedType : membersInjectedTypes.build()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 01b0951a6..d6aa2f21c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -34,18 +34,17 @@
  * @since 2.0
  */
 // TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
-final class MapKeyValidator implements Validator<Element> {
-  @Override
-  public ValidationReport<Element> validate(Element element) {
-    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+final class MapKeyValidator {
+  ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
     if (members.isEmpty()) {
-      builder.addItem(MAPKEY_WITHOUT_MEMBERS, element);
+      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);
     } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
       if (members.size() > 1) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
       }
     }
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index f2116b110..516d0e0ae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -61,12 +61,12 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
+ * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ModuleValidator implements Validator<TypeElement> {
+final class ModuleValidator {
   private final Types types;
   private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
@@ -86,9 +86,8 @@
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override
-  public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
@@ -99,88 +98,102 @@
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
-      
+
     validateModuleVisibility(subject, builder);
     validateMethodsWithSameName(builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
       validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
     }
-    validateModifiers(subject, builder);    
+    validateModifiers(subject, builder);
     validateReferencedModules(subject, builder);
-    
+
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
-  private void validateModifiers(TypeElement subject,
-      ValidationReport.Builder<TypeElement> builder) {    
+  private void validateModifiers(
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
-    // only modules without type parameters are referenced from @Component(modules={...}). 
+    // only modules without type parameters are referenced from @Component(modules={...}).
     if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
-      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
     }
   }
-  
-  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+
+  private void validateMethodsWithSameName(
+      ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
         bindingMethodsByName.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
-          builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+          builder.addError(
+              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
               offendingMethod);
         }
       }
-    }    
+    }
   }
-  
-  private void validateReferencedModules(final TypeElement subject,
-      final ValidationReport.Builder<TypeElement> builder) {
+
+  private void validateReferencedModules(
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
     validateReferencedModules(subject,  builder, includedTypes);
   }
-  
+
   /**
    * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
    */
-  void validateReferencedModules(final TypeElement subject,
+  void validateReferencedModules(
+      final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
       ImmutableList<TypeMirror> includedTypes) {
     for (TypeMirror includedType : includedTypes) {
-      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
+      includedType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
 
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          TypeElement element = MoreElements.asType(t.asElement()); 
-          if (!t.getTypeArguments().isEmpty()) {
-            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
-                element.getQualifiedName()), subject);
-          }
-          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
-            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
-                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
-          }
-          if (element.getModifiers().contains(ABSTRACT)) {
-            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
-                element.getQualifiedName()), subject);
-          }
-          return null;
-        }
-      }, null);
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              TypeElement element = MoreElements.asType(t.asElement());
+              if (!t.getTypeArguments().isEmpty()) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
+                    subject);
+              }
+              if (!getAnnotationMirror(element, moduleClass).isPresent()) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_NOT_ANNOTATED,
+                        element.getQualifiedName(),
+                        moduleClass.getSimpleName()),
+                    subject);
+              }
+              if (element.getModifiers().contains(ABSTRACT)) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, element.getQualifiedName()),
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
     }
   }
-  
-  private void validateProvidesOverrides(TypeElement subject,
+
+  private void validateProvidesOverrides(
+      TypeElement subject,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
-      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
     // Consider the following hierarchy:
     // class Parent {
@@ -211,8 +224,11 @@ private void validateProvidesOverrides(TypeElement subject,
           if (!failedMethods.contains(providesMethod)
               && elements.overrides(providesMethod, superclassMethod, subject)) {
             failedMethods.add(providesMethod);
-            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+            builder.addError(
+                String.format(
+                    PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                    methodClass.getSimpleName(),
+                    methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
@@ -222,8 +238,11 @@ private void validateProvidesOverrides(TypeElement subject,
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
               failedMethods.add(method);
-              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
-                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+              builder.addError(
+                  String.format(
+                      METHOD_OVERRIDES_PROVIDES_METHOD,
+                      methodClass.getSimpleName(),
+                      methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
           }
@@ -237,9 +256,9 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+      reportBuilder.addError("Modules cannot be private.", moduleElement);
     } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+      reportBuilder.addError("Modules cannot be enclosed in private types.", moduleElement);
     }
 
     switch (moduleElement.getNestingKind()) {
@@ -264,7 +283,7 @@ private void validateModuleVisibility(final TypeElement moduleElement,
                   })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
-            reportBuilder.addItem(
+            reportBuilder.addError(
                 String.format(
                     "This module is public, but it includes non-public "
                         + "(or effectively non-public) modules. "
diff --git a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
deleted file mode 100644
index bb9ba982c..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import javax.annotation.processing.Messager;
-
-/**
- * An interface for types that represent a compilation
- * {@linkplain javax.tools.Diagnostic.Kind#ERROR error} (though, not necessarily a
- * {@link Throwable}) that can be printed using a {@link Messager}.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-interface PrintableErrorMessage {
-  /**
-   * Prints the information represented by this object to the given {@link Messager} as an
-   * {@link javax.tools.Diagnostic.Kind#ERROR}.
-   */
-  void printMessageTo(Messager messager);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index a6e77a712..b0b4df1cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -55,14 +55,14 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@link Validator} for {@link Produces} methods.
+ * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
 // TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
-final class ProducesMethodValidator implements Validator<ExecutableElement> {
+final class ProducesMethodValidator {
   private final Elements elements;
 
   ProducesMethodValidator(Elements elements) {
@@ -73,43 +73,42 @@ private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(producesMethodElement);
+        ValidationReport.about(producesMethodElement);
 
     Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
     checkArgument(producesAnnotation != null);
 
     Element enclosingElement = producesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          producesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), producesMethodElement);
     }
 
     if (!producesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
     }
 
     Set<Modifier> modifiers = producesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
 
     TypeMirror returnType = producesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          producesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
     }
 
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
         && !getMapKeys(producesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
@@ -125,13 +124,13 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
             break;
         }
@@ -167,7 +166,7 @@ private void validateKeyType(ValidationReport.Builder<? extends Element> reportB
       TypeMirror type) {
     TypeKind kind = type.getKind();
     if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 
@@ -176,7 +175,7 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
     if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
       } else {
         validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
       }
@@ -188,17 +187,17 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
   private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     if (!type.getKind().equals(DECLARED)) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
       return;
     }
 
     // TODO(gak): should we allow "covariant return" for set values?
     DeclaredType declaredType = MoreTypes.asDeclared(type);
     if (!declaredType.asElement().equals(getSetElement())) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
     } else if (declaredType.getTypeArguments().isEmpty()) {
-      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-          reportBuilder.getSubject());
+      reportBuilder.addError(
+          formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), reportBuilder.getSubject());
     } else {
       validateSingleReturnType(reportBuilder,
           Iterables.getOnlyElement(declaredType.getTypeArguments()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
index 6107280e4..2e2291d34 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
@@ -38,14 +38,14 @@
  *
  * @author Jesse Beder
  */
-final class ProductionComponentValidator implements Validator<TypeElement> {
-  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+final class ProductionComponentValidator {
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem("@ProductionComponent may only be applied to an interface or abstract class",
-          subject);
+      builder.addError(
+          "@ProductionComponent may only be applied to an interface or abstract class", subject);
     }
 
     AnnotationMirror componentMirror =
@@ -54,26 +54,30 @@
 
     // TODO(gak): make unused modules an error
     for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
+      moduleType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
 
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          checkState(t.getTypeArguments().isEmpty());
-          TypeElement moduleElement = MoreElements.asType(t.asElement());
-          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
-              && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
-            builder.addItem(moduleElement.getQualifiedName()
-                + " is listed as a module, but is not annotated with @Module or @ProducerModule",
-                subject);
-          }
-          return null;
-        }
-      }, null);
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              checkState(t.getTypeArguments().isEmpty());
+              TypeElement moduleElement = MoreElements.asType(t.asElement());
+              if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
+                  && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
+                builder.addError(
+                    moduleElement.getQualifiedName()
+                        + " is listed as a module, but is not annotated with @Module or"
+                        + " @ProducerModule",
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
     }
 
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index af2e1f0d6..e9c8b1629 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -54,12 +54,12 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@link Validator} for {@link Provides} methods.
+ * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+final class ProvidesMethodValidator {
   private final Elements elements;
 
   ProvidesMethodValidator(Elements elements) {
@@ -70,45 +70,42 @@ private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(providesMethodElement);
+        ValidationReport.about(providesMethodElement);
 
     Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
     checkArgument(providesAnnotation != null);
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          providesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), providesMethodElement);
     }
 
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), providesMethodElement);
     }
 
     Set<Modifier> modifiers = providesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), providesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
 
     TypeMirror returnType = providesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          providesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
     }
 
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
     }
 
@@ -124,28 +121,28 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
             break;
         }
         break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
-          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
         } else {
           DeclaredType declaredReturnType = (DeclaredType) returnType;
           // TODO(gak): should we allow "covariant return" for set values?
           if (!declaredReturnType.asElement().equals(getSetElement())) {
-            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+            builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
           } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-                providesMethodElement);
+            builder.addError(
+                formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
           } else {
             validateKeyType(builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
@@ -165,7 +162,7 @@ static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement>
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        builder.addError(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
       }
     }
   }
@@ -182,7 +179,7 @@ private void validateKeyType(ValidationReport.Builder<? extends Element> reportB
       TypeMirror type) {
     TypeKind kind = type.getKind();
     if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+      reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 6ea9729d1..c2620981a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -35,7 +35,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
+final class SourceFileGenerationException extends Exception {
   private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
@@ -71,8 +71,7 @@ private static String createMessage(Iterable<ClassName> generatedClassNames, Str
         message);
   }
 
-  @Override
-  public void printMessageTo(Messager messager) {
+  void printMessageTo(Messager messager) {
     if (associatedElement.isPresent()) {
       messager.printMessage(ERROR, getMessage(), associatedElement.get());
     } else {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index d9e9daef7..f79ec7562 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,23 +21,35 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
 import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.NOTE;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
 /**
  * A collection of items describing contractual issues with the code as presented to an annotation
- * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}.
- * Callers will typically print the results of the report to a {@link Messager} instance using
- * {@link #printMessagesTo}.
+ * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}
+ * and clean subreports. Callers will typically print the results of the report to a
+ * {@link Messager} instance using {@link #printMessagesTo}.
+ *
+ * <p>A report describes a subject {@link Element}.  Callers may choose to add report items about
+ * other elements that are contained within or related to the subject. Since {@link Diagnostic}
+ * reporting is expected to be associated with elements that are currently being compiled,
+ * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they
+ * are contained within the subject. Otherwise, they will be associated with the subject and contain
+ * a reference to the item's element in the message string. It is the responsibility of the caller
+ * to choose subjects that are part of the compilation.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
-abstract class ValidationReport<T> {
+abstract class ValidationReport<T extends Element> {
   abstract T subject();
   abstract ImmutableSet<Item> items();
+  abstract ImmutableSet<ValidationReport<?>> subreports();
 
   boolean isClean() {
     for (Item item : items()) {
@@ -48,39 +60,64 @@ boolean isClean() {
           break;
       }
     }
+    for (ValidationReport<?> subreport : subreports()) {
+      if (!subreport.isClean()) {
+        return false;
+      }
+    }
     return true;
   }
 
   void printMessagesTo(Messager messager) {
     for (Item item : items()) {
-      item.printMessageTo(messager);
+      if (isEnclosedIn(subject(), item.element())) {
+        if (item.annotation().isPresent()) {
+          messager.printMessage(
+              item.kind(), item.message(), item.element(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), item.message(), item.element());
+        }
+      } else {
+        String message = String.format("[%s] %s", item.element(), item.message());
+        if (item.annotation().isPresent()) {
+          messager.printMessage(item.kind(), message, subject(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), message, subject());
+        }
+      }
+    }
+    for (ValidationReport<?> subreport : subreports()) {
+      subreport.printMessagesTo(messager);
     }
   }
 
+  private static boolean isEnclosedIn(Element parent, Element child) {
+    Element current = child;
+    while (current != null) {
+      if (current.equals(parent)) {
+        return true;
+      }
+      current = current.getEnclosingElement();
+    }
+    return false;
+  }
+
   @AutoValue
-  static abstract class Item implements PrintableErrorMessage {
+  static abstract class Item {
     abstract String message();
     abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
-
-    @Override
-    public void printMessageTo(Messager messager) {
-      if (annotation().isPresent()) {
-        messager.printMessage(kind(), message(), element(), annotation().get());
-      } else {
-        messager.printMessage(kind(), message(), element());
-      }
-    }
   }
 
-  static final class Builder<T> {
-    static <T> Builder<T> about(T subject) {
-      return new Builder<T>(subject);
-    }
+  static <T extends Element> Builder<T> about(T subject) {
+    return new Builder<T>(subject);
+  }
 
+  static final class Builder<T extends Element> {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
+    private final ImmutableSet.Builder<ValidationReport<?>> subreports = ImmutableSet.builder();
 
     private Builder(T subject) {
       this.subject = subject;
@@ -89,27 +126,62 @@ private Builder(T subject) {
     T getSubject() {
       return subject;
     }
-    
+
     Builder<T> addItems(Iterable<Item> newItems) {
       items.addAll(newItems);
       return this;
     }
 
-    Builder<T> addItem(String message, Element element) {
-      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message) {
+      addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Kind kind, Element element) {
-      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message, Element element) {
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
+    Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
       addItem(message, ERROR, element, Optional.of(annotation));
       return this;
     }
 
+    Builder<T> addWarning(String message) {
+      addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element) {
+      addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, WARNING, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addNote(String message) {
+      addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element) {
+      addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, NOTE, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
       addItem(message, kind, element, Optional.of(annotation));
       return this;
@@ -121,8 +193,13 @@ T getSubject() {
       return this;
     }
 
+    Builder<T> addSubreport(ValidationReport<?> subreport) {
+      subreports.add(subreport);
+      return this;
+    }
+
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<T>(subject, items.build());
+      return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
deleted file mode 100644
index 615f863c0..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/Validator.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-/**
- * Validates a given subject and produces a {@link ValidationReport} containing the result.
- *
- * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
- */
-interface Validator<T> {
-  ValidationReport<T> validate(T subject);
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
new file mode 100644
index 000000000..d7f445125
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(JUnit4.class)
+public class ValidationReportTest {
+  private static final JavaFileObject TEST_CLASS_FILE =
+      JavaFileObjects.forSourceLines("test.TestClass",
+          "package test;",
+          "",
+          "final class TestClass {}");
+
+  @Test
+  public void basicReport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void messageOnDifferentElement() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error", getTypeElement(String.class));
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("[java.lang.String] simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void subreport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                ValidationReport<TypeElement> parentReport =
+                    ValidationReport.about(getTypeElement(String.class))
+                        .addSubreport(reportBuilder.build())
+                        .build();
+                assertThat(parentReport.isClean()).isFalse();
+                parentReport.printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  private static abstract class SimpleTestProcessor extends AbstractProcessor {
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      test();
+      return false;
+    }
+
+    protected final TypeElement getTypeElement(Class<?> clazz) {
+      return getTypeElement(clazz.getCanonicalName());
+    }
+
+    protected final TypeElement getTypeElement(String canonicalName) {
+      return processingEnv.getElementUtils().getTypeElement(canonicalName);
+    }
+
+    abstract void test();
+  }
+}
