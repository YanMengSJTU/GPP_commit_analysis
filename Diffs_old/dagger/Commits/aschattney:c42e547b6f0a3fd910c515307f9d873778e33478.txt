diff --git a/compiler/pom.xml b/compiler/pom.xml
index 89bf8cbf8..2d882c934 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -130,6 +130,13 @@
                 <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
                 <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
               </annotationProcessors>
+              <compilerArguments>
+                <!-- enable the next line to have the output of the processor shown on console -->
+                <Xlint/>
+                <Averbose>true</Averbose>
+              </compilerArguments>
+              <!-- set the next to true to enable verbose output of the compiler plugin -->
+              <verbose>true</verbose>
             </configuration>
           </execution>
           <execution>
@@ -139,6 +146,13 @@
               <annotationProcessors>
                 <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
               </annotationProcessors>
+              <compilerArguments>
+                <!-- enable the next line to have the output of the processor shown on console -->
+                <Xlint/>
+                <Averbose>true</Averbose>
+              </compilerArguments>
+              <!-- set the next to true to enable verbose output of the compiler plugin -->
+              <verbose>true</verbose>
             </configuration>
           </execution>
         </executions>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 58e262f26..990316c3e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -629,7 +629,7 @@ private FieldSpec addFrameworkField(
    // try {
       //ContributionBinding binding = resolvedBindings.contributionBinding();
       createDelegateFieldAndMethod(name, component, resolvedBindings, delegateFieldNames);
-      /*if (supportsTestDelegate(binding)) {
+      /*if (bindingSupportsTestDelegate(binding)) {
         final String delegateFieldName = contributionBindingField.name() + "Delegate";
         final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
         final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
@@ -1167,7 +1167,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           }
           arguments.addAll(getDependencyArguments(binding));
 
-          if (supportsTestDelegate(binding)) {
+          if (bindingSupportsTestDelegate(binding)) {
             arguments.add(0, CodeBlock.of(delegateFieldName));
           }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
new file mode 100644
index 000000000..6918182f4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
@@ -0,0 +1,20 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+
+public class BuilderStatement implements InitializationStatement {
+
+    private ComponentDescriptor componentDescriptor;
+
+    public BuilderStatement(ComponentDescriptor componentDescriptor) {
+        this.componentDescriptor = componentDescriptor;
+    }
+
+    @Override
+    public CodeBlock get() {
+        return CodeBlock.of("$T.builder()", Util.getDaggerComponentClassName(componentDescriptor.componentDefinitionType()));
+    }
+
+
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index d8a77d6aa..6c4601229 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -79,7 +79,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ComponentDescriptor {
+public abstract class ComponentDescriptor {
   ComponentDescriptor() {}
 
   enum Kind {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e62ac994e..2010695d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -254,6 +254,7 @@ public SourceVersion getSupportedSourceVersion() {
             bindingGraphFactory,
             componentGenerator),
          new InjectorProcessingStep(
+                 types,
                  messager,
                  new InjectorGenerator(filer, elements),
                  ComponentDescriptor.Kind.COMPONENT,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
new file mode 100644
index 000000000..760f5fe36
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
@@ -0,0 +1,70 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.Var;
+import com.squareup.javapoet.CodeBlock;
+
+import javax.lang.model.element.*;
+import javax.lang.model.util.Types;
+import java.util.*;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ComponentStatement implements InitializationStatement{
+
+    private Types types;
+    private TypeElement injector;
+    private ComponentDescriptor.Factory factory;
+    private ComponentDescriptor componentDescriptor;
+    private Map<Key, VariableElement> providedParams;
+
+    public ComponentStatement(Types types, TypeElement injector, ComponentDescriptor.Factory factory, ComponentDescriptor componentDescriptor, Map<Key, VariableElement> providedParams) {
+        this.types = types;
+        this.injector = injector;
+        this.factory = factory;
+        this.componentDescriptor = componentDescriptor;
+        this.providedParams = providedParams;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder builder = CodeBlock.builder();
+        final ImmutableSet<TypeElement> dependencies = componentDescriptor.dependencies();
+        for (TypeElement element : dependencies) {
+            final ComponentDescriptor dependencyComponentDescriptor = factory.forComponent(element);
+            final Optional<ComponentDescriptor.BuilderSpec> builderSpec = dependencyComponentDescriptor.builderSpec();
+            String methodName = builderSpec.isPresent() ? builderSpec.get().methodMap().get(element).getSimpleName().toString() : Util.lowerCaseFirstLetter(element.getSimpleName().toString());
+            final HashMap<String, ExecutableElement> providingMethods = Util.findProvidingMethods(types, injector);
+            if (!providingMethods.containsKey(element.toString())) {
+                throw new IllegalStateException(String.format("providing method not found for component: %s", element.getSimpleName().toString()));
+            }
+
+            final Key componentKey = Key.builder(element.asType()).build();
+            if (providedParams.containsKey(componentKey)) {
+                builder.add(".$L($L)", CodeBlock.of(methodName), CodeBlock.of(providedParams.get(componentKey).getSimpleName().toString()));
+                continue;
+            }
+
+            final ExecutableElement executableElement = providingMethods.get(element.asType().toString());
+
+            List<CodeBlock> arguments = new ArrayList<>();
+            final List<? extends VariableElement> parameters = executableElement.getParameters();
+            for (VariableElement parameter : parameters) {
+                final Key key = Key.builder(parameter.asType()).build();
+                if (!providedParams.containsKey(key)) {
+                    throw new IllegalStateException(String.format("parameter '%s' not found", parameter.getSimpleName().toString()));
+                }
+                final VariableElement variableElement = providedParams.get(key);
+                arguments.add(CodeBlock.of("$L", CodeBlock.of(variableElement.getSimpleName().toString())));
+            }
+
+            builder.add(".$L(this.$L($L))", CodeBlock.of(methodName), CodeBlock.of(executableElement.getSimpleName().toString()), makeParametersCodeBlock(arguments));
+        }
+        return builder.build();
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
index 2713b07e6..e6c27cdaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DI.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -5,16 +5,17 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Created by Andy on 05.05.2017.
  */
 public class DI {
     private final TypeElement injector;
-    private List<ExecutableElement> methods;
+    private Map<TypeElement, ProvidingMethodOverrider> methods;
     private List<InjectorType> injectorTypes;
 
-    public DI(TypeElement injector, List<ExecutableElement> methods, List<InjectorType> injectorTypes) {
+    public DI(TypeElement injector, Map<TypeElement, ProvidingMethodOverrider> methods, List<InjectorType> injectorTypes) {
         this.injector = injector;
         this.methods = methods;
         this.injectorTypes = injectorTypes;
@@ -29,7 +30,7 @@ public ClassName getClassName() {
         return ClassName.bestGuess(className.packageName() + "." + "Test" + className.simpleName());
     }
 
-    public List<ExecutableElement> getMethods() {
+    public Map<TypeElement, ProvidingMethodOverrider> getMethods() {
         return methods;
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
new file mode 100644
index 000000000..de5feb9cc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
@@ -0,0 +1,14 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class FinishBuilderStatement implements InitializationStatement{
+
+    @Override
+    public CodeBlock get() {
+        return CodeBlock.of(".build()");
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java b/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java
new file mode 100644
index 000000000..c476fa4e3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java
@@ -0,0 +1,7 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+
+public interface InitializationStatement {
+    CodeBlock get();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 30a09c234..f90f12982 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -56,8 +56,19 @@ ClassName nameGeneratedType(DI input) {
             componentDescriptors.put(key, injectorType.getComponentDescriptor());
         }
 
-        for (ExecutableElement executableElement : input.getMethods()) {
-            final MethodSpec.Builder method = MethodSpec.overriding(executableElement);
+        final Map<TypeElement, ProvidingMethodOverrider> methods = input.getMethods();
+        for (Map.Entry<TypeElement, ProvidingMethodOverrider> entry : methods.entrySet()) {
+            final ProvidingMethodOverrider overrider = entry.getValue();
+            final MethodSpec.Builder methodSpec = MethodSpec.overriding(overrider.getExecutableElement());
+            final List<InitializationStatement> statements = overrider.getStatements();
+            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+            for (InitializationStatement statement : statements) {
+                codeBuilder.add(statement.get());
+            }
+            methodSpec.addStatement("return $L", codeBuilder.build());
+            builder.addMethod(methodSpec.build());
+        }
+            /*final MethodSpec.Builder method = MethodSpec.overriding(executableElement);
             final List<? extends VariableElement> parameters = executableElement.getParameters();
             Map<Key, VariableElement> map = new HashMap<>();
             for (VariableElement parameter : parameters) {
@@ -73,8 +84,7 @@ ClassName nameGeneratedType(DI input) {
             }
             codeBuilder.add(".build()");
             method.addStatement("return $L", codeBuilder.build());
-            builder.addMethod(method.build());
-        }
+            builder.addMethod(method.build());*/
 
         return Optional.of(builder);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index 39ba2d08b..4c03e5a7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -2,20 +2,23 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.Injector;
 import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
+import dagger.internal.Preconditions;
 
 import javax.annotation.processing.Messager;
-import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Types;
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Executable;
 import java.util.*;
 import java.util.function.Function;
 import java.util.stream.Collectors;
@@ -25,13 +28,17 @@
  */
 public class InjectorProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
 
+    private Types types;
     private final Messager messager;
     private final InjectorGenerator injectorGenerator;
     private final ComponentDescriptor.Kind component;
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private Map<TypeElement, ExecutableElement> componentMethodMap;
+    private Map<TypeElement, ExecutableElement> moduleMethodMap;
 
-    public InjectorProcessingStep(Messager messager, InjectorGenerator injectorGenerator, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+    public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator injectorGenerator, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+        this.types = types;
         this.messager = messager;
         this.injectorGenerator = injectorGenerator;
         this.component = component;
@@ -41,7 +48,7 @@ public InjectorProcessingStep(Messager messager, InjectorGenerator injectorGener
 
     @Override
     public Set<? extends Class<? extends Annotation>> annotations() {
-        return ImmutableSet.of(ProvidesComponent.class, Injector.class, Component.class);
+        return ImmutableSet.of(ProvidesComponent.class, ProvidesModule.class, Injector.class, Component.class);
     }
 
     @Override
@@ -50,12 +57,18 @@ public InjectorProcessingStep(Messager messager, InjectorGenerator injectorGener
         if (!it.hasNext()) {
             return ImmutableSet.of();
         }
-        final Set<Element> elements = elementsByAnnotation.get(ProvidesComponent.class);
-        final List<ExecutableElement> methods = elements.stream()
-                .map(element -> (ExecutableElement) element)
-                .collect(Collectors.toList());
 
         TypeElement injector = MoreElements.asType(it.next());
+
+        this.moduleMethodMap =
+                this.buildProvideModuleMethodMap(elementsByAnnotation.get(ProvidesModule.class));
+
+        this.componentMethodMap =
+                this.buildProvideModuleMethodMap(elementsByAnnotation.get(ProvidesComponent.class));
+
+        final Map<TypeElement, ProvidingMethodOverrider> componentOverriderMap =
+                this.buildProvideComponentMethodMap(elementsByAnnotation.get(ProvidesComponent.class), injector);
+
         Set<Element> rejectedElements = new LinkedHashSet<>();
         List<InjectorType> injectorTypeList = new ArrayList<>();
         for (Element element : elementsByAnnotation.get(component.annotationType())) {
@@ -69,8 +82,46 @@ public InjectorProcessingStep(Messager messager, InjectorGenerator injectorGener
                 rejectedElements.add(componentTypeElement);
             }
         }
-        final DI di = new DI(injector, methods, injectorTypeList);
+        final DI di = new DI(injector, componentOverriderMap, injectorTypeList);
         this.injectorGenerator.generate(di, messager);
         return rejectedElements;
     }
+
+    private Map<TypeElement, ExecutableElement> buildProvideModuleMethodMap(Set<Element> elements) {
+        return elements.stream()
+                .map(element -> (ExecutableElement) element)
+                .collect(Collectors.toMap(p -> MoreTypes.asTypeElement(p.getReturnType()), Function.identity()));
+    }
+
+    private Map<TypeElement, ProvidingMethodOverrider> buildProvideComponentMethodMap(Set<Element> elements, TypeElement injector) {
+        return elements.stream()
+                .map(element -> this.createOverrider(element, injector))
+                .collect(Collectors.toMap(p -> p.getComponent(), Function.identity()));
+    }
+
+    private ProvidingMethodOverrider createOverrider(Element element, TypeElement injector) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        final TypeElement component = MoreTypes.asTypeElement(executableElement.getReturnType());
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, this.componentMethodMap, this.moduleMethodMap, toParameterMap(executableElement.getParameters()));
+        return new ProvidingMethodOverrider(component, descriptor, executableElement, statements);
+    }
+
+    private Map<Key, VariableElement> toParameterMap(List<? extends VariableElement> parameters) {
+        return parameters.stream()
+                .collect(Collectors.toMap(p -> Key.builder(p.asType()).build(), Function.identity()));
+    }
+
+    private List<InitializationStatement> createInitializationsStatements(TypeElement injector,
+                                                                          ComponentDescriptor componentDescriptor,
+                                                                          Map<TypeElement, ExecutableElement> componentMethodMap,
+                                                                          Map<TypeElement, ExecutableElement> moduleMethodMap,
+                                                                          Map<Key, VariableElement> providedParams) {
+        return ImmutableList.of(
+                new BuilderStatement(componentDescriptor),
+                new ComponentStatement(this.types, injector, componentDescriptorFactory, componentDescriptor, providedParams),
+                new ModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams),
+                new FinishBuilderStatement()
+        );
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
new file mode 100644
index 000000000..c7402f531
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
@@ -0,0 +1,111 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.CodeBlock;
+import dagger.Injector;
+import dagger.internal.Preconditions;
+
+import javax.inject.Inject;
+import javax.lang.model.element.*;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ModuleStatement implements InitializationStatement {
+
+    private Types types;
+    private TypeElement injector;
+    private ComponentDescriptor descriptor;
+    private Map<TypeElement, ExecutableElement> moduleMethodMap;
+    private Map<Key, VariableElement> providedParams;
+
+    public ModuleStatement(Types types, TypeElement injector, ComponentDescriptor descriptor, Map<TypeElement, ExecutableElement> moduleMethodMap, Map<Key, VariableElement> providedParams) {
+        Preconditions.checkNotNull(types, "types is null!");
+        this.types = types;
+        Preconditions.checkNotNull(injector, "injector is null!");
+        this.injector = injector;
+        Preconditions.checkNotNull(descriptor, "descriptor is null!");
+        this.descriptor = descriptor;
+        Preconditions.checkNotNull(moduleMethodMap, "moduleMethodMap is null!");
+        this.moduleMethodMap = moduleMethodMap;
+        Preconditions.checkNotNull(providedParams, "providedParams is null!");
+        this.providedParams = providedParams;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
+        for (ModuleDescriptor moduleDescriptor : modules) {
+            final TypeElement moduleElement = moduleDescriptor.moduleElement();
+            if (!moduleMethodMap.keySet().contains(moduleElement))
+                throw new IllegalStateException(moduleMethodMap.entrySet().toString() + " | " + moduleElement.toString());
+            final ExecutableElement method = moduleMethodMap.get(moduleElement);
+            if (method == null) {
+                throw new IllegalStateException("method is null in moduleMethodMap in ModuleStatement");
+            }
+            final HashMap<String, ExecutableElement> providingMethods = Util.findProvidingMethods(types, injector);
+            final ExecutableElement providingModuleMethod = providingMethods.get(moduleElement.toString());
+            if (providingModuleMethod == null) {
+                throw new IllegalStateException("providingModuleMethod is null in providingMethods in ModuleStatement");
+            }
+            //final Map<Key, VariableElement> constructorParameterMap = getConstructorParameterMap(moduleElement);
+            final Map<Key, VariableElement> parameterMap = getMethodParameterMap(providingModuleMethod);
+            final List<CodeBlock> arguments = new ArrayList<>();
+            //if (!constructorParameterMap.isEmpty() || !providedParams.isEmpty())
+            //throw new IllegalStateException(constructorParameterMap.entrySet().toString() + " | "+ providedParams.entrySet().toString());
+            for (Map.Entry<Key, VariableElement> entry : parameterMap.entrySet()) {
+                if (resolvesToInjectorType(entry)) {
+                    arguments.add(CodeBlock.of("$L", CodeBlock.of("this")));
+                }else {
+                    final VariableElement variableElement = providedParams.get(entry.getKey());
+                    if (variableElement == null) {
+                        throw new IllegalStateException("parameter is null in providedParams in ModuleStatement");
+                    }
+                    arguments.add(CodeBlock.of("$L", CodeBlock.of(variableElement.getSimpleName().toString())));
+                }
+            }
+            codeBuilder.add(".$L(this.$L($L))",
+                    CodeBlock.of(method.getSimpleName().toString()),
+                    CodeBlock.of(providingModuleMethod.getSimpleName().toString()),
+                    makeParametersCodeBlock(arguments));
+        }
+        return codeBuilder.build();
+    }
+
+    private boolean resolvesToInjectorType(Map.Entry<Key, VariableElement> entry) {
+        final TypeMirror type = entry.getKey().type();
+        return types.isAssignable(type, injector.asType());
+    }
+
+    private Map<Key, VariableElement> getMethodParameterMap(ExecutableElement element) {
+        return element.getParameters()
+                .stream()
+                .collect(Collectors.toMap(e -> Key.builder(e.asType()).build(), Function.identity()));
+    }
+
+    private Map<Key, VariableElement> getConstructorParameterMap(TypeElement element) {
+        Map<Key, VariableElement> result = new HashMap<>();
+        final List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                final List<? extends VariableElement> parameters = executableElement.getParameters();
+                for (VariableElement parameter : parameters) {
+                    result.put(Key.builder(parameter.asType()).build(), parameter);
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
new file mode 100644
index 000000000..cd660922d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
@@ -0,0 +1,41 @@
+package dagger.internal.codegen;
+
+import dagger.Component;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import java.util.List;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ProvidingMethodOverrider {
+
+    private final TypeElement component;
+    private final ComponentDescriptor descriptor;
+    private final ExecutableElement executableElement;
+    private List<InitializationStatement> statements;
+
+    public ProvidingMethodOverrider(TypeElement component, ComponentDescriptor descriptor, ExecutableElement executableElement, List<InitializationStatement> statements) {
+        this.component = component;
+        this.descriptor = descriptor;
+        this.executableElement = executableElement;
+        this.statements = statements;
+    }
+
+    public TypeElement getComponent() {
+        return component;
+    }
+
+    public ComponentDescriptor getDescriptor() {
+        return descriptor;
+    }
+
+    public ExecutableElement getExecutableElement() {
+        return executableElement;
+    }
+
+    public List<InitializationStatement> getStatements() {
+        return statements;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 5ed684ffb..e208270cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -38,9 +38,13 @@
 import com.squareup.javapoet.*;
 import dagger.Binds;
 import dagger.Provides;
+import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.stream.Collector;
 import javax.inject.Named;
@@ -334,8 +338,14 @@ public static String lowerCaseFirstLetter(String original) {
     return original.substring(0, 1).toLowerCase() + original.substring(1);
   }
 
-  public static boolean supportsTestDelegate(ContributionBinding binding) {
-    return binding.factoryCreationStrategy() != ContributionBinding.FactoryCreationStrategy.DELEGATE;
+  public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
+    final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
+            ContributionBinding.Kind.PROVISION,
+            ContributionBinding.Kind.COMPONENT_PROVISION,
+            ContributionBinding.Kind.INJECTION
+    );
+    final ContributionBinding.Kind kind = binding.bindingKind();
+    return kinds.contains(kind);
   }
 
   private Util() {}
@@ -344,7 +354,7 @@ public static void createDelegateFieldAndMethod(ClassName generatedTypeName, Typ
       try {
           final FrameworkField contributionBindingField = FrameworkField.forResolvedBindings(resolvedBindings, Optional.absent());
           ContributionBinding binding = resolvedBindings.contributionBinding();
-          if (supportsTestDelegate(binding)) {
+          if (bindingSupportsTestDelegate(binding)) {
               final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
               final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
               final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
@@ -388,4 +398,95 @@ public static ClassName getDaggerComponentClassName(ClassName componentDefinitio
   public static ClassName getDaggerComponentClassName(Element component) {
       return getDaggerComponentClassName(ClassName.bestGuess(component.asType().toString()));
   }
+
+  public static HashMap<String, ExecutableElement> findProvidingMethodsOfModules(Types typeUtils, Element componentProvider){
+    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+    if (componentProvider.getKind() == ElementKind.CLASS){
+      TypeElement typeElement = (TypeElement) componentProvider;
+      for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+      }
+      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      while (!typeElement.toString().equals(Object.class.getName())) {
+        for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        }
+        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      }
+    }
+    return providingMethods;
+  }
+
+  public static HashMap<String, ExecutableElement> findProvidingMethodsOfComponents(Types typeUtils, Element componentProvider){
+    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+    if (componentProvider.getKind() == ElementKind.CLASS){
+      TypeElement typeElement = (TypeElement) componentProvider;
+      for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+        if (!providingMethods.containsKey(e.getKey()))
+          providingMethods.put(e.getKey(), e.getValue());
+      }
+      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      while (!typeElement.toString().equals(Object.class.getName())) {
+        for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+          if (!providingMethods.containsKey(e.getKey()))
+            providingMethods.put(e.getKey(), e.getValue());
+        }
+        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      }
+    }
+    return providingMethods;
+  }
+
+  public static HashMap<String, ExecutableElement> findProvidingMethods(Types typeUtils, Element componentProvider){
+    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+    if (componentProvider.getKind() == ElementKind.CLASS){
+      TypeElement typeElement = (TypeElement) componentProvider;
+      for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+      }
+      for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+      }
+      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      while (!typeElement.toString().equals(Object.class.getName())) {
+        for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        }
+        for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        }
+        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+      }
+    }
+    return providingMethods;
+  }
+
+  private static HashMap<String, ExecutableElement> findProvidingModuleMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+    List<? extends Element> enclosedElements = element.getEnclosedElements();
+    for (Element enclosedElement : enclosedElements) {
+      if (enclosedElement.getKind() == ElementKind.METHOD){
+        ProvidesModule providesModule = enclosedElement.getAnnotation(ProvidesModule.class);
+        if (providesModule != null){
+          ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+          providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+        }
+      }
+    }
+    return providingMethods;
+  }
+
+  private static HashMap<String, ExecutableElement> findProvidingComponentMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+    List<? extends Element> enclosedElements = element.getEnclosedElements();
+    for (Element enclosedElement : enclosedElements) {
+      if (enclosedElement.getKind() == ElementKind.METHOD){
+        ProvidesComponent providesComponent = enclosedElement.getAnnotation(ProvidesComponent.class);
+        if (providesComponent != null){
+          ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+          providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+        }
+      }
+    }
+    return providingMethods;
+  }
+
 }
diff --git a/core/pom.xml b/core/pom.xml
index a2c524533..f1fd6c133 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -65,8 +65,8 @@
               <goal>compile</goal>
             </goals>
             <configuration>
-              <source>1.7</source>
-              <target>1.7</target>
+              <source>1.8</source>
+              <target>1.8</target>
             </configuration>
           </execution>
           <execution>
diff --git a/core/src/main/java/dagger/ProvidesModule.java b/core/src/main/java/dagger/ProvidesModule.java
new file mode 100644
index 000000000..f87620177
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesModule.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesModule {}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index b18f7d1dc..421cf49e9 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -16,10 +16,13 @@
 
 package com.example.dagger.activitygraphs;
 
+import android.app.Activity;
 import android.app.Application;
 import android.location.LocationManager;
 import dagger.Injector;
+import dagger.Provides;
 import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
 
 import javax.inject.Inject;
 
@@ -41,4 +44,27 @@
   public ApplicationComponent component() {
     return applicationComponent;
   }
+
+  @ProvidesComponent
+  public AbstractActivityComponent activityComponent(Activity activity) {
+    return DaggerAbstractActivityComponent.builder()
+            .activityModule(this.activityModule(activity))
+            .applicationComponent(this.component())
+            .build();
+  }
+
+  @ProvidesComponent
+  public FragmentComponent fragmentComponent(AbstractActivityComponent component) {
+      return null;
+  }
+
+  @ProvidesModule
+  public DemoApplicationModule demoApplicationModule() {
+    return new DemoApplicationModule(this);
+  }
+
+  @ProvidesModule
+  public ActivityModule activityModule(Activity activity) {
+    return new ActivityModule(activity);
+  }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
new file mode 100644
index 000000000..8fff0004c
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
@@ -0,0 +1,8 @@
+package com.example.dagger.activitygraphs;
+
+import dagger.Component;
+
+@PerFragment
+@Component(dependencies = AbstractActivityComponent.class)
+public interface FragmentComponent {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
new file mode 100644
index 000000000..a19da6203
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.dagger.activitygraphs;
+
+import javax.inject.Scope;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scoping annotation to permit objects whose lifetime should
+ * conform to the life of the activity to be memoized in the
+ * correct component.
+ */
+@Scope
+@Retention(RUNTIME)
+public @interface PerFragment {
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index 5d407243d..19b78a491 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -22,6 +22,7 @@
 import dagger.Component;
 import dagger.Injector;
 import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
 
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -56,4 +57,14 @@
   public ApplicationComponent component() {
     return component;
   }
+
+  @ProvidesModule
+  public AndroidModule androidModule() {
+    return new AndroidModule(this);
+  }
+
+  @ProvidesModule
+  public SingletonModule singletonModule() {
+    return new SingletonModule();
+  }
 }
diff --git a/examples/simple/src/main/java/coffee/AModule.java b/examples/simple/src/main/java/coffee/AModule.java
new file mode 100644
index 000000000..57aaa9372
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/AModule.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+@Module
+public class AModule {
+
+    @Provides
+    public Integer integer() {
+        return 1;
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/BModule.java b/examples/simple/src/main/java/coffee/BModule.java
new file mode 100644
index 000000000..c7596af63
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/BModule.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+@Module
+public class BModule {
+
+    @Provides
+    public Double aDouble() {
+        return 1.0;
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index c499bbc52..44ea3253f 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,8 @@
 package coffee;
 
 import dagger.Component;
+import dagger.ProvidesModule;
+import dagger.Subcomponent;
 
 import javax.inject.Named;
 import javax.inject.Singleton;
@@ -11,12 +13,29 @@
   public interface Coffee {
     CoffeeMaker maker();
     Thermosiphon thermosiphon();
+    Bleu.Builder bleu();
   }
 
   @ActivityScope
-  @Component(dependencies = {Coffee.class})
+  @Subcomponent(modules = {AModule.class})
   public interface Bleu {
-    Thermosiphon thermosiphon();
+    Integer integer();
+    Bleu2.Builder bleu2();
+    @Subcomponent.Builder
+    interface Builder {
+      Builder requestModule(AModule module);
+      Bleu build();
+    }
+  }
+
+  @Subcomponent(modules = {BModule.class})
+  public interface Bleu2 {
+    CoffeeMaker dou();
+    @Subcomponent.Builder
+    interface Builder {
+      Builder requestModule(BModule module);
+      Bleu2 build();
+    }
   }
 
   public static void main(String[] args) {
diff --git a/examples/simple/src/main/java/coffee/DependencyInjector.java b/examples/simple/src/main/java/coffee/DependencyInjector.java
index 5d1403eaf..880d31e4c 100644
--- a/examples/simple/src/main/java/coffee/DependencyInjector.java
+++ b/examples/simple/src/main/java/coffee/DependencyInjector.java
@@ -2,6 +2,7 @@
 
 import dagger.Injector;
 import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
 
 
 @Injector
@@ -14,4 +15,18 @@
                 .build();
     }
 
+    @ProvidesModule
+    public AModule aModule() {
+        return new AModule();
+    }
+
+    @ProvidesModule
+    public BModule bModule() {
+        return new BModule();
+    }
+
+    @ProvidesModule
+    public DripCoffeeModule dripCoffeeModule() {
+        return new DripCoffeeModule();
+    }
 }
