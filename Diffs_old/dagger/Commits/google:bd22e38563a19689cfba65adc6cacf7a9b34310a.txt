diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
new file mode 100644
index 000000000..c965bc224
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import dagger.BindsInstance;
+import javax.inject.Named;
+
+interface BuilderSupertype {
+  @BindsInstance
+  void boundInSubtype(@Named("subtype") int subtype);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
index 2fefb3f86..75d470b9a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
@@ -36,8 +36,11 @@
 
   List<String> listOfString();
 
+  @Named("subtype")
+  int boundInSubtype();
+
   @Component.Builder
-  interface Builder {
+  interface Builder extends BuilderSupertype {
     @BindsInstance
     Builder count(int count);
 
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
index 377369d41..01c73842e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
@@ -24,20 +24,22 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import test.builderbinds.TestComponent.Builder;
 
 @RunWith(JUnit4.class)
 public final class BuilderBindsTest {
 
   @Test
   public void builderBinds() {
-    TestComponent component =
+    TestComponent.Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
             .nullableInput("bar")
-            .listOfString(Arrays.asList("x", "y", "z"))
-            .build();
+            .listOfString(Arrays.asList("x", "y", "z"));
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isEqualTo("bar");
@@ -46,14 +48,16 @@ public void builderBinds() {
 
   @Test
   public void builderBindsNullableWithNull() {
-    TestComponent component =
+    Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
             .nullableInput(null)
-            .listOfString(Collections.<String>emptyList())
-            .build();
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isNull();
@@ -72,12 +76,14 @@ public void builderBindsNonNullableWithNull() {
   @Test
   public void builderBindsPrimitiveNotSet() {
     try {
-      DaggerTestComponent.builder()
-          .l(10L)
-          .input("foo")
-          .nullableInput("bar")
-          .listOfString(Collections.<String>emptyList())
-          .build();
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .l(10L)
+              .input("foo")
+              .nullableInput("bar")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
       fail("expected IllegalStateException");
     } catch (IllegalStateException expected) {
     }
@@ -86,12 +92,14 @@ public void builderBindsPrimitiveNotSet() {
   @Test
   public void builderBindsNonNullableNotSet() {
     try {
-      DaggerTestComponent.builder()
-          .count(5)
-          .l(10L)
-          .nullableInput("foo")
-          .listOfString(Collections.<String>emptyList())
-          .build();
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .count(5)
+              .l(10L)
+              .nullableInput("foo")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
       fail("expected IllegalStateException");
     } catch (IllegalStateException expected) {
     }
@@ -99,13 +107,14 @@ public void builderBindsNonNullableNotSet() {
 
   @Test
   public void builderBindsNullableNotSet() {
-    TestComponent component =
+    Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
-            .listOfString(Collections.<String>emptyList())
-            .build();
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isNull();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index ab90e093c..8165da85e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -16,11 +16,19 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_NOT_IN_BUILDER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_INVALID_COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_ONE_PARAMETER;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.BindsInstance;
@@ -28,8 +36,11 @@
 import java.util.Set;
 import java.util.stream.Stream;
 import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.tools.Diagnostic.Kind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 
 /**
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
@@ -37,9 +48,13 @@
  */
 final class BindsInstanceProcessingStep implements ProcessingStep {
 
-  private static final ImmutableSet<Class<? extends Annotation>> VALID_CONTAINING_ANNOTATIONS =
+  private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
       Stream.of(ComponentDescriptor.Kind.values())
-          .map(ComponentDescriptor.Kind::builderAnnotationType)
+          .map(ComponentDescriptor.Kind::annotationType)
+          .collect(toImmutableSet());
+  private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
+      Stream.of(ModuleDescriptor.Kind.values())
+          .map(ModuleDescriptor.Kind::moduleAnnotation)
           .collect(toImmutableSet());
 
   private final Messager messager;
@@ -57,9 +72,32 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
-      if (!isAnyAnnotationPresent(element.getEnclosingElement(), VALID_CONTAINING_ANNOTATIONS)) {
-        messager.printMessage(Kind.ERROR, BINDS_INSTANCE_NOT_IN_BUILDER, element);
+      ExecutableElement method = MoreElements.asExecutable(element);
+      ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        report.addError("@BindsInstance methods must be abstract");
+      }
+      if (method.getParameters().size() != 1) {
+        report.addError(BINDS_INSTANCE_ONE_PARAMETER);
+      } else {
+        VariableElement parameter = getOnlyElement(method.getParameters());
+        if (FrameworkTypes.isFrameworkType(parameter.asType())) {
+          report.addError("@BindsInstance parameters may not be framework types", parameter);
+        }
+      }
+      TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+      if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
+        report.addError(
+            String.format(
+                BINDS_INSTANCE_IN_MODULE, simpleName(getModuleAnnotation(enclosingType).get())));
+      }
+      if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
+        AnnotationMirror componentAnnotation =
+            getComponentOrSubcomponentAnnotation(enclosingType).get();
+        report.addError(
+            String.format(BINDS_INSTANCE_IN_INVALID_COMPONENT, simpleName(componentAnnotation)));
       }
+      report.build().printMessagesTo(messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index fe5bd95d5..d5e7c9b5a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -70,6 +70,14 @@
     return getAnyAnnotation(subcomponent, Subcomponent.class, ProductionSubcomponent.class);
   }
 
+  static Optional<AnnotationMirror> getComponentOrSubcomponentAnnotation(TypeElement type) {
+    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
+    if (componentAnnotation.isPresent()) {
+      return componentAnnotation;
+    }
+    return getSubcomponentAnnotation(type);
+  }
+
   static boolean isSubcomponent(Element element) {
     return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index ae15635e3..5c45f66d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -322,8 +322,15 @@ static String nullableToNonNullable(String typeName, String bindingString) {
       "@%s.type cannot be used with multibinding annotations";
 
   /* BindsInstance messages. */
-  static final String BINDS_INSTANCE_NOT_IN_BUILDER =
-      "@BindsInstance must annotate a method in a component builder";
+  static final String BINDS_INSTANCE_IN_MODULE =
+      "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?";
+
+  static final String BINDS_INSTANCE_IN_INVALID_COMPONENT =
+      "@BindsInstance methods should not be included in @%1$ss. "
+          + "Did you mean to put it in a @%1$s.Builder?";
+
+  static final String BINDS_INSTANCE_ONE_PARAMETER =
+      "@BindsInstance methods should have exactly one parameter for the bound type";
 
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index cacd83332..570f27b46 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2682,16 +2682,16 @@ public void bindsInstanceInModule() {
             "",
             "import dagger.BindsInstance;",
             "import dagger.Module;",
-            "import dagger.Provides;",
             "",
             "@Module",
-            "final class TestModule {",
-            "  @BindsInstance String s() { return null; }",
+            "abstract class TestModule {",
+            "  @BindsInstance abstract void str(String string);",
             "}");
     Compilation compilation = daggerCompiler().compile(testModule);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
   }
 
   @Test
@@ -2706,12 +2706,105 @@ public void bindsInstanceInComponent() {
             "",
             "@Component",
             "interface TestComponent {",
-            "  @BindsInstance String s();",
+            "  @BindsInstance String s(String s);",
             "}");
     Compilation compilation = daggerCompiler().compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Components. "
+                + "Did you mean to put it in a @Component.Builder?");
+  }
+
+  @Test
+  public void bindsInstanceNotAbstract() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNotAbstract",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "class BindsInstanceNotAbstract {",
+            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance methods must be abstract")
+        .inFile(notAbstract)
+        .onLine(7);
+  }
+
+  @Test
+  public void bindsInstanceNoParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameters",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceNoParameters {",
+            "  @BindsInstance void noParams();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceManyParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameter",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceManyParameters {",
+            "  @BindsInstance void manyParams(int i, long l);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceFrameworkType() {
+    JavaFileObject bindsFrameworkType =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceFrameworkType",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Producer;",
+            "import javax.inject.Provider;",
+            "",
+            "interface BindsInstanceFrameworkType {",
+            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
+            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(8);
+
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(9);
   }
 
   private static Compiler daggerCompiler(Processor... extraProcessors) {
