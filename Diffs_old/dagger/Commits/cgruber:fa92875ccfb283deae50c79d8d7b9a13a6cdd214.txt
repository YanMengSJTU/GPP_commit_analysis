diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
index 6c061bc5c..2529433ae 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -17,6 +17,6 @@
 
 import dagger.Subcomponent;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 abstract class ChildAbstractClassComponent implements ChildComponent {
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 67d66cae9..d3c28f2b4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 import javax.inject.Provider;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 interface ChildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
@@ -28,4 +28,6 @@
   Set<Object> objectSet();
 
   GrandchildComponent newGrandchildComponent();
+  
+  Object object();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
new file mode 100644
index 000000000..f7fd49058
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class StaticChildModule {
+  private StaticChildModule() {}
+  
+  @Provides static Object provideStaticObject() {
+    return "static";
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 3d28a9b3f..f8010c301 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -59,6 +59,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -67,7 +68,10 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.all;
@@ -75,6 +79,9 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Maps.filterKeys;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
@@ -89,6 +96,7 @@
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
 import static dagger.internal.codegen.Util.getValueTypeOfMap;
@@ -165,6 +173,13 @@ void validateSubgraph() {
               new HashSet<DependencyRequest>());
         }
       }
+      
+      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
+          filterKeys(subject.componentDescriptor().subcomponents(), isOfKind(SUBCOMPONENT))
+              .entrySet()) {
+        validateSubcomponentFactoryMethod(
+            entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
+      }
 
       for (BindingGraph subgraph : subject.subgraphs().values()) {
         Validation subgraphValidation =
@@ -174,6 +189,39 @@ void validateSubgraph() {
       }
     }
 
+    private void validateSubcomponentFactoryMethod(
+        ExecutableElement factoryMethod, TypeElement subcomponentType) {
+      BindingGraph subgraph = subject.subgraphs().get(factoryMethod);
+      FluentIterable<TypeElement> missingModules =
+          FluentIterable.from(subgraph.componentRequirements())
+              .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
+              .filter(
+                  new Predicate<TypeElement>() {
+                    @Override
+                    public boolean apply(TypeElement moduleType) {
+                      return !componentCanMakeNewInstances(moduleType);
+                    }
+                  });
+      if (!missingModules.isEmpty()) {
+        reportBuilder.addError(
+            String.format(
+                "%s requires modules which have no visible default constructors. "
+                    + "Add the following modules as parameters to this method: %s",
+                subcomponentType.getQualifiedName(),
+                Joiner.on(", ").join(missingModules.toSet())),
+            factoryMethod);
+      }
+    }
+
+    private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
+        ExecutableElement factoryMethod) {
+      DeclaredType componentType =
+          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+      ExecutableType factoryMethodType =
+          asExecutable(types.asMemberOf(componentType, factoryMethod));
+      return asTypeElements(factoryMethodType.getParameterTypes());
+    }
+
     /**
      * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
      * cycles found.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index df0ea7113..650fb9dcc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -19,6 +19,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -203,6 +204,18 @@ boolean isTopLevel() {
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
+    
+    /**
+     * A predicate that passes for {@link ComponentMethodDescriptor}s of a given kind.
+     */
+    static Predicate<ComponentMethodDescriptor> isOfKind(final ComponentMethodKind kind) {
+      return new Predicate<ComponentMethodDescriptor>() {
+        @Override
+        public boolean apply(ComponentMethodDescriptor descriptor) {
+          return kind.equals(descriptor.kind());
+        }
+      };
+    }
   }
 
   enum ComponentMethodKind {
@@ -212,7 +225,7 @@ boolean isTopLevel() {
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
   }
-
+  
   @AutoValue
   static abstract class BuilderSpec {
     abstract TypeElement builderDefinitionType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 58fe1ca0c..a9e82a8cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -18,17 +18,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
-import com.google.common.collect.Sets.SetView;
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
@@ -54,7 +50,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -264,18 +259,10 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
     // subcomponents and their modules separately from how it is done in ComponentDescriptor and
     // ModuleDescriptor
+    @SuppressWarnings("deprecation")
     ImmutableSet<TypeElement> transitiveModules =
         getTransitiveModules(types, elements, moduleTypes);
 
-    ImmutableSet<TypeElement> requiredModules =
-        FluentIterable.from(transitiveModules)
-            .filter(new Predicate<TypeElement>() {
-              @Override public boolean apply(TypeElement input) {
-                return !componentCanMakeNewInstances(input);
-              }
-            })
-            .toSet();
-
     Set<TypeElement> variableTypes = Sets.newHashSet();
 
     for (int i = 0; i < parameterTypes.size(); i++) {
@@ -320,18 +307,6 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
             parameter);
       }
     }
-
-    SetView<TypeElement> missingModules =
-        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
-    if (!missingModules.isEmpty()) {
-      builder.addError(
-          String.format(
-              "%s requires modules which have no visible default constructors. "
-                  + "Add the following modules as parameters to this method: %s",
-              MoreTypes.asTypeElement(returnType).getQualifiedName(),
-              Joiner.on(", ").join(missingModules)),
-          method);
-    }
   }
 
   private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 8cb31b92d..128766872 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -18,10 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentGenerator.MemberSelect;
 import dagger.internal.codegen.writer.ClassName;
@@ -32,6 +29,7 @@
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
+import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -40,6 +38,7 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Sets.difference;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -189,12 +188,9 @@ private void writeSubcomponentWithoutBuilder(
       }
     }
 
-    ImmutableSet<TypeElement> uninitializedModules =
-        FluentIterable.from(graph.componentDescriptor().transitiveModules())
-            .transform(ModuleDescriptor.getModuleElement())
-            .filter(Predicates.not(Predicates.in(componentContributionFields.keySet())))
-            .toSet();
-
+    Set<TypeElement> uninitializedModules =
+        difference(graph.componentRequirements(), componentContributionFields.keySet());
+    
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 51fb2c0e9..d47c32839 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -43,15 +43,26 @@
         "import dagger.Subcomponent;",
         "",
         "@Subcomponent(modules = ModuleWithParameters.class)",
-        "interface ChildComponent {}");
+        "interface ChildComponent {",
+        "  Object object();",
+        "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
         "package test;",
         "",
         "import dagger.Module;",
+        "import dagger.Provides;",
         "",
         "@Module",
         "final class ModuleWithParameters {",
-        "  ModuleWithParameters(Object whatever) {}",
+        "  private final Object object;",
+        "",
+        "  ModuleWithParameters(Object object) {",
+        "    this.object = object;",
+        "  }",
+        "",
+        "  @Provides Object object() {",
+        "    return object;",
+        "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
         .processedWith(new ComponentProcessor())
