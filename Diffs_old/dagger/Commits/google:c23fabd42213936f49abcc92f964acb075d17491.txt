diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index a5e4ededf..d1edfebc0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -40,6 +40,13 @@
   static final String GENERIC_INJECT_METHOD =
       "Methods with @Inject may not declare type parameters.";
 
+  /* qualifiers */
+  static final String MULTIPLE_QUALIFIERS =
+      "A single injection site may not use more than one @Qualifier.";
+
+  /* scope */
+  static final String MULTIPLE_SCOPES = "A single binding may not declare more than one @Scope.";
+
   /*
    * Dagger errors
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 183c71f25..22ade7abb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -24,6 +24,8 @@
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static javax.lang.model.SourceVersion.RELEASE_6;
@@ -31,12 +33,13 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 
+import java.lang.annotation.Annotation;
+import java.util.List;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -45,6 +48,9 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -83,78 +89,25 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
           new ElementKindVisitor6<Void, Void>() {
             @Override
             public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
-              boolean errorRaised = false;
+              ValidationReport<ExecutableElement> report =
+                  validateInjectConstructor(constructorElement);
 
-              if (constructorElement.getModifiers().contains(PRIVATE)) {
-                messager.printMessage(ERROR, INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
-                errorRaised = true;
-              }
-
-              TypeElement enclosingElement =
-                  ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+              report.printMessagesTo(messager);
 
-              if (enclosingElement.getModifiers().contains(PRIVATE)) {
-                messager.printMessage(ERROR, INJECT_INTO_PRIVATE_CLASS, constructorElement);
-                errorRaised = true;
-              }
-
-              if (enclosingElement.getModifiers().contains(ABSTRACT)) {
-                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS,
-                    constructorElement);
-                errorRaised = true;
-              }
-
-              if (!enclosingElement.getTypeParameters().isEmpty()) {
-                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_GENERIC_CLASS,
-                    constructorElement);
-                errorRaised = true;
-              }
-
-              if (enclosingElement.getNestingKind().isNested()
-                  && !enclosingElement.getModifiers().contains(STATIC)) {
-                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_INNER_CLASS,
-                    constructorElement);
-                errorRaised = true;
-              }
-
-              // This is computationally expensive, but probably preferable to a giant index
-              FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
-                  ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
-                      .filter(new Predicate<ExecutableElement>() {
-                        @Override public boolean apply(ExecutableElement input) {
-                          return input.getAnnotation(Inject.class) != null;
-                        }
-                      });
-
-              if (injectConstructors.size() > 1) {
-                messager.printMessage(ERROR, MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
-                errorRaised = true;
-              }
-
-              if (!errorRaised) {
+              if (report.isClean()) {
                 // collect bindings for generating factories
               }
+
               return null;
             }
 
             @Override
             public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              boolean errorRaised = false;
-
-              Set<Modifier> modifiers = fieldElement.getModifiers();
-              if (modifiers.contains(FINAL)) {
-                messager.printMessage(ERROR, FINAL_INJECT_FIELD, fieldElement);
-                errorRaised = true;
-              }
-
-              if (modifiers.contains(PRIVATE)) {
-                messager.printMessage(ERROR, PRIVATE_INJECT_FIELD, fieldElement);
-                errorRaised = true;
-              }
+              ValidationReport<VariableElement> report = validateInjectField(fieldElement);
 
-              // TODO(gak): check for static
+              report.printMessagesTo(messager);
 
-              if (!errorRaised) {
+              if (report.isClean()) {
                 // collect bindings for generating members injectors
               }
 
@@ -163,27 +116,11 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
 
             @Override
             public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              boolean errorRaised = false;
+              ValidationReport<ExecutableElement> report = validateInjectMethod(methodElement);
 
-              Set<Modifier> modifiers = methodElement.getModifiers();
-              if (modifiers.contains(ABSTRACT)) {
-                messager.printMessage(ERROR, ABSTRACT_INJECT_METHOD, methodElement);
-                errorRaised = true;
-              }
-
-              if (modifiers.contains(PRIVATE)) {
-                messager.printMessage(ERROR, PRIVATE_INJECT_METHOD, methodElement);
-                errorRaised = true;
-              }
-
-              if (!methodElement.getTypeParameters().isEmpty()) {
-                messager.printMessage(ERROR, GENERIC_INJECT_METHOD, methodElement);
-                errorRaised = true;
-              }
+              report.printMessagesTo(messager);
 
-              // TODO(gak): check for static
-
-              if (!errorRaised) {
+              if (report.isClean()) {
                 // collect bindings for generating members injectors
               }
 
@@ -196,4 +133,136 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
     return false;
   }
+
+  private ValidationReport<ExecutableElement> validateInjectConstructor(
+      ExecutableElement constructorElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(constructorElement);
+    if (constructorElement.getModifiers().contains(PRIVATE)) {
+      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+    }
+
+    for (VariableElement parameter : constructorElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+        }
+      }
+    }
+
+    TypeElement enclosingElement =
+        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
+
+    if (typeModifiers.contains(PRIVATE)) {
+      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    }
+
+    if (typeModifiers.contains(ABSTRACT)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+    }
+
+    if (!enclosingElement.getTypeParameters().isEmpty()) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
+    }
+
+    if (enclosingElement.getNestingKind().isNested()
+        && !typeModifiers.contains(STATIC)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+    }
+
+    // This is computationally expensive, but probably preferable to a giant index
+    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
+        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override public boolean apply(ExecutableElement input) {
+                return input.getAnnotation(Inject.class) != null;
+              }
+            });
+
+    if (injectConstructors.size() > 1) {
+      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
+    if (scopes.size() > 1) {
+      for (AnnotationMirror scope : scopes) {
+        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+      }
+    }
+
+    return builder.build();
+  }
+
+  private ValidationReport<ExecutableElement> validateInjectMethod(
+      ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(methodElement);
+    Set<Modifier> modifiers = methodElement.getModifiers();
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+    }
+
+    if (!methodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+    }
+
+    for (VariableElement parameter : methodElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        }
+      }
+    }
+
+    return builder.build();
+  }
+
+  private ValidationReport<VariableElement> validateInjectField(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder =
+        ValidationReport.Builder.about(fieldElement);
+    Set<Modifier> modifiers = fieldElement.getModifiers();
+    if (modifiers.contains(FINAL)) {
+      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+      }
+    }
+
+    return builder.build();
+  }
+
+  private ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
+    return getAnnotatedAnnotations(element, Qualifier.class);
+  }
+
+  private ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
+    return getAnnotatedAnnotations(element, Scope.class);
+  }
+
+  private ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
+      final Class<? extends Annotation> annotationType) {
+    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
+    return FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override public boolean apply(AnnotationMirror input) {
+            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
+          }
+        })
+        .toSet();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
new file mode 100644
index 000000000..6ae5ad013
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+
+/**
+ * A collection of items describing contractual issues with the code as presented to an annotation
+ * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}.
+ * Callers will typically print the results of the report to a {@link Messager} instance using
+ * {@link #printMessagesTo}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ValidationReport<T> {
+  abstract T subject();
+  abstract ImmutableSet<Item> items();
+
+  boolean isClean() {
+    return items().isEmpty();
+  }
+
+  void printMessagesTo(Messager messager) {
+    for (Item item : items()) {
+      item.printMessageTo(messager);
+    }
+  }
+
+  @AutoValue
+  static abstract class Item {
+    abstract String message();
+    abstract Element element();
+    abstract Optional<AnnotationMirror> annotation();
+
+    void printMessageTo(Messager messager) {
+      if (annotation().isPresent()) {
+        messager.printMessage(ERROR, message(), element(), annotation().get());
+      } else {
+        messager.printMessage(ERROR, message(), element());
+      }
+    }
+  }
+
+  static final class Builder<T> {
+    static final <T> Builder<T> about(T subject) {
+      return new Builder<T>(subject);
+    }
+
+    private final T subject;
+    private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
+
+    private Builder(T subject) {
+      this.subject = subject;
+    }
+
+    Builder<T> addItem(String message, Element element) {
+      items.add(new AutoValue_ValidationReport_Item(message, element,
+          Optional.<AnnotationMirror>absent()));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
+      items.add(new AutoValue_ValidationReport_Item(message, element, Optional.of(annotation)));
+      return this;
+    }
+
+    ValidationReport<T> build() {
+      return new AutoValue_ValidationReport<T>(subject, items.build());
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index 3fea485d1..a78f59fb2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
@@ -24,10 +25,13 @@
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static org.truth0.Truth.ASSERT;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 
 import javax.tools.JavaFileObject;
@@ -36,8 +40,38 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+
 @RunWith(JUnit4.class)
 public final class InjectProcessorTest {
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+  private static final JavaFileObject SCOPE_A =
+      JavaFileObjects.forSourceLines("test.ScopeA",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeA {}");
+  private static final JavaFileObject SCOPE_B =
+      JavaFileObjects.forSourceLines("test.ScopeB",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeB {}");
+
   @Test public void injectOnPrivateConstructor() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateConstructor",
         "package test;",
@@ -111,6 +145,36 @@
         .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
   }
 
+  @Test public void multipleQualifiersOnInjectConstructorParameter() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierConstructorParam",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierConstructorParam {",
+        "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new InjectProcessor()).failsToCompile()
+        // for whatever reason, javac only reports the error once on the constructor
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnClassWithMultipleScopes() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleScopeClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "@ScopeA @ScopeB class MultipleScopeClass {",
+        "  @Inject MultipleScopeClass() {}",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
+        .processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
+        .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
+  }
+
   @Test public void finalInjectField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
         "package test;",
@@ -137,6 +201,21 @@
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
 
+  @Test public void multipleQualifiersOnField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierInjectField {",
+        "  @Inject @QualifierA @QualifierB String s;",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
+        .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
+  }
+
   @Test public void abstractInjectMethod() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.AbstractInjectMethod",
         "package test;",
@@ -175,4 +254,19 @@
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
   }
+
+  @Test public void multipleQualifiersOnInjectMethodParameter() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierMethodParam",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierMethodParam {",
+        "  @Inject void method(@QualifierA @QualifierB String s) {}",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new InjectProcessor()).failsToCompile()
+        // for whatever reason, javac only reports the error once on the method
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+  }
 }
