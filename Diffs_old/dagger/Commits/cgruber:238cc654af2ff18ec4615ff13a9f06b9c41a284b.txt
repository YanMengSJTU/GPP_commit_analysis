diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 212ac5cc1..77fc3c220 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -61,12 +61,15 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.Generated;
 import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -75,6 +78,8 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
@@ -95,7 +100,7 @@
 import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
@@ -114,8 +119,9 @@
 abstract class AbstractComponentWriter {
 
   // TODO(dpb): Make all these fields private after refactoring is complete.
-
+  protected final Elements elements;
   protected final Types types;
+  protected final Key.Factory keyFactory;
   protected final Kind nullableValidationType;
   protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
@@ -145,8 +151,15 @@
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
   AbstractComponentWriter(
-      Types types, Diagnostic.Kind nullableValidationType, ClassName name, BindingGraph graph) {
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
     this.name = name;
     this.graph = graph;
@@ -521,7 +534,6 @@ private void addField(
 
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
@@ -858,7 +870,7 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             && !binding.bindingElement().getModifiers().contains(STATIC)) {
           parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
         }
-        parameters.addAll(getDependencyParameters(binding.implicitDependencies()));
+        parameters.addAll(getDependencyParameters(binding));
 
         Snippet factorySnippet =
             Snippet.format(
@@ -903,7 +915,7 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding)
         parameters.add(
             getComponentContributionSnippet(
                 graph.componentDescriptor().executorDependency().get()));
-        parameters.addAll(getProducerDependencyParameters(binding.dependencies()));
+        parameters.addAll(getProducerDependencyParameters(binding));
 
         return Snippet.format(
             "new %s(%s)",
@@ -918,54 +930,75 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     switch (binding.injectionStrategy()) {
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
-      case DELEGATE:
-        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
-        return Snippet.format(
-            "%s.delegatingTo(%s)",
-            ClassName.fromClass(MembersInjectors.class),
-            getMemberSelectSnippet(parentInjectorRequest.bindingKey()));
       case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(binding.implicitDependencies());
+        List<Snippet> parameters = getDependencyParameters(binding);
         return Snippet.format(
             "%s.create(%s)",
-            membersInjectorNameForMembersInjectionBinding(binding),
+            membersInjectorNameForType(binding.bindingElement()),
             Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
   }
 
-  private List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies) {
+  private List<Snippet> getDependencyParameters(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    Set<Key> keysSeen = new HashSet<>();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          })
-          .toSet());
-      if (bindingKeysWithDelegates.contains(key)) {
-        parameters.add(delegateFactoryVariableSnippet(key));
-      } else {
-        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
+            .asMap()
+            .values()) {
+      Set<BindingKey> requestedBindingKeys = new HashSet<>();
+      for (DependencyRequest dependencyRequest : requestsForKey) {
+        Element requestElement = dependencyRequest.requestElement();
+        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
+        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
+        if (keysSeen.add(key)) {
+          requestedBindingKeys.add(dependencyRequest.bindingKey());
+        }
+      }
+      if (!requestedBindingKeys.isEmpty()) {
+        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
+        if (bindingKeysWithDelegates.contains(key)) {
+          parameters.add(delegateFactoryVariableSnippet(key));
+        } else {
+          parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+        }
       }
     }
     return parameters.build();
   }
 
-  private List<Snippet> getProducerDependencyParameters(
-      Iterable<DependencyRequest> dependencies) {
+  // TODO(dpb): Investigate use of asMemberOf here.
+  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (requestType.getKind() == TypeKind.TYPEVAR) {
+      return types.asMemberOf(
+          MoreTypes.asDeclared(bindingTypeElement.asType()),
+          (requestElement.getKind() == ElementKind.PARAMETER)
+              ? MoreTypes.asElement(requestType)
+              : requestElement);
+    } else {
+      return requestType;
+    }
+  }
+
+  private List<Snippet> getProducerDependencyParameters(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          }));
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.dependencies())
+            .asMap()
+            .values()) {
+      BindingKey key =
+          Iterables.getOnlyElement(
+              FluentIterable.from(requestsForKey)
+                  .transform(
+                      new Function<DependencyRequest, BindingKey>() {
+                        @Override
+                        public BindingKey apply(DependencyRequest request) {
+                          return request.bindingKey();
+                        }
+                      }));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
       Class<?> frameworkClass =
           DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 2e5d869b1..7bd476a33 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -55,7 +55,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 
 /**
@@ -350,9 +350,11 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
 
-        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
-          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
-              membersInjectionBinding.parentInjectorRequest().get().key());
+        if (membersInjectionBinding.parentInjectorRequest().isPresent()
+            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
+          MembersInjectionBinding parentBinding =
+              rollUpMembersInjectionBindings(
+                  membersInjectionBinding.parentInjectorRequest().get().key());
           if (parentBinding.injectionStrategy().equals(NO_OP)) {
             return membersInjectionBinding.withoutParentInjectorRequest();
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index f79f0bc99..b5212f6bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -27,6 +27,7 @@
 import dagger.internal.codegen.writer.TypeName;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -38,11 +39,20 @@
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
+  private final Elements elements;
+  private final Key.Factory keyFactory;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
+  ComponentGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -115,14 +125,14 @@ Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
     }
 
     Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass)
-          ? snippet()
-          : qualifiedSelectSnippet();
+      return owningClass().equals(usingClass) ? snippet() : qualifiedSelectSnippet();
     }
   }
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    return new ComponentWriter(types, nullableValidationType, componentName, input).write();
+    return new ComponentWriter(
+            types, elements, keyFactory, nullableValidationType, componentName, input)
+        .write();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index ec90b08e6..785fe8117 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -114,9 +114,9 @@ public SourceVersion getSupportedSourceVersion() {
     this.factoryGenerator =
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, types, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 8690b3967..5221cf0a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -23,6 +23,7 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import javax.annotation.Generated;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
@@ -37,8 +38,13 @@
 class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types, Kind nullableValidationType, ClassName name, BindingGraph graph) {
-    super(types, nullableValidationType, name, graph);
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
+    super(types, elements, keyFactory, nullableValidationType, name, graph);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 071ce6982..a876f445c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -45,6 +45,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -191,8 +192,7 @@ private ProvisionBinding registerBinding(ProvisionBinding binding, boolean expli
    */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName =
-        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    ClassName membersInjectorName = membersInjectorNameForType(binding.bindingTypeElement());
     if (binding.injectionSites().isEmpty()) {
       // empty members injection bindings are special and don't need source files.
       // so, we just pretend
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index d11d7ef3e..1212e5aa2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -24,11 +24,17 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -56,7 +62,7 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
-
+        
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
@@ -64,18 +70,11 @@
 
   enum Strategy {
     NO_OP,
-    DELEGATE,
     INJECT_MEMBERS,
   }
 
   Strategy injectionStrategy() {
-    if (injectionSites().isEmpty()) {
-      return parentInjectorRequest().isPresent()
-          ? Strategy.DELEGATE
-          : Strategy.NO_OP;
-    } else {
-      return Strategy.INJECT_MEMBERS;
-    }
+    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
   MembersInjectionBinding withoutParentInjectorRequest() {
@@ -90,27 +89,6 @@ MembersInjectionBinding withoutParentInjectorRequest() {
           Optional.<DependencyRequest>absent());
   }
 
-  private static final Ordering<InjectionSite> INJECTION_ORDERING =
-      new Ordering<InjectionSite>() {
-        @Override
-        public int compare(InjectionSite left, InjectionSite right) {
-          checkArgument(left.element().getEnclosingElement()
-              .equals(right.element().getEnclosingElement()));
-          return ComparisonChain.start()
-              // fields before methods
-              .compare(left.element().getKind(), right.element().getKind())
-              // then sort by whichever element comes first in the parent
-              // this isn't necessary, but makes the processor nice and predictable
-              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
-              .result();
-        }
-
-        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
-          return injectionSite.element().getEnclosingElement().getEnclosedElements()
-              .indexOf(injectionSite.element());
-        }
-      };
-
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
@@ -123,6 +101,14 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+    
+    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+      return injectionSite
+          .element()
+          .getEnclosingElement()
+          .getEnclosedElements()
+          .indexOf(injectionSite.element());
+    }
   }
 
   static final class Factory {
@@ -139,33 +125,33 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectMethod(
+        ExecutableElement methodElement, DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-      checkArgument(isAnnotationPresent(methodElement, Inject.class));
       ExecutableType resolved =
           MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType,
-              methodElement.getParameters(),
-              resolved.getParameterTypes()));
+              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectField(
+        VariableElement fieldElement, DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
-              containingType, fieldElement, resolved)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(
+                  containingType, fieldElement, resolved)));
     }
-  
+
     /** Returns an unresolved version of this binding. */
     MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
       checkState(binding.hasNonDefaultTypeParameters());
@@ -178,76 +164,146 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
      * this will return a resolved binding, with the key & type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+    MembersInjectionBinding forInjectedType(
+        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
       // If the class this is injecting has some type arguments, resolve everything.
-      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
         // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+        checkState(
+            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
             "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(type));
-        type = resolved;
-      }
-
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      final DeclaredType resolved = type;
-      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
-          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        injectionSitesBuilder.addAll(enclosedElement.accept(
-            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
-                Optional.<InjectionSite>absent()) {
-                  @Override
-                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
-                      Void p) {
-                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
-                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-
-                  @Override
-                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
-                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
-                        ? Optional.of(injectionSiteForInjectField(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-                }, null).asSet());
+            types.erasure(resolved),
+            types.erasure(declaredType));
+        declaredType = resolved;
       }
-      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
-
-      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
-          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-            @Override public Set<DependencyRequest> apply(InjectionSite input) {
-              return input.dependencies();
-            }
-          })
-          .toSet();
+      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
+      ImmutableSet<DependencyRequest> dependencies =
+          FluentIterable.from(injectionSites)
+              .transformAndConcat(
+                  new Function<InjectionSite, Set<DependencyRequest>>() {
+                    @Override
+                    public Set<DependencyRequest> apply(InjectionSite input) {
+                      return input.dependencies();
+                    }
+                  })
+              .toSet();
 
       Optional<DependencyRequest> parentInjectorRequest =
-          MoreTypes.nonObjectSuperclass(types, elements, type)
-              .transform(new Function<DeclaredType, DependencyRequest>() {
-                @Override public DependencyRequest apply(DeclaredType input) {
-                  return dependencyRequestFactory.forMembersInjectedType(input);
-                }
-              });
-
-      Key key = keyFactory.forMembersInjectedType(type);
+          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
+              .transform(
+                  new Function<DeclaredType, DependencyRequest>() {
+                    @Override
+                    public DependencyRequest apply(DeclaredType input) {
+                      return dependencyRequestFactory.forMembersInjectedType(input);
+                    }
+                  });
+
+      Key key = keyFactory.forMembersInjectedType(declaredType);
+      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
           key,
           dependencies,
-          new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(parentInjectorRequest.asSet())
-              .addAll(dependencies)
-              .build(),
+          dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
           parentInjectorRequest);
     }
-    
-    protected boolean modifiersSupported(Element e) {
-      return !e.getModifiers().contains(PRIVATE) && !e.getModifiers().contains(STATIC);
+
+    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
+      Set<InjectionSite> injectionSites = new HashSet<>();
+      final List<TypeElement> ancestors = new ArrayList<>();
+      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
+      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
+          currentType.isPresent();
+          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+        final DeclaredType type = currentType.get();
+        ancestors.add(MoreElements.asType(type.asElement()));
+        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
+          Optional<InjectionSite> maybeInjectionSite =
+              injectionSiteVisitor.visit(enclosedElement, type);
+          if (maybeInjectionSite.isPresent()) {
+            InjectionSite injectionSite = maybeInjectionSite.get();
+            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
+              injectionSites.add(injectionSite);
+            }
+            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+              ExecutableElement injectionSiteMethod =
+                  MoreElements.asExecutable(injectionSite.element());
+              overriddenMethodMap.put(
+                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
+            }
+          }
+        }
+      }
+      return ImmutableSortedSet.copyOf(
+          new Comparator<InjectionSite>() {
+            @Override
+            public int compare(InjectionSite left, InjectionSite right) {
+              return ComparisonChain.start()
+                  // supertypes before subtypes
+                  .compare(
+                      ancestors.indexOf(right.element().getEnclosingElement()),
+                      ancestors.indexOf(left.element().getEnclosingElement()))
+                  // fields before methods
+                  .compare(left.element().getKind(), right.element().getKind())
+                  // then sort by whichever element comes first in the parent
+                  // this isn't necessary, but makes the processor nice and predictable
+                  .compare(
+                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
+                  .result();
+            }
+          },
+          injectionSites);
+    }
+
+    private boolean shouldBeInjected(
+        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
+      if (!isAnnotationPresent(injectionSite, Inject.class)
+          || injectionSite.getModifiers().contains(PRIVATE)
+          || injectionSite.getModifiers().contains(STATIC)) {
+        return false;
+      }
+
+      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
+        return true;
+      }
+
+      // For each method with the same name belonging to any descendant class, return false if any
+      // method has already overridden the injectionSite method. To decrease the number of methods
+      // that are checked, we store the already injected methods in a SetMultimap and only
+      // check the methods with the same name.
+      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
+      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
+      for (ExecutableElement method :
+          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
+        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
+          return false;
+        }
+      }
+      return true;
     }
+
+    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
+            Optional.<InjectionSite>absent()) {
+          @Override
+          public Optional<InjectionSite> visitExecutableAsMethod(
+              ExecutableElement e, DeclaredType type) {
+            return Optional.of(injectionSiteForInjectMethod(e, type));
+          }
+
+          @Override
+          public Optional<InjectionSite> visitVariableAsField(
+              VariableElement e, DeclaredType type) {
+            return (isAnnotationPresent(e, Inject.class)
+                    && !e.getModifiers().contains(PRIVATE)
+                    && !e.getModifiers().contains(STATIC))
+                ? Optional.of(injectionSiteForInjectField(e, type))
+                : Optional.<InjectionSite>absent();
+          }
+        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4d0db6cc..429b4007f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,7 +15,8 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -39,25 +40,25 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.VoidName;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -66,24 +67,18 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
-  private final Elements elements;
-  private final Types types;
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
       Filer filer,
-      Elements elements,
-      Types types,
       DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    return membersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -105,8 +100,10 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    Set<String> delegateMethods = new HashSet<>();
+
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.hasNonDefaultTypeParameters()); 
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -135,21 +132,6 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-    Optional<DeclaredType> supertype =
-        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
-    if (supertype.isPresent()) {
-      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
-      injectorWriter
-          .addField(supertypeMemebersInjectorType, "supertypeInjector")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
-      constructorWriter.body()
-          .addSnippet("assert supertypeInjector != null;")
-          .addSnippet("this.supertypeInjector = supertypeInjector;");
-      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
-    }
-
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
@@ -182,35 +164,123 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
         Joiner.on(", ").join(params.keySet()));
     
-    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
+      Element injectionSiteElement = injectionSite.element();
+      ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+      if (!visibleTo(binding, injectionSite)) {
+        parameters.add(Snippet.format("instance"));
+      }
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(
-              fieldDependency.bindingKey());
-          injectMembersWriter.body().addSnippet("instance.%s = %s;",
-              injectionSite.element().getSimpleName(),
-              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
-                  fieldDependency.kind()));
+          FieldWriter singleField = dependencyFields.get(fieldDependency.bindingKey());
+          parameters.add(
+              frameworkTypeUsageStatement(
+                  Snippet.format("%s", singleField.name()), fieldDependency.kind()));
           break;
         case METHOD:
-          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field = depedencyFields.get(
-                methodDependency.bindingKey());
-            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
-                methodDependency.kind()));
+            FieldWriter field = dependencyFields.get(methodDependency.bindingKey());
+            parameters.add(
+                frameworkTypeUsageStatement(
+                    Snippet.format("%s", field.name()), methodDependency.kind()));
           }
-          injectMembersWriter.body().addSnippet("instance.%s(%s);",
-              injectionSite.element().getSimpleName(),
-              Snippet.makeParametersSnippet(parameters.build()));
           break;
         default:
           throw new AssertionError();
       }
+      injectMembersWriter
+          .body()
+          .addSnippet(
+              injectMemberSnippet(
+                  injectionSite, binding, Snippet.makeParametersSnippet(parameters.build())));
+      if (!injectionSiteElement.getModifiers().contains(PUBLIC)
+          && injectionSiteElement.getEnclosingElement().equals(binding.bindingElement())
+          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSiteElement))) {
+        writeInjectorMethodForSubclasses(
+            injectorWriter,
+            typeParameters,
+            injectedTypeName,
+            injectionSiteElement,
+            injectionSite.dependencies());
+      }
     }
     return ImmutableSet.of(writer);
   }
+  
+  private boolean visibleTo(Binding binding, InjectionSite injectionSite) {
+    return MoreElements.getPackage(injectionSite.element())
+            .equals(MoreElements.getPackage(binding.bindingElement()))
+        || injectionSite.element().getModifiers().contains(PUBLIC);
+  }
+
+  private Snippet injectMemberSnippet(
+      InjectionSite injectionSite, MembersInjectionBinding binding, Snippet parametersSnippet) {
+
+    if (visibleTo(binding, injectionSite)) {
+      return Snippet.format(
+          (injectionSite.element().getKind().isField()) ? "%s.%s = %s;" : "%s.%s(%s);",
+          getInstanceSnippetWithPotentialCast(
+              injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+          injectionSite.element().getSimpleName(),
+          parametersSnippet);
+    } else {
+      return Snippet.format(
+          "%s.%s(%s);",
+          membersInjectorNameForType(
+              MoreElements.asType(injectionSite.element().getEnclosingElement())),
+          injectionSiteDelegateMethodName(injectionSite.element()),
+          parametersSnippet);
+    }
+  }
+
+  private Snippet getInstanceSnippetWithPotentialCast(
+      Element injectionSiteElement, Element bindingElement) {
+    return (injectionSiteElement.equals(bindingElement))
+        ? Snippet.format("instance")
+        : Snippet.format("((%s)instance)", injectionSiteElement);
+  }
+
+  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+    return "inject"
+        + CaseFormat.LOWER_CAMEL.to(
+            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
+  }
+
+  private void writeInjectorMethodForSubclasses(
+      ClassWriter injectorWriter,
+      List<TypeVariableName> typeParameters,
+      TypeName injectedTypeName,
+      Element injectionElement,
+      ImmutableSet<DependencyRequest> dependencies) {
+    MethodWriter methodWriter =
+        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
+    methodWriter.addModifiers(PUBLIC, STATIC);
+    methodWriter.addParameter(injectedTypeName, "instance");
+    methodWriter.addTypeParameters(typeParameters);
+    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
+    for (DependencyRequest methodDependency : dependencies) {
+      Element requestElement = methodDependency.requestElement();
+      methodWriter.addParameter(
+          TypeNames.forTypeMirror(requestElement.asType()), requestElement.toString());
+      providedParameters.add(Snippet.format("%s", requestElement));
+    }
+    if (injectionElement.getKind().isField()) {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s = %s;",
+              injectionElement.getSimpleName(),
+              Iterables.getOnlyElement(providedParameters.build()));
+    } else {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s(%s);",
+              injectionElement.getSimpleName(),
+              Snippet.makeParametersSnippet(providedParameters.build()));
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 57c815b23..890d3553b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -251,7 +251,7 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
    */
   static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
       MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
+    ClassName factoryName = membersInjectorNameForType(binding.bindingElement());
     TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
     // If the binding is parameterized, parameterize the MembersInjector.
     if (bindingName instanceof ParameterizedTypeName) {
@@ -261,10 +261,11 @@ static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
     return factoryName;
   }
 
-  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
-    return injectedClassName.topLevelClassName().peerNamed(
-        injectedClassName.classFileName() + "_MembersInjector");
+  static ClassName membersInjectorNameForType(TypeElement typeElement) {
+    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
+    return injectedClassName
+        .topLevelClassName()
+        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
   private static String factoryPrefix(ProvisionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 908ee8eea..3aab845aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -58,6 +58,8 @@ public SubcomponentWriter(
       BindingGraph subgraph) {
     super(
         parent.types,
+        parent.elements,
+        parent.keyFactory,
         parent.nullableValidationType,
         parent.name.nestedClassNamed(subcomponentSimpleName(subgraph)),
         subgraph);
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 25762ea94..a10d8d7c0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -141,59 +141,57 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<Parent> parentMembersInjector;",
-        "  private MembersInjector<Child> childMembersInjector;",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
-        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = Child_Factory.create(childMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<Child> childMembersInjector;",
+            "  private Provider<Child> childProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
+            "    this.childProvider = Child_Factory.create(childMembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return childProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void fieldAndMethodGenerics() {
@@ -209,7 +207,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -232,21 +231,32 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
         "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get())",
+        "    instance.register(bProvider.get());",
         "  }",
         "",
         "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
         "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "      return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
         "  }",
+        "",
+        "  public static <A, B> void injectA(GenericClass<A, B> instance, A a) {",
+        "    instance.a = a;",
+        "  }",
+        "",
+        "  public static <A, B> void injectRegister(GenericClass<A, B> instance, B b) {",
+        "    instance.register(b);",
+        "  }",
+        "",
         "}");
-    assertAbout(javaSource()).that(file)
+    assertAbout(javaSource())
+        .that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void subclassedGenericMembersInjectors() {
@@ -289,7 +299,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.Child_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -299,41 +310,51 @@ public void parentClass_injectedMembersInSupertype() {
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
-        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<T> tProvider;",
+        "  private final Provider<T> tAndXProvider;",
+        "  private final Provider<A> aAndYProvider;",
+        "  private final Provider<A2> a2Provider;",
         "",
         "  public Child_MembersInjector(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    assert tAndXProvider != null;",
+        "    this.tAndXProvider = tAndXProvider;",
+        "    assert aAndYProvider != null;",
+        "    this.aAndYProvider = aAndYProvider;",
+        "    assert a2Provider != null;",
+        "    this.a2Provider = a2Provider;",
         "  }",
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
-        "    instance.a = aProvider.get();",
-        "    instance.t = tProvider.get();",
+        "    ((test.Parent) instance).x = tAndXProvider.get();",
+        "    ((test.Parent) instance).y = aAndYProvider.get();",
+        "    ((test.Parent) instance).a2 = a2Provider.get();",
+        "    instance.a = aAndYProvider.get();",
+        "    instance.t = tAndXProvider.get();",
         "  }",
         "",
         "  public static <T> MembersInjector<Child<T>> create(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
+        "  public static <T> void injectA(Child<T> instance, A a) {",
+        "    instance.a = a;",
+        "  }",
+        "",
+        "  public static <T> void injectT(Child<T> instance, T t) {",
+        "    instance.t = t;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(a, a2, parent, child))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void fieldInjection() {
@@ -349,18 +370,19 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.FieldInjection_MembersInjector",
         "package test;",
         "",
+        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection_MembersInjector ",
+        "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
-        "",
         "  private final Provider<String> stringProvider;",
         "",
         "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
@@ -368,7 +390,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -377,14 +400,30 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(",
-        "      Provider<String> stringProvider) {",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
         "    return new FieldInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectString(FieldInjection instance, String string) {",
+        "    instance.string = string;",
+        "  }",
+        "",
+        "  public static void injectLazyString(",
+        "      FieldInjection instance, Lazy<String> lazyString) {",
+        "    instance.lazyString = lazyString;",
+        "  }",
+        "",
+        "  public static void injectStringProvider(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void methodInjection() {
@@ -405,14 +444,15 @@ public void parentClass_injectedMembersInSupertype() {
         "test.MethodInjection_MembersInjector",
         "package test;",
         "",
+        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection_MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
+        "public final class MethodInjection_MembersInjector",
+        "     implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
@@ -421,7 +461,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -435,14 +476,35 @@ public void parentClass_injectedMembersInSupertype() {
         "      Provider<String> stringProvider) {",
         "    return new MethodInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectNoArgs(MethodInjection instance) {",
+        "    instance.noArgs();",
+        "  }",
+        "",
+        "  public static void injectOneArg(MethodInjection instance, String string) {",
+        "    instance.oneArg(string);",
+        "  }",
+        "",
+        "  public static void injectManyArgs(",
+        "      MethodInjection instance,",
+        "      String string,",
+        "      Lazy<String> lazyString,",
+        "      Provider<String> stringProvider) {",
+        "    instance.manyArgs(string, lazyString, stringProvider);",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+  @Test
+  public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -464,13 +526,14 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection_MembersInjector ",
+        "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
         "  private final Provider<String> stringAndSProvider;",
         "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
+        "  public MixedMemberInjection_MembersInjector(",
+        "      Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
@@ -478,7 +541,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -494,10 +558,28 @@ public void parentClass_injectedMembersInSupertype() {
         "    return new MixedMemberInjection_MembersInjector(",
         "        stringAndSProvider, objectAndOProvider);",
         "  }",
+        "  public static void injectString(MixedMemberInjection instance, String string) {",
+        "    instance.string = string;",
+        "  }",
+        "",
+        "  public static void injectObject(MixedMemberInjection instance, Object object) {",
+        "    instance.object = object;",
+        "  }",
+        "",
+        "  public static void injectSetString(MixedMemberInjection instance, String s) {",
+        "    instance.setString(s);",
+        "  }",
+        "",
+        "  public static void injectSetObject(MixedMemberInjection instance, Object o) {",
+        "    instance.setObject(o);",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void injectConstructorAndMembersInjection() {
@@ -530,7 +612,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(AllInjections instance) {",
+        "  @Override",
+        "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -539,10 +622,16 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "    return new AllInjections_MembersInjector(sProvider);",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  public static void injectS(AllInjections instance, String s) {",
+        "    instance.s = s;",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedMembersInjector);
@@ -570,93 +659,98 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
+        "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
-        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
+        "  public B_MembersInjector(Provider<String> sProvider) {",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(B instance) {",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(",
-        "      MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    return new B_MembersInjector(supertypeInjector, sProvider);",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "  public static void injectS(B instance, String s) {",
+        "    instance.s = s;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
-  @Test public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterType {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
-        "}");
+  @Test
+  public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
+          "test.OuterType",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import javax.inject.Inject;",
+          "",
+          "final class OuterType {",
+          "  static class A {",
+          "    @Inject A() {}",
+          "  }",
+          "  static class B {",
+          "    @Inject A a;",
+          "  }",
+          "  @Component interface SimpleComponent {",
+          "    A a();",
+          "    void inject(B b);",
+          "  }",
+          "}");
     JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-        "    return new OuterType$B_MembersInjector(aProvider);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+          "test.OuterType$B_MembersInjector",
+          "package test;",
+          "",
+          "import dagger.MembersInjector;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "import test.OuterType.A;",
+          "import test.OuterType.B;",
+          "",
+          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+          "  private final Provider<A> aProvider;",
+          "",
+          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+          "    assert aProvider != null;",
+          "    this.aProvider = aProvider;",
+          "  }",
+          "",
+          "  @Override",
+          "  public void injectMembers(B instance) {",
+          "    if (instance == null) {",
+          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+          "    }",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "",
+          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  public static void injectA(B instance, A a) {",
+          "    instance.a = a;",
+          "  }",
+          "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(bMembersInjector);
+        .and()
+        .generatesSources(bMembersInjector);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 40ceb7ede..8df80d19b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -184,62 +184,49 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import foreign.B;",
-        "import foreign.B_MembersInjector;",
-        "import foreign.C_MembersInjector;",
-        "import foreign.DaggerTestComponent_PackageProxy;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<D> dMembersInjector;",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
-        "  private MembersInjector<B> bMembersInjector;",
-        "  private MembersInjector<A> aMembersInjector;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.cMembersInjector =",
-        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
-        "    this.bMembersInjector = B_MembersInjector.create(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
-        "    this.aMembersInjector = A_MembersInjector.create(",
-        "        bMembersInjector, NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectA(A a) {",
-        "    aMembersInjector.injectMembers(a);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<A> aMembersInjector;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectA(A a) {",
+            "    aMembersInjector.injectMembers(a);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assert_().about(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
