diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 40791d463..711332d6a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -50,6 +50,7 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -287,7 +288,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
         BindingsType bindingsType = ProvisionBinding.getBindingsType(bindings);
         switch (bindingsType) {
-          case SETBINDING:
+          case SET_BINDING:
             ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
             for (ProvisionBinding binding : bindings) {
               setFactoryParameters.add(initializeFactoryForBinding(
@@ -297,9 +298,11 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                 memberSelectSnippets.get(frameworkKey), ClassName.fromClass(SetFactory.class),
                 Snippet.makeParametersSnippet(setFactoryParameters.build()));
             break;
-          case MAPBINDING:
-            if (bindings.iterator().hasNext()) {
-              ProvisionBinding firstBinding = bindings.iterator().next();
+          case MAP_BINDING:
+            if (!bindings.isEmpty()) {
+              Iterator<ProvisionBinding> iterator = bindings.iterator();
+              // get type information from first binding in iterator
+              ProvisionBinding firstBinding = iterator.next();
               DeclaredType declaredMapType =
                   Util.getDeclaredTypeOfMap(firstBinding.providedKey().type());
               TypeMirror mapKeyType = Util.getKeyTypeOfMap(declaredMapType);
@@ -310,21 +313,17 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                   TypeNames.forTypeMirror(mapKeyType),
                   TypeNames.forTypeMirror(mapValueType),
                   bindings.size());
+              writeEntry(constructorWriter, firstBinding, initializeFactoryForBinding(
+                  firstBinding, componentContributionFields, memberSelectSnippets));
+              while (iterator.hasNext()) {
+                ProvisionBinding binding = iterator.next();
+                writeEntry(constructorWriter, binding, initializeFactoryForBinding(
+                    binding, componentContributionFields, memberSelectSnippets));
+              }
+              constructorWriter.body().addSnippet("    .build();");
             }
-
-            for (ProvisionBinding binding : bindings) {
-              AnnotationMirror mapKeyAnnotationMirror =
-                  Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
-              Map<? extends ExecutableElement, ? extends AnnotationValue> map =
-                  mapKeyAnnotationMirror.getElementValues();
-              constructorWriter.body().addSnippet("    .put(%s, %s)",
-                  Iterables.getOnlyElement(map.entrySet()).getValue(),
-                  initializeFactoryForBinding(
-                      binding, componentContributionFields, memberSelectSnippets));
-            }
-            constructorWriter.body().addSnippet("    .build();");
             break;
-          case SINGULARBINDING:
+          case SINGULAR_BINDING:
             ProvisionBinding binding = Iterables.getOnlyElement(bindings);
             constructorWriter.body().addSnippet("this.%s = %s;",
                 memberSelectSnippets.get(frameworkKey),
@@ -440,4 +439,15 @@ private static Snippet initializeMembersInjectorForBinding(
     }
     return parameters.build();
   }
+
+  // add one map entry for map Provider in Constructor
+  private void writeEntry(ConstructorWriter constructorWriter, ProvisionBinding binding,
+      Snippet factory) {
+    AnnotationMirror mapKeyAnnotationMirror =
+        Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+        mapKeyAnnotationMirror.getElementValues();
+    constructorWriter.body().addSnippet("    .put(%s, %s)",
+        Iterables.getOnlyElement(map.entrySet()).getValue(), factory);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 0afd875b3..b2aae3a8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -110,11 +110,11 @@
   
   static enum BindingsType {
     /** Represents set bindings. */
-    SETBINDING, 
+    SET_BINDING, 
     /** Represents map bindings. */
-    MAPBINDING, 
+    MAP_BINDING, 
     /** Represents a valid non-collection binding. */
-    SINGULARBINDING,
+    SINGULAR_BINDING,
   }
   
   /**
@@ -135,11 +135,11 @@ static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
         throw new IllegalArgumentException("no bindings");
       case 1:
         if (SET_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
-          return BindingsType.SETBINDING;
+          return BindingsType.SET_BINDING;
         } else if (MAP_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
-          return BindingsType.MAPBINDING;
+          return BindingsType.MAP_BINDING;
         }
-        return BindingsType.SINGULARBINDING;
+        return BindingsType.SINGULAR_BINDING;
       default:
         Iterator<ProvisionBinding> iterator = bindings.iterator();
         boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
@@ -149,7 +149,7 @@ static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
             checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
                 NON_SETBINDING);
           }
-          return BindingsType.SETBINDING;
+          return BindingsType.SET_BINDING;
         }
 
         iterator = bindings.iterator();
@@ -160,7 +160,7 @@ static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
             checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
                 NON_MAPBINDING);
           }
-          return BindingsType.MAPBINDING;
+          return BindingsType.MAP_BINDING;
         }
         throw new IllegalStateException(INVALID_COLLECTIONBINDING);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index bff40ab06..9b826f971 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -188,15 +188,15 @@
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
       BindingsType bindingsType = ProvisionBinding.getBindingsType(bindingsForKey);
       switch (bindingsType) {
-        case SETBINDING:
+        case SET_BINDING:
           providerNames.put(entry.getKey(),
               new KeyVariableNamer().apply(entry.getKey()) + "Provider");
           break;
-        case MAPBINDING:
+        case MAP_BINDING:
           providerNames.put(entry.getKey(),
               new KeyVariableNamer().apply(entry.getKey()) + "Provider");
           break;
-        case SINGULARBINDING:
+        case SINGULAR_BINDING:
           ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
           providerNames.put(entry.getKey(),
               binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
