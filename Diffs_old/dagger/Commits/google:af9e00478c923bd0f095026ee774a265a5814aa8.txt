diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 4cb230f17..8a775d04a 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -30,6 +30,8 @@
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.model.BindingKind.DELEGATE;
+import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static dagger.model.BindingKind.MULTIBOUND_SET;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.HashBasedTable;
@@ -114,7 +116,7 @@ private ComponentBindingExpressions(
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
         new MembersInjectionMethods(generatedComponentModel, this, graph, elements, types);
-    this.switchingProviders = new SwitchingProviders(generatedComponentModel, this, graph, types);
+    this.switchingProviders = new SwitchingProviders(generatedComponentModel, this, types);
   }
 
   /**
@@ -279,7 +281,11 @@ private BindingExpression createBindingExpression(
    */
   private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
-    Optional<MemberSelect> staticMethod = staticFactoryCreation(resolvedBindings);
+    // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
+    Optional<MemberSelect> staticMethod =
+        useStaticFactoryCreation(resolvedBindings.contributionBinding())
+            ? staticFactoryCreation(resolvedBindings)
+            : Optional.empty();
     FrameworkInstanceCreationExpression frameworkInstanceCreationExpression =
         resolvedBindings.scope().isPresent()
             ? scope(resolvedBindings, frameworkInstanceCreationExpression(resolvedBindings))
@@ -573,6 +579,20 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
     throw new AssertionError();
   }
 
+  /**
+   * Returns {@code true} if the binding should use the static factory creation strategy.
+   *
+   * In default mode, we always use the static factory creation strategy. In Android mode, we
+   * prefer to use the SwitchingProvider than the static factories to reduce class loading; however,
+   * we allow static factories that can reused across multiple bindings, e.g. {@code MapFactory} or
+   * {@code SetFactory}.
+   */
+  private boolean useStaticFactoryCreation(ContributionBinding binding) {
+    return !compilerOptions.experimentalAndroidMode()
+        || binding.kind().equals(MULTIBOUND_MAP)
+        || binding.kind().equals(MULTIBOUND_SET);
+  }
+
   /**
    * Returns {@code true} if we can use a direct (not {@code Provider.get()}) expression for this
    * binding. If the binding doesn't {@linkplain #needsCaching(ResolvedBindings) need to be cached},
@@ -609,7 +629,7 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
         return wrapInMethod(
             resolvedBindings,
             RequestKind.PROVIDER,
-            switchingProviders.newBindingExpression(resolvedBindings.key()));
+            switchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
       }
     } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
         && !needsCaching(resolvedBindings)) {
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 313069600..8f8dde15c 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -35,7 +34,6 @@
 import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Optional;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
@@ -119,7 +117,7 @@
       MultimapBuilder.enumKeys(MethodSpecKind.class).arrayListValues().build();
   private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
-  private Optional<Supplier<TypeSpec>> switchingProviderSupplier = Optional.empty();
+  private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
 
   private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
     this.name = name;
@@ -183,8 +181,7 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
 
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
   void addSwitchingProvider(Supplier<TypeSpec> typeSpecSupplier) {
-    checkState(!switchingProviderSupplier.isPresent());
-    switchingProviderSupplier = Optional.of(typeSpecSupplier);
+    switchingProviderSupplier.add(typeSpecSupplier);
   }
 
   /** Adds the given code block to the initialize methods of the component. */
@@ -217,7 +214,7 @@ void claimMethodName(Name name) {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
     methodSpecsMap.asMap().values().forEach(component::addMethods);
     typeSpecsMap.asMap().values().forEach(component::addTypes);
-    switchingProviderSupplier.map(Supplier::get).ifPresent(component::addType);
+    switchingProviderSupplier.stream().map(Supplier::get).forEach(component::addType);
     return component;
   }
 }
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index 29eac3f5a..306ec61f7 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -17,25 +17,31 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getLast;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
-import static dagger.internal.codegen.CodeBlocks.toConcatenatedCodeBlock;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.model.RequestKind.INSTANCE;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.model.Key;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.TreeMap;
 import javax.inject.Provider;
@@ -47,95 +53,174 @@
  * class that can provide instances for all types by switching on an id.
  */
 final class SwitchingProviders {
+  /**
+   * Each switch size is fixed at 100 cases each and put in its own method. This is to limit the
+   * size of the methods so that we don't reach the "huge" method size limit for Android that will
+   * prevent it from being AOT compiled in some versions of Android (b/77652521). This generally
+   * starts to happen around 1500 cases, but we are choosing 100 to be safe.
+   */
+  // TODO(user): Include a proguard_spec in the Dagger library to prevent inlining these methods?
+  // TODO(ronshapiro): Consider making this configurable via a flag.
+  private static final int MAX_CASES_PER_SWITCH = 100;
+
+  private static final long MAX_CASES_PER_CLASS = MAX_CASES_PER_SWITCH * MAX_CASES_PER_SWITCH;
   private static final TypeVariableName T = TypeVariableName.get("T");
 
-  // Keep the switch cases ordered by switch id.
-  private final Map<Integer, CodeBlock> switchCases = new TreeMap<>();
-  private final Map<Key, Integer> switchIds = new HashMap<>();
+  /**
+   * Maps a {@link Key} to an instance of a {@link SwitchingProviderExpressions}. Each group of
+   * {@code MAX_CASES_PER_CLASS} keys will share the same instance.
+   */
+  private final Map<Key, SwitchingProviderExpressions> switchingProviderExpressionsMap =
+      new LinkedHashMap<>();
 
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final BindingGraph graph;
   private final GeneratedComponentModel generatedComponentModel;
   private final ClassName owningComponent;
-  private final ClassName switchingProviderType;
   private final DaggerTypes types;
+  private final UniqueNameSet switchingProviderNames = new UniqueNameSet();
 
   SwitchingProviders(
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      BindingGraph graph,
       DaggerTypes types) {
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.graph = checkNotNull(graph);
     this.types = checkNotNull(types);
     this.owningComponent = checkNotNull(generatedComponentModel).name();
-    this.switchingProviderType = owningComponent.nestedClass("SwitchingProvider");
   }
 
   /**
    * Returns the binding expression for a binding that satisfies its {link Provider} requests with
    * the generated {@code SwitchingProvider}.
    */
-  BindingExpression newBindingExpression(Key key) {
+  BindingExpression newBindingExpression(ContributionBinding binding) {
     return new BindingExpression() {
       @Override
       Expression getDependencyExpression(ClassName requestingClass) {
-        if (!switchIds.containsKey(key)) {
-          // Register the SwitchingProvider creation method the first time it's requested.
-          if (switchIds.isEmpty()) {
-            generatedComponentModel.addSwitchingProvider(
-                SwitchingProviders.this::createSwitchingProviderType);
-          }
-
-          int switchId = switchIds.size();
-          switchIds.put(key, switchId);
-          switchCases.put(switchId, createSwitchCaseCodeBlock(key));
-        }
-
-        return Expression.create(
-            types.wrapType(key.type(), Provider.class),
-            CodeBlock.of("new $T<>($L)", switchingProviderType, switchIds.get(key)));
+        return switchingProviderExpressionsMap
+            .computeIfAbsent(binding.key(), key -> getSwitchingProviderExpressions())
+            .getExpression(binding);
       }
     };
   }
 
-  private CodeBlock createSwitchCaseCodeBlock(Key key) {
-    CodeBlock instanceCodeBlock =
+  private SwitchingProviderExpressions getSwitchingProviderExpressions() {
+    if (switchingProviderExpressionsMap.size() % MAX_CASES_PER_CLASS == 0) {
+      String name = switchingProviderNames.getUniqueName("SwitchingProvider");
+      SwitchingProviderExpressions switchingProviderExpressions =
+          new SwitchingProviderExpressions(owningComponent.nestedClass(name));
+      generatedComponentModel.addSwitchingProvider(
+          switchingProviderExpressions::createSwitchingProviderType);
+      return switchingProviderExpressions;
+    }
+    return getLast(switchingProviderExpressionsMap.values());
+  }
+
+  // TODO(user): Consider just merging this class with SwitchingProviders.
+  private final class SwitchingProviderExpressions {
+    // Keep the switch cases ordered by switch id. The switch Ids are assigned in pre-order
+    // traversal, but the switch cases are assigned in post-order traversal of the binding graph.
+    private final Map<Integer, CodeBlock> switchCases = new TreeMap<>();
+    private final Map<Key, Integer> switchIds = new HashMap<>();
+    private final ClassName switchingProviderType;
+
+    SwitchingProviderExpressions(ClassName switchingProviderType) {
+      this.switchingProviderType = checkNotNull(switchingProviderType);
+    }
+
+    private Expression getExpression(ContributionBinding binding) {
+      if (!switchIds.containsKey(binding.key())) {
+        int switchId = switchIds.size();
+        switchIds.put(binding.key(), switchId);
+        switchCases.put(switchId, createSwitchCaseCodeBlock(binding));
+      }
+
+      return Expression.create(
+          types.wrapType(binding.key().type(), Provider.class),
+          CodeBlock.of("new $T<>($L)", switchingProviderType, switchIds.get(binding.key())));
+    }
+
+    private CodeBlock createSwitchCaseCodeBlock(ContributionBinding binding) {
+      CodeBlock instanceCodeBlock =
         componentBindingExpressions
-            .getDependencyExpression(key, INSTANCE, owningComponent)
+            .getDependencyExpression(binding.key(), INSTANCE, owningComponent)
             .box(types)
             .codeBlock();
 
-    return CodeBlock.builder()
-        // TODO(user): Is there something else more useful than the key?
-        .add("case $L: // $L \n", switchIds.get(key), key)
-        .addStatement("return ($T) $L", T, instanceCodeBlock)
-        .build();
-  }
+      return CodeBlock.builder()
+          // TODO(user): Is there something else more useful than the key?
+          .add("case $L: // $L \n", switchIds.get(binding.key()), binding.key())
+          .addStatement("return ($T) $L", T, instanceCodeBlock)
+          .build();
+    }
+
+    private TypeSpec createSwitchingProviderType() {
+      return classBuilder(switchingProviderType)
+          .addModifiers(PRIVATE, FINAL)
+          .addTypeVariable(T)
+          .addSuperinterface(providerOf(T))
+          .addField(TypeName.INT, "id", PRIVATE, FINAL)
+          .addMethod(
+              constructorBuilder()
+                  .addParameter(TypeName.INT, "id")
+                  .addStatement("this.id = id")
+                  .build())
+          .addMethods(getMethods())
+          .build();
+    }
 
-  private TypeSpec createSwitchingProviderType() {
-    return classBuilder(switchingProviderType)
-        .addModifiers(PRIVATE, FINAL)
-        .addTypeVariable(T)
-        .addSuperinterface(providerOf(T))
-        .addField(TypeName.INT, "id", PRIVATE, FINAL)
-        .addMethod(
-            constructorBuilder()
-                .addParameter(TypeName.INT, "id")
-                .addStatement("this.id = id")
-                .build())
-        .addMethod(
+    private ImmutableList<MethodSpec> getMethods() {
+      ImmutableList<CodeBlock> switchCodeBlockPartitions = switchCodeBlockPartitions();
+      if (switchCodeBlockPartitions.size() == 1) {
+        // There are less than MAX_CASES_PER_SWITCH cases, so no need for extra get methods.
+        return ImmutableList.of(
             methodBuilder("get")
                 .addModifiers(PUBLIC)
                 .addAnnotation(suppressWarnings(UNCHECKED))
                 .addAnnotation(Override.class)
                 .returns(T)
-                .beginControlFlow("switch (id)")
-                .addCode(switchCases.values().stream().collect(toConcatenatedCodeBlock()))
-                .addStatement("default: throw new $T(id)", AssertionError.class)
-                .endControlFlow()
-                .build())
-        .build();
+                .addCode(getOnlyElement(switchCodeBlockPartitions))
+                .build());
+      }
+
+      // This is the main public "get" method that will route to private getter methods.
+      MethodSpec.Builder routerMethod =
+          methodBuilder("get")
+              .addModifiers(PUBLIC)
+              .addAnnotation(Override.class)
+              .returns(T)
+              .beginControlFlow("switch (id / $L)", MAX_CASES_PER_SWITCH);
+
+      ImmutableList.Builder<MethodSpec> getMethods = ImmutableList.builder();
+      for (int i = 0; i < switchCodeBlockPartitions.size(); i++) {
+        MethodSpec method =
+            methodBuilder("get" + i)
+                .addModifiers(PRIVATE)
+                .addAnnotation(suppressWarnings(UNCHECKED))
+                .returns(T)
+                .addCode(switchCodeBlockPartitions.get(i))
+                .build();
+        getMethods.add(method);
+        routerMethod.addStatement("case $L: return $N()", i, method);
+      }
+
+      routerMethod.addStatement("default: throw new $T(id)", AssertionError.class).endControlFlow();
+
+      return getMethods.add(routerMethod.build()).build();
+    }
+
+    private ImmutableList<CodeBlock> switchCodeBlockPartitions() {
+      return Lists.partition(ImmutableList.copyOf(switchCases.values()), MAX_CASES_PER_SWITCH)
+          .stream()
+          .map(
+              partitionCases ->
+                  CodeBlock.builder()
+                      .beginControlFlow("switch (id)")
+                      .add(CodeBlocks.concat(partitionCases))
+                      .addStatement("default: throw new $T(id)", AssertionError.class)
+                      .endControlFlow()
+                      .build())
+          .collect(toImmutableList());
+    }
   }
 }
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
new file mode 100644
index 000000000..e6f7a4727
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.annotation.processing.Processor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SwitchingProviderTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SwitchingProviderTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  @Test
+  public void switchingProviderTest() {
+    ImmutableList.Builder<JavaFileObject> javaFileObjects = ImmutableList.builder();
+    StringBuilder entryPoints = new StringBuilder();
+    for (int i = 0; i <= 100; i++) {
+      String bindingName = "Binding" + i;
+      javaFileObjects.add(
+          JavaFileObjects.forSourceLines(
+              "test." + bindingName,
+              "package test;",
+              "",
+              "import javax.inject.Inject;",
+              "",
+              "final class " + bindingName + " {",
+              "  @Inject",
+              "  " + bindingName + "() {}",
+              "}"));
+      entryPoints.append(String.format("  Provider<%1$s> get%1$sProvider();\n", bindingName));
+    }
+
+    javaFileObjects.add(
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            entryPoints.toString(),
+            "}"));
+
+    JavaFileObject generatedComponent =
+        compilerMode
+            .javaFileBuilder("test.DaggerTestComponent")
+            .addLines(
+                "package test;",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    private T get0() {",
+                "      switch (id) {",
+                "        case 0:  return (T) new Binding0();",
+                "        case 1:  return (T) new Binding1();",
+                "        case 2:  return (T) new Binding2();",
+                "        case 3:  return (T) new Binding3();",
+                "        case 4:  return (T) new Binding4();",
+                "        case 5:  return (T) new Binding5();",
+                "        case 6:  return (T) new Binding6();",
+                "        case 7:  return (T) new Binding7();",
+                "        case 8:  return (T) new Binding8();",
+                "        case 9:  return (T) new Binding9();",
+                "        case 10: return (T) new Binding10();",
+                "        case 11: return (T) new Binding11();",
+                "        case 12: return (T) new Binding12();",
+                "        case 13: return (T) new Binding13();",
+                "        case 14: return (T) new Binding14();",
+                "        case 15: return (T) new Binding15();",
+                "        case 16: return (T) new Binding16();",
+                "        case 17: return (T) new Binding17();",
+                "        case 18: return (T) new Binding18();",
+                "        case 19: return (T) new Binding19();",
+                "        case 20: return (T) new Binding20();",
+                "        case 21: return (T) new Binding21();",
+                "        case 22: return (T) new Binding22();",
+                "        case 23: return (T) new Binding23();",
+                "        case 24: return (T) new Binding24();",
+                "        case 25: return (T) new Binding25();",
+                "        case 26: return (T) new Binding26();",
+                "        case 27: return (T) new Binding27();",
+                "        case 28: return (T) new Binding28();",
+                "        case 29: return (T) new Binding29();",
+                "        case 30: return (T) new Binding30();",
+                "        case 31: return (T) new Binding31();",
+                "        case 32: return (T) new Binding32();",
+                "        case 33: return (T) new Binding33();",
+                "        case 34: return (T) new Binding34();",
+                "        case 35: return (T) new Binding35();",
+                "        case 36: return (T) new Binding36();",
+                "        case 37: return (T) new Binding37();",
+                "        case 38: return (T) new Binding38();",
+                "        case 39: return (T) new Binding39();",
+                "        case 40: return (T) new Binding40();",
+                "        case 41: return (T) new Binding41();",
+                "        case 42: return (T) new Binding42();",
+                "        case 43: return (T) new Binding43();",
+                "        case 44: return (T) new Binding44();",
+                "        case 45: return (T) new Binding45();",
+                "        case 46: return (T) new Binding46();",
+                "        case 47: return (T) new Binding47();",
+                "        case 48: return (T) new Binding48();",
+                "        case 49: return (T) new Binding49();",
+                "        case 50: return (T) new Binding50();",
+                "        case 51: return (T) new Binding51();",
+                "        case 52: return (T) new Binding52();",
+                "        case 53: return (T) new Binding53();",
+                "        case 54: return (T) new Binding54();",
+                "        case 55: return (T) new Binding55();",
+                "        case 56: return (T) new Binding56();",
+                "        case 57: return (T) new Binding57();",
+                "        case 58: return (T) new Binding58();",
+                "        case 59: return (T) new Binding59();",
+                "        case 60: return (T) new Binding60();",
+                "        case 61: return (T) new Binding61();",
+                "        case 62: return (T) new Binding62();",
+                "        case 63: return (T) new Binding63();",
+                "        case 64: return (T) new Binding64();",
+                "        case 65: return (T) new Binding65();",
+                "        case 66: return (T) new Binding66();",
+                "        case 67: return (T) new Binding67();",
+                "        case 68: return (T) new Binding68();",
+                "        case 69: return (T) new Binding69();",
+                "        case 70: return (T) new Binding70();",
+                "        case 71: return (T) new Binding71();",
+                "        case 72: return (T) new Binding72();",
+                "        case 73: return (T) new Binding73();",
+                "        case 74: return (T) new Binding74();",
+                "        case 75: return (T) new Binding75();",
+                "        case 76: return (T) new Binding76();",
+                "        case 77: return (T) new Binding77();",
+                "        case 78: return (T) new Binding78();",
+                "        case 79: return (T) new Binding79();",
+                "        case 80: return (T) new Binding80();",
+                "        case 81: return (T) new Binding81();",
+                "        case 82: return (T) new Binding82();",
+                "        case 83: return (T) new Binding83();",
+                "        case 84: return (T) new Binding84();",
+                "        case 85: return (T) new Binding85();",
+                "        case 86: return (T) new Binding86();",
+                "        case 87: return (T) new Binding87();",
+                "        case 88: return (T) new Binding88();",
+                "        case 89: return (T) new Binding89();",
+                "        case 90: return (T) new Binding90();",
+                "        case 91: return (T) new Binding91();",
+                "        case 92: return (T) new Binding92();",
+                "        case 93: return (T) new Binding93();",
+                "        case 94: return (T) new Binding94();",
+                "        case 95: return (T) new Binding95();",
+                "        case 96: return (T) new Binding96();",
+                "        case 97: return (T) new Binding97();",
+                "        case 98: return (T) new Binding98();",
+                "        case 99: return (T) new Binding99();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    private T get1() {",
+                "      switch (id) {",
+                "        case 100: return (T) new Binding100();",
+                "        default:  throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id / 100) {",
+                "        case 0:  return get0();",
+                "        case 1:  return get1();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }")
+            .build();
+
+    Compilation compilation = daggerCompiler().compile(javaFileObjects.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(generatedComponent);
+  }
+
+  private Compiler daggerCompiler(Processor... extraProcessors) {
+    return javac()
+        .withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors))
+        .withOptions(compilerMode.javacopts());
+  }
+}
