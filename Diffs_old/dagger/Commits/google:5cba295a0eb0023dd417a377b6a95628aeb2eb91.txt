diff --git a/.travis.yml b/.travis.yml
index 5445350b9..a8e4a4308 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,6 +3,7 @@ language: android
 jdk:
   - oraclejdk7
   - openjdk7
+  - oraclejdk8
 
 android:
   components:
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 65bd4dbab..54c7d0a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -659,26 +659,29 @@ private void implementInterfaceMethods() {
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
-        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement requestElement =
-            MoreElements.asExecutable(interfaceRequest.requestElement());
-        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
-            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
-        MethodSignature signature = MethodSignature.fromExecutableType(
-            requestElement.getSimpleName().toString(), requestType);
+        ExecutableElement methodElement =
+            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableType requestType =
+            MoreTypes.asExecutable(
+                types.asMemberOf(
+                    MoreTypes.asDeclared(componentDefinitionType().asType()), methodElement));
+        MethodSignature signature =
+            MethodSignature.fromExecutableType(
+                methodElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
           MethodSpec.Builder interfaceMethod =
-              methodBuilder(requestElement.getSimpleName().toString())
+              methodBuilder(methodElement.getSimpleName().toString())
                   .addAnnotation(Override.class)
                   .addModifiers(PUBLIC)
                   .returns(TypeName.get(requestType.getReturnType()));
+          DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
           BindingKey bindingKey = interfaceRequest.bindingKey();
           MemberSelect memberSelect = getMemberSelect(bindingKey);
           CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
-              List<? extends VariableElement> parameters = requestElement.getParameters();
+              List<? extends VariableElement> parameters = methodElement.getParameters();
               if (parameters.isEmpty()) {
                 // we're returning the framework type
                 interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 569e9ceb6..27e412970 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import java.util.List;
 import java.util.Set;
@@ -61,15 +62,31 @@
   public abstract Key key();
 
   /**
-   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
+   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
+   * defined by the user-defined injection sites.
    */
   abstract ImmutableSet<DependencyRequest> dependencies();
 
   /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
-   * superset of {@link #dependencies()}.  This returns an unmodifiable set.
+   * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
+   * user-defined injection site. This returns an unmodifiable set.
    */
-  abstract Set<DependencyRequest> implicitDependencies();
+  // TODO(gak): this will eventually get migrated to FrameworkDependency
+  Set<DependencyRequest> frameworkDependencies() {
+    return ImmutableSet.of();
+  }
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
+   * union of {@link #dependencies()} and {@link #frameworkDependencies()}. This returns an
+   * unmodifiable set.
+   */
+  final Set<DependencyRequest> implicitDependencies() {
+    Set<DependencyRequest> frameworkDependencies = frameworkDependencies();
+    return frameworkDependencies.isEmpty()
+        ? dependencies()
+        : Sets.union(frameworkDependencies, dependencies());
+  }
 
   /**
    * Returns the name of the package in which this binding must be managed. E.g.: a binding
@@ -129,7 +146,7 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   }
 
   /**
-   * if this binding's key's type parameters are different from those of the
+   * If this binding's key's type parameters are different from those of the
    * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
    * unresolved type.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index e880aa009..7ca284831 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -547,28 +547,49 @@ private boolean multibindingsRequireProduction(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
         for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
-          DependencyRequest delegateRequest = delegateDeclaration.delegateRequest();
-          ResolvedBindings resolvedDelegate = lookUpBindings(delegateRequest);
-          for (ContributionBinding explicitDelegate : resolvedDelegate.contributionBindings()) {
-            switch (explicitDelegate.bindingType()) {
-              case PRODUCTION:
-                builder.add(
-                    productionBindingFactory.delegate(
-                        delegateDeclaration, (ProductionBinding) explicitDelegate));
-                break;
-              case PROVISION:
-                builder.add(
-                    provisionBindingFactory.delegate(
-                        delegateDeclaration, (ProvisionBinding) explicitDelegate));
-                break;
-              default:
-                throw new AssertionError();
-            }
-          }
+          builder.add(createDelegateBinding(delegateDeclaration));
         }
         return builder.build();
       }
 
+      /**
+       * Creates one (and only one) delegate binding for a delegate declaration, based on the
+       * resolved bindings of the right-hand-side of a {@link dagger.Binds} method. If there are
+       * duplicate bindings for the dependency key, there should still be only one binding for the
+       * delegate key.
+       */
+      private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
+        ResolvedBindings resolvedDelegate = lookUpBindings(delegateDeclaration.delegateRequest());
+        if (resolvedDelegate.contributionBindings().isEmpty()) {
+          // This is guaranteed to result in a missing binding error, so it doesn't matter if the
+          // binding is a Provision or Production, except if it is a @IntoMap method, in which
+          // case the key will be of type Map<K, Provider<V>>, which will be "upgraded" into a
+          // Map<K, Producer<V>> if it's requested in a ProductionComponent. This may result in a
+          // strange error, that the RHS needs to be provided with an @Inject or @Provides
+          // annotated method, but a user should be able to figure out if a @Produces annotation
+          // is needed.
+          // TODO(gak): revisit how we model missing delegates if/when we clean up how we model
+          // binding declarations
+          return provisionBindingFactory.missingDelegate(delegateDeclaration);
+        }
+        // It doesn't matter which of these is selected, since they will later on produce a
+        // duplicate binding error.
+        // TODO(ronshapiro): Once compile-testing has a CompilationResult, add a test which asserts
+        // that a duplicate binding for the RHS does not result in a duplicate binding for the LHS.
+        ContributionBinding explicitDelegate =
+            resolvedDelegate.contributionBindings().iterator().next();
+        switch (explicitDelegate.bindingType()) {
+          case PRODUCTION:
+            return productionBindingFactory.delegate(
+                delegateDeclaration, (ProductionBinding) explicitDelegate);
+          case PROVISION:
+            return provisionBindingFactory.delegate(
+                delegateDeclaration, (ProvisionBinding) explicitDelegate);
+          default:
+            throw new AssertionError("bindingType: " + explicitDelegate);
+        }
+      }
+
       private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
           indexBindingsByOwningComponent(
               DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 6e3f23741..df91437de 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -160,7 +160,7 @@
 
     /** The entry point. */
     Element entryPointElement() {
-      return path.getFirst().dependencyRequest().requestElement();
+      return path.getFirst().dependencyRequest().requestElement().get();
     }
 
     /** The current dependency request, which is a transitive dependency of the entry point. */
@@ -392,8 +392,7 @@ private void validateResolvedBindings(DependencyPath path) {
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          validateNullability(
-              path.currentDependencyRequest(), resolvedBindings.contributionBindings());
+          validateNullability(path, resolvedBindings.contributionBindings());
           if (resolvedBindings.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return;
@@ -517,9 +516,12 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           .build();
     }
 
-    /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-    private void validateNullability(DependencyRequest request, Set<ContributionBinding> bindings) {
-      if (request.isNullable()) {
+    /**
+     * Ensures that if the current request isn't nullable, then each contribution is also not
+     * nullable.
+     */
+    private void validateNullability(DependencyPath path, Set<ContributionBinding> bindings) {
+      if (path.currentDependencyRequest().isNullable()) {
         return;
       }
 
@@ -528,16 +530,16 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
        * (Maybe this happens if the code was already compiled before this point?)
        * ... we manually print out the request in that case, otherwise the error
        * message is kind of useless. */
-      String typeName = TypeName.get(request.key().type()).toString();
+      String typeName = TypeName.get(path.currentDependencyRequest().key().type()).toString();
 
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
               nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
                   + "\n at: "
-                  + dependencyRequestFormatter.format(request),
+                  + dependencyRequestFormatter.toDependencyTrace(path),
               compilerOptions.nullableValidationKind(),
-              request.requestElement());
+              path.entryPointElement());
         }
       }
     }
@@ -583,10 +585,9 @@ private void validateMapKeyAnnotationTypes(
       }
     }
 
-    /**
-     * Reports errors if a members injection binding is invalid.
-     */
-    private void validateMembersInjectionBinding(Binding binding, final DependencyPath path) {
+    /** Reports errors if a members injection binding is invalid. */
+    private void validateMembersInjectionBinding(
+        final MembersInjectionBinding binding, final DependencyPath path) {
       binding
           .key()
           .type()
@@ -595,8 +596,7 @@ private void validateMembersInjectionBinding(Binding binding, final DependencyPa
                 @Override
                 protected Void defaultAction(TypeMirror e, Void p) {
                   reportBuilder.addError(
-                      "Invalid members injection request.",
-                      path.currentDependencyRequest().requestElement());
+                      "Invalid members injection request.", binding.membersInjectedType());
                   return null;
                 }
 
@@ -1180,7 +1180,7 @@ private void reportCycle(DependencyPath path) {
       return FluentIterable.from(cycle)
           .skip(1)
           .transform(ResolvedRequest.DEPENDENCY_REQUEST)
-          .filter(not(DependencyRequest.IS_SYNTHETIC))
+          .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
           .filter(
               new Predicate<DependencyRequest>() {
                 @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 24e788f48..816c51f80 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -20,7 +20,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 
@@ -33,7 +32,6 @@
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
@@ -59,28 +57,9 @@
  */
 abstract class ContributionBinding extends Binding implements HasContributionType {
 
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!membersInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(membersInjectionRequest().asSet(), dependencies());
-    }
-  }
-
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  /**
-   * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
-   * implicitly by the framework.
-   */
-  boolean isSyntheticBinding() {
-    return IS_SYNTHETIC_KIND.apply(bindingKind());
-  }
-
   /**
    * A function that returns the kind of a binding.
    */
@@ -92,9 +71,6 @@ public Kind apply(ContributionBinding binding) {
         }
       };
 
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> membersInjectionRequest();
-
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -166,17 +142,6 @@ public Kind apply(ContributionBinding binding) {
     COMPONENT_PRODUCTION,
     ;
 
-    /**
-     * A predicate that tests whether a kind is for synthetic bindings.
-     */
-    static final Predicate<Kind> IS_SYNTHETIC_KIND =
-        Predicates.in(
-            immutableEnumSet(
-                SYNTHETIC_MAP,
-                SYNTHETIC_MULTIBOUND_SET,
-                SYNTHETIC_MULTIBOUND_MAP,
-                SYNTHETIC_DELEGATE_BINDING));
-
     /**
      * A predicate that tests whether a kind is for synthetic multibindings.
      */
@@ -320,8 +285,6 @@ public Object apply(ContributionBinding mapBinding) {
 
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
-    abstract B membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
-
     abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
 
     abstract B bindingKind(ContributionBinding.Kind kind);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 70886d0f4..be829f1db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -152,7 +152,8 @@ BindingKey bindingKey() {
     }
   }
 
-  abstract Element requestElement();
+  /** The element that declares this dependency request. Absent for synthetic requests. */
+  abstract Optional<Element> requestElement();
 
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
@@ -163,22 +164,17 @@ BindingKey bindingKey() {
    */
   abstract Optional<String> overriddenVariableName();
 
-  /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
-  abstract boolean isSynthetic();
-
-  /** A predicate that passes for synthetic requests. */
-  static final Predicate<DependencyRequest> IS_SYNTHETIC =
+  /** A predicate that passes for requests with elements. */
+  static final Predicate<DependencyRequest> HAS_REQUEST_ELEMENT =
       new Predicate<DependencyRequest>() {
         @Override
         public boolean apply(DependencyRequest request) {
-          return request.isSynthetic();
+          return request.requestElement().isPresent();
         }
       };
 
   private static DependencyRequest.Builder builder() {
-    return new AutoValue_DependencyRequest.Builder()
-        .isNullable(false)
-        .isSynthetic(false);
+    return new AutoValue_DependencyRequest.Builder().isNullable(false);
   }
 
   @CanIgnoreReturnValue
@@ -194,12 +190,6 @@ public boolean apply(DependencyRequest request) {
 
     abstract Builder overriddenVariableName(Optional<String> overriddenVariableName);
 
-    abstract Builder isSynthetic(boolean isSynthetic);
-
-    Builder isSynthetic() {
-      return isSynthetic(true);
-    }
-
     @CheckReturnValue
     abstract DependencyRequest build();
   }
@@ -230,30 +220,23 @@ Builder isSynthetic() {
     }
 
     /**
-     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
-     * to satisfy the {@code mapOfValueRequest}.
+     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}.
      *
-     * @param mapOfValueRequest a request for {@code Map<K, V>}
      * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
      *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(
-        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
-      checkNotNull(mapOfValueRequest);
+    DependencyRequest forImplicitMapBinding(Key mapOfFactoryKey) {
       return DependencyRequest.builder()
           .kind(Kind.PROVIDER)
           .key(mapOfFactoryKey)
-          .requestElement(mapOfValueRequest.requestElement())
-          .isSynthetic()
           .build();
     }
 
     /**
-     * Creates a dependency request, with the same element as {@code request}, for one individual
-     * {@code multibindingContribution}.
+     * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
-    DependencyRequest forMultibindingContribution(
-        DependencyRequest request, ContributionBinding multibindingContribution) {
+    private DependencyRequest forMultibindingContribution(
+        ContributionBinding multibindingContribution) {
       checkArgument(
           multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
           "multibindingContribution's key must have a multibinding contribution identifier: %s",
@@ -261,8 +244,6 @@ DependencyRequest forMultibindingContribution(
       return DependencyRequest.builder()
           .kind(multibindingContributionRequestKind(multibindingContribution))
           .key(multibindingContribution.key())
-          .requestElement(request.requestElement())
-          .isSynthetic()
           .build();
     }
 
@@ -284,14 +265,14 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
     }
 
     /**
-     * Creates dependency requests, with the same element as {@code request}, for each individual
-     * multibinding contribution in {@code multibindingContributions}.
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
      */
     ImmutableSet<DependencyRequest> forMultibindingContributions(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        Iterable<ContributionBinding> multibindingContributions) {
       ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
       for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(request, multibindingContribution));
+        requests.add(forMultibindingContribution(multibindingContribution));
       }
       return requests.build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 74d57469a..5d5c6a544 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -80,7 +80,7 @@ String toDependencyTrace(DependencyPath dependencyPath) {
         .join(
             dependencyPath
                 .dependencyRequests()
-                .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
+                .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
                 .transform(this)
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
@@ -93,6 +93,7 @@ String toDependencyTrace(DependencyPath dependencyPath) {
   public String format(DependencyRequest request) {
     return request
         .requestElement()
+        .get()
         .accept(
             new ElementKindVisitor7<String, DependencyRequest>() {
 
@@ -117,8 +118,8 @@ public String visitExecutableAsMethod(
 
               /**
                * Returns the description for {@link javax.inject.Inject @Inject} constructor and
-               * method parameters and for {@link dagger.Provides @Provides} and
-               * {@link dagger.producers.Produces @Produces} method parameters.
+               * method parameters and for {@link dagger.Provides @Provides} and {@link
+               * dagger.producers.Produces @Produces} method parameters.
                */
               @Override
               public String visitVariableAsParameter(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index f68cedf55..b84d338db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.base.Ascii;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -42,7 +44,8 @@ public String apply(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
       return dependency.overriddenVariableName().get();
     }
-    String variableName = dependency.requestElement().getSimpleName().toString();
+    checkArgument(dependency.requestElement().isPresent());
+    String variableName = dependency.requestElement().get().getSimpleName().toString();
     if (Ascii.isUpperCase(variableName.charAt(0))) {
       variableName = toLowerCamel(variableName);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 0d69b5d31..a5dfed2dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -19,17 +19,14 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Maps;
 import java.util.Collection;
+import java.util.Iterator;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
 
 /**
  * The framework class and binding key for a resolved dependency of a binding. If a binding has
@@ -137,43 +134,14 @@
    */
   private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
       Binding binding) {
-    // If the binding has no unresolved version, just group the dependencies by binding key.
-    if (!binding.unresolved().isPresent()) {
-      return groupByKey(binding, Functions.<DependencyRequest>identity());
-    }
-
-    // Group the unresolved dependencies, replacing each one with its resolved version by looking it
-    // up by request element.
-    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
-        Maps.uniqueIndex(
-            binding.implicitDependencies(),
-            new Function<DependencyRequest, Element>() {
-              @Override
-              public Element apply(DependencyRequest dependencyRequest) {
-                return dependencyRequest.requestElement();
-              }
-            });
-    return groupByKey(
-        binding.unresolved().get(),
-        new Function<DependencyRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
-            return resolvedDependencies.get(unresolvedRequest.requestElement());
-          }
-        });
-  }
-
-  /**
-   * Groups a binding's dependency requests by their binding key.
-   *
-   * @param transformer applied to each dependency before inserting into the group
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByKey(
-      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
         ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : binding.implicitDependencies()) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
+    Iterator<DependencyRequest> dependencies = binding.implicitDependencies().iterator();
+    Binding unresolved = binding.unresolved().isPresent() ? binding.unresolved().get() : binding;
+    Iterator<DependencyRequest> unresolvedDependencies =
+        unresolved.implicitDependencies().iterator();
+    while (dependencies.hasNext()) {
+      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
     }
     return ImmutableList.copyOf(
         dependenciesByKeyBuilder
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index deb8d15be..d441ce7ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -77,11 +77,6 @@
     return Optional.absent();
   }
 
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    return dependencies();
-  }
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 936d88c91..4b6563406 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -357,7 +357,7 @@ private MethodSpec injectorMethodForSubclasses(
   private String staticInjectMethodDependencyParameterName(
       Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
     StringBuilder parameterName =
-        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+        new StringBuilder(dependency.requestElement().get().getSimpleName().toString());
     switch (dependency.kind()) {
       case LAZY:
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 1921b6baf..7605e4d49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -254,7 +254,7 @@ private CodeBlock producerTokenConstruction(
 
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
-    return dependency.requestElement().getSimpleName() + "Future";
+    return dependency.requestElement().get().getSimpleName() + "Future";
   }
 
   /** Represents the transformation of an input future by a producer method. */
@@ -354,7 +354,7 @@ TypeName applyArgType() {
 
     @Override
     String applyArgName() {
-      return asyncDependency.requestElement().getSimpleName().toString();
+      return asyncDependency.requestElement().get().getSimpleName().toString();
     }
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 1a50fb091..a1c3af826 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -27,7 +27,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
@@ -60,15 +59,11 @@ public BindingType bindingType() {
   }
 
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Similar optimizations to ContributionBinding.implicitDependencies().
-    if (!executorRequest().isPresent() && !monitorRequest().isPresent()) {
-      return super.implicitDependencies();
-    } else {
-      return Sets.union(
-          Sets.union(executorRequest().asSet(), monitorRequest().asSet()),
-          super.implicitDependencies());
-    }
+  Set<DependencyRequest> frameworkDependencies() {
+    return new ImmutableSet.Builder<DependencyRequest>()
+        .addAll(executorRequest().asSet())
+        .addAll(monitorRequest().asSet())
+        .build();
   }
 
   /** Returns the list of types in the throws clause of the method. */
@@ -166,8 +161,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           "%s is not for a Map<K, V> or Map<K, Produced<V>>",
           requestForMapOfValuesOrProduced);
       DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValuesOrProduced, mapOfProducersKey.get());
+          dependencyRequestFactory.forImplicitMapBinding(mapOfProducersKey.get());
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(requestForMapOfValuesOrProduced.key())
@@ -188,8 +182,7 @@ ProductionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(request.key())
           .dependencies(
-              dependencyRequestFactory.forMultibindingContributions(
-                  request, multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
           .build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 13011fc29..3fc438624 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Set;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -58,6 +59,14 @@
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
 
+  @Override
+  Set<DependencyRequest> frameworkDependencies() {
+    return membersInjectionRequest().asSet();
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
+
   @Override
   public BindingType bindingType() {
     return BindingType.PROVISION;
@@ -78,6 +87,8 @@ private static Builder builder() {
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
 
+    abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+
     abstract Builder unresolved(ProvisionBinding unresolved);
 
     abstract Builder scope(Optional<Scope> scope);
@@ -206,8 +217,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           "%s is not a request for Map<K, V>",
           requestForMapOfValues);
       DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValues, mapOfProvidersKey.get());
+          dependencyRequestFactory.forImplicitMapBinding(mapOfProvidersKey.get());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(requestForMapOfValues.key())
@@ -228,8 +238,7 @@ ProvisionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(request.key())
           .dependencies(
-              dependencyRequestFactory.forMultibindingContributions(
-                  request, multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
           .build();
     }
@@ -275,17 +284,27 @@ ProvisionBinding forSubcomponentBuilderMethod(
 
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
+      return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();
+    }
+
+    /**
+     * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side
+     * of a {@link dagger.Binds} method cannot be resolved.
+     */
+    ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
+      return delegateBuilder(delegateDeclaration).build();
+    }
+
+    private ProvisionBinding.Builder delegateBuilder(DelegateDeclaration delegateDeclaration) {
       return ProvisionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
           .dependencies(delegateDeclaration.delegateRequest())
-          .nullableType(delegate.nullableType())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
-          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()))
-          .build();
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index ff362422c..c5a2e36c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -19,6 +19,8 @@
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
+import static dagger.internal.codegen.Util.ELEMENT_KIND;
+import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
@@ -36,6 +38,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Iterator;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
@@ -54,19 +57,26 @@
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
-    @Override
-    public int compare(DependencyRequest left, DependencyRequest right) {
-      return ComparisonChain.start()
-      // put fields before parameters
-          .compare(left.requestElement().getKind(), right.requestElement().getKind())
-          // order by dependency kind
-          .compare(left.kind(), right.kind())
-          // then sort by name
-          .compare(left.requestElement().getSimpleName().toString(),
-              right.requestElement().getSimpleName().toString()).result();
-    }
-  };
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
+      new Ordering<DependencyRequest>() {
+        @Override
+        public int compare(DependencyRequest left, DependencyRequest right) {
+          return ComparisonChain.start()
+              // put fields before parameters
+              .compare(
+                  left.requestElement().transform(ELEMENT_KIND),
+                  right.requestElement().transform(ELEMENT_KIND),
+                  Util.<ElementKind>optionalComparator())
+              // order by dependency kind
+              .compare(left.kind(), right.kind())
+              // then sort by name
+              .compare(
+                  left.requestElement().transform(ELEMENT_SIMPLE_NAME),
+                  right.requestElement().transform(ELEMENT_SIMPLE_NAME),
+                  Util.<String>optionalComparator())
+              .result();
+        }
+      };
 
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 9b66577cd..234b1f528 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -27,6 +27,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
+import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -34,8 +35,10 @@
 import dagger.Provides;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.Comparator;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -211,5 +214,36 @@ public String apply(Element element) {
         }
       };
 
+  /** A function that returns the kind of an element. */
+  static final Function<Element, ElementKind> ELEMENT_KIND =
+      new Function<Element, ElementKind>() {
+        @Override
+        public ElementKind apply(Element element) {
+          return element.getKind();
+        }
+      };
+
+  @SuppressWarnings("rawtypes")
+  private static final Comparator OPTIONAL_COMPARATOR =
+      new Comparator<Optional<Comparable>>() {
+        @SuppressWarnings("unchecked") // Only used as a Comparator<Optional<SomeType>>.
+        @Override
+        public int compare(Optional<Comparable> o1, Optional<Comparable> o2) {
+          if (o1.isPresent() && o2.isPresent()) {
+            return o1.get().compareTo(o2.get());
+          }
+          return o1.isPresent() ? -1 : 1;
+        }
+      };
+
+  /**
+   * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
+   * present {@link Optional}s by their values.
+   */
+  @SuppressWarnings("unchecked") // Fully covariant.
+  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+    return OPTIONAL_COMPARATOR;
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 1d97a29d9..701f56d64 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 
@@ -1065,6 +1066,89 @@ public void bindsMethodAppearsInTrace() {
         .onLine(5);
   }
 
+  @Test
+  public void bindsMissingRightHandSide() {
+    JavaFileObject duplicates =
+        JavaFileObjects.forSourceLines(
+            "test.Duplicates",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "interface Duplicates {",
+            "",
+            "  interface BoundTwice {}",
+            "",
+            "  class BoundImpl implements BoundTwice {",
+            "    @Inject BoundImpl() {}",
+            "  }",
+            "",
+            "  class NotBound implements BoundTwice {}",
+            "",
+            "  @Module",
+            "  abstract class DuplicatesModule {",
+            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
+            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
+            "",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "",
+            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
+            "",
+            "    @Binds @IntoMap @IntKey(1)",
+            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
+            "",
+            "    @Provides @IntoMap @LongKey(2L)",
+            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
+            "      return impl;",
+            "    }",
+            "    @Binds @IntoMap @LongKey(2L)",
+            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import java.util.Map;",
+            "import test.Duplicates.BoundTwice;",
+            "",
+            "@Component(modules = Duplicates.DuplicatesModule.class)",
+            "interface C {",
+            "  BoundTwice boundTwice();",
+            "  Object object();",
+            "  Set<BoundTwice> set();",
+            "  Map<Integer, BoundTwice> intMap();",
+            "  Map<Long, BoundTwice> longMap();",
+            "}");
+
+    assertThat(duplicates, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(11)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(12)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(13)
+        .and().withErrorContaining("same map key is bound more than once")
+            .in(component).onLine(14);
+  }
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
diff --git a/pom.xml b/pom.xml
index 5a95c4776..d95579bdc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -202,6 +202,7 @@
 
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
