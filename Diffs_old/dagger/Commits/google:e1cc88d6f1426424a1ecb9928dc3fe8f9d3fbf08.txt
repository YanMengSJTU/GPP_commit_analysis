diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 17b57e416..abed9b7f2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -122,6 +122,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String PROVIDES_METHOD_THROWS =
       "@Provides methods may only throw unchecked exceptions";
 
+  static final String PRODUCES_METHOD_NULLABLE =
+      "@Nullable on @Produces methods does not do anything.";
+
   static final String PRODUCES_METHOD_RETURN_TYPE =
       "@Produces methods must either return a primitive, an array, a type variable, or a declared"
           + " type, or a ListenableFuture of one of those types.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 62079a625..ce2479008 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -44,6 +44,7 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
@@ -103,6 +104,11 @@ private TypeElement getSetElement() {
       builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
 
+    if (ConfigurationAnnotations.getNullableType(producesMethodElement).isPresent()) {
+      // TODO(beder): Make this an error.
+      builder.addWarning(PRODUCES_METHOD_NULLABLE, producesMethodElement);
+    }
+
     TypeMirror returnType = producesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 4630567f0..c21aec6db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -123,7 +123,7 @@ ProductionBinding forProducesMethod(
           key,
           dependencies,
           findBindingPackage(key),
-          ConfigurationAnnotations.getNullableType(producesMethod),
+          Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ffda289a7..c20c6aa81 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -370,4 +370,57 @@ public void dependsOnProductionExecutor() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void nullableProducersAreNotErrors() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "import javax.annotation.Nullable;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "  interface B {}",
+        "  interface C {}",
+        "",
+        "  @Module",
+        "  static final class CModule {",
+        "    @Provides @Nullable C c() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class ABModule {",
+        "    @Produces @Nullable B b(@Nullable C c) {",
+        "      return null;",
+        "    }",
+
+        "    @Produces @Nullable ListenableFuture<A> a(B b) {",  // NOTE: B not injected as nullable
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {ABModule.class, CModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(26)
+        .and()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(29);
+  }
 }
