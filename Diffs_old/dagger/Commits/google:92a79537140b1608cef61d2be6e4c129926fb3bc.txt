diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index d982132fc..f86408393 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,6 +16,9 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -69,7 +72,7 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           @Override
           public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(
                         map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
@@ -78,7 +81,8 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
                   public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
         });
   }
@@ -93,14 +97,15 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
             @Override
             public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   Producers.createFutureProduced(entry.getValue().get()),
                   new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
                     @Override
                     public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index b5104f01d..d02c9ca90 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -16,6 +16,9 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -65,7 +68,7 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
           @Override
           public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
                 new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
@@ -73,7 +76,8 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
                   public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
         });
   }
@@ -86,14 +90,15 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
             @Override
             public ListenableFuture<Map.Entry<Object, Object>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   entry.getValue().get(),
                   new Function<Object, Map.Entry<Object, Object>>() {
                     @Override
                     public Map.Entry<Object, Object> apply(Object value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 4d9d17c4c..029bcb51a 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -17,6 +17,9 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.catchingAsync;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
@@ -49,17 +52,19 @@
   // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
-    return Futures.catchingAsync(
-        Futures.transform(
+    return catchingAsync(
+        transform(
             future,
             new Function<T, Produced<T>>() {
               @Override
               public Produced<T> apply(final T value) {
                 return Produced.successful(value);
               }
-            }),
+            },
+            directExecutor()),
         Throwable.class,
-        Producers.<T>futureFallbackForProduced());
+        Producers.<T>futureFallbackForProduced(),
+        directExecutor());
 
   }
 
@@ -82,11 +87,15 @@
    * future.
    */
   public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
-    return Futures.transform(future, new Function<T, Set<T>>() {
-      @Override public Set<T> apply(T value) {
-        return ImmutableSet.of(value);
-      }
-    });
+    return transform(
+        future,
+        new Function<T, Set<T>>() {
+          @Override
+          public Set<T> apply(T value) {
+            return ImmutableSet.of(value);
+          }
+        },
+        directExecutor());
   }
 
   /**
@@ -97,14 +106,15 @@
    */
   public static <T> ListenableFuture<Set<T>> allAsSet(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
-    return Futures.transform(
+    return transform(
         Futures.allAsList(futures),
         new Function<List<T>, Set<T>>() {
           @Override
           public Set<T> apply(List<T> values) {
             return ImmutableSet.copyOf(values);
           }
-        });
+        },
+        directExecutor());
   }
 
   /**
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index c8d75b3e6..ff25ad709 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -17,6 +17,8 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static dagger.internal.DaggerCollections.hasDuplicates;
 import static dagger.internal.DaggerCollections.presizedList;
 
@@ -137,7 +139,7 @@ private SetProducer(
     for (Producer<Collection<T>> producer : collectionProducers) {
       futureCollections.add(checkNotNull(producer.get()));
     }
-    return Futures.transform(
+    return transform(
         Futures.allAsList(futureCollections),
         new Function<List<Collection<T>>, Set<T>>() {
           @Override
@@ -148,6 +150,7 @@ private SetProducer(
             }
             return builder.build();
           }
-        });
+        },
+        directExecutor());
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 6a3ad1148..a7ead827d 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -16,8 +16,10 @@
 
 package dagger.producers.monitoring;
 
+import static com.google.common.util.concurrent.Futures.addCallback;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
@@ -160,7 +162,7 @@ public void failed(@SuppressWarnings("unused") Throwable t) {}
    * overridden in the framework!
    */
   public <T> void addCallbackTo(ListenableFuture<T> future) {
-    Futures.addCallback(
+    addCallback(
         future,
         new FutureCallback<T>() {
           @Override
@@ -172,7 +174,8 @@ public void onSuccess(T value) {
           public void onFailure(Throwable t) {
             failed(t);
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final ProducerMonitor NO_OP =
