diff --git a/.gitignore b/.gitignore
index 7de7142f7..f05f56746 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,5 +27,3 @@ obj
 .DS_Store
 
 dependency-reduced-pom.xml
-
-test_runs/
diff --git a/.travis.yml b/.travis.yml
index 3e1627c46..140bc5580 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,8 +6,8 @@ jdk:
 
 android:
   components:
-    - build-tools-20.0.0
-    - android-16
+    - build-tools-23.0.0
+    - android-23
   licenses:
     - android-sdk-license-5be876d5
 
@@ -20,9 +20,9 @@ before_install:
   - export PATH=$M2_HOME/bin:$PATH
   - mvn --version
 
-install: mvn -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+install: mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-script: mvn -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
+script: mvn -B -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
 
 notifications:
   email: dagger-firehose@googlegroups.com
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 957840eca..3a38bfc00 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,58 @@
 Change Log
 ==========
 
-Version 1.2.0 *(2013-12-13)*
-----------------------------
+Dagger 2 (Components)
+---------------------
+
+### Version 2.0.2 *(2015-11-03)*
+
+A patch release, most crucially including:
+
+  * A fix to the way processor validation of types is done that permits dagger to play
+    more nicely with other processors, avoiding over-validating aspects that it doesn't
+    need, which may yet not have been generated by other processors in a different round
+    of processing.
+  * Some improved error reporting for edge-cases
+  * Fix to prevent incompatible versions of Guava on the classpath from blowing up processing
+  * Support a more robust set of types for map keys in map bindings (primitive types, etc.)
+
+### Version 2.0.1 *(2015-05-28)*
+
+A maintenance release fixing immediate issues following the Dagger 2.0 release, including:
+
+  * Speed up Graph Validation (reduce build times by 10s of seconds on sampled large projects)
+  * Generate correct code for @MapKey annotation types (beta)
+  * Fix to properly emit code for class literal values in @MapKey annotations.
+  * Fix for injecting component dependencies
+  * Fixes to generated code to account for differences in generics handling in ecg vs. javac.
+  * Subcomponents can now be abstract classes.
+  * Subcomponents now properly build the object graph in some cases involving explicit bindings
+    and (sub)components without scope.
+  * Improve runtime performance of SetFactory (set multibindings)
+  * Other smaller fixes, refactorings, etc.
+
+### Version 2.0.0 *(2015-04-21)*
+
+The initial release of the 2.0 code-line, supporting:
+
+  * `@Component` interfaces representing a custom API to access a graph of objects
+  * JSR-330 injection automation using `@Inject` signals, `@Qualifiers`
+  * Simple bindings of implementations to interfaces, custom provision of objects, and set-bindings
+  * Compile-time validation of graph structure (cycles, missing bindings, duplicate bindings)
+  * Generation of 
+    - backing implementations for components
+    - factories for `@Inject` constructors and modules
+    - members-injectors for `@Inject` methods and fields
+  * Beta support for
+    - Map bindings
+    - [Producers](http://google.github.io/dagger/api/latest/dagger/producers/Producer.html)
+
+==============================================================
+
+Dagger 1 (ObjectGraph)
+----------------------
+
+### Version 1.2.0 *(2013-12-13)*
 
  * Numerous performance improvements in both the compiler and runtime.
    * Use more efficient `String` concatenation.
@@ -15,8 +65,7 @@ Version 1.2.0 *(2013-12-13)*
    module adapters.
 
 
-Version 1.1.0 *(2013-08-05)*
-----------------------------
+### Version 1.1.0 *(2013-08-05)*
 
  * Module loading now requires code generation via the 'dagger-compiler' artifact.
  * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`.
@@ -27,14 +76,12 @@ Version 1.1.0 *(2013-08-05)*
  * Update JavaWriter to 2.1.1.
 
 
-Version 1.0.1 *(2013-06-03)*
-----------------------------
+### Version 1.0.1 *(2013-06-03)*
 
  * Explicitly forbid declaring `@Inject` on a class type (e.g., `@Inject class Foo {}`).
  * Update JavaWriter to 1.0.5.
 
 
-Version 1.0.0 *(2013-05-07)*
-----------------------------
+### Version 1.0.0 *(2013-05-07)*
 
 Initial release.
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 40e0fa27d..69839a1e6 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -46,26 +46,28 @@
       <artifactId>auto-common</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.google.auto.service</groupId>
-      <artifactId>auto-service</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
       <optional>true</optional>
     </dependency>
-    <!-- TODO(gak): Restore this presumably as javapoet when appropriate.
     <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>javawriter</artifactId>
+      <groupId>com.google.googlejavaformat</groupId>
+      <artifactId>google-java-format</artifactId>
     </dependency>
-    -->
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>com.google.auto.service</groupId>
+      <artifactId>auto-service</artifactId>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
-
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <optional>true</optional>
       <version>1.0</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
     <dependency>
@@ -90,6 +92,11 @@
       <artifactId>guava-testlib</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>javapoet</artifactId>
+      <version>1.5.1</version>
+    </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
       <artifactId>mockito-core</artifactId>
@@ -158,6 +165,7 @@
         </executions>
       </plugin>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
         <version>2.3</version>
         <executions>
@@ -187,6 +195,16 @@
                   <shadedPattern>dagger.shaded.auto.common</shadedPattern>
                 </relocation>
               </relocations>
+              <filters>
+                <filter>
+                  <artifact>*:*</artifact>
+                  <excludes>
+                    <exclude>META-INF/*.SF</exclude>
+                    <exclude>META-INF/*.DSA</exclude>
+                    <exclude>META-INF/*.RSA</exclude>
+                  </excludes>
+                </filter>
+              </filters>
             </configuration>
           </execution>
         </executions>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 1eca20c14..217e6167a 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -28,6 +28,10 @@ limitations under the License.
   <artifactId>functional-tests</artifactId>
   <name>Functional Tests</name>
   <dependencies>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
@@ -40,18 +44,20 @@ limitations under the License.
       <optional>true</optional>
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject-tck</artifactId>
+    </dependency>
+    <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
       <version>${auto.value.version}</version>
-      <optional>true</optional>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
       <version>${auto.factory.version}</version>
-      <optional>true</optional>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
     <dependency>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
similarity index 95%
rename from compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
index a4883459a..4cef79e02 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestBooleanKey {
+@interface BooleanKey {
   boolean value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
index 7ad25c4a2..8e739bd4a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestByteKey {
+@interface ByteKey {
   byte value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/CharKey.java
index a727551de..a4f4e29c8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestCharKey {
+@interface CharKey {
   char value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
new file mode 100644
index 000000000..f7460c989
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+@Component
+interface ComponentSupertypeDependsOnGeneratedCode
+    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
new file mode 100644
index 000000000..fca90e0f3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+interface ComponentSupertypeDependsOnGeneratedCodeInterface {
+  NeedsFactory_SomethingFactory somethingFactory();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
index 0e01f5f7e..c50e3451b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -16,22 +16,24 @@
 package test;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
 class GenericParent<X, Y> {
   
-  X registeredX;
+  Provider<X> registeredX;
   Y registeredY;
   B registeredB;
   
-  
   @Inject GenericParent() {}
   
-  @Inject X x;
+  @Inject Provider<X> x;
   @Inject Y y;
   @Inject B b;
   
-  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject
+  void registerX(Provider<X> x) {
+    this.registeredX = x;
+  }
   @Inject void registerY(Y y) { this.registeredY = y; }
   @Inject void registerB(B b) { this.registeredB = b; }
-
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 05542a40d..92355088b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,9 +16,11 @@
 package test;
 
 import dagger.Component;
+import dagger.mapkeys.StringKey;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import javax.inject.Named;
 import javax.inject.Provider;
 import test.sub.ContributionsModule;
 
@@ -31,11 +33,12 @@
 )
 interface MultibindingComponent {
   Map<String, String> map();
+  Map<String, String[]> mapOfArrays();
   Map<String, Provider<String>> mapOfProviders();
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
-  Map<TestStringKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<NestedAnnotationContainer.NestedWrappedKey, String> nestedKeyMap();
   Map<Class<? extends Number>, String> numberClassKeyMap();
   Map<Class<?>, String> classKeyMap();
   Map<Long, String> longKeyMap();
@@ -44,6 +47,26 @@
   Map<Byte, String> byteKeyMap();
   Map<Boolean, String> booleanKeyMap();
   Map<Character, String> characterKeyMap();
-  Map<TestStringKey, String> unwrappedAnnotationKeyMap();
-  Map<TestWrappedAnnotationKey, String> wrappedAnnotationKeyMap();
+  Map<StringKey, String> unwrappedAnnotationKeyMap();
+  Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
+  @Named("complexQualifier") Set<String> complexQualifierStringSet();
+  Set<Object> emptySet();
+
+  @Named("complexQualifier")
+  Set<Object> emptyQualifiedSet();
+
+  Map<String, Object> emptyMap();
+
+  @Named("complexQualifier")
+  Map<String, Object> emptyQualifiedMap();
+
+  Set<CharSequence> maybeEmptySet();
+
+  @Named("complexQualifier")
+  Set<CharSequence> maybeEmptyQualifiedSet();
+
+  Map<String, CharSequence> maybeEmptyMap();
+
+  @Named("complexQualifier")
+  Map<String, CharSequence> maybeEmptyQualifiedMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 73d53fef3..08433a988 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -16,12 +16,18 @@
 package test;
 
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.IntKey;
+import dagger.mapkeys.LongKey;
+import dagger.mapkeys.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import javax.inject.Named;
 import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
@@ -30,125 +36,196 @@
 @Module
 class MultibindingModule {
   @Provides(type = MAP)
-  @TestStringKey("foo")
-  String provideFooKey(double doubleDependency) {
+  @StringKey("foo")
+  static String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
   @Provides(type = MAP)
-  @TestStringKey("bar")
-  String provideBarKey() {
+  @StringKey("bar")
+  static String provideBarKey() {
     return "bar value";
   }
 
-  @Provides(type = SET) int provideFiveToSet() {
+  @Provides(type = MAP)
+  @StringKey("foo")
+  static String[] provideFooArrayValue(double doubleDependency) {
+    return new String[] {"foo1", "foo2"};
+  }
+
+  @Provides(type = MAP)
+  @StringKey("bar")
+  static String[] provideBarArrayValue() {
+    return new String[] {"bar1", "bar2"};
+  }
+
+  @Provides(type = SET)
+  static int provideFiveToSet() {
     return 5;
   }
 
-  @Provides(type = SET) int provideSixToSet() {
+  @Provides(type = SET)
+  static int provideSixToSet() {
     return 6;
   }
 
-  @Provides Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+  @Provides
+  static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
     return map.keySet();
   }
 
-  @Provides Collection<String> provideMapValues(Map<String, String> map) {
+  @Provides
+  static Collection<String> provideMapValues(Map<String, String> map) {
     return map.values();
   }
 
   @Provides(type = MAP)
-  @TestStringKey.NestedWrappedKey(Integer.class)
-  String valueForInteger() {
+  @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
+  static String valueForInteger() {
     return "integer";
   }
 
   @Provides(type = MAP)
-  @TestStringKey.NestedWrappedKey(Long.class)
-  String valueForLong() {
+  @NestedAnnotationContainer.NestedWrappedKey(Long.class)
+  static String valueForLong() {
     return "long";
   }
 
   @Provides(type = MAP)
-  @TestClassKey(Integer.class)
-  String valueForClassInteger() {
+  @ClassKey(Integer.class)
+  static String valueForClassInteger() {
     return "integer";
   }
 
   @Provides(type = MAP)
-  @TestClassKey(Long.class)
-  String valueForClassLong() {
+  @ClassKey(Long.class)
+  static String valueForClassLong() {
     return "long";
   }
 
   @Provides(type = MAP)
-  @TestNumberClassKey(BigDecimal.class)
-  String valueForNumberClassBigDecimal() {
+  @NumberClassKey(BigDecimal.class)
+  static String valueForNumberClassBigDecimal() {
     return "bigdecimal";
   }
 
   @Provides(type = MAP)
-  @TestNumberClassKey(BigInteger.class)
-  String valueForNumberClassBigInteger() {
+  @NumberClassKey(BigInteger.class)
+  static String valueForNumberClassBigInteger() {
     return "biginteger";
   }
 
   @Provides(type = MAP)
-  @TestLongKey(longValue = 100)
-  String valueFor100Long() {
+  @LongKey(100)
+  static String valueFor100Long() {
     return "100 long";
   }
 
   @Provides(type = MAP)
-  @TestIntKey(100)
-  String valueFor100Int() {
+  @IntKey(100)
+  static String valueFor100Int() {
     return "100 int";
   }
 
   @Provides(type = MAP)
-  @TestShortKey(100)
-  String valueFor100Short() {
+  @ShortKey(100)
+  static String valueFor100Short() {
     return "100 short";
   }
 
   @Provides(type = MAP)
-  @TestByteKey(100)
-  String valueFor100Byte() {
+  @ByteKey(100)
+  static String valueFor100Byte() {
     return "100 byte";
   }
 
   @Provides(type = MAP)
-  @TestBooleanKey(true)
-  String valueForTrue() {
+  @BooleanKey(true)
+  static String valueForTrue() {
     return "true";
   }
 
   @Provides(type = MAP)
-  @TestCharKey('a')
-  String valueForA() {
+  @CharKey('a')
+  static String valueForA() {
     return "a char";
   }
 
   @Provides(type = MAP)
-  @TestCharKey('\n')
-  String valueForNewline() {
+  @CharKey('\n')
+  static String valueForNewline() {
     return "newline char";
   }
 
   @Provides(type = MAP)
-  @TestUnwrappedAnnotationKey(@TestStringKey("foo\n"))
-  String valueForUnwrappedAnnotationKeyFoo() {
+  @UnwrappedAnnotationKey(@StringKey("foo\n"))
+  static String valueForUnwrappedAnnotationKeyFoo() {
     return "foo annotation";
   }
 
   @Provides(type = MAP)
-  @TestWrappedAnnotationKey(
-    value = @TestStringKey("foo"),
+  @WrappedAnnotationKey(
+    value = @StringKey("foo"),
     integers = {1, 2, 3},
     annotations = {},
     classes = {Long.class, Integer.class}
   )
-  String valueForWrappedAnnotationKeyFoo() {
+  static String valueForWrappedAnnotationKeyFoo() {
     return "wrapped foo annotation";
   }
+
+  @Provides(type = SET)
+  @Named("complexQualifier")
+  static String valueForComplexQualifierSet() {
+    return "foo";
+  }
+
+  @Provides(type = SET)
+  static CharSequence setContribution() {
+    return "foo";
+  }
+
+  @Provides(type = SET)
+  @Named("complexQualifier")
+  static CharSequence qualifiedSetContribution() {
+    return "qualified foo";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("key")
+  static CharSequence mapContribution() {
+    return "foo value";
+  }
+
+  @Provides(type = MAP)
+  @Named("complexQualifier")
+  @StringKey("key")
+  static CharSequence qualifiedMapContribution() {
+    return "qualified foo value";
+  }
+
+  interface EmptiesSupertype {
+    Set<Object> emptySet();
+
+    Map<String, Object> emptyMap();
+
+    Set<CharSequence> maybeEmptySet();
+
+    Map<String, CharSequence> maybeEmptyMap();
+  }
+
+  @Multibindings
+  interface Empties extends EmptiesSupertype {
+    @Named("complexQualifier")
+    Set<Object> emptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, Object> emptyQualifiedMap();
+
+    @Named("complexQualifier")
+    Set<CharSequence> maybeEmptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, CharSequence> maybeEmptyQualifiedMap();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
similarity index 90%
rename from compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
index a0e89ed71..c57b4ecf4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
@@ -17,9 +17,7 @@
 
 import dagger.MapKey;
 
-@MapKey(unwrapValue = true)
-@interface TestStringKey {
-  String value();
+public final class NestedAnnotationContainer {
 
   @MapKey(unwrapValue = false)
   @interface NestedWrappedKey {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
similarity index 95%
rename from compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
index 884c75e19..4164ae5cc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestNumberClassKey {
+@interface NumberClassKey {
   Class<? extends Number> value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index a161abaa8..f550f2f21 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -4,6 +4,7 @@
 import dagger.Provides;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 @Module
 abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
@@ -15,4 +16,14 @@
     }
     return list;
   }
+
+  @Provides static char provideNonGenericBindingInParameterizedModule() {
+    return 'c';
+  }
+
+  @Provides
+  static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
+    return new ArrayList<>();
+  }
+
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
index a74f21041..01b3aa99d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestShortKey {
+@interface ShortKey {
   short value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
deleted file mode 100644
index 14b25cf5d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestIntKey {
-  int value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
deleted file mode 100644
index ba06ad0e1..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestLongKey {
-  long longValue(); // Tests that the unwrapped member can have any name.
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
deleted file mode 100644
index a00372890..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestUnwrappedAnnotationKey {
-  TestStringKey value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
similarity index 87%
rename from compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
index 921259781..21ed95841 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
@@ -16,8 +16,9 @@
 package test;
 
 import dagger.MapKey;
+import dagger.mapkeys.StringKey;
 
 @MapKey(unwrapValue = true)
-@interface TestClassKey {
-  Class<?> value();
+@interface UnwrappedAnnotationKey {
+  StringKey value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
similarity index 82%
rename from compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
index 13c059058..5d6e86dc7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
@@ -16,11 +16,13 @@
 package test;
 
 import dagger.MapKey;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.StringKey;
 
 @MapKey(unwrapValue = false)
-@interface TestWrappedAnnotationKey {
-  TestStringKey value();
+@interface WrappedAnnotationKey {
+  StringKey value();
   int[] integers();
-  TestClassKey[] annotations();
+  ClassKey[] annotations();
   Class<? extends Number>[] classes();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
index 59c29ab34..690c91ad7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -24,6 +24,8 @@
   
   Grandchild.Builder grandchildBuilder();
   
+  RequiresSubcomponentBuilder<Grandchild.Builder> requiresGrandchildBuilder();
+  
   @Subcomponent.Builder
   interface Builder {
     MiddleChild build();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
index f901b8863..584eff6ef 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -26,4 +26,6 @@
   
   MiddleChild.Builder middleBuilder();
   OtherMiddleChild.Builder otherBuilder();
+  
+  RequiresSubcomponentBuilder<MiddleChild.Builder> requiresMiddleChildBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
new file mode 100644
index 000000000..ee9963227
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class RequiresSubcomponentBuilder<B> {
+  private final Provider<B> subcomponentBuilderProvider;
+  private final B subcomponentBuilder;
+
+  @Inject
+  RequiresSubcomponentBuilder(Provider<B> subcomponentBuilderProvider, B subcomponentBuilder) {
+    this.subcomponentBuilderProvider = subcomponentBuilderProvider;
+    this.subcomponentBuilder = subcomponentBuilder;
+  }
+
+  Provider<B> subcomponentBuilderProvider() {
+    return subcomponentBuilderProvider;
+  }
+  
+  B subcomponentBuilder() {
+    return subcomponentBuilder;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
new file mode 100644
index 000000000..8d67d92eb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.mapkeys.StringKey;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+import static dagger.Provides.Type.MAP;
+
+/**
+ * Cycle classes used for testing cyclic dependencies.
+ * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
+ * S <- Provider<S>, Lazy<S>
+ *
+ * @author Tony Bentancur
+ * @since 2.0
+ */
+
+final class Cycles {
+  private Cycles() {}
+
+  static class A {
+    public final B b;
+    public final E e;
+
+    @Inject
+    A(E e, B b) {
+      this.e = e;
+      this.b = b;
+    }
+  }
+
+  static class B {
+    public final C c;
+
+    @Inject
+    B(C c) {
+      this.c = c;
+    }
+  }
+
+  static class C {
+    public final Provider<A> aProvider;
+    @Inject public Lazy<A> aLazy;
+
+    @Inject
+    C(Provider<A> aProvider) {
+      this.aProvider = aProvider;
+    }
+  }
+
+  static class D {
+    public final B b;
+
+    @Inject
+    D(B b) {
+      this.b = b;
+    }
+  }
+
+  static class E {
+    public final D d;
+
+    @Inject
+    E(D d) {
+      this.d = d;
+    }
+  }
+
+  static class S {
+    public final Provider<S> sProvider;
+    @Inject public Lazy<S> sLazy;
+
+    @Inject
+    S(Provider<S> sProvider) {
+      this.sProvider = sProvider;
+    }
+  }
+
+  static class X {
+    public final Y y;
+
+    @Inject
+    X(Y y) {
+      this.y = y;
+    }
+  }
+
+  static class Y {
+    public final Map<String, Provider<X>> mapOfProvidersOfX;
+    public final Map<String, Provider<Y>> mapOfProvidersOfY;
+
+    @Inject
+    Y(Map<String, Provider<X>> mapOfProvidersOfX, Map<String, Provider<Y>> mapOfProvidersOfY) {
+      this.mapOfProvidersOfX = mapOfProvidersOfX;
+      this.mapOfProvidersOfY = mapOfProvidersOfY;
+    }
+  }
+
+  @Module
+  static class CycleMapModule {
+    @Provides(type = MAP)
+    @StringKey("X")
+    static X x(X x) {
+      return x;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("Y")
+    static Y y(Y y) {
+      return y;
+    }
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component(modules = CycleMapModule.class)
+  interface CycleMapComponent {
+    Y y();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface CycleComponent {
+    A a();
+
+    C c();
+
+    ChildCycleComponent child();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface SelfCycleComponent {
+    S s();
+  }
+
+  @Subcomponent
+  interface ChildCycleComponent {
+    @SuppressWarnings("dependency-cycle")
+    A a();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
new file mode 100644
index 000000000..b4f61e096
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import dagger.Component;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+final class LongCycle {
+  static class Class1 { @Inject Class1(Class2 class2) {} }
+  static class Class2 { @Inject Class2(Class3 class3) {} }
+  static class Class3 { @Inject Class3(Class4 class4) {} }
+  static class Class4 { @Inject Class4(Class5 class5) {} }
+  static class Class5 { @Inject Class5(Class6 class6) {} }
+  static class Class6 { @Inject Class6(Class7 class7) {} }
+  static class Class7 { @Inject Class7(Class8 class8) {} }
+  static class Class8 { @Inject Class8(Class9 class9) {} }
+  static class Class9 { @Inject Class9(Class10 class10) {} }
+  static class Class10 { @Inject Class10(Class11 class11) {} }
+  static class Class11 { @Inject Class11(Class12 class12) {} }
+  static class Class12 { @Inject Class12(Class13 class13) {} }
+  static class Class13 { @Inject Class13(Class14 class14) {} }
+  static class Class14 { @Inject Class14(Class15 class15) {} }
+  static class Class15 { @Inject Class15(Class16 class16) {} }
+  static class Class16 { @Inject Class16(Class17 class17) {} }
+  static class Class17 { @Inject Class17(Class18 class18) {} }
+  static class Class18 { @Inject Class18(Class19 class19) {} }
+  static class Class19 { @Inject Class19(Class20 class20) {} }
+  static class Class20 { @Inject Class20(Class21 class21) {} }
+  static class Class21 { @Inject Class21(Class22 class22) {} }
+  static class Class22 { @Inject Class22(Class23 class23) {} }
+  static class Class23 { @Inject Class23(Class24 class24) {} }
+  static class Class24 { @Inject Class24(Class25 class25) {} }
+  static class Class25 { @Inject Class25(Class26 class26) {} }
+  static class Class26 { @Inject Class26(Class27 class27) {} }
+  static class Class27 { @Inject Class27(Class28 class28) {} }
+  static class Class28 { @Inject Class28(Class29 class29) {} }
+  static class Class29 { @Inject Class29(Class30 class30) {} }
+  static class Class30 { @Inject Class30(Class31 class31) {} }
+  static class Class31 { @Inject Class31(Class32 class32) {} }
+  static class Class32 { @Inject Class32(Class33 class33) {} }
+  static class Class33 { @Inject Class33(Class34 class34) {} }
+  static class Class34 { @Inject Class34(Class35 class35) {} }
+  static class Class35 { @Inject Class35(Class36 class36) {} }
+  static class Class36 { @Inject Class36(Class37 class37) {} }
+  static class Class37 { @Inject Class37(Class38 class38) {} }
+  static class Class38 { @Inject Class38(Class39 class39) {} }
+  static class Class39 { @Inject Class39(Class40 class40) {} }
+  static class Class40 { @Inject Class40(Class41 class41) {} }
+  static class Class41 { @Inject Class41(Class42 class42) {} }
+  static class Class42 { @Inject Class42(Class43 class43) {} }
+  static class Class43 { @Inject Class43(Class44 class44) {} }
+  static class Class44 { @Inject Class44(Class45 class45) {} }
+  static class Class45 { @Inject Class45(Class46 class46) {} }
+  static class Class46 { @Inject Class46(Class47 class47) {} }
+  static class Class47 { @Inject Class47(Class48 class48) {} }
+  static class Class48 { @Inject Class48(Class49 class49) {} }
+  static class Class49 { @Inject Class49(Class50 class50) {} }
+  static class Class50 { @Inject Class50(Class51 class51) {} }
+  static class Class51 { @Inject Class51(Class52 class52) {} }
+  static class Class52 { @Inject Class52(Class53 class53) {} }
+  static class Class53 { @Inject Class53(Class54 class54) {} }
+  static class Class54 { @Inject Class54(Class55 class55) {} }
+  static class Class55 { @Inject Class55(Class56 class56) {} }
+  static class Class56 { @Inject Class56(Class57 class57) {} }
+  static class Class57 { @Inject Class57(Class58 class58) {} }
+  static class Class58 { @Inject Class58(Class59 class59) {} }
+  static class Class59 { @Inject Class59(Class60 class60) {} }
+  static class Class60 { @Inject Class60(Class61 class61) {} }
+  static class Class61 { @Inject Class61(Class62 class62) {} }
+  static class Class62 { @Inject Class62(Class63 class63) {} }
+  static class Class63 { @Inject Class63(Class64 class64) {} }
+  static class Class64 { @Inject Class64(Class65 class65) {} }
+  static class Class65 { @Inject Class65(Class66 class66) {} }
+  static class Class66 { @Inject Class66(Class67 class67) {} }
+  static class Class67 { @Inject Class67(Class68 class68) {} }
+  static class Class68 { @Inject Class68(Class69 class69) {} }
+  static class Class69 { @Inject Class69(Class70 class70) {} }
+  static class Class70 { @Inject Class70(Class71 class71) {} }
+  static class Class71 { @Inject Class71(Class72 class72) {} }
+  static class Class72 { @Inject Class72(Class73 class73) {} }
+  static class Class73 { @Inject Class73(Class74 class74) {} }
+  static class Class74 { @Inject Class74(Class75 class75) {} }
+  static class Class75 { @Inject Class75(Class76 class76) {} }
+  static class Class76 { @Inject Class76(Class77 class77) {} }
+  static class Class77 { @Inject Class77(Class78 class78) {} }
+  static class Class78 { @Inject Class78(Class79 class79) {} }
+  static class Class79 { @Inject Class79(Class80 class80) {} }
+  static class Class80 { @Inject Class80(Class81 class81) {} }
+  static class Class81 { @Inject Class81(Class82 class82) {} }
+  static class Class82 { @Inject Class82(Class83 class83) {} }
+  static class Class83 { @Inject Class83(Class84 class84) {} }
+  static class Class84 { @Inject Class84(Class85 class85) {} }
+  static class Class85 { @Inject Class85(Class86 class86) {} }
+  static class Class86 { @Inject Class86(Class87 class87) {} }
+  static class Class87 { @Inject Class87(Class88 class88) {} }
+  static class Class88 { @Inject Class88(Class89 class89) {} }
+  static class Class89 { @Inject Class89(Class90 class90) {} }
+  static class Class90 { @Inject Class90(Class91 class91) {} }
+  static class Class91 { @Inject Class91(Class92 class92) {} }
+  static class Class92 { @Inject Class92(Class93 class93) {} }
+  static class Class93 { @Inject Class93(Class94 class94) {} }
+  static class Class94 { @Inject Class94(Class95 class95) {} }
+  static class Class95 { @Inject Class95(Class96 class96) {} }
+  static class Class96 { @Inject Class96(Class97 class97) {} }
+  static class Class97 { @Inject Class97(Class98 class98) {} }
+  static class Class98 { @Inject Class98(Class99 class99) {} }
+  static class Class99 { @Inject Class99(Class100 class100) {} }
+  static class Class100 { @Inject Class100(Class101 class101) {} }
+  static class Class101 { @Inject Class101(Provider<Class1> class1Provider) {} }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface LongCycleComponent {
+    Class1 class1();
+  }
+
+  private LongCycle() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
new file mode 100644
index 000000000..108a1b58f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import javax.inject.Inject;
+
+/**
+ * A class that should not be requested by any component, to ensure that we still generate a members
+ * injector for it.
+ */
+class NonRequestedChild extends MembersInjectGenericParent<String> {
+  @Inject
+  NonRequestedChild() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
new file mode 100644
index 000000000..85ce40aac
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage;
+
+import dagger.Component;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AModule;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+/**
+ * A component that tests members injection across packages and subclasses.
+ */
+@Component(modules = {AModule.class})
+public interface MembersInjectionVisibilityComponent {
+  void inject(AParent aParent);
+
+  void inject(BChild aChild);
+
+  void inject(AGrandchild aGrandchild);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
new file mode 100644
index 000000000..8f0f1f39c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+import test.multipackage.b.BChild;
+
+public class AGrandchild extends BChild {
+
+  @Inject APackagePrivateObject aGrandchildField;
+
+  private APackagePrivateObject aGrandchildMethod;
+
+  @Inject
+  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {
+    this.aGrandchildMethod = aGrandchildMethod;
+  }
+
+  @Override
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  @Override
+  protected void aChildMethod(APublicObject aChildMethod) {
+    super.aChildMethod(aChildMethod);
+  }
+
+  public APackagePrivateObject aGrandchildField() {
+    return aGrandchildField;
+  }
+
+  public APackagePrivateObject aGrandchildMethod() {
+    return aGrandchildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
new file mode 100644
index 000000000..d60413331
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+class APackagePrivateObject {
+
+  @Inject
+  APackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
new file mode 100644
index 000000000..4c91a6f26
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class AParent {
+
+  @Inject APackagePrivateObject aParentField;
+
+  private APublicObject aParentMethod;
+
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    this.aParentMethod = aParentMethod;
+  }
+
+  public APackagePrivateObject aParentField() {
+    return aParentField;
+  }
+
+  public APublicObject aParentMethod() {
+    return aParentMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
new file mode 100644
index 000000000..90357f661
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class APublicObject {
+
+  @Inject
+  APublicObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
new file mode 100644
index 000000000..188d1201f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+import test.multipackage.a.AParent;
+import test.multipackage.a.APublicObject;
+
+public class BChild extends AParent {
+
+  @Inject BPackagePrivateObject aChildField;
+
+  private APublicObject aChildMethod;
+
+  @Inject
+  protected void aChildMethod(APublicObject aChildMethod) {
+    this.aChildMethod = aChildMethod;
+  }
+
+  @Override
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  public BPackagePrivateObject aChildField() {
+    return aChildField;
+  }
+
+  public APublicObject aChildMethod() {
+    return aChildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
new file mode 100644
index 000000000..c397a02c8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+
+class BPackagePrivateObject {
+
+  @Inject
+  BPackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
index 255f28c3a..4be51ed7b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 
 /**
- * A simple component that demonstrates both static an non-static provides methods.
+ * A simple component that demonstrates both static and non-static provides methods.
  */
 @Component(modules = {AllStaticModule.class, SomeStaticModule.class})
 interface StaticTestComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
new file mode 100644
index 000000000..d778fc5c5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+
+/**
+ * A simple component that demonstrates both static and non-static provides methods with a builder.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponentWithBuilder extends StaticTestComponent {
+  @Component.Builder
+  interface Builder {
+    Builder allStaticModule(AllStaticModule allStaticModule);
+    Builder someStaticModule(SomeStaticModule someStaticModule);
+    StaticTestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
index 6c061bc5c..2529433ae 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -17,6 +17,6 @@
 
 import dagger.Subcomponent;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 abstract class ChildAbstractClassComponent implements ChildComponent {
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 67d66cae9..d3c28f2b4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 import javax.inject.Provider;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 interface ChildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
@@ -28,4 +28,6 @@
   Set<Object> objectSet();
 
   GrandchildComponent newGrandchildComponent();
+  
+  Object object();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
new file mode 100644
index 000000000..612096417
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.mapkeys.StringKey;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import javax.inject.Inject;
+
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
+
+final class MultibindingSubcomponents {
+
+  /** Multibindings for this type are bound only in the parent component. */
+  enum BoundInParent {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound only in the child component. */
+  enum BoundInChild {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound in the parent component and the child component. */
+  enum BoundInParentAndChild {
+    IN_PARENT,
+    IN_CHILD;
+  }
+
+  static final class RequiresMultibindings<T> {
+    private final Set<T> set;
+    private final Map<String, T> map;
+
+    @Inject
+    RequiresMultibindings(Set<T> set, Map<String, T> map) {
+      this.set = set;
+      this.map = map;
+    }
+
+    Set<T> set() {
+      return set;
+    }
+
+    Map<String, T> map() {
+      return map;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof RequiresMultibindings<?>
+          && set.equals(((RequiresMultibindings<?>) obj).set)
+          && map.equals(((RequiresMultibindings<?>) obj).map);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(set, map);
+    }
+
+    @Override
+    public String toString() {
+      return String.format(
+          "%s{set=%s, map=%s}", RequiresMultibindings.class.getSimpleName(), set, map);
+    }
+  }
+
+  @Module
+  static final class ParentMultibindingModule {
+
+    @Provides(type = SET)
+    static BoundInParent onlyInParentElement() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("parent key")
+    static BoundInParent onlyInParentEntry() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides(type = SET)
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("parent key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    @Provides(type = SET)
+    static RequiresMultibindings<BoundInParentAndChild>
+        requiresMultibindingsInParentAndChildElement(
+            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
+      return requiresMultibindingsInParentAndChild;
+    }
+  }
+
+  @Module
+  static final class ChildMultibindingModule {
+
+    @Provides(type = SET)
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("child key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides(type = SET)
+    static BoundInChild onlyInChildElement() {
+      return BoundInChild.INSTANCE;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("child key")
+    static BoundInChild onlyInChildEntry() {
+      return BoundInChild.INSTANCE;
+    }
+  }
+
+  interface ProvidesBoundInParent {
+    RequiresMultibindings<BoundInParent> requiresMultibindingsBoundInParent();
+  }
+
+  interface ProvidesBoundInChild {
+    RequiresMultibindings<BoundInChild> requiresMultibindingsBoundInChild();
+  }
+
+  interface ProvidesBoundInParentAndChild {
+    RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsBoundInParentAndChild();
+  }
+
+  interface ProvidesSetOfRequiresMultibindings {
+    Set<RequiresMultibindings<BoundInParentAndChild>> setOfRequiresMultibindingsInParentAndChild();
+  }
+
+  interface ParentWithProvision extends ProvidesBoundInParent, ProvidesBoundInParentAndChild {}
+
+  interface HasChildWithProvision {
+    ChildWithProvision childWithProvision();
+  }
+
+  interface HasChildWithoutProvision {
+    ChildWithoutProvision childWithoutProvision();
+  }
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithoutProvision extends HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithProvision extends HasChildWithProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithoutProvision
+      extends ParentWithProvision, HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithProvision
+      extends ParentWithProvision, HasChildWithProvision {}
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithoutProvision {
+    Grandchild grandchild();
+  }
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithProvision
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {
+
+    Grandchild grandchild();
+  }
+
+  @Subcomponent
+  interface Grandchild
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
new file mode 100644
index 000000000..f7fd49058
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class StaticChildModule {
+  private StaticChildModule() {}
+  
+  @Provides static Object provideStaticObject() {
+    return "static";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
deleted file mode 100644
index badb7cac6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
+++ /dev/null
@@ -1,14 +0,0 @@
-
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-import java.util.Set;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface ChildComponent {
-  String getString();
-  Set<String> getMultiboundStrings();
-  OnlyUsedInChild getOnlyUsedInChild();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
index 91df02cc3..f0af00237 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -1,19 +1,39 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
 import dagger.Component;
-
 import java.util.Set;
 
 @Component(modules = RepeatedModule.class)
 interface ParentComponent {
+  Object state();
+
   String getString();
   Set<String> getMultiboundStrings();
   OnlyUsedInParent getOnlyUsedInParent();
 
-  ChildComponent newChildComponent();
+  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
+
+  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
 
   @Component.Builder
   interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
     ParentComponent build();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index 508a41b56..d0997513d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -1,25 +1,51 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
-import static dagger.Provides.Type.SET;
-
 import dagger.Module;
 import dagger.Provides;
 
+import static dagger.Provides.Type.SET;
+
 @Module
 final class RepeatedModule {
-  @Provides String provideString() {
+  private final Object state = new Object();
+
+  @Provides
+  Object state() {
+    return state;
+  }
+
+  @Provides
+  static String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET) String contributeString() {
+  @Provides(type = SET)
+  static String contributeString() {
     return "a string in a set";
   }
 
-  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
+  @Provides
+  static OnlyUsedInParent provideOnlyUsedInParent() {
     return new OnlyUsedInParent() {};
   }
 
-  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
+  @Provides
+  static OnlyUsedInChild provideOnlyUsedInChild() {
     return new OnlyUsedInChild() {};
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..279bc954c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface SubcomponentWithRepeatedModule {
+  Object state();
+
+  String getString();
+
+  Set<String> getMultiboundStrings();
+
+  OnlyUsedInChild getOnlyUsedInChild();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    SubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
new file mode 100644
index 000000000..e63c9a0ae
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent
+interface SubcomponentWithoutRepeatedModule {
+  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 66a429be1..e0ad8e651 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,6 +15,8 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableMap;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
@@ -47,6 +49,15 @@
     assertThat(map).containsEntry("bar", "bar value");
   }
 
+  @Test public void mapOfArrays() {
+    Map<String, String[]> map = multibindingComponent.mapOfArrays();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey("foo");
+    assertThat(map.get("foo")).asList().containsExactly("foo1", "foo2").inOrder();
+    assertThat(map).containsKey("bar");
+    assertThat(map.get("bar")).asList().containsExactly("bar1", "bar2").inOrder();
+  }
+
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
     assertThat(mapOfProviders).hasSize(2);
@@ -80,7 +91,7 @@ public void wrappedAnnotationKeyMap() {
         .isEqualTo(
             ImmutableMap.of(
                 testWrappedAnnotationKey(
-                    testStringKey("foo"), new int[] {1, 2, 3}, new TestClassKey[] {}, classes),
+                    testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
                 "wrapped foo annotation"));
   }
 
@@ -140,22 +151,64 @@ public void shortKeyMap() {
     assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
   }
 
+  @Test public void complexQualifierSet() {
+    assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
+  }
+  
+  @Test
+  public void emptySet() {
+    assertThat(multibindingComponent.emptySet()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedSet() {
+    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();
+  }
+
+  @Test
+  public void emptyMap() {
+    assertThat(multibindingComponent.emptyMap()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedMap() {
+    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();
+  }
+
+  @Test
+  public void maybeEmptySet() {
+    assertThat(multibindingComponent.maybeEmptySet()).containsExactly("foo");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedSet() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly("qualified foo");
+  }
+
+  @Test
+  public void maybeEmptyMap() {
+    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry("key", "foo value");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedMap() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedMap())
+        .containsEntry("key", "qualified foo value");
+  }
+
   @AutoAnnotation
-  static TestStringKey testStringKey(String value) {
+  static StringKey testStringKey(String value) {
     return new AutoAnnotation_MultibindingTest_testStringKey(value);
   }
 
   @AutoAnnotation
-  static TestStringKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+  static NestedAnnotationContainer.NestedWrappedKey nestedWrappedKey(Class<?> value) {
     return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
 
   @AutoAnnotation
-  static TestWrappedAnnotationKey testWrappedAnnotationKey(
-      TestStringKey value,
-      int[] integers,
-      TestClassKey[] annotations,
-      Class<? extends Number>[] classes) {
+  static WrappedAnnotationKey testWrappedAnnotationKey(
+      StringKey value, int[] integers, ClassKey[] annotations, Class<? extends Number>[] classes) {
     return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
         value, integers, annotations, classes);
   }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index ba590d2d9..46f5388ec 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -163,7 +163,7 @@
     assertThat(child2.l()).isEqualTo(6L);
     assertThat(child2.b()).isEqualTo((byte)70);
   }
-  
+    
   @Test
   public void grandchildren() {
     ParentComponent parent = DaggerParentComponent.create();
@@ -222,4 +222,45 @@ public void genericSubcomponentMethod() {
     assertThat(child.i()).isEqualTo(21);
   }
   
+  @Test
+  public void requireSubcomponentBuilderProviders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
+  
+  @Test
+  public void requireSubcomponentBuilders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilder()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilder()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
new file mode 100644
index 000000000..d3bc2cbad
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.cycle.Cycles.A;
+import test.cycle.Cycles.C;
+import test.cycle.Cycles.ChildCycleComponent;
+import test.cycle.Cycles.CycleComponent;
+import test.cycle.Cycles.CycleMapComponent;
+import test.cycle.Cycles.S;
+import test.cycle.Cycles.SelfCycleComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class CycleTest {
+  @Test
+  public void providerIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void providerIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aProvider.get()).isNotNull();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sLazy.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aLazy.get()).isNotNull();
+    assertThat(a.b.c.aLazy.get()).isNotNull();
+    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
+  }
+  
+  @Test
+  public void subcomponentIndirectionCycle() {
+    ChildCycleComponent childCycleComponent = DaggerCycles_CycleComponent.create().child();
+    A a = childCycleComponent.a();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+  
+  @Test
+  public void providerMapIndirectionCycle() {
+    CycleMapComponent cycleMapComponent = DaggerCycles_CycleMapComponent.create();
+    assertThat(cycleMapComponent.y()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).containsKey("X");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get().y).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).containsKey("Y");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfY).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
new file mode 100644
index 000000000..e50eaee69
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.cycle.LongCycle.LongCycleComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class LongCycleTest {
+  
+  /**
+   * Tests a cycle long enough that the real factory is created in a separate initialize method from
+   * the delegate factory.
+   */
+  @Test
+  public void longCycle() {
+    LongCycleComponent longCycleComponent = DaggerLongCycle_LongCycleComponent.create();
+    assertThat(longCycleComponent.class1()).isNotNull();
+  }
+
+  /**
+   * Fails if {@link LongCycleComponent} doesn't have a long enough cycle to make sure the real
+   * factory is created in a separate method from the delegate factory.
+   */
+  @Test
+  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
+    DaggerLongCycle_LongCycleComponent.class
+        .getDeclaredMethod("initialize1", DaggerLongCycle_LongCycleComponent.Builder.class);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 1b382d8f7..411ecb177 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -1,36 +1,45 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.membersinject;
 
+import dagger.MembersInjector;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import test.multipackage.DaggerMembersInjectionVisibilityComponent;
+import test.multipackage.MembersInjectionVisibilityComponent;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public class MembersInjectTest {
   @Test public void testMembersInject_arrays() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfStringArray childOfStringArray = new ChildOfStringArray();
     component.inject(childOfStringArray);
   }
 
   @Test public void testMembersInject_nestedArrays() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
         new ChildOfArrayOfParentOfStringArray();
     component.inject(childOfArrayOfParentOfStringArray);
@@ -38,8 +47,49 @@
 
   @Test public void testMembersInject_primitives() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
     component.inject(childOfPrimitiveIntArray);
   }
+
+  @Test
+  public void testMembersInject_overrides() {
+    MembersInjectionVisibilityComponent component =
+        DaggerMembersInjectionVisibilityComponent.create();
+    AParent aParent = new AParent();
+    component.inject(aParent);
+    assertThat(aParent.aParentField()).isNotNull();
+    assertThat(aParent.aParentMethod()).isNotNull();
+
+    BChild aChild = new BChild();
+    component.inject(aChild);
+    assertThat(aChild.aParentField()).isNotNull();
+    assertThat(aChild.aParentMethod()).isNull();
+    assertThat(aChild.aChildField()).isNotNull();
+    assertThat(aChild.aChildMethod()).isNotNull();
+
+    AGrandchild aGrandchild = new AGrandchild();
+    component.inject(aGrandchild);
+    assertThat(aGrandchild.aParentField()).isNotNull();
+    assertThat(aGrandchild.aParentMethod()).isNotNull();
+    assertThat(aGrandchild.aChildField()).isNotNull();
+    assertThat(aGrandchild.aChildMethod()).isNull();
+    assertThat(aGrandchild.aGrandchildField()).isNotNull();
+    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();
+  }
+
+  @Test
+  public void testNonRequestedMembersInjector() {
+    NonRequestedChild child = new NonRequestedChild();
+    Provider<String> provider =
+        new Provider<String>() {
+          @Override
+          public String get() {
+            return "field!";
+          }
+        };
+    MembersInjector<NonRequestedChild> injector = new NonRequestedChild_MembersInjector(provider);
+    injector.injectMembers(child);
+    assertThat(child.t).isEqualTo("field!");
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
index 53185f8fc..397259403 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -15,17 +15,35 @@
  */
 package test.staticprovides;
 
-import static com.google.common.truth.Truth.assertThat;
-
 import com.google.common.collect.ImmutableSet;
-
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+@RunWith(Parameterized.class)
 public class StaticProvidesTest {
-  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+  @Parameters
+  public static Collection<Object[]> components() {
+    return Arrays.asList(new Object[][] {
+        {DaggerStaticTestComponent.create()},
+        {DaggerStaticTestComponentWithBuilder.builder().build()},
+        {DaggerStaticTestComponentWithBuilder.builder()
+          .allStaticModule(new AllStaticModule())
+          .someStaticModule(new SomeStaticModule())
+          .build()}});
+  }
+
+  @Parameter
+  public StaticTestComponent component;
 
   @Test public void setMultibinding() {
     assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
@@ -33,4 +51,21 @@
         SomeStaticModule.class + ".contributeStringFromAStaticMethod",
         SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
   }
+
+  @Test public void allStaticProvidesModules_noFieldInComponentBuilder() {
+    for (Field field : DaggerStaticTestComponent.Builder.class.getDeclaredFields()) {
+      assertWithMessage(field.getName())
+          .that(field.getType()).isNotEqualTo(AllStaticModule.class);
+    }
+  }
+
+  @Test public void allStaticProvidesModules_deprecatedMethodInComponentBuilder() {
+    for (Method method : DaggerStaticTestComponent.Builder.class.getDeclaredMethods()) {
+      if (Arrays.asList(method.getParameterTypes()).contains(AllStaticModule.class)) {
+        assertWithMessage(method.getName())
+            .that(method.isAnnotationPresent(Deprecated.class))
+            .isTrue();
+      }
+    }
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
new file mode 100644
index 000000000..99ca1cd44
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.subcomponent.MultibindingSubcomponents.BoundInChild;
+import test.subcomponent.MultibindingSubcomponents.BoundInParent;
+import test.subcomponent.MultibindingSubcomponents.BoundInParentAndChild;
+import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithoutProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithProvision;
+import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;
+import test.subcomponent.MultibindingSubcomponents.RequiresMultibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SubcomponentMultibindingsTest {
+
+  private static final RequiresMultibindings<BoundInParent> BOUND_IN_PARENT =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParent.INSTANCE),
+          ImmutableMap.of("parent key", BoundInParent.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInChild> BOUND_IN_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInChild.INSTANCE),
+          ImmutableMap.of("child key", BoundInChild.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInParentAndChild> BOUND_IN_PARENT_AND_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParentAndChild.IN_PARENT, BoundInParentAndChild.IN_CHILD),
+          ImmutableMap.of(
+              "parent key", BoundInParentAndChild.IN_PARENT,
+              "child key", BoundInParentAndChild.IN_CHILD));
+
+  private static final RequiresMultibindings<BoundInParentAndChild>
+      BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT =
+          new RequiresMultibindings<>(
+              ImmutableSet.of(BoundInParentAndChild.IN_PARENT),
+              ImmutableMap.of("parent key", BoundInParentAndChild.IN_PARENT));
+
+  private ParentWithoutProvisionHasChildWithoutProvision
+      parentWithoutProvisionHasChildWithoutProvision;
+  private ParentWithoutProvisionHasChildWithProvision parentWithoutProvisionHasChildWithProvision;
+  private ParentWithProvisionHasChildWithoutProvision parentWithProvisionHasChildWithoutProvision;
+  private ParentWithProvisionHasChildWithProvision parentWithProvisionHasChildWithProvision;
+
+  @Before
+  public void setUp() {
+    parentWithoutProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithoutProvision.create();
+    parentWithoutProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithProvision.create();
+    parentWithProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithoutProvision.create();
+    parentWithProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithProvision.create();
+  }
+
+  @Test
+  public void testParentWithoutProvisionHasChildWithoutProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithoutProvisionHasChildWithProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithProvisionHasChildWithoutProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithoutProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithProvisionHasChildWithProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Child
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
new file mode 100644
index 000000000..7e92371bf
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class RepeatedModuleTest {
+  private ParentComponent parentComponent;
+
+  @Before
+  public void initializeParentComponent() {
+    this.parentComponent = DaggerParentComponent.builder().build();
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInSubcomponent() {
+    SubcomponentWithRepeatedModule childComponent =
+        parentComponent.newChildComponentBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(childComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule grandchildComponent =
+        childComponent.newGrandchildBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInSubcomponent() {
+    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
+        parentComponent.newChildComponentBuilder();
+    try {
+      childComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+        childComponent.newGrandchildBuilder();
+    try {
+      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index 206a7e2d8..a0d16498a 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -28,6 +28,10 @@ limitations under the License.
   <artifactId>producers-functional-tests</artifactId>
   <name>Producers Functional Tests</name>
   <dependencies>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
@@ -56,8 +60,9 @@ limitations under the License.
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
     </dependency>
   </dependencies>
   <build>
@@ -66,8 +71,8 @@ limitations under the License.
         <artifactId>maven-compiler-plugin</artifactId>
         <version>3.1</version>
         <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
+          <source>1.7</source>
+          <target>1.7</target>
         </configuration>
       </plugin>
       <plugin>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
index fa392dd8e..a80ea4968 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
index 604107025..dc62612cd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import dagger.Module;
 import dagger.Provides;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
index ad0c792a9..fe47c9973 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
index 57f175812..ba98e3698 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
index 4b14f99b5..85709f0f3 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
similarity index 98%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
index 234c088d3..e16c82212 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
index 039d0fe55..0227be6bd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import javax.inject.Inject;
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
index 7a46e5b0e..8618ff5e1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 final class Response {
   private final String data;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
new file mode 100644
index 000000000..1edbe8aa6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class ResponseModule {
+  @Provides
+  static int requestNumber() {
+    return 5;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
new file mode 100644
index 000000000..02fa7e91f
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Lazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+@ProducerModule(includes = ResponseModule.class)
+final class ResponseProducerModule {
+  @Qualifier
+  @interface RequestsProducerAndProduced {}
+
+  @Produces
+  static ListenableFuture<String> greeting() {
+    return Futures.immediateFuture("Hello");
+  }
+
+  @Produces
+  @RequestsProducerAndProduced
+  static ListenableFuture<String> intermediateGreeting(
+      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
+      // to be a provision binding), and add validation for that.
+      String greeting,
+      Producer<String> greetingProducer,
+      Produced<String> greetingProduced,
+      Provider<Integer> requestNumberProvider,
+      Lazy<Integer> requestNumberLazy) {
+    return greetingProducer.get();
+  }
+
+  @Produces
+  static Response response(
+      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {
+    return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
index 583cd50f0..1d1e49233 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
new file mode 100644
index 000000000..2d831ed7f
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -0,0 +1,219 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package producerstest;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.io.IOException;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+/**
+ * A module that contains various signatures of produces methods. This is not used in any
+ * components.
+ */
+@ProducerModule
+final class SimpleProducerModule {
+  @Qualifier @interface Qual {
+    int value();
+  }
+
+  // Unique bindings.
+
+  @Produces
+  @Qual(-2)
+  static ListenableFuture<String> throwingProducer() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces
+  @Qual(-1)
+  static ListenableFuture<String> settableFutureStr(SettableFuture<String> future) {
+    return future;
+  }
+
+  @Produces
+  @Qual(0)
+  static String str() {
+    return "str";
+  }
+
+  @Produces
+  @Qual(1)
+  static ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("future str");
+  }
+
+  @Produces
+  @Qual(2)
+  static String strWithArg(int i) {
+    return "str with arg";
+  }
+
+  @Produces
+  @Qual(3)
+  static ListenableFuture<String> futureStrWithArg(int i) {
+    return Futures.immediateFuture("future str with arg");
+  }
+
+  @Produces
+  @Qual(4)
+  static String strThrowingException() throws IOException {
+    return "str throwing exception";
+  }
+
+  @Produces
+  @Qual(5)
+  static ListenableFuture<String> futureStrThrowingException() throws IOException {
+    return Futures.immediateFuture("future str throwing exception");
+  }
+
+  @Produces
+  @Qual(6)
+  static String strWithArgThrowingException(int i) throws IOException {
+    return "str with arg throwing exception";
+  }
+
+  @Produces
+  @Qual(7)
+  static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
+    return Futures.immediateFuture("future str with arg throwing exception");
+  }
+
+  @Produces
+  @Qual(8)
+  static String strWithArgs(int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return "str with args";
+  }
+
+  @Produces
+  @Qual(9)
+  static String strWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return "str with args throwing exception";
+  }
+
+  @Produces
+  @Qual(10)
+  static ListenableFuture<String> futureStrWithArgs(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return Futures.immediateFuture("future str with args");
+  }
+
+  @Produces
+  @Qual(11)
+  static ListenableFuture<String> futureStrWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return Futures.immediateFuture("str with args throwing exception");
+  }
+
+  // Set bindings.
+
+  @Produces(type = SET)
+  static String setOfStrElement() {
+    return "set of str element";
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementThrowingException() throws IOException {
+    return "set of str element throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElement() {
+    return Futures.immediateFuture("set of str element");
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
+    return Futures.immediateFuture("set of str element throwing exception");
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementWithArg(int i) {
+    return "set of str element with arg";
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementWithArgThrowingException(int i) throws IOException {
+    return "set of str element with arg throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
+    return Futures.immediateFuture("set of str element with arg");
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.immediateFuture("set of str element with arg throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValues() {
+    return ImmutableSet.of("set of str 1", "set of str 2");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesThrowingException() throws IOException {
+    return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValues() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArg(int i) {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
new file mode 100644
index 000000000..7bba4ea4e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface ComponentDependency {
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
new file mode 100644
index 000000000..6b3536eae
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A component that contains entry points that exercise different execution paths, for verifying the
+ * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
+ */
+@ProductionComponent(dependencies = ComponentDependency.class, modules = SimpleProducerModule.class)
+interface SimpleComponent {
+  /** An entry point exposing a producer method with no args. */
+  ListenableFuture<String> noArgStr();
+
+  /** An entry point exposing a producer method that depends on another producer method. */
+  ListenableFuture<Integer> singleArgInt();
+
+  /** An entry point exposing a producer method that depends on a component dependency method. */
+  ListenableFuture<Boolean> singleArgBool();
+
+  /** An entry point exposing a component dependency method. */
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
similarity index 64%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
index bda53eb56..00ab037bd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
@@ -13,20 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest.badexecutor;
 
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
 @ProducerModule
-final class ResponseProducerModule {
-  @Produces ListenableFuture<String> greeting() {
-    return Futures.immediateFuture("Hello");
+final class SimpleProducerModule {
+  @Produces
+  static String noArgStr() {
+    return "no arg string";
   }
 
-  @Produces Response response(String greeting, Request request) {
-    return new Response(greeting + ", " + request.name() + "!");
+  @Produces
+  static int singleArgInt(String arg) {
+    return arg.length();
+  }
+
+  @Produces
+  static boolean singleArgBool(double arg) {
+    return arg > 0.0;
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
new file mode 100644
index 000000000..dadde7b05
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface DepComponent {
+  ListenableFuture<Double> d();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
new file mode 100644
index 000000000..7f99836d3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class IntModule {
+  @Provides
+  static int i() {
+    return 42;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
new file mode 100644
index 000000000..cdf0793da
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class StringModule {
+  @Produces
+  static String str(int i) {
+    return "arg: " + i;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
new file mode 100644
index 000000000..16dc9bad7
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+@ProductionComponent(
+  modules = {StringModule.class, IntModule.class},
+  dependencies = DepComponent.class
+)
+interface TestComponentWithBuilder {
+  ListenableFuture<String> s();
+  ListenableFuture<Double> d();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder depComponent(DepComponent depComponent);
+    Builder strModule(StringModule strModule);
+    Builder executor(Executor executor);
+    TestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
similarity index 76%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
index 561ad4a89..48acbabac 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -13,14 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest.monitoring;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
-import java.util.Set;
 
-@ProductionComponent(modules = MultibindingProducerModule.class)
-interface MultibindingComponent {
-  ListenableFuture<Set<String>> strs();
-  ListenableFuture<Integer> strCount();
+@ProductionComponent(modules = {MonitoringModule.class, StubModule.class, ServingModule.class})
+interface MonitoredComponent {
+  ListenableFuture<String> output();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
new file mode 100644
index 000000000..0c4209076
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class MonitoringModule {
+  private final ProductionComponentMonitor.Factory monitorFactory;
+
+  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {
+    this.monitorFactory = monitorFactory;
+  }
+
+  @Provides(type = SET)
+  ProductionComponentMonitor.Factory monitorFactory() {
+    return monitorFactory;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
new file mode 100644
index 000000000..d5bec22ce
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Qualifier;
+import producerstest.monitoring.StubModule.ForServer1;
+import producerstest.monitoring.StubModule.ForServer2;
+
+@ProducerModule
+final class ServingModule {
+  @Qualifier
+  @interface RequestData {}
+
+  @Qualifier
+  @interface IntermediateData {}
+
+  @Produces
+  @RequestData
+  static String requestData() {
+    return "Hello, World!";
+  }
+
+  @Produces
+  @IntermediateData
+  static ListenableFuture<String> callServer1(
+      @RequestData String data, @ForServer1 StringStub stub) {
+    return stub.run(data);
+  }
+
+  @Produces
+  static ListenableFuture<String> callServer2(
+      @IntermediateData String data, @ForServer2 StringStub stub) {
+    return stub.run(data);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
new file mode 100644
index 000000000..195dd283d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface StringStub {
+  ListenableFuture<String> run(String input);
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
new file mode 100644
index 000000000..dc8ab6260
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Qualifier;
+
+@Module
+final class StubModule {
+  @Qualifier
+  @interface ForServer1 {}
+
+  @Qualifier
+  @interface ForServer2 {}
+
+  private final StringStub server1;
+  private final StringStub server2;
+
+  StubModule(StringStub server1, StringStub server2) {
+    this.server1 = server1;
+    this.server2 = server2;
+  }
+
+  @Provides
+  @ForServer1
+  StringStub server1() {
+    return server1;
+  }
+
+  @Provides
+  @ForServer2
+  StringStub server2() {
+    return server2;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
new file mode 100644
index 000000000..efbd5a593
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProductionComponent;
+import java.util.Map;
+import java.util.Set;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
+
+@ProductionComponent(modules = MultibindingProducerModule.class)
+interface MultibindingComponent {
+  ListenableFuture<Set<String>> strs();
+  ListenableFuture<Integer> strCount();
+
+  ListenableFuture<Set<Produced<String>>> successfulSet();
+
+  @PossiblyThrowingSet
+  ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
+
+  ListenableFuture<Map<Integer, String>> map();
+
+  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducer();
+
+  ListenableFuture<Map<Integer, Produced<String>>> mapOfProduced();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducer();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
new file mode 100644
index 000000000..dbeefeede
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.mapkeys.IntKey;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
+import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
+import java.util.Set;
+
+import static dagger.producers.Produces.Type.MAP;
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+@ProducerModule
+final class MultibindingProducerModule {
+  @Produces(type = SET)
+  static ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("foo");
+  }
+
+  @Produces(type = SET)
+  static String str() {
+    return "bar";
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> futureStrs() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> strs() {
+    return ImmutableSet.of("bar1", "bar2");
+  }
+
+  @Produces
+  static int strCount(Set<String> strs) {
+    return strs.size();
+  }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String successfulStringForSet() {
+    return "singleton";
+  }
+
+  @Produces(type = SET_VALUES)
+  @PossiblyThrowingSet
+  static Set<String> successfulStringsForSet() {
+    return ImmutableSet.of("double", "ton");
+  }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String throwingStringForSet() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces(type = MAP)
+  @IntKey(42)
+  static ListenableFuture<String> futureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces(type = MAP)
+  @IntKey(15)
+  static String valueFor15() {
+    return "fifteen";
+  }
+
+  @Produces(type = MAP)
+  @PossiblyThrowingMap
+  @IntKey(42)
+  static ListenableFuture<String> successfulFutureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces(type = MAP)
+  @PossiblyThrowingMap
+  @IntKey(15)
+  static String throwingValueFor15() {
+    throw new RuntimeException("monkey");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
new file mode 100644
index 000000000..1a41b4330
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Documented;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class Qualifiers {
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingMap {}
+
+  private Qualifiers() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
new file mode 100644
index 000000000..3ebd6078d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+final class Subcomponents {
+  @Qualifier
+  @interface FromParent {}
+
+  @Qualifier
+  @interface FromChild {}
+
+  @Qualifier
+  @interface FromGrandchild {}
+
+  @Module
+  static final class ParentModule {
+    @Provides
+    @FromParent
+    static String fromParent() {
+      return "parent";
+    }
+  }
+
+  @Component(modules = ParentModule.class)
+  interface ParentComponent {
+    InjectsChildBuilder injectsChildBuilder();
+
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ParentProducerModule {
+    @Produces
+    @FromParent
+    static String fromParent() {
+      return "parentproduction";
+    }
+  }
+
+  @ProductionComponent(modules = ParentProducerModule.class)
+  interface ParentProductionComponent {
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ChildProducerModule {
+    @Produces
+    @FromChild
+    static String fromChild(@FromParent String fromParent) {
+      return "child:" + fromParent;
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponent {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder executor(Executor executor);
+
+      ChildComponent build();
+    }
+  }
+
+  static final class InjectsChildBuilder {
+    private final Provider<ChildComponent.Builder> childBuilder;
+
+    @Inject
+    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+      this.childBuilder = childBuilder;
+    }
+
+    ChildComponent.Builder childBuilder() {
+      return childBuilder.get();
+    }
+  }
+
+  @ProducerModule
+  static final class GrandchildProducerModule {
+    @Produces
+    @FromGrandchild
+    static String fromGranchild(@FromChild String fromChild) {
+      return "grandchild:" + fromChild;
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponent {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder executor(Executor executor);
+
+      GrandchildComponent build();
+    }
+  }
+
+  private Subcomponents() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
deleted file mode 100644
index 4651afcc6..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.util.Set;
-
-import static dagger.producers.Produces.Type.SET;
-import static dagger.producers.Produces.Type.SET_VALUES;
-
-@ProducerModule
-final class MultibindingProducerModule {
-  @Produces(type = SET) ListenableFuture<String> futureStr() {
-    return Futures.immediateFuture("foo");
-  }
-
-  @Produces(type = SET) String str() {
-    return "bar";
-  }
-
-  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
-    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
-  }
-
-  @Produces(type = SET_VALUES) Set<String> strs() {
-    return ImmutableSet.of("bar1", "bar2");
-  }
-
-  @Produces int strCount(Set<String> strs) {
-    return strs.size();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
deleted file mode 100644
index fa63d4822..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class SimpleProducerModule {
-  @Produces ListenableFuture<String> str() {
-    return Futures.immediateFuture("Hello, World!");
-  }
-
-  @Produces int len(String str) {
-    return str.length();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
similarity index 99%
rename from compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
index 15aa48165..b2533d735 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
@@ -13,7 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
new file mode 100644
index 000000000..9a5602990
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -0,0 +1,185 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package producerstest;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public class ProducerFactoryTest {
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void setUpMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void noArgMethod() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider);
+    assertThat(producer.get().get()).isEqualTo("str");
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    order.verify(monitor).succeeded("str");
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test public void singleArgMethod() throws Exception {
+    SettableFuture<Integer> intFuture = SettableFuture.create();
+    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_StrWithArgFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, intProducer);
+    assertThat(producer.get().isDone()).isFalse();
+    intFuture.set(42);
+    assertThat(producer.get().get()).isEqualTo("str with arg");
+  }
+
+  @Test
+  public void successMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    strFuture.set("monkey");
+    assertThat(producer.get().get()).isEqualTo("monkey");
+    order.verify(monitor).succeeded("monkey");
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    Throwable t = new RuntimeException("monkey");
+    strFuture.setException(t);
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+      order.verify(monitor).failed(t);
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitorDueToThrowingProducer() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
+
+    Producer<String> producer =
+        new SimpleProducerModule_ThrowingProducerFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider);
+    assertThat(producer.get().isDone()).isTrue();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      order.verify(monitor).failed(e.getCause());
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void nullComponentMonitorProvider() throws Exception {
+    new SimpleProducerModule_StrFactory(MoreExecutors.directExecutor(), null);
+  }
+
+  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new Producer<T>() {
+      @Override public ListenableFuture<T> get() {
+        return future;
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
similarity index 96%
rename from compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
index f2b910e3c..cacc0f11d 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
@@ -13,7 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
@@ -30,6 +30,6 @@
         .executor(MoreExecutors.directExecutor())
         .build();
     assertThat(simpleComponent).isNotNull();
-    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
new file mode 100644
index 000000000..8a49797f5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -0,0 +1,74 @@
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.RejectedExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
+@RunWith(JUnit4.class)
+public final class BadExecutorTest {
+  private SimpleComponent component;
+
+  @Before
+  public void setUpComponent() {
+    ComponentDependency dependency =
+        new ComponentDependency() {
+          @Override
+          public ListenableFuture<Double> doubleDep() {
+            return Futures.immediateFuture(42.0);
+          }
+        };
+    ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
+    component =
+        DaggerSimpleComponent.builder()
+            .executor(executorService)
+            .componentDependency(dependency)
+            .build();
+    executorService.shutdown();
+  }
+
+  @Test
+  public void rejectNoArgMethod() throws Exception {
+    try {
+      component.noArgStr().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgMethod() throws Exception {
+    try {
+      component.singleArgInt().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgFromComponentDepMethod() throws Exception {
+    try {
+      component.singleArgBool().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void doNotRejectComponentDepMethod() throws Exception {
+    assertThat(component.doubleDep().get()).isEqualTo(42.0);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
new file mode 100644
index 000000000..715761df4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
+@RunWith(JUnit4.class)
+public final class ProductionComponentBuilderTest {
+
+  @Test
+  public void successfulBuild() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .strModule(new StringModule())
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test
+  public void successfulBuild_withMissingZeroArgModule() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingExecutor() {
+    DaggerTestComponentWithBuilder.builder()
+        .depComponent(depComponent(15.3))
+        .strModule(new StringModule())
+        .build();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingDepComponent() {
+    DaggerTestComponentWithBuilder.builder()
+        .executor(MoreExecutors.directExecutor())
+        .strModule(new StringModule())
+        .build();
+  }
+
+  private static DepComponent depComponent(final double value) {
+    return new DepComponent() {
+      @Override
+      public ListenableFuture<Double> d() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
new file mode 100644
index 000000000..375c90a19
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+/** Tests for production components using monitoring. */
+@RunWith(JUnit4.class)
+public final class MonitoringTest {
+  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;
+  @Mock private StringStub server1;
+  @Mock private StringStub server2;
+  private SettableFuture<String> server1Future;
+  private SettableFuture<String> server2Future;
+  private FakeProductionComponentMonitor componentMonitor;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    componentMonitor = new FakeProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+    server1Future = SettableFuture.create();
+    server2Future = SettableFuture.create();
+    when(server1.run(any(String.class))).thenReturn(server1Future);
+    when(server2.run(any(String.class))).thenReturn(server2Future);
+  }
+
+  @Test
+  public void basicMonitoring() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server1Future.set("server 1 response");
+    inOrder.verify(callServer1Monitor).succeeded("server 1 response");
+    inOrder.verify(callServer2Monitor).methodStarting();
+    inOrder.verify(callServer2Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server2Future.set("server 2 response");
+    inOrder.verify(callServer2Monitor).succeeded("server 2 response");
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    assertThat(output.get()).isEqualTo("server 2 response");
+  }
+
+  @Test
+  public void basicMonitoringWithFailure() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    RuntimeException cause = new RuntimeException("monkey");
+    server1Future.setException(cause);
+    inOrder.verify(callServer1Monitor).failed(cause);
+    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    try {
+      output.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(Throwables.getRootCause(e)).isSameAs(cause);
+    }
+  }
+
+  private static final class FakeProductionComponentMonitor implements ProductionComponentMonitor {
+    final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ProducerMonitor monitor = mock(ProducerMonitor.class);
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
new file mode 100644
index 000000000..15ce7592c
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test
+  public void setBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
+  }
+
+  @Test
+  public void setBindingOfProduced() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.successfulSet().get())
+        .containsExactly(
+            Produced.successful("foo"),
+            Produced.successful("foo1"),
+            Produced.successful("foo2"),
+            Produced.successful("bar"),
+            Produced.successful("bar1"),
+            Produced.successful("bar2"));
+  }
+
+  @Test
+  public void setBindingOfProducedWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
+    Set<String> successes = new HashSet<>();
+    Set<ExecutionException> failures = new HashSet<>();
+    for (Produced<String> str : possiblyThrowingSet) {
+      try {
+        successes.add(str.get());
+      } catch (ExecutionException e) {
+        failures.add(e);
+      }
+    }
+    assertThat(successes).containsExactly("singleton", "double", "ton");
+    assertThat(failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
+  }
+
+  @Test
+  public void mapBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, String> map = multibindingComponent.map().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry(15, "fifteen");
+    assertThat(map).containsEntry(42, "forty two");
+  }
+
+  @Test
+  public void mapOfProducerBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+  }
+
+  @Test
+  public void mapOfProducedBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+  }
+
+  @Test
+  public void mapBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    try {
+      multibindingComponent.possiblyThrowingMap().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void mapOfProducerBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Producer<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProducer().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    ListenableFuture<String> future = map.get(15).get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void mapOfProducedBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Produced<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    Produced<String> produced = map.get(15);
+    try {
+      produced.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
new file mode 100644
index 000000000..ef15bdd23
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Executor;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.Subcomponents.ChildComponent;
+import producerstest.subcomponent.Subcomponents.GrandchildComponent;
+import producerstest.subcomponent.Subcomponents.ParentComponent;
+import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentTest {
+  @Test
+  public void topLevelComponent_child() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+  }
+
+  @Test
+  public void topLevelComponent_injectsChildBuilder() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.injectsChildBuilder().childBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+  }
+
+  @Test
+  public void topLevelComponent_grandchild() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild =
+        child.newGrandchildComponentBuilder().executor(executor).build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+  }
+
+  @Test
+  public void topLevelProductionComponent_child() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentProductionComponent parent =
+        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchild() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentProductionComponent parent =
+        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild =
+        child.newGrandchildComponentBuilder().executor(executor).build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
deleted file mode 100644
index 20c86dc52..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class MultibindingTest {
-  @Test public void multibinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.builder()
-        .executor(MoreExecutors.directExecutor())
-        .build();
-    assertThat(multibindingComponent.strs().get())
-        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
deleted file mode 100644
index 3826b6ed0..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
-import com.google.common.util.concurrent.SettableFuture;
-import dagger.producers.Producer;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class ProducerFactoryTest {
-  @Test public void noArgMethod() throws Exception {
-    SimpleProducerModule module = new SimpleProducerModule();
-    Producer<String> producer =
-        new SimpleProducerModule_StrFactory(module, MoreExecutors.directExecutor());
-    assertThat(producer.get().get()).isEqualTo("Hello, World!");
-  }
-
-  @Test public void singleArgMethod() throws Exception {
-    SimpleProducerModule module = new SimpleProducerModule();
-    SettableFuture<String> strFuture = SettableFuture.create();
-    Producer<String> strProducer = producerOfFuture(strFuture);
-    Producer<Integer> producer =
-        new SimpleProducerModule_LenFactory(module, MoreExecutors.directExecutor(), strProducer);
-    assertThat(producer.get().isDone()).isFalse();
-    strFuture.set("abcdef");
-    assertThat(producer.get().get()).isEqualTo(6);
-  }
-
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
-      @Override public ListenableFuture<T> get() {
-        return future;
-      }
-    };
-  }
-}
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
new file mode 100644
index 000000000..34a018f7d
--- /dev/null
+++ b/compiler/src/it/tck/pom.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2014 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>tck</artifactId>
+  <name>TCK</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject-tck</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+          <compilerArgs>
+            <arg>-Adagger.privateMemberValidation=warning</arg>
+            <arg>-Adagger.staticMemberValidation=warning</arg>
+          </compilerArgs>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <configuration>
+          <failsOnError>false</failsOnError>
+          <consoleOutput>true</consoleOutput>
+          <configLocation>../../../../checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
new file mode 100644
index 000000000..31a8006e1
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+@Module
+class CarModule {
+  @Provides
+  static Car provideConvertible(Convertible convertible) {
+    return convertible;
+  }
+}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarShop.java b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
new file mode 100644
index 000000000..e42532e9d
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Component;
+import org.atinject.tck.auto.Car;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(
+  modules = {
+    CarModule.class,
+    TireModule.class,
+    SeatModule.class,
+    EngineModule.class,
+    FuelTankModule.class
+  }
+)
+public interface CarShop {
+  @SuppressWarnings("dependency-cycle")
+  Car make();
+}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
new file mode 100644
index 000000000..61c100bae
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Engine;
+import org.atinject.tck.auto.V8Engine;
+
+@Module
+public class EngineModule {
+  @Provides
+  static Engine provideEngine(MembersInjector<V8Engine> injector) {
+    // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject
+    // constructor, however this is a TCK supplied class that we prefer to leave unmodified.
+    V8Engine engine = new V8Engine();
+    injector.injectMembers(engine);
+    return engine;
+  }
+}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
new file mode 100644
index 000000000..f412e664e
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.FuelTank;
+
+@Module
+class FuelTankModule {
+  @Provides
+  static FuelTank provideFuelTank() {
+    return new FuelTank();
+  }
+}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
new file mode 100644
index 000000000..b02f218bb
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Drivers;
+import org.atinject.tck.auto.DriversSeat;
+import org.atinject.tck.auto.Seat;
+
+@Module
+class SeatModule {
+  @Provides
+  @Drivers
+  static Seat provideSeat(DriversSeat seat) {
+    return seat;
+  }
+}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
new file mode 100644
index 000000000..f41852025
--- /dev/null
+++ b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Tire;
+import org.atinject.tck.auto.accessories.SpareTire;
+import javax.inject.Named;
+
+@Module
+class TireModule {
+  @Provides
+  @Named("spare")
+  static Tire provideTire(SpareTire sparetire) {
+    return sparetire;
+  }
+}
diff --git a/compiler/src/it/tck/src/test/java/test/tck/TckTest.java b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
new file mode 100644
index 000000000..d79b06b6a
--- /dev/null
+++ b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import junit.framework.Test;
+import org.atinject.tck.Tck;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+/** 
+ * Test suite to execute the JSR-330 TCK in JUnit.
+ */
+public class TckTest {
+  public static Test suite() {
+    CarShop carShopComponent = DaggerCarShop.create();
+    Car car = carShopComponent.make();
+    Convertible.localConvertible.set((Convertible) car);
+    return Tck.testsFor(car, false, false);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
deleted file mode 100644
index fd670f266..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with a component or production component
- * as part of the {@link ComponentProcessor}.
- */
-abstract class AbstractComponentProcessingStep implements ProcessingStep {
-
-  private final Messager messager;
-  private final BindingGraphValidator bindingGraphValidator;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
-
-  AbstractComponentProcessingStep(
-      Messager messager,
-      BindingGraphValidator bindingGraphValidator,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    this.messager = messager;
-    this.bindingGraphValidator = bindingGraphValidator;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
-  }
-
-  @Override
-  public final ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
-      try {
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
-        graphReport.printMessagesTo(messager);
-        if (graphReport.isClean()) {
-          try {
-            componentGenerator.generate(bindingGraph);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
-          }
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentDescriptor.componentDefinitionType());
-      }
-    }
-    return rejectedElements.build();
-  }
-
-  /**
-   * Returns a {@link ComponentDescriptor} for each valid component element for which an
-   * implementation class should be generated.
-   */
-  protected abstract Set<ComponentDescriptor> componentDescriptors(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
new file mode 100644
index 000000000..261e1b270
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -0,0 +1,1174 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.DelegateFactory;
+import dagger.internal.Factory;
+import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.ScopedProvider;
+import dagger.internal.SetFactory;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.internal.MapOfProducedProducer;
+import dagger.producers.internal.MapOfProducerProducer;
+import dagger.producers.internal.MapProducer;
+import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
+import static dagger.internal.codegen.MemberSelect.emptyMapProviderFactory;
+import static dagger.internal.codegen.MemberSelect.emptySetProvider;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
+import static dagger.internal.codegen.MemberSelect.staticMethod;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.writer.Snippet.nullCheck;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * Creates the implementation class for a component or subcomponent.
+ */
+abstract class AbstractComponentWriter {
+  // TODO(dpb): Make all these fields private after refactoring is complete.
+  protected final Elements elements;
+  protected final Types types;
+  protected final Key.Factory keyFactory;
+  protected final Kind nullableValidationType;
+  protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
+  protected final ClassName name;
+  protected final BindingGraph graph;
+  protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
+  private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
+  private final Map<Binding, InitializationState> contributionInitializationStates =
+      new HashMap<>();
+  protected ClassWriter componentWriter;
+  private final Map<BindingKey, MemberSelect> memberSelectSnippets = new HashMap<>();
+  private final Map<ContributionBinding, MemberSelect> multibindingContributionSnippets =
+      new HashMap<>();
+  protected ConstructorWriter constructorWriter;
+  protected Optional<ClassName> builderName = Optional.absent();
+
+  /**
+   * For each component requirement, the builder field. This map is empty for subcomponents that do
+   * not use a builder.
+   */
+  private ImmutableMap<TypeElement, FieldWriter> builderFields = ImmutableMap.of();
+
+  /**
+   * For each component requirement, the snippet for the component field that holds it.
+   *
+   * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
+   * any requirement that is reused from a subcomponent of this component.
+   */
+  protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+
+  AbstractComponentWriter(
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph,
+      ImmutableMap<ComponentDescriptor, String> subcomponentImplNames) {
+    this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.nullableValidationType = nullableValidationType;
+    this.name = name;
+    this.graph = graph;
+    this.subcomponentImplNames = subcomponentImplNames;
+  }
+
+  protected final TypeElement componentDefinitionType() {
+    return graph.componentDescriptor().componentDefinitionType();
+  }
+
+  protected final ClassName componentDefinitionTypeName() {
+    return ClassName.fromTypeElement(componentDefinitionType());
+  }
+
+  /**
+   * Returns an expression snippet that evaluates to an instance of the contribution, looking for
+   * either a builder field or a component field.
+   */
+  private Snippet getComponentContributionSnippet(TypeElement contributionType) {
+    if (builderFields.containsKey(contributionType)) {
+      return Snippet.format("builder.%s", builderFields.get(contributionType).name());
+    } else {
+      Optional<Snippet> snippet = getOrCreateComponentContributionFieldSnippet(contributionType);
+      checkState(snippet.isPresent(), "no builder or component field for %s", contributionType);
+      return snippet.get();
+    }
+  }
+
+  /**
+   * Returns a snippet for a component contribution field. Adds a field the first time one is
+   * requested for a contribution type if this component's builder has a field for it.
+   */
+  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+      TypeElement contributionType) {
+    MemberSelect fieldSelect = componentContributionFields.get(contributionType);
+    if (fieldSelect == null) {
+      if (!builderFields.containsKey(contributionType)) {
+        return Optional.absent();
+      }
+      FieldWriter componentField =
+          componentWriter.addField(contributionType, simpleVariableName(contributionType));
+      componentField.addModifiers(PRIVATE, FINAL);
+      constructorWriter
+          .body()
+          .addSnippet(
+              "this.%s = builder.%s;",
+              componentField.name(),
+              builderFields.get(contributionType).name());
+      fieldSelect = localField(name, componentField.name());
+      componentContributionFields.put(contributionType, fieldSelect);
+    }
+    return Optional.of(fieldSelect.getSnippetFor(name));
+  }
+
+  private Snippet getMemberSelectSnippet(BindingKey key) {
+    return getMemberSelect(key).getSnippetFor(name);
+  }
+
+  protected MemberSelect getMemberSelect(BindingKey key) {
+    return memberSelectSnippets.get(key);
+  }
+
+  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
+    return Optional.fromNullable(multibindingContributionSnippets.get(binding));
+  }
+
+  /**
+   * Returns the initialization state of the factory field for a binding key in this component.
+   */
+  protected InitializationState getInitializationState(BindingKey bindingKey) {
+    return initializationStates.containsKey(bindingKey)
+        ? initializationStates.get(bindingKey)
+        : UNINITIALIZED;
+  }
+
+  private void setInitializationState(BindingKey bindingKey, InitializationState state) {
+    initializationStates.put(bindingKey, state);
+  }
+
+  private InitializationState getContributionInitializationState(Binding binding) {
+    return contributionInitializationStates.containsKey(binding)
+        ? contributionInitializationStates.get(binding)
+        : UNINITIALIZED;
+  }
+
+  private void setContributionInitializationState(Binding binding, InitializationState state) {
+    contributionInitializationStates.put(binding, state);
+  }
+
+  ImmutableSet<JavaWriter> write() {
+    if (javaWriters.isEmpty()) {
+      writeComponent();
+    }
+    return ImmutableSet.copyOf(javaWriters);
+  }
+
+  private void writeComponent() {
+    componentWriter = createComponentClass();
+    addConstructor();
+    addBuilder();
+    addFactoryMethods();
+    addFields();
+    initializeFrameworkTypes();
+    implementInterfaceMethods();
+    addSubcomponents();
+  }
+
+  /**
+   * Creates the component implementation class.
+   */
+  protected abstract ClassWriter createComponentClass();
+
+  private void addConstructor() {
+    constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+  }
+
+  /**
+   * Adds a builder type.
+   */
+  protected void addBuilder() {
+    ClassWriter builderWriter = createBuilder();
+    builderWriter.addModifiers(FINAL);
+    builderWriter.addConstructor().addModifiers(PRIVATE);
+    builderName = Optional.of(builderWriter.name());
+
+    Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
+    if (builderSpec.isPresent()) {
+      builderWriter.addModifiers(PRIVATE);
+      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
+    } else {
+      builderWriter.addModifiers(PUBLIC);
+    }
+
+    builderFields = addBuilderFields(builderWriter);
+    addBuildMethod(builderWriter, builderSpec);
+    addBuilderMethods(builderWriter, builderSpec);
+
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+  }
+
+  /**
+   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
+   * requirements}. Regardless of builder spec, there is always one field per requirement.
+   */
+  private ImmutableMap<TypeElement, FieldWriter> addBuilderFields(ClassWriter builderWriter) {
+    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
+    for (TypeElement contributionElement : graph.componentRequirements()) {
+      String contributionName = simpleVariableName(contributionElement);
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
+      builderFieldsBuilder.put(contributionElement, builderField);
+    }
+    return builderFieldsBuilder.build();
+  }
+
+  /** Adds the build method to the builder. */
+  private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> builderSpec) {
+    MethodWriter buildMethod;
+    if (builderSpec.isPresent()) {
+      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+      // Note: we don't use the specBuildMethod.getReturnType() as the return type
+      // because it might be a type variable.  We make use of covariant returns to allow
+      // us to return the component type, which will always be valid.
+      buildMethod =
+          builderWriter.addMethod(
+              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
+      buildMethod.annotate(Override.class);
+    } else {
+      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
+    }
+    buildMethod.addModifiers(PUBLIC);
+
+    for (Map.Entry<TypeElement, FieldWriter> builderFieldEntry : builderFields.entrySet()) {
+      FieldWriter builderField = builderFieldEntry.getValue();
+      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
+        buildMethod.body()
+            .addSnippet("if (%1$s == null) { this.%1$s = new %2$s(); }",
+                builderField.name(),
+                builderField.type());
+      } else {
+        buildMethod.body()
+            .addSnippet(
+                "if (%s == null) { throw new %s(%s.class.getCanonicalName() + \" must be set\"); }",
+                builderField.name(),
+                ClassName.fromClass(IllegalStateException.class),
+                builderField.type());
+      }
+    }
+
+    buildMethod.body().addSnippet("return new %s(this);", name);
+  }
+
+  /**
+   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
+   * present, it will tailor the methods to match the spec.
+   */
+  private void addBuilderMethods(
+      ClassWriter builderWriter,
+      Optional<BuilderSpec> builderSpec) {
+    if (builderSpec.isPresent()) {
+      for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+          builderSpec.get().methodMap().entrySet()) {
+        TypeElement builderMethodType = builderMethodEntry.getKey();
+        ExecutableElement specMethod = builderMethodEntry.getValue();
+        MethodWriter builderMethod = addBuilderMethodFromSpec(builderWriter, specMethod);
+        String parameterName =
+            Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName().toString();
+        builderMethod.addParameter(builderMethodType, parameterName);
+        builderMethod.body().addSnippet(nullCheck(parameterName));
+        if (graph.componentRequirements().contains(builderMethodType)) {
+          // required type
+          builderMethod.body().addSnippet("this.%s = %s;",
+              builderFields.get(builderMethodType).name(),
+              parameterName);
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
+          // owned, but not required
+          builderMethod.body()
+              .addSnippet("// This module is declared, but not used in the component. "
+                  + "This method is a no-op");
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else {
+          // neither owned nor required, so it must be an inherited module
+          builderMethod
+              .body()
+              .addSnippet(
+                  "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
+                  ClassName.fromClass(UnsupportedOperationException.class),
+                  ClassName.fromClass(String.class),
+                  StringLiteral.forValue(
+                      "%s cannot be set because it is inherited from the enclosing component"),
+                  ClassName.fromTypeElement(builderMethodType));
+        }
+      }
+    } else {
+      for (TypeElement componentRequirement : graph.availableDependencies()) {
+        String componentRequirementName = simpleVariableName(componentRequirement);
+        MethodWriter builderMethod = builderWriter.addMethod(
+            builderWriter.name(),
+            componentRequirementName);
+        builderMethod.addModifiers(PUBLIC);
+        builderMethod.addParameter(componentRequirement, componentRequirementName);
+        builderMethod.body().addSnippet(nullCheck(componentRequirementName));
+        if (graph.componentRequirements().contains(componentRequirement)) {
+          builderMethod.body()
+              .addSnippet("this.%s = %s;",
+                  builderFields.get(componentRequirement).name(),
+                  componentRequirementName);
+        } else {
+          builderMethod.annotate(Deprecated.class);
+        }
+        builderMethod.body().addSnippet("return this;");
+      }
+    }
+  }
+
+  private void addBuilderMethodReturnStatementForSpec(
+      ExecutableElement specMethod, MethodWriter builderMethod) {
+    if (!specMethod.getReturnType().getKind().equals(VOID)) {
+      builderMethod.body().addSnippet("return this;");
+    }
+  }
+
+  private MethodWriter addBuilderMethodFromSpec(
+      ClassWriter builderWriter, ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+    TypeMirror returnType = method.getReturnType();
+    // If the return type is void, we add a method with the void return type.
+    // Otherwise we use the builderWriter and take advantage of covariant returns
+    // (so that we don't have to worry about setter methods that return type variables).
+    MethodWriter builderMethod =
+        returnType.getKind().equals(TypeKind.VOID)
+            ? builderWriter.addMethod(returnType, methodName)
+            : builderWriter.addMethod(builderWriter, methodName);
+    builderMethod.annotate(Override.class);
+    builderMethod.addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+    return builderMethod;
+  }
+
+  /**
+   * Creates the builder class.
+   */
+  protected abstract ClassWriter createBuilder();
+
+  /**
+   * Adds component factory methods.
+   */
+  protected abstract void addFactoryMethods();
+
+  private void addFields() {
+    for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
+      addField(resolvedBindings);
+    }
+  }
+
+  private void addField(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+
+    // If the binding can be satisfied with a static method call without dependencies or state,
+    // no field is necessary.
+    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
+    if (staticMemberSelect.isPresent()) {
+      memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
+      return;
+    }
+
+    // No field needed if there are no owned bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return;
+    }
+
+    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+    boolean useRawType = bindingPackage.isPresent()
+        && !bindingPackage.get().equals(name.packageName());
+    if (resolvedBindings.isMultibindings()) {
+      // note that here we rely on the order of the resolved bindings being from parent to child
+      // otherwise, the numbering wouldn't work
+      int contributionNumber = 0;
+      for (ContributionBinding contributionBinding : resolvedBindings.contributionBindings()) {
+        contributionNumber++;
+        if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
+          FrameworkField contributionBindingField =
+              FrameworkField.createForSyntheticContributionBinding(
+                  contributionNumber, contributionBinding);
+          FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
+
+          multibindingContributionSnippets.put(
+              contributionBinding,
+              localField(name, contributionField.name()));
+        }
+      }
+    }
+
+    FrameworkField bindingField = FrameworkField.createForResolvedBindings(resolvedBindings);
+    FieldWriter frameworkField = addFrameworkField(useRawType, bindingField);
+
+    memberSelectSnippets.put(
+        bindingKey,
+        localField(name, frameworkField.name()));
+  }
+
+  private FieldWriter addFrameworkField(boolean useRawType,
+      FrameworkField contributionBindingField) {
+    FieldWriter contributionField =
+        componentWriter.addField(
+            useRawType
+                ? contributionBindingField.frameworkType().type()
+                : contributionBindingField.frameworkType(),
+            contributionBindingField.name());
+    contributionField.addModifiers(PRIVATE);
+    if (useRawType) {
+      contributionField.annotate(SuppressWarnings.class).setValue("rawtypes");
+    }
+    return contributionField;
+  }
+
+  /**
+   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
+   * this method returns the static member select snippet that returns the factory or no-op members
+   * injector.
+   */
+  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        if (resolvedBindings.isMultibindings()
+            && resolvedBindings.contributionBindings().isEmpty()) {
+          switch (resolvedBindings.contributionType()) {
+            case MAP:
+              return Optional.of(emptyMapProviderFactory(
+                  MapType.from(resolvedBindings.key().type())));
+
+            case SET:
+              return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
+
+            case UNIQUE:
+            default:
+              throw new AssertionError("Multibindings must be map or set, not " + resolvedBindings);
+          }
+        }
+        if (resolvedBindings.contributionBindings().size() != 1) {
+          return Optional.absent();
+        }
+        ContributionBinding contributionBinding =
+            getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding.contributionType().isMultibinding()
+            || !contributionBinding.bindingType().equals(BindingType.PROVISION)) {
+          return Optional.absent();
+        }
+        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          return Optional.of(
+              staticMethod(
+                  generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            resolvedBindings.membersInjectionBinding();
+        if (membersInjectionBinding.isPresent()
+            && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
+          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+    return Optional.absent();
+  }
+
+  /**
+   * A static member select for a call to {@code F.create()} where {@code F} is either
+   * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
+   * set bindings.
+   */
+  private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
+    ClassName setFactoryClassName = setFactoryClassName(setBindings);
+    return emptySetProvider(setFactoryClassName,
+        SetType.from(setBindings.bindingKey().key().type()));
+  }
+
+  /**
+   * Returns a {@link Set} factory class name appropriate for the set bindings.
+   *
+   * <ul>
+   * <li>{@link SetFactory} for provision bindings.
+   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   * </ul>
+   */
+  private ClassName setFactoryClassName(ResolvedBindings setBindings) {
+    if (setBindings.bindingType().equals(BindingType.PROVISION)) {
+      return ClassName.fromClass(SetFactory.class);
+    } else {
+      SetType setType = SetType.from(setBindings.bindingKey().key().type());
+      return ClassName.fromClass(
+          setType.elementsAreTypeOf(Produced.class)
+              ? SetOfProducedProducer.class
+              : SetProducer.class);
+    }
+  }
+
+  private void implementInterfaceMethods() {
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+    for (ComponentMethodDescriptor componentMethod :
+        graph.componentDescriptor().componentMethods()) {
+      if (componentMethod.dependencyRequest().isPresent()) {
+        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+        ExecutableElement requestElement =
+            MoreElements.asExecutable(interfaceRequest.requestElement());
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
+        MethodSignature signature = MethodSignature.fromExecutableType(
+            requestElement.getSimpleName().toString(), requestType);
+        if (!interfaceMethods.contains(signature)) {
+          interfaceMethods.add(signature);
+          MethodWriter interfaceMethod =
+              requestType.getReturnType().getKind().equals(VOID)
+                  ? componentWriter.addMethod(
+                      VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(
+                      requestType.getReturnType(), requestElement.getSimpleName().toString());
+          interfaceMethod.annotate(Override.class);
+          interfaceMethod.addModifiers(PUBLIC);
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          MemberSelect memberSelect = getMemberSelect(bindingKey);
+          Snippet memberSelectSnippet = memberSelect.getSnippetFor(name);
+          switch (interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.body().addSnippet("return %s;", memberSelectSnippet);
+              } else {
+                VariableElement parameter = Iterables.getOnlyElement(parameters);
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(
+                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod
+                    .body()
+                    .addSnippet(
+                        "%s.injectMembers(%s);",
+                        memberSelectSnippet,
+                        parameterName);
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+              }
+              break;
+            case INSTANCE:
+              if (memberSelect.staticMember()
+                  && bindingKey.key().type().getKind().equals(DECLARED)
+                  && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty()) {
+                // If using a parameterized enum type, then we need to store the factory
+                // in a temporary variable, in order to help javac be able to infer
+                // the generics of the Factory.create methods.
+                TypeName factoryType =
+                    ParameterizedTypeName.create(
+                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
+                interfaceMethod
+                    .body()
+                    .addSnippet(
+                        "%s factory = %s;", factoryType, memberSelectSnippet);
+                interfaceMethod.body().addSnippet("return factory.get();");
+                break;
+              }
+              // fall through in the else case.
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case FUTURE:
+              interfaceMethod
+                  .body()
+                  .addSnippet(
+                      "return %s;",
+                      frameworkTypeUsageStatement(
+                          memberSelectSnippet, interfaceRequest.kind()));
+              break;
+            default:
+              throw new AssertionError();
+          }
+        }
+      }
+    }
+  }
+
+  private void addSubcomponents() {
+    for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+      SubcomponentWriter subcomponent =
+          new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
+      javaWriters.addAll(subcomponent.write());
+    }
+  }
+
+  private static final int SNIPPETS_PER_INITIALIZATION_METHOD = 100;
+
+  private void initializeFrameworkTypes() {
+    ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
+    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
+      snippetsBuilder.addAll(initializeFrameworkType(bindingKey).asSet());
+    }
+    ImmutableList<Snippet> snippets = snippetsBuilder.build();
+
+    List<List<Snippet>> partitions = Lists.partition(snippets, SNIPPETS_PER_INITIALIZATION_METHOD);
+    for (int i = 0; i < partitions.size(); i++) {
+      MethodWriter initializeMethod =
+          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
+      /* TODO(gak): Strictly speaking, we only need the suppression here if we are also initializing
+       * a raw field in this method, but the structure of this code makes it awkward to pass that
+       * bit through.  This will be cleaned up when we no longer separate fields and initilization
+       * as we do now. */
+      initializeMethod.annotate(SuppressWarnings.class).setValue("unchecked");
+      for (Snippet snippet : partitions.get(i)) {
+        initializeMethod.body().addSnippet(snippet);
+      }
+      initializeMethod.addModifiers(PRIVATE);
+      if (builderName.isPresent()) {
+        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
+        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
+      } else {
+        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
+      }
+    }
+  }
+
+  /**
+   * Returns a single snippet representing the initialization of the framework type.
+   *
+   * <p>Note that this must be a single snippet because initialization snippets can be invoked from
+   * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
+   * ensure that things like local variables always behave as expected by the initialization logic.
+   */
+  private Optional<Snippet> initializeFrameworkType(BindingKey bindingKey) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+
+    // There's no field for inherited bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return Optional.absent();
+    }
+
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        switch (resolvedBindings.contributionType()) {
+          case SET:
+            return Optional.of(initializeSetMultibindings(resolvedBindings));
+          case MAP:
+            return Optional.of(initializeMapMultibindings(resolvedBindings));
+          case UNIQUE:
+            return initializeUniqueContributionBinding(resolvedBindings);
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return initializeMembersInjectionBinding(resolvedBindings);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
+      Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
+      if (multibindingContributionSnippet.get().owningClass().equals(name)
+          // the binding might already be initialized by a different set binding that shares the
+          // same contributions (e.g., Set<T> and Set<Produced<T>>)
+          && getContributionInitializationState(binding)
+              .equals(InitializationState.UNINITIALIZED)) {
+        Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
+        initializationSnippets.add(Snippet.format("this.%s = %s;", snippet, initializeSnippet));
+        setContributionInitializationState(binding, InitializationState.INITIALIZED);
+      }
+      parameterSnippets.add(snippet);
+    }
+    Snippet initializeSetSnippet =
+        Snippet.format(
+            "%s.create(%s)",
+            setFactoryClassName(resolvedBindings),
+            makeParametersSnippet(parameterSnippets.build()));
+    initializationSnippets.add(
+        initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      if (multibindingContributionSnippet.isPresent()
+          && multibindingContributionSnippet.get().owningClass().equals(name)) {
+        initializationSnippets.add(
+            Snippet.format(
+                "this.%s = %s;",
+                multibindingContributionSnippet.get().getSnippetFor(name),
+                initializeFactoryForContributionBinding(binding)));
+      }
+    }
+    initializationSnippets.add(
+        initializeMember(resolvedBindings.bindingKey(), initializeMapBinding(resolvedBindings)));
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Optional<Snippet> initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
+    ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+    if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
+      return Optional.absent();
+    }
+
+    return Optional.of(
+        Snippet.concat(
+            ImmutableList.of(
+                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeMember(
+                    resolvedBindings.bindingKey(),
+                    initializeFactoryForContributionBinding(binding)))));
+  }
+
+  private Optional<Snippet> initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
+    MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
+    if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+      return Optional.absent();
+    }
+
+    return Optional.of(
+        Snippet.concat(
+            ImmutableList.of(
+                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeMember(
+                    resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)))));
+  }
+
+  /**
+   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
+   * because of a dependency cycle.
+   */
+  private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    for (BindingKey dependencyKey :
+        FluentIterable.from(binding.implicitDependencies())
+            .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+            .toSet()) {
+      if (!getMemberSelect(dependencyKey).staticMember()
+          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+        initializationSnippets.add(
+            Snippet.format(
+                "this.%s = new %s();",
+                getMemberSelectSnippet(dependencyKey),
+                ClassName.fromClass(DelegateFactory.class)));
+        setInitializationState(dependencyKey, DELEGATED);
+      }
+    }
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeMember(BindingKey bindingKey, Snippet initializationSnippet) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    Snippet memberSelect = getMemberSelectSnippet(bindingKey);
+    Snippet delegateFactoryVariable = delegateFactoryVariableSnippet(bindingKey);
+    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+      initializationSnippets.add(
+          Snippet.format(
+              "%1$s %2$s = (%1$s) %3$s;",
+              ClassName.fromClass(DelegateFactory.class),
+              delegateFactoryVariable,
+              memberSelect));
+    }
+    initializationSnippets.add(
+        Snippet.format("this.%s = %s;", memberSelect, initializationSnippet));
+    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+      initializationSnippets.add(
+          Snippet.format("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect));
+    }
+    setInitializationState(bindingKey, INITIALIZED);
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet delegateFactoryVariableSnippet(BindingKey key) {
+    return Snippet.format("%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+  }
+
+  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeNames.forTypeMirror(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        return Snippet.format(
+            "%s.<%s>create(%s)",
+            ClassName.fromClass(InstanceFactory.class),
+            bindingKeyTypeName,
+            bindingKeyTypeName.equals(componentDefinitionTypeName())
+                ? "this"
+                : getComponentContributionSnippet(MoreTypes.asTypeElement(binding.key().type())));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          String localFactoryVariable = simpleVariableName(bindingTypeElement);
+          Snippet callFactoryMethodSnippet =
+              Snippet.format(
+                  "%s.%s()",
+                  localFactoryVariable,
+                  binding.bindingElement().getSimpleName().toString());
+          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          StringLiteral failMsg =
+              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          Snippet getMethodBody =
+              binding.nullableType().isPresent()
+                      || nullableValidationType.equals(Diagnostic.Kind.WARNING)
+                  ? Snippet.format("return %s;", callFactoryMethodSnippet)
+                  : Snippet.format(
+                      Joiner.on('\n')
+                          .join(
+                              "%s provided = %s;",
+                              "if (provided == null) {",
+                              "  throw new NullPointerException(%s);",
+                              "}",
+                              "return provided;"),
+                      bindingKeyTypeName,
+                      callFactoryMethodSnippet,
+                      failMsg);
+          return Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  private final %5$s %6$s = %3$s;",
+                      "  %4$s@Override public %2$s get() {",
+                      "    %7$s",
+                      "  }",
+                      "}"),
+              /* 1 */ ClassName.fromClass(Factory.class),
+              /* 2 */ bindingKeyTypeName,
+              /* 3 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 4 */ nullableSnippet(binding.nullableType()),
+              /* 5 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 6 */ localFactoryVariable,
+              /* 7 */ getMethodBody);
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        return Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "new %1$s<%2$s>() {",
+                    "  @Override public %2$s get() {",
+                    "    return %3$s();",
+                    "  }",
+                    "}"),
+            /* 1 */ ClassName.fromClass(Factory.class),
+            /* 2 */ bindingKeyTypeName,
+            /* 3 */ binding.bindingElement().getSimpleName().toString());
+
+      case INJECTION:
+      case PROVISION:
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+          if (binding.bindingKind().equals(PROVISION)
+              && !binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+          }
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER));
+
+          Snippet factorySnippet =
+              Snippet.format(
+                  "%s.create(%s)",
+                  generatedClassNameForBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+          return binding.scope().isPresent()
+              ? Snippet.format(
+                  "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
+              : factorySnippet;
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          return Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  private final %6$s %7$s = %4$s;",
+                      "  @Override public %3$s<%2$s> get() {",
+                      "    return %7$s.%5$s();",
+                      "  }",
+                      "}"),
+              /* 1 */ ClassName.fromClass(Producer.class),
+              /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
+              /* 3 */ ClassName.fromClass(ListenableFuture.class),
+              /* 4 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 5 */ binding.bindingElement().getSimpleName().toString(),
+              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 7 */ simpleVariableName(bindingTypeElement));
+        }
+
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
+          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+          }
+          parameters.add(
+              getComponentContributionSnippet(
+                  graph.componentDescriptor().executorDependency().get()));
+          parameters.addAll(
+              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PRODUCER));
+
+          return Snippet.format(
+              "new %s(%s)",
+              generatedClassNameForBinding(binding),
+              Snippet.makeParametersSnippet(parameters));
+        }
+
+      case SYNTHETIC_MAP:
+        checkState(
+            MapType.isMap(binding.key().type()),
+            "Expected synthetic binding to be for a map: %s",
+            binding);
+        final ClassName contributionClassName;
+        switch (binding.bindingType()) {
+          case PRODUCTION:
+            if (MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)) {
+              contributionClassName = ClassName.fromClass(MapOfProducedProducer.class);
+            } else {
+              contributionClassName = ClassName.fromClass(MapProducer.class);
+            }
+            break;
+          case PROVISION:
+            contributionClassName = ClassName.fromClass(MapFactory.class);
+            break;
+          default:
+            throw new AssertionError();
+        }
+        return Snippet.format(
+            "%s.create(%s)",
+            contributionClassName,
+            getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
+                .getSnippetFor(name));
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet nullableSnippet(Optional<DeclaredType> nullableType) {
+    return nullableType.isPresent()
+        ? Snippet.format("@%s ", TypeNames.forTypeMirror(nullableType.get()))
+        : Snippet.format("");
+  }
+
+  private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
+      case INJECT_MEMBERS:
+        List<Snippet> parameters =
+            getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER);
+        return Snippet.format(
+            "%s.create(%s)",
+            membersInjectorNameForType(binding.bindingElement()),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * The snippets that represent factory arguments for the dependencies of a binding.
+   */
+  private List<Snippet> getDependencyParameterSnippets(
+      Binding binding, DependencyRequestMapper dependencyRequestMapper) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> dependencyRequestsForUnresolvedKey :
+        indexDependenciesByUnresolvedKey(binding).asMap().values()) {
+      BindingKey requestedKey =
+          Iterables.getOnlyElement(
+              FluentIterable.from(dependencyRequestsForUnresolvedKey)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .toSet());
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetFor(name);
+      if (resolvedBindings.frameworkClass().equals(Provider.class)
+          && dependencyRequestMapper
+              .getFrameworkClass(dependencyRequestsForUnresolvedKey)
+              .equals(Producer.class)) {
+        parameters.add(
+            Snippet.format(
+                "%s.producerFromProvider(%s)",
+                ClassName.fromClass(Producers.class),
+                frameworkSnippet));
+      } else {
+        parameters.add(frameworkSnippet);
+      }
+    }
+    return parameters.build();
+  }
+
+  private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
+    MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
+    boolean hasProductionContribution =
+        Iterables.any(
+            resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION));
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    snippets.add(
+        Snippet.format(
+            "%s.<%s, %s>builder(%d)",
+            ClassName.fromClass(
+                hasProductionContribution ? MapOfProducerProducer.class : MapProviderFactory.class),
+            TypeNames.forTypeMirror(mapType.keyType()),
+            TypeNames.forTypeMirror(
+                mapType.unwrappedValueType(
+                    hasProductionContribution ? Producer.class : Provider.class)),
+            resolvedBindings.contributionBindings().size()));
+
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      snippets.add(
+          Snippet.format(
+              "    .put(%s, %s)",
+              getMapKeySnippet(binding.bindingElement()),
+              getMultibindingContributionSnippet(binding).get().getSnippetFor(name)));
+    }
+
+    snippets.add(Snippet.format("    .build()"));
+
+    return Snippet.concat(snippets.build());
+  }
+
+  private static String simpleVariableName(TypeElement typeElement) {
+    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+  }
+
+  /**
+   * Initialization state for a factory field.
+   */
+  enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /** The field is set to a {@link DelegateFactory}. */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
new file mode 100644
index 000000000..d8c5d2369
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.auto.common.MoreElements.getPackage;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Utility methods for determining whether a {@linkplain TypeMirror type} or an {@linkplain Element
+ * element} is accessible given the rules outlined in
+ * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.6">section 6.6 of the
+ * Java Language Specification</a>.
+ *
+ * <p>This class only provides an approximation for accessibility.  It does not always yield the
+ * same result as the compiler, but will always err on the side of declaring something inaccessible.
+ * This ensures that using this class will never result in generating code that will not compile.
+ *
+ * <p>Whenever compiler independence is not a requirement, the compiler-specific implementation of
+ * this functionality should be preferred.  For example,
+ * {@link com.sun.source.util.Trees#isAccessible(com.sun.source.tree.Scope, TypeElement)} would be
+ * preferable for {@code javac}.
+ */
+final class Accessibility {
+  /**
+   * Returns true if the given type can be referenced from code in the given package.
+   */
+  static boolean isTypeAccessibleFrom(TypeMirror type, String packageName) {
+    return type.accept(new TypeAccessiblityVisitor(packageName), null);
+  }
+
+  private static final class TypeAccessiblityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
+    final String packageName;
+
+    TypeAccessiblityVisitor(String packageName) {
+      this.packageName = packageName;
+    }
+
+    boolean isAccessible(TypeMirror type) {
+      return type.accept(this, null);
+    }
+
+    @Override
+    public Boolean visitNoType(NoType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitDeclared(DeclaredType type, Void p) {
+      if (!isAccessible(type.getEnclosingType())) {
+        // TODO(gak): investigate this check.  see comment in Binding
+        return false;
+      }
+      if (!isElementAccessibleFrom(type.asElement(), packageName)) {
+        return false;
+      }
+      for (TypeMirror typeArgument : type.getTypeArguments()) {
+        if (!isAccessible(typeArgument)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    @Override
+    public Boolean visitArray(ArrayType type, Void p) {
+      return type.getComponentType().accept(this, null);
+    }
+
+    @Override
+    public Boolean visitPrimitive(PrimitiveType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitNull(NullType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitTypeVariable(TypeVariable type, Void p) {
+      // a _reference_ to a type variable is always accessible
+      return true;
+    }
+
+    @Override
+    public Boolean visitWildcard(WildcardType type, Void p) {
+      if (type.getExtendsBound() != null && !isAccessible(type.getExtendsBound())) {
+        return false;
+      }
+      if (type.getSuperBound() != null && !isAccessible(type.getSuperBound())) {
+        return false;
+      }
+      return true;
+    }
+
+    @Override
+    protected Boolean defaultAction(TypeMirror type, Void p) {
+      throw new IllegalArgumentException(String.format(
+          "%s of kind %s should not be checked for accessibility", type, type.getKind()));
+    }
+  }
+
+  /**
+   * Returns true if the given element can be referenced from code in the given package.
+   */
+  //TODO(gak): account for protected
+  static boolean isElementAccessibleFrom(Element element, final String packageName) {
+    return element.accept(new ElementAccessibilityVisitor(packageName), null);
+  }
+
+  private static final class ElementAccessibilityVisitor
+      extends SimpleElementVisitor6<Boolean, Void> {
+    final String packageName;
+
+    ElementAccessibilityVisitor(String packageName) {
+      this.packageName = packageName;
+    }
+
+    @Override
+    public Boolean visitPackage(PackageElement element, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitType(TypeElement element, Void p) {
+      switch (element.getNestingKind()) {
+        case MEMBER:
+          return accessibleMember(element);
+        case TOP_LEVEL:
+          return accessibleModifiers(element);
+        case ANONYMOUS:
+        case LOCAL:
+          return false;
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    boolean accessibleMember(Element element) {
+      if (!element.getEnclosingElement().accept(this, null)) {
+        return false;
+      }
+      return accessibleModifiers(element);
+    }
+
+    boolean accessibleModifiers(Element element) {
+      if (element.getModifiers().contains(PUBLIC)) {
+        return true;
+      } else if (element.getModifiers().contains(PRIVATE)) {
+        return false;
+      } else if (getPackage(element).getQualifiedName().contentEquals(packageName)) {
+        return true;
+      } else {
+        return false;
+      }
+    }
+
+    @Override
+    public Boolean visitTypeParameter(TypeParameterElement element, Void p) {
+      throw new IllegalArgumentException(
+          "It does not make sense to check the accessibility of a type parameter");
+    }
+
+    @Override
+    public Boolean visitExecutable(ExecutableElement element, Void p) {
+      return accessibleMember(element);
+    }
+
+    @Override
+    public Boolean visitVariable(VariableElement element, Void p) {
+      ElementKind kind = element.getKind();
+      checkArgument(kind.isField(), "checking a variable that isn't a field: %s", kind);
+      return accessibleMember(element);
+    }
+  }
+
+  private Accessibility() {}
+}
+
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
new file mode 100644
index 000000000..d4772f3a5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import dagger.Provides;
+
+final class AnnotationSpecs {
+
+  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
+  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
+
+  private static AnnotationSpec suppressWarnings(String value) {
+    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
+  }
+
+  static final AnnotationSpec PROVIDES_SET_VALUES =
+      AnnotationSpec.builder(Provides.class)
+          .addMember("type", "$T.SET_VALUES", ClassName.get(Provides.Type.class))
+          .build();
+
+  private AnnotationSpecs() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index edb8ad6b3..26d3b61d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -20,6 +20,9 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -31,7 +34,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -46,42 +48,27 @@
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class Binding {
-  static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
-    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
-    for (Binding binding : bindings) {
-      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
-    }
-    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
-    switch (bindingPackages.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.of(bindingPackages.iterator().next());
-      default:
-        throw new IllegalArgumentException();
-    }
+abstract class Binding implements HasBindingType, HasKey, HasSourceElement {
+
+  /**
+   * Returns the framework class associated with this binding.
+   */
+  Class<?> frameworkClass() {
+    return bindingType().frameworkClass();
   }
 
   /** The {@link Key} that is provided by this binding. */
-  protected abstract Key key();
+  @Override
+  public abstract Key key();
 
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
-  abstract Element bindingElement();
+  Element bindingElement() {
+    return sourceElement().element();
+  }
 
   /** The type enclosing the binding {@link #bindingElement()}. */
   TypeElement bindingTypeElement() {
-    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override
-      protected TypeElement defaultAction(Element e, Void p) {
-        return MoreElements.asType(bindingElement().getEnclosingElement());
-      }
-
-      @Override
-      public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-    }, null);
+    return sourceElement().enclosingTypeElement();
   }
 
   /**
@@ -155,10 +142,18 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   }
 
   /**
-   * Returns true if this is a binding for a key that has a different type parameter list than the
-   * element it's providing.
+   * if this binding's key's type parameters are different from those of the
+   * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
+   * unresolved type.
    */
-  abstract boolean hasNonDefaultTypeParameters();
+  abstract Optional<? extends Binding> unresolved();
+
+  /**
+   * The scope of this binding.
+   */
+  Scope scope() {
+    return Scope.unscoped();
+  }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
   static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
@@ -166,25 +161,27 @@ static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type,
     if (element.getTypeParameters().isEmpty()) {
       return false;
     }
-    
+
     List<TypeMirror> defaultTypes = Lists.newArrayList();
     for (TypeParameterElement parameter : element.getTypeParameters()) {
       defaultTypes.add(parameter.asType());
     }
-    
+
     List<TypeMirror> actualTypes =
-        type.accept(new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
-          @Override
-          protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
-            return ImmutableList.of();
-          }
-
-          @Override
-          public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
-            return ImmutableList.copyOf(t.getTypeArguments());
-          }
-        }, null);
-    
+        type.accept(
+            new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
+              @Override
+              protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
+                return ImmutableList.of();
+              }
+
+              @Override
+              public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
+                return ImmutableList.<TypeMirror>copyOf(t.getTypeArguments());
+              }
+            },
+            null);
+
     // The actual type parameter size can be different if the user is using a raw type.
     if (defaultTypes.size() != actualTypes.size()) {
       return true;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 68da53502..f7ed3ac77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,26 +17,37 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.TreeTraverser;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -44,12 +55,18 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Key.indexByKey;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -62,61 +79,121 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
+  /**
+   * Returns the set of modules that are owned by this graph regardless of whether or not any of
+   * their bindings are used in this graph. For graphs representing top-level {@link Component
+   * components}, this set will be the same as
+   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
+   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
+   * owned by any of their ancestors.
+   */
+  abstract ImmutableSet<ModuleDescriptor> ownedModules();
+
+  ImmutableSet<TypeElement> ownedModuleTypes() {
+    return FluentIterable.from(ownedModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
+  private static final TreeTraverser<BindingGraph> SUBGRAPH_TRAVERSER =
+      new TreeTraverser<BindingGraph>() {
+        @Override
+        public Iterable<BindingGraph> children(BindingGraph node) {
+          return node.subgraphs().values();
+        }
+      };
+
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
    * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
    * {@link ProductionComponent}.
    */
   ImmutableSet<TypeElement> componentRequirements() {
-    return FluentIterable.from(componentDescriptor().transitiveModules())
-        .transform(new Function<ModuleDescriptor, TypeElement>() {
-          @Override public TypeElement apply(ModuleDescriptor input) {
-            return input.moduleElement();
-          }
-        })
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transformAndConcat(
+            new Function<BindingGraph, Iterable<ResolvedBindings>>() {
+              @Override
+              public Iterable<ResolvedBindings> apply(BindingGraph input) {
+                return input.resolvedBindings().values();
+              }
+            })
+        .transformAndConcat(
+            new Function<ResolvedBindings, Set<ContributionBinding>>() {
+              @Override
+              public Set<ContributionBinding> apply(ResolvedBindings input) {
+                return input.contributionBindings();
+              }
+            })
+        .transformAndConcat(
+            new Function<ContributionBinding, Set<TypeElement>>() {
+              @Override
+              public Set<TypeElement> apply(ContributionBinding input) {
+                return input.bindingElement().getModifiers().contains(STATIC)
+                    ? ImmutableSet.<TypeElement>of()
+                    : input.contributedBy().asSet();
+              }
+            })
+        .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .append(componentDescriptor().executorDependency().asSet())
         .toSet();
   }
 
+  /**
+   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
+   */
+  ImmutableSet<ComponentDescriptor> componentDescriptors() {
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transform(
+            new Function<BindingGraph, ComponentDescriptor>() {
+              @Override
+              public ComponentDescriptor apply(BindingGraph graph) {
+                return graph.componentDescriptor();
+              }
+            })
+        .toSet();
+  }
+
+  ImmutableSet<TypeElement> availableDependencies() {
+    return new ImmutableSet.Builder<TypeElement>()
+        .addAll(componentDescriptor().transitiveModuleTypes())
+        .addAll(componentDescriptor().dependencies())
+        .addAll(componentDescriptor().executorDependency().asSet())
+        .build();
+  }
+
   static final class Factory {
     private final Elements elements;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+      return create(Optional.<Resolver>absent(), componentDescriptor);
     }
 
-    private BindingGraph create(Optional<RequestResolver> parentResolver,
-        ComponentDescriptor componentDescriptor) {
-      ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
-          ImmutableSet.builder();
+    private BindingGraph create(
+        Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
-      ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDefinitionType);
-      explicitProvisionBindingsBuilder.add(componentBinding);
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
@@ -126,42 +203,47 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
           : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
-        explicitProvisionBindingsBuilder.add(
-            provisionBindingFactory.forComponent(componentDependency));
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
           // MembersInjection methods aren't "provided" explicitly, so ignore them.
           if (isComponentContributionMethod(elements, method)) {
-            if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
-                && isComponentProductionMethod(elements, method)) {
-              explicitProductionBindingsBuilder.add(
-                  productionBindingFactory.forComponentMethod(method));
-            } else {
-              explicitProvisionBindingsBuilder.add(
-                  provisionBindingFactory.forComponentMethod(method));
-            }
+            explicitBindingsBuilder.add(
+                componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+                        && isComponentProductionMethod(elements, method)
+                    ? productionBindingFactory.forComponentMethod(method)
+                    : provisionBindingFactory.forComponentMethod(method));
           }
         }
       }
 
-      // Collect transitive module bindings.
+      // Bindings for subcomponent builders.
+      for (ComponentMethodDescriptor subcomponentMethodDescriptor :
+          Iterables.filter(
+              componentDescriptor.subcomponents().keySet(),
+              isOfKind(SUBCOMPONENT_BUILDER, PRODUCTION_SUBCOMPONENT_BUILDER))) {
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forSubcomponentBuilderMethod(
+                subcomponentMethodDescriptor.methodElement(),
+                componentDescriptor.componentDefinitionType()));
+      }
+
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      // Collect transitive module bindings and multibinding declarations.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
-        for (ContributionBinding binding : moduleDescriptor.bindings()) {
-          if (binding instanceof ProvisionBinding) {
-            explicitProvisionBindingsBuilder.add((ProvisionBinding) binding);
-          }
-          if (binding instanceof ProductionBinding) {
-            explicitProductionBindingsBuilder.add((ProductionBinding) binding);
-          }
-        }
+        explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
+        multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
       }
 
-      RequestResolver requestResolver = new RequestResolver(
-          parentResolver,
-          componentDescriptor.wrappedScope(),
-          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
-          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      Resolver requestResolver =
+          new Resolver(
+              parentResolver,
+              componentDescriptor,
+              indexByKey(explicitBindingsBuilder.build()),
+              indexByKey(multibindingDeclarations.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -171,181 +253,228 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
           ImmutableMap.builder();
-      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
           componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(subcomponentEntry.getKey(),
+        subgraphsBuilder.put(
+            subcomponentEntry.getKey().methodElement(),
             create(Optional.of(requestResolver), subcomponentEntry.getValue()));
       }
 
+      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
+        verify(
+            resolvedBindings.owningComponent().equals(componentDescriptor),
+            "%s is not owned by %s",
+            resolvedBindings,
+            componentDescriptor);
+      }
+
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build());
-    }
-
-    private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
-        Iterable<? extends B> bindings) {
-      // Multimaps.index() doesn't do ImmutableSetMultimaps.
-      ImmutableSetMultimap.Builder<Key, B> builder = ImmutableSetMultimap.builder();
-      for (B binding : bindings) {
-        builder.put(binding.key(), binding);
-      }
-      return builder.build();
+          subgraphsBuilder.build(),
+          requestResolver.getOwnedModules());
     }
 
-    private final class RequestResolver {
-      final Optional<RequestResolver> parentResolver;
-      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
-      final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
-      final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
+    private final class Resolver {
+      final Optional<Resolver> parentResolver;
+      final ComponentDescriptor componentDescriptor;
+      final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
+      final ImmutableSet<ContributionBinding> explicitBindingsSet;
+      final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
-
-      RequestResolver(Optional<RequestResolver> parentResolver,
-          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
-          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
-          ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+      final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
+          CacheBuilder.newBuilder().<BindingKey, Boolean>build();
+      final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
+          CacheBuilder.newBuilder().<Binding, Boolean>build();
+
+      Resolver(
+          Optional<Resolver> parentResolver,
+          ComponentDescriptor componentDescriptor,
+          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
+          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
-        assert targetScope != null;
-        this.targetScope = targetScope;
-        assert explicitProvisionBindings != null;
-        this.explicitProvisionBindings = explicitProvisionBindings;
-        assert explicitProductionBindings != null;
-        this.explicitProductionBindings = explicitProductionBindings;
+        assert componentDescriptor != null;
+        this.componentDescriptor = componentDescriptor;
+        assert explicitBindings != null;
+        this.explicitBindings = explicitBindings;
+        this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
+        assert multibindingDeclarations != null;
+        this.multibindingDeclarations = multibindingDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
       /**
-       *  Looks up the bindings associated with a given dependency request and returns them.  In the
-       *  event that the binding is owned by a parent component it will trigger resolution in that
-       *  component's resolver but will return an {@link Optional#absent} value.
+       * Returns the bindings that satisfy a given dependency request.
+       *
+       * <p>For {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:
+       * <ul>
+       * <li>All explicit bindings for the requested key.
+       * <li>All explicit bindings for {@code Set<T>} if the requested key's type is
+       *     {@code Set<Produced<T>>}.
+       * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
+       *     type is {@code Map<K, V>} and there are some explicit bindings for
+       *     {@code Map<K, Producer<V>>}.
+       * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
+       *     type is {@code Map<K, V>} and there are some explicit bindings for
+       *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
+       * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
+       *     there are no explicit bindings or synthetic bindings.
+       * </ul>
+       *
+       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the
+       * {@link MembersInjectionBinding} for the type.
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            // First, check for explicit keys (those from modules and components)
-            ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
-                getExplicitProvisionBindings(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
-                getExplicitProductionBindings(bindingKey.key());
-
-            // If the key is Map<K, V>, get its implicit binding keys, which are either
-            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
-            Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-            ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
-            if (mapProviderKey.isPresent()) {
-              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
+            Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
+            ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
+                ImmutableSet.builder();
+
+            // Add explicit bindings and declarations (those from modules and components).
+            contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
+
+            // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
+            // Set<T>.
+            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            contributionBindings.addAll(getExplicitBindings(implicitSetKey));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
+
+            ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
+                multibindingDeclarationsBuilder.build();
+
+            // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
+            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
+            // declarations.
+            Optional<Key> implicitMapProviderKey =
+                keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitProviderMapBindings =
+                getExplicitBindings(implicitMapProviderKey);
+            ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProviderKey);
+
+            Optional<Key> implicitMapProducerKey =
+                keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitProducerMapBindings =
+                getExplicitBindings(implicitMapProducerKey);
+            ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProducerKey);
+
+            if (!explicitProducerMapBindings.isEmpty()
+                || !explicitProducerMultibindingDeclarations.isEmpty()) {
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
+               * bindings or multibinding declarations, then add the synthetic binding that depends
+               * on Map<K, Producer<V>>. */
+              contributionBindings.add(
+                  productionBindingFactory.implicitMapOfProducerBinding(request));
+            } else if (!explicitProviderMapBindings.isEmpty()
+                || !explicitProviderMultibindingDeclarations.isEmpty()) {
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
+               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
+               * or multibinding declarations, then add the synthetic binding that depends on
+               * Map<K, Provider<V>>. */
+              contributionBindings.add(
+                  provisionBindingFactory.implicitMapOfProviderBinding(request));
             }
 
-            Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
-            if (mapProducerKey.isPresent()) {
-              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
+            /* If there are no explicit or synthetic bindings or multibinding declarations, use an
+             * implicit @Inject- constructed binding if there is one. */
+            if (contributionBindings.isEmpty() && multibindingDeclarations.isEmpty()) {
+              contributionBindings.addAll(
+                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
             }
 
-            if (!explicitProvisionBindingsForKey.isEmpty()
-                || !explicitProductionBindingsForKey.isEmpty()) {
-              // we have some explicit binding for this key, so we collect all explicit implicit map
-              // bindings that might conflict with this and let the validator sort it out
-              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
-              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
-              for (ProvisionBinding provisionBinding :
-                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
-                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
-                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                  owningResolver.get().resolve(request);
-                  inheritedBindings.add(provisionBinding);
-                } else {
-                  ownedBindings.add(provisionBinding);
-                }
-              }
-              return ResolvedBindings.create(bindingKey,
-                  ownedBindings
-                      .addAll(explicitProductionBindingsForKey)
-                      .addAll(explicitMapProductionBindings)
-                      .build(),
-                  inheritedBindings.build());
-            } else {
-              if (!explicitMapProductionBindings.isEmpty()) {
-                // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
-                // must be considered an implicit ProductionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return ResolvedBindings.create(bindingKey,
-                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
-              } else if (!explicitMapProvisionBindings.isEmpty()) {
-                // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
-                // ProvisionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ResolvedBindings.create(bindingKey,
-                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
-              } else {
-                // no explicit binding, look it up.
-                Optional<ProvisionBinding> provisionBinding =
-                    injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-                if (provisionBinding.isPresent()) {
-                  Optional<RequestResolver> owningResolver =
-                      getOwningResolver(provisionBinding.get());
-                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                    owningResolver.get().resolve(request);
-                    return ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(),
-                        provisionBinding.asSet());
-                  }
-                }
-                return ResolvedBindings.create(
-                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
-              }
-            }
+            return ResolvedBindings.forContributionBindings(
+                bindingKey,
+                componentDescriptor,
+                indexBindingsByOwningComponent(request, ImmutableSet.copyOf(contributionBindings)),
+                multibindingDeclarations);
+
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            return ResolvedBindings.create(
-                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
+            Optional<MembersInjectionBinding> binding =
+                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
+            return binding.isPresent()
+                ? ResolvedBindings.forMembersInjectionBinding(
+                    bindingKey, componentDescriptor, binding.get())
+                : ResolvedBindings.noBindings(bindingKey, componentDescriptor);
           default:
             throw new AssertionError();
         }
       }
 
-      private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
-        MembersInjectionBinding membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-
-        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
-          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
-              membersInjectionBinding.parentInjectorRequest().get().key());
-          if (parentBinding.injectionStrategy().equals(NO_OP)) {
-            return membersInjectionBinding.withoutParentInjectorRequest();
-          }
+      private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
+          indexBindingsByOwningComponent(
+              DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
+        ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> index =
+            ImmutableSetMultimap.builder();
+        for (ContributionBinding binding : bindings) {
+          index.put(getOwningComponent(request, binding), binding);
         }
+        return index.build();
+      }
 
-        return membersInjectionBinding;
+      /**
+       * Returns the component that "owns" {@code binding}.
+       *
+       * <p>If {@code binding} is bound in an ancestor component, resolves {@code request} in this
+       * component's parent. Returns the ancestor component in which it is bound, unless
+       * {@code binding} depends on local multibindings, in which case returns this component.
+       *
+       * <p>If {@code binding} is not bound in an ancestor component, simply returns this component.
+       */
+      private ComponentDescriptor getOwningComponent(
+          DependencyRequest request, ContributionBinding binding) {
+        return isResolvedInParent(request, binding)
+                && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)
+            ? getOwningResolver(binding).get().componentDescriptor
+            : componentDescriptor;
       }
 
-      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
-        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
-            provisionBinding.wrappedScope();
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitProvisionBindings.containsValue(provisionBinding)) {
-             return Optional.of(requestResolver);
+      /**
+       * Returns {@code true} if {@code binding} is owned by an ancestor. If so,
+       * {@linkplain #resolve(DependencyRequest) resolves} the request in this component's parent.
+       * Don't resolve directly in the owning component in case it depends on multibindings in any
+       * of its descendants.
+       */
+      private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
+        Optional<Resolver> owningResolver = getOwningResolver(binding);
+        if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+          parentResolver.get().resolve(request);
+          return true;
+        } else {
+          return false;
+        }
+      }
+
+      private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.explicitBindingsSet.contains(binding)) {
+            return Optional.of(requestResolver);
           }
         }
+
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the † compatibility mode
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-          if (bindingScope.isPresent() && bindingScope.equals(requestResolver.targetScope)) {
-            return Optional.of(requestResolver);
+        Scope bindingScope = binding.scope();
+        if (bindingScope.isPresent()) {
+          for (Resolver requestResolver : getResolverLineage().reverse()) {
+            if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
+              return Optional.of(requestResolver);
+            }
           }
         }
         return Optional.absent();
       }
 
       /** Returns the resolver lineage from parent to child. */
-      private ImmutableList<RequestResolver> getResolverLineage() {
-        List<RequestResolver> resolverList = Lists.newArrayList();
-        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+      private ImmutableList<Resolver> getResolverLineage() {
+        List<Resolver> resolverList = Lists.newArrayList();
+        for (Optional<Resolver> currentResolver = Optional.of(this);
             currentResolver.isPresent();
             currentResolver = currentResolver.get().parentResolver) {
           resolverList.add(currentResolver.get());
@@ -353,22 +482,42 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
-      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProvisionBindings.get(requestKey));
+      /**
+       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
+       * this and all ancestor resolvers.
+       */
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
+        ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(resolver.explicitBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
 
-      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProductionBindings.get(requestKey));
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getExplicitBindings(optionalKey.get())
+            : ImmutableSet.<ContributionBinding>of();
+      }
+
+      /**
+       * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
+       * ancestor resolvers.
+       */
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(Key key) {
+        ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          multibindingDeclarations.addAll(resolver.multibindingDeclarations.get(key));
         }
-        return explicitBindingsForKey.build();
+        return multibindingDeclarations.build();
+      }
+
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getMultibindingDeclarations(optionalKey.get())
+            : ImmutableSet.<MultibindingDeclaration>of();
       }
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
@@ -386,19 +535,24 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
 
-        Optional<ResolvedBindings> previouslyResolvedBinding =
-            getPreviouslyResolvedBindings(bindingKey);
-        if (previouslyResolvedBinding.isPresent()
-            && !(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-                && !previouslyResolvedBinding.get().contributionBindings().isEmpty()
-                && ContributionBinding.bindingTypeFor(
-                    previouslyResolvedBinding.get().contributionBindings()).isMultibinding())) {
+        // If we find a cycle, stop resolving. The original request will add it with all of the
+        // other resolved deps.
+        if (cycleStack.contains(bindingKey)) {
+          return;
+        }
+
+        // If the binding was previously resolved in this (sub)component, don't resolve it again.
+        if (resolvedBindings.containsKey(bindingKey)) {
           return;
         }
 
-        if (cycleStack.contains(bindingKey)) {
-          // We found a cycle. Don't add a resolved binding, since the original request will add it
-          // with all of the other resolved deps
+        // If the binding was previously resolved in a supercomponent, then test to see if it
+        // depends on multibindings with contributions from this subcomponent. If it does, then we
+        // have to resolve it in this subcomponent so that it sees the local contributions. If it
+        // does not, then we can stop resolving it in this subcomponent and rely on the
+        // supercomponent resolution.
+        if (getPreviouslyResolvedBindings(bindingKey).isPresent()
+            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)) {
           return;
         }
 
@@ -421,23 +575,119 @@ void resolve(DependencyRequest request) {
             ImmutableMap.builder();
         resolvedBindingsBuilder.putAll(resolvedBindings);
         if (parentResolver.isPresent()) {
-          for (ResolvedBindings resolvedInParent :
-              parentResolver.get().getResolvedBindings().values()) {
-            BindingKey bindingKey = resolvedInParent.bindingKey();
-            if (!resolvedBindings.containsKey(bindingKey)) {
-              if (resolvedInParent.ownedBindings().isEmpty()) {
-                // reuse the instance if we can get away with it
-                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
-              } else {
-                resolvedBindingsBuilder.put(bindingKey,
-                    ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
-              }
-            }
+          Collection<ResolvedBindings> bindingsResolvedInParent =
+              Maps.difference(parentResolver.get().getResolvedBindings(), resolvedBindings)
+                  .entriesOnlyOnLeft()
+                  .values();
+          for (ResolvedBindings resolvedInParent : bindingsResolvedInParent) {
+            resolvedBindingsBuilder.put(
+                resolvedInParent.bindingKey(),
+                resolvedInParent.asInheritedIn(componentDescriptor));
           }
         }
         return resolvedBindingsBuilder.build();
       }
+
+      ImmutableSet<ModuleDescriptor> getInheritedModules() {
+        return parentResolver.isPresent()
+            ? Sets.union(
+                    parentResolver.get().getInheritedModules(),
+                    parentResolver.get().componentDescriptor.transitiveModules())
+                .immutableCopy()
+            : ImmutableSet.<ModuleDescriptor>of();
+      }
+
+      ImmutableSet<ModuleDescriptor> getOwnedModules() {
+        return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
+            .immutableCopy();
+      }
+
+      private final class MultibindingDependencies {
+        private final Set<BindingKey> cycleChecker = new HashSet<>();
+
+        /**
+         * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with
+         * contributions declared within this component's modules, or if any of its unscoped
+         * dependencies depend on such local multibindings.
+         *
+         * <p>We don't care about scoped dependencies because they will never depend on
+         * multibindings with contributions from subcomponents.
+         *
+         * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is
+         *     absent
+         */
+        boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
+          checkArgument(
+              getPreviouslyResolvedBindings(bindingKey).isPresent(),
+              "no previously resolved bindings in %s for %s",
+              Resolver.this,
+              bindingKey);
+          // Don't recur infinitely if there are valid cycles in the dependency graph.
+          if (!cycleChecker.add(bindingKey)) {
+            return false;
+          }
+          try {
+            return dependsOnLocalMultibindingsCache.get(
+                bindingKey,
+                new Callable<Boolean>() {
+                  @Override
+                  public Boolean call() {
+                    ResolvedBindings previouslyResolvedBindings =
+                        getPreviouslyResolvedBindings(bindingKey).get();
+                    if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
+                      return true;
+                    }
+
+                    for (Binding binding : previouslyResolvedBindings.bindings()) {
+                      if (dependsOnLocalMultibindings(binding)) {
+                        return true;
+                      }
+                    }
+                    return false;
+                  }
+                });
+          } catch (ExecutionException e) {
+            throw new AssertionError(e);
+          }
+        }
+
+        /**
+         * Returns {@code true} if {@code binding} is unscoped and depends on multibindings with
+         * contributions declared within this component's modules, or if any of its unscoped
+         * dependencies depend on such local multibindings.
+         *
+         * <p>We don't care about scoped dependencies because they will never depend on
+         * multibindings with contributions from subcomponents.
+         */
+        boolean dependsOnLocalMultibindings(final Binding binding) {
+          try {
+            return bindingDependsOnLocalMultibindingsCache.get(
+                binding,
+                new Callable<Boolean>() {
+                  @Override
+                  public Boolean call() {
+                    if (!binding.scope().isPresent()
+                        // TODO(beder): Figure out what happens with production subcomponents.
+                        && !binding.bindingType().equals(BindingType.PRODUCTION)) {
+                      for (DependencyRequest dependency : binding.implicitDependencies()) {
+                        if (dependsOnLocalMultibindings(dependency.bindingKey())) {
+                          return true;
+                        }
+                      }
+                    }
+                    return false;
+                  }
+                });
+          } catch (ExecutionException e) {
+            throw new AssertionError(e);
+          }
+        }
+
+        private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
+          return resolvedBindings.isMultibindings()
+              && explicitBindings.containsKey(resolvedBindings.key());
+        }
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2b38b5ab6..413896c38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -30,28 +29,38 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
-import javax.inject.Singleton;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -59,97 +68,191 @@
 import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Maps.filterKeys;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
+import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
-public class BindingGraphValidator implements Validator<BindingGraph> {
+public class BindingGraphValidator {
 
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
-  private final ProvisionBindingFormatter provisionBindingFormatter;
-  private final ProductionBindingFormatter productionBindingFormatter;
+  private final HasSourceElementFormatter hasSourceElementFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
+  private final Key.Factory keyFactory;
 
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
-      ProvisionBindingFormatter provisionBindingFormatter,
-      ProductionBindingFormatter productionBindingFormatter,
+      HasSourceElementFormatter hasSourceElementFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
-      KeyFormatter keyFormatter) {
+      KeyFormatter keyFormatter,
+      Key.Factory keyFactory) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
-    this.provisionBindingFormatter = provisionBindingFormatter;
-    this.productionBindingFormatter = productionBindingFormatter;
+    this.hasSourceElementFormatter = hasSourceElementFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
+    this.keyFactory = keyFactory;
   }
 
   private class Validation {
     final BindingGraph topLevelGraph;
-    final ValidationReport.Builder<BindingGraph> reportBuilder;
+    final BindingGraph subject;
+    final ValidationReport.Builder<TypeElement> reportBuilder;
 
-    Validation(BindingGraph topLevelGraph) {
+    Validation(BindingGraph topLevelGraph, BindingGraph subject) {
       this.topLevelGraph = topLevelGraph;
-      this.reportBuilder = ValidationReport.Builder.about(topLevelGraph);
+      this.subject = subject;
+      this.reportBuilder =
+          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
+    }
+
+    Validation(BindingGraph topLevelGraph) {
+      this(topLevelGraph, topLevelGraph);
     }
 
-    ValidationReport<BindingGraph> buildReport() {
+    ValidationReport<TypeElement> buildReport() {
       return reportBuilder.build();
     }
 
-    void validateSubgraph(BindingGraph subject) {
-      validateComponentScope(subject);
-      validateDependencyScopes(subject);
-      validateBuilders(subject);
+    void validateSubgraph() {
+      validateComponentScope();
+      validateDependencyScopes();
+      validateComponentHierarchy();
+      validateBuilders();
 
       for (ComponentMethodDescriptor componentMethod :
            subject.componentDescriptor().componentMethods()) {
         Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
         if (entryPoint.isPresent()) {
-          traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
-              Sets.<BindingKey>newHashSet(), subject,
-              Sets.<DependencyRequest>newHashSet());
+          traverseRequest(
+              entryPoint.get(),
+              new ArrayDeque<ResolvedRequest>(),
+              new LinkedHashSet<BindingKey>(),
+              subject,
+              new HashSet<DependencyRequest>());
         }
       }
+      
+      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
+          filterKeys(
+                  subject.componentDescriptor().subcomponents(),
+                  isOfKind(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT))
+              .entrySet()) {
+        validateSubcomponentFactoryMethod(
+            entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
+      }
 
       for (BindingGraph subgraph : subject.subgraphs().values()) {
-        validateSubgraph(subgraph);
+        Validation subgraphValidation =
+            new Validation(topLevelGraph, subgraph);
+        subgraphValidation.validateSubgraph();
+        reportBuilder.addSubreport(subgraphValidation.buildReport());
       }
     }
 
+    private void validateSubcomponentFactoryMethod(
+        ExecutableElement factoryMethod, TypeElement subcomponentType) {
+      BindingGraph subgraph = subject.subgraphs().get(factoryMethod);
+      FluentIterable<TypeElement> missingModules =
+          FluentIterable.from(subgraph.componentRequirements())
+              .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
+              .filter(
+                  new Predicate<TypeElement>() {
+                    @Override
+                    public boolean apply(TypeElement moduleType) {
+                      return !componentCanMakeNewInstances(moduleType);
+                    }
+                  });
+      if (!missingModules.isEmpty()) {
+        reportBuilder.addError(
+            String.format(
+                "%s requires modules which have no visible default constructors. "
+                    + "Add the following modules as parameters to this method: %s",
+                subcomponentType.getQualifiedName(),
+                Joiner.on(", ").join(missingModules.toSet())),
+            factoryMethod);
+      }
+    }
+
+    private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
+        ExecutableElement factoryMethod) {
+      DeclaredType componentType =
+          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+      ExecutableType factoryMethodType =
+          asExecutable(types.asMemberOf(componentType, factoryMethod));
+      return asTypeElements(factoryMethodType.getParameterTypes());
+    }
+
+    /**
+     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
+     * cycles found.
+     *
+     * @param request the current dependency request
+     * @param bindingPath the dependency request path from the parent of {@code request} at the head
+     *     up to the root dependency request from the component method at the tail
+     * @param keysInPath the binding keys corresponding to the dependency requests in
+     *     {@code bindingPath}, but in reverse order: the first element is the binding key from the
+     *     component method
+     * @param resolvedRequests the requests that have already been resolved, so we can avoid
+     *     traversing that part of the graph again
+     */
+    // TODO(dpb): It might be simpler to invert bindingPath's order.
     private void traverseRequest(
         DependencyRequest request,
         Deque<ResolvedRequest> bindingPath,
-        Set<BindingKey> keysInPath,
+        LinkedHashSet<BindingKey> keysInPath,
         BindingGraph graph,
         Set<DependencyRequest> resolvedRequests) {
       verify(bindingPath.size() == keysInPath.size(),
           "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
       BindingKey requestKey = request.bindingKey();
       if (keysInPath.contains(requestKey)) {
-        reportCycle(request, bindingPath);
+        reportCycle(
+            // Invert bindingPath to match keysInPath's order
+            ImmutableList.copyOf(bindingPath).reverse(),
+            request,
+            indexOf(keysInPath, equalTo(requestKey)));
         return;
       }
 
@@ -176,212 +279,355 @@ private void traverseRequest(
      */
     private boolean validateResolvedBinding(
         Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
-      if (resolvedBinding.bindings().isEmpty()) {
+      if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
         return false;
       }
 
-      ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
-          ImmutableSet.builder();
-      for (Binding binding : resolvedBinding.bindings()) {
-        if (binding instanceof ProvisionBinding) {
-          provisionBindingsBuilder.add((ProvisionBinding) binding);
-        }
-        if (binding instanceof ProductionBinding) {
-          productionBindingsBuilder.add((ProductionBinding) binding);
-        }
-        if (binding instanceof MembersInjectionBinding) {
-          membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
-        }
-      }
-      ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
-      ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
-      ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-          membersInjectionBindingsBuilder.build();
-
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          if (!membersInjectionBindings.isEmpty()) {
-            throw new IllegalArgumentException(
+          ImmutableSet<ContributionBinding> contributionBindings =
+              resolvedBinding.contributionBindings();
+          if (Iterables.any(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
-          if (!validateNullability(path.peek().request(), combined)) {
+          if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+          if (Iterables.any(contributionBindings, BindingType.isOfType(BindingType.PRODUCTION))
+              && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if ((provisionBindings.size() + productionBindings.size()) <= 1) {
-            return true;
-          }
-          ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-              ContributionBinding.bindingTypesFor(
-                  Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
-          if (bindingsByType.keySet().size() > 1) {
+          ImmutableSet<ContributionType> contributionTypes =
+              declarationsByType(resolvedBinding).keySet();
+          if (contributionTypes.size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
-          } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-            reportDuplicateBindings(path);
-            return false;
+          }
+          if (contributionBindings.size() <= 1) {
+            return true;
+          }
+          switch (getOnlyElement(contributionTypes)) {
+            case UNIQUE:
+              reportDuplicateBindings(path);
+              return false;
+            case MAP:
+              boolean duplicateMapKeys = hasDuplicateMapKeys(path, contributionBindings);
+              boolean inconsistentMapKeyAnnotationTypes =
+                  hasInconsistentMapKeyAnnotationTypes(path, contributionBindings);
+              return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
+            case SET:
+              break;
+            default:
+              throw new AssertionError();
           }
           break;
         case MEMBERS_INJECTION:
-          if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
-            throw new IllegalArgumentException(
+          if (!Iterables.all(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "members injection binding keys should never have contribution bindings");
           }
-          if (membersInjectionBindings.size() > 1) {
+          if (resolvedBinding.bindings().size() > 1) {
             reportDuplicateBindings(path);
             return false;
           }
-          if (membersInjectionBindings.size() == 1) {
-            MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
-            if (!validateMembersInjectionBinding(binding, path)) {
-              return false;
-            }
-          }
-          break;
+          return validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
         default:
           throw new AssertionError();
       }
       return true;
     }
 
+    /**
+     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
+     * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
+     * bindings and multibinding declarations of their dependencies.
+     *
+     * <p>For example, if:
+     *
+     * <ul>
+     * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
+     *     {@code X}.
+     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
+     * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
+     *     {@code Y}.
+     * </ul>
+     *
+     * then {@code inlineSyntheticBindings(bindingsForKey1)} has bindings {@code A}, {@code C}, and
+     * {@code D}, with multibinding declarations {@code X} and {@code Y}.
+     *
+     * <p>The replacement is repeated until none of the bindings are synthetic.
+     */
+    private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
+      if (!Iterables.any(
+          resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
+        return resolvedBinding;
+      }
+      
+      ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
+          ImmutableSetMultimap.builder();
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      Queue<Map.Entry<ComponentDescriptor, ContributionBinding>> contributionQueue =
+          new ArrayDeque<>(resolvedBinding.allContributionBindings().entries());
+
+      for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry =
+              contributionQueue.poll();
+          bindingEntry != null;
+          bindingEntry = contributionQueue.poll()) {
+        ContributionBinding binding = bindingEntry.getValue();
+        if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
+          BindingKey syntheticBindingDependency =
+              getOnlyElement(binding.dependencies()).bindingKey();
+          ResolvedBindings dependencyBindings =
+              subject.resolvedBindings().get(syntheticBindingDependency);
+          multibindingDeclarations.addAll(dependencyBindings.multibindingDeclarations());
+          contributionQueue.addAll(dependencyBindings.allContributionBindings().entries());
+        } else {
+          contributions.put(bindingEntry);
+        }
+      }
+      return ResolvedBindings.forContributionBindings(
+          resolvedBinding.bindingKey(),
+          resolvedBinding.owningComponent(),
+          contributions.build(),
+          multibindingDeclarations.build());
+    }
+
+    private ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType(
+        ResolvedBindings resolvedBinding) {
+      ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
+      return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+          .putAll(indexByContributionType(inlined.contributionBindings()))
+          .putAll(indexByContributionType(inlined.multibindingDeclarations()))
+          .build();
+    }
+
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
         DependencyRequest request, Set<ContributionBinding> bindings) {
+      if (request.isNullable()) {
+        return true;
+      }
+
+      // Note: the method signature will include the @Nullable in it!
+      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+       * (Maybe this happens if the code was already compiled before this point?)
+       * ... we manually print out the request in that case, otherwise the error
+       * message is kind of useless. */
+      String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+
       boolean valid = true;
-      if (!request.isNullable()) {
-        String typeName = null;
-        for (ContributionBinding binding : bindings) {
-          if (binding.nullableType().isPresent()) {
-            String methodSignature;
-            if (binding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-              methodSignature = provisionBindingFormatter.format(provisionBinding);
-            } else {
-              ProductionBinding productionBinding = (ProductionBinding) binding;
-              methodSignature = productionBindingFormatter.format(productionBinding);
-            }
-            // Note: the method signature will include the @Nullable in it!
-            // TODO(sameb): Sometimes javac doesn't include the Element in its output.
-            // (Maybe this happens if the code was already compiled before this point?)
-            // ... we manually print ouf the request in that case, otherwise the error
-            // message is kind of useless.
-            if (typeName == null) {
-              typeName = TypeNames.forTypeMirror(request.key().type()).toString();
-            }
-            reportBuilder.addItem(
-                String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
-                + "\n at: " + dependencyRequestFormatter.format(request),
-                nullableValidationType,
-                request.requestElement());
-            valid = false;
-          }
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          reportBuilder.addItem(
+              nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
+                  + "\n at: "
+                  + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
         }
       }
       return valid;
     }
 
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
+     * for the same map key.
+     */
+    private boolean hasDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+      boolean hasDuplicateMapKeys = false;
+      for (Collection<ContributionBinding> mapBindingsForMapKey :
+          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
+        if (mapBindingsForMapKey.size() > 1) {
+          hasDuplicateMapKeys = true;
+          reportDuplicateMapKeys(path, mapBindingsForMapKey);
+        }
+      }
+      return hasDuplicateMapKeys;
+    }
+
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
+     * {@link MapKey} annotation type.
+     */
+    private boolean hasInconsistentMapKeyAnnotationTypes(
+        Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
+      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
+      if (mapBindingsByAnnotationType.keySet().size() > 1) {
+        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
+        return true;
+      }
+      return false;
+    }
+
     /**
      * Validates a members injection binding, returning false (and reporting the error) if it wasn't
      * valid.
      */
     private boolean validateMembersInjectionBinding(
-        MembersInjectionBinding binding, final Deque<ResolvedRequest> path) {
-      return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-          reportBuilder.addItem("Invalid members injection request.",
-              path.peek().request().requestElement());
-          return false;
-        }
+        Binding binding, final Deque<ResolvedRequest> path) {
+      return binding
+          .key()
+          .type()
+          .accept(
+              new SimpleTypeVisitor6<Boolean, Void>() {
+                @Override
+                protected Boolean defaultAction(TypeMirror e, Void p) {
+                  reportBuilder.addError(
+                      "Invalid members injection request.", path.peek().request().requestElement());
+                  return false;
+                }
 
-        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-          // If the key has type arguments, validate that each type argument is declared.
-          // Otherwise the type argument may be a wildcard (or other type), and we can't
-          // resolve that to actual types.  If the arg was an array, validate the type
-          // of the array.
-          for (TypeMirror arg : type.getTypeArguments()) {
-            boolean declared;
-            switch (arg.getKind()) {
-              case ARRAY:
-                declared = MoreTypes.asArray(arg).getComponentType().accept(
-                    new SimpleTypeVisitor6<Boolean, Void>() {
-                      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-                        return false;
-                      }
-
-                      @Override public Boolean visitDeclared(DeclaredType t, Void p) {
-                        for (TypeMirror arg : t.getTypeArguments()) {
-                          if (!arg.accept(this, null)) {
-                            return false;
-                          }
-                        }
-                        return true;
-                      }
-
-                      @Override public Boolean visitArray(ArrayType t, Void p) {
-                        return t.getComponentType().accept(this, null);
-                      }
-
-                      @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                        return true;
-                      }
-                    }, null);
-                break;
-              case DECLARED:
-                declared = true;
-                break;
-              default:
-                declared = false;
-            }
-            if (!declared) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-              reportBuilder.addItem(
-                  String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                      arg.toString(),
-                      type.toString(),
-                      Joiner.on('\n').join(printableDependencyPath)),
-                      path.peek().request().requestElement());
-              return false;
-            }
-          }
+                @Override
+                public Boolean visitDeclared(DeclaredType type, Void ignored) {
+                  // If the key has type arguments, validate that each type argument is declared.
+                  // Otherwise the type argument may be a wildcard (or other type), and we can't
+                  // resolve that to actual types.  If the arg was an array, validate the type
+                  // of the array.
+                  for (TypeMirror arg : type.getTypeArguments()) {
+                    boolean declared;
+                    switch (arg.getKind()) {
+                      case ARRAY:
+                        declared =
+                            MoreTypes.asArray(arg)
+                                .getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor6<Boolean, Void>() {
+                                      @Override
+                                      protected Boolean defaultAction(TypeMirror e, Void p) {
+                                        return false;
+                                      }
 
-          TypeElement element = MoreElements.asType(type.asElement());
-          // Also validate that the key is not the erasure of a generic type.
-          // If it is, that means the user referred to Foo<T> as just 'Foo',
-          // which we don't allow.  (This is a judgement call -- we *could*
-          // allow it and instantiate the type bounds... but we don't.)
-          if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-              && types.isSameType(types.erasure(element.asType()), type)) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-            reportBuilder.addItem(
-                String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                    type.toString(),
-                    Joiner.on('\n').join(printableDependencyPath)),
-                path.peek().request().requestElement());
-            return false;
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                        break;
+                      case DECLARED:
+                        declared = true;
+                        break;
+                      default:
+                        declared = false;
+                    }
+                    if (!declared) {
+                      ImmutableList<String> printableDependencyPath =
+                          FluentIterable.from(path)
+                              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                              .transform(dependencyRequestFormatter)
+                              .filter(Predicates.not(Predicates.equalTo("")))
+                              .toList()
+                              .reverse();
+                      reportBuilder.addError(
+                          String.format(
+                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                              arg.toString(),
+                              type.toString(),
+                              Joiner.on('\n').join(printableDependencyPath)),
+                          path.peek().request().requestElement());
+                      return false;
+                    }
+                  }
+
+                  TypeElement element = MoreElements.asType(type.asElement());
+                  // Also validate that the key is not the erasure of a generic type.
+                  // If it is, that means the user referred to Foo<T> as just 'Foo',
+                  // which we don't allow.  (This is a judgement call -- we *could*
+                  // allow it and instantiate the type bounds... but we don't.)
+                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                      && types.isSameType(types.erasure(element.asType()), type)) {
+                    ImmutableList<String> printableDependencyPath =
+                        FluentIterable.from(path)
+                            .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                            .transform(dependencyRequestFormatter)
+                            .filter(Predicates.not(Predicates.equalTo("")))
+                            .toList()
+                            .reverse();
+                    reportBuilder.addError(
+                        String.format(
+                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
+                            type.toString(),
+                            Joiner.on('\n').join(printableDependencyPath)),
+                        path.peek().request().requestElement());
+                    return false;
+                  }
+
+                  return true; // valid
+                }
+              },
+              null);
+    }
+
+    /**
+     * Validates that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy() {
+      ComponentDescriptor descriptor = subject.componentDescriptor();
+      TypeElement componentType = descriptor.componentDefinitionType();
+      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
+    }
+
+    /**
+     * Recursive method to validate that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy(
+        TypeElement rootComponent,
+        TypeElement componentType,
+        Deque<TypeElement> componentStack) {
+
+      if (componentStack.contains(componentType)) {
+        // Current component has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" contains a cycle in its component dependencies:\n");
+        componentStack.push(componentType);
+        appendIndentedComponentsList(message, componentStack);
+        componentStack.pop();
+        reportBuilder.addItem(message.toString(),
+            scopeCycleValidationType.diagnosticKind().get(),
+            rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          componentStack.push(componentType);
+
+          ImmutableSet<TypeElement> dependencies =
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
+          for (TypeElement dependency : dependencies) {
+            validateComponentHierarchy(rootComponent, dependency, componentStack);
           }
 
-          return true; // valid
+          componentStack.pop();
         }
-      }, null);
+      }
     }
 
     /**
@@ -389,14 +635,14 @@ private boolean validateMembersInjectionBinding(
      * that there are no cycles within the scoping chain, and that singleton
      * components have no scoped dependencies.
      */
-    private void validateDependencyScopes(BindingGraph subject) {
+    private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Optional<AnnotationMirror> scope = descriptor.scope();
+      Scope scope = descriptor.scope();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (scope.isPresent()) {
         // Dagger 1.x scope compatibility requires this be suppress-able.
         if (scopeCycleValidationType.diagnosticKind().isPresent()
-            && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+            && scope.isSingleton()) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
@@ -410,12 +656,13 @@ private void validateDependencyScopes(BindingGraph subject) {
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+          StringBuilder message = new StringBuilder(scope.getReadableSource())
               .append(' ')
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         } else {
@@ -423,7 +670,7 @@ private void validateDependencyScopes(BindingGraph subject) {
           if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
-                new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+                new ArrayDeque<Scope>(),
                 new ArrayDeque<TypeElement>());
           }
         }
@@ -434,33 +681,37 @@ private void validateDependencyScopes(BindingGraph subject) {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders(BindingGraph subject) {
+    private void validateBuilders() {
       ComponentDescriptor componentDesc = subject.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<TypeElement> allDependents = subject.componentRequirements();
-      Set<TypeElement> requiredDependents =
-          Sets.filter(allDependents, new Predicate<TypeElement>() {
-            @Override public boolean apply(TypeElement input) {
-              return !Util.componentCanMakeNewInstances(input);
-            }
-          });
+      Set<TypeElement> availableDependencies = subject.availableDependencies();
+      Set<TypeElement> requiredDependencies =
+          Sets.filter(
+              availableDependencies,
+              new Predicate<TypeElement>() {
+                @Override
+                public boolean apply(TypeElement input) {
+                  return !Util.componentCanMakeNewInstances(input);
+                }
+              });
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
@@ -470,14 +721,14 @@ private void validateBuilders(BindingGraph subject) {
                 return methodSignatureFormatter.format(input,
                     Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
               }});
-        reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
       }
     }
 
@@ -487,17 +738,16 @@ private void validateBuilders(BindingGraph subject) {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes.
+     * relationship between scopes. However, cycles in component dependencies are explicitly
+     * checked in {@link #validateComponentHierarchy()}.
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
-        Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+        Deque<Scope> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+      Scope scope = Scope.scopeOf(componentType);
       if (scope.isPresent()) {
-        Equivalence.Wrapper<AnnotationMirror> wrappedScope =
-            AnnotationMirrors.equivalence().wrap(scope.get());
-        if (scopeStack.contains(wrappedScope)) {
+        if (scopeStack.contains(scope)) {
           scopedDependencyStack.push(componentType);
           // Current scope has already appeared in the component chain.
           StringBuilder message = new StringBuilder();
@@ -518,7 +768,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
                 MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
             if (scopedDependencies.size() == 1) {
               // empty can be ignored (base-case), and > 1 is a different error reported separately.
-              scopeStack.push(wrappedScope);
+              scopeStack.push(scope);
               scopedDependencyStack.push(componentType);
               validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
                   scopeStack, scopedDependencyStack);
@@ -534,49 +784,45 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      * Validates that the scope (if any) of this component are compatible with the scopes of the
      * bindings available in this component
      */
-    void validateComponentScope(final BindingGraph subject) {
+    void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
-          subject.componentDescriptor().wrappedScope();
+      Scope componentScope = subject.componentDescriptor().scope();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
-        if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-          for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-            if (contributionBinding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-              if (provisionBinding.scope().isPresent()
-                  && !componentScope.equals(provisionBinding.wrappedScope())) {
-                // Scoped components cannot reference bindings to @Provides methods or @Inject
-                // types decorated by a different scope annotation. Unscoped components cannot
-                // reference to scoped @Provides methods or @Inject types decorated by any
-                // scope annotation.
-                switch (provisionBinding.bindingKind()) {
-                  case PROVISION:
-                    ExecutableElement provisionMethod =
-                        MoreElements.asExecutable(provisionBinding.bindingElement());
-                    incompatiblyScopedMethodsBuilder.add(
-                        methodSignatureFormatter.format(provisionMethod));
-                    break;
-                  case INJECTION:
-                    incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
-                        provisionBinding.scope().get().toString()) + " class "
-                            + provisionBinding.bindingTypeElement().getQualifiedName());
-                    break;
-                  default:
-                    throw new IllegalStateException();
-                }
-              }
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
+          Scope bindingScope = contributionBinding.scope();
+          if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+            // Scoped components cannot reference bindings to @Provides methods or @Inject
+            // types decorated by a different scope annotation. Unscoped components cannot
+            // reference to scoped @Provides methods or @Inject types decorated by any
+            // scope annotation.
+            switch (contributionBinding.bindingKind()) {
+              case PROVISION:
+                ExecutableElement provisionMethod =
+                    MoreElements.asExecutable(contributionBinding.bindingElement());
+                incompatiblyScopedMethodsBuilder.add(
+                    methodSignatureFormatter.format(provisionMethod));
+                break;
+              case INJECTION:
+                incompatiblyScopedMethodsBuilder.add(
+                    bindingScope.getReadableSource()
+                        + " class "
+                        + contributionBinding.bindingTypeElement().getQualifiedName());
+                break;
+              default:
+                throw new IllegalStateException();
             }
           }
         }
       }
+
       ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
       if (!incompatiblyScopedMethods.isEmpty()) {
         TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
         if (componentScope.isPresent()) {
           message.append(" scoped with ");
-          message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
+          message.append(componentScope.getReadableSource());
           message.append(" may not reference bindings with different scopes:\n");
         } else {
           message.append(" (unscoped) may not reference scoped bindings:\n");
@@ -584,8 +830,8 @@ void validateComponentScope(final BindingGraph subject) {
         for (String method : incompatiblyScopedMethods) {
           message.append(ErrorMessages.INDENT).append(method).append("\n");
         }
-        reportBuilder.addItem(message.toString(), componentType,
-            subject.componentDescriptor().componentAnnotation());
+        reportBuilder.addError(
+            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
       }
     }
 
@@ -593,25 +839,24 @@ void validateComponentScope(final BindingGraph subject) {
     private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
-        new Formatter(errorMessage).format(
-            ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-            keyFormatter.format(path.peek().request().key()));
+        new Formatter(errorMessage)
+            .format(
+                ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                formatRootRequestKey(path));
       } else {
-        ImmutableSet<ProvisionBinding> dependentProvisions =
+        ImmutableSet<? extends Binding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
         // that, should we display all productions that depend on them also?
         new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
             keyFormatter.format(dependentProvisions.iterator().next().key()));
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
     private void reportMissingBinding(Deque<ResolvedRequest> path) {
       Key key = path.peek().request().key();
       BindingKey bindingKey = path.peek().request().bindingKey();
-      TypeMirror type = key.type();
-      String typeName = TypeNames.forTypeMirror(type).toString();
       boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
       boolean requiresProvision = doesPathRequireProvisionOnly(path);
       StringBuilder errorMessage = new StringBuilder();
@@ -622,11 +867,14 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
           : requiresProvision
               ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
               : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-      errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
-      if (key.isValidMembersInjectionKey()
-          && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
-              .isEmpty()) {
-        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+      errorMessage.append(String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
+      if (key.isValidMembersInjectionKey()) {
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+        if (membersInjectionBinding.isPresent()
+            && !membersInjectionBinding.get().injectionSites().isEmpty()) {
+          errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+        }
       }
       ImmutableList<String> printableDependencyPath =
           FluentIterable.from(path)
@@ -642,91 +890,187 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph, bindingKey)) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    private static final int DUPLICATE_SIZE_LIMIT = 10;
-
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
-      for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT);
-        // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
-        if (binding instanceof ProvisionBinding) {
-          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-        } else if (binding instanceof ProductionBinding) {
-          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-        }
-      }
-      int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
-      if (numberOfOtherBindings > 0) {
-        builder.append('\n').append(INDENT)
-            .append("and ").append(numberOfOtherBindings).append(" other");
-      }
-      if (numberOfOtherBindings > 1) {
-        builder.append('s');
-      }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+      new Formatter(builder)
+          .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      hasSourceElementFormatter.formatIndentedList(
+          builder,
+          inlineSyntheticContributions(resolvedBinding).contributionBindings(),
+          1,
+          DUPLICATE_SIZE_LIMIT);
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
-      ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
-      ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-          ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
-      for (BindingType type :
-          Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      new Formatter(builder)
+          .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      ResolvedBindings resolvedBinding = path.peek().binding();
+      ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
+          declarationsByType(resolvedBinding);
+      for (ContributionType type :
+          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
-        builder.append(formatBindingType(type));
-        builder.append(" bindings:\n");
-        for (ContributionBinding binding : bindingsByType.get(type)) {
-          builder.append(INDENT).append(INDENT);
-          if (binding instanceof ProvisionBinding) {
-            builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-          } else if (binding instanceof ProductionBinding) {
-            builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-          }
-          builder.append('\n');
-        }
+        builder.append(formatContributionType(type));
+        builder.append(" bindings and declarations:");
+        hasSourceElementFormatter.formatIndentedList(
+            builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
+        builder.append('\n');
       }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
-    private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path) {
-      ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
-          .add(request)
-          .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
-          .build();
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
-          .transform(dependencyRequestFormatter)
-          .filter(Predicates.not(Predicates.equalTo("")))
-          .toList()
-          .reverse();
-      DependencyRequest rootRequest = path.getLast().request();
-      TypeElement componentType =
-          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-      // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
+    private void reportDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
+      StringBuilder builder = new StringBuilder();
+      builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
+      hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    private void reportInconsistentMapKeyAnnotations(
+        Deque<ResolvedRequest> path,
+        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType) {
+      StringBuilder builder =
+          new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
+      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+          mapBindingsByAnnotationType.asMap().entrySet()) {
+        DeclaredType annotationType = entry.getKey().get();
+        Collection<ContributionBinding> bindings = entry.getValue();
+
+        builder
+            .append('\n')
+            .append(INDENT)
+            .append(annotationType)
+            .append(':');
+
+        hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+      }
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    /**
+     * Reports a cycle in the binding path.
+     *
+     * @param bindingPath the binding path, starting with the component provision dependency, and
+     *     ending with the binding that depends on {@code request}
+     * @param request the request that would have been added to the binding path if its
+     *     {@linkplain DependencyRequest#bindingKey() binding key} wasn't already in it
+     * @param indexOfDuplicatedKey the index of the dependency request in {@code bindingPath} whose
+     *     {@linkplain DependencyRequest#bindingKey() binding key} matches {@code request}'s
+     */
+    private void reportCycle(
+        Iterable<ResolvedRequest> bindingPath,
+        DependencyRequest request,
+        int indexOfDuplicatedKey) {
+      ImmutableList<DependencyRequest> requestPath =
+          FluentIterable.from(bindingPath)
+              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+              .append(request)
+              .toList();
+      Element rootRequestElement = requestPath.get(0).requestElement();
+      ImmutableList<DependencyRequest> cycle =
+          requestPath.subList(indexOfDuplicatedKey, requestPath.size());
+      Diagnostic.Kind kind = cycleHasProviderOrLazy(cycle) ? WARNING : ERROR;
+      if (kind == WARNING
+          && (suppressCycleWarnings(rootRequestElement)
+              || suppressCycleWarnings(rootRequestElement.getEnclosingElement())
+              || suppressCycleWarnings(cycle))) {
+        return;
+      }
+      // TODO(cgruber): Provide a hint for the start and end of the cycle.
+      TypeElement componentType = MoreElements.asType(rootRequestElement.getEnclosingElement());
       reportBuilder.addItem(
-          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+          String.format(
+              ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
-              rootRequest.requestElement().getSimpleName(),
+              rootRequestElement.getSimpleName(),
               Joiner.on("\n")
-                  .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
-          rootRequest.requestElement());
+                  .join(
+                      FluentIterable.from(requestPath)
+                          .transform(dependencyRequestFormatter)
+                          .filter(not(equalTo("")))
+                          .skip(1))),
+          kind,
+          rootRequestElement);
+    }
+
+    /**
+     * Returns {@code true} if any step of a dependency cycle after the first is a {@link Provider}
+     * or {@link Lazy} or a {@code Map<K, Provider<V>>}.
+     *
+     * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
+     * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
+     * {@link Provider#get() get()} methods are called during provision and so the cycle is not
+     * really broken.
+     */
+    private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
+      DependencyRequest lastDependencyRequest = cycle.get(0);
+      for (DependencyRequest dependencyRequest : skip(cycle, 1)) {
+        switch (dependencyRequest.kind()) {
+          case PROVIDER:
+            if (!isImplicitProviderMapForValueMap(dependencyRequest, lastDependencyRequest)) {
+              return true;
+            }
+            break;
+
+          case LAZY:
+            return true;
+
+          case INSTANCE:
+            TypeMirror type = dependencyRequest.key().type();
+            if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
+              return true;
+            }
+            break;
+
+          default:
+            break;
+        }
+        lastDependencyRequest = dependencyRequest;
+      }
+      return false;
+    }
+
+    /**
+     * Returns {@code true} if {@code maybeValueMapRequest}'s key type is {@code Map<K, V>} and
+     * {@code maybeProviderMapRequest}'s key type is {@code Map<K, Provider<V>>}, and both keys have
+     * the same qualifier.
+     */
+    private boolean isImplicitProviderMapForValueMap(
+        DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
+      Optional<Key> implicitProviderMapKey =
+          keyFactory.implicitMapProviderKeyFrom(maybeValueMapRequest.key());
+      return implicitProviderMapKey.isPresent()
+          && implicitProviderMapKey.get().equals(maybeProviderMapRequest.key());
+    }
+  }
+
+  private boolean suppressCycleWarnings(Element requestElement) {
+    SuppressWarnings suppressions = requestElement.getAnnotation(SuppressWarnings.class);
+    return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
+  }
+
+  private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathElements) {
+    for (DependencyRequest dependencyRequest : pathElements) {
+      if (suppressCycleWarnings(dependencyRequest.requestElement())) {
+        return true;
+      }
     }
+    return false;
   }
 
-  @Override
-  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+  ValidationReport<TypeElement> validate(BindingGraph subject) {
     Validation validation = new Validation(subject);
-    validation.validateSubgraph(subject);
+    validation.validateSubgraph();
     return validation.buildReport();
   }
 
@@ -736,9 +1080,9 @@ private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path)
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      Scope scope = Scope.scopeOf(scopedComponent);
       if (scope.isPresent()) {
-        message.append(ErrorMessages.format(scope.get())).append(' ');
+        message.append(scope.getReadableSource()).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
           .append('\n');
@@ -752,7 +1096,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
       @Override public boolean apply(TypeElement input) {
-        return getScopeAnnotation(input).isPresent();
+        return Scope.scopeOf(input).isPresent();
       }
     }).toSet();
   }
@@ -780,33 +1124,32 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     }
     // otherwise, the second-most-recent bindings determine whether the most recent one must be a
     // provision
-    ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
-    return !dependentProvisions.isEmpty();
+    return !provisionsDependingOnLatestRequest(path).isEmpty();
   }
 
   /**
    * Returns any provision bindings resolved for the second-most-recent request in the given path;
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
-  private ImmutableSet<ProvisionBinding> provisionsDependingOnLatestRequest(
+  private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
       Deque<ResolvedRequest> path) {
     Iterator<ResolvedRequest> iterator = path.iterator();
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
-    @SuppressWarnings("unchecked")  // validated by instanceof below
-    ImmutableSet<ProvisionBinding> bindings = (ImmutableSet<ProvisionBinding>) FluentIterable
-        .from(previousResolvedRequest.binding().bindings())
-        .filter(new Predicate<Binding>() {
-            @Override public boolean apply(Binding binding) {
-              return binding instanceof ProvisionBinding
-                  && binding.implicitDependencies().contains(request);
-            }
-        }).toSet();
-    return bindings;
+    return FluentIterable.from(previousResolvedRequest.binding().bindings())
+        .filter(BindingType.isOfType(BindingType.PROVISION))
+        .filter(
+            new Predicate<Binding>() {
+              @Override
+              public boolean apply(Binding binding) {
+                return binding.implicitDependencies().contains(request);
+              }
+            })
+        .toSet();
   }
 
-  private String formatBindingType(BindingType type) {
-    switch(type) {
+  private String formatContributionType(ContributionType type) {
+    switch (type) {
       case MAP:
         return "Map";
       case SET:
@@ -818,6 +1161,10 @@ private String formatBindingType(BindingType type) {
     }
   }
 
+  private String formatRootRequestKey(Deque<ResolvedRequest> path) {
+    return keyFormatter.format(path.peek().request().key());
+  }
+
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
@@ -826,10 +1173,10 @@ private String formatBindingType(BindingType type) {
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
       BindingKey bindingKey = request.bindingKey();
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(
+          request,
           resolvedBindings == null
-              ? ResolvedBindings.create(bindingKey,
-                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+              ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
               : resolvedBindings);
     }
   }
@@ -840,8 +1187,4 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
           return resolvedRequest.request();
         }
       };
-
-  abstract static class Traverser {
-    abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
new file mode 100644
index 000000000..8d2a1d6c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.
+ */
+enum BindingType {
+  /** A binding with this type is a {@link ProvisionBinding}. */
+  PROVISION(Provider.class),
+
+  /** A binding with this type is a {@link MembersInjectionBinding}. */
+  MEMBERS_INJECTION(MembersInjector.class),
+
+  /** A binding with this type is a {@link ProductionBinding}. */
+  PRODUCTION(Producer.class),
+  ;
+
+  /** An object that is associated with a {@link BindingType}. */
+  interface HasBindingType {
+    /** The binding type of this object. */
+    BindingType bindingType();
+  }
+
+  private final Class<?> frameworkClass;
+
+  private BindingType(Class<?> frameworkClass) {
+    this.frameworkClass = frameworkClass;
+  }
+
+  /** The framework class associated with bindings of this type. */
+  Class<?> frameworkClass() {
+    return frameworkClass;
+  }
+
+  /** A predicate that passes for {@link HasBindingType}s with a given type. */
+  static Predicate<HasBindingType> isOfType(BindingType type) {
+    return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
+  }
+
+  /** A function that returns {@link HasBindingType#bindingType()}. */
+  static Function<HasBindingType, BindingType> BINDING_TYPE =
+      new Function<HasBindingType, BindingType>() {
+        @Override
+        public BindingType apply(HasBindingType hasBindingType) {
+          return hasBindingType.bindingType();
+        }
+      };
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 3bb85e3f9..fb9515486 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -43,33 +43,34 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
-/** 
+/**
  * Validates {@link dagger.Component.Builder} annotations.
- * 
- * @author sameb@google.com (Sam Berlin)  
+ *
+ * @author sameb@google.com (Sam Berlin)
  */
-class BuilderValidator implements Validator<TypeElement> {
+class BuilderValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
-  
-  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
+
+  BuilderValidator(Elements elements, Types types) {
     this.elements = elements;
     this.types = types;
-    this.componentType = componentType;
   }
 
-  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
 
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
-    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
+    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
-    
+
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
-      builder.addItem(msgs.mustBeInComponent(), subject);
+      builder.addError(msgs.mustBeInComponent(), subject);
     }
 
     switch (subject.getKind()) {
@@ -77,37 +78,36 @@
         List<? extends Element> allElements = subject.getEnclosedElements();
         List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
         if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
-          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
+          builder.addError(msgs.cxtorOnlyOneAndNoArgs(), subject);
         }
         break;
       case INTERFACE:
         break;
       default:
         // If not the correct type, exit early since the rest of the messages will be bogus.
-        builder.addItem(msgs.mustBeClassOrInterface(), subject);
-        return builder.build(); 
-    }    
+        builder.addError(msgs.mustBeClassOrInterface(), subject);
+        return builder.build();
+    }
 
-    
     if (!subject.getTypeParameters().isEmpty()) {
-      builder.addItem(msgs.generics(), subject);
+      builder.addError(msgs.generics(), subject);
     }
 
     Set<Modifier> modifiers = subject.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(msgs.isPrivate(), subject);
+      builder.addError(msgs.isPrivate(), subject);
     }
     if (!modifiers.contains(STATIC)) {
-      builder.addItem(msgs.mustBeStatic(), subject);
+      builder.addError(msgs.mustBeStatic(), subject);
     }
     // Note: Must be abstract, so no need to check for final.
     if (!modifiers.contains(ABSTRACT)) {
-      builder.addItem(msgs.mustBeAbstract(), subject);
+      builder.addError(msgs.mustBeAbstract(), subject);
     }
-    
+
     ExecutableElement buildMethod = null;
     Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
-        LinkedHashMultimap.create();    
+        LinkedHashMultimap.create();
     for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -141,33 +141,33 @@
                 Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
             method);
       }
-      
+
       if (!method.getTypeParameters().isEmpty()) {
         error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
             msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
-    
+
     if (buildMethod == null) {
-      builder.addItem(msgs.missingBuildMethod(), subject);
+      builder.addError(msgs.missingBuildMethod(), subject);
     }
-    
+
     // Go back through each recorded method per param type.  If we had more than one method
     // for a given param, fail.
     for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
         methodsPerParam.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         TypeMirror type = entry.getKey().get();
-        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
+        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
       }
     }
-    
+
     // Note: there's more validation in BindingGraphValidator,
     // specifically to make sure the setter methods mirror the deps.
 
     return builder.build();
   }
-  
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -182,19 +182,23 @@
    * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
    * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
    * failure.
-   * 
+   *
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
-      String enclosedError, String inheritedError, Object... extraArgs) {
+  private void error(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedError,
+      String inheritedError,
+      Object... extraArgs) {
     if (method.getEnclosingElement().equals(builder.getSubject())) {
-      builder.addItem(String.format(enclosedError, extraArgs), method);
+      builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
       Object[] newArgs = new Object[extraArgs.length + 1];
       newArgs[0] = method;
       System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+      builder.addError(String.format(inheritedError, newArgs), builder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
new file mode 100644
index 000000000..0bb43f65a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterSpec;
+import java.util.Iterator;
+import javax.lang.model.type.TypeMirror;
+
+final class CodeBlocks {
+
+  /** Shorthand for a {@link CodeBlock} with a single format and an argument list. */
+  static CodeBlock format(String format, Object... args) {
+    return CodeBlock.builder().add(format, args).build();
+  }
+
+  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
+    return join(codeBlocks, ", ");
+  }
+
+  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
+    CodeBlock.Builder builder = CodeBlock.builder();
+    Iterator<CodeBlock> iterator = codeBlocks.iterator();
+    while (iterator.hasNext()) {
+      builder.add(iterator.next());
+      if (iterator.hasNext()) {
+        builder.add(delimiter);
+      }
+    }
+    return builder.build();
+  }
+
+  static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
+      new Function<TypeMirror, CodeBlock>() {
+        @Override
+        public CodeBlock apply(TypeMirror typeMirror) {
+          return CodeBlocks.format("$T", typeMirror);
+        }
+      };
+
+  static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
+      new Function<ParameterSpec, CodeBlock>() {
+          @Override
+          public CodeBlock apply(ParameterSpec input) {
+            return CodeBlocks.format("$N", input);
+          }
+      };
+
+  private CodeBlocks() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 906be8a57..5d929868f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,22 +15,28 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
+import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -49,15 +55,12 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -72,16 +75,61 @@
   ComponentDescriptor() {}
 
   enum Kind {
-    COMPONENT(Component.class, Component.Builder.class),
-    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
-    PRODUCTION_COMPONENT(ProductionComponent.class, null);
+    COMPONENT(Component.class, Component.Builder.class, true),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
+    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true),
+    PRODUCTION_SUBCOMPONENT(
+        ProductionSubcomponent.class, ProductionSubcomponent.Builder.class, false);
 
     private final Class<? extends Annotation> annotationType;
     private final Class<? extends Annotation> builderType;
+    private final boolean isTopLevel;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #annotationType() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #builderAnnotationType() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
 
-    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
+    Kind(
+        Class<? extends Annotation> annotationType,
+        Class<? extends Annotation> builderType,
+        boolean isTopLevel) {
       this.annotationType = annotationType;
       this.builderType = builderType;
+      this.isTopLevel = isTopLevel;
     }
 
     Class<? extends Annotation> annotationType() {
@@ -91,6 +139,61 @@
     Class<? extends Annotation> builderAnnotationType() {
       return builderType;
     }
+
+    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
+        case PRODUCTION_COMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
+          return Sets.immutableEnumSet(
+              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
+        default:
+          throw new AssertionError(this);
+      }
+    }
+
+    ImmutableSet<Kind> subcomponentKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return ImmutableSet.of(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
+        case PRODUCTION_COMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
+          return ImmutableSet.of(PRODUCTION_SUBCOMPONENT);
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    boolean isTopLevel() {
+      return isTopLevel;
+    }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.annotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
+      return TO_ANNOTATION_TYPE;
+    }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.builderAnnotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
+      return TO_BUILDER_ANNOTATION_TYPE;
+    }
   }
 
   abstract Kind kind();
@@ -108,8 +211,20 @@
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  /**
+   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
+   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
+   * {@link Module#includes}.
+   */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
+  /**
+   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
+   * those reachable by traversing {@link Module#includes}.
+   *
+   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
+   * are declared in parent components.
+   */
   ImmutableSet<ModuleDescriptor> transitiveModules() {
     Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
     for (ModuleDescriptor module : modules()) {
@@ -118,6 +233,12 @@
     return ImmutableSet.copyOf(transitiveModules);
   }
 
+  ImmutableSet<TypeElement> transitiveModuleTypes() {
+    return FluentIterable.from(transitiveModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
@@ -141,20 +262,11 @@
   abstract Optional<TypeElement> executorDependency();
 
   /**
-   * An optional annotation constraining the scope of this component.
+   * The scope of the component.
    */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
-  }
+  abstract Scope scope();
 
-  /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
-   */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
-
-  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
@@ -167,14 +279,70 @@
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
+
+    /**
+     * A predicate that passes for {@link ComponentMethodDescriptor}s of one of the given kinds.
+     */
+    static Predicate<ComponentMethodDescriptor> isOfKind(ComponentMethodKind... kinds) {
+      final ImmutableSet<ComponentMethodKind> kindSet = ImmutableSet.copyOf(kinds);
+      return new Predicate<ComponentMethodDescriptor>() {
+        @Override
+        public boolean apply(ComponentMethodDescriptor descriptor) {
+          return kindSet.contains(descriptor.kind());
+        }
+      };
+    }
+
+    static ComponentMethodDescriptor create(
+        ComponentMethodKind kind,
+        Optional<DependencyRequest> dependencyRequest,
+        ExecutableElement methodElement) {
+      return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+          kind, dependencyRequest, methodElement);
+    }
+
+    static ComponentMethodDescriptor forProvision(
+        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
+      return create(ComponentMethodKind.PROVISION, Optional.of(dependencyRequest), methodElement);
+    }
+
+    static ComponentMethodDescriptor forMembersInjection(
+        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
+      return create(
+          ComponentMethodKind.MEMBERS_INJECTION, Optional.of(dependencyRequest), methodElement);
+    }
+
+    static ComponentMethodDescriptor forSubcomponent(
+        ComponentMethodKind kind, ExecutableElement methodElement) {
+      return create(kind, Optional.<DependencyRequest>absent(), methodElement);
+    }
   }
 
   enum ComponentMethodKind {
-    PROVISON,
+    PROVISION,
     PRODUCTION,
     MEMBERS_INJECTION,
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
+    PRODUCTION_SUBCOMPONENT,
+    PRODUCTION_SUBCOMPONENT_BUILDER;
+
+    /**
+     * Returns the component kind associated with this component method, if it exists. Otherwise,
+     * throws.
+     */
+    Kind componentKind() {
+      switch (this) {
+        case SUBCOMPONENT:
+        case SUBCOMPONENT_BUILDER:
+          return Kind.SUBCOMPONENT;
+        case PRODUCTION_SUBCOMPONENT:
+        case PRODUCTION_SUBCOMPONENT_BUILDER:
+          return Kind.PRODUCTION_SUBCOMPONENT;
+        default:
+          throw new IllegalStateException("no component associated with method " + this);
+      }
+    }
   }
 
   @AutoValue
@@ -202,22 +370,26 @@
       this.moduleDescriptorFactory = moduleDescriptorFactory;
     }
 
+    /**
+     * Returns a component descriptor for a type annotated with either {@link Component @Component}
+     * or {@link ProductionComponent @ProductionComponent}.
+     */
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.COMPONENT);
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+      checkArgument(
+          kind.isPresent() && kind.get().isTopLevel(),
+          "%s must be annotated with @Component or @ProductionComponent",
+          componentDefinitionType);
+      return create(componentDefinitionType, kind.get(), Optional.<Kind>absent());
     }
 
-    ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.PRODUCTION_COMPONENT);
-    }
-
-    private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
+    private ComponentDescriptor create(
+        TypeElement componentDefinitionType, Kind kind, Optional<Kind> parentKind) {
       DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
       AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, kind.annotationType())
-              .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
-              .get();
+          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
       ImmutableSet<TypeElement> componentDependencyTypes =
-          isComponent(componentDefinitionType)
+          kind.isTopLevel()
               ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
               : ImmutableSet.<TypeElement>of();
 
@@ -235,7 +407,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       }
 
       Optional<TypeElement> executorDependency =
-          kind.equals(Kind.PRODUCTION_COMPONENT)
+          kind.equals(Kind.PRODUCTION_COMPONENT) || kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
               ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
               : Optional.<TypeElement>absent();
 
@@ -243,6 +415,13 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
       }
+      if (kind.equals(Kind.PRODUCTION_COMPONENT)
+          || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
+              && parentKind.isPresent()
+              && (parentKind.get().equals(Kind.COMPONENT)
+                  || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
+        modules.add(descriptorForMonitoringModule(componentDefinitionType));
+      }
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
@@ -250,7 +429,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
@@ -260,14 +439,23 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
-            subcomponentDescriptors.put(componentMethod,
-                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
-                    Kind.SUBCOMPONENT));
+          case PRODUCTION_SUBCOMPONENT:
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+                    componentMethodDescriptor.kind().componentKind(),
+                    Optional.of(kind)));
             break;
           case SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
-                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
-                    Kind.SUBCOMPONENT));
+          case PRODUCTION_SUBCOMPONENT_BUILDER:
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(
+                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+                    componentMethodDescriptor.kind().componentKind(),
+                    Optional.of(kind)));
             break;
           default: // nothing special to do for other methods.
         }
@@ -280,7 +468,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
+      Scope scope = Scope.scopeOf(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -289,44 +477,45 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
           createBuilderSpec(builderType));
     }
 
-    private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
-        Kind componentKind,
-        ExecutableElement componentMethod) {
-      ExecutableType resolvedComponentMethod = MoreTypes.asExecutable(types.asMemberOf(
-          MoreTypes.asDeclared(componentElement.asType()), componentMethod));
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(
+        TypeElement componentElement, Kind componentKind, ExecutableElement componentMethod) {
+      ExecutableType resolvedComponentMethod =
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
       TypeMirror returnType = resolvedComponentMethod.getReturnType();
       if (returnType.getKind().equals(DECLARED)) {
         if (MoreTypes.isTypeOf(Provider.class, returnType)
             || MoreTypes.isTypeOf(Lazy.class, returnType)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.PROVISON,
-              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
-                  resolvedComponentMethod)),
-              componentMethod);
+          return ComponentMethodDescriptor.forProvision(
+              componentMethod,
+              dependencyRequestFactory.forComponentProvisionMethod(
+                  componentMethod, resolvedComponentMethod));
         } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.MEMBERS_INJECTION,
-              Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                  componentMethod,
-                  resolvedComponentMethod)),
-              componentMethod);
+          return ComponentMethodDescriptor.forMembersInjection(
+              componentMethod,
+              dependencyRequestFactory.forComponentMembersInjectionMethod(
+                  componentMethod, resolvedComponentMethod));
         } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.SUBCOMPONENT,
-              Optional.<DependencyRequest>absent(),
-              componentMethod);
-        } else if (isAnnotationPresent(MoreTypes.asElement(returnType),
-            Subcomponent.Builder.class)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.SUBCOMPONENT_BUILDER,
-              Optional.<DependencyRequest>absent(),
-              componentMethod);
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.SUBCOMPONENT, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
         }
       }
 
@@ -336,17 +525,16 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
         switch (componentKind) {
           case COMPONENT:
           case SUBCOMPONENT:
-            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-                ComponentMethodKind.PROVISON,
-                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
-                    resolvedComponentMethod)),
-                componentMethod);
+            return ComponentMethodDescriptor.forProvision(
+                componentMethod,
+                dependencyRequestFactory.forComponentProvisionMethod(
+                    componentMethod, resolvedComponentMethod));
           case PRODUCTION_COMPONENT:
-            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-                ComponentMethodKind.PRODUCTION,
-                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod,
-                    resolvedComponentMethod)),
-                componentMethod);
+          case PRODUCTION_SUBCOMPONENT:
+            return ComponentMethodDescriptor.forProvision(
+                componentMethod,
+                dependencyRequestFactory.forComponentProductionMethod(
+                    componentMethod, resolvedComponentMethod));
           default:
             throw new AssertionError();
         }
@@ -356,12 +544,10 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
       if (parameterTypes.size() == 1
           && (returnType.getKind().equals(VOID)
               || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
-        return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-            ComponentMethodKind.MEMBERS_INJECTION,
-            Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                componentMethod,
-                resolvedComponentMethod)),
-            componentMethod);
+        return ComponentMethodDescriptor.forMembersInjection(
+            componentMethod,
+            dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod, resolvedComponentMethod));
       }
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
@@ -388,6 +574,24 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
       return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
+
+    /**
+     * Returns a descriptor for a generated module that handles monitoring for production
+     * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
+     *
+     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+     *     processor to retry in a later processing round.
+     */
+    private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
+      ClassName monitoringModuleName =
+          SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
+      String generatedMonitorModuleName = monitoringModuleName.toString();
+      TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
+      if (monitoringModule == null) {
+        throw new TypeNotPresentException(generatedMonitorModuleName, null);
+      }
+      return moduleDescriptorFactory.create(monitoringModule);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 1584945ae..379a60236 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,115 +15,39 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
-import dagger.MembersInjector;
-import dagger.internal.Factory;
-import dagger.internal.InstanceFactory;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
-import dagger.internal.SetFactory;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeWriter;
-import dagger.internal.codegen.writer.VoidName;
-import dagger.producers.Producer;
-import dagger.producers.internal.Producers;
-import dagger.producers.internal.SetProducer;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.Binding.bindingPackageFor;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
-
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends JavaWriterSourceFileGenerator<BindingGraph> {
   private final Types types;
+  private final Elements elements;
+  private final Key.Factory keyFactory;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
-    super(filer);
+  ComponentGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType) {
+    super(filer, elements);
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -131,8 +55,7 @@
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
-    String componentName =
-        "Dagger" + componentDefinitionClassName.classFileName().replace('$', '_');
+    String componentName = "Dagger" + componentDefinitionClassName.classFileName('_');
     return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
   }
 
@@ -146,1222 +69,10 @@ ClassName nameGeneratedType(BindingGraph input) {
     return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
-  @AutoValue
-  static abstract class ProxyClassAndField {
-    abstract ClassWriter proxyWriter();
-    abstract FieldWriter proxyFieldWriter();
-
-    static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyFieldWriter) {
-      return new AutoValue_ComponentGenerator_ProxyClassAndField(proxyWriter, proxyFieldWriter);
-    }
-  }
-
-  @AutoValue static abstract class MemberSelect {
-    static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.<TypeName> absent(), owningClass, false, snippet);
-    }
-
-    static MemberSelect staticSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.<TypeName> absent(), owningClass, true, snippet);
-    }
-
-    static MemberSelect staticMethodInvocationWithCast(
-        ClassName owningClass, Snippet snippet, TypeName castType) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.of(castType), owningClass, true, snippet);
-    }
-
-    /**
-     * This exists only to facilitate edge cases in which we need to select a member, but that
-     * member uses a type parameter that can't be inferred.
-     */
-    abstract Optional<TypeName> selectedCast();
-    abstract ClassName owningClass();
-    abstract boolean staticMember();
-    abstract Snippet snippet();
-
-    private Snippet qualifiedSelectSnippet() {
-      return Snippet.format(
-          "%s" + (staticMember() ? "" : ".this") + ".%s",
-          owningClass(), snippet());
-    }
-
-    Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
-      Snippet snippet = getSnippetFor(usingClass);
-      return selectedCast().isPresent()
-          ? Snippet.format("(%s) %s", selectedCast().get(), snippet)
-          : snippet;
-    }
-
-    Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass)
-          ? snippet()
-          : qualifiedSelectSnippet();
-    }
-  }
-
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    TypeElement componentDefinitionType = input.componentDescriptor().componentDefinitionType();
-    ClassName componentDefinitionTypeName =
-        ClassName.fromTypeElement(componentDefinitionType);
-
-    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
-
-    ClassWriter componentWriter = writer.addClass(componentName.simpleName());
-    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
-    componentWriter.addModifiers(PUBLIC, FINAL);
-    checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
-    componentWriter.setSupertype(componentDefinitionType);
-
-    Set<JavaWriter> javaWriters = Sets.newHashSet();
-    javaWriters.add(writer);
-    writeComponent(input, componentDefinitionTypeName, componentWriter, javaWriters);
-
-    return ImmutableSet.copyOf(javaWriters);
-  }
-
-  /**
-   * Writes out a builder for a component or subcomponent.
-   *
-   * @param input the component or subcomponent
-   * @param componentApiName the API name of the component we're building (not our impl)
-   * @param componentImplName the implementation name of the component we're building
-   * @param componentWriter the class we're adding this builder to
-   * @param componentContributionFields a map of member selects so we can later use the fields
-   */
-  private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
-      ClassName componentImplName, ClassWriter componentWriter,
-      Map<TypeElement, MemberSelect> componentContributionFields) {
-    ClassWriter builderWriter;
-    Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
-    switch (input.componentDescriptor().kind()) {
-      case COMPONENT:
-      case PRODUCTION_COMPONENT:
-        builderWriter = componentWriter.addNestedClass("Builder");
-        builderWriter.addModifiers(STATIC);
-
-        // Only top-level components have the factory builder() method.
-        // Mirror the user's builder API type if they had one.
-        MethodWriter builderFactoryMethod = builderSpec.isPresent()
-            ? componentWriter.addMethod(
-                builderSpec.get().builderDefinitionType().asType(), "builder")
-            : componentWriter.addMethod(builderWriter, "builder");
-        builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-        builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
-        break;
-      case SUBCOMPONENT:
-        verify(builderSpec.isPresent()); // we only write subcomponent builders if there was a spec
-        builderWriter =
-            componentWriter.addNestedClass(componentApiName.simpleName() + "Builder");
-        break;
-      default:
-        throw new IllegalStateException();
-    }
-    builderWriter.addModifiers(FINAL);
-    builderWriter.addConstructor().addModifiers(PRIVATE);
-    if (builderSpec.isPresent()) {
-      builderWriter.addModifiers(PRIVATE);
-      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
-    } else {
-      builderWriter.addModifiers(PUBLIC);
-    }
-
-    // the full set of types that calling code uses to construct a component instance
-    ImmutableMap<TypeElement, String> componentContributionNames =
-        ImmutableMap.copyOf(Maps.asMap(
-            input.componentRequirements(),
-            Functions.compose(
-                CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
-                new Function<TypeElement, String>() {
-                  @Override public String apply(TypeElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })));
-
-    MethodWriter buildMethod;
-    if (builderSpec.isPresent()) {
-      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
-      // Note: we don't use the specBuildMethod.getReturnType() as the return type
-      // because it might be a type variable.  We make use of covariant returns to allow
-      // us to return the component type, which will always be valid.
-      buildMethod = builderWriter.addMethod(componentApiName,
-          specBuildMethod.getSimpleName().toString());
-      buildMethod.annotate(Override.class);
-    } else {
-      buildMethod = builderWriter.addMethod(componentApiName, "build");
-    }
-    buildMethod.addModifiers(PUBLIC);
-
-    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
-      TypeElement contributionElement = entry.getKey();
-      String contributionName = entry.getValue();
-      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
-      builderField.addModifiers(PRIVATE);
-      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentImplName, Snippet.format("builder.%s", builderField.name())));
-      if (componentCanMakeNewInstances(contributionElement)) {
-        buildMethod.body()
-            .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  this.%s = new %s();",
-                builderField.name(), ClassName.fromTypeElement(contributionElement))
-            .addSnippet("}");
-      } else {
-        buildMethod.body()
-            .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
-                builderField.name())
-            .addSnippet("}");
-      }
-      MethodWriter builderMethod;
-      boolean returnsVoid = false;
-      if (builderSpec.isPresent()) {
-        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
-        if (method == null) { // no method in the API, nothing to write out.
-          continue;
-        }
-        // If the return type is void, we add a method with the void return type.
-        // Otherwise we use the builderWriter and take advantage of covariant returns
-        // (so that we don't have to worry about setter methods that return type variables).
-        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
-          returnsVoid = true;
-          builderMethod =
-              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
-        } else {
-          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
-        }
-        builderMethod.annotate(Override.class);
-      } else {
-        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
-      }
-      // TODO(gak): Mirror the API's visibility.
-      // (Makes no difference to the user since this class is private,
-      //  but makes generated code prettier.)
-      builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod.body()
-          .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(contributionName))
-          .addSnippet("}")
-          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
-      if (!returnsVoid) {
-        builderMethod.body().addSnippet("return this;");
-      }
-    }
-    buildMethod.body().addSnippet("return new %s(this);", componentImplName);
-    return builderWriter;
-  }
-
-  /** Returns true if the graph has any dependents that can't be automatically constructed. */
-  private boolean requiresUserSuppliedDependents(BindingGraph input) {
-    Set<TypeElement> userRequiredDependents =
-        Sets.filter(input.componentRequirements(), new Predicate<TypeElement>() {
-          @Override public boolean apply(TypeElement input) {
-            return !Util.componentCanMakeNewInstances(input);
-          }
-        });
-    return !userRequiredDependents.isEmpty();
-  }
-
-  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
-      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters) {
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-    ClassWriter builderWriter = writeBuilder(input, componentDefinitionTypeName,
-        componentWriter.name(), componentWriter, componentContributionFields);
-    if (!requiresUserSuppliedDependents(input)) {
-      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().%s();",
-          input.componentDescriptor().builderSpec().isPresent()
-              ? input.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
-              : "build");
-    }
-
-    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
-    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
-    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
-
-    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
-
-    writeFields(input,
-        componentWriter,
-        proxyWriters,
-        memberSelectSnippetsBuilder,
-        multibindingContributionSnippetsBuilder,
-        enumBindingKeysBuilder,
-        packageProxies);
-
-    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
-        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
-    initializeFrameworkTypes(input,
-        componentWriter,
-        constructorWriter,
-        Optional.of(builderWriter.name()),
-        componentContributionFields,
-        memberSelectSnippets,
-        ImmutableMap.<ContributionBinding, Snippet>of(),
-        multibindingContributionSnippets);
-
-    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
-
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
-      writeSubcomponent(componentWriter,
-          MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
-          proxyWriters,
-          memberSelectSnippets,
-          multibindingContributionSnippets,
-          subgraphEntry.getKey(),
-          subgraphEntry.getValue());
-    }
-
-    return memberSelectSnippets;
-  }
-
-  private void writeSubcomponent(ClassWriter componentWriter,
-      DeclaredType containingComponent,
-      Set<JavaWriter> proxyWriters,
-      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ExecutableElement subcomponentFactoryMethod,
-      BindingGraph subgraph) {
-    ClassName subcomponentApiName =
-        ClassName.fromTypeElement(subgraph.componentDescriptor().componentDefinitionType());
-    ClassWriter subcomponentWriter =
-        componentWriter.addNestedClass(subcomponentApiName.simpleName() + "Impl");
-    subcomponentWriter.addModifiers(PRIVATE, FINAL);
-
-    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.body();
-
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
-
-    TypeMirror subcomponentType;
-    MethodWriter componentMethod;
-    Optional<ClassName> builderName;
-    if (subgraph.componentDescriptor().builderSpec().isPresent()) {
-      BuilderSpec spec = subgraph.componentDescriptor().builderSpec().get();
-      subcomponentType = spec.componentType();
-      componentMethod = componentWriter.addMethod(
-          ClassName.fromTypeElement(spec.builderDefinitionType()),
-          subcomponentFactoryMethod.getSimpleName().toString());
-      ClassWriter builderWriter = writeBuilder(subgraph, subcomponentApiName,
-          subcomponentWriter.name(), componentWriter, componentContributionFields);
-      builderName = Optional.of(builderWriter.name());
-      constructorWriter.addParameter(builderWriter, "builder");
-      constructorWriter.body().addSnippet("assert builder != null;");
-      componentMethod.body().addSnippet("return new %s();", builderWriter.name());
-    } else {
-      builderName = Optional.absent();
-      ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(containingComponent, subcomponentFactoryMethod));
-      subcomponentType = resolvedMethod.getReturnType();
-      componentMethod = componentWriter.addMethod(subcomponentType,
-          subcomponentFactoryMethod.getSimpleName().toString());
-      writeSubcomponentWithoutBuilder(subcomponentFactoryMethod,
-          subgraph,
-          subcomponentWriter,
-          constructorWriter,
-          componentContributionFields,
-          subcomponentConstructorParameters,
-          componentMethod,
-          resolvedMethod);
-    }
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
-
-    TypeElement subcomponentElement = MoreTypes.asTypeElement(subcomponentType);
-    checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
-    subcomponentWriter.setSupertype(subcomponentElement);
-
-    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
-
-    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
-    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
-
-    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
-
-    writeFields(subgraph,
-        subcomponentWriter,
-        proxyWriters,
-        memberSelectSnippetsBuilder,
-        multibindingContributionSnippetsBuilder,
-        enumBindingKeysBuilder,
-        packageProxies);
-
-    for (Entry<BindingKey, MemberSelect> parentBindingEntry :
-        parentMemberSelectSnippets.entrySet()) {
-      if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
-        memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
-      }
-    }
-
-    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
-        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
-    initializeFrameworkTypes(subgraph,
-        subcomponentWriter,
-        constructorWriter,
-        builderName,
-        componentContributionFields,
-        memberSelectSnippets,
-        parentMultibindingContributionSnippets,
-        multibindingContributionSnippets);
-
-    writeInterfaceMethods(subgraph, subcomponentWriter, memberSelectSnippets, enumBindingKeys);
-
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
-      writeSubcomponent(subcomponentWriter,
-          MoreTypes.asDeclared(subgraph.componentDescriptor().componentDefinitionType().asType()),
-          proxyWriters,
-          memberSelectSnippets,
-          new ImmutableMap.Builder<ContributionBinding, Snippet>()
-              .putAll(parentMultibindingContributionSnippets)
-              .putAll(multibindingContributionSnippets)
-              .build(),
-          subgraphEntry.getKey(),
-          subgraphEntry.getValue());
-    }
-  }
-
-  private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFactoryMethod,
-      BindingGraph subgraph,
-      ClassWriter subcomponentWriter,
-      ConstructorWriter constructorWriter,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableList.Builder<Snippet> subcomponentConstructorParameters,
-      MethodWriter componentMethod,
-      ExecutableType resolvedMethod) {
-    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
-    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
-    for (int i = 0; i < params.size(); i++) {
-      VariableElement moduleVariable = params.get(i);
-      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
-      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
-      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleTypeElement)) {
-        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-            moduleTypeElement.getSimpleName().toString());
-        FieldWriter contributionField =
-            subcomponentWriter.addField(moduleTypeElement, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(moduleType, actualModuleName);
-        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "if (%s == null) {",
-            "  throw new NullPointerException();",
-            "}"), actualModuleName));
-        constructorWriter.body().addSnippet(
-            Snippet.format("this.%1$s = %1$s;", actualModuleName));
-        MemberSelect moduleSelect = MemberSelect.instanceSelect(
-            subcomponentWriter.name(), Snippet.format(actualModuleName));
-        componentContributionFields.put(moduleTypeElement, moduleSelect);
-        subcomponentConstructorParameters.add(
-            Snippet.format("%s", moduleVariable.getSimpleName()));
-      }
-    }
-
-    ImmutableSet<TypeElement> uninitializedModules =
-        FluentIterable.from(subgraph.componentDescriptor().transitiveModules())
-            .transform(ModuleDescriptor.getModuleElement())
-            .filter(Predicates.not(Predicates.in(componentContributionFields.keySet())))
-            .toSet();
-
-    for (TypeElement moduleType : uninitializedModules) {
-      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-          moduleType.getSimpleName().toString());
-      FieldWriter contributionField =
-          subcomponentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet(
-          Snippet.format("this.%s = new %s();", actualModuleName,
-              ClassName.fromTypeElement(moduleType)));
-      MemberSelect moduleSelect = MemberSelect.instanceSelect(
-          subcomponentWriter.name(), Snippet.format(actualModuleName));
-      componentContributionFields.put(moduleType, moduleSelect);
-    }
-
-    componentMethod.body().addSnippet("return new %s(%s);",
-        subcomponentWriter.name(),
-        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
-  }
-
-  private void writeFields(BindingGraph input,
-      ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
-      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies) {
-    for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
-      writeField(
-          componentWriter,
-          proxyWriters,
-          memberSelectSnippetsBuilder,
-          multibindingContributionSnippetsBuilder,
-          enumBindingKeysBuilder,
-          packageProxies,
-          resolvedBindings);
-    }
-  }
-
-  private void writeField(
-      ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
-      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && resolvedBindings.ownedContributionBindings().isEmpty()
-        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
-            .isMultibinding()) {
-      return;
-    }
-
-    if (resolvedBindings.bindings().size() == 1) {
-      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ContributionBinding contributionBinding =
-            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-        if (!contributionBinding.bindingType().isMultibinding()
-            && (contributionBinding instanceof ProvisionBinding)) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-              && !provisionBinding.scope().isPresent()) {
-            enumBindingKeysBuilder.add(bindingKey);
-            // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticSelect(
-                    factoryNameForProvisionBinding(provisionBinding),
-                    Snippet.format("create()")));
-            return;
-          }
-        }
-      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
-        MembersInjectionBinding membersInjectionBinding =
-            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-          // TODO(gak): refactor to use enumBindingKeys throughout the generator
-          enumBindingKeysBuilder.add(bindingKey);
-          // TODO(gak): suppress the warnings in a reasonable place
-          memberSelectSnippetsBuilder.put(bindingKey,
-              MemberSelect.staticMethodInvocationWithCast(
-                  ClassName.fromClass(MembersInjectors.class),
-                  Snippet.format("noOp()"),
-                  ClassName.fromClass(MembersInjector.class)));
-          return;
-        }
-      }
-    }
-
-    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-        .or(componentWriter.name().packageName());
-
-    final Optional<String> proxySelector;
-    final TypeWriter classWithFields;
-    final Set<Modifier> fieldModifiers;
-
-    if (bindingPackage.equals(componentWriter.name().packageName())) {
-      // no proxy
-      proxySelector = Optional.absent();
-      // component gets the fields
-      classWithFields = componentWriter;
-      // private fields
-      fieldModifiers = EnumSet.of(PRIVATE);
-    } else {
-      // get or create the proxy
-      ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
-      if (proxyClassAndField == null) {
-        JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
-        proxyWriters.add(proxyJavaWriter);
-        ClassWriter proxyWriter =
-            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "_PackageProxy");
-        proxyWriter.annotate(Generated.class)
-            .setValue(ComponentProcessor.class.getCanonicalName());
-        proxyWriter.addModifiers(PUBLIC, FINAL);
-        // create the field for the proxy in the component
-        FieldWriter proxyFieldWriter =
-            componentWriter.addField(proxyWriter.name(),
-                bindingPackage.replace('.', '_') + "_Proxy");
-        proxyFieldWriter.addModifiers(PRIVATE, FINAL);
-        proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
-        proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
-        packageProxies.put(bindingPackage, proxyClassAndField);
-      }
-      // add the field for the member select
-      proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
-      // proxy gets the fields
-      classWithFields = proxyClassAndField.proxyWriter();
-      // public fields in the proxy
-      fieldModifiers = EnumSet.of(PUBLIC);
-    }
-
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-      ImmutableSet<? extends ContributionBinding> contributionBindings =
-          resolvedBindings.contributionBindings();
-      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
-        // note that here we rely on the order of the resolved bindings being from parent to child
-        // otherwise, the numbering wouldn't work
-        int contributionNumber = 0;
-        for (ContributionBinding contributionBinding : contributionBindings) {
-          if (!contributionBinding.isSyntheticBinding()) {
-            contributionNumber++;
-            if (resolvedBindings.ownedBindings().contains(contributionBinding)) {
-              FrameworkField contributionBindingField =
-                  frameworkFieldForSyntheticContributionBinding(
-                        bindingKey, contributionNumber, contributionBinding);
-              FieldWriter contributionField = classWithFields.addField(
-                  contributionBindingField.frameworkType(), contributionBindingField.name());
-              contributionField.addModifiers(fieldModifiers);
-
-              ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
-                  .addAll(proxySelector.asSet())
-                  .add(contributionField.name())
-                  .build();
-              multibindingContributionSnippetsBuilder.put(contributionBinding,
-                  Snippet.memberSelectSnippet(contributionSelectTokens));
-            }
-          }
-        }
-      }
-    }
-
-    FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
-    FieldWriter frameworkField =
-        classWithFields.addField(bindingField.frameworkType(), bindingField.name());
-    frameworkField.addModifiers(fieldModifiers);
-
-    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-        .addAll(proxySelector.asSet())
-        .add(frameworkField.name())
-        .build();
-    memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
-        componentWriter.name(),
-        Snippet.memberSelectSnippet(memberSelectTokens)));
-  }
-
-  private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-    for (ComponentMethodDescriptor componentMethod :
-        input.componentDescriptor().componentMethods()) {
-      if (componentMethod.dependencyRequest().isPresent()) {
-        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement requestElement =
-            MoreElements.asExecutable(interfaceRequest.requestElement());
-        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
-            MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
-            requestElement));
-        MethodSignature signature = MethodSignature.fromExecutableType(
-            requestElement.getSimpleName().toString(),
-            requestType);
-        if (!interfaceMethods.contains(signature)) {
-          interfaceMethods.add(signature);
-          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
-              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(requestType.getReturnType(),
-                      requestElement.getSimpleName().toString());
-          interfaceMethod.annotate(Override.class);
-          interfaceMethod.addModifiers(PUBLIC);
-          BindingKey bindingKey = interfaceRequest.bindingKey();
-          switch(interfaceRequest.kind()) {
-            case MEMBERS_INJECTOR:
-              MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
-              List<? extends VariableElement> parameters = requestElement.getParameters();
-              if (parameters.isEmpty()) {
-                // we're returning the framework type
-                interfaceMethod.body().addSnippet("return %s;",
-                    membersInjectorSelect.getSnippetFor(componentWriter.name()));
-              } else {
-                VariableElement parameter = Iterables.getOnlyElement(parameters);
-                Name parameterName = parameter.getSimpleName();
-                interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(
-                        Iterables.getOnlyElement(requestType.getParameterTypes())),
-                    parameterName.toString());
-                interfaceMethod.body().addSnippet("%s.injectMembers(%s);",
-                    // in this case we know we won't need the cast because we're never going to pass
-                    // the reference to anything
-                    membersInjectorSelect.getSnippetFor(componentWriter.name()),
-                    parameterName);
-                if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
-                }
-              }
-              break;
-            case INSTANCE:
-              if (enumBindingKeys.contains(bindingKey)
-                  && (bindingKey.key().type().getKind().equals(DECLARED)
-                      && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty())) {
-                // If using a parameterized enum type, then we need to store the factory
-                // in a temporary variable, in order to help javac be able to infer
-                // the generics of the Factory.create methods.
-                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                    TypeNames.forTypeMirror(requestType.getReturnType()));
-                interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
-                interfaceMethod.body().addSnippet("return factory.get();");
-                break;
-              }
-              // fall through in the else case.
-            case LAZY:
-            case PRODUCED:
-            case PRODUCER:
-            case PROVIDER:
-            case FUTURE:
-              interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(
-                      memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
-                      interfaceRequest.kind()));
-              break;
-            default:
-              throw new AssertionError();
-          }
-        }
-      }
-    }
-  }
-
-  private void initializeFrameworkTypes(BindingGraph input,
-      ClassWriter componentWriter,
-      ConstructorWriter constructorWriter,
-      Optional<ClassName> builderName,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
-      throws AssertionError {
-    List<List<BindingKey>> partitions = Lists.partition(
-        input.resolvedBindings().keySet().asList(), 100);
-    for (int i = 0; i < partitions.size(); i++) {
-      MethodWriter initializeMethod =
-          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
-      initializeMethod.body();
-      initializeMethod.addModifiers(PRIVATE);
-      if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
-        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
-      } else {
-        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
-      }
-
-      for (BindingKey bindingKey : partitions.get(i)) {
-        Snippet memberSelectSnippet =
-            memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
-        ResolvedBindings resolvedBindings = input.resolvedBindings().get(bindingKey);
-        switch (bindingKey.kind()) {
-          case CONTRIBUTION:
-            ImmutableSet<? extends ContributionBinding> bindings =
-                resolvedBindings.contributionBindings();
-
-            switch (ContributionBinding.bindingTypeFor(bindings)) {
-              case SET:
-                boolean hasOnlyProvisions =
-                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
-                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                for (ContributionBinding binding : bindings) {
-                  if (multibindingContributionSnippets.containsKey(binding)) {
-                    Snippet initializeSnippet = initializeFactoryForContributionBinding(
-                        binding,
-                        input,
-                        componentWriter.name(),
-                        componentContributionFields,
-                        memberSelectSnippets);
-                    Snippet snippet = multibindingContributionSnippets.get(binding);
-                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
-                    parameterSnippets.add(snippet);
-                  } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
-                    parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
-                  } else {
-                    throw new IllegalStateException(binding + " was not found in");
-                  }
-                }
-                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                    hasOnlyProvisions
-                        ? ClassName.fromClass(SetFactory.class)
-                        : ClassName.fromClass(SetProducer.class),
-                    Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeSetSnippet);
-                break;
-              case MAP:
-                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
-                    .isEmpty()) {
-                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
-                  ImmutableSet<ProvisionBinding> provisionBindings =
-                      (ImmutableSet<ProvisionBinding>) bindings;
-                  for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding.key().type())
-                        && multibindingContributionSnippets.containsKey(provisionBinding)) {
-                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          snippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              componentWriter.name(),
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields,
-                              memberSelectSnippets));
-                    }
-                  }
-                  if (!provisionBindings.isEmpty()) {
-                    Snippet initializeMapSnippet = initializeMapBinding(
-                        componentWriter.name(), memberSelectSnippets,
-                        new ImmutableMap.Builder<ContributionBinding, Snippet>()
-                            .putAll(parentMultibindingContributionSnippets)
-                            .putAll(multibindingContributionSnippets)
-                            .build(),
-                        provisionBindings);
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet, initializeMapSnippet);
-                  }
-                } else {
-                  // TODO(user): Implement producer map bindings.
-                  throw new IllegalStateException("producer map bindings not implemented yet");
-                }
-                break;
-              case UNIQUE:
-                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
-                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
-                  if (binding instanceof ProvisionBinding) {
-                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                        || provisionBinding.scope().isPresent()) {
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          memberSelectSnippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              componentWriter.name(),
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields, memberSelectSnippets));
-                    }
-                  } else if (binding instanceof ProductionBinding) {
-                    ProductionBinding productionBinding = (ProductionBinding) binding;
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet,
-                        initializeFactoryForProductionBinding(productionBinding,
-                            input,
-                            componentWriter.name(),
-                            input.componentDescriptor().dependencyMethodIndex(),
-                            componentContributionFields, memberSelectSnippets));
-                  } else {
-                    throw new AssertionError();
-                  }
-                }
-                break;
-              default:
-                throw new IllegalStateException();
-            }
-            break;
-          case MEMBERS_INJECTION:
-            MembersInjectionBinding binding = Iterables.getOnlyElement(
-                resolvedBindings.membersInjectionBindings());
-            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-              initializeMethod.body().addSnippet("this.%s = %s;",
-                  memberSelectSnippet,
-                  initializeMembersInjectorForBinding(
-                      componentWriter.name(), binding, memberSelectSnippets));
-            }
-            break;
-          default:
-            throw new AssertionError();
-        }
-      }
-    }
-  }
-
-  private static FrameworkField frameworkFieldForSyntheticContributionBinding(BindingKey bindingKey,
-      int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
-    switch (contributionBinding.bindingType()) {
-      case MAP:
-        return FrameworkField.createForMapBindingContribution(
-            contributionBinding.frameworkClass(),
-            BindingKey.create(bindingKey.kind(), contributionBinding.key()),
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      case SET:
-        return FrameworkField.createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      case UNIQUE:
-        return FrameworkField.createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.bindingKey().kind()) {
-      case CONTRIBUTION:
-        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-          if (binding instanceof ProductionBinding) {
-            return Producer.class;
-          }
-        }
-        return Provider.class;
-      case MEMBERS_INJECTION:
-        return MembersInjector.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ImmutableSet<? extends ContributionBinding> contributionBindings =
-            resolvedBindings.contributionBindings();
-        BindingType bindingsType = ProvisionBinding.bindingTypeFor(contributionBindings);
-        switch (bindingsType) {
-          case SET:
-          case MAP:
-            return FrameworkField.createWithTypeFromKey(
-                frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
-          case UNIQUE:
-            ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
-            return FrameworkField.createWithTypeFromKey(
-                frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-                  @Override
-                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                    return e.getEnclosingElement().accept(this, null);
-                  }
-
-                  @Override
-                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                    return e.getSimpleName().toString();
-                  }
-
-                  @Override
-                  public String visitType(TypeElement e, Void p) {
-                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                        e.getSimpleName().toString());
-                  }
-                }, null));
-          default:
-            throw new AssertionError();
-        }
-      case MEMBERS_INJECTION:
-        return FrameworkField.createWithTypeFromKey(
-            MembersInjector.class,
-            bindingKey,
-            CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                Iterables.getOnlyElement(resolvedBindings.bindings())
-                .bindingElement().getSimpleName().toString()));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding,
-      BindingGraph input,
-      ClassName componentName,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    if (binding instanceof ProvisionBinding) {
-      return initializeFactoryForProvisionBinding(
-          (ProvisionBinding) binding,
-          componentName,
-          input.componentDescriptor().dependencyMethodIndex(),
-          componentContributionFields,
-          memberSelectSnippets);
-    } else if (binding instanceof ProductionBinding) {
-      return initializeFactoryForProductionBinding(
-          (ProductionBinding) binding,
-          input,
-          componentName,
-          input.componentDescriptor().dependencyMethodIndex(),
-          componentContributionFields,
-          memberSelectSnippets);
-    } else {
-      throw new AssertionError();
-    }
-}
-
-  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
-      ClassName componentName,
-      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, MemberSelect> contributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch(binding.bindingKind()) {
-      case COMPONENT:
-        MemberSelect componentContributionSelect =
-            contributionFields.get(MoreTypes.asTypeElement(binding.key().type()));
-        return Snippet.format("%s.<%s>create(%s)",
-            ClassName.fromClass(InstanceFactory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            componentContributionSelect != null
-                ? componentContributionSelect.getSnippetFor(componentName) : "this");
-      case COMPONENT_PROVISION:
-        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
-        String sourceFieldName =
-            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
-        if (binding.nullableType().isPresent()
-            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
-          Snippet nullableSnippet = binding.nullableType().isPresent()
-              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
-              : Snippet.format("");
-          return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %3$s;",
-            "  %5$s@Override public %2$s get() {",
-            "    return %7$s.%4$s();",
-            "  }",
-            "}"),
-            ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            nullableSnippet,
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-        } else {
-          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          StringLiteral failMsg =
-              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %3$s;",
-            "  @Override public %2$s get() {",
-            "    %2$s provided = %7$s.%4$s();",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(%5$s);",
-            "    }",
-            "    return provided;",
-            "  }",
-            "}"),
-            ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            failMsg,
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-        }
-      case INJECTION:
-      case PROVISION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-        if (binding.bindingKind().equals(PROVISION)
-            && !binding.bindingElement().getModifiers().contains(STATIC)) {
-          parameters.add(contributionFields.get(binding.contributedBy().get())
-              .getSnippetFor(componentName));
-        }
-        parameters.addAll(getDependencyParameters(componentName, binding.implicitDependencies(),
-            memberSelectSnippets));
-
-        Snippet factorySnippet = Snippet.format("%s.create(%s)",
-            factoryNameForProvisionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-        return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s)",
-                ClassName.fromClass(ScopedProvider.class),
-                factorySnippet)
-            : factorySnippet;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
-      BindingGraph bindingGraph,
-      ClassName componentName,
-      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, MemberSelect> contributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch (binding.bindingKind()) {
-      case COMPONENT_PRODUCTION:
-        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
-        String sourceFieldName =
-            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
-        return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %4$s;",
-            "  @Override public %3$s<%2$s> get() {",
-            "    return %7$s.%5$s();",
-            "  }",
-            "}"),
-            ClassName.fromClass(Producer.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            ClassName.fromClass(ListenableFuture.class),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-        parameters.add(contributionFields.get(binding.bindingTypeElement())
-            .getSnippetFor(componentName));
-        parameters.add(contributionFields.get(
-            bindingGraph.componentDescriptor().executorDependency().get())
-                .getSnippetFor(componentName));
-        parameters.addAll(getProducerDependencyParameters(
-            bindingGraph, componentName, binding.dependencies(), memberSelectSnippets));
-
-        return Snippet.format("new %s(%s)",
-            factoryNameForProductionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeMembersInjectorForBinding(
-      ClassName componentName,
-      MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch (binding.injectionStrategy()) {
-      case NO_OP:
-        return Snippet.format("%s.noOp()",
-            ClassName.fromClass(MembersInjectors.class));
-      case DELEGATE:
-        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
-        return Snippet.format("%s.delegatingTo(%s)",
-            ClassName.fromClass(MembersInjectors.class),
-            memberSelectSnippets.get(parentInjectorRequest.bindingKey())
-                .getSnippetFor(componentName));
-      case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(
-            componentName,
-            binding.implicitDependencies(),
-            memberSelectSnippets);
-        return Snippet.format("%s.create(%s)",
-            membersInjectorNameForMembersInjectionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private List<Snippet> getDependencyParameters(
-      ClassName componentName,
-      Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          })
-          .toSet());
-      parameters.add(memberSelectSnippets.get(key).getSnippetWithRawTypeCastFor(componentName));
-    }
-    return parameters.build();
-  }
-
-  private List<Snippet> getProducerDependencyParameters(
-      BindingGraph bindingGraph,
-      ClassName componentName,
-      Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          }));
-      ResolvedBindings resolvedBindings = bindingGraph.resolvedBindings().get(key);
-      Class<?> frameworkClass =
-          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
-          && frameworkClass.equals(Producer.class)) {
-        parameters.add(Snippet.format(
-            "%s.producerFromProvider(%s)",
-            ClassName.fromClass(Producers.class),
-            memberSelectSnippets.get(key).getSnippetFor(componentName)));
-      } else {
-        parameters.add(memberSelectSnippets.get(key).getSnippetFor(componentName));
-      }
-    }
-    return parameters.build();
-  }
-
-  private Snippet initializeMapBinding(
-      ClassName componentName,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
-      Set<ProvisionBinding> bindings) {
-    // Get type information from the first binding.
-    ProvisionBinding firstBinding = bindings.iterator().next();
-    DeclaredType mapType = asDeclared(firstBinding.key().type());
-
-    if (isNonProviderMap(mapType)) {
-      return Snippet.format(
-          "%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets
-              .get(getOnlyElement(firstBinding.dependencies()).bindingKey())
-              .getSnippetFor(componentName));
-    }
-
-    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
-        ImmutableList.builder();
-    snippets.add(
-        Snippet.format(
-            "%s.<%s, %s>builder(%d)",
-            ClassName.fromClass(MapProviderFactory.class),
-            TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
-            TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
-            bindings.size()));
-
-    for (ProvisionBinding binding : bindings) {
-      snippets.add(
-          Snippet.format(
-              "    .put(%s, %s)",
-              getMapKeySnippet(binding.bindingElement()),
-              multibindingContributionSnippets.get(binding)));
-    }
-
-    snippets.add(Snippet.format("    .build()"));
-
-    return Snippet.join(Joiner.on('\n'), snippets.build());
-  }
-
-  private boolean isNonProviderMap(TypeMirror type) {
-    return MoreTypes.isTypeOf(Map.class, type) // Implicitly guarantees a declared type.
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
+    return new ComponentWriter(
+            types, elements, keyFactory, nullableValidationType, componentName, input)
+        .write();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
new file mode 100644
index 000000000..3a09e8cba
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.Map;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+import static com.google.common.base.Functions.constant;
+
+/**
+ * Validates the relationships between parent components and subcomponents.
+ */
+final class ComponentHierarchyValidator {
+  ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
+    return validateSubcomponentMethods(
+        componentDescriptor,
+        Maps.toMap(
+            componentDescriptor.transitiveModuleTypes(),
+            constant(componentDescriptor.componentDefinitionType())));
+  }
+
+  private ValidationReport<TypeElement> validateSubcomponentMethods(
+      ComponentDescriptor componentDescriptor,
+      Map<TypeElement, TypeElement> existingModuleToOwners) {
+    ValidationReport.Builder<TypeElement> reportBuilder =
+        ValidationReport.about(componentDescriptor.componentDefinitionType());
+    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
+        componentDescriptor.subcomponents().entrySet()) {
+      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
+      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
+      // validate the way that we create subcomponents
+      switch (subcomponentMethodDescriptor.kind()) {
+        case SUBCOMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
+          for (VariableElement factoryMethodParameter :
+              subcomponentMethodDescriptor.methodElement().getParameters()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(
+                    MoreTypes.asTypeElement(factoryMethodParameter.asType()));
+            if (origininatingComponent != null) {
+              /* Factory method tries to pass a module that is already present in the parent.
+               * This is an error. */
+              reportBuilder.addError(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent.",
+                      origininatingComponent.getQualifiedName()),
+                  factoryMethodParameter);
+            }
+          }
+          break;
+        case SUBCOMPONENT_BUILDER:
+        case PRODUCTION_SUBCOMPONENT_BUILDER:
+          BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
+          for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+              subcomponentBuilderSpec.methodMap().entrySet()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(builderMethodEntry.getKey());
+            if (origininatingComponent != null) {
+              /* A subcomponent builder allows you to pass a module that is already present in the
+               * parent.  This can't be an error because it might be valid in _other_ components, so
+               * we warn here. */
+              ExecutableElement builderMethodElement = builderMethodEntry.getValue();
+              /* TODO(gak): consider putting this on the builder method directly if it's in the
+               * component being compiled */
+              reportBuilder.addWarning(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent. The implementation of %s "
+                          + "in this component will throw %s.",
+                      origininatingComponent.getQualifiedName(),
+                      builderMethodElement.getSimpleName(),
+                      UnsupportedOperationException.class.getSimpleName()),
+                  builderMethodElement);
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+      reportBuilder.addSubreport(
+          validateSubcomponentMethods(
+              subcomponentDescriptor,
+              new ImmutableMap.Builder<TypeElement, TypeElement>()
+                  .putAll(existingModuleToOwners)
+                  .putAll(
+                      Maps.toMap(
+                          Sets.difference(
+                              subcomponentDescriptor.transitiveModuleTypes(),
+                              existingModuleToOwners.keySet()),
+                          constant(subcomponentDescriptor.componentDefinitionType())))
+                  .build()));
+    }
+    return reportBuilder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 18636fe18..8a4feddac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,116 +17,163 @@
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic.Kind;
 
 /**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * A {@link ProcessingStep} that is responsible for dealing with a component or production component
  * as part of the {@link ComponentProcessor}.
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep extends AbstractComponentProcessingStep {
+final class ComponentProcessingStep implements ProcessingStep {
+  private final ComponentDescriptor.Kind componentKind;
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentValidator subcomponentValidator;
-  private final BuilderValidator componentBuilderValidator;
-  private final BuilderValidator subcomponentBuilderValidator;
+  private final BuilderValidator builderValidator;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
 
   ComponentProcessingStep(
+      ComponentDescriptor.Kind componentKind,
       Messager messager,
       ComponentValidator componentValidator,
       ComponentValidator subcomponentValidator,
-      BuilderValidator componentBuilderValidator,
-      BuilderValidator subcomponentBuilderValidator,
+      BuilderValidator builderValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
-    super(
-        messager,
-        bindingGraphValidator,
-        bindingGraphFactory,
-        componentGenerator);
+    this.componentKind = componentKind;
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
-    this.componentBuilderValidator = componentBuilderValidator;
-    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+    this.builderValidator = builderValidator;
+    this.componentHierarchyValidator = componentHierarchyValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
-        Subcomponent.class, Subcomponent.Builder.class);
+    return ImmutableSet.of(
+        Component.class,
+        Component.Builder.class,
+        ProductionComponent.class,
+        ProductionComponent.Builder.class,
+        Subcomponent.class,
+        Subcomponent.Builder.class,
+        ProductionSubcomponent.class,
+        ProductionSubcomponent.Builder.class);
   }
 
   @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+  public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
+
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
-    Set<Element> subcomponentBuilderElements = elementsByAnnotation.get(Subcomponent.Builder.class);
+        processBuilders(elementsByAnnotation.get(componentKind.builderAnnotationType()));
+    Set<Element> subcomponentBuilderElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                .toSet());
     Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processSubcomponentBuilders(subcomponentBuilderElements);
-    Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+        processBuilders(subcomponentBuilderElements);
+    Set<Element> subcomponentElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toAnnotationType())
+                .toSet());
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-    Set<Element> componentElements = elementsByAnnotation.get(Component.class);
 
-    ImmutableSet.Builder<ComponentDescriptor> builder = ImmutableSet.builder();
-    for (Element element : componentElements) {
+    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
       TypeElement componentTypeElement = MoreElements.asType(element);
-      ComponentValidationReport report = componentValidator.validate(
-          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      if (isClean(
-          report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
-        try {
-          builder.add(componentDescriptorFactory.forComponent(componentTypeElement));
-        } catch (TypeNotPresentException e) {
-          // just skip it and get it later
+      try {
+        ComponentValidationReport validationReport =
+            componentValidator.validate(
+                componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+        validationReport.report().printMessagesTo(messager);
+        if (isClean(
+            validationReport,
+            builderReportsByComponent,
+            reportsBySubcomponent,
+            builderReportsBySubcomponent)) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(componentTypeElement);
+          ValidationReport<TypeElement> hierarchyReport =
+              componentHierarchyValidator.validate(componentDescriptor);
+          hierarchyReport.printMessagesTo(messager);
+          if (hierarchyReport.isClean()) {
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            ValidationReport<TypeElement> graphReport =
+                bindingGraphValidator.validate(bindingGraph);
+            graphReport.printMessagesTo(messager);
+            if (graphReport.isClean()) {
+              generateComponent(bindingGraph);
+            }
+          }
         }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentTypeElement);
       }
     }
-    return builder.build();
+    return rejectedElements.build();
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
-      Set<? extends Element> componentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : componentBuilderElements) {
-      ValidationReport<TypeElement> report =
-          componentBuilderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
+  private void generateComponent(BindingGraph bindingGraph) {
+    try {
+      componentGenerator.generate(bindingGraph);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
     }
-    return builderReportsByComponent;
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
-      Set<? extends Element> subcomponentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
-    for (Element element : subcomponentBuilderElements) {
+  private ImmutableSet<Element> getElementsFromAnnotations(
+      final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
+      ImmutableSet<Class<? extends Annotation>> annotations) {
+    return ImmutableSet.copyOf(
+        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processBuilders(
+      Set<? extends Element> builderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : builderElements) {
       ValidationReport<TypeElement> report =
-          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+          builderValidator.validate(MoreElements.asType(element));
       report.printMessagesTo(messager);
-      builderReportsBySubcomponent.put(element, report);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
     }
-    return builderReportsBySubcomponent;
+    return builderReportsByComponent;
   }
 
   private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3152c3fd1..d67214d68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -17,12 +17,9 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -61,12 +58,14 @@ public SourceVersion getSupportedSourceVersion() {
   public Set<String> getSupportedOptions() {
     return ImmutableSet.of(
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        NULLABLE_VALIDATION_KEY
+        NULLABLE_VALIDATION_KEY,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY
     );
   }
 
   @Override
-  protected Iterable<ProcessingStep> initSteps() {
+  protected Iterable<? extends ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -76,96 +75,110 @@ public SourceVersion getSupportedSourceVersion() {
         nullableValidationType(processingEnv).diagnosticKind().get();
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    ProvisionBindingFormatter provisionBindingFormatter =
-        new ProvisionBindingFormatter(methodSignatureFormatter);
-    ProductionBindingFormatter productionBindingFormatter =
-        new ProductionBindingFormatter(methodSignatureFormatter);
+    HasSourceElementFormatter hasSourceElementFormatter =
+        new HasSourceElementFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
     KeyFormatter keyFormatter = new KeyFormatter();
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
-    InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
-    InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
-        Module.class, Provides.class);
-    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    BuilderValidator componentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
-    BuilderValidator subcomponentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
-    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
-        types, moduleValidator, subcomponentBuilderValidator);
-    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
-        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    MembersInjectedTypeValidator membersInjectedTypeValidator =
+        new MembersInjectedTypeValidator(injectFieldValidator, injectMethodValidator);
+    ModuleValidator moduleValidator =
+        new ModuleValidator(types, elements, methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+            elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
-        methodSignatureFormatter, ProducerModule.class, Produces.class);
-    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
-    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
+    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
+    MultibindingsValidator multibindingsValidator =
+        new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
+
     this.factoryGenerator =
-        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
+        new FactoryGenerator(
+            filer, elements, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, elements, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, types, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
+        new ProducerFactoryGenerator(filer, elements, DependencyRequestMapper.FOR_PRODUCER);
+    MonitoringModuleGenerator monitoringModuleGenerator =
+        new MonitoringModuleGenerator(filer, elements);
 
-    DependencyRequest.Factory dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+    MultibindingDeclaration.Factory multibindingDeclarationFactory =
+        new MultibindingDeclaration.Factory(elements, types, keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
-    this.injectBindingRegistry = new InjectBindingRegistry(
-        elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
+    this.injectBindingRegistry =
+        new InjectBindingRegistry(
+            elements,
+            types,
+            messager,
+            injectConstructorValidator,
+            membersInjectedTypeValidator,
+            keyFactory,
+            provisionBindingFactory,
+            membersInjectionBindingFactory);
 
-    ModuleDescriptor.Factory moduleDescriptorFactory = new ModuleDescriptor.Factory(
-        elements, provisionBindingFactory, productionBindingFactory);
+    ModuleDescriptor.Factory moduleDescriptorFactory =
+        new ModuleDescriptor.Factory(
+            elements,
+            provisionBindingFactory,
+            productionBindingFactory,
+            multibindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements,
-        injectBindingRegistry,
-        keyFactory,
-        dependencyRequestFactory,
-        provisionBindingFactory,
-        productionBindingFactory);
-
-    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
-        types,
-        injectBindingRegistry,
-        scopeValidationType(processingEnv),
-        nullableDiagnosticType,
-        provisionBindingFormatter,
-        productionBindingFormatter,
-        methodSignatureFormatter,
-        dependencyRequestFormatter,
-        keyFormatter);
-
-    return ImmutableList.<ProcessingStep>of(
-        new MapKeyProcessingStep(
-            messager,
-            types,
-            mapKeyValidator,
-            mapKeyGenerator),
-        new InjectProcessingStep(
-            messager,
-            injectConstructorValidator,
-            injectFieldValidator,
-            injectMethodValidator,
+    BindingGraph.Factory bindingGraphFactory =
+        new BindingGraph.Factory(
+            elements,
+            injectBindingRegistry,
+            keyFactory,
             provisionBindingFactory,
-            membersInjectionBindingFactory,
-            injectBindingRegistry),
+            productionBindingFactory);
+
+    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer, elements);
+    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
+    BindingGraphValidator bindingGraphValidator =
+        new BindingGraphValidator(
+            types,
+            injectBindingRegistry,
+            scopeValidationType(processingEnv),
+            nullableDiagnosticType,
+            hasSourceElementFormatter,
+            methodSignatureFormatter,
+            dependencyRequestFormatter,
+            keyFormatter,
+            keyFactory);
+
+    return ImmutableList.of(
+        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
+        new InjectProcessingStep(injectBindingRegistry),
+        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new MultibindingsProcessingStep(messager, multibindingsValidator),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
@@ -173,24 +186,29 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             factoryGenerator),
         new ComponentProcessingStep(
+            ComponentDescriptor.Kind.COMPONENT,
             messager,
             componentValidator,
             subcomponentValidator,
-            componentBuilderValidator,
-            subcomponentBuilderValidator,
+            builderValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
             componentGenerator),
         new ProducerModuleProcessingStep(
             messager,
-            producerModuleValidator,
+            moduleValidator,
             producesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
-        new ProductionComponentProcessingStep(
+        new ComponentProcessingStep(
+            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
-            productionComponentValidator,
+            componentValidator,
+            subcomponentValidator,
+            builderValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -212,6 +230,12 @@ protected void postProcess() {
 
   private static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
 
+  private static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY =
+      "dagger.privateMemberValidation";
+
+  private static final String STATIC_MEMBER_VALIDATION_TYPE_KEY =
+      "dagger.staticMemberValidation";
+
   private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
     return valueOf(processingEnv,
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
@@ -226,12 +250,28 @@ private static ValidationType nullableValidationType(ProcessingEnvironment proce
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
+  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(processingEnv,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(processingEnv,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
   private static <T extends Enum<T>> T valueOf(ProcessingEnvironment processingEnv, String key,
       T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
     if (options.containsKey(key)) {
       try {
-        T type = Enum.valueOf(defaultValue.getDeclaringClass(), options.get(key).toUpperCase());
+        T type = Enum.valueOf(
+            defaultValue.getDeclaringClass(),
+            Ascii.toUpperCase(options.get(key)));
         if (!validValues.contains(type)) {
           throw new IllegalArgumentException(); // let handler below print out good msg.
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index a2a5eac22..0be4686a9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -18,9 +18,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -28,10 +26,8 @@
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
-import com.google.common.collect.Sets.SetView;
 import dagger.Component;
-import dagger.Module;
-import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -54,21 +50,20 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} annotation.
+ * Performs superficial validation of the contract of the {@link Component} and
+ * {@link ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
 final class ComponentValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
@@ -79,7 +74,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = this;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -92,7 +86,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -103,21 +96,15 @@ static ComponentValidator createForComponent(Elements elements,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(
+        elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(elements, types, moduleValidator, subcomponentBuilderValidator);
   }
 
   @AutoValue
@@ -133,19 +120,25 @@ static ComponentValidator createForSubcomponent(Elements elements,
   public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
-          componentType.annotationType().getSimpleName()), subject);
+      builder.addError(
+          String.format(
+              "@%s may only be applied to an interface or abstract class",
+              componentKind.annotationType().getSimpleName()),
+          subject);
     }
 
     ImmutableList<DeclaredType> builders =
-        enclosedBuilders(subject, componentType.builderAnnotationType());
+        enclosedBuilders(subject, componentKind.builderAnnotationType());
     if (builders.size() > 1) {
-      builder.addItem(
-          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+      builder.addError(
+          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
@@ -166,12 +159,23 @@ public ComponentValidationReport validate(final TypeElement subject,
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
         Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotation(returnType, Subcomponent.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toAnnotationType())
+                    .toSet());
         Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotation(returnType, Subcomponent.Builder.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                    .toSet());
         if (subcomponentAnnotation.isPresent()) {
           referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(builder,
+          validateSubcomponentMethod(
+              builder,
+              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
+                  .get(),
               method,
               parameters,
               parameterTypes,
@@ -197,16 +201,16 @@ public ComponentValidationReport validate(final TypeElement subject,
               TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
               if (!(returnType.getKind().equals(VOID)
                   || types.isSameType(returnType, onlyParameter))) {
-                builder.addItem(
-                    "Members injection methods may only return the injected type or void.",
-                    method);
+                builder.addError(
+                    "Members injection methods may only return the injected type or void.", method);
               }
               break;
             default:
               // this isn't any method that we know how to implement...
-              builder.addItem(
+              builder.addError(
                   "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method", method);
+                      + "subcomponent factory method. Dagger cannot implement this method",
+                  method);
               break;
           }
         }
@@ -216,18 +220,20 @@ public ComponentValidationReport validate(final TypeElement subject,
     for (Map.Entry<Element, Collection<ExecutableElement>> entry :
         referencedSubcomponents.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
-        builder.addItem(
+        builder.addError(
             String.format(
                 ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(), entry.getValue()),
+                entry.getKey(),
+                entry.getValue()),
             subject);
       }
     }
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentType.annotationType()).get();
+        getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
+    moduleValidator.validateReferencedModules(
+        subject, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -248,7 +254,9 @@ public ComponentValidationReport validate(final TypeElement subject,
         builder.build());
   }
 
-  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+  private void validateSubcomponentMethod(
+      final ValidationReport.Builder<TypeElement> builder,
+      final ComponentDescriptor.Kind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -260,45 +268,46 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
     // subcomponents and their modules separately from how it is done in ComponentDescriptor and
     // ModuleDescriptor
+    @SuppressWarnings("deprecation")
     ImmutableSet<TypeElement> transitiveModules =
         getTransitiveModules(types, elements, moduleTypes);
 
-    ImmutableSet<TypeElement> requiredModules =
-        FluentIterable.from(transitiveModules)
-            .filter(new Predicate<TypeElement>() {
-              @Override public boolean apply(TypeElement input) {
-                return !componentCanMakeNewInstances(input);
-              }
-            })
-            .toSet();
-
     Set<TypeElement> variableTypes = Sets.newHashSet();
 
     for (int i = 0; i < parameterTypes.size(); i++) {
       VariableElement parameter = parameters.get(i);
       TypeMirror parameterType = parameterTypes.get(i);
-      Optional<TypeElement> moduleType = parameterType.accept(
-          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
-            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-              return Optional.absent();
-            }
+      Optional<TypeElement> moduleType =
+          parameterType.accept(
+              new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+                @Override
+                protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+                  return Optional.absent();
+                }
 
-            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
-                  ? Optional.of(MoreTypes.asTypeElement(t))
-                  : Optional.<TypeElement>absent();
-            }
-          }, null);
+                @Override
+                public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
+                    if (MoreElements.isAnnotationPresent(
+                        t.asElement(), moduleKind.moduleAnnotation())) {
+                      return Optional.of(MoreTypes.asTypeElement(t));
+                    }
+                  }
+                  return Optional.absent();
+                }
+              },
+              null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "A module may only occur once an an argument in a Subcomponent factory "
                       + "method, but %s was already passed.",
-                  moduleType.get().getQualifiedName()), parameter);
+                  moduleType.get().getQualifiedName()),
+              parameter);
         }
         if (!transitiveModules.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "%s is present as an argument to the %s factory method, but is not one of the"
                       + " modules used to implement the subcomponent.",
@@ -308,25 +317,13 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
         }
         variableTypes.add(moduleType.get());
       } else {
-        builder.addItem(
+        builder.addError(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
                 parameterType),
             parameter);
       }
     }
-
-    SetView<TypeElement> missingModules =
-        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
-    if (!missingModules.isEmpty()) {
-      builder.addItem(
-          String.format(
-              "%s requires modules which have no visible default constructors. "
-                  + "Add the following modules as parameters to this method: %s",
-              MoreTypes.asTypeElement(returnType).getQualifiedName(),
-              Joiner.on(", ").join(missingModules)),
-          method);
-    }
   }
 
   private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
@@ -334,7 +331,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
-      builder.addItem(
+      builder.addError(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
@@ -348,18 +345,27 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
-      final Class<? extends Annotation> annotation) {
-    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-      @Override
-      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-        return Optional.absent();
-      }
+  private Optional<AnnotationMirror> checkForAnnotations(
+      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
+    return type.accept(
+        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+          @Override
+          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+            return Optional.absent();
+          }
 
-      @Override
-      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
-      }
-    }, null);
+          @Override
+          public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+            for (Class<? extends Annotation> annotation : annotations) {
+              Optional<AnnotationMirror> mirror =
+                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
+              if (mirror.isPresent()) {
+                return mirror;
+              }
+            }
+            return Optional.absent();
+          }
+        },
+        null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
new file mode 100644
index 000000000..aeab5a746
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.annotation.Generated;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Creates the implementation class for a component.
+ */
+final class ComponentWriter extends AbstractComponentWriter {
+
+  ComponentWriter(
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
+    super(
+        types,
+        elements,
+        keyFactory,
+        nullableValidationType,
+        name,
+        graph,
+        new UniqueSubcomponentNamesGenerator(graph).generate());
+  }
+
+  /**
+   * Generates a map of unique simple names for all subcomponents, keyed by their {@link
+   * ComponentDescriptor}.
+   */
+  private static class UniqueSubcomponentNamesGenerator {
+
+    private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
+    private static final Joiner QUALIFIED_NAME_JOINER = Joiner.on('_');
+
+    private final BindingGraph graph;
+    private final ImmutableListMultimap<String, ComponentDescriptor>
+        componentDescriptorsBySimpleName;
+    private final ImmutableListMultimap<ComponentDescriptor, String> componentQualifiedNamePieces;
+
+    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
+      this.graph = graph;
+      componentDescriptorsBySimpleName =
+          Multimaps.index(
+              graph.componentDescriptors(),
+              new Function<ComponentDescriptor, String>() {
+                @Override
+                public String apply(ComponentDescriptor componentDescriptor) {
+                  return componentDescriptor.componentDefinitionType().getSimpleName().toString();
+                }
+              });
+      componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
+    }
+
+    private ImmutableBiMap<ComponentDescriptor, String> generate() {
+      Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
+      for (Entry<String, Collection<ComponentDescriptor>> componentEntry :
+          componentDescriptorsBySimpleName.asMap().entrySet()) {
+        Collection<ComponentDescriptor> components = componentEntry.getValue();
+        subcomponentImplSimpleNames.putAll(disambiguateConflictingSimpleNames(components));
+      }
+      subcomponentImplSimpleNames.remove(graph.componentDescriptor());
+      return ImmutableBiMap.copyOf(subcomponentImplSimpleNames);
+    }
+
+    private ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
+        Collection<ComponentDescriptor> components) {
+      Map<String, ComponentDescriptor> generatedSimpleNames = new LinkedHashMap<>();
+      // The ending condition is when there is a unique simple name generated for every element
+      // in components. The sizes should be equivalent (with one generated name per component).
+      for (int levels = 0; generatedSimpleNames.size() != components.size(); levels++) {
+        generatedSimpleNames.clear();
+        for (ComponentDescriptor component : components) {
+          List<String> pieces = componentQualifiedNamePieces.get(component);
+          String simpleName =
+              QUALIFIED_NAME_JOINER.join(
+                      pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()))
+                  + "Impl";
+          ComponentDescriptor conflict = generatedSimpleNames.put(simpleName, component);
+          if (conflict != null) {
+            // if the map previously contained an entry for the same simple name, stop early since
+            // 2+ subcomponent descriptors will have the same simple name
+            break;
+          }
+        }
+      }
+      return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();
+    }
+
+    private static ImmutableListMultimap<ComponentDescriptor, String> qualifiedNames(
+        Iterable<ComponentDescriptor> componentDescriptors) {
+      ImmutableListMultimap.Builder<ComponentDescriptor, String> builder =
+          ImmutableListMultimap.builder();
+      for (ComponentDescriptor component : componentDescriptors) {
+        Name qualifiedName = component.componentDefinitionType().getQualifiedName();
+        builder.putAll(component, QUALIFIED_NAME_SPLITTER.split(qualifiedName));
+      }
+      return builder.build();
+    }
+  }
+
+  @Override
+  protected ClassWriter createComponentClass() {
+    JavaWriter javaWriter = JavaWriter.inPackage(name.packageName());
+    javaWriters.add(javaWriter);
+
+    ClassWriter componentWriter = javaWriter.addClass(name.simpleName());
+    componentWriter.addModifiers(PUBLIC, FINAL);
+    componentWriter.setSupertype(componentDefinitionType());
+    return componentWriter;
+  }
+
+  @Override
+  protected ClassWriter createBuilder() {
+    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
+    builderWriter.addModifiers(STATIC);
+
+    // Only top-level components have the factory builder() method.
+    // Mirror the user's builder API type if they had one.
+    MethodWriter builderFactoryMethod =
+        graph.componentDescriptor().builderSpec().isPresent()
+            ? componentWriter.addMethod(
+                graph
+                    .componentDescriptor()
+                    .builderSpec()
+                    .get()
+                    .builderDefinitionType()
+                    .asType(),
+                "builder")
+            : componentWriter.addMethod(builderWriter, "builder");
+    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+    return builderWriter;
+  }
+
+  @Override
+  protected void addFactoryMethods() {
+    if (canInstantiateAllRequirements()) {
+      MethodWriter factoryMethod =
+          componentWriter.addMethod(componentDefinitionTypeName(), "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod
+          .body()
+          .addSnippet(
+              "return builder().%s();",
+              graph.componentDescriptor().builderSpec().isPresent()
+                  ? graph
+                      .componentDescriptor()
+                      .builderSpec()
+                      .get()
+                      .buildMethod()
+                      .getSimpleName()
+                  : "build");
+    }
+  }
+
+  /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
+  private boolean canInstantiateAllRequirements() {
+    return Iterables.all(
+        graph.componentRequirements(),
+        new Predicate<TypeElement>() {
+          @Override
+          public boolean apply(TypeElement dependency) {
+            return componentCanMakeNewInstances(dependency);
+          }
+        });
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 50e343543..a9f1ffa35 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -26,9 +26,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Module;
-import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
@@ -45,7 +43,6 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
@@ -60,11 +57,6 @@
  */
 final class ConfigurationAnnotations {
 
-  static boolean isComponent(TypeElement componentDefinitionType) {
-    return MoreElements.isAnnotationPresent(componentDefinitionType, Component.class)
-        || MoreElements.isAnnotationPresent(componentDefinitionType, ProductionComponent.class);
-  }
-
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
@@ -203,23 +195,6 @@ protected TypeMirror defaultAction(Object o, Void p) {
     return builders.build();
   }
 
-  static boolean isSubcomponentType(TypeMirror type) {
-    return type.accept(new SubcomponentDetector(), null).isPresent();
-  }
-
-  private static final class SubcomponentDetector
-      extends SimpleTypeVisitor6<Optional<AnnotationMirror>, Void> {
-    @Override
-    protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-      return Optional.absent();
-    }
-
-    @Override
-    public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-      return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
-    }
-  }
-
   /** Traverses includes from superclasses and adds them into the builder. */
   private static void addIncludesFromSuperclasses(Types types, TypeElement element,
       ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 0630dfc7d..dbe84067d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -15,18 +15,32 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Ordering;
-import java.util.EnumSet;
+import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
 import java.util.Set;
-import javax.inject.Provider;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -35,22 +49,19 @@
  * @author Jesse Beder
  * @since 2.0
  */
-abstract class ContributionBinding extends Binding {
-  static enum BindingType {
-    /** Represents map bindings. */
-    MAP,
-    /** Represents set bindings. */
-    SET,
-    /** Represents a valid non-collection binding. */
-    UNIQUE;
-
-    boolean isMultibinding() {
-      return !this.equals(UNIQUE);
+abstract class ContributionBinding extends Binding implements HasContributionType {
+
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
+    if (!membersInjectionRequest().isPresent()) {
+      return dependencies();
+    } else {
+      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
+      return Sets.union(membersInjectionRequest().asSet(), dependencies());
     }
   }
-
-  abstract BindingType bindingType();
-
+  
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -60,53 +71,158 @@ boolean isMultibinding() {
    * binding's enclosed element, as this will return the subclass whereas the enclosed element will
    * be the superclass.
    */
-  abstract Optional<TypeElement> contributedBy();
+  Optional<TypeElement> contributedBy() {
+    return sourceElement().contributedBy();
+  }
 
   /**
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
    */
-  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
-  // this field the source of truth for synthetic bindings.
-  abstract boolean isSyntheticBinding();
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_MAP);
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
 
   /**
-   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
-   * ProvisionBinding.
+   * The kind of contribution this binding represents. Defines which elements can specify this kind
+   * of contribution.
    */
-  abstract Class<?> frameworkClass();
+  enum Kind {
+    /**
+     * The synthetic binding for {@code Map<K, V>} that depends on either
+     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
+     */
+    SYNTHETIC_MAP,
+
+    // Provision kinds
+
+    /** An {@link Inject}-annotated constructor. */
+    INJECTION,
+
+    /** A {@link Provides}-annotated method. */
+    PROVISION,
+
+    /** An implicit binding to a {@link Component @Component}-annotated type. */
+    COMPONENT,
+
+    /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
+    COMPONENT_PROVISION,
+
+    /**
+     * A subcomponent builder method on a component or subcomponent.
+     */
+    SUBCOMPONENT_BUILDER,
+
+    // Production kinds
+
+    /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
+    IMMEDIATE,
+
+    /** A {@link Produces}-annotated method that returns a {@link ListenableFuture}. */
+    FUTURE_PRODUCTION,
+
+    /**
+     * A production method on a production component's
+     * {@linkplain ProductionComponent#dependencies() dependency} that returns a
+     * {@link ListenableFuture}. Methods on production component dependencies that don't return a
+     * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
+     */
+    COMPONENT_PRODUCTION,
+  }
 
   /**
-   * Returns the set of {@link BindingType} enum values implied by a given
-   * {@link ContributionBinding} collection.
+   * The kind of this contribution binding.
    */
-  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
-      Iterable<? extends B> bindings) {
-    ImmutableListMultimap.Builder<BindingType, B> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<BindingType>natural());
-    for (B binding : bindings) {
-      builder.put(binding.bindingType(), binding);
-    }
-    return builder.build();
+  protected abstract Kind bindingKind();
+  
+  /**
+   * A predicate that passes for bindings of a given kind.
+   */
+  static Predicate<ContributionBinding> isOfKind(final Kind kind) {
+    return new Predicate<ContributionBinding>() {
+      @Override
+      public boolean apply(ContributionBinding binding) {
+        return binding.bindingKind().equals(kind);
+      }};
+  }
+
+  /** The provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
+
+  @Override
+  public ContributionType contributionType() {
+    return ContributionType.forProvisionType(provisionType());
   }
 
   /**
-   * Returns a single {@code BindingsType} represented by a given collection of
-   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
-   * are not all of one type.
+   * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
-  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
-    checkNotNull(bindings);
-    checkArgument(!Iterables.isEmpty(bindings), "no bindings");
-    Set<BindingType> types = EnumSet.noneOf(BindingType.class);
-    for (ContributionBinding binding : bindings) {
-      types.add(binding.bindingType());
-    }
-    if (types.size() > 1) {
-      throw new IllegalArgumentException(
-          String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+  enum FactoryCreationStrategy {
+    /** The factory class is an enum with one value named {@code INSTANCE}. */
+    ENUM_INSTANCE,
+    /** The factory must be created by calling the constructor. */
+    CLASS_CONSTRUCTOR,
+  }
+
+  /**
+   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
+   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
+   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   */
+  FactoryCreationStrategy factoryCreationStrategy() {
+    switch (bindingKind()) {
+      case PROVISION:
+        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      case INJECTION:
+        return implicitDependencies().isEmpty()
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      default:
+        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
     }
-    return Iterables.getOnlyElement(types);
+  }
+
+  /**
+   * Indexes map-multibindings by map key (the result of calling
+   * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
+   * itself, depending on {@link MapKey#unwrapValue()}).
+   */
+  static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
+      Set<ContributionBinding> mapBindings) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Object>() {
+              @Override
+              public Object apply(ContributionBinding mapBinding) {
+                AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+                Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+                return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
+              }
+            }));
+  }
+
+  /**
+   * Indexes map-multibindings by map key annotation type.
+   */
+  static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
+      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Equivalence.Wrapper<DeclaredType>>() {
+              @Override
+              public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
+                return MoreTypes.equivalence()
+                    .wrap(getMapKey(mapBinding.bindingElement()).get().getAnnotationType());
+              }
+            }));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
new file mode 100644
index 000000000..a1033932a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Multimaps;
+
+/**
+ * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
+ */
+enum ContributionType {
+  /** Represents map bindings. */
+  MAP,
+  /** Represents set bindings. */
+  SET,
+  /** Represents a valid non-collection binding. */
+  UNIQUE,
+  ;
+
+  /**
+   * An object that is associated with a {@link ContributionType}.
+   */
+  interface HasContributionType {
+
+    /** The contribution type of this object. */
+    ContributionType contributionType();
+  }
+
+  /**
+   * {@code true} if this is for a multibinding.
+   */
+  boolean isMultibinding() {
+    return !this.equals(UNIQUE);
+  }
+
+  /** The contribution type for a given provision type. */
+  static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
+    switch (provisionType) {
+      case SET:
+      case SET_VALUES:
+        return SET;
+      case MAP:
+        return MAP;
+      case UNIQUE:
+        return UNIQUE;
+      default:
+        throw new AssertionError("Unknown provision type: " + provisionType);
+    }
+  }
+
+  /** Indexes objects by their contribution type. */
+  static <T extends HasContributionType>
+      ImmutableListMultimap<ContributionType, T> indexByContributionType(
+          Iterable<T> haveContributionTypes) {
+    return Multimaps.index(
+        haveContributionTypes,
+        new Function<HasContributionType, ContributionType>() {
+          @Override
+          public ContributionType apply(HasContributionType hasContributionType) {
+            return hasContributionType.contributionType();
+          }
+        });
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 7097b9991..453215667 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -29,23 +29,29 @@
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
 import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor7;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -57,29 +63,53 @@
 // TODO(gak): Set bindings and the permutations thereof need to be addressed
 @AutoValue
 abstract class DependencyRequest {
+  static final Function<DependencyRequest, BindingKey> BINDING_KEY_FUNCTION =
+      new Function<DependencyRequest, BindingKey>() {
+        @Override public BindingKey apply(DependencyRequest request) {
+          return request.bindingKey();
+        }
+      };
+
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
+    
     /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
-    PROVIDER,
+    PROVIDER(Provider.class),
+    
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
-    LAZY,
+    LAZY(Lazy.class),
+    
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
-    MEMBERS_INJECTOR,
+    MEMBERS_INJECTOR(MembersInjector.class),
+    
     /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
-    PRODUCER,
+    PRODUCER(Producer.class),
+    
     /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
-    PRODUCED,
+    PRODUCED(Produced.class),
+    
     /**
      * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
      * These can only be requested by component interfaces.
      */
     FUTURE,
+    ;
+
+    final Optional<Class<?>> frameworkClass;
+
+    Kind(Class<?> frameworkClass) {
+      this.frameworkClass = Optional.<Class<?>>of(frameworkClass);
+    }
+
+    Kind() {
+      this.frameworkClass = Optional.absent();
+    }
   }
 
   abstract Kind kind();
   abstract Key key();
-
+  
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -107,6 +137,12 @@ BindingKey bindingKey() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
+  /**
+   * An optional name for this request when it's referred to in generated code. If absent, it will
+   * use a name derived from {@link #requestElement}.
+   */
+  abstract Optional<String> overriddenVariableName();
+
   /**
    * Factory for {@link DependencyRequest}s.
    *
@@ -114,9 +150,11 @@ BindingKey bindingKey() {
    * which may mean that the type will be generated in a later round of processing.
    */
   static final class Factory {
+    private final Elements elements;
     private final Key.Factory keyFactory;
 
-    Factory(Key.Factory keyFactory) {
+    Factory(Elements elements, Key.Factory keyFactory) {
+      this.elements = elements;
       this.keyFactory = keyFactory;
     }
 
@@ -133,33 +171,46 @@ BindingKey bindingKey() {
     ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
-          .transform(new Function<VariableElement, DependencyRequest>() {
-            @Override public DependencyRequest apply(VariableElement input) {
-              return forRequiredVariable(input);
-            }
-          })
+          .transform(
+              new Function<VariableElement, DependencyRequest>() {
+                @Override
+                public DependencyRequest apply(VariableElement input) {
+                  return forRequiredVariable(input);
+                }
+              })
           .toSet();
     }
 
     /**
-     * Creates a DependencyRequest for implictMapBinding, this request's key will be
-     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
-     * whose key is {@code Map<K, V>}
+     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
+     * to satisfy the {@code mapOfValueRequest}.
+     * 
+     * @param mapOfValueRequest a request for {@code Map<K, V>}
+     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
+     *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
-      checkNotNull(delegatingRequest);
-      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
-          delegatingRequest.requestElement(),
-          getEnclosingType(delegatingRequest.requestElement()),
-          false /* doesn't allow null */);
+    DependencyRequest forImplicitMapBinding(
+        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
+      checkNotNull(mapOfValueRequest);
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          mapOfFactoryKey,
+          mapOfValueRequest.requestElement(),
+          mapOfValueRequest.enclosingType(),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
+      return forRequiredVariable(variableElement, Optional.<String>absent());
+    }
+
+    DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier,
-          getEnclosingType(variableElement));
+      return newDependencyRequest(
+          variableElement, type, qualifier, getEnclosingType(variableElement), name);
     }
 
     DependencyRequest forRequiredResolvedVariable(DeclaredType container,
@@ -168,18 +219,25 @@ DependencyRequest forRequiredResolvedVariable(DeclaredType container,
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier, container);
+      return newDependencyRequest(
+          variableElement, resolvedType, qualifier, container, Optional.<String>absent());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
         ExecutableType provisionMethodType) {
       checkNotNull(provisionMethod);
       checkNotNull(provisionMethodType);
-      checkArgument(provisionMethod.getParameters().isEmpty(),
-          "Component provision methods must be empty: " + provisionMethod);
+      checkArgument(
+          provisionMethod.getParameters().isEmpty(),
+          "Component provision methods must be empty: %s",
+          provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
-          getEnclosingType(provisionMethod));
+      return newDependencyRequest(
+          provisionMethod,
+          provisionMethodType.getReturnType(),
+          qualifier,
+          getEnclosingType(provisionMethod),
+          Optional.<String>absent());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -196,13 +254,15 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       if (isTypeOf(ListenableFuture.class, type)) {
         return new AutoValue_DependencyRequest(
             Kind.FUTURE,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
+            keyFactory.forQualifiedType(
+                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
             container,
-            false /* doesn't allow null */);
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, container);
+        return newDependencyRequest(
+            productionMethod, type, qualifier, container, Optional.<String>absent());
       }
     }
 
@@ -216,32 +276,53 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
       if (returnType.getKind().equals(DECLARED)
           && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       }
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+      return new AutoValue_DependencyRequest(
+          Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
           type,
-          false /* doesn't allow null */);
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
+    DependencyRequest forProductionComponentMonitorProvider() {
+      TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
+      for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
+        if (constructor.getParameters().size() == 2) {
+          // the 2-arg constructor has the appropriate dependency as its first arg
+          return forRequiredVariable(constructor.getParameters().get(0), Optional.of("monitor"));
+        }
+      }
+      throw new AssertionError("expected 2-arg constructor in AbstractProducer");
     }
 
-    private DependencyRequest newDependencyRequest(Element requestElement,
-        TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
+    private DependencyRequest newDependencyRequest(
+        Element requestElement,
+        TypeMirror type,
+        Optional<AnnotationMirror> qualifier,
+        DeclaredType container,
+        Optional<String> name) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
@@ -251,11 +332,13 @@ private DependencyRequest newDependencyRequest(Element requestElement,
       // TODO(sameb): should Produced/Producer always require non-nullable?
       boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
           || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
-      return new AutoValue_DependencyRequest(kindAndType.kind(),
+      return new AutoValue_DependencyRequest(
+          kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
           container,
-          allowsNull);
+          allowsNull,
+          name);
     }
 
     @AutoValue
@@ -265,40 +348,44 @@ private DependencyRequest newDependencyRequest(Element requestElement,
     }
 
     /**
-     * Extracts the correct requesting type & kind out a request type. For example, if a user
-     * requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER}, {@code Foo}).
+     * Extracts the dependency request type and kind from the type of a dependency request element.
+     * For example, if a user requests {@code Provider<Foo>}, this will return
+     * ({@link Kind#PROVIDER}, {@code Foo}).
      *
      * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
      *     mean that the type will be generated in a later round of processing
      */
     static KindAndType extractKindAndType(TypeMirror type) {
-      if (type.getKind().equals(TypeKind.ERROR)) {
-        throw new TypeNotPresentException(type.toString(), null);
-      }
+      return type.accept(
+          new SimpleTypeVisitor7<KindAndType, Void>() {
+            @Override
+            public KindAndType visitError(ErrorType errorType, Void p) {
+              throw new TypeNotPresentException(errorType.toString(), null);
+            }
 
-      // We must check TYPEVAR explicitly before the below checks because calling
-      // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
-      // represented as a Class).
-      if (type.getKind().equals(TypeKind.TYPEVAR)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
-      } else if (isTypeOf(Provider.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Lazy.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(MembersInjector.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Producer.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else if (isTypeOf(Produced.class, type)) {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
-            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
-      } else {
-        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
-      }
+            @Override
+            public KindAndType visitExecutable(ExecutableType executableType, Void p) {
+              return executableType.getReturnType().accept(this, null);
+            }
+
+            @Override
+            public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
+              for (Kind kind : Kind.values()) {
+                if (kind.frameworkClass.isPresent()
+                    && isTypeOf(kind.frameworkClass.get(), declaredType)) {
+                  return new AutoValue_DependencyRequest_Factory_KindAndType(
+                      kind, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+                }
+              }
+              return defaultAction(declaredType, p);
+            }
+
+            @Override
+            protected KindAndType defaultAction(TypeMirror otherType, Void p) {
+              return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, otherType);
+            }
+          },
+          null);
     }
 
     static DeclaredType getEnclosingType(Element element) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 1643adbc4..b12a854d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import dagger.Lazy;
 import javax.inject.Provider;
@@ -33,13 +34,19 @@
 final class DependencyVariableNamer implements Function<DependencyRequest, String> {
   @Override
   public String apply(DependencyRequest dependency) {
+    if (dependency.overriddenVariableName().isPresent()) {
+      return dependency.overriddenVariableName().get();
+    }
     String variableName = dependency.requestElement().getSimpleName().toString();
+    if (Ascii.isUpperCase(variableName.charAt(0))) {
+      variableName = toLowerCamel(variableName);
+    }
     switch (dependency.kind()) {
       case INSTANCE:
         return variableName;
       case LAZY:
         return variableName.startsWith("lazy") && !variableName.equals("lazy")
-            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            ? toLowerCamel(variableName.substring(4))
             : variableName;
       case PROVIDER:
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
@@ -51,7 +58,7 @@ public String apply(DependencyRequest dependency) {
             : variableName;
       case PRODUCED:
         return variableName.startsWith("produced") && !variableName.equals("produced")
-            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            ? toLowerCamel(variableName.substring(8))
             : variableName;
       case PRODUCER:
         return variableName.endsWith("Producer") && !variableName.equals("Producer")
@@ -61,4 +68,8 @@ public String apply(DependencyRequest dependency) {
         throw new AssertionError();
     }
   }
+
+  private String toLowerCamel(String name) {
+    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 12da8deae..41406f80c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -15,10 +15,13 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import dagger.Multibindings;
 import dagger.Provides;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * The collection of error messages to be reported back to users.
@@ -31,6 +34,7 @@
    * Common constants.
    */
   static final String INDENT = "    ";
+  static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
    * JSR-330 errors
@@ -76,10 +80,16 @@
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
       "Dagger does not support injection into private fields";
+  
+  static final String STATIC_INJECT_FIELD =
+      "Dagger does not support injection into static fields";
 
   /* methods */
   static final String PRIVATE_INJECT_METHOD =
       "Dagger does not support injection into private methods";
+  
+  static final String STATIC_INJECT_METHOD =
+      "Dagger does not support injection into static methods";
 
   /* all */
   static final String INJECT_INTO_PRIVATE_CLASS =
@@ -94,12 +104,24 @@
   static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
       "%s is bound multiple times:";
 
+  static String duplicateMapKeysError(String key) {
+    return "The same map key is bound more than once for " + key;
+  }
+
+  static String inconsistentMapKeyAnnotationsError(String key) {
+    return key + " uses more than one @MapKey annotation type";
+  }
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
-      "@Provides methods must either return a primitive, an array or a declared type.";
+      "@Provides methods must either return a primitive, an array, a type variable, or a declared"
+          + " type.";
+
+  static final String PROVIDES_METHOD_THROWS =
+      "@Provides methods may only throw unchecked exceptions";
 
   static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must either return a primitive, an array or a declared type, or a"
-      + " ListenableFuture of one of those types.";
+      "@Produces methods must either return a primitive, an array, a type variable, or a declared"
+          + " type, or a ListenableFuture of one of those types.";
 
   static final String PRODUCES_METHOD_RAW_FUTURE =
       "@Produces methods cannot return a raw ListenableFuture.";
@@ -113,6 +135,9 @@
   static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
       "@Produces methods of type set values must return a Set or ListenableFuture of Set";
 
+  static final String PRODUCES_METHOD_THROWS =
+      "@Produces methods may only throw unchecked exceptions or exceptions subclassing Exception";
+
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
 
@@ -145,7 +170,7 @@
       "%s is listed as a module, but is an abstract class or interface";
 
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
-      "%s is listed as a module, but is not annotated with @%s";
+      "%s is listed as a module, but is not annotated with %s";
 
   static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
       "%s is listed as a module, but has type parameters";
@@ -170,11 +195,11 @@
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+  static final String MULTIPLE_CONTRIBUTION_TYPES_FORMAT =
       "More than one binding present of different types %s";
 
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
-      "%s has incompatible bindings:\n";
+      "%s has incompatible bindings or declarations:\n";
 
   static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision entry-point, which cannot depend on a production.";
@@ -195,6 +220,15 @@
   static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT =
       "%s cannot be provided without an @Provides- or @Produces-annotated method.";
 
+  private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT =
+      "%s may only be injected in @Produces methods.";
+
+  static String provisionMayNotDependOnProducerType(TypeMirror type) {
+    return String.format(
+        PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT,
+        MoreTypes.asTypeElement(type).getSimpleName());
+  }
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
@@ -209,8 +243,12 @@
   static final String MALFORMED_MODULE_METHOD_FORMAT =
       "Cannot generated a graph because method %s on module %s was malformed";
 
-  static final String NULLABLE_TO_NON_NULLABLE =
-      "%s is not nullable, but is being provided by %s";
+  static String nullableToNonNullable(String typeName, String bindingString) {
+    return String.format(
+            "%s is not nullable, but is being provided by %s",
+            typeName,
+            bindingString);
+  }
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
       "Cannot return null from a non-@Nullable component method";
@@ -224,6 +262,10 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
         return ComponentBuilderMessages.INSTANCE;
       case SUBCOMPONENT:
         return SubcomponentBuilderMessages.INSTANCE;
+      case PRODUCTION_COMPONENT:
+        return ProductionComponentBuilderMessages.INSTANCE;
+      case PRODUCTION_SUBCOMPONENT:
+        return ProductionSubcomponentBuilderMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
@@ -355,6 +397,61 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final ProductionComponentBuilderMessages INSTANCE =
+        new ProductionComponentBuilderMessages();
+
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "production component")
+          .replaceAll("Component", "ProductionComponent");
+    }
+  }
+
+  static final class ProductionSubcomponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final ProductionSubcomponentBuilderMessages INSTANCE =
+        new ProductionSubcomponentBuilderMessages();
+
+    @Override
+    protected String process(String s) {
+      return s.replaceAll("component", "production subcomponent")
+          .replaceAll("Component", "ProductionSubcomponent");
+    }
+
+    String builderMethodRequiresNoArgs() {
+      return "Methods returning a @ProductionSubcomponent.Builder must have no arguments";
+    }
+
+    String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given production subcomponent. %s is created by: %s";
+    }
+  }
+
+  /** Error messages related to {@link Multibindings @Multibindings}. */
+  static final class MultibindingsMessages {
+    static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
+
+    static final String MUST_NOT_HAVE_TYPE_PARAMETERS =
+        "@Multibindings types must not have type parameters";
+
+    static final String MUST_BE_IN_MODULE =
+        "@Multibindings types must be nested within a @Module or @ProducerModule";
+
+    static final String METHOD_MUST_RETURN_MAP_OR_SET =
+        "@Multibindings methods must return Map<K, V> or Set<T>";
+
+    static final String TOO_MANY_QUALIFIERS =
+        "Cannot use more than one @Qualifier on a method in an @Multibindings type";
+
+    static String tooManyMethodsForKey(String formattedKey) {
+      return String.format(
+          "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
+    }
+
+    private MultibindingsMessages() {}
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index c7eb6326f..8b548c0db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -16,48 +16,50 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MembersInjector;
-import dagger.Provides.Type;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.EnumWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeVariableName;
-import dagger.internal.codegen.writer.TypeWriter;
+import dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
 import static com.google.common.base.Preconditions.checkState;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.TypeSpec.enumBuilder;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.TypeNames.factoryOf;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -70,25 +72,24 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
+
   private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
-  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper,
+  FactoryGenerator(
+      Filer filer,
+      Elements elements,
+      DependencyRequestMapper dependencyRequestMapper,
       Diagnostic.Kind nullableValidationType) {
-    super(filer);
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
     this.nullableValidationType = nullableValidationType;
   }
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return factoryNameForProvisionBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(ProvisionBinding binding) {
-    return ImmutableSet.of(binding.bindingElement());
+    return javapoetGeneratedClassNameForBinding(binding);
   }
 
   @Override
@@ -97,182 +98,199 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.unresolved().isPresent());
 
-    TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
-    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-
-    final TypeWriter factoryWriter;
-    final Optional<ConstructorWriter> constructorWriter;
-    List<TypeVariableName> typeParameters = Lists.newArrayList();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-     typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
-    }
+    TypeMirror keyType =
+        binding.contributionType().equals(ContributionType.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
+            : binding.key().type();
+    TypeName providedTypeName = TypeName.get(keyType);
+    ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
+    Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
+    TypeSpec.Builder factoryBuilder;
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+    boolean useRawType =
+        binding.factoryCreationStrategy() == ENUM_INSTANCE
+            && binding.bindingKind() == INJECTION
+            && !typeParameters.isEmpty();
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
-        EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
-        enumWriter.addConstant("INSTANCE");
-        constructorWriter = Optional.absent();
-        factoryWriter = enumWriter;
+        factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
         // If we have type parameters, then remove the parameters from our providedTypeName,
         // since we'll be implementing an erased version of it.
-        if (!typeParameters.isEmpty()) {
-          factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
-          providedTypeName = ((ParameterizedTypeName) providedTypeName).type();
+        if (useRawType) {
+          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
+          providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
+          factoryOfRawTypeName = Optional.of(factoryOf(providedTypeName));
         }
         break;
       case CLASS_CONSTRUCTOR:
-        ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
-        classWriter.addTypeParameters(typeParameters);
-        classWriter.addModifiers(FINAL);
-        constructorWriter = Optional.of(classWriter.addConstructor());
-        constructorWriter.get().addModifiers(PUBLIC);
-        factoryWriter = classWriter;
+        factoryBuilder =
+            classBuilder(generatedTypeName.simpleName())
+                .addTypeVariables(typeParameters)
+                .addModifiers(FINAL);
+        constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
         if (binding.bindingKind().equals(PROVISION)
             && !binding.bindingElement().getModifiers().contains(STATIC)) {
-          TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
-          factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
-          constructorWriter.get().addParameter(enclosingType, "module");
-          constructorWriter.get().body()
-              .addSnippet("assert module != null;")
-              .addSnippet("this.module = module;");
+          addConstructorParameterAndTypeField(
+              TypeName.get(binding.bindingTypeElement().asType()),
+              "module",
+              factoryBuilder,
+              constructorBuilder.get());
+        }
+        for (FrameworkField bindingField : fields.values()) {
+          addConstructorParameterAndTypeField(
+              bindingField.javapoetFrameworkType(),
+              bindingField.name(),
+              factoryBuilder,
+              constructorBuilder.get());
         }
         break;
       default:
         throw new AssertionError();
     }
 
-    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addImplementedType(
-        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
-
-    MethodWriter getMethodWriter = factoryWriter.addMethod(providedTypeName, "get");
-    getMethodWriter.annotate(Override.class);
-    getMethodWriter.addModifiers(PUBLIC);
-
-    if (binding.memberInjectionRequest().isPresent()) {
-      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, providedTypeName);
-      factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
-      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.get().body()
-          .addSnippet("assert membersInjector != null;")
-          .addSnippet("this.membersInjector = membersInjector;");
-    }
-
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
-
-    for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.get().addParameter(field.type(), field.name());
-      constructorWriter.get().body()
-          .addSnippet("assert %s != null;", field.name())
-          .addSnippet("this.%1$s = %1$s;", field.name());
-    }
+    factoryBuilder
+        .addModifiers(PUBLIC)
+        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));
 
     // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
     // of the factory.  (Otherwise they may have visibility problems referring to the types.)
+    Optional<MethodSpec> createMethod;
     switch(binding.bindingKind()) {
       case INJECTION:
       case PROVISION:
         // The return type is usually the same as the implementing type, except in the case
         // of enums with type variables (where we cast).
-        TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(keyType));
-        MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
-        createMethodWriter.addTypeParameters(typeParameters);
-        createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-        Map<String, TypeName> params = constructorWriter.isPresent()
-            ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
-        for (Map.Entry<String, TypeName> param : params.entrySet()) {
-          createMethodWriter.addParameter(param.getValue(), param.getKey());
+        MethodSpec.Builder createMethodBuilder =
+            methodBuilder("create")
+                .addModifiers(PUBLIC, STATIC)
+                .returns(parameterizedFactoryName);
+        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
+            || binding.bindingKind() == INJECTION) {
+          createMethodBuilder.addTypeVariables(typeParameters);
         }
+        List<ParameterSpec> params =
+            constructorBuilder.isPresent()
+                ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
+        createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
           case ENUM_INSTANCE:
-            if (typeParameters.isEmpty()) {
-              createMethodWriter.body().addSnippet("return INSTANCE;");
+            if (!useRawType) {
+              createMethodBuilder.addStatement("return INSTANCE");
             } else {
               // We use an unsafe cast here because the types are different.
               // It's safe because the type is never referenced anywhere.
-              createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
-              createMethodWriter.body().addSnippet("return (Factory) INSTANCE;");
+              createMethodBuilder.addStatement("return ($T) INSTANCE", TypeNames.FACTORY);
+              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
             }
             break;
+
           case CLASS_CONSTRUCTOR:
-            createMethodWriter.body().addSnippet("return new %s(%s);",
-                parameterizedFactoryNameForProvisionBinding(binding),
-                Joiner.on(", ").join(params.keySet()));
+            createMethodBuilder.addStatement(
+                "return new $T($L)",
+                javapoetParameterizedGeneratedTypeNameForBinding(binding),
+                makeParametersCodeBlock(
+                    Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
             break;
           default:
             throw new AssertionError();
         }
+        createMethod = Optional.of(createMethodBuilder.build());
         break;
-      default: // do nothing.
+      default:
+        createMethod = Optional.absent();
     }
 
-    List<Snippet> parameters = Lists.newArrayList();
+    if (constructorBuilder.isPresent()) {
+      factoryBuilder.addMethod(constructorBuilder.get().build());
+    }
+
+    List<CodeBlock> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
-      parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+      parameters.add(
+          frameworkTypeUsageStatement(
+              CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+              dependency.kind()));
     }
-    Snippet parametersSnippet = makeParametersSnippet(parameters);
+    CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
+
+    MethodSpec.Builder getMethodBuilder =
+        methodBuilder("get")
+            .returns(providedTypeName)
+            .addAnnotation(Override.class)
+            .addModifiers(PUBLIC);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      Snippet providesMethodInvocation = Snippet.format("%s.%s(%s)",
-          binding.bindingElement().getModifiers().contains(STATIC)
-              ? ClassName.fromTypeElement(binding.bindingTypeElement())
-              : "module",
-          binding.bindingElement().getSimpleName(),
-          parametersSnippet);
+      CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
+      if (binding.bindingElement().getModifiers().contains(STATIC)) {
+        providesMethodInvocationBuilder.add("$T", ClassName.get(binding.bindingTypeElement()));
+      } else {
+        providesMethodInvocationBuilder.add("module");
+      }
+      providesMethodInvocationBuilder.add(
+          ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
+      CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
       if (binding.provisionType().equals(SET)) {
-        TypeName paramTypeName = TypeNames.forTypeMirror(
+        TypeName paramTypeName = TypeName.get(
             MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
         // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
-        getMethodWriter.body().addSnippet("return %s.<%s>singleton(%s);",
-            ClassName.fromClass(Collections.class), paramTypeName, providesMethodInvocation);
+        getMethodBuilder.addStatement(
+            "return $T.<$T>singleton($L)",
+            Collections.class, paramTypeName, providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
           || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
-          getMethodWriter.annotate(
-              (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
+          getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
         }
-        getMethodWriter.body().addSnippet("return %s;", providesMethodInvocation);
+        getMethodBuilder.addStatement("return $L", providesMethodInvocation);
       } else {
-        StringLiteral failMsg =
-            StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-        getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "%s provided = %s;",
-            "if (provided == null) {",
-            "  throw new NullPointerException(%s);",
-            "}",
-            "return provided;"),
-            getMethodWriter.returnType(),
-            providesMethodInvocation,
-            failMsg));
+        String failMsg = CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+        getMethodBuilder
+            .addStatement(
+                "$T provided = $L", getMethodBuilder.build().returnType, providesMethodInvocation)
+            .addCode("if (provided == null) { ")
+            .addStatement("throw new $T($S)", NullPointerException.class, failMsg)
+            .addCode("}")
+            .addStatement("return provided");
       }
-    } else if (binding.memberInjectionRequest().isPresent()) {
-      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
-          providedTypeName, parametersSnippet);
-      getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
-      getMethodWriter.body().addSnippet("return instance;");
+    } else if (binding.membersInjectionRequest().isPresent()) {
+      getMethodBuilder.addStatement(
+          "$1T instance = new $1T($2L)", providedTypeName, parametersCodeBlock);
+      getMethodBuilder.addStatement(
+          "$L.injectMembers(instance)",
+          fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
+      getMethodBuilder.addStatement("return instance");
     } else {
-      getMethodWriter.body()
-          .addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
+      getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
+    }
+
+    factoryBuilder.addMethod(getMethodBuilder.build());
+    if (createMethod.isPresent()) {
+      factoryBuilder.addMethod(createMethod.get());
     }
 
     // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    return Optional.of(factoryBuilder);
+  }
+
+  private void addConstructorParameterAndTypeField(
+      TypeName typeName,
+      String variableName,
+      TypeSpec.Builder factoryBuilder,
+      MethodSpec.Builder constructorBuilder) {
+    FieldSpec field = FieldSpec.builder(typeName, variableName, PRIVATE, FINAL).build();
+    factoryBuilder.addField(field);
+    ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
+    constructorBuilder.addParameter(parameter);
+    constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 880b78705..93f88bee1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,6 +16,10 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+
+import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * A formatter which transforms an instance of a particular type into a string
@@ -45,4 +49,48 @@
   @Override final public String apply(T object) {
     return format(object);
   }
+
+  /**
+   * Formats {@code items}, one per line.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
+    formatIndentedList(builder, indentLevel, items, ImmutableList.<T>of());
+  }
+
+  /**
+   * Formats {@code items}, one per line. Stops after {@code limit} items.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel, int limit) {
+    formatIndentedList(
+        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));
+  }
+
+  private void formatIndentedList(
+      StringBuilder builder,
+      int indentLevel,
+      Iterable<? extends T> firstItems,
+      Iterable<? extends T> restOfItems) {
+    for (T item : firstItems) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append(format(item));
+    }
+    int numberOfOtherItems = Iterables.size(restOfItems);
+    if (numberOfOtherItems > 0) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append("and ").append(numberOfOtherItems).append(" other");
+    }
+    if (numberOfOtherItems > 1) {
+      builder.append('s');
+    }
+  }
+
+  private void appendIndent(StringBuilder builder, int indentLevel) {
+    for (int i = 0; i < indentLevel; i++) {
+      builder.append(INDENT);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index f6b207c09..baad3b393 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,13 +15,18 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.CaseFormat;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
 
 /**
  * A value object that represents a field used by Dagger-generated code.
@@ -30,32 +35,91 @@
  * @since 2.0
  */
 @AutoValue
+// TODO(gak): Reexamine the this class and how consistently we're using it and its creation methods.
 abstract class FrameworkField {
-  // TODO(gak): reexamine the this class and how consistently we're using it and its creation
-  // methods
-
-  static FrameworkField createWithTypeFromKey(
-      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+  static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
     String suffix = frameworkClass.getSimpleName();
-    ParameterizedTypeName frameworkType = ParameterizedTypeName.create(
-        ClassName.fromClass(frameworkClass),
-        TypeNames.forTypeMirror(bindingKey.key().type()));
-    return new AutoValue_FrameworkField(frameworkClass, frameworkType, bindingKey,
-        name.endsWith(suffix) ? name : name + suffix);
+    ParameterizedTypeName frameworkType =
+        ParameterizedTypeName.create(
+            ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
+    com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType =
+        com.squareup.javapoet.ParameterizedTypeName.get(
+            com.squareup.javapoet.ClassName.get(frameworkClass),
+            com.squareup.javapoet.TypeName.get(key.type()));
+    return new AutoValue_FrameworkField(
+        javapoetFrameworkType, frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
-  static FrameworkField createForMapBindingContribution(
-      Class<?> frameworkClass, BindingKey bindingKey, String name) {
-    TypeMirror mapValueType =
-        MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
-    return new AutoValue_FrameworkField(frameworkClass,
-        TypeNames.forTypeMirror(mapValueType),
-        bindingKey,
+  private static FrameworkField createForMapBindingContribution(Key key, String name) {
+    TypeMirror type = MapType.from(key.type()).valueType();
+    return new AutoValue_FrameworkField(
+        (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
+        (ParameterizedTypeName) TypeNames.forTypeMirror(type),
         name);
   }
 
-  abstract Class<?> frameworkClass();
-  abstract TypeName frameworkType();
-  abstract BindingKey bindingKey();
+  static FrameworkField createForSyntheticContributionBinding(
+      int contributionNumber, ContributionBinding contributionBinding) {
+    switch (contributionBinding.contributionType()) {
+      case MAP:
+        return createForMapBindingContribution(
+            contributionBinding.key(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
+                + "Contribution"
+                + contributionNumber);
+
+      case SET:
+      case UNIQUE:
+        return createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
+            contributionBinding.key(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
+                + "Contribution"
+                + contributionNumber);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+    return createWithTypeFromKey(
+        resolvedBindings.frameworkClass(),
+        resolvedBindings.bindingKey().key(),
+        frameworkFieldName(resolvedBindings));
+  }
+
+  private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.contributionType().equals(ContributionType.UNIQUE)) {
+      ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
+      if (!binding.bindingKind().equals(ContributionBinding.Kind.SYNTHETIC_MAP)) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement());
+      }
+    }
+    return KeyVariableNamer.INSTANCE.apply(bindingKey.key());
+  }
+
+  private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
+      new ElementKindVisitor6<String, Void>() {
+        @Override
+        public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+          return e.getSimpleName().toString();
+        }
+
+        @Override
+        public String visitType(TypeElement e, Void p) {
+          return CaseFormat.UPPER_CAMEL.to(
+              CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
+        }
+      };
+
+  abstract com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType();
+  abstract ParameterizedTypeName frameworkType();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
new file mode 100644
index 000000000..e565da792
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A collection of utility methods for dealing with Dagger framework types. A framework type is any
+ * type that the framework itself defines.
+ */
+final class FrameworkTypes {
+  // NOTE(beder): ListenableFuture is not considered a producer framework type because it is not
+  // defined by the framework, so we can't treat it specially in ordinary Dagger.
+  private static final ImmutableSet<Class<?>> PRODUCER_TYPES =
+      ImmutableSet.of(Produced.class, Producer.class);
+
+  /** Returns true if the type represents a producer-related framework type. */
+  static boolean isProducerType(TypeMirror type) {
+    if (!MoreTypes.isType(type)) {
+      return false;
+    }
+    for (Class<?> clazz : PRODUCER_TYPES) {
+      if (MoreTypes.isTypeOf(clazz, type)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private FrameworkTypes() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
new file mode 100644
index 000000000..d73930aee
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/**
+ * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
+ */
+final class HasSourceElementFormatter extends Formatter<HasSourceElement> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  HasSourceElementFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String format(HasSourceElement hasElement) {
+    SourceElement sourceElement = hasElement.sourceElement();
+    checkArgument(
+        sourceElement.element().asType().getKind().equals(TypeKind.EXECUTABLE),
+        "Not yet supporting nonexecutable elements: %s",
+        hasElement);
+
+    Optional<TypeElement> contributedBy = sourceElement.contributedBy();
+    return methodSignatureFormatter.format(
+        MoreElements.asExecutable(sourceElement.element()),
+        contributedBy.isPresent()
+            ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
+            : Optional.<DeclaredType>absent());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 071ce6982..ee92a0db3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -29,14 +29,14 @@
 import dagger.internal.codegen.writer.ClassName;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
@@ -45,6 +45,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -58,22 +61,28 @@
   private final Elements elements;
   private final Types types;
   private final Messager messager;
+  private final InjectConstructorValidator injectConstructorValidator;
+  private final MembersInjectedTypeValidator membersInjectedTypeValidator;
+  private final Key.Factory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
 
   final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
-    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+    private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
-        checkState(!binding.hasNonDefaultTypeParameters());
+        checkState(!binding.unresolved().isPresent());
         generator.generate(binding);
-        materializedBindings.add(binding);
+        materializedBindingKeys.add(binding.key());
       }
+      // Because Elements instantiated across processing rounds are not guaranteed to be equals() to
+      // the logically same element, clear the cache after generating
+      bindingsByKey.clear();
     }
 
     /** Returns a previously cached binding. */
@@ -81,29 +90,20 @@ B getBinding(Key key) {
       return bindingsByKey.get(key);
     }
 
-    /** Caches the binding and pretends a binding is generated without actually generating it. */
-    B pretendBindingGenerated(B binding, ClassName factoryName) {
-      tryToCacheBinding(binding);
-      if (shouldGenerateBinding(binding, factoryName)) {
-        materializedBindings.add(binding);
-      }
-      return binding;
-    }
-
     /** Caches the binding and generates it if it needs generation. */
-    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+    void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {
       tryToCacheBinding(binding);
-      tryToGenerateBinding(binding, factoryName, explicit);
+      tryToGenerateBinding(binding, warnIfNotAlreadyGenerated);
     }
 
     /**
      * Tries to generate a binding, not generating if it already is generated. For resolved
      * bindings, this will try to generate the unresolved version of the binding.
      */
-    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
-      if (shouldGenerateBinding(binding, factoryName)) {
+    void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
+      if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
         bindingsRequiringGeneration.offer(binding);
-        if (!explicit) {
+        if (warnIfNotAlreadyGenerated) {
           messager.printMessage(Kind.NOTE, String.format(
               "Generating a MembersInjector or Factory for %s. "
                     + "Prefer to run the dagger processor over that class instead.",
@@ -114,9 +114,9 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
 
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
-      return !binding.hasNonDefaultTypeParameters()
+      return !binding.unresolved().isPresent()
           && elements.getTypeElement(factoryName.canonicalName()) == null
-          && !materializedBindings.contains(binding)
+          && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
 
     }
@@ -125,7 +125,7 @@ private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
     private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.hasNonDefaultTypeParameters()
+      if (binding.unresolved().isPresent()
           || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
@@ -140,14 +140,21 @@ private void tryToCacheBinding(B binding) {
   private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
       new BindingsCollection<>();
 
-  InjectBindingRegistry(Elements elements,
+  InjectBindingRegistry(
+      Elements elements,
       Types types,
       Messager messager,
+      InjectConstructorValidator injectConstructorValidator,
+      MembersInjectedTypeValidator membersInjectedTypeValidator,
+      Key.Factory keyFactory,
       ProvisionBinding.Factory provisionBindingFactory,
       MembersInjectionBinding.Factory membersInjectionBindingFactory) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
+    this.injectConstructorValidator = injectConstructorValidator;
+    this.membersInjectedTypeValidator = membersInjectedTypeValidator;
+    this.keyFactory = keyFactory;
     this.provisionBindingFactory = provisionBindingFactory;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
   }
@@ -163,52 +170,104 @@ void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
     membersInjectionBindings.generateBindings(membersInjectorGenerator);
   }
 
-  ProvisionBinding registerBinding(ProvisionBinding binding) {
-    return registerBinding(binding, true);
-  }
-
-  MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
-    return registerBinding(binding, true);
-  }
-
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
-    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
-    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
-    if (binding.hasNonDefaultTypeParameters()) {
-      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
-          factoryName, explicit);
+  private ProvisionBinding registerBinding(
+      ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
+    provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
+    if (binding.unresolved().isPresent()) {
+      provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);
     }
     return binding;
   }
 
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
   private MembersInjectionBinding registerBinding(
-      MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName =
-        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-    if (binding.injectionSites().isEmpty()) {
-      // empty members injection bindings are special and don't need source files.
-      // so, we just pretend
-      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.pretendBindingGenerated(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
+      MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+    /*
+     * We generate MembersInjector classes for types with @Inject constructors only if they have any
+     * injection sites.
+     *
+     * We generate MembersInjector classes for types without @Inject constructors only if they have
+     * local (non-inherited) injection sites.
+     *
+     * Warn only when registering bindings post-hoc for those types.
+     */
+    warnIfNotAlreadyGenerated =
+        warnIfNotAlreadyGenerated
+            && (!injectedConstructors(binding.bindingElement()).isEmpty()
+                ? !binding.injectionSites().isEmpty()
+                : binding.hasLocalInjectionSites());
+    membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
+    if (binding.unresolved().isPresent()) {
+      membersInjectionBindings.tryToGenerateBinding(
+          binding.unresolved().get(), warnIfNotAlreadyGenerated);
+    }
+    return binding;
+  }
+
+  Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
+    return tryRegisterConstructor(constructorElement, Optional.<TypeMirror>absent(), false);
+  }
+
+  private Optional<ProvisionBinding> tryRegisterConstructor(
+      ExecutableElement constructorElement,
+      Optional<TypeMirror> resolvedType,
+      boolean warnIfNotAlreadyGenerated) {
+    TypeElement typeElement = MoreElements.asType(constructorElement.getEnclosingElement());
+    DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
+    Key key = keyFactory.forInjectConstructorWithResolvedType(type);
+    ProvisionBinding cachedBinding = provisionBindings.getBinding(key);
+    if (cachedBinding != null) {
+      return Optional.of(cachedBinding);
+    }
+
+    ValidationReport<TypeElement> report = injectConstructorValidator.validate(constructorElement);
+    report.printMessagesTo(messager);
+    if (report.isClean()) {
+      ProvisionBinding binding =
+          provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
+      registerBinding(binding, warnIfNotAlreadyGenerated);
+      if (membersInjectionBindingFactory.hasInjectedMembers(type)) {
+        tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
       }
-    } else {
-      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.tryToGenerateBinding(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
+      return Optional.of(binding);
+    }
+    return Optional.absent();
+  }
+
+  Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
+    return tryRegisterMembersInjectedType(typeElement, Optional.<TypeMirror>absent(), false);
+  }
+
+  private Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(
+      TypeElement typeElement,
+      Optional<TypeMirror> resolvedType,
+      boolean warnIfNotAlreadyGenerated) {
+    DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
+    Key key = keyFactory.forInjectConstructorWithResolvedType(type);
+    MembersInjectionBinding cachedBinding = membersInjectionBindings.getBinding(key);
+    if (cachedBinding != null) {
+      return Optional.of(cachedBinding);
+    }
+
+    ValidationReport<TypeElement> report = membersInjectedTypeValidator.validate(typeElement);
+    report.printMessagesTo(messager);
+    if (report.isClean()) {
+      MembersInjectionBinding binding =
+          membersInjectionBindingFactory.forInjectedType(type, resolvedType);
+      registerBinding(binding, warnIfNotAlreadyGenerated);
+      if (binding.parentKey().isPresent() && binding.injectionStrategy().equals(INJECT_MEMBERS)) {
+        getOrFindMembersInjectionBinding(binding.parentKey().get());
       }
+      return Optional.of(binding);
     }
-    return binding;
+    return Optional.absent();
   }
 
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
@@ -223,37 +282,47 @@ private MembersInjectionBinding registerBinding(
 
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    List<ExecutableElement> constructors =
-        ElementFilter.constructorsIn(element.getEnclosedElements());
-    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
-        .filter(new Predicate<ExecutableElement>() {
-          @Override public boolean apply(ExecutableElement input) {
-            return isAnnotationPresent(input, Inject.class);
-          }
-        }).toSet();
+    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(element);
     switch (injectConstructors.size()) {
       case 0:
         // No constructor found.
         return Optional.absent();
       case 1:
-        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
-        return Optional.of(registerBinding(constructorBinding, false));
+        return tryRegisterConstructor(
+            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
             + injectConstructors);
     }
   }
 
-  MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
+  private ImmutableSet<ExecutableElement> injectedConstructors(TypeElement element) {
+    return FluentIterable.from(constructorsIn(element.getEnclosedElements()))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement constructor) {
+                return isAnnotationPresent(constructor, Inject.class);
+              }
+            })
+        .toSet();
+  }
+
+  /**
+   * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
+   * registers one, along with all necessary members injection bindings for superclasses.
+   */
+  Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
     checkArgument(key.isValidMembersInjectionKey());
     MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
     if (binding != null) {
-      return binding;
+      return Optional.of(binding);
     }
-    return registerBinding(membersInjectionBindingFactory.forInjectedType(
-        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
+    Optional<MembersInjectionBinding> newBinding =
+        tryRegisterMembersInjectedType(
+            MoreTypes.asTypeElement(key.type()), Optional.of(key.type()), true);
+    return newBinding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index ac4f914e3..23b2edcab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -44,31 +45,33 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} constructors.
+ * A {@linkplain ValidationReport validator} for {@link Inject} constructors.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(constructorElement);
+final class InjectConstructorValidator {
+  ValidationReport<TypeElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<TypeElement> builder =
+        ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
     }
 
     for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
-      builder.addItem(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
         }
       }
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
     }
 
     TypeElement enclosingElement =
@@ -76,16 +79,16 @@
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
     if (typeModifiers.contains(PRIVATE)) {
-      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+      builder.addError(INJECT_INTO_PRIVATE_CLASS, constructorElement);
     }
 
     if (typeModifiers.contains(ABSTRACT)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
     }
 
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
     }
 
     // This is computationally expensive, but probably preferable to a giant index
@@ -98,13 +101,13 @@
             });
 
     if (injectConstructors.size() > 1) {
-      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
     }
 
     ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
     if (scopes.size() > 1) {
       for (AnnotationMirror scope : scopes) {
-        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope);
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index 1841290ea..96822b190 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -21,41 +21,60 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
+import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} fields.
+ * A {@linkplain ValidationReport validator} for {@link Inject} fields.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectFieldValidator implements Validator<VariableElement> {
-  @Override
-  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder =
-        ValidationReport.Builder.about(fieldElement);
+final class InjectFieldValidator {
+  private Kind privateMemberValidationKind;
+  private Kind staticMemberValidationKind;
+  
+  public InjectFieldValidator(
+      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+  }
+
+  ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
-      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+      builder.addError(FINAL_INJECT_FIELD, fieldElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+      builder.addItem(PRIVATE_INJECT_FIELD, privateMemberValidationKind, fieldElement);
     }
 
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(STATIC_INJECT_FIELD, staticMemberValidationKind, fieldElement);
+    }
+    
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
       }
     }
 
+    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
+      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
+    }
+
     return builder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index 9454f230e..b151ee4fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -22,46 +22,64 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
+import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} methods.
+ * A {@linkplain ValidationReport validator} for {@link Inject} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectMethodValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(methodElement);
+final class InjectMethodValidator {
+  private Kind privateMemberValidationKind;
+  private Kind staticMemberValidationKind;
+  
+  public InjectMethodValidator(
+      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+  }
+
+  ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+      builder.addItem(PRIVATE_INJECT_METHOD, privateMemberValidationKind, methodElement);
+    }
+    
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(STATIC_INJECT_METHOD, staticMemberValidationKind, methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+      builder.addError(GENERIC_INJECT_METHOD, methodElement);
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
         }
       }
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
     }
 
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 708763b8c..77f64ed12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,19 +16,17 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+
 import java.lang.annotation.Annotation;
 import java.util.Set;
-import javax.annotation.processing.Messager;
+
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
@@ -39,27 +37,9 @@
  * @since 2.0
  */
 final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
-  private final Messager messager;
-  private final InjectConstructorValidator constructorValidator;
-  private final InjectFieldValidator fieldValidator;
-  private final InjectMethodValidator methodValidator;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final InjectBindingRegistry injectBindingRegistry;
 
-  InjectProcessingStep(Messager messager,
-      InjectConstructorValidator constructorValidator,
-      InjectFieldValidator fieldValidator,
-      InjectMethodValidator methodValidator,
-      ProvisionBinding.Factory provisionBindingFactory,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
-      InjectBindingRegistry factoryRegistrar) {
-    this.messager = messager;
-    this.constructorValidator = constructorValidator;
-    this.fieldValidator = fieldValidator;
-    this.methodValidator = methodValidator;
-    this.provisionBindingFactory = provisionBindingFactory;
-    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+  InjectProcessingStep(InjectBindingRegistry factoryRegistrar) {
     this.injectBindingRegistry = factoryRegistrar;
   }
 
@@ -71,69 +51,40 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
     // TODO(gak): add some error handling for bad source files
-    final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
-    // TODO(gak): instead, we should collect reports by type and check later
-    final ImmutableSet.Builder<DeclaredType> membersInjectedTypes = ImmutableSet.builder();
 
     for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
-      injectElement.accept(
-          new ElementKindVisitor6<Void, Void>() {
-            @Override
-            public Void visitExecutableAsConstructor(
-                ExecutableElement constructorElement, Void v) {
-              ValidationReport<ExecutableElement> report =
-                  constructorValidator.validate(constructorElement);
-
-              report.printMessagesTo(messager);
-
-              if (report.isClean()) {
-                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
-                    Optional.<TypeMirror>absent()));
+      try {
+        injectElement.accept(
+            new ElementKindVisitor6<Void, Void>() {
+              @Override
+              public Void visitExecutableAsConstructor(
+                  ExecutableElement constructorElement, Void v) {
+                injectBindingRegistry.tryRegisterConstructor(constructorElement);
+                return null;
               }
 
-              return null;
-            }
-
-            @Override
-            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
-
-              report.printMessagesTo(messager);
-
-              if (report.isClean()) {
-                membersInjectedTypes.add(
-                    MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
+              @Override
+              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+                injectBindingRegistry.tryRegisterMembersInjectedType(
+                    MoreElements.asType(fieldElement.getEnclosingElement()));
+                return null;
               }
 
-              return null;
-            }
-
-            @Override
-            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report =
-                  methodValidator.validate(methodElement);
-
-              report.printMessagesTo(messager);
-
-              if (report.isClean()) {
-                membersInjectedTypes.add(
-                    MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
+              @Override
+              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+                injectBindingRegistry.tryRegisterMembersInjectedType(
+                    MoreElements.asType(methodElement.getEnclosingElement()));
+                return null;
               }
-
-              return null;
-            }
-          }, null);
+            },
+            null);
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(injectElement);
+      }
     }
 
-    for (DeclaredType injectedType : membersInjectedTypes.build()) {
-      injectBindingRegistry.registerBinding(membersInjectionBindingFactory.forInjectedType(
-          injectedType, Optional.<TypeMirror>absent()));
-    }
-
-    for (ProvisionBinding binding : provisions.build()) {
-      injectBindingRegistry.registerBinding(binding);
-    }
-    return ImmutableSet.of();
+    return rejectedElements.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
new file mode 100644
index 000000000..745fe7b79
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.Iterables;
+import com.google.common.io.CharSink;
+import com.google.common.io.CharSource;
+import com.google.googlejavaformat.java.Formatter;
+import com.google.googlejavaformat.java.FormatterException;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.TypeSpec;
+import java.io.IOException;
+import java.io.Writer;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * <p>This differs from {@link JavaWriterSourceFileGenerator} only in that it uses JavaPoet for
+ * constructing the source code model. It is intended for this to take on all usages of JavaWriter.
+ *
+ * @param <T> The input type from which source is to be generated.
+ */
+abstract class JavaPoetSourceFileGenerator<T> implements SourceFileGenerator<T> {
+  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
+
+  private static final AnnotationSpec GENERATED =
+      AnnotationSpec.builder(Generated.class)
+          .addMember("value", "$S", ComponentProcessor.class.getName())
+          .addMember("comments", "$S", GENERATED_COMMENTS)
+          .build();
+
+  private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
+
+  JavaPoetSourceFileGenerator(Filer filer, Elements elements) {
+    this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
+  }
+
+  @Override
+  public final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    try {
+      Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+      if (!type.isPresent()) {
+        return;
+      }
+      JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
+
+      final JavaFileObject sourceFile = filer.createSourceFile(
+          generatedTypeName.toString(),
+          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));
+      try {
+        new Formatter().formatSource(
+            CharSource.wrap(javaFile.toString()),
+            new CharSink() {
+              @Override public Writer openStream() throws IOException {
+                return sourceFile.openWriter();
+              }
+            });
+      } catch (FormatterException e) {
+        throw new SourceFileGenerationException(
+            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(
+          Optional.<ClassName>absent(), e, getElementForErrorReporting(input));
+    }
+  }
+
+  private JavaFile buildJavaFile(
+      ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
+    if (generatedAnnotationAvailable) {
+      typeSpecBuilder.addAnnotation(GENERATED);
+    }
+    JavaFile.Builder javaFileBuilder =
+        JavaFile.builder(generatedTypeName.packageName(), typeSpecBuilder.build())
+            .skipJavaLangImports(true);
+    if (!generatedAnnotationAvailable) {
+      javaFileBuilder.addFileComment(
+          "Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
+    }
+    return javaFileBuilder.build();
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
+   * Optional#absent()} if no file should be generated.
+   */
+  // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.
+  // consider renaming to something like typeBuilder() which conveys the mutability of the result
+  abstract Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
new file mode 100644
index 000000000..e43b1a5c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.io.IOException;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * @param <T> The input type from which source is to be generated.
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class JavaWriterSourceFileGenerator<T> implements SourceFileGenerator<T> {
+  private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
+
+  JavaWriterSourceFileGenerator(Filer filer, Elements elements) {
+    this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
+  }
+
+  @Override
+  public final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    ImmutableSet<Element> originatingElements =
+        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
+    try {
+      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
+      for (JavaWriter javaWriter : writers) {
+        javaWriter.markGenerated(generatedAnnotationAvailable);
+        try {
+          javaWriter.file(filer, originatingElements);
+        } catch (IOException e) {
+          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
+              e, getElementForErrorReporting(input));
+        }
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
+          getElementForErrorReporting(input));
+    }
+  }
+
+  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
+    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
+      @Override public ClassName apply(TypeWriter input) {
+        return input.name();
+      }
+    });
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Implementations should return {@link Element} instances from which the source is to be
+   * generated.
+   */
+  abstract Iterable<? extends Element> getOriginatingElements(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   * Returns a set of writers to be generated for {@code T} input.
+   */
+  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index cd7579659..77a92ed3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,12 +20,17 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.MapKey;
+import dagger.Multibindings;
 import dagger.Provides;
+import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
 import java.util.Map;
@@ -46,13 +51,12 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -63,6 +67,13 @@
  */
 @AutoValue
 abstract class Key {
+  
+  /** An object that is associated with a {@link Key}. */
+  interface HasKey {
+    /** The key associated with this object. */
+    Key key();
+  }
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -154,6 +165,42 @@ public String toString() {
         .toString();
   }
 
+  /**
+   * Indexes {@code haveKeys} by {@link HasKey#key()}.
+   */
+  static <T extends HasKey> ImmutableSetMultimap<Key, T> indexByKey(Iterable<T> haveKeys) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            haveKeys,
+            new Function<HasKey, Key>() {
+              @Override
+              public Key apply(HasKey hasKey) {
+                return hasKey.key();
+              }
+            }));
+  }
+
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
+   */
+  private static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
+      Equivalence<T> equivalence, Optional<T> optional) {
+    return optional.isPresent()
+        ? Optional.of(equivalence.wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<T>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
+   * type.
+   */
+  private static <T> Optional<T> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<T>absent();
+  }
+
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -201,6 +248,16 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
       return forMethod(componentMethod, keyType);
     }
 
+    Key forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      ExecutableType resolvedMethod =
+          asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+      TypeMirror returnType = normalize(types, resolvedMethod.getReturnType());
+      return forMethod(subcomponentBuilderMethod, returnType);
+    }
+
     Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
       checkArgument(method.getKind().equals(METHOD));
@@ -216,7 +273,7 @@ Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       return forMethod(method, keyType);
     }
 
-    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
     Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
@@ -237,6 +294,28 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
               Optional.of(producesAnnotation.type()));
       return forMethod(method, keyType);
     }
+    
+    /**
+     * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
+     *
+     * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
+     * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+     */
+    Key forMultibindingsMethod(
+        BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+      checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
+      TypeElement factoryType =
+          elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror keyType =
+          MapType.isMap(returnType)
+              ? mapOfFrameworkType(
+                  MapType.from(returnType).keyType(),
+                  factoryType,
+                  MapType.from(returnType).valueType())
+              : returnType;
+      return forMethod(method, keyType);
+    }
 
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
@@ -251,10 +330,10 @@ private TypeMirror providesOrProducesKeyType(
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFactoryType(
-              method,
-              returnType,
-              providesType.isPresent() ? getProviderElement() : getProducerElement());
+          return mapOfFrameworkType(
+              mapKeyType(method),
+              providesType.isPresent() ? getProviderElement() : getProducerElement(),
+              returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
@@ -264,17 +343,18 @@ private TypeMirror providesOrProducesKeyType(
       }
     }
 
-    private TypeMirror mapOfFactoryType(
-        ExecutableElement method, TypeMirror valueType, TypeElement factoryType) {
-      TypeMirror mapKeyType = mapKeyType(method);
-      TypeMirror mapValueFactoryType = types.getDeclaredType(factoryType, valueType);
-      return types.getDeclaredType(getMapElement(), mapKeyType, mapValueFactoryType);
+    /**
+     * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
+     */
+    private TypeMirror mapOfFrameworkType(
+        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
       AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
-      MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-      return mapKey.unwrapValue()
+      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
           ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
           : mapKeyAnnotation.getAnnotationType();
     }
@@ -321,10 +401,39 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     /**
      * Optionally extract a {@link Key} for the underlying production binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Producer<V>>} will be returned.
+     * {@link Map}{@code <K, V>} or {@code Map<K, Produced<V>>}, a key of
+     * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Producer.class);
+      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
+          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+    }
+
+    /**
+     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
+     * {@code Map<K, CurrentWrappingClass<V>>}.
+     */
+    private Optional<Key> maybeRewrapMapValue(
+        Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
+      checkArgument(!currentWrappingClass.equals(newWrappingClass));
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (mapType.valuesAreTypeOf(currentWrappingClass)) {
+          TypeElement wrappingElement = getClassElement(newWrappingClass);
+          if (wrappingElement == null) {
+            // This target might not be compiled with Producers, so wrappingClass might not have an
+            // associated element.
+            return Optional.absent();
+          }
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(
+                  wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+        }
+      }
+      return Optional.absent();
     }
 
     /**
@@ -332,22 +441,37 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
      * {@code Map<K, V>}.
      */
     private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
-        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
-        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
-          DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (!mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
             return Optional.absent();
           }
-          DeclaredType wrappedType = types.getDeclaredType(wrappingElement, mapValueType);
-          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, wrappedType);
-          return Optional.<Key>of(new AutoValue_Key(
-              possibleMapKey.wrappedQualifier(),
-              MoreTypes.equivalence().wrap(mapType)));
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(wrappingElement, mapType.valueType());
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+        }
+      }
+      return Optional.absent();
+    }
+
+    /**
+     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
+     * {@code Set<Produced<T>>}.
+     */
+    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
+      if (MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
+        TypeMirror argType =
+            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
+        if (MoreTypes.isTypeOf(Produced.class, argType)) {
+          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
+          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
+          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
         }
       }
       return Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index d2e62fcab..6e695f33a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -26,7 +26,7 @@
   @Override public String format(Key request) {
     StringBuilder builder = new StringBuilder();
     if (request.qualifier().isPresent()) {
-      builder.append(request.qualifier()); // TODO(cgruber): Use AnnotationMirrorFormatter.
+      builder.append(request.qualifier().get());
       builder.append(' ');
     }
     builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
index c32d50806..5fe12b102 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -39,10 +39,7 @@ public String apply(Key key) {
     StringBuilder builder = new StringBuilder();
 
     if (key.qualifier().isPresent()) {
-      if (!key.qualifier().get().getElementValues().isEmpty()) {
-        // TODO(gak): obviously we need to support this
-        throw new UnsupportedOperationException();
-      }
+      // TODO(gak): Use a better name for fields with qualifiers with members.
       builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 8d72e5e48..423d62615 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -20,29 +20,28 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.MapKey;
 import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeWriter;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.MapKeys.getJavapoetMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -53,7 +52,7 @@
  *
  * @since 2.0
  */
-final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+final class MapKeyGenerator extends JavaPoetSourceFileGenerator<MapKeyCreatorSpecification> {
 
   /**
    * Specification of the {@link MapKey} annotation and the annotation type to generate.
@@ -90,18 +89,13 @@ static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
     }
   }
 
-  MapKeyGenerator(Filer filer) {
-    super(filer);
+  MapKeyGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
   }
 
   @Override
   ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return ImmutableSet.of(mapKeyCreatorType.mapKeyElement());
+    return getJavapoetMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
@@ -111,41 +105,41 @@ ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(
+  Optional<TypeSpec.Builder> write(
       ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    TypeWriter mapKeyCreatorWriter = writer.addClass(generatedTypeName.simpleName());
-    mapKeyCreatorWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    mapKeyCreatorWriter.addModifiers(PUBLIC, FINAL);
+    TypeSpec.Builder mapKeyCreatorBuilder =
+        classBuilder(generatedTypeName.simpleName()).addModifiers(PUBLIC, FINAL);
 
     for (TypeElement annotationElement :
         nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
-      writeCreateMethod(mapKeyCreatorWriter, annotationElement);
+      mapKeyCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
     }
 
-    return ImmutableSet.of(writer);
+    return Optional.of(mapKeyCreatorBuilder);
   }
 
-  private void writeCreateMethod(TypeWriter mapKeyCreatorWriter, TypeElement annotationElement) {
-    MethodWriter createMethod =
-        mapKeyCreatorWriter.addMethod(
-            annotationElement.asType(), "create" + annotationElement.getSimpleName());
-
-    createMethod.annotate(AutoAnnotation.class);
-    createMethod.addModifiers(PUBLIC, STATIC);
+  private MethodSpec buildCreateMethod(
+      ClassName mapKeyGeneratedTypeName, TypeElement annotationElement) {
+    String createMethodName = "create" + annotationElement.getSimpleName();
+    MethodSpec.Builder createMethod =
+        methodBuilder(createMethodName)
+            .addAnnotation(AutoAnnotation.class)
+            .addModifiers(PUBLIC, STATIC)
+            .returns(TypeName.get(annotationElement.asType()));
 
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (ExecutableElement annotationMember : methodsIn(annotationElement.getEnclosedElements())) {
       String parameterName = annotationMember.getSimpleName().toString();
-      TypeName parameterType = TypeNames.forTypeMirror(annotationMember.getReturnType());
+      TypeName parameterType = TypeName.get(annotationMember.getReturnType());
       createMethod.addParameter(parameterType, parameterName);
-      parameters.add(Snippet.format("%s", parameterName));
+      parameters.add(CodeBlocks.format("$L", parameterName));
     }
 
-    ClassName autoAnnotationClass = mapKeyCreatorWriter.name().peerNamed(
-        "AutoAnnotation_" + mapKeyCreatorWriter.name().simpleName() + "_" + createMethod.name());
-    createMethod.body().addSnippet(
-        "return new %s(%s);", autoAnnotationClass, makeParametersSnippet(parameters.build()));
+    ClassName autoAnnotationClass = mapKeyGeneratedTypeName.peerClass(
+        "AutoAnnotation_" + mapKeyGeneratedTypeName.simpleName() + "_" + createMethodName);
+    createMethod.addStatement(
+        "return new $T($L)", autoAnnotationClass, makeParametersCodeBlock(parameters.build()));
+    return createMethod.build();
   }
 
   private static Set<TypeElement> nestedAnnotationElements(TypeElement annotationElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 01b0951a6..586a1e935 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -28,24 +28,23 @@
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * A {@link Validator} for {@link MapKey} annotations.
+ * A validator for {@link MapKey} annotations.
  *
  * @author Chenying Hou
  * @since 2.0
  */
 // TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
-final class MapKeyValidator implements Validator<Element> {
-  @Override
-  public ValidationReport<Element> validate(Element element) {
-    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+final class MapKeyValidator {
+  ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
     if (members.isEmpty()) {
-      builder.addItem(MAPKEY_WITHOUT_MEMBERS, element);
+      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);
     } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
       if (members.size() > 1) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
       }
     }
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index f378bbb26..3bfd46916 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -48,6 +48,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.transform;
+import static dagger.internal.codegen.SourceFiles.classFileName;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -76,6 +77,22 @@
     return getAnnotatedAnnotations(bindingElement, MapKey.class);
   }
 
+  /**
+   * Returns the annotation value if {@code mapKey}'s type is annotated with
+   * {@link MapKey @MapKey(unwrapValue = true)}.
+   *
+   * @throws IllegalArgumentException if {@code mapKey}'s type is not annotated with
+   *     {@link MapKey @MapKey} at all.
+   */
+  static Optional<? extends AnnotationValue> unwrapValue(AnnotationMirror mapKey) {
+    MapKey mapKeyAnnotation = mapKey.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    checkArgument(
+        mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
+    return mapKeyAnnotation.unwrapValue()
+        ? Optional.of(getOnlyElement(mapKey.getElementValues().values()))
+        : Optional.<AnnotationValue>absent();
+  }
+
   /**
    * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
    * type is primitive, returns the boxed type.
@@ -116,15 +133,24 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
     return keyTypeElementVisitor.visit(onlyElement.getReturnType());
   }
 
+  /**
+   * Returns the name of the generated class that contains the static {@code create} methods for a
+   * {@link MapKey} annotation type.
+   */
+  public static com.squareup.javapoet.ClassName getJavapoetMapKeyCreatorClassName(
+      TypeElement mapKeyType) {
+    com.squareup.javapoet.ClassName mapKeyTypeName =
+        com.squareup.javapoet.ClassName.get(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerClass(classFileName(mapKeyTypeName) + "Creator");
+  }
+
   /**
    * Returns the name of the generated class that contains the static {@code create} methods for a
    * {@link MapKey} annotation type.
    */
   public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
-    return enclosingClassName
-        .topLevelClassName()
-        .peerNamed(enclosingClassName.classFileName() + "Creator");
+    ClassName mapKeyTypeName = ClassName.fromTypeElement(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerNamed(mapKeyTypeName.classFileName() + "Creator");
   }
 
   /**
@@ -138,11 +164,12 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    */
   static Snippet getMapKeySnippet(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
-    TypeElement mapKeyAnnotationType = MoreTypes.asTypeElement(mapKey.getAnnotationType());
-    ClassName mapKeyCreator = MapKeys.getMapKeyCreatorClassName(mapKeyAnnotationType);
-    if (mapKeyAnnotationType.getAnnotation(MapKey.class).unwrapValue()) {
-      AnnotationValue memberToUnwrap = getOnlyElement(mapKey.getElementValues().values());
-      return new MapKeySnippetExceptArrays(mapKeyCreator).visit(memberToUnwrap, memberToUnwrap);
+    ClassName mapKeyCreator =
+        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
+    Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+    if (unwrappedValue.isPresent()) {
+      return new MapKeySnippetExceptArrays(mapKeyCreator)
+          .visit(unwrappedValue.get(), unwrappedValue.get());
     } else {
       return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
new file mode 100644
index 000000000..5c0faf820
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Map;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Map} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class MapType {
+  /**
+   * The map type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredMapType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredMapType();
+
+  /**
+   * The map type itself.
+   */
+  DeclaredType declaredMapType() {
+    return wrappedDeclaredMapType().get();
+  }
+
+  /**
+   * {@code true} if the map type is the raw {@link Map} type.
+   */
+  boolean isRawType() {
+    return declaredMapType().getTypeArguments().isEmpty();
+  }
+
+  /**
+   * The map key type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  TypeMirror keyType() {
+    checkState(!isRawType());
+    return declaredMapType().getTypeArguments().get(0);
+  }
+
+  /**
+   * The map value type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  TypeMirror valueType() {
+    checkState(!isRawType());
+    return declaredMapType().getTypeArguments().get(1);
+  }
+
+  /**
+   * {@code true} if {@link #valueType()} is a {@code clazz}.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
+   */
+  boolean valuesAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(valueType()) && MoreTypes.isTypeOf(clazz, valueType());
+  }
+
+  /**
+   * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
+   *
+   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a
+   *     {@code WrappingClass<V>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedValueType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(valuesAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Map} type.
+   */
+  static boolean isMap(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Map.class, type);
+  }
+
+  /**
+   * Returns a {@link MapType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Map} type
+   */
+  static MapType from(TypeMirror type) {
+    checkArgument(isMap(type), "%s is not a Map", type);
+    return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
new file mode 100644
index 000000000..54fc45e87
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import dagger.MembersInjector;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+/**
+ * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link Snippet}.
+ */
+abstract class MemberSelect {
+  /**
+   * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by
+   * {@code owningClass}.  In this context "local" refers to the fact that the field is owned by the
+   * type (or an enclosing type) from which the snippet will be used.  The returned
+   * {@link MemberSelect} will not be valid for accessing the field from a different class
+   * (regardless of accessibility).
+   */
+  static MemberSelect localField(ClassName owningClass, String fieldName) {
+    return new LocalField(owningClass, fieldName);
+  }
+
+  private static final class LocalField extends MemberSelect {
+    final String fieldName;
+
+    LocalField(ClassName owningClass, String fieldName) {
+      super(owningClass, false);
+      this.fieldName = checkNotNull(fieldName);
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? Snippet.format("%s", fieldName)
+          : Snippet.format("%s.this.%s", owningClass(), fieldName);
+    }
+  }
+
+  /**
+   * Returns a {@link MemberSelect} for the invocation of a static method (given by
+   * {@code methodInvocationSnippet}) on the {@code owningClass}.
+   */
+  static MemberSelect staticMethod(ClassName owningClass, Snippet methodInvocationSnippet) {
+    return new StaticMethod(owningClass, methodInvocationSnippet);
+  }
+
+  private static final class StaticMethod extends MemberSelect {
+    final Snippet methodSnippet;
+
+    StaticMethod(ClassName owningClass, Snippet methodSnippet) {
+      super(owningClass, true);
+      this.methodSnippet = checkNotNull(methodSnippet);
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? methodSnippet
+          : Snippet.format("%s.%s", owningClass(), methodSnippet);
+    }
+  }
+
+  /**
+   * Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type.
+   */
+  static MemberSelect noOpMembersInjector(TypeMirror type) {
+    return new ParameterizedStaticMethod(
+        ClassName.fromClass(MembersInjectors.class),
+        ImmutableList.of(type),
+        Snippet.format("noOp()"),
+        ClassName.fromClass(MembersInjector.class));
+  }
+
+  /**
+   * Returns the {@link MemberSelect} an empty implementation of {@link MapProviderFactory}.
+   */
+  static MemberSelect emptyMapProviderFactory(MapType mapType) {
+    return new ParameterizedStaticMethod(
+        ClassName.fromClass(MapProviderFactory.class),
+        ImmutableList.of(mapType.keyType(), mapType.unwrappedValueType(Provider.class)),
+        Snippet.format("empty()"),
+        ClassName.fromClass(MapProviderFactory.class));
+  }
+
+  /**
+   * Returns the {@link MemberSelect} for an empty set provider.  Since there are several different
+   * implementations for a multibound {@link Set}, the caller is responsible for passing the
+   * correct factory.
+   */
+  static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {
+    return new ParameterizedStaticMethod(
+        setFactoryType,
+        ImmutableList.of(setType.elementType()),
+        Snippet.format("create()"),
+        ClassName.fromClass(Set.class));
+  }
+
+  static final class ParameterizedStaticMethod extends MemberSelect {
+    final ImmutableList<TypeMirror> typeParameters;
+    final Snippet methodSnippet;
+    final ClassName rawReturnType;
+
+    ParameterizedStaticMethod(
+        ClassName owningClass,
+        ImmutableList<TypeMirror> typeParameters,
+        Snippet methodSnippet,
+        ClassName rawReturnType) {
+      super(owningClass, true);
+      this.typeParameters = typeParameters;
+      this.methodSnippet = methodSnippet;
+      this.rawReturnType = rawReturnType;
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      boolean accessible = true;
+      for (TypeMirror typeParameter : typeParameters) {
+        accessible &= isTypeAccessibleFrom(typeParameter, usingClass.packageName());
+      }
+
+      if (accessible) {
+        Snippet typeParametersSnippet = Snippet.makeParametersSnippet(
+            FluentIterable.from(typeParameters)
+                .transform(new Function<TypeMirror, Snippet>() {
+                  @Override
+                  public Snippet apply(TypeMirror input) {
+                    return Snippet.format("%s", TypeNames.forTypeMirror(input));
+                  }
+                }));
+        return Snippet.format(
+            "%s.<%s>%s",
+            owningClass(),
+            typeParametersSnippet,
+            methodSnippet);
+      } else {
+        return Snippet.format(
+            "((%s) %s.%s)",
+            rawReturnType,
+            owningClass(),
+            methodSnippet);
+      }
+    }
+  }
+
+  private final ClassName owningClass;
+  private final boolean staticMember;
+
+  MemberSelect(ClassName owningClass, boolean staticMemeber) {
+    this.owningClass = owningClass;
+    this.staticMember = staticMemeber;
+  }
+
+  /** Returns the class that owns the member being selected. */
+  ClassName owningClass() {
+    return owningClass;
+  }
+
+  /**
+   * Returns true if the member being selected is static and does not require an instance of
+   * {@link #owningClass()}.
+   */
+  boolean staticMember() {
+    return staticMember;
+  }
+
+  /**
+   * Returns a {@link Snippet} suitable for accessing the member from the given {@code usingClass}.
+   */
+  abstract Snippet getSnippetFor(ClassName usingClass);
+}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java
new file mode 100644
index 000000000..1508db4b2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectedTypeValidator.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+
+/** Validates the {@code @Inject} fields and methods in a class and its superclasses. */
+final class MembersInjectedTypeValidator {
+  private final InjectFieldValidator fieldValidator;
+  private final InjectMethodValidator methodValidator;
+
+  MembersInjectedTypeValidator(
+      InjectFieldValidator fieldValidator, InjectMethodValidator methodValidator) {
+    this.fieldValidator = fieldValidator;
+    this.methodValidator = methodValidator;
+  }
+
+  ValidationReport<TypeElement> validate(TypeElement typeElement) {
+    // TODO(beder): This element might not be currently compiled, so this error message could be
+    // left in limbo. Find an appropriate way to display the error message in that case.
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+    for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<VariableElement> report = fieldValidator.validate(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, Inject.class)) {
+        ValidationReport<ExecutableElement> report = methodValidator.validate(element);
+        if (!report.isClean()) {
+          builder.addSubreport(report);
+        }
+      }
+    }
+    TypeMirror superclass = typeElement.getSuperclass();
+    if (!superclass.getKind().equals(TypeKind.NONE)) {
+      ValidationReport<TypeElement> report = validate(MoreTypes.asTypeElement(superclass));
+      if (!report.isClean()) {
+        builder.addSubreport(report);
+      }
+    }
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 4f48d8d59..53d15ee8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,15 +20,22 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -43,71 +50,66 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Represents the full members injection of a particular type. This does not pay attention to
- * injected members on supertypes.
+ * Represents the full members injection of a particular type.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
-  @Override abstract TypeElement bindingElement();
+  @Override
+  abstract Optional<MembersInjectionBinding> unresolved();
+
+  @Override
+  TypeElement bindingElement() {
+    return MoreElements.asType(super.bindingElement());
+  }
+
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    return dependencies();
+  }
 
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
-  abstract Optional<DependencyRequest> parentInjectorRequest();
+  /**
+   * The {@link Key} for the non-object superclass of {@link #bindingElement()}. Absent if
+   * {@link #bindingElement()} is a direct subclass of {@link Object}. 
+   */
+  abstract Optional<Key> parentKey();
 
   enum Strategy {
     NO_OP,
-    DELEGATE,
     INJECT_MEMBERS,
   }
 
   Strategy injectionStrategy() {
-    if (injectionSites().isEmpty()) {
-      return parentInjectorRequest().isPresent()
-          ? Strategy.DELEGATE
-          : Strategy.NO_OP;
-    } else {
-      return Strategy.INJECT_MEMBERS;
-    }
+    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
-  MembersInjectionBinding withoutParentInjectorRequest() {
-    return new AutoValue_MembersInjectionBinding(
-          key(),
-          dependencies(),
-          implicitDependencies(),
-          bindingPackage(),
-          hasNonDefaultTypeParameters(),
-          bindingElement(),
-          injectionSites(),
-          Optional.<DependencyRequest>absent());
+  @Override
+  public BindingType bindingType() {
+    return BindingType.MEMBERS_INJECTION;
   }
 
-  private static final Ordering<InjectionSite> INJECTION_ORDERING =
-      new Ordering<InjectionSite>() {
-        @Override
-        public int compare(InjectionSite left, InjectionSite right) {
-          checkArgument(left.element().getEnclosingElement()
-              .equals(right.element().getEnclosingElement()));
-          return ComparisonChain.start()
-              // fields before methods
-              .compare(left.element().getKind(), right.element().getKind())
-              // then sort by whichever element comes first in the parent
-              // this isn't necessary, but makes the processor nice and predictable
-              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
-              .result();
-        }
-
-        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
-          return injectionSite.element().getEnclosingElement().getEnclosedElements()
-              .indexOf(injectionSite.element());
-        }
-      };
+  /**
+   * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
+   */
+  boolean hasLocalInjectionSites() {
+    return FluentIterable.from(injectionSites())
+        .anyMatch(
+            new Predicate<InjectionSite>() {
+              @Override
+              public boolean apply(InjectionSite injectionSite) {
+                return injectionSite.element().getEnclosingElement().equals(bindingElement());
+              }
+            });
+  }
 
   @AutoValue
   abstract static class InjectionSite {
@@ -121,6 +123,14 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+    
+    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+      return injectionSite
+          .element()
+          .getEnclosingElement()
+          .getEnclosedElements()
+          .indexOf(injectionSite.element());
+    }
   }
 
   static final class Factory {
@@ -137,38 +147,36 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectMethod(
+        ExecutableElement methodElement, DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-      checkArgument(isAnnotationPresent(methodElement, Inject.class));
       ExecutableType resolved =
           MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType,
-              methodElement.getParameters(),
-              resolved.getParameterTypes()));
+              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectField(
+        VariableElement fieldElement, DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
-              containingType, fieldElement, resolved)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(
+                  containingType, fieldElement, resolved)));
     }
 
-    /** Returns an unresolved version of this binding. */
-    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
-      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
+    /** Returns true if the type has some injected members in itself or any of its super classes. */
+    boolean hasInjectedMembers(DeclaredType declaredType) {
+      return !getInjectionSites(declaredType).isEmpty();
     }
 
     /**
@@ -176,72 +184,149 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
      * this will return a resolved binding, with the key & type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+    MembersInjectionBinding forInjectedType(
+        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
       // If the class this is injecting has some type arguments, resolve everything.
-      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
         // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+        checkState(
+            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
             "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(type));
-        type = resolved;
+            types.erasure(resolved),
+            types.erasure(declaredType));
+        declaredType = resolved;
       }
+      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
+      ImmutableSet<DependencyRequest> dependencies =
+          FluentIterable.from(injectionSites)
+              .transformAndConcat(
+                  new Function<InjectionSite, Set<DependencyRequest>>() {
+                    @Override
+                    public Set<DependencyRequest> apply(InjectionSite input) {
+                      return input.dependencies();
+                    }
+                  })
+              .toSet();
 
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      final DeclaredType resolved = type;
-      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
-          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        injectionSitesBuilder.addAll(enclosedElement.accept(
-            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
-                Optional.<InjectionSite>absent()) {
-                  @Override
-                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
-                      Void p) {
-                    return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-
-                  @Override
-                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
-                    return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectField(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-                }, null).asSet());
-      }
-      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
+      Optional<Key> parentKey =
+          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
+              .transform(
+                  new Function<DeclaredType, Key>() {
+                    @Override
+                    public Key apply(DeclaredType superclass) {
+                      return keyFactory.forMembersInjectedType(superclass);
+                    }
+                  });
 
-      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
-          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-            @Override public Set<DependencyRequest> apply(InjectionSite input) {
-              return input.dependencies();
-            }
-          })
-          .toSet();
-
-      Optional<DependencyRequest> parentInjectorRequest =
-          MoreTypes.nonObjectSuperclass(types, elements, type)
-              .transform(new Function<DeclaredType, DependencyRequest>() {
-                @Override public DependencyRequest apply(DeclaredType input) {
-                  return dependencyRequestFactory.forMembersInjectedType(input);
-                }
-              });
-
-      Key key = keyFactory.forMembersInjectedType(type);
+      Key key = keyFactory.forMembersInjectedType(declaredType);
+      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
+          SourceElement.forElement(typeElement),
           key,
           dependencies,
-          new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(parentInjectorRequest.asSet())
-              .addAll(dependencies)
-              .build(),
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(typeElement, key.type(), types),
-          typeElement,
+          hasNonDefaultTypeParameters(typeElement, key.type(), types)
+              ? Optional.of(
+                  forInjectedType(
+                      MoreTypes.asDeclared(typeElement.asType()), Optional.<TypeMirror>absent()))
+              : Optional.<MembersInjectionBinding>absent(),
           injectionSites,
-          parentInjectorRequest);
+          parentKey);
     }
+
+    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
+      Set<InjectionSite> injectionSites = new HashSet<>();
+      final List<TypeElement> ancestors = new ArrayList<>();
+      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
+      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
+          currentType.isPresent();
+          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+        final DeclaredType type = currentType.get();
+        ancestors.add(MoreElements.asType(type.asElement()));
+        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
+          Optional<InjectionSite> maybeInjectionSite =
+              injectionSiteVisitor.visit(enclosedElement, type);
+          if (maybeInjectionSite.isPresent()) {
+            InjectionSite injectionSite = maybeInjectionSite.get();
+            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
+              injectionSites.add(injectionSite);
+            }
+            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+              ExecutableElement injectionSiteMethod =
+                  MoreElements.asExecutable(injectionSite.element());
+              overriddenMethodMap.put(
+                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
+            }
+          }
+        }
+      }
+      return ImmutableSortedSet.copyOf(
+          new Comparator<InjectionSite>() {
+            @Override
+            public int compare(InjectionSite left, InjectionSite right) {
+              return ComparisonChain.start()
+                  // supertypes before subtypes
+                  .compare(
+                      ancestors.indexOf(right.element().getEnclosingElement()),
+                      ancestors.indexOf(left.element().getEnclosingElement()))
+                  // fields before methods
+                  .compare(left.element().getKind(), right.element().getKind())
+                  // then sort by whichever element comes first in the parent
+                  // this isn't necessary, but makes the processor nice and predictable
+                  .compare(
+                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
+                  .result();
+            }
+          },
+          injectionSites);
+    }
+
+    private boolean shouldBeInjected(
+        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
+      if (!isAnnotationPresent(injectionSite, Inject.class)
+          || injectionSite.getModifiers().contains(PRIVATE)
+          || injectionSite.getModifiers().contains(STATIC)) {
+        return false;
+      }
+
+      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
+        return true;
+      }
+
+      // For each method with the same name belonging to any descendant class, return false if any
+      // method has already overridden the injectionSite method. To decrease the number of methods
+      // that are checked, we store the already injected methods in a SetMultimap and only
+      // check the methods with the same name.
+      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
+      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
+      for (ExecutableElement method :
+          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
+        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
+            Optional.<InjectionSite>absent()) {
+          @Override
+          public Optional<InjectionSite> visitExecutableAsMethod(
+              ExecutableElement e, DeclaredType type) {
+            return Optional.of(injectionSiteForInjectMethod(e, type));
+          }
+
+          @Override
+          public Optional<InjectionSite> visitVariableAsField(
+              VariableElement e, DeclaredType type) {
+            return (isAnnotationPresent(e, Inject.class)
+                    && !e.getModifiers().contains(PRIVATE)
+                    && !e.getModifiers().contains(STATIC))
+                ? Optional.of(injectionSiteForInjectField(e, type))
+                : Optional.<InjectionSite>absent();
+          }
+        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4d0db6cc..d4539a8f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,49 +15,57 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeVariableName;
-import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
-import javax.annotation.Generated;
+import java.util.Set;
 import javax.annotation.processing.Filer;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
+import javax.lang.model.util.SimpleTypeVisitor7;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -65,37 +73,18 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
-  private final Elements elements;
-  private final Types types;
+final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
-      Filer filer,
-      Elements elements,
-      Types types,
-      DependencyRequestMapper dependencyRequestMapper) {
-    super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
+      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(
-      MembersInjectionBinding binding) {
-    return FluentIterable.from(binding.injectionSites())
-        .transform(new Function<InjectionSite, Element>() {
-          @Override public Element apply(InjectionSite injectionSite) {
-            return injectionSite.element();
-          }
-        })
-        .toSet();
+    return javapoetMembersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -104,113 +93,312 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // Empty members injection bindings are special and don't need source files.
+    if (binding.injectionSites().isEmpty()) {
+      return Optional.absent();
+    }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.unresolved().isPresent());
 
-    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    TypeSpec.Builder injectorTypeBuilder =
+        classBuilder(generatedTypeName.simpleName())
+            .addModifiers(PUBLIC, FINAL)
+            .addTypeVariables(typeParameters);
 
-    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
-    List<TypeVariableName> typeParameters = Lists.newArrayList();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
-    }
-    injectorWriter.addTypeParameters(typeParameters);
-    injectorWriter.annotate(Generated.class)
-        .setValue(ComponentProcessor.class.getCanonicalName());
-    injectorWriter.addModifiers(PUBLIC, FINAL);
-    TypeName implementedType =
-        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
-    injectorWriter.addImplementedType(implementedType);
-
-    ConstructorWriter constructorWriter = injectorWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-    MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
-    injectMembersWriter.addModifiers(PUBLIC);
-    injectMembersWriter.annotate(Override.class);
-    injectMembersWriter.addParameter(injectedTypeName, "instance");
-    injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
-        "if (instance == null) {",
-        "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "}"));
-
-    Optional<DeclaredType> supertype =
-        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
-    if (supertype.isPresent()) {
-      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
-      injectorWriter
-          .addField(supertypeMemebersInjectorType, "supertypeInjector")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
-      constructorWriter.body()
-          .addSnippet("assert supertypeInjector != null;")
-          .addSnippet("this.supertypeInjector = supertypeInjector;");
-      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
-    }
+    TypeName injectedTypeName = TypeName.get(binding.key().type());
+    TypeName implementedType = membersInjectorOf(injectedTypeName);
+    injectorTypeBuilder.addSuperinterface(implementedType);
+
+    MethodSpec.Builder injectMembersBuilder =
+        methodBuilder("injectMembers")
+            .returns(TypeName.VOID)
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(injectedTypeName, "instance")
+            .addCode("if (instance == null) {")
+            .addStatement(
+                "throw new $T($S)",
+                NullPointerException.class,
+                "Cannot inject members into a null reference")
+            .addCode("}");
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
-    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
-        ImmutableMap.builder();
+    ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
+
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
 
-    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
-      FrameworkField bindingField = fieldEntry.getValue();
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body().addSnippet("assert %s != null;", field.name());
-      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
-      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
-    }
-    
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
     // (Otherwise they may have visibility problems referring to the types.)
-    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
-    createMethodWriter.addTypeParameters(typeParameters);
-    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-    Map<String, TypeName> params = constructorWriter.parameters();
-    for (Map.Entry<String, TypeName> param : params.entrySet()) {
-      createMethodWriter.addParameter(param.getValue(), param.getKey());      
+    MethodSpec.Builder createMethodBuilder =
+        methodBuilder("create")
+            .returns(implementedType)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addTypeVariables(typeParameters);
+
+    createMethodBuilder.addCode(
+        "return new $T(", javapoetParameterizedGeneratedTypeNameForBinding(binding));
+    ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
+
+    boolean usesRawFrameworkTypes = false;
+    UniqueNames fieldNames = new UniqueNames();
+    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
+      BindingKey bindingKey = fieldEntry.getKey();
+      FrameworkField bindingField = fieldEntry.getValue();
+
+      // If the dependency type is not visible to this members injector, then use the raw framework
+      // type for the field.
+      boolean useRawFrameworkType =
+          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
+
+      String fieldName = fieldNames.getUniqueName(bindingField.name());
+      TypeName fieldType =
+          useRawFrameworkType
+              ? bindingField.javapoetFrameworkType().rawType
+              : bindingField.javapoetFrameworkType();
+      FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
+      ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
+
+      // If we're using the raw type for the field, then suppress the injectMembers method's
+      // unchecked-type warning and the field's and the constructor and create-method's
+      // parameters' raw-type warnings.
+      if (useRawFrameworkType) {
+        usesRawFrameworkTypes = true;
+        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+      }
+      constructorBuilder.addParameter(parameterBuilder.build());
+      createMethodBuilder.addParameter(parameterBuilder.build());
+
+      FieldSpec field = fieldBuilder.build();
+      injectorTypeBuilder.addField(field);
+      constructorBuilder.addStatement("assert $N != null", field);
+      constructorBuilder.addStatement("this.$N = $N", field, field);
+      dependencyFieldsBuilder.put(bindingKey, field);
+      constructorInvocationParameters.add(CodeBlocks.format("$N", field));
     }
-    createMethodWriter.body().addSnippet("  return new %s(%s);",
-        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
-        Joiner.on(", ").join(params.keySet()));
-    
-    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
+    createMethodBuilder.addCode(");");
+
+    injectorTypeBuilder.addMethod(constructorBuilder.build());
+    injectorTypeBuilder.addMethod(createMethodBuilder.build());
+
+    Set<String> delegateMethods = new HashSet<>();
+    ImmutableMap<BindingKey, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
+    List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      switch (injectionSite.kind()) {
-        case FIELD:
-          DependencyRequest fieldDependency =
-              Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(
-              fieldDependency.bindingKey());
-          injectMembersWriter.body().addSnippet("instance.%s = %s;",
-              injectionSite.element().getSimpleName(),
-              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
-                  fieldDependency.kind()));
-          break;
-        case METHOD:
-          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-          for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field = depedencyFields.get(
-                methodDependency.bindingKey());
-            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
-                methodDependency.kind()));
-          }
-          injectMembersWriter.body().addSnippet("instance.%s(%s);",
-              injectionSite.element().getSimpleName(),
-              Snippet.makeParametersSnippet(parameters.build()));
-          break;
-        default:
-          throw new AssertionError();
+      injectMembersBuilder.addCode(
+          visibleToMembersInjector(binding, injectionSite.element())
+              ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
+              : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
+      if (!injectionSite.element().getModifiers().contains(PUBLIC)
+          && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
+          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
+        injectMethodsForSubclasses.add(
+            injectorMethodForSubclasses(
+                dependencyFields,
+                typeParameters,
+                injectedTypeName,
+                injectionSite.element(),
+                injectionSite.dependencies()));
+      }
+    }
+
+    if (usesRawFrameworkTypes) {
+      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+    }
+
+    injectorTypeBuilder.addMethod(injectMembersBuilder.build());
+    for (MethodSpec methodSpec : injectMethodsForSubclasses) {
+      injectorTypeBuilder.addMethod(methodSpec);
+    }
+
+    return Optional.of(injectorTypeBuilder);
+  }
+
+  /**
+   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.
+   */
+  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but
+  // enclosed in a package-private element?
+  private static boolean visibleToMembersInjector(
+      MembersInjectionBinding binding, Element element) {
+    return getPackage(element).equals(getPackage(binding.bindingElement()))
+        || element.getModifiers().contains(PUBLIC);
+  }
+
+  /**
+   * Returns a code block that directly injects the instance's field or method.
+   */
+  private CodeBlock directInjectMemberCodeBlock(
+      MembersInjectionBinding binding,
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+      InjectionSite injectionSite) {
+    return CodeBlocks.format(
+        injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
+        getInstanceCodeBlockWithPotentialCast(
+            injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+        injectionSite.element().getSimpleName(),
+        makeParametersCodeBlock(
+            parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
+  }
+
+  /**
+   * Returns a code block that injects the instance's field or method by calling a static method on
+   * the parent MembersInjector class.
+   */
+  private CodeBlock delegateInjectMemberCodeBlock(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
+    return CodeBlocks.format(
+        "$L.$L($L);",
+        javapoetMembersInjectorNameForType(
+            MoreElements.asType(injectionSite.element().getEnclosingElement())),
+        injectionSiteDelegateMethodName(injectionSite.element()),
+        makeParametersCodeBlock(
+            new ImmutableList.Builder<CodeBlock>()
+                .add(CodeBlocks.format("instance"))
+                .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
+                .build()));
+  }
+
+  /**
+   * Returns the parameters for injecting a member.
+   *
+   * @param passValue if {@code true}, each parameter code block will be the result of converting
+   *     the field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real
+   *     value; if {@code false}, each parameter code block will be just the field
+   */
+  private ImmutableList<CodeBlock> parameterCodeBlocks(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+      ImmutableSet<DependencyRequest> dependencies,
+      boolean passValue) {
+    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
+    for (DependencyRequest dependency : dependencies) {
+      CodeBlock fieldCodeBlock =
+          CodeBlocks.format("$L", dependencyFields.get(dependency.bindingKey()).name);
+      parameters.add(
+          passValue
+              ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
+              : fieldCodeBlock);
+    }
+    return parameters.build();
+  }
+
+  private CodeBlock getInstanceCodeBlockWithPotentialCast(
+      Element injectionSiteElement, Element bindingElement) {
+    if (injectionSiteElement.equals(bindingElement)) {
+      return CodeBlocks.format("instance");
+    }
+    TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
+    if (injectionSiteName instanceof ParameterizedTypeName) {
+      injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
+    }
+    return CodeBlocks.format("(($T) instance)", injectionSiteName);
+  }
+
+  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+    return "inject"
+        + CaseFormat.LOWER_CAMEL.to(
+            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
+  }
+
+  private MethodSpec injectorMethodForSubclasses(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+      List<TypeVariableName> typeParameters,
+      TypeName injectedTypeName,
+      Element injectionElement,
+      ImmutableSet<DependencyRequest> dependencies) {
+    MethodSpec.Builder methodBuilder =
+        methodBuilder(injectionSiteDelegateMethodName(injectionElement))
+            .addModifiers(PUBLIC, STATIC)
+            .addParameter(injectedTypeName, "instance")
+            .addTypeVariables(typeParameters);
+    ImmutableList.Builder<CodeBlock> providedParameters = ImmutableList.builder();
+    Set<String> parameterNames = new HashSet<>();
+    for (DependencyRequest dependency : dependencies) {
+      FieldSpec field = dependencyFields.get(dependency.bindingKey());
+      ParameterSpec parameter =
+          ParameterSpec.builder(
+                  field.type,
+                  staticInjectMethodDependencyParameterName(parameterNames, dependency, field))
+              .build();
+      methodBuilder.addParameter(parameter);
+      providedParameters.add(
+          frameworkTypeUsageStatement(CodeBlocks.format("$N", parameter), dependency.kind()));
+    }
+    if (injectionElement.getKind().isField()) {
+      methodBuilder.addStatement(
+          "instance.$L = $L",
+          injectionElement.getSimpleName(),
+          getOnlyElement(providedParameters.build()));
+    } else {
+      methodBuilder.addStatement(
+          "instance.$L($L)",
+          injectionElement.getSimpleName(),
+          makeParametersCodeBlock(providedParameters.build()));
+    }
+    return methodBuilder.build();
+  }
+
+  /**
+   * Returns the static inject method parameter name for a dependency.
+   *
+   * @param parameterNames the parameter names used so far
+   * @param dependency the dependency
+   * @param field the field used to hold the framework type for the dependency
+   */
+  private String staticInjectMethodDependencyParameterName(
+      Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
+    StringBuilder parameterName =
+        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+    switch (dependency.kind()) {
+      case LAZY:
+      case INSTANCE:
+      case FUTURE:
+        String suffix = ((ParameterizedTypeName) field.type).rawType.simpleName();
+        if (parameterName.length() <= suffix.length()
+            || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
+          parameterName.append(suffix);
+        }
+        break;
+
+      default:
+        break;
+    }
+    int baseLength = parameterName.length();
+    for (int i = 2; !parameterNames.add(parameterName.toString()); i++) {
+      parameterName.replace(baseLength, parameterName.length(), String.valueOf(i));
+    }
+    return parameterName.toString();
+  }
+
+  private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
+      new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
+        @Override
+        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {
+          return visit(t.getComponentType(), p);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
+          return visibleToMembersInjector(p, t.asElement());
+        }
+      };
+
+  private static final class UniqueNames {
+    private final Set<String> uniqueNames = new HashSet<>();
+
+    String getUniqueName(String base) {
+      String name = base;
+      for (int differentiator = 2; !uniqueNames.add(name); differentiator++) {
+        name = base + differentiator;
       }
+      uniqueNames.add(name);
+      return name;
     }
-    return ImmutableSet.of(writer);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index dcabab52d..4b6f0c33c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -15,9 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index f5e33b59d..954b91eeb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,14 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
@@ -19,12 +39,15 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 @AutoValue
 abstract class ModuleDescriptor {
@@ -42,7 +65,12 @@
 
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
-  abstract ImmutableSet<? extends ContributionBinding> bindings();
+  abstract ImmutableSet<ContributionBinding> bindings();
+  
+  /**
+   * The multibinding declarations contained in this module.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
   enum DefaultCreationStrategy {
     PASSED,
@@ -51,22 +79,82 @@
 
   abstract DefaultCreationStrategy defaultCreationStrategy();
 
+  enum Kind {
+    MODULE(
+        Module.class, Provides.class, ImmutableSet.of(Module.class)),
+    PRODUCER_MODULE(
+        ProducerModule.class,
+        Produces.class,
+        ImmutableSet.of(Module.class, ProducerModule.class));
+
+    private final Class<? extends Annotation> moduleAnnotation;
+    private final Class<? extends Annotation> methodAnnotation;
+    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #moduleAnnotation() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
+    }
+
+    Kind(
+        Class<? extends Annotation> moduleAnnotation,
+        Class<? extends Annotation> methodAnnotation,
+        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
+      this.moduleAnnotation = moduleAnnotation;
+      this.methodAnnotation = methodAnnotation;
+      this.includesTypes = includesTypes;
+    }
+
+    Class<? extends Annotation> moduleAnnotation() {
+      return moduleAnnotation;
+    }
+
+    Class<? extends Annotation> methodAnnotation() {
+      return methodAnnotation;
+    }
+
+    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
+      return includesTypes;
+    }
+  }
+
   static final class Factory {
     private final Elements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
+    private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
-        ProductionBinding.Factory productionBindingFactory) {
+        ProductionBinding.Factory productionBindingFactory,
+        MultibindingDeclaration.Factory multibindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
+      this.multibindingDeclarationFactory = multibindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      AnnotationMirror moduleAnnotation = getModuleAnnotation(moduleElement).get();
+      Optional<AnnotationMirror> probableModuleAnnotation = getModuleAnnotation(moduleElement);
+      checkState(probableModuleAnnotation.isPresent(),
+          "%s did not have an AnnotationMirror for @Module",
+          moduleElement.getQualifiedName());
+      AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
@@ -79,6 +167,15 @@ ModuleDescriptor create(TypeElement moduleElement) {
               productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
         }
       }
+      
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
+        if (isAnnotationPresent(memberType, Multibindings.class)) {
+          multibindingDeclarations.addAll(
+              multibindingDeclarationFactory.forDeclaredInterface(memberType));
+        }
+      }
 
       DefaultCreationStrategy defaultCreationStrategy =
           (componentCanMakeNewInstances(moduleElement)
@@ -92,6 +189,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           ImmutableSet.copyOf(
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
+          multibindingDeclarations.build(),
           defaultCreationStrategy);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index f2116b110..9bb5fd1b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -50,6 +50,7 @@
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
@@ -61,126 +62,176 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
+ * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ModuleValidator implements Validator<TypeElement> {
+final class ModuleValidator {
   private final Types types;
   private final Elements elements;
-  private final Class<? extends Annotation> moduleClass;
-  private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
-      Types types,
-      Elements elements,
-      MethodSignatureFormatter methodSignatureFormatter,
-      Class<? extends Annotation> moduleClass,
-      Class<? extends Annotation> methodClass) {
+      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
-    this.moduleClass = moduleClass;
-    this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override
-  public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, methodClass)) {
+      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
-      
-    validateModuleVisibility(subject, builder);
-    validateMethodsWithSameName(builder, bindingMethodsByName);
+
+    validateModuleVisibility(subject, moduleKind, builder);
+    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
-      validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+      validateProvidesOverrides(
+          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
-    validateModifiers(subject, builder);    
-    validateReferencedModules(subject, builder);
-    
+    validateModifiers(subject, builder);
+    validateReferencedModules(subject, moduleKind, builder);
+
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
-  private void validateModifiers(TypeElement subject,
-      ValidationReport.Builder<TypeElement> builder) {    
+  private void validateModifiers(
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
-    // only modules without type parameters are referenced from @Component(modules={...}). 
+    // only modules without type parameters are referenced from @Component(modules={...}).
     if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
-      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
     }
   }
-  
-  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+
+  private void validateMethodsWithSameName(
+      ModuleDescriptor.Kind moduleKind,
+      ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
         bindingMethodsByName.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
-          builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+          builder.addError(
+              String.format(
+                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
               offendingMethod);
         }
       }
-    }    
+    }
   }
-  
-  private void validateReferencedModules(final TypeElement subject,
-      final ValidationReport.Builder<TypeElement> builder) {
+
+  private void validateReferencedModules(
+      TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
+      ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject,  builder, includedTypes);
+    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
+  }
+
+  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    return FluentIterable.from(validModuleKinds)
+        .transformAndConcat(
+            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
+              @Override
+              public Set<? extends Class<? extends Annotation>> apply(
+                  ModuleDescriptor.Kind moduleKind) {
+                return moduleKind.includesTypes();
+              }
+            })
+        .toSet();
   }
-  
+
   /**
    * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
    */
-  void validateReferencedModules(final TypeElement subject,
+  void validateReferencedModules(
+      final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes) {
+      ImmutableList<TypeMirror> includedTypes,
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
+        includedModuleClasses(validModuleKinds);
+
     for (TypeMirror includedType : includedTypes) {
-      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
+      includedType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
 
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          TypeElement element = MoreElements.asType(t.asElement()); 
-          if (!t.getTypeArguments().isEmpty()) {
-            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
-                element.getQualifiedName()), subject);
-          }
-          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
-            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
-                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
-          }
-          if (element.getModifiers().contains(ABSTRACT)) {
-            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
-                element.getQualifiedName()), subject);
-          }
-          return null;
-        }
-      }, null);
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              final TypeElement element = MoreElements.asType(t.asElement());
+              if (!t.getTypeArguments().isEmpty()) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
+                    subject);
+              }
+              boolean isIncludedModule =
+                  any(
+                      includedModuleClasses,
+                      new Predicate<Class<? extends Annotation>>() {
+                        @Override
+                        public boolean apply(Class<? extends Annotation> otherClass) {
+                          return MoreElements.isAnnotationPresent(element, otherClass);
+                        }
+                      });
+              if (!isIncludedModule) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_NOT_ANNOTATED,
+                        element.getQualifiedName(),
+                        (includedModuleClasses.size() > 1 ? "one of " : "")
+                            + Joiner.on(", ")
+                                .join(
+                                    FluentIterable.from(includedModuleClasses)
+                                        .transform(
+                                            new Function<Class<? extends Annotation>, String>() {
+                                              @Override
+                                              public String apply(
+                                                  Class<? extends Annotation> otherClass) {
+                                                return "@" + otherClass.getSimpleName();
+                                              }
+                                            }))),
+                    subject);
+              }
+              if (element.getModifiers().contains(ABSTRACT)) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, element.getQualifiedName()),
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
     }
   }
-  
-  private void validateProvidesOverrides(TypeElement subject,
+
+  private void validateProvidesOverrides(
+      TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
-      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
     // Consider the following hierarchy:
     // class Parent {
@@ -211,19 +262,25 @@ private void validateProvidesOverrides(TypeElement subject,
           if (!failedMethods.contains(providesMethod)
               && elements.overrides(providesMethod, superclassMethod, subject)) {
             failedMethods.add(providesMethod);
-            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+            builder.addError(
+                String.format(
+                    PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                    moduleKind.methodAnnotation().getSimpleName(),
+                    methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, methodClass)) {
+        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {
           for (ExecutableElement method : allMethodsByName.get(name)) {
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
               failedMethods.add(method);
-              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
-                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+              builder.addError(
+                  String.format(
+                      METHOD_OVERRIDES_PROVIDES_METHOD,
+                      moduleKind.methodAnnotation().getSimpleName(),
+                      methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
           }
@@ -233,13 +290,15 @@ private void validateProvidesOverrides(TypeElement subject,
     }
   }
 
-  private void validateModuleVisibility(final TypeElement moduleElement,
+  private void validateModuleVisibility(
+      final TypeElement moduleElement,
+      ModuleDescriptor.Kind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+      reportBuilder.addError("Modules cannot be private.", moduleElement);
     } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+      reportBuilder.addError("Modules cannot be enclosed in private types.", moduleElement);
     }
 
     switch (moduleElement.getNestingKind()) {
@@ -250,21 +309,27 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
-              getAnnotationMirror(moduleElement, moduleClass).get()))
-                  .transform(new Function<TypeMirror, Element>() {
-                    @Override public Element apply(TypeMirror input) {
-                      return types.asElement(input);
-                    }
-                  })
-                  .filter(new Predicate<Element>() {
-                    @Override public boolean apply(Element input) {
-                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                    }
-                  })
+          ImmutableSet<Element> nonPublicModules =
+              FluentIterable.from(
+                      getModuleIncludes(
+                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
+                  .transform(
+                      new Function<TypeMirror, Element>() {
+                        @Override
+                        public Element apply(TypeMirror input) {
+                          return types.asElement(input);
+                        }
+                      })
+                  .filter(
+                      new Predicate<Element>() {
+                        @Override
+                        public boolean apply(Element input) {
+                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                        }
+                      })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
-            reportBuilder.addItem(
+            reportBuilder.addError(
                 String.format(
                     "This module is public, but it includes non-public "
                         + "(or effectively non-public) modules. "
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
new file mode 100644
index 000000000..20b45fd53
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.producers.monitoring.internal.MonitorCache;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.PROVIDES_SET_VALUES;
+import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.FINAL;
+
+/** Generates a monitoring module for use with production components. */
+final class MonitoringModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
+
+  MonitoringModuleGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
+  }
+
+  @Override
+  ClassName nameGeneratedType(TypeElement componentElement) {
+    return SourceFiles.generatedMonitoringModuleName(componentElement);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
+    return Optional.of(componentElement);
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
+    return Optional.of(
+        classBuilder(generatedTypeName.simpleName())
+            .addAnnotation(Module.class)
+            .addModifiers(FINAL)
+
+            // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
+            .addMethod(
+                methodBuilder("defaultSetOfFactories")
+                    .returns(SET_OF_FACTORIES)
+                    .addModifiers(STATIC)
+                    .addAnnotation(PROVIDES_SET_VALUES)
+                    .addStatement("return $T.of()", ClassName.get(ImmutableSet.class))
+                    .build())
+
+            .addField(
+                FieldSpec.builder(MonitorCache.class, "monitorCache", PRIVATE, FINAL)
+                    .initializer("new $T()", MonitorCache.class)
+                    .build())
+
+            .addMethod(
+                methodBuilder("monitor")
+                    .returns(ProductionComponentMonitor.class)
+                    .addAnnotation(Provides.class)
+                    .addParameter(
+                        providerOf(ClassName.get(componentElement.asType())),
+                        "component")
+                    .addParameter(providerOf(SET_OF_FACTORIES), "factories")
+                    .addStatement("return monitorCache.monitor(component, factories)")
+                    .build()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
new file mode 100644
index 000000000..45e5e835c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * A processing step that is responsible for generating a special module for a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+final class MonitoringModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MonitoringModuleGenerator monitoringModuleGenerator;
+
+  MonitoringModuleProcessingStep(
+      Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {
+    this.messager = messager;
+    this.monitoringModuleGenerator = monitoringModuleGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.values()) {
+      try {
+        monitoringModuleGenerator.generate(MoreElements.asType(element));
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
new file mode 100644
index 000000000..e708e35e9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A declaration that a multibinding with a certain key is available to be injected in a component
+ * even if the component has no multibindings for that key. Identified by a map- or set-returning
+ * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
+ */
+@AutoValue
+abstract class MultibindingDeclaration
+    implements HasBindingType, HasKey, HasSourceElement, HasContributionType {
+
+  /**
+   * The method in a {@link Multibindings @Multibindings} interface that declares that this map or
+   * set is available to be injected.
+   */
+  @Override
+  public abstract SourceElement sourceElement();
+
+  /**
+   * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
+   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be
+   * {@code Set<T>}.
+   */
+  @Override
+  public abstract Key key();
+
+  /**
+   * {@link ContributionType#SET} if the declared type is a {@link Set}, or
+   * {@link ContributionType#MAP} if it is a {@link Map}.
+   */
+  @Override
+  public abstract ContributionType contributionType();
+
+  /**
+   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface
+   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
+   * {@link ProducerModule @ProducerModule}.
+   */
+  @Override
+  public abstract BindingType bindingType();
+
+  /**
+   * A factory for {@link MultibindingDeclaration}s.
+   */
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final TypeElement objectElement;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+    }
+
+    /**
+     * Creates multibinding declarations for each method in a
+     * {@link Multibindings @Multibindings}-annotated interface.
+     */
+    ImmutableSet<MultibindingDeclaration> forDeclaredInterface(TypeElement interfaceElement) {
+      checkArgument(interfaceElement.getKind().equals(INTERFACE));
+      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
+      BindingType bindingType = bindingType(interfaceElement);
+      DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
+
+      ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
+      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+        if (!method.getEnclosingElement().equals(objectElement)) {
+          ExecutableType methodType =
+              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
+          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));
+        }
+      }
+      return declarations.build();
+    }
+
+    private BindingType bindingType(TypeElement interfaceElement) {
+      if (isAnnotationPresent(interfaceElement.getEnclosingElement(), Module.class)) {
+        return BindingType.PROVISION;
+      } else if (isAnnotationPresent(
+          interfaceElement.getEnclosingElement(), ProducerModule.class)) {
+        return BindingType.PRODUCTION;
+      } else {
+        throw new IllegalArgumentException(
+            "Expected " + interfaceElement + " to be nested in a @Module or @ProducerModule");
+      }
+    }
+
+    private MultibindingDeclaration forDeclaredMethod(
+        BindingType bindingType,
+        ExecutableElement method,
+        ExecutableType methodType,
+        TypeElement interfaceElement) {
+      TypeMirror returnType = methodType.getReturnType();
+      checkArgument(
+          SetType.isSet(returnType) || MapType.isMap(returnType),
+          "%s must return a set or map",
+          method);
+      return new AutoValue_MultibindingDeclaration(
+          SourceElement.forElement(method, interfaceElement),
+          keyFactory.forMultibindingsMethod(bindingType, methodType, method),
+          contributionType(returnType),
+          bindingType);
+    }
+
+    private ContributionType contributionType(TypeMirror returnType) {
+      if (MapType.isMap(returnType)) {
+        return ContributionType.MAP;
+      } else if (SetType.isSet(returnType)) {
+        return ContributionType.SET;
+      } else {
+        throw new IllegalArgumentException("Must be Map or Set: " + returnType);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
new file mode 100644
index 000000000..db14a695b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Multibindings;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * Processes elements annotated with {@link Multibindings @Multibindings}.
+ */
+class MultibindingsProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MultibindingsValidator multibindingsValidator;
+
+  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {
+    this.messager = messager;
+    this.multibindingsValidator = multibindingsValidator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Multibindings.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.values())) {
+      multibindingsValidator.validate(element).printMessagesTo(messager);
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
new file mode 100644
index 000000000..d68e1dec3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Collection;
+import java.util.Map;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.TOO_MANY_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
+ * types.
+ */
+final class MultibindingsValidator {
+  private final Elements elements;
+  private final Key.Factory keyFactory;
+  private final KeyFormatter keyFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final TypeElement objectElement;
+
+  MultibindingsValidator(
+      Elements elements,
+      Key.Factory keyFactory,
+      KeyFormatter keyFormatter,
+      MethodSignatureFormatter methodSignatureFormatter) {
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.keyFormatter = keyFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+  }
+
+  /**
+   * Returns a report containing validation errors for a
+   * {@link Multibindings @Multibindings}-annotated type.
+   */
+  public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
+    ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
+    if (!multibindingsType.getKind().equals(INTERFACE)) {
+      validation.addError(MUST_BE_INTERFACE, multibindingsType);
+    }
+    if (!multibindingsType.getTypeParameters().isEmpty()) {
+      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);
+    }
+    Optional<BindingType> bindingType = bindingType(multibindingsType);
+    if (!bindingType.isPresent()) {
+      validation.addError(MUST_BE_IN_MODULE, multibindingsType);
+    }
+
+    ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
+        ImmutableListMultimap.builder();
+    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+      // Skip methods in Object.
+      if (method.getEnclosingElement().equals(objectElement)) {
+        continue;
+      }
+      if (!isPlainMap(method.getReturnType()) && !isPlainSet(method.getReturnType())) {
+        validation.addError(METHOD_MUST_RETURN_MAP_OR_SET, method);
+        continue;
+      }
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(method);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          validation.addError(TOO_MANY_QUALIFIERS, method, qualifier);
+        }
+        continue;
+      }
+      if (bindingType.isPresent()) {
+        methodsByKey.put(
+            keyFactory.forMultibindingsMethod(
+                bindingType.get(), asExecutable(method.asType()), method),
+            method);
+      }
+    }
+    for (Map.Entry<Key, Collection<ExecutableElement>> entry :
+        methodsByKey.build().asMap().entrySet()) {
+      Collection<ExecutableElement> methods = entry.getValue();
+      if (methods.size() > 1) {
+        Key key = entry.getKey();
+        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);
+      }
+    }
+    return validation.build();
+  }
+
+  private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableElement> methods) {
+    StringBuilder builder = new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));
+    builder.append(':');
+    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);
+    return builder.toString();
+  }
+
+  private Optional<BindingType> bindingType(TypeElement multibindingsType) {
+    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
+      return Optional.of(BindingType.PROVISION);
+    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
+      return Optional.of(BindingType.PRODUCTION);
+    } else {
+      return Optional.<BindingType>absent();
+    }
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !mapType.valuesAreTypeOf(Provider.class)
+        && !mapType.valuesAreTypeOf(Producer.class)
+        && !mapType.valuesAreTypeOf(Produced.class);
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !setType.elementsAreTypeOf(Provider.class)
+        && !setType.elementsAreTypeOf(Producer.class)
+        && !setType.elementsAreTypeOf(Produced.class);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
deleted file mode 100644
index bb9ba982c..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import javax.annotation.processing.Messager;
-
-/**
- * An interface for types that represent a compilation
- * {@linkplain javax.tools.Diagnostic.Kind#ERROR error} (though, not necessarily a
- * {@link Throwable}) that can be printed using a {@link Messager}.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-interface PrintableErrorMessage {
-  /**
-   * Prints the information represented by this object to the given {@link Messager} as an
-   * {@link javax.tools.Diagnostic.Kind#ERROR}.
-   */
-  void printMessageTo(Messager messager);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 10565a1b7..4741ef5b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -23,42 +22,46 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.AsyncFunction;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Provides.Type;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.producers.Produced;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
-import dagger.producers.internal.AbstractProducer;
-import dagger.producers.internal.Producers;
+import dagger.producers.Produces.Type;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executor;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
+import static com.squareup.javapoet.ClassName.OBJECT;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
+import static dagger.internal.codegen.TypeNames.listOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
+import static dagger.internal.codegen.TypeNames.EXECUTOR;
+import static dagger.internal.codegen.TypeNames.FUTURES;
+import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
+import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.VOID_CLASS;
+import static dagger.internal.codegen.TypeNames.producedOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -66,22 +69,19 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+
   private final DependencyRequestMapper dependencyRequestMapper;
 
-  ProducerFactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
-    super(filer);
+  ProducerFactoryGenerator(
+      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer, elements);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return factoryNameForProductionBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(ProductionBinding binding) {
-    return ImmutableSet.of(binding.bindingElement());
+    return javapoetGeneratedClassNameForBinding(binding);
   }
 
   @Override
@@ -90,194 +90,300 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeMirror keyType = binding.productionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
-    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
-    TypeName futureTypeName = ParameterizedTypeName.create(
-        ClassName.fromClass(ListenableFuture.class), providedTypeName);
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-
-    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
-    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-
-    factoryWriter.addField(binding.bindingTypeElement(), "module")
-        .addModifiers(PRIVATE, FINAL);
-    constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-    constructorWriter.body()
-        .addSnippet("assert module != null;")
-        .addSnippet("this.module = module;");
-
-    factoryWriter.addField(Executor.class, "executor")
-        .addModifiers(PRIVATE, FINAL);
-    constructorWriter.addParameter(Executor.class, "executor");
-    constructorWriter.body()
-        .addSnippet("assert executor != null;")
-        .addSnippet("this.executor = executor;");
-
-    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addModifiers(FINAL);
-    factoryWriter.setSuperclass(
-        ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
-
-    MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
-    getMethodWriter.annotate(Override.class);
-    getMethodWriter.addModifiers(PROTECTED);
-
-    final ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
+    TypeMirror keyType =
+        binding.productionType().equals(Type.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
+            : binding.key().type();
+    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName futureTypeName = listenableFutureOf(providedTypeName);
+
+    TypeSpec.Builder factoryBuilder =
+        classBuilder(generatedTypeName.simpleName())
+            .addModifiers(PUBLIC, FINAL)
+            .superclass(abstractProducerOf(providedTypeName));
+
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+
+    MethodSpec.Builder constructorBuilder =
+        constructorBuilder()
+            .addModifiers(PUBLIC)
+            .addStatement(
+                "super($L, $T.create($T.class))",
+                fields.get(binding.monitorRequest().get().bindingKey()).name(),
+                PRODUCER_TOKEN,
+                generatedTypeName);
+
+    if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, "module", moduleType);
+    }
+
+    addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
-          .addSnippet("assert %s != null;", field.name())
-          .addSnippet("this.%1$s = %1$s;", field.name());
+      TypeName fieldType = bindingField.javapoetFrameworkType();
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
 
-    boolean returnsFuture = binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION);
-    ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
-        .from(binding.dependencies())
-        .filter(new Predicate<DependencyRequest>() {
-          @Override public boolean apply(DependencyRequest dependency) {
-            return isAsyncDependency(dependency);
-          }
-        })
-        .toList();
+    boolean returnsFuture =
+        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
+    ImmutableList<DependencyRequest> asyncDependencies =
+        FluentIterable.from(binding.implicitDependencies())
+            .filter(
+                new Predicate<DependencyRequest>() {
+                  @Override
+                  public boolean apply(DependencyRequest dependency) {
+                    return isAsyncDependency(dependency);
+                  }
+                })
+            .toList();
+
+    MethodSpec.Builder computeMethodBuilder =
+        methodBuilder("compute")
+            .returns(futureTypeName)
+            .addAnnotation(Override.class)
+            .addModifiers(PROTECTED)
+            .addParameter(ProducerMonitor.class, "monitor", FINAL);
 
     for (DependencyRequest dependency : asyncDependencies) {
-      ParameterizedTypeName futureType = ParameterizedTypeName.create(
-          ClassName.fromClass(ListenableFuture.class),
-          asyncDependencyType(dependency));
-      String name = fields.get(dependency.bindingKey()).name();
-      Snippet futureAccess = Snippet.format("%s.get()", name);
-      getMethodWriter.body().addSnippet("%s %sFuture = %s;",
+      TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
+      CodeBlock futureAccess =
+          CodeBlocks.format("$L.get()", fields.get(dependency.bindingKey()).name());
+      computeMethodBuilder.addStatement(
+          "$T $L = $L",
           futureType,
-          name,
+          dependencyFutureName(dependency),
           dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-              ? Snippet.format("%s.createFutureProduced(%s)",
-                  ClassName.fromClass(Producers.class), futureAccess)
+              ? CodeBlocks.format("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
               : futureAccess);
     }
+    FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
+    CodeBlock transformCodeBlock =
+        CodeBlocks.format(
+            Joiner.on('\n')
+                .join(
+                    "new $1T<$2T, $3T>() {",
+                    "  $4L",
+                    "  @Override public $5T apply($2T $6L) $7L {",
+                    "    $8L",
+                    "  }",
+                    "}"),
+            ASYNC_FUNCTION,
+            futureTransform.applyArgType(),
+            providedTypeName,
+            futureTransform.hasUncheckedCast()
+                ? CodeBlocks.format("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
+                : "",
+            futureTypeName,
+            futureTransform.applyArgName(),
+            getThrowsClause(binding.thrownTypes()),
+            getInvocationCodeBlock(
+                !returnsFuture, binding, providedTypeName, futureTransform.parameterCodeBlocks()));
+    computeMethodBuilder.addStatement(
+        "return $T.transformAsync($L, $L, executor)",
+        FUTURES, futureTransform.futureCodeBlock(), transformCodeBlock);
 
-    if (asyncDependencies.isEmpty()) {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
-        parameterSnippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+    factoryBuilder.addMethod(constructorBuilder.build());
+    factoryBuilder.addMethod(computeMethodBuilder.build());
+
+    // TODO(gak): write a sensible toString
+    return Optional.of(factoryBuilder);
+  }
+
+  // TODO(ronshapiro): consolidate versions of these
+  private static void addFieldAndConstructorParameter(
+      TypeSpec.Builder typeBuilder,
+      MethodSpec.Builder constructorBuilder,
+      String variableName,
+      TypeName variableType) {
+    typeBuilder.addField(variableType, variableName, PRIVATE, FINAL);
+    constructorBuilder
+        .addParameter(variableType, variableName)
+        .addStatement("assert $L != null", variableName)
+        .addStatement("this.$1L = $1L", variableName);
+  }
+
+  /** Returns a name of the variable representing this dependency's future. */
+  private static String dependencyFutureName(DependencyRequest dependency) {
+    return dependency.requestElement().getSimpleName() + "Future";
+  }
+
+  /** Represents the transformation of an input future by a producer method. */
+  abstract static class FutureTransform {
+    protected final ImmutableMap<BindingKey, FrameworkField> fields;
+    protected final ProductionBinding binding;
+
+    FutureTransform(ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      this.fields = fields;
+      this.binding = binding;
+    }
+
+    /** The code block representing the future that should be transformed. */
+    abstract CodeBlock futureCodeBlock();
+
+    /** The type of the argument to the apply method. */
+    abstract TypeName applyArgType();
+
+    /** The name of the argument to the apply method */
+    abstract String applyArgName();
+
+    /** The code blocks to be passed to the produces method itself. */
+    abstract ImmutableList<CodeBlock> parameterCodeBlocks();
+
+    /** Whether the transform method has an unchecked cast. */
+    boolean hasUncheckedCast() {
+      return false;
+    }
+
+    static FutureTransform create(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      if (asyncDependencies.isEmpty()) {
+        return new NoArgFutureTransform(fields, binding);
+      } else if (asyncDependencies.size() == 1) {
+        return new SingleArgFutureTransform(
+            fields, binding, Iterables.getOnlyElement(asyncDependencies));
+      } else {
+        return new MultiArgFutureTransform(fields, binding, asyncDependencies);
       }
-      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
-      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-          parameterSnippets.build());
-      TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
-      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-      Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
-          "new %1$s<%2$s>() {",
-          "  @Override public %2$s call() %3$s{",
-          "    return %4$s;",
-          "  }",
-          "}"),
-          ClassName.fromClass(Callable.class),
-          callableReturnType,
-          throwsClause,
-          invocationSnippet);
-      getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
-          ParameterizedTypeName.create(
-              ClassName.fromClass(ListenableFuture.class),
-              callableReturnType),
-          ClassName.fromClass(Producers.class),
-          callableSnippet);
-      getMethodWriter.body().addSnippet("return %s;",
-          returnsFuture
-              ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
-              : "future");
-    } else {
-      final Snippet futureSnippet;
-      final Snippet transformSnippet;
-      if (asyncDependencies.size() == 1) {
-        DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
-        futureSnippet = Snippet.format("%s",
-            fields.get(asyncDependency.bindingKey()).name() + "Future");
-        String argName = asyncDependency.requestElement().getSimpleName().toString();
-        ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-        for (DependencyRequest dependency : binding.dependencies()) {
-          // We really want to compare instances here, because asyncDependency is an element in the
-          // set binding.dependencies().
-          if (dependency == asyncDependency) {
-            parameterSnippets.add(Snippet.format("%s", argName));
-          } else {
-            parameterSnippets.add(frameworkTypeUsageStatement(
-                Snippet.format(fields.get(dependency.bindingKey()).name()),
+    }
+  }
+
+  static final class NoArgFutureTransform extends FutureTransform {
+    NoArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      super(fields, binding);
+    }
+
+    @Override
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return VOID_CLASS;
+    }
+
+    @Override
+    String applyArgName() {
+      return "ignoredVoidArg";
+    }
+
+    @Override
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        parameterCodeBlocks.add(
+            frameworkTypeUsageStatement(
+                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
                 dependency.kind()));
-          }
+      }
+      return parameterCodeBlocks.build();
+    }
+  }
+
+  static final class SingleArgFutureTransform extends FutureTransform {
+    private final DependencyRequest asyncDependency;
+
+    SingleArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        DependencyRequest asyncDependency) {
+      super(fields, binding);
+      this.asyncDependency = asyncDependency;
+    }
+
+    @Override
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$L", dependencyFutureName(asyncDependency));
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return asyncDependencyType(asyncDependency);
+    }
+
+    @Override
+    String applyArgName() {
+      return asyncDependency.requestElement().getSimpleName().toString();
+    }
+
+    @Override
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        // We really want to compare instances here, because asyncDependency is an element in the
+        // set binding.dependencies().
+        if (dependency == asyncDependency) {
+          parameterCodeBlocks.add(CodeBlocks.format("$L", applyArgName()));
+        } else {
+          parameterCodeBlocks.add(
+              // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
+              frameworkTypeUsageStatement(
+                  CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                  dependency.kind()));
         }
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets.build());
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
-            "    return %7$s;",
-            "  }",
-            "}"),
-            ClassName.fromClass(AsyncFunction.class),
-            asyncDependencyType(asyncDependency),
-            providedTypeName,
-            futureTypeName,
-            argName,
-            throwsClause,
-            invocationSnippet);
-      } else {
-        futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
-            ClassName.fromClass(Futures.class),
-            ClassName.fromClass(Object.class),
-            Joiner.on(",").join(FluentIterable
-                .from(asyncDependencies)
-                .transform(new Function<DependencyRequest, String>() {
-                  @Override public String apply(DependencyRequest dependency) {
-                    return fields.get(dependency.bindingKey()).name() + "Future";
-                  }
-                })));
-        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets);
-        ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
-            ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @SuppressWarnings(\"unchecked\")  // safe by specification",
-            "  @Override public %4$s apply(%2$s args) %5$s{",
-            "    return %6$s;",
-            "  }",
-            "}"),
-            ClassName.fromClass(AsyncFunction.class),
-            listOfObject,
-            providedTypeName,
-            futureTypeName,
-            throwsClause,
-            invocationSnippet);
       }
-      getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
-          ClassName.fromClass(Futures.class),
-          "transform",
-          futureSnippet,
-          transformSnippet);
+      return parameterCodeBlocks.build();
     }
+  }
 
-    // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+  static final class MultiArgFutureTransform extends FutureTransform {
+    private final ImmutableList<DependencyRequest> asyncDependencies;
+
+    MultiArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      super(fields, binding);
+      this.asyncDependencies = asyncDependencies;
+    }
+
+    @Override
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format(
+          "$T.<$T>allAsList($L)",
+          FUTURES,
+          OBJECT,
+          makeParametersCodeBlock(
+              FluentIterable.from(asyncDependencies)
+                  .transform(
+                      new Function<DependencyRequest, CodeBlock>() {
+                        @Override
+                        public CodeBlock apply(DependencyRequest dependency) {
+                          return CodeBlocks.format("$L", dependencyFutureName(dependency));
+                        }
+                      })));
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return listOf(OBJECT);
+    }
+
+    @Override
+    String applyArgName() {
+      return "args";
+    }
+
+    @Override
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      return getParameterCodeBlocks(binding, fields, applyArgName());
+    }
+
+    @Override
+    boolean hasUncheckedCast() {
+      return true;
+    }
   }
 
-  private boolean isAsyncDependency(DependencyRequest dependency) {
+  private static boolean isAsyncDependency(DependencyRequest dependency) {
     switch (dependency.kind()) {
       case INSTANCE:
       case PRODUCED:
@@ -287,89 +393,114 @@ private boolean isAsyncDependency(DependencyRequest dependency) {
     }
   }
 
-  private TypeName asyncDependencyType(DependencyRequest dependency) {
-    TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
+  private static TypeName asyncDependencyType(DependencyRequest dependency) {
+    TypeName keyName = TypeName.get(dependency.key().type());
     switch (dependency.kind()) {
       case INSTANCE:
         return keyName;
       case PRODUCED:
-        return ParameterizedTypeName.create(ClassName.fromClass(Produced.class), keyName);
+        return producedOf(keyName);
       default:
         throw new AssertionError();
     }
   }
 
-  private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
+  private static ImmutableList<CodeBlock> getParameterCodeBlocks(
+      ProductionBinding binding,
       ImmutableMap<BindingKey, FrameworkField> fields,
       String listArgName) {
     int argIndex = 0;
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
-        snippets.add(Snippet.format(
-            "(%s) %s.get(%s)",
+        codeBlocks.add(CodeBlocks.format(
+            "($T) $L.get($L)",
             asyncDependencyType(dependency),
             listArgName,
             argIndex));
         argIndex++;
       } else {
-        snippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+        codeBlocks.add(frameworkTypeUsageStatement(
+            CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+            dependency.kind()));
       }
     }
-    return snippets.build();
+    return codeBlocks.build();
   }
 
   /**
-   * Creates a Snippet for the invocation of the producer method from the module.
+   * Creates a code block for the invocation of the producer method from the module, which should be
+   * used entirely within a method body.
    *
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
-   * @param binding The binding to generate the invocation snippet for.
-   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   * @param binding The binding to generate the invocation code block for.
+   * @param providedTypeName The type name that should be provided by this producer.
+   * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
-  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
-      ImmutableList<Snippet> parameterSnippets) {
-    Snippet moduleSnippet = Snippet.format("module.%s(%s)",
+  private CodeBlock getInvocationCodeBlock(
+      boolean wrapWithFuture,
+      ProductionBinding binding,
+      TypeName providedTypeName,
+      ImmutableList<CodeBlock> parameterCodeBlocks) {
+    CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
+        binding.bindingElement().getModifiers().contains(STATIC)
+            ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
+            : "module",
         binding.bindingElement().getSimpleName(),
-        makeParametersSnippet(parameterSnippets));
-    if (wrapWithFuture) {
-      moduleSnippet = Snippet.format("%s.immediateFuture(%s)",
-          ClassName.fromClass(Futures.class),
-          moduleSnippet);
-    }
+        makeParametersCodeBlock(parameterCodeBlocks));
+
+    // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
+    // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
+    // factories.
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
+
+    final CodeBlock valueCodeBlock;
     if (binding.productionType().equals(Produces.Type.SET)) {
-      if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
-        return Snippet.format("%s.createFutureSingletonSet(%s)",
-            ClassName.fromClass(Producers.class),
-            moduleSnippet);
+      if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
+        valueCodeBlock =
+            CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        return Snippet.format("%s.of(%s)",
-            ClassName.fromClass(ImmutableSet.class),
-            moduleSnippet);
+        valueCodeBlock =
+            CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
-      return moduleSnippet;
+      valueCodeBlock = moduleCodeBlock;
     }
+    CodeBlock returnCodeBlock =
+        wrapWithFuture
+            ? CodeBlocks.format(
+                "$T.<$T>immediateFuture($L)",
+                FUTURES,
+                providedTypeName,
+                valueCodeBlock)
+            : valueCodeBlock;
+    return CodeBlocks.format(
+        Joiner.on('\n')
+            .join(
+                "monitor.methodStarting();",
+                "try {",
+                "  return $L;",
+                "} finally {",
+                "  monitor.methodFinished();",
+                "}"),
+        returnCodeBlock);
   }
 
   /**
-   * Creates a Snippet for the throws clause.
+   * Creates a CodeBlock for the throws clause.
    *
    * @param thrownTypes the list of thrown types.
    */
-  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+  private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
-      return Snippet.format("");
+      return CodeBlocks.format("");
     }
-    return Snippet.format("throws %s ",
-        Snippet.makeParametersSnippet(FluentIterable
-            .from(thrownTypes)
-            .transform(new Function<TypeMirror, Snippet>() {
-              @Override public Snippet apply(TypeMirror thrownType) {
-                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
-              }
-            })
-            .toList()));
+    return CodeBlocks.format(
+        "throws $L",
+        CodeBlocks.join(
+            FluentIterable.from(thrownTypes)
+                .transform(CodeBlocks.TYPE_MIRROR_TO_CODE_BLOCK), ", "));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index a6e77a712..62079a625 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -47,6 +47,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -54,62 +55,74 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import javax.lang.model.util.Types;
+
 /**
- * A {@link Validator} for {@link Produces} methods.
+ * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
-// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
-final class ProducesMethodValidator implements Validator<ExecutableElement> {
+final class ProducesMethodValidator {
   private final Elements elements;
+  private final Types types;
 
-  ProducesMethodValidator(Elements elements) {
+  ProducesMethodValidator(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(producesMethodElement);
+        ValidationReport.about(producesMethodElement);
 
     Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
     checkArgument(producesAnnotation != null);
 
     Element enclosingElement = producesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          producesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), producesMethodElement);
     }
 
     if (!producesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
     }
 
     Set<Modifier> modifiers = producesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
 
     TypeMirror returnType = producesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          producesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
+    }
+
+    TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, exceptionType) && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(PRODUCES_METHOD_THROWS, producesMethodElement);
+        break;
+      }
     }
 
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
         && !getMapKeys(producesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
@@ -125,13 +138,13 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
             break;
         }
@@ -167,7 +180,7 @@ private void validateKeyType(ValidationReport.Builder<? extends Element> reportB
       TypeMirror type) {
     TypeKind kind = type.getKind();
     if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 
@@ -176,7 +189,7 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
     if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
       } else {
         validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
       }
@@ -188,17 +201,17 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
   private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     if (!type.getKind().equals(DECLARED)) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
       return;
     }
 
     // TODO(gak): should we allow "covariant return" for set values?
     DeclaredType declaredType = MoreTypes.asDeclared(type);
     if (!declaredType.asElement().equals(getSetElement())) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
     } else if (declaredType.getTypeArguments().isEmpty()) {
-      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-          reportBuilder.getSubject());
+      reportBuilder.addError(
+          formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), reportBuilder.getSubject());
     } else {
       validateSingleReturnType(reportBuilder,
           Iterables.getOnlyElement(declaredType.getTypeArguments()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 38d45e6a2..391d804e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -20,11 +20,12 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
+import dagger.Provides;
 import dagger.producers.Produces;
+import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -44,33 +45,31 @@
  */
 @AutoValue
 abstract class ProductionBinding extends ContributionBinding {
+
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return dependencies();
+  public BindingType bindingType() {
+    return BindingType.PRODUCTION;
   }
 
-  enum Kind {
-    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
-    IMMEDIATE,
-    /** Represents a binding configured by {@link Produces} that returns a future. */
-    FUTURE_PRODUCTION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PRODUCTION,
-    /**
-     * Represents a binding from a production method on a component dependency that returns a
-     * future. Methods that return immediate values are considered provision bindings.
-     */
-    COMPONENT_PRODUCTION,
+  @Override
+  Optional<ProductionBinding> unresolved() {
+    return Optional.absent();
+  }
+
+  @Override
+  Provides.Type provisionType() {
+    return Provides.Type.valueOf(productionType().name());
   }
 
-  /**
-   * The type of binding (whether the {@link Produces} method returns a future). For the particular
-   * type of production, use {@link #productionType}.
-   */
-  abstract Kind bindingKind();
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Similar optimizations to ContributionBinding.implicitDependencies().
+    if (!monitorRequest().isPresent()) {
+      return super.implicitDependencies();
+    } else {
+      return Sets.union(monitorRequest().asSet(), super.implicitDependencies());
+    }
+  }
 
   /** Returns provision type that was used to bind the key. */
   abstract Produces.Type productionType();
@@ -78,40 +77,16 @@
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
-  @Override
-  BindingType bindingType() {
-    switch (productionType()) {
-      case SET:
-      case SET_VALUES:
-        return BindingType.SET;
-      case MAP:
-        return BindingType.MAP;
-      case UNIQUE:
-        return BindingType.UNIQUE;
-      default:
-        throw new IllegalStateException("Unknown production type: " + productionType());
-    }
-  }
-
-  @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
-  }
-
-  @Override
-  Class<?> frameworkClass() {
-    return Producer.class;
-  }
+  /** If this production requires a monitor, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> monitorRequest();
 
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Types types,
-        Key.Factory keyFactory,
-        DependencyRequest.Factory
-        dependencyRequestFactory) {
+    Factory(
+        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
@@ -133,38 +108,44 @@ ProductionBinding forProducesMethod(
               declaredContainer,
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
+      DependencyRequest monitorRequest =
+          dependencyRequestFactory.forProductionComponentMonitorProvider();
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(producesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          producesMethod,
           dependencies,
           findBindingPackage(key),
-          false,
           ConfigurationAnnotations.getNullableType(producesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
-          ImmutableList.copyOf(producesMethod.getThrownTypes()));
+          ImmutableList.copyOf(producesMethod.getThrownTypes()),
+          Optional.of(monitorRequest));
     }
 
-    ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+    ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProducerKey =
+          keyFactory.implicitMapProducerKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProducerKey.isPresent(), "%s is not for a Map<K, V>", mapOfValueRequest);
+      DependencyRequest implicitMapOfProducerRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProducerKey.get());
       return new AutoValue_ProductionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
-          false,
+          SourceElement.forElement(implicitMapOfProducerRequest.requestElement()),
+          mapOfValueRequest.key(),
+          ImmutableSet.of(implicitMapOfProducerRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PRODUCTION,
-          Produces.Type.MAP,
-          ImmutableList.<TypeMirror>of());
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC_MAP,
+          Produces.Type.UNIQUE,
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent());
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -173,16 +154,16 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forProductionComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()));
+          ImmutableList.copyOf(componentMethod.getThrownTypes()),
+          Optional.<DependencyRequest>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
deleted file mode 100644
index e7e7e778a..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ProductionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Jesse Beder
- * @since 2.0
- */
-final class ProductionBindingFormatter extends Formatter<ProductionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-
-  ProductionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) {
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ProductionBinding binding) {
-    switch (binding.bindingKind()) {
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
deleted file mode 100644
index a424d12b4..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.producers.ProductionComponent;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
- * annotation as part of the {@link ComponentProcessor}.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
-  private final Messager messager;
-  private final ProductionComponentValidator componentValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
-
-  ProductionComponentProcessingStep(
-      Messager messager,
-      ProductionComponentValidator componentValidator,
-      BindingGraphValidator bindingGraphValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    super(
-        messager,
-        bindingGraphValidator,
-        bindingGraphFactory,
-        componentGenerator);
-    this.messager = messager;
-    this.componentValidator = componentValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
-  }
-
-  @Override
-  public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(ProductionComponent.class);
-  }
-
-  @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ComponentDescriptor> componentDescriptors = ImmutableSet.builder();
-    Set<Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ValidationReport<TypeElement> componentReport =
-          componentValidator.validate(componentTypeElement);
-      componentReport.printMessagesTo(messager);
-      if (componentReport.isClean()) {
-        componentDescriptors.add(
-            componentDescriptorFactory.forProductionComponent(componentTypeElement));
-      }
-    }
-    return componentDescriptors.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
deleted file mode 100644
index 6107280e4..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
-import dagger.Module;
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-
-/**
- * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentValidator implements Validator<TypeElement> {
-  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-
-    if (!subject.getKind().equals(INTERFACE)
-        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem("@ProductionComponent may only be applied to an interface or abstract class",
-          subject);
-    }
-
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, ProductionComponent.class).get();
-    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-
-    // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
-
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          checkState(t.getTypeArguments().isEmpty());
-          TypeElement moduleElement = MoreElements.asType(t.asElement());
-          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
-              && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
-            builder.addItem(moduleElement.getQualifiedName()
-                + " is listed as a module, but is not annotated with @Module or @ProducerModule",
-                subject);
-          }
-          return null;
-        }
-      }, null);
-    }
-
-    return builder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index af2e1f0d6..61420df59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -25,6 +25,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
@@ -44,71 +45,92 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import javax.lang.model.util.Types;
+
 /**
- * A {@link Validator} for {@link Provides} methods.
+ * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+final class ProvidesMethodValidator {
   private final Elements elements;
+  private final Types types;
 
-  ProvidesMethodValidator(Elements elements) {
+  ProvidesMethodValidator(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(providesMethodElement);
+        ValidationReport.about(providesMethodElement);
 
     Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
     checkArgument(providesAnnotation != null);
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          providesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), providesMethodElement);
     }
 
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), providesMethodElement);
     }
 
     Set<Modifier> modifiers = providesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), providesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
 
     TypeMirror returnType = providesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          providesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
+    }
+
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : providesMethodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(PROVIDES_METHOD_THROWS, providesMethodElement);
+        break;
+      }
+    }
+
+    for (VariableElement parameter : providesMethodElement.getParameters()) {
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
     }
 
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
     }
 
@@ -124,28 +146,28 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
             break;
         }
         break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
-          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
         } else {
           DeclaredType declaredReturnType = (DeclaredType) returnType;
           // TODO(gak): should we allow "covariant return" for set values?
           if (!declaredReturnType.asElement().equals(getSetElement())) {
-            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+            builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
           } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-                providesMethodElement);
+            builder.addError(
+                formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
           } else {
             validateKeyType(builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
@@ -165,7 +187,7 @@ static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement>
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        builder.addError(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
       }
     }
   }
@@ -181,8 +203,11 @@ private String formatModuleErrorMessage(String msg) {
   private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index aec51f038..7b2fb5d8e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,19 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
-import java.util.Set;
 import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -40,19 +35,15 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -63,99 +54,18 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!memberInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(memberInjectionRequest().asSet(), dependencies());
-    }
-  }
-
-  enum Kind {
-    /** Represents an {@link Inject} binding. */
-    INJECTION,
-    /** Represents a binding configured by {@link Provides}. */
-    PROVISION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PROVISON,
-    /** Represents the implicit binding to the component. */
-    COMPONENT,
-    /** Represents a binding from a provision method on a component dependency. */
-    COMPONENT_PROVISION,
-  }
-
-  /**
-   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
-   * use {@link #provisionType}.
-   */
-  abstract Kind bindingKind();
-
-  /** Returns provision type that was used to bind the key. */
-  abstract Provides.Type provisionType();
-
-  /** The scope in which the binding declares the {@link #key()}. */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
-  }
-
-  /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
-   */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
-
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> memberInjectionRequest();
 
   @Override
-  BindingType bindingType() {
-    switch (provisionType()) {
-      case SET:
-      case SET_VALUES:
-        return BindingType.SET;
-      case MAP:
-        return BindingType.MAP;
-      case UNIQUE:
-        return BindingType.UNIQUE;
-      default:
-        throw new IllegalStateException("Unknown provision type: " + provisionType());
-    }
+  public BindingType bindingType() {
+    return BindingType.PROVISION;
   }
 
   @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
-  }
+  abstract Optional<ProvisionBinding> unresolved();
 
   @Override
-  Class<?> frameworkClass() {
-    return Provider.class;
-  }
-
-  enum FactoryCreationStrategy {
-    ENUM_INSTANCE,
-    CLASS_CONSTRUCTOR,
-  }
-
-  FactoryCreationStrategy factoryCreationStrategy() {
-    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    if (bindingKind().equals(PROVISION)
-        && implicitDependencies().isEmpty()
-        && bindingElement().getModifiers().contains(STATIC)) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-  }
-
+  abstract Scope scope();
+  
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -170,13 +80,6 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    /** Returns an unresolved version of this binding. */
-    ProvisionBinding unresolve(ProvisionBinding binding) {
-      checkState(binding.hasNonDefaultTypeParameters());
-      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
-          Optional.<TypeMirror>absent());
-    }
-
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
      * will return a resolved binding, with the key & type resolved to the given type (using
@@ -211,24 +114,24 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<AnnotationMirror> scope =
-          getScopeAnnotation(constructorElement.getEnclosingElement());
+      Scope scope = Scope.scopeOf(constructorElement.getEnclosingElement());
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(constructorElement),
           key,
-          constructorElement,
           dependencies,
           findBindingPackage(key),
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
+          membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          membersInjectionRequest);
+          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
+              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
+              : Optional.<ProvisionBinding>absent(),
+          scope);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -264,74 +167,94 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
               declaredContainer,
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
+      Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(providesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          providesMethod,
           dependencies,
           findBindingPackage(key),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<ProvisionBinding>absent(),
+          scope);
     }
-
-    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
+    
+    ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProviderKey =
+          keyFactory.implicitMapProviderKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProviderKey.isPresent(),
+          "%s is not a request for Map<K, V>",
+          mapOfValueRequest);
+      DependencyRequest implicitMapOfProviderRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProviderKey.get());
       return new AutoValue_ProvisionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
-          false /* no non-default parameter types */,
+          SourceElement.forElement(implicitMapOfProviderRequest.requestElement()),
+          mapOfValueRequest.key(),
+          ImmutableSet.of(implicitMapOfProviderRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PROVISON,
-          Provides.Type.MAP,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC_MAP,
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentDefinitionType),
           keyFactory.forComponent(componentDefinitionType.asType()),
-          componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Optional.<DependencyRequest>absent());
+          Optional.<ProvisionBinding>absent(),
+          Scope.unscoped());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
+      Scope scope = Scope.scopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
-          false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<ProvisionBinding>absent(),
+          scope);
+    }
+
+    ProvisionBinding forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+      DeclaredType declaredContainer = asDeclared(contributedBy.asType());
+      return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
+          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.SUBCOMPONENT_BUILDER,
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          Scope.unscoped());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
deleted file mode 100644
index 92d031042..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Christian Gruber
- * @since 2.0
- */
-final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  
-  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ProvisionBinding binding) {
-    switch (binding.bindingKind()) {
-      case PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index e44ba4ca7..62b102245 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -16,10 +16,26 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimap;
+import dagger.MembersInjector;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.concat;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -27,47 +43,294 @@
  * @author Gregory Kick
  */
 @AutoValue
-abstract class ResolvedBindings {
+abstract class ResolvedBindings implements HasBindingType, HasContributionType, HasKey {
+  /**
+   * The binding key for which the {@link #bindings()} have been resolved.
+   */
   abstract BindingKey bindingKey();
-  abstract ImmutableSet<? extends Binding> ownedBindings();
-  abstract ImmutableSet<? extends Binding> bindings();
 
-  static ResolvedBindings create(
+  /**
+   * The component in which the bindings in {@link #ownedBindings()},
+   * {@link #ownedContributionBindings()}, and {@link #ownedMembersInjectionBinding()} were
+   * resolved.
+   */
+  abstract ComponentDescriptor owningComponent();
+
+  /**
+   * The contribution bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
+
+  /**
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   */
+  abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
+
+  @Override
+  public Key key() {
+    return bindingKey().key();
+  }
+  
+  /**
+   * The multibinding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
+  
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
+   */
+  boolean isEmpty() {
+    return bindings().isEmpty() && multibindingDeclarations().isEmpty();
+  }
+
+  /**
+   * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
+   */
+  ImmutableSet<? extends Binding> ownedBindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return ownedContributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * All contribution bindings, regardless of owning component. Empty if this is a members-injection
+   * binding.
+   */
+  ImmutableSet<ContributionBinding> contributionBindings() {
+    return ImmutableSet.copyOf(allContributionBindings().values());
+  }
+
+  /**
+   * The contribution bindings that were resolved in {@link #owningComponent()}. Empty if this is a
+   * members-injection binding.
+   */
+  ImmutableSet<ContributionBinding> ownedContributionBindings() {
+    return allContributionBindings().get(owningComponent());
+  }
+
+  /**
+   * The members-injection binding, regardless of owning component. Empty if these are contribution
+   * bindings.
+   */
+  Optional<MembersInjectionBinding> membersInjectionBinding() {
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        FluentIterable.from(allMembersInjectionBindings().values()).toSet();
+    return membersInjectionBindings.isEmpty()
+        ? Optional.<MembersInjectionBinding>absent()
+        : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
+  }
+
+  /**
+   * The members-injection binding that was resolved in {@link #owningComponent()}. Empty if these
+   * are contribution bindings.
+   */
+  Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
+    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
+  }
+
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
-      Set<? extends Binding> ownedBindings,
-      Set<? extends Binding> inheritedBindings) {
-    ImmutableSet<Binding> immutableOwnedBindings = ImmutableSet.copyOf(ownedBindings);
+      ComponentDescriptor owningComponent,
+      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
+      Iterable<MultibindingDeclaration> multibindings) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
-        immutableOwnedBindings,
-        ImmutableSet.<Binding>builder()
-        .addAll(inheritedBindings)
-        .addAll(immutableOwnedBindings)
-        .build());
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.copyOf(multibindings));
   }
 
-  static ResolvedBindings create(
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
-      Binding... ownedBindings) {
-    ImmutableSet<Binding> bindings = ImmutableSet.copyOf(ownedBindings);
-    return new AutoValue_ResolvedBindings(bindingKey, bindings, bindings);
+      ComponentDescriptor owningComponent,
+      ContributionBinding... ownedContributionBindings) {
+    return forContributionBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
+            .putAll(owningComponent, ownedContributionBindings)
+            .build(),
+        ImmutableSet.<MultibindingDeclaration>of());
+  }
+
+  /**
+   * Creates a {@link ResolvedBindings} for members injection bindings.
+   */
+  static ResolvedBindings forMembersInjectionBinding(
+      BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
+      MembersInjectionBinding ownedMembersInjectionBinding) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
+        ImmutableSet.<MultibindingDeclaration>of());
+  }
+
+  /**
+   * Creates a {@link ResolvedBindings} appropriate for when there are no bindings for the key.
+   */
+  static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor owningComponent) {
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.<MultibindingDeclaration>of());
+  }
+
+  /**
+   * Returns a {@code ResolvedBindings} with the same {@link #bindingKey()} and {@link #bindings()}
+   * as this one, but no {@link #ownedBindings()}.
+   */
+  ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
+    return new AutoValue_ResolvedBindings(
+        bindingKey(),
+        owningComponent,
+        allContributionBindings(),
+        allMembersInjectionBindings(),
+        multibindingDeclarations());
+  }
+
+  /**
+   * {@code true} if this is a multibindings contribution.
+   */
+  boolean isMultibindings() {
+    return !(contributionBindings().isEmpty() && multibindingDeclarations().isEmpty())
+        && contributionType().isMultibinding();
+  }
+
+  /**
+   * {@code true} if this is a unique contribution binding.
+   */
+  boolean isUniqueContribution() {
+    return !contributionBindings().isEmpty() && !contributionType().isMultibinding();
+  }
+
+  /**
+   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
+   *
+   * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
+   */
+  @Override
+  public BindingType bindingType() {
+    checkState(!isEmpty(), "empty bindings for %s", bindingKey());
+    ImmutableSet<BindingType> bindingTypes =
+        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
+            .transform(BindingType.BINDING_TYPE)
+            .toSet();
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+    return getOnlyElement(bindingTypes);
+  }
+
+  /**
+   * The contribution type for these bindings.
+   *
+   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
+   */
+  @Override
+  public ContributionType contributionType() {
+    ImmutableSet<ContributionType> types = contributionTypes();
+    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
+    checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
+    return getOnlyElement(types);
+  }
+
+  /**
+   * The contribution types represented by {@link #contributionBindings()} and
+   * {@link #multibindingDeclarations()}.
+   */
+  ImmutableSet<ContributionType> contributionTypes() {
+    return bindingsAndDeclarationsByContributionType().keySet();
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
+  /**
+   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
+   * {@link ContributionType}.
+   */
+  ImmutableListMultimap<ContributionType, HasSourceElement>
+      bindingsAndDeclarationsByContributionType() {
+    return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+        .putAll(indexByContributionType(contributionBindings()))
+        .putAll(indexByContributionType(multibindingDeclarations()))
+        .build();
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> contributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) bindings();
+  /**
+   * The name of the package in which these bindings must be managed, for
+   * example if a binding references non-public types.
+   * 
+   * @throws IllegalArgumentException if the bindings must be managed in more than one package
+   */
+  Optional<String> bindingPackage() {
+    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+    for (Binding binding : bindings()) {
+      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+    }
+    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+    switch (bindingPackages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(bindingPackages.iterator().next());
+      default:
+        throw new IllegalArgumentException();
+    }
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+  /**
+   * The framework class associated with these bindings.
+   */
+  Class<?> frameworkClass() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return Iterables.any(contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))
+            ? BindingType.PRODUCTION.frameworkClass()
+            : BindingType.PROVISION.frameworkClass();
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
new file mode 100644
index 000000000..bcb009d1e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.base.Preconditions;
+import javax.annotation.Nullable;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+
+/**
+ * A representation of the scope (or lack of it) associated with a component, providing method
+ * or injection location.
+ */
+final class Scope {
+
+  /**
+   * An internal representation for an unscoped binding.
+   */
+  private static final Scope UNSCOPED = new Scope();
+
+  /**
+   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   */
+  @Nullable
+  private final AnnotationMirror annotationMirror;
+
+  private Scope(@Nullable AnnotationMirror annotationMirror) {
+    this.annotationMirror = annotationMirror;
+  }
+
+  private Scope() {
+    this(null);
+  }
+
+  /**
+   * Returns representation for an unscoped binding.
+   */
+  static Scope unscoped() {
+    return UNSCOPED;
+  }
+
+  /**
+   * If the source code element has an associated scoped annotation then returns a representation
+   * of that scope, otherwise returns a representation for an unscoped binding.
+   */
+  static Scope scopeOf(Element element) {
+    Optional<AnnotationMirror> scopeAnnotation = getScopeAnnotation(element);
+    return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
+  }
+
+  /**
+   * Returns true if the scope is present, i.e. it's not unscoped binding.
+   */
+  public boolean isPresent() {
+    return annotationMirror != null;
+  }
+
+  /**
+   * Returns true if the scope represents the {@link Singleton @Singleton} annotation.
+   */
+  public boolean isSingleton() {
+    return annotationMirror != null
+        && isTypeOf(Singleton.class, annotationMirror.getAnnotationType());
+  }
+
+  /**
+   * Returns the readable source representation (name with @ prefix) of the annotation type.
+   *
+   * <p>It's readable source because it has had common package prefixes removed, e.g.
+   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getReadableSource() {
+    return stripCommonTypePrefixes("@" + getQualifiedName());
+  }
+
+  /**
+   * Returns the fully qualified name of the annotation type.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getQualifiedName() {
+    Preconditions.checkState(annotationMirror != null,
+        "Cannot create a stripped source representation of no annotation");
+    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
+    return typeElement.getQualifiedName().toString();
+  }
+
+  /**
+   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
+   * {@link AnnotationMirrors#equivalence()}.
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    } else if (obj instanceof Scope) {
+      Scope that = (Scope) obj;
+      return AnnotationMirrors.equivalence()
+        .equivalent(this.annotationMirror, that.annotationMirror);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return AnnotationMirrors.equivalence().hash(annotationMirror);
+  }
+
+  /**
+   * Returns a debug representation of the scope.
+   */
+  @Override
+  public String toString() {
+    return annotationMirror == null ? "UNSCOPED" : annotationMirror.toString();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
new file mode 100644
index 000000000..23e95c7f7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Set;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Set} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class SetType {
+  /**
+   * The set type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredSetType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredSetType();
+  
+  /**
+   * The set type itself.
+   */
+  DeclaredType declaredSetType() {
+    return wrappedDeclaredSetType().get();
+  }
+
+  /**
+   * {@code true} if the set type is the raw {@link Set} type.
+   */
+  boolean isRawType() {
+    return declaredSetType().getTypeArguments().isEmpty();
+  }
+
+  /**
+   * The element type.
+   */
+  TypeMirror elementType() {
+    return declaredSetType().getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@link #elementType()} is a {@code clazz}.
+   */
+  boolean elementsAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(elementType()) && MoreTypes.isTypeOf(clazz, elementType());
+  }
+
+  /**
+   * {@code T} if {@link #elementType()} is a {@code WrappingClass<T>}.
+   *
+   * @throws IllegalStateException if {@link #elementType()} is not a {@code WrappingClass<T>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedElementType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(elementsAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Set} type.
+   */
+  static boolean isSet(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
+  }
+
+  /**
+   * Returns a {@link SetType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Set} type
+   */
+  static SetType from(TypeMirror type) {
+    checkArgument(isSet(type), "%s must be a Set", type);
+    return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
new file mode 100644
index 000000000..29949629b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+/**
+ * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
+ */
+@AutoValue
+abstract class SourceElement {
+
+  /** An object that has a {@link SourceElement}. */
+  interface HasSourceElement {
+    /** The source element associated with this object. */
+    SourceElement sourceElement();
+  }
+
+  /** The {@link Element} instance.. */
+  abstract Element element();
+
+  /**
+   * The concrete class that contributed the {@link #element()}, if different from
+   * {@link #enclosingTypeElement()}.
+   */
+  abstract Optional<TypeElement> contributedBy();
+
+  /** The type enclosing the {@link #element()}. */
+  TypeElement enclosingTypeElement() {
+    return BINDING_TYPE_ELEMENT.visit(element());
+  }
+
+  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
+  static SourceElement forElement(Element element) {
+    return new AutoValue_SourceElement(element, Optional.<TypeElement>absent());
+  }
+
+  static SourceElement forElement(Element element, TypeElement contributedBy) {
+    return new AutoValue_SourceElement(element, Optional.of(contributedBy));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 6ea9729d1..05c4f3a6d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -35,7 +35,8 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
+final class SourceFileGenerationException extends Exception {
+  // TODO(ronshapiro): remove these unused values
   private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
@@ -55,6 +56,15 @@
     this(generatedClassNames, cause, Optional.of(associatedElement));
   }
 
+  SourceFileGenerationException(
+      Optional<com.squareup.javapoet.ClassName> generatedClassName,
+      Throwable cause,
+      Optional<? extends Element> associatedElement) {
+    super(createMessage(generatedClassName, cause.getMessage()), cause);
+    this.generatedClassNames = ImmutableSet.of();
+    this.associatedElement = checkNotNull(associatedElement);
+  }
+
   public ImmutableSet<ClassName> generatedClassNames() {
     return generatedClassNames;
   }
@@ -71,8 +81,16 @@ private static String createMessage(Iterable<ClassName> generatedClassNames, Str
         message);
   }
 
-  @Override
-  public void printMessageTo(Messager messager) {
+  private static String createMessage(
+      Optional<com.squareup.javapoet.ClassName> generatedClassName, String message) {
+    return String.format("Could not generate %s: %s.",
+        generatedClassName.isPresent()
+            ? generatedClassName.get()
+            : "unknown file",
+        message);
+  }
+
+  void printMessageTo(Messager messager) {
     if (associatedElement.isPresent()) {
       messager.printMessage(ERROR, getMessage(), associatedElement.get());
     } else {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 13430c670..ddb889f34 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -15,85 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.TypeWriter;
-import java.io.IOException;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
+ * A template for types that generate source files from an annotation processor.
  *
  * @param <T> The input type from which source is to be generated.
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class SourceFileGenerator<T> {
-  private final Filer filer;
-
-  SourceFileGenerator(Filer filer) {
-    this.filer = checkNotNull(filer);
-  }
-
-  final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
-    try {
-      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
-      for (JavaWriter javaWriter : writers) {
-        try {
-          javaWriter.file(filer, originatingElements);
-        } catch (IOException e) {
-          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
-              e, getElementForErrorReporting(input));
-        }
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
-          getElementForErrorReporting(input));
-    }
-  }
-
-  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
-    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
-      @Override public ClassName apply(TypeWriter input) {
-        return input.name();
-      }
-    });
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Implementations should return {@link Element} instances from which the source is to be
-   * generated.
-   */
-  abstract Iterable<? extends Element> getOriginatingElements(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   */
-  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
+interface SourceFileGenerator<T> {
+  /** Generates a source file to be compiled for {@code T}. */
+  void generate(T input) throws SourceFileGenerationException;
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 57c815b23..f7b2f8ee9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,6 +14,11 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Splitter;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -21,25 +26,31 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
 
 /**
  * Utilities for generating files.
@@ -48,6 +59,9 @@
  * @since 2.0
  */
 class SourceFiles {
+
+  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('$');
+
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
@@ -67,71 +81,77 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   };
 
   /**
-   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
-   * to requests.  This is used when generating component's initialize()
-   * methods (and in members injectors) in order to instantiate dependent
-   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
-   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
-   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
-   * if it was referenced as {@code Foo<A>}, we need to make sure we still
-   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
-   * we would have passed a single {@code aProvider}.
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   *
+   * <p>Consider a generic type {@code Foo<T>} with a constructor {@code Foo(T t, T t1, A a, A a1)}.
+   * Its factory's {@code create} method should take only two parameters:
+   * {@code create(Provider<T> tProvider, Provider<A> aProvider)}. However, if the component
+   * initializes a factory for {@code Foo<A>}, it really has only one dependency:
+   * both arguments should be the same {@code Provider<A>}. In order to get the right number of
+   * arguments, we have to index resolved binding's dependencies by their keys in the unresolved
+   * version of the binding.
    */
-  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
-  // binding keys and framework classes that it needs.
+  // TODO(dpb): Move this to DependencyRequest.
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Types types, Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      BindingKey resolved = dependency.bindingKey();
-      // To get the proper unresolved type, we have to extract the proper type from the
-      // request type again (because we're looking at the actual element's type).
-      TypeMirror unresolvedType =
-          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
-      BindingKey unresolved =
-          BindingKey.create(resolved.kind(), resolved.key().withType(types, unresolvedType));
-      dependenciesByKeyBuilder.put(unresolved, dependency);
+      Binding binding) {
+    // If the binding is already fully resolved, just index the dependencies by binding key.
+    if (!binding.unresolved().isPresent()) {
+      return indexDependenciesByKey(binding, Functions.<DependencyRequest>identity());
     }
-    return dependenciesByKeyBuilder.build();
+    
+    // Index the unresolved dependencies, replacing each one with its resolved version by looking it
+    // up by request element.
+    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
+        Maps.uniqueIndex(
+            binding.implicitDependencies(),
+            new Function<DependencyRequest, Element>() {
+              @Override
+              public Element apply(DependencyRequest dependencyRequest) {
+                return dependencyRequest.requestElement();
+              }
+            });
+    return indexDependenciesByKey(
+        binding.unresolved().get(),
+        new Function<DependencyRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
+            return resolvedDependencies.get(unresolvedRequest.requestElement());
+          }
+        });
   }
 
   /**
-   * Allows dependency requests to be grouped by the key they're requesting.
-   * This is used by factory generation in order to minimize the number of parameters
-   * required in the case where a given key is requested more than once.  This expects
-   * unresolved dependency requests, otherwise we may generate factories based on
-   * a particular usage of a class as opposed to the generic types of the class.
+   * Groups a binding's dependency requests by their binding key.
+   *
+   * @param transformer applied to each dependency before inserting into the multimap
    */
-  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
-      Iterable<? extends DependencyRequest> dependencies) {
+  private static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
+      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), dependency);
+        ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : binding.implicitDependencies()) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
     }
-    return dependenciesByKeyBuilder.build();
+    return dependenciesByKeyBuilder.orderValuesBy(DEPENDENCY_ORDERING).build();
   }
 
   /**
-   * This method generates names and keys for the framework classes necessary for all of the
-   * bindings. It is responsible for the following:
+   * Generates names and keys for the factory class fields needed to hold the framework classes for
+   * all of the dependencies of {@code binding}. It is responsible for choosing a name that
+   *
    * <ul>
-   * <li>Choosing a name that associates the binding with all of the dependency requests for this
-   * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
-   * <li>Ensuring that no two bindings end up with the same name.
+   * <li>represents all of the dependency requests for this key
+   * <li>is <i>probably</i> associated with the type being bound
+   * <li>is unique within the class
    * </ul>
    *
-   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
+   * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
-      DependencyRequestMapper dependencyRequestMapper,
-      Iterable<? extends DependencyRequest> dependencies) {
+      DependencyRequestMapper dependencyRequestMapper, Binding binding) {
     ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByKey(dependencies);
+        indexDependenciesByUnresolvedKey(binding);
     Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
@@ -144,12 +164,13 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
           FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
-
+    
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(bindingKey,
-            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
+        bindingFields.put(
+            bindingKey,
+            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey.key(), name));
       } else {
         // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
@@ -160,8 +181,10 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           compositeNameBuilder.append("And").append(
               CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(
-            frameworkClass, bindingKey, compositeNameBuilder.toString()));
+        bindingFields.put(
+            bindingKey,
+            FrameworkField.createWithTypeFromKey(
+                frameworkClass, bindingKey.key(), compositeNameBuilder.toString()));
       }
     }
     return bindingFields.build();
@@ -185,110 +208,228 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
     }
   }
 
-  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case INJECTION:
-      case PROVISION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
-      case SYNTHETIC_PROVISON:
-        throw new IllegalArgumentException();
+  static CodeBlock frameworkTypeUsageStatement(
+      CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
+    switch (dependencyKind) {
+      case LAZY:
+        return CodeBlocks.format(
+            "$T.create($L)", DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
+      case INSTANCE:
+      case FUTURE:
+        return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
+      case PROVIDER:
+      case PRODUCER:
+      case MEMBERS_INJECTOR:
+        return CodeBlocks.format("$L", frameworkTypeMemberSelect);
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   * Returns the generated factory or members injector name for a binding.
    */
-  static TypeName parameterizedFactoryNameForProvisionBinding(
-      ProvisionBinding binding) {
-    ClassName factoryName = factoryNameForProvisionBinding(binding);
-    List<TypeName> parameters = ImmutableList.of();
-    if (binding.bindingType().equals(BindingType.UNIQUE)) {
-      switch(binding.bindingKind()) {
-        case INJECTION:
-          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-          // If the binding is parameterized, parameterize the factory.
-          if (bindingName instanceof ParameterizedTypeName) {
-            parameters = ((ParameterizedTypeName) bindingName).parameters();
-          }
-          break;
-        case PROVISION:
-          // For provision bindings, we parameterize creation on the types of
-          // the module, not the types of the binding.
-          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
-            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
-                binding.bindingTypeElement().asType())).parameters();
-          }
-          break;
-        default: // fall through.
-      }
-    }
-    return parameters.isEmpty() ? factoryName
-        : ParameterizedTypeName.create(factoryName, parameters);
-  }
+  static ClassName generatedClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(!contribution.isSyntheticBinding());
+        ClassName enclosingClassName = ClassName.fromTypeElement(contribution.bindingTypeElement());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            return enclosingClassName
+                .topLevelClassName()
+                .peerNamed(
+                    enclosingClassName.classFileName()
+                        + "_"
+                        + factoryPrefix(contribution)
+                        + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return membersInjectorNameForType(binding.bindingTypeElement());
 
-  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
+   * Returns the generated factory or members injector name parameterized with the proper type
+   * parameters if necessary.
    */
-  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
-      MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
-    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-    // If the binding is parameterized, parameterize the MembersInjector.
-    if (bindingName instanceof ParameterizedTypeName) {
-      return ParameterizedTypeName.create(factoryName,
-          ((ParameterizedTypeName) bindingName).parameters());
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
+    return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
+  }
+
+  /**
+   * Returns the generated factory or members injector name for a binding.
+   */
+  static com.squareup.javapoet.ClassName javapoetGeneratedClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(!contribution.isSyntheticBinding());
+        com.squareup.javapoet.ClassName enclosingClassName =
+            com.squareup.javapoet.ClassName.get(contribution.bindingTypeElement());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            return enclosingClassName
+                .topLevelClassName()
+                .peerClass(
+                    classFileName(enclosingClassName)
+                        + "_"
+                        + factoryPrefix(contribution)
+                        + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return javapoetMembersInjectorNameForType(binding.bindingTypeElement());
+
+      default:
+        throw new AssertionError();
     }
-    return factoryName;
   }
 
-  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
-    return injectedClassName.topLevelClassName().peerNamed(
-        injectedClassName.classFileName() + "_MembersInjector");
+  static com.squareup.javapoet.TypeName javapoetParameterizedGeneratedTypeNameForBinding(
+      Binding binding) {
+    com.squareup.javapoet.ClassName className = javapoetGeneratedClassNameForBinding(binding);
+    ImmutableList<com.squareup.javapoet.TypeName> typeParameters =
+        javapoetBindingTypeParameters(binding);
+    if (typeParameters.isEmpty()) {
+      return className;
+    } else {
+      return com.squareup.javapoet.ParameterizedTypeName.get(
+          className,
+          FluentIterable.from(typeParameters).toArray(com.squareup.javapoet.TypeName.class));
+    }
   }
 
-  private static String factoryPrefix(ProvisionBinding binding) {
-    switch (binding.bindingKind()) {
-      case INJECTION:
-        return "";
+  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
+      throws AssertionError {
+    switch (binding.bindingType()) {
       case PROVISION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      case PRODUCTION:
+        ContributionBinding contributionBinding = (ContributionBinding) binding;
+        switch (contributionBinding.bindingKind()) {
+          case INJECTION:
+            return Optional.of(contributionBinding.key().type());
+
+          case PROVISION:
+            // For provision bindings, we parameterize creation on the types of
+            // the module, not the types of the binding.
+            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+            return Optional.of(contributionBinding.bindingTypeElement().asType());
+
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            // TODO(beder): Can these be treated just like PROVISION?
+            throw new UnsupportedOperationException();
+            
+          default:
+            return Optional.absent();
+        }
+
+      case MEMBERS_INJECTION:
+        return Optional.of(binding.key().type());
+
       default:
-        throw new IllegalArgumentException();
+        throw new AssertionError();
+    }
+  }
+
+  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding) {
+    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
+    if (!typeMirror.isPresent()) {
+      return ImmutableList.of();
+    }
+    TypeName bindingTypeName = dagger.internal.codegen.writer.TypeNames.forTypeMirror(typeMirror.get());
+    return bindingTypeName instanceof ParameterizedTypeName
+        ? ((ParameterizedTypeName) bindingTypeName).parameters()
+        : ImmutableList.<TypeName>of();
+  }
+
+  static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
+      Binding binding) {
+    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
+    if (!typeMirror.isPresent()) {
+      return ImmutableList.of();
     }
+    com.squareup.javapoet.TypeName bindingTypeName =
+        com.squareup.javapoet.TypeName.get(typeMirror.get());
+    return bindingTypeName instanceof com.squareup.javapoet.ParameterizedTypeName
+        ? ImmutableList.copyOf(
+            ((com.squareup.javapoet.ParameterizedTypeName) bindingTypeName).typeArguments)
+        : ImmutableList.<com.squareup.javapoet.TypeName>of();
+  }
+  
+  static ClassName membersInjectorNameForType(TypeElement typeElement) {
+    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
+    return injectedClassName
+        .topLevelClassName()
+        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
+  }
+
+  static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
+      TypeElement typeElement) {
+    return siblingClassName(typeElement,  "_MembersInjector");
   }
 
-  private static String factoryPrefix(ProductionBinding binding) {
+  static String classFileName(com.squareup.javapoet.ClassName className) {
+    return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
+  }
+
+  static com.squareup.javapoet.ClassName generatedMonitoringModuleName(
+      TypeElement componentElement) {
+    return siblingClassName(componentElement, "_MonitoringModule");
+  }
+
+  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code which could
+  // use this.
+  private static com.squareup.javapoet.ClassName siblingClassName(
+      TypeElement typeElement, String suffix) {
+    com.squareup.javapoet.ClassName className = com.squareup.javapoet.ClassName.get(typeElement);
+    return className.topLevelClassName().peerClass(classFileName(className) + suffix);
+  }
+
+  private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
+      case INJECTION:
+        return "";
+
+      case PROVISION:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+        return CaseFormat.LOWER_CAMEL.to(
+            UPPER_CAMEL, ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+
       default:
         throw new IllegalArgumentException();
     }
   }
 
+  static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+    ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+      builder.add(TypeVariableName.get(typeParameter));
+    }
+    return builder.build();
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
new file mode 100644
index 000000000..36963a7e8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Sets.difference;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Creates the nested implementation class for a subcomponent.
+ */
+final class SubcomponentWriter extends AbstractComponentWriter {
+
+  private AbstractComponentWriter parent;
+  private ExecutableElement subcomponentFactoryMethod;
+
+  public SubcomponentWriter(
+      AbstractComponentWriter parent,
+      ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph) {
+    super(
+        parent.types,
+        parent.elements,
+        parent.keyFactory,
+        parent.nullableValidationType,
+        subcomponentName(parent, subgraph),
+        subgraph,
+        parent.subcomponentImplNames);
+    this.parent = parent;
+    this.subcomponentFactoryMethod = subcomponentFactoryMethod;
+  }
+
+  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
+    return parent.name.nestedClassNamed(
+        parent.subcomponentImplNames.get(subgraph.componentDescriptor()));
+  }
+
+  @Override
+  protected InitializationState getInitializationState(BindingKey bindingKey) {
+    InitializationState initializationState = super.getInitializationState(bindingKey);
+    return initializationState.equals(UNINITIALIZED)
+        ? parent.getInitializationState(bindingKey)
+        : initializationState;
+  }
+
+  @Override
+  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+      TypeElement contributionType) {
+    return super.getOrCreateComponentContributionFieldSnippet(contributionType)
+        .or(parent.getOrCreateComponentContributionFieldSnippet(contributionType));
+  }
+
+  @Override
+  protected MemberSelect getMemberSelect(BindingKey key) {
+    MemberSelect memberSelect = super.getMemberSelect(key);
+    return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
+  }
+
+  @Override
+  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
+    return super.getMultibindingContributionSnippet(binding)
+        .or(parent.getMultibindingContributionSnippet(binding));
+  }
+
+  private ExecutableType resolvedSubcomponentFactoryMethod() {
+    return MoreTypes.asExecutable(
+        types.asMemberOf(
+            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
+            subcomponentFactoryMethod));
+  }
+
+  @Override
+  protected ClassWriter createComponentClass() {
+    ClassWriter componentWriter = parent.componentWriter.addNestedClass(name.simpleName());
+    componentWriter.addModifiers(PRIVATE, FINAL);
+    componentWriter.setSupertype(
+        MoreTypes.asTypeElement(
+            graph.componentDescriptor().builderSpec().isPresent()
+                ? graph
+                    .componentDescriptor()
+                    .builderSpec()
+                    .get()
+                    .componentType()
+                : resolvedSubcomponentFactoryMethod().getReturnType()));
+    return componentWriter;
+  }
+
+  @Override
+  protected void addBuilder() {
+    // Only write subcomponent builders if there is a spec.
+    if (graph.componentDescriptor().builderSpec().isPresent()) {
+      super.addBuilder();
+    }
+  }
+
+  @Override
+  protected ClassWriter createBuilder() {
+    // Only write subcomponent builders if there is a spec.
+    verify(graph.componentDescriptor().builderSpec().isPresent());
+    return parent.componentWriter.addNestedClass(
+        componentDefinitionTypeName().simpleName() + "Builder");
+  }
+
+  @Override
+  protected void addFactoryMethods() {
+    MethodWriter componentMethod;
+    if (graph.componentDescriptor().builderSpec().isPresent()) {
+      BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
+      componentMethod =
+          parent.componentWriter.addMethod(
+              spec.builderDefinitionType().asType(),
+              subcomponentFactoryMethod.getSimpleName().toString());
+      componentMethod.body().addSnippet("return new %s();", builderName.get());
+    } else {
+      ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
+      componentMethod =
+          parent.componentWriter.addMethod(
+              resolvedMethod.getReturnType(), subcomponentFactoryMethod.getSimpleName().toString());
+      writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
+    }
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
+  }
+
+  private void writeSubcomponentWithoutBuilder(
+      MethodWriter componentMethod, ExecutableType resolvedMethod) {
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
+    for (int i = 0; i < params.size(); i++) {
+      VariableElement moduleVariable = params.get(i);
+      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+        String preferredModuleName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
+        FieldWriter contributionField =
+            componentWriter.addField(moduleTypeElement, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(moduleType, actualModuleName);
+        constructorWriter.body()
+            .addSnippet("if (%s == null) {", actualModuleName)
+            .addSnippet("  throw new NullPointerException();")
+            .addSnippet("}");
+        constructorWriter.body().addSnippet("this.%1$s = %1$s;", actualModuleName);
+        MemberSelect moduleSelect = localField(name, actualModuleName);
+        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
+
+    Set<TypeElement> uninitializedModules =
+        difference(graph.componentRequirements(), componentContributionFields.keySet());
+
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName =
+          CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
+      FieldWriter contributionField = componentWriter.addField(moduleType, preferredModuleName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet("this.%s = new %s();",
+          actualModuleName, ClassName.fromTypeElement(moduleType));
+      MemberSelect moduleSelect = localField(name, actualModuleName);
+      componentContributionFields.put(moduleType, moduleSelect);
+    }
+
+    componentMethod.body().addSnippet("return new %s(%s);",
+        name, Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
new file mode 100644
index 000000000..80d83efba
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheckLazy;
+import dagger.internal.Factory;
+import dagger.producers.Produced;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+
+/**
+ * Common names and convenience methods for JavaPoet {@link TypeName} usage.
+ */
+final class TypeNames {
+
+  static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
+  static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
+  static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName EXECUTOR = ClassName.get(Executor.class);
+  static final ClassName FACTORY = ClassName.get(Factory.class);
+  static final ClassName FUTURES = ClassName.get(Futures.class);
+  static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
+  static final ClassName LIST = ClassName.get(List.class);
+  static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
+  static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+  static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
+  static final ClassName PRODUCED = ClassName.get(Produced.class);
+  static final ClassName PRODUCERS = ClassName.get(Producers.class);
+  static final ClassName PROVIDER = ClassName.get(Provider.class);
+
+  /**
+   * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
+   * Void}.
+   */
+  static final ClassName VOID_CLASS = ClassName.get(Void.class);
+
+  static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.get(
+          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+
+  static ParameterizedTypeName listOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LIST, typeName);
+  }
+
+  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  }
+
+  static ParameterizedTypeName producedOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PRODUCED, typeName);
+  }
+
+  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  }
+
+  static ParameterizedTypeName providerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PROVIDER, typeName);
+  }
+
+  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
+    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
+  }
+
+  static ParameterizedTypeName factoryOf(TypeName factoryType) {
+    return ParameterizedTypeName.get(FACTORY, factoryType);
+  }
+
+  private TypeNames() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1eca18f68..1b941ceab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,30 +16,15 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.hasModifiers;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -49,69 +34,6 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns the {@code V} type for a {@link Map} type like Map<K, Provider<V>>} if the map
-   * includes such a construction
-   */
-  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
-  }
-
-  // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
-  /**
-   * returns the value type for a {@link Map} type like Map<K, V>}.
-   */
-  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return mapArgs.get(1);
-  }
-
-  /**
-   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
-   */
-  public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return MoreTypes.asDeclared(mapArgs.get(0));
-  }
-
-  /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
-   */
-  static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
-      Equivalence<T> equivalence, Optional<T> optional) {
-    return optional.isPresent()
-        ? Optional.of(equivalence.wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<T>>absent();
-  }
-
-  /**
-   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
-   * type.
-   */
-  static <T> Optional<T> unwrapOptionalEquivalence(
-      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<T>absent();
-  }
-
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
-        return false;
-      case MEMBER:
-        return !typeElement.getModifiers().contains(STATIC);
-      case ANONYMOUS:
-      case LOCAL:
-        return true;
-      default:
-        throw new AssertionError("TypeElement cannot have nesting kind: "
-            + typeElement.getNestingKind());
-    }
-  }
 
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
@@ -150,73 +72,26 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
-  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
-      TypeElement type) {
-    List<ExecutableElement> methods = Lists.newArrayList();
-    TypeElement objectType = elements.getTypeElement(Object.class.getName());
-    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
-    return ImmutableList.copyOf(methods);
-  }
-
-  private static void findLocalAndInheritedMethodsRecursive(
-      TypeElement objectType,
-      Elements elements,
-      TypeElement type,
-      List<ExecutableElement> methods) {
-    if (objectType.equals(type)) {
-      return;
-    }
-
-    for (TypeMirror superInterface : type.getInterfaces()) {
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
-    }
-    if (type.getSuperclass().getKind() != TypeKind.NONE) {
-      // Visit the superclass after superinterfaces so we will always see the implementation of a
-      // method after any interfaces that declared it.
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
-    }
-    // Add each method of this class, and in so doing remove any inherited method it overrides.
-    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
-    // that while still using Elements.overrides.
-    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
-    for (ExecutableElement method : theseMethods) {
-      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
-        boolean alreadySeen = false;
-        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
-          ExecutableElement otherMethod = methodIter.next();
-          if (elements.overrides(method, otherMethod, type)) {
-            methodIter.remove();
-          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
-              && method.getParameters().equals(otherMethod.getParameters())) {
-            // If we inherit this method on more than one path, we don't want to add it twice.
-            alreadySeen = true;
-          }
-        }
-        if (!alreadySeen) {
-          methods.add(method);
-        }
-      }
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError(
+            "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
     }
   }
 
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
       Elements elements, TypeElement type) {
-    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
-        unimplementedMethods.add(method);
-      }
-    }
-    return unimplementedMethods.build();
+    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
+        .filter(hasModifiers(ABSTRACT))
+        .toSet();
   }
 
   private Util() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index d9e9daef7..e17406755 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,23 +21,37 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
 import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.NOTE;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
 /**
  * A collection of items describing contractual issues with the code as presented to an annotation
- * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}.
- * Callers will typically print the results of the report to a {@link Messager} instance using
- * {@link #printMessagesTo}.
+ * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}
+ * and clean subreports. Callers will typically print the results of the report to a
+ * {@link Messager} instance using {@link #printMessagesTo}.
+ *
+ * <p>A report describes a subject {@link Element}.  Callers may choose to add report items about
+ * other elements that are contained within or related to the subject. Since {@link Diagnostic}
+ * reporting is expected to be associated with elements that are currently being compiled,
+ * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they
+ * are contained within the subject. Otherwise, they will be associated with the subject and contain
+ * a reference to the item's element in the message string. It is the responsibility of the caller
+ * to choose subjects that are part of the compilation.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
-abstract class ValidationReport<T> {
+abstract class ValidationReport<T extends Element> {
   abstract T subject();
   abstract ImmutableSet<Item> items();
+  abstract ImmutableSet<ValidationReport<?>> subreports();
 
   boolean isClean() {
     for (Item item : items()) {
@@ -48,39 +62,80 @@ boolean isClean() {
           break;
       }
     }
+    for (ValidationReport<?> subreport : subreports()) {
+      if (!subreport.isClean()) {
+        return false;
+      }
+    }
     return true;
   }
 
   void printMessagesTo(Messager messager) {
     for (Item item : items()) {
-      item.printMessageTo(messager);
+      if (isEnclosedIn(subject(), item.element())) {
+        if (item.annotation().isPresent()) {
+          messager.printMessage(
+              item.kind(), item.message(), item.element(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), item.message(), item.element());
+        }
+      } else {
+        String message = String.format("[%s] %s", elementString(item.element()), item.message());
+        if (item.annotation().isPresent()) {
+          messager.printMessage(item.kind(), message, subject(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), message, subject());
+        }
+      }
+    }
+    for (ValidationReport<?> subreport : subreports()) {
+      subreport.printMessagesTo(messager);
     }
   }
 
+  private static String elementString(Element element) {
+    return element.accept(
+        new SimpleElementVisitor6<String, Void>() {
+          @Override
+          protected String defaultAction(Element e, Void p) {
+            return e.toString();
+          }
+
+          @Override
+          public String visitExecutable(ExecutableElement e, Void p) {
+            return e.getEnclosingElement().accept(this, null) + '.' + e.toString();
+          }
+        },
+        null);
+  }
+
+  private static boolean isEnclosedIn(Element parent, Element child) {
+    Element current = child;
+    while (current != null) {
+      if (current.equals(parent)) {
+        return true;
+      }
+      current = current.getEnclosingElement();
+    }
+    return false;
+  }
+
   @AutoValue
-  static abstract class Item implements PrintableErrorMessage {
+  static abstract class Item {
     abstract String message();
     abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
-
-    @Override
-    public void printMessageTo(Messager messager) {
-      if (annotation().isPresent()) {
-        messager.printMessage(kind(), message(), element(), annotation().get());
-      } else {
-        messager.printMessage(kind(), message(), element());
-      }
-    }
   }
 
-  static final class Builder<T> {
-    static <T> Builder<T> about(T subject) {
-      return new Builder<T>(subject);
-    }
+  static <T extends Element> Builder<T> about(T subject) {
+    return new Builder<T>(subject);
+  }
 
+  static final class Builder<T extends Element> {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
+    private final ImmutableSet.Builder<ValidationReport<?>> subreports = ImmutableSet.builder();
 
     private Builder(T subject) {
       this.subject = subject;
@@ -89,27 +144,62 @@ private Builder(T subject) {
     T getSubject() {
       return subject;
     }
-    
+
     Builder<T> addItems(Iterable<Item> newItems) {
       items.addAll(newItems);
       return this;
     }
 
-    Builder<T> addItem(String message, Element element) {
-      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message) {
+      addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Kind kind, Element element) {
-      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message, Element element) {
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
+    Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
       addItem(message, ERROR, element, Optional.of(annotation));
       return this;
     }
 
+    Builder<T> addWarning(String message) {
+      addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element) {
+      addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, WARNING, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addNote(String message) {
+      addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element) {
+      addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, NOTE, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
       addItem(message, kind, element, Optional.of(annotation));
       return this;
@@ -121,8 +211,13 @@ T getSubject() {
       return this;
     }
 
+    Builder<T> addSubreport(ValidationReport<?> subreport) {
+      subreports.add(subreport);
+      return this;
+    }
+
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<T>(subject, items.build());
+      return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index b2cb45134..9ffab1871 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -15,10 +15,12 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedMap;
@@ -27,6 +29,7 @@
 
 public final class AnnotationWriter implements Writable, HasClassReferences {
   private final ClassName annotationName;
+  private final Set<HasClassReferences> memberReferences = Sets.newLinkedHashSet();
   private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
 
   AnnotationWriter(ClassName annotationName) {
@@ -45,18 +48,29 @@ public void setMember(String name, String value) {
     memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
   }
 
+  public <T extends Enum<T>> void setMember(String name, T value) {
+    Snippet snippet = Snippet.format("%s.%s", ClassName.fromClass(value.getClass()), value);
+    memberMap.put(name, snippet);
+    memberReferences.add(snippet);
+  }
+
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('@');
     annotationName.write(appendable, context);
     if (!memberMap.isEmpty()) {
       appendable.append('(');
-      if (memberMap.size() == 1) {
-        Entry<String, Writable> onlyEntry = Iterables.getOnlyElement(memberMap.entrySet());
-        if (!onlyEntry.getKey().equals("value")) {
-          appendable.append(onlyEntry.getKey()).append(" = ");
+      boolean singleEntry = memberMap.size() == 1;
+      Iterator<Entry<String, Writable>> iterator = memberMap.entrySet().iterator();
+      while (iterator.hasNext()) {
+        Entry<String, Writable> member = iterator.next();
+        if (!singleEntry || !member.getKey().equals("value")) {
+          appendable.append(member.getKey()).append(" = ");
+        }
+        member.getValue().write(appendable, context);
+        if (iterator.hasNext()) {
+          appendable.append(",");
         }
-        onlyEntry.getValue().write(appendable, context);
       }
       appendable.append(')');
     }
@@ -65,6 +79,9 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of(annotationName);
+    return FluentIterable.from(memberReferences)
+        .append(annotationName)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 0b2615e9a..bd0791fc6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -95,11 +95,23 @@ public String canonicalName() {
     return fullyQualifiedName;
   }
 
+  /**
+   * Equivalent to {@link #classFileName(char) classFileName('$')}
+   */
   public String classFileName() {
+    return classFileName('$');
+  }
+
+  /**
+   * Returns the class name (excluding package).
+   *
+   * <p>The returned value includes the names of its enclosing classes (if any) but not the package
+   * name. e.g. {@code fromClass(Map.Entry.class).classFileName('_')} will return {@code Map_Entry}.
+   */
+  public String classFileName(char separator) {
     StringBuilder builder = new StringBuilder();
-    Joiner.on('$').appendTo(builder, enclosingSimpleNames());
-    if (!enclosingSimpleNames().isEmpty()) {
-      builder.append('$');
+    for (String enclosingSimpleName : enclosingSimpleNames) {
+      builder.append(enclosingSimpleName).append(separator);
     }
     return builder.append(simpleName()).toString();
   }
@@ -115,7 +127,6 @@ public ClassName topLevelClassName() {
   public ClassName nestedClassNamed(String memberClassName) {
     checkNotNull(memberClassName);
     checkArgument(SourceVersion.isIdentifier(memberClassName));
-    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
     return new ClassName(packageName(),
         new ImmutableList.Builder<String>()
             .addAll(enclosingSimpleNames())
@@ -127,10 +138,17 @@ public ClassName nestedClassNamed(String memberClassName) {
   public ClassName peerNamed(String peerClassName) {
     checkNotNull(peerClassName);
     checkArgument(SourceVersion.isIdentifier(peerClassName));
-    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
     return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
   }
 
+  /**
+   * Returns a parameterized type name with this as its raw type if {@code parameters} is not empty.
+   * If {@code parameters} is empty, returns this object.
+   */
+  public TypeName withTypeParameters(List<? extends TypeName> parameters) {
+    return parameters.isEmpty() ? this : ParameterizedTypeName.create(this, parameters);
+  }
+
   private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
       Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 95ddf0c39..edaba3a2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -138,17 +138,16 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, superclass.asSet(), annotations, typeParameters);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(superclass.asSet())
+        .append(annotations)
+        .append(typeParameters)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index f4a2c15f7..387c1ddf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -15,11 +15,9 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import java.io.IOException;
 import java.util.Map;
@@ -78,19 +76,17 @@ private VariableWriter addParameter(ClassName type, String name) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(annotations)
+        .append(blockWriter)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeAnnotations(appendable, context);
     writeModifiers(appendable).append(name).append('(');
     Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(") {");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
index cb0d75e73..4ab017d79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -18,7 +18,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -123,17 +122,15 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
-            constructorWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(constantWriters.values())
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 
@@ -170,12 +167,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     @Override
     public Set<ClassName> referencedClasses() {
       return FluentIterable.from(constructorSnippets)
-          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
-            @Override
-            public Set<ClassName> apply(Snippet input) {
-              return input.referencedClasses();
-            }
-          })
+          .transformAndConcat(HasClassReferences.COMBINER)
           .toSet();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
index 15b412068..e463ea2cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
@@ -15,8 +15,17 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.base.Function;
 import java.util.Set;
 
 public interface HasClassReferences {
   Set<ClassName> referencedClasses();
+
+  static final Function<HasClassReferences, Set<ClassName>> COMBINER =
+      new Function<HasClassReferences, Set<ClassName>>() {
+        @Override
+        public Set<ClassName> apply(HasClassReferences input) {
+          return input.referencedClasses();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index 5eac8a9ee..ffcfc7562 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -18,7 +18,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.io.IOException;
 import java.util.Iterator;
@@ -76,16 +76,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 4fa5a3fc9..674dd621e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -26,13 +26,19 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
-import com.google.common.io.Closer;
+import com.google.common.io.CharSink;
+import com.google.common.io.CharSource;
+import com.google.googlejavaformat.java.Formatter;
+import com.google.googlejavaformat.java.FormatterException;
+import dagger.internal.codegen.ComponentProcessor;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.io.Writer;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
@@ -97,7 +103,13 @@ public InterfaceWriter addInterface(String simpleName) {
     return writer;
   }
 
-  public Appendable write(Appendable appendable) throws IOException {
+  public void markGenerated(boolean generatedAnnotationAvailable) {
+    for (TypeWriter typeWriter : typeWriters) {
+      typeWriter.markGenerated(generatedAnnotationAvailable);
+    }
+  }
+
+  public <A extends Appendable> A write(A appendable) throws IOException {
     if (!packageName.isEmpty()) {
       appendable.append("package ").append(packageName).append(";\n\n");
     }
@@ -173,20 +185,19 @@ public void file(Filer filer, Iterable<? extends Element> originatingElements)
 
   public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
       throws IOException {
-    JavaFileObject sourceFile = filer.createSourceFile(name,
+    final JavaFileObject sourceFile = filer.createSourceFile(name,
         Iterables.toArray(originatingElements, Element.class));
-    Closer closer = Closer.create();
     try {
-      write(closer.register(sourceFile.openWriter()));
-    } catch (Exception e) {
-      try {
-        sourceFile.delete();
-      } catch (Exception e2) {
-        // couldn't delete the file
-      }
-      throw closer.rethrow(e);
-    } finally {
-      closer.close();
+      new Formatter().formatSource(
+          CharSource.wrap(write(new StringBuilder())),
+          new CharSink() {
+            @Override public Writer openStream() throws IOException {
+              return sourceFile.openWriter();
+            }
+          });
+    } catch (FormatterException e) {
+      throw new IllegalStateException(
+          "The writer produced code that could not be parsed by the formatter", e);
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 7831fe816..eb4ff8d51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -111,14 +110,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(returnType)
+        .append(body.asSet())
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index bb4c6ffd9..91072baf6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -17,17 +17,25 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import dagger.internal.codegen.ComponentProcessor;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Generated;
 import javax.lang.model.element.Modifier;
 
 public abstract class Modifiable {
+
+  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
+
   final Set<Modifier> modifiers;
   final List<AnnotationWriter> annotations;
+  // This is not intended to be widely used; handling comments should be deferred to
+  // when Javapoet is adopted
+  private String generatedComment;
 
   Modifiable() {
     this.modifiers = EnumSet.noneOf(Modifier.class);
@@ -52,6 +60,18 @@ public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
     return annotate(ClassName.fromClass(annotation));
   }
 
+  public void markGenerated(boolean generatedAnnotationAvailable) {
+    if (generatedAnnotationAvailable) {
+      AnnotationWriter annotation = annotate(Generated.class);
+      annotation.setValue(ComponentProcessor.class.getName());
+      annotation.setMember("comments", GENERATED_COMMENTS);
+    } else {
+      generatedComment =
+          String.format(
+              "// Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
+    }
+  }
+
   Appendable writeModifiers(Appendable appendable) throws IOException {
     for (Modifier modifier : modifiers) {
       appendable.append(modifier.toString()).append(' ');
@@ -63,6 +83,9 @@ Appendable writeAnnotations(Appendable appendable, Context context) throws IOExc
     for (AnnotationWriter annotationWriter : annotations) {
       annotationWriter.write(appendable, context).append('\n');
     }
+    if (generatedComment != null) {
+      appendable.append(generatedComment).append('\n');
+    }
     return appendable;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 63cf3dd95..e46a96186 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -31,7 +31,7 @@
 
   ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
     this.type = type;
-    this.parameters = ImmutableList.copyOf(parameters);
+    this.parameters = ImmutableList.<TypeName>copyOf(parameters);
   }
   
   public ClassName type() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 50dc91838..80ab944f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -27,28 +27,9 @@
 import java.util.Iterator;
 import java.util.Set;
 
-public final class Snippet implements HasClassReferences, Writable {
-  private final String format;
-  private final ImmutableSet<TypeName> types;
-  private final ImmutableList<Object> args;
-
-  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
-    this.format = format;
-    this.types = types;
-    this.args = args;
-  }
-
-  public String format() {
-    return format;
-  }
+public abstract class Snippet implements HasClassReferences, Writable {
 
-  public ImmutableList<Object> args() {
-    return args;
-  }
-
-  public ImmutableSet<TypeName> types() {
-    return types;
-  }
+  abstract ImmutableSet<TypeName> types();
 
   @Override
   public String toString() {
@@ -56,40 +37,96 @@ public String toString() {
   }
 
   @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(types)
-        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(TypeName input) {
-            return input.referencedClasses();
-          }
-        })
+  public final Set<ClassName> referencedClasses() {
+    return FluentIterable.from(types())
+        .transformAndConcat(
+            new Function<TypeName, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(TypeName input) {
+                return input.referencedClasses();
+              }
+            })
         .toSet();
   }
 
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
-    for (Object arg : args) {
-      if (arg instanceof Writable) {
-        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
-      } else {
-        formattedArgsBuilder.add(arg);
+  private static final class BasicSnippet extends Snippet {
+    final String format;
+    final ImmutableSet<TypeName> types;
+    final ImmutableList<Object> args;
+
+    BasicSnippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
+      this.format = format;
+      this.types = types;
+      this.args = args;
+    }
+
+    @Override
+    ImmutableSet<TypeName> types() {
+      return types;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
+      for (Object arg : args) {
+        if (arg instanceof Writable) {
+          formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
+        } else {
+          formattedArgsBuilder.add(arg);
+        }
       }
+
+      @SuppressWarnings("resource") // intentionally don't close the formatter
+      Formatter formatter = new Formatter(appendable);
+      formatter.format(format, Iterables.toArray(formattedArgsBuilder.build(), Object.class));
+
+      return appendable;
     }
+  }
 
-    @SuppressWarnings("resource") // intentionally don't close the formatter
-    Formatter formatter = new Formatter(appendable);
-    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));
+  private static final class CompoundSnippet extends Snippet {
+    final String joinToken;
+    final ImmutableList<Snippet> snippets;
+
+    CompoundSnippet(String joinToken, ImmutableList<Snippet> snippets) {
+      this.joinToken = joinToken;
+      this.snippets = snippets;
+    }
 
-    return appendable;
+    @Override
+    ImmutableSet<TypeName> types() {
+      return FluentIterable.from(snippets)
+          .transformAndConcat(
+              new Function<Snippet, Iterable<TypeName>>() {
+                @Override
+                public Iterable<TypeName> apply(Snippet input) {
+                  return input.types();
+                }
+              })
+          .toSet();
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      Iterator<Snippet> snippetIterator = snippets.iterator();
+      if (snippetIterator.hasNext()) {
+        Snippet firstSnippet = snippetIterator.next();
+        firstSnippet.write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          Snippet nextSnippet = snippetIterator.next();
+          appendable.append(joinToken);
+          nextSnippet.write(appendable, context);
+        }
+      }
+      return appendable;
+    }
   }
 
   public static Snippet format(String format, Object... args) {
     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
     for (Object arg : args) {
       if (arg instanceof Snippet) {
-        types.addAll(((Snippet) arg).types);
+        types.addAll(((Snippet) arg).types());
       }
       if (arg instanceof TypeName) {
         types.add((TypeName) arg);
@@ -98,7 +135,7 @@ public static Snippet format(String format, Object... args) {
         types.add(((HasTypeName) arg).name());
       }
     }
-    return new Snippet(format, types.build(), ImmutableList.copyOf(args));
+    return new BasicSnippet(format, types.build(), ImmutableList.copyOf(args));
   }
 
   public static Snippet format(String format, Iterable<? extends Object> args) {
@@ -110,65 +147,31 @@ public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors)
         selectors);
   }
 
+  public static Snippet nullCheck(Object thingToCheck) {
+    return format("if (%s == null) { throw new NullPointerException(); } ", thingToCheck);
+  }
+
+  public static Snippet nullCheck(Object thingToCheck, String message) {
+    return format("if (%s == null) { throw new NullPointerException(%s); } ",
+        thingToCheck,
+        StringLiteral.forValue(message));
+  }
+
   public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
-    Iterator<Snippet> iterator = parameterSnippets.iterator();
-    StringBuilder stringBuilder = new StringBuilder();
-    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
-    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();
-    if (iterator.hasNext()) {
-      Snippet firstSnippet = iterator.next();
-      stringBuilder.append(firstSnippet.format());
-      typesBuilder.addAll(firstSnippet.types());
-      argsBuilder.addAll(firstSnippet.args());
-    }
-    while (iterator.hasNext()) {
-      Snippet nextSnippet = iterator.next();
-      stringBuilder.append(", ").append(nextSnippet.format());
-      typesBuilder.addAll(nextSnippet.types());
-      argsBuilder.addAll(nextSnippet.args());
-    }
-    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
+    return join(", ", parameterSnippets);
   }
 
   /**
-   * A snippet that concatenates its arguments.
+   * A snippet that concatenates its arguments with each snippet separated by a new line.
    */
   public static Snippet concat(Iterable<Snippet> snippets) {
-    return join(Joiner.on(""), snippets);
+    return join("\n", snippets);
   }
 
   /**
    * A snippet that joins its arguments with {@code joiner}.
    */
-  public static Snippet join(Joiner joiner, Iterable<Snippet> snippets) {
-    FluentIterable<Snippet> fluentSnippets = FluentIterable.from(snippets);
-    return new Snippet(
-        fluentSnippets
-            .transform(
-                new Function<Snippet, String>() {
-                  @Override
-                  public String apply(Snippet snippet) {
-                    return snippet.format;
-                  }
-                })
-            .join(joiner),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableSet<TypeName>>() {
-                  @Override
-                  public ImmutableSet<TypeName> apply(Snippet snippet) {
-                    return snippet.types;
-                  }
-                })
-            .toSet(),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableList<Object>>() {
-                  @Override
-                  public ImmutableList<Object> apply(Snippet snippet) {
-                    return snippet.args;
-                  }
-                })
-            .toList());
+  public static Snippet join(String joinToken, Iterable<Snippet> snippets) {
+    return new CompoundSnippet(joinToken, ImmutableList.copyOf(snippets));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 28a290e35..58ee1e494 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import java.io.IOException;
 import java.util.Set;
 
@@ -39,6 +41,7 @@ public String name() {
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeAnnotations(appendable, context);
     writeModifiers(appendable);
     type.write(appendable, context);
     return appendable.append(' ').append(name);
@@ -46,6 +49,10 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return type.referencedClasses();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(annotations)
+        .append(type)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
new file mode 100644
index 000000000..43d471879
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.CompilationRule;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unused") // contains a variety things used by the compilation rule for testing
+public class AccessibilityTest {
+  /* test data */
+  public AccessibilityTest() {}
+  protected AccessibilityTest(Object o) {}
+  AccessibilityTest(Object o1, Object o2) {}
+  private AccessibilityTest(Object o1, Object o2, Object o3) {}
+
+  public String publicField;
+  protected String protectedField;
+  String packagePrivateField;
+  private String privateField;
+
+  public void publicMethod() {}
+  protected void protectedMethod() {}
+  void packagePrivateMethod() {}
+  private void privateMethod() {}
+
+  public static final class PublicNestedClass {}
+  protected static final class ProtectedNestedClass {}
+  static final class PackagePrivateNestedClass {}
+  private static final class PrivateNestedClass {}
+
+  @Rule
+  public final CompilationRule compilationRule = new CompilationRule();
+
+  private TypeElement testElement;
+
+  @Before
+  public void setUp() {
+    Elements elements = compilationRule.getElements();
+    testElement = elements.getTypeElement(AccessibilityTest.class.getCanonicalName());
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicType() {
+    assertThat(isElementAccessibleFrom(testElement, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicMethod() {
+    Element member = getMemberNamed("publicMethod");
+    assertThat(isElementAccessibleFrom(member, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_protectedMethod() {
+    Element member = getMemberNamed("protectedMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_packagePrivateMethod() {
+    Element member = getMemberNamed("packagePrivateMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_privateMethod() {
+    Element member = getMemberNamed( "privateMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isFalse();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicField() {
+    Element member = getMemberNamed("publicField");
+    assertThat(isElementAccessibleFrom(member, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_protectedField() {
+    Element member = getMemberNamed("protectedField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_packagePrivateField() {
+    Element member = getMemberNamed("packagePrivateField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_privateField() {
+    Element member = getMemberNamed("privateField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isFalse();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  private Element getMemberNamed(String memberName) {
+    for (Element enclosedElement : testElement.getEnclosedElements()) {
+      if (enclosedElement.getSimpleName().contentEquals(memberName)) {
+        return enclosedElement;
+      }
+    }
+    throw new IllegalArgumentException();
+  }
+}
+
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index eaaa595d3..b8349156d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -64,26 +64,21 @@ private ExecutableElement getXConstructor() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
     TypeName xClass = TypeNames.forTypeMirror(key.type());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
-        .frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class), xClass));
-    assertThat(FrameworkField.createWithTypeFromKey(MembersInjector.class,
-            BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key), "test")
-        .frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class), xClass));
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(ClassName.fromClass(Provider.class), xClass));
+    assertThat(
+            FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
+                .frameworkType())
+        .isEqualTo(
+            ParameterizedTypeName.create(ClassName.fromClass(MembersInjector.class), xClass));
   }
 
   @Test public void nameSuffix() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "foo").name())
         .isEqualTo("fooProvider");
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
-            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "fooProvider").name())
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "fooProvider").name())
         .isEqualTo("fooProvider");
 
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index de59af6ec..d318cd37c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -25,14 +25,15 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 /** Tests for {@link dagger.Component.Builder} */
 @RunWith(JUnit4.class)
 public class ComponentBuilderTest {
-  
+
   private static final ErrorMessages.ComponentBuilderMessages MSGS =
       ErrorMessages.ComponentBuilderMessages.INSTANCE;
-  
+
   @Test
   public void testEmptyBuilder() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -57,7 +58,7 @@ public void testEmptyBuilder() {
         "  @Component.Builder",
         "  static interface Builder {",
         "     SimpleComponent build();",
-        "  }",        
+        "  }",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.DaggerSimpleComponent",
@@ -66,11 +67,10 @@ public void testEmptyBuilder() {
         "import javax.annotation.Generated;",
         "import test.SimpleComponent",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static SimpleComponent.Builder builder() {",
@@ -81,9 +81,6 @@ public void testEmptyBuilder() {
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize(final Builder builder) {",
-        "  }",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -101,7 +98,7 @@ public void testEmptyBuilder() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testUsesBuildAndSetterNames() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
@@ -138,7 +135,7 @@ public void testUsesBuildAndSetterNames() {
         "import javax.inject.Provider;",
         "import test.TestComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<String> stringProvider;",
         "",
@@ -155,6 +152,7 @@ public void testUsesBuildAndSetterNames() {
         "    return builder().create();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
         "  }",
@@ -178,7 +176,7 @@ public void testUsesBuildAndSetterNames() {
         "    @Override",
         "    public Builder setTestModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -191,7 +189,7 @@ public void testUsesBuildAndSetterNames() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testIgnoresModulesNotInApi() {
     JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
@@ -227,7 +225,7 @@ public void testIgnoresModulesNotInApi() {
         "",
         "  @Component.Builder",
         "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule);",
+        "    Builder testModule1(TestModule1 testModule1);",
         "    TestComponent build();",
         "  }",
         "}");
@@ -239,7 +237,7 @@ public void testIgnoresModulesNotInApi() {
         "import javax.inject.Provider;",
         "import test.TestComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<String> stringProvider;",
         "  private Provider<Integer> integerProvider;",
@@ -257,6 +255,7 @@ public void testIgnoresModulesNotInApi() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
         "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
@@ -290,7 +289,7 @@ public void testIgnoresModulesNotInApi() {
         "    @Override",
         "    public Builder testModule1(TestModule1 testModule1) {",
         "      if (testModule1 == null) {",
-        "        throw new NullPointerException(\"testModule1\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule1 = testModule1;",
         "      return this;",
@@ -303,7 +302,7 @@ public void testIgnoresModulesNotInApi() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testMoreThanOneBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -323,7 +322,7 @@ public void testMoreThanOneBuilderFails() {
         "  @Component.Builder",
         "  interface Builder2 {",
         "     SimpleComponent build();",
-        "  }",           
+        "  }",
         "}");
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
@@ -332,7 +331,7 @@ public void testMoreThanOneBuilderFails() {
             "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderGenericsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -347,7 +346,7 @@ public void testBuilderGenericsFails() {
         "  @Component.Builder",
         "  interface Builder<T> {",
         "     SimpleComponent build();",
-        "  }",           
+        "  }",
         "}");
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
@@ -355,7 +354,7 @@ public void testBuilderGenericsFails() {
         .withErrorContaining(MSGS.generics())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderNotInComponentFails() {
     JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
@@ -371,7 +370,7 @@ public void testBuilderNotInComponentFails() {
         .withErrorContaining(MSGS.mustBeInComponent())
         .in(builder);
   }
-  
+
   @Test
   public void testBuilderMissingBuildMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -392,7 +391,7 @@ public void testBuilderMissingBuildMethodFails() {
         .withErrorContaining(MSGS.missingBuildMethod())
         .in(componentFile);
   }
-  
+
   @Test
   public void testPrivateBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -413,7 +412,7 @@ public void testPrivateBuilderFails() {
         .withErrorContaining(MSGS.isPrivate())
         .in(componentFile);
   }
-  
+
   @Test
   public void testNonStaticBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -434,7 +433,7 @@ public void testNonStaticBuilderFails() {
         .withErrorContaining(MSGS.mustBeStatic())
         .in(componentFile);
   }
-  
+
   @Test
   public void testNonAbstractBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -454,7 +453,7 @@ public void testNonAbstractBuilderFails() {
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeAbstract());
   }
-  
+
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -477,7 +476,7 @@ public void testBuilderOneCxtorWithArgsFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -501,7 +500,7 @@ public void testBuilderMoreThanOneCxtorFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderEnumFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -522,7 +521,7 @@ public void testBuilderEnumFails() {
         .withErrorContaining(MSGS.mustBeClassOrInterface())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -545,7 +544,7 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         .withErrorContaining(MSGS.buildMustReturnComponentType())
             .in(componentFile).onLine(11);
   }
-  
+
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -571,7 +570,7 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
             .in(componentFile).onLine(14);
   }
-  
+
   @Test
   public void testTwoBuildMethodsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -595,7 +594,7 @@ public void testTwoBuildMethodsFails() {
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testInheritedTwoBuildMethodsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -622,7 +621,7 @@ public void testInheritedTwoBuildMethodsFails() {
             String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
             .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testMoreThanOneArgFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -649,7 +648,7 @@ public void testMoreThanOneArgFails() {
         .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
             .in(componentFile).onLine(13);
   }
-  
+
   @Test
   public void testInheritedMoreThanOneArgFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -677,7 +676,7 @@ public void testInheritedMoreThanOneArgFails() {
                 "set1(java.lang.String,java.lang.Integer)"))
             .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -701,7 +700,7 @@ public void testSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -727,9 +726,9 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
                 "set(java.lang.Integer)"))
-            .in(componentFile).onLine(15);    
+            .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testGenericsOnSetterMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -753,7 +752,7 @@ public void testGenericsOnSetterMethodFails() {
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -778,9 +777,9 @@ public void testGenericsOnInheritedSetterMethodFails() {
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(15);    
+            .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -807,7 +806,7 @@ public void testMultipleSettersPerTypeFails() {
                   "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
             .in(componentFile).onLine(10);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -837,7 +836,7 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
                   "java.lang.String", "[set1(T), set2(java.lang.String)]"))
             .in(componentFile).onLine(14);
   }
-  
+
   @Test
   public void testExtraSettersFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -864,9 +863,9 @@ public void testExtraSettersFails() {
                   "[void test.SimpleComponent.Builder.set1(String),"
                   + " void test.SimpleComponent.Builder.set2(Integer)]"))
             .in(componentFile).onLine(10);
-    
+
   }
-  
+
   @Test
   public void testMissingSettersFail() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f7e79da29..ba235258a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,17 +15,27 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.MembersInjector;
 import dagger.internal.codegen.writer.StringLiteral;
 import java.io.IOException;
 import java.io.Writer;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
@@ -37,6 +47,8 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -216,11 +228,10 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -231,9 +242,6 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize(final Builder builder) {",
-        "  }",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -300,7 +308,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
@@ -317,6 +325,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectableTypeProvider =",
         "        ScopedProvider.create(SomeInjectableType_Factory.create());",
@@ -382,7 +391,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import test.OuterType.B;",
         "import test.OuterType.SimpleComponent;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
         "  private MembersInjector<B> bMembersInjector;",
         "",
@@ -399,6 +408,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bMembersInjector =",
         "        OuterType$B_MembersInjector.create(OuterType$A_Factory.create());",
@@ -480,7 +490,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
@@ -498,6 +508,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
         "        C_Factory.create());",
@@ -524,7 +535,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -614,7 +625,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "",
         "  private DaggerTestComponent(Builder builder) {",
@@ -630,83 +641,58 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  }",
         "",
         "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "    private ParentTestIncluded parentTestIncluded;",
-        "    private AlwaysIncluded alwaysIncluded;",
-        "    private DepModule depModule;",
-        "    private ParentDepIncluded parentDepIncluded;",
-        "    private RefByDep refByDep;",
-        "",
         "    private Builder() {",
         "    }",
         "",
         "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      if (parentTestIncluded == null) {",
-        "        this.parentTestIncluded = new ParentTestIncluded();",
-        "      }",
-        "      if (alwaysIncluded == null) {",
-        "        this.alwaysIncluded = new AlwaysIncluded();",
-        "      }",
-        "      if (depModule == null) {",
-        "        this.depModule = new DepModule();",
-        "      }",
-        "      if (parentDepIncluded == null) {",
-        "        this.parentDepIncluded = new ParentDepIncluded();",
-        "      }",
-        "      if (refByDep == null) {",
-        "        this.refByDep = new RefByDep();",
-        "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.testModule = testModule;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
         "      if (parentTestIncluded == null) {",
-        "        throw new NullPointerException(\"parentTestIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.parentTestIncluded = parentTestIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
         "      if (alwaysIncluded == null) {",
-        "        throw new NullPointerException(\"alwaysIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.alwaysIncluded = alwaysIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder depModule(DepModule depModule) {",
         "      if (depModule == null) {",
-        "        throw new NullPointerException(\"depModule\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.depModule = depModule;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
         "      if (parentDepIncluded == null) {",
-        "        throw new NullPointerException(\"parentDepIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.parentDepIncluded = parentDepIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder refByDep(RefByDep refByDep) {",
         "      if (refByDep == null) {",
-        "        throw new NullPointerException(\"refByDep\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.refByDep = refByDep;",
         "      return this;",
         "    }",
         "  }",
@@ -761,6 +747,201 @@ public void generatedTransitiveModule() {
         .compilesWithoutError();
   }
 
+  @Test
+  public void generatedModuleInSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GeneratedModule.class)",
+            "interface ChildComponent {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  ChildComponent childComponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponent, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponent, component))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedModule",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "",
+                "@Module",
+                "final class GeneratedModule {}"))
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.mapkeys.StringKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides(type = SET) static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
+            "  private Provider<Set<Object>> setOfObjectProvider;",
+            "  private Provider<Object> mapOfStringAndProviderOfObjectContribution1;",
+            "  private Provider<Map<String, Provider<Object>>>",
+            "      mapOfStringAndProviderOfObjectProvider;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfObjectContribution1Provider =",
+            "        ParentModule_ParentObjectFactory.create();",
+            "    this.setOfObjectProvider = SetFactory.create(setOfObjectContribution1Provider);",
+            "    this.mapOfStringAndProviderOfObjectContribution1 =",
+            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
+            "    this.mapOfStringAndProviderOfObjectProvider =",
+            "        MapProviderFactory.<String, Object>builder(1)",
+            "            .put(\"parent key\", mapOfStringAndProviderOfObjectContribution1)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      if (parentModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.parentModule = parentModule;",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
+            "          DaggerParent.this.mapOfStringAndProviderOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Object> objectSet() {",
+            "      return DaggerParent.this.setOfObjectProvider.get();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return mapOfStringAndObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
   @Test public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
@@ -839,7 +1020,7 @@ public void generatedTransitiveModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Set<String>> setOfStringContribution1Provider;",
         "  private Provider<Set<String>> setOfStringContribution2Provider;",
@@ -858,6 +1039,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.setOfStringContribution1Provider =",
         "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
@@ -891,7 +1073,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
         "      if (emptySetModule == null) {",
-        "        throw new NullPointerException(\"emptySetModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.emptySetModule = emptySetModule;",
         "      return this;",
@@ -899,7 +1081,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder setModule(SetModule setModule) {",
         "      if (setModule == null) {",
-        "        throw new NullPointerException(\"setModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.setModule = setModule;",
         "      return this;",
@@ -951,7 +1133,7 @@ public void generatedTransitiveModule() {
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
@@ -968,6 +1150,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectedTypeMembersInjector =",
         "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
@@ -1029,7 +1212,7 @@ public void generatedTransitiveModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SimpleComponent> simpleComponentProvider;",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
@@ -1047,6 +1230,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
@@ -1108,7 +1292,7 @@ public void generatedTransitiveModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
@@ -1126,6 +1310,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectedTypeMembersInjector =",
         "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
@@ -1181,12 +1366,11 @@ public void generatedTransitiveModule() {
         "test.DaggerSimpleComponent",
         "package test;",
         "",
-        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
@@ -1203,9 +1387,10 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "        SomeInjectableType_Factory.create(MembersInjectors.<SomeInjectableType>noOp());",
         "  }",
         "",
         "  @Override",
@@ -1278,7 +1463,7 @@ public void generatedTransitiveModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerBComponent implements BComponent {",
         "  private Provider<A> aProvider;",
         "  private Provider<B> bProvider;",
@@ -1292,6 +1477,7 @@ public void generatedTransitiveModule() {
         "    return new Builder();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.aProvider = new Factory<A>() {",
         "      private final AComponent aComponent = builder.aComponent;",
@@ -1319,14 +1505,15 @@ public void generatedTransitiveModule() {
         "",
         "    public BComponent build() {",
         "      if (aComponent == null) {",
-        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+        "            + \" must be set\");",
         "      }",
         "      return new DaggerBComponent(this);",
         "    }",
         "",
         "    public Builder aComponent(AComponent aComponent) {",
         "      if (aComponent == null) {",
-        "        throw new NullPointerException(\"aComponent\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.aComponent = aComponent;",
         "      return this;",
@@ -1393,7 +1580,7 @@ public void generatedTransitiveModule() {
         "import other.test.TestModule;",
         "import other.test.TestModule_AFactory;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<test.A> aProvider;",
         "  private Provider<A> aProvider1;",
@@ -1411,6 +1598,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.aProvider = test.TestModule_AFactory.create(builder.testModule);",
         "    this.aProvider1 = TestModule_AFactory.create(builder.testModule1);",
@@ -1445,7 +1633,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder testModule(test.TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -1453,7 +1641,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule1 = testModule;",
         "      return this;",
@@ -1521,7 +1709,7 @@ public void generatedTransitiveModule() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
@@ -1540,6 +1728,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bProvider = B_Factory.create(C_Factory.create());",
         "    this.aProvider = A_Factory.create(bProvider);",
@@ -1627,11 +1816,10 @@ public void generatedTransitiveModule() {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1642,8 +1830,6 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize(final Builder builder) {}",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -1715,11 +1901,10 @@ public void generatedTransitiveModule() {
         "",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    initialize(builder);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1730,8 +1915,6 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize(final Builder builder) {}",
-        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return SomeInjectableType_Factory.create().get();",
@@ -1798,7 +1981,6 @@ public void generatedTransitiveModule() {
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
-
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -1813,9 +1995,6 @@ public void componentImplicitlyDependsOnGeneratedType() {
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
@@ -1825,7 +2004,8 @@ public void componentImplicitlyDependsOnGeneratedType() {
         .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(
             new ComponentProcessor(),
-            new GeneratingProcessor("test.GeneratedType",
+            new GeneratingProcessor(
+                "test.GeneratedType",
                 "package test;",
                 "",
                 "import javax.inject.Inject;",
@@ -1833,7 +2013,45 @@ public void componentImplicitlyDependsOnGeneratedType() {
                 "final class GeneratedType {",
                 "  @Inject GeneratedType() {}",
                 "}"))
-        .compilesWithoutError();
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
+  }
+  @Test
+  public void componentSupertypeDependsOnGeneratedType() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent extends SimpleComponentInterface {}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponentInterface",
+            "package test;",
+            "",
+            "interface SimpleComponentInterface {",
+            "  GeneratedType generatedType();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, interfaceFile))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedType",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "final class GeneratedType {",
+                "  @Inject GeneratedType() {}",
+                "}"))
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
   }
 
   @Test
@@ -1887,13 +2105,13 @@ public void genericTestToLetMeDebugInEclipse() {
          "import javax.annotation.Generated;",
          "import javax.inject.Provider;",
          "",
-         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+         GENERATED_ANNOTATION,
          "public final class DaggerSimpleComponent implements SimpleComponent {",
          "  private Provider<D> dProvider;",
          "",
          "  private DaggerSimpleComponent(Builder builder) {",
          "    assert builder != null;",
-         "    initialize();",
+         "    initialize(builder);",
          "  }",
          "",
          "  public static Builder builder() {",
@@ -1904,7 +2122,8 @@ public void genericTestToLetMeDebugInEclipse() {
          "    return builder().build();",
          "  }",
          "",
-         "  private void initialize() {",
+         "  @SuppressWarnings(\"unchecked\")",
+         "  private void initialize(final Builder builder) {",
          "    this.dProvider = new D_Factory(B_Factory.INSTANCE);",
          "  }",
          "",
@@ -1928,6 +2147,197 @@ public void genericTestToLetMeDebugInEclipse() {
          .and().generatesSources(generatedComponent);
    }
 
+  /**
+   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn't
+   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types
+   * with {@link Inject @Inject} constructors if they have any injection sites, and it only
+   * generates them for types without {@link Inject @Inject} constructors if they have local
+   * (non-inherited) injection sites. So make sure we warn in only those cases where running the
+   * Dagger processor actually generates a {@link MembersInjector}.
+   */
+  @Test
+  public void unprocessedMembersInjectorNotes() {
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  void inject(test.inject.NoInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.NoInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberWithConstructor object);",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class TestModule {",
+                    "  @Provides static Object object() {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "public class NoInjectMemberNoConstructor {",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class NoInjectMemberWithConstructor {",
+                    "  @Inject NoInjectMemberWithConstructor() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberNoConstructor {",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberWithConstructor {",
+                    "  @Inject LocalInjectMemberWithConstructor() {}",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberNoConstructor",
+                    "    extends LocalInjectMemberNoConstructor {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberWithConstructor",
+                    "    extends LocalInjectMemberNoConstructor {",
+                    "  @Inject ParentInjectMemberWithConstructor() {}",
+                    "}")))
+        .processedWith(
+            new ElementFilteringComponentProcessor(
+                Predicates.not(
+                    new Predicate<Element>() {
+                      @Override
+                      public boolean apply(Element element) {
+                        return MoreElements.getPackage(element)
+                            .getQualifiedName()
+                            .toString()
+                            .equals("test.inject");
+                      }
+                    })))
+        .compilesWithoutError();
+        /* TODO(b/23108801): Uncomment when compilesWithoutWarnings() is implemented.
+        .compilesWithoutWarnings()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberNoConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.ParentInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteCount(3);
+         */
+  }
+
+  /**
+   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
+   */
+  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {
+    private final ComponentProcessor componentProcessor = new ComponentProcessor();
+    private final Predicate<? super Element> filter;
+
+    /**
+     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.
+     */
+    public ElementFilteringComponentProcessor(Predicate<? super Element> filter) {
+      this.filter = filter;
+    }
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+      super.init(processingEnv);
+      componentProcessor.init(processingEnv);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return componentProcessor.getSupportedAnnotationTypes();
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return componentProcessor.getSupportedSourceVersion();
+    }
+
+    @Override
+    public boolean process(
+        Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
+      return componentProcessor.process(
+          annotations,
+          new RoundEnvironment() {
+            @Override
+            public boolean processingOver() {
+              return roundEnv.processingOver();
+            }
+
+            @Override
+            public Set<? extends Element> getRootElements() {
+              return Sets.filter(roundEnv.getRootElements(), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public boolean errorRaised() {
+              return roundEnv.errorRaised();
+            }
+          });
+    }
+  }
+
   /**
    * A simple {@link Processor} that generates one source file.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 76b28e461..b47a43c1c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -57,7 +57,7 @@
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
   private List<? extends VariableElement> sampleProviderParameters() {
@@ -131,7 +131,7 @@ private DependencyRequest dependencyRequestForProduced() {
   @Module
   static final class ProvidesMethodModule {
     @Provides String provideString(
-        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Y> d) {
       return null;
     }
   }
@@ -142,4 +142,6 @@ private DependencyRequest dependencyRequestForProduced() {
       return null;
     }
   }
+  
+  static final class Y {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
similarity index 52%
rename from compiler/src/main/java/dagger/internal/codegen/Validator.java
rename to compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 615f863c0..0a37c2294 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Validator.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,16 @@
 package dagger.internal.codegen;
 
 /**
- * Validates a given subject and produces a {@link ValidationReport} containing the result.
- *
- * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
+ * Common lines outputted during code generation.
  */
-interface Validator<T> {
-  ValidationReport<T> validate(T subject);
+public final class GeneratedLines {
+  public static final String GENERATED_ANNOTATION =
+      "@Generated("
+          + "comments = \"https://google.github.io/dagger\", "
+          + "value = \"dagger.internal.codegen.ComponentProcessor\")";
+
+  public static final String GENERATED_ANNOTATION_JAVAPOET =
+      "@Generated("
+          + "value = \"dagger.internal.codegen.ComponentProcessor\", "
+          + "comments = \"https://google.github.io/dagger\")";
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index da0c2b06c..e207fe0ee 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -130,6 +130,7 @@
         "import javax.inject.Inject;",
         "",
         "class SimpleType {",
+        "  @Inject SimpleType() {}",
         "  static class A { @Inject A() {} }",
         "  static class B { @Inject B() {} }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 19b9c9419..86e84690a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -20,6 +20,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,7 +28,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
@@ -67,25 +68,38 @@
   }
 
   @Test public void componentProvisionWithNoDependencyChain() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSource()).that(component)
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class TestClass {",
+            "  @Qualifier @interface Q {}",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    A getA();",
+            "    @Q A qualifiedA();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(10);
+        .withErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@test.TestClass.Q test.TestClass.A "
+                + "cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(13);
   }
 
   @Test public void constructorInjectionWithoutAnnotation() {
@@ -190,36 +204,38 @@
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-
-        "  static class D {",
-        "    @Inject D(C cParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface DComponent {",
-        "    D getD();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(C cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
 
     String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
         + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
@@ -231,10 +247,234 @@
         + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
         + "          [parameter: test.Outer.C cParam]";
 
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(27);
+  }
+
+  @Test
+  public void cyclicDependencyNotBrokenByMapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MapKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Map<String, C> cMap) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides(type = Provides.Type.MAP)",
+            "    @StringKey(\"C\")",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "",
+            "  @MapKey",
+            "  @interface StringKey {",
+            "    String value();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(test.Outer.B bParam)",
+                "          [parameter: test.Outer.B bParam]",
+                "      test.Outer.B.<init>(test.Outer.A aParam)",
+                "          [parameter: test.Outer.A aParam]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.CModule.c(test.Outer.C c)",
+                "          [parameter: test.Outer.C c]");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(25);
+  }
+
+  @Test
+  public void falsePositiveCyclicDependencyIndirectionDetected() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(Provider<C> cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    String expectedError =
+        "test.Outer.DComponent.getD() contains a dependency cycle:\n"
+            + "      test.Outer.D.<init>(javax.inject.Provider<test.Outer.C> cParam)\n"
+            + "          [parameter: javax.inject.Provider<test.Outer.C> cParam]\n"
+            + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+            + "          [parameter: test.Outer.B bParam]\n"
+            + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+            + "          [parameter: test.Outer.A aParam]\n"
+            + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+            + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(26);
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(28);
+  }
+
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarning() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    /* String expectedWarning =
+     "test.Outer.CComponent.get() contains a dependency cycle:"
+     + "      test.Outer.C.<init>(javax.inject.Provider<test.Outer.A> aParam)"
+     + "          [parameter: javax.inject.Provider<test.Outer.A> aParam]"
+     + "      test.Outer.A.<init>(test.Outer.B bParam)"
+     + "          [parameter: test.Outer.B bParam]"
+     + "      test.Outer.B.<init>(test.Outer.C bParam, test.Outer.D dParam)"
+     + "          [parameter: test.Outer.C bParam]";
+     */
+    assertAbout(javaSource()) // TODO(cgruber): Implement warning checks.
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.withWarningContaining(expectedWarning).in(component).onLine(X);
+  }
+
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarningSuppressed() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"dependency-cycle\")",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.compilesWithoutWarning(); //TODO(cgruber)
   }
 
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
@@ -371,25 +611,106 @@
         "}");
 
     String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings:\n"
-            + "      Set bindings:\n"
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
             + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
     String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
-            + "      Map bindings:\n"
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
             + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(43)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(44);
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.Provides;",
+            "import java.util.HashMap;",
+            "import java.util.HashSet;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "import static dagger.Provides.Type.MAP;",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  static class TestModule1 {",
+            "    @Multibindings",
+            "    interface Empties {",
+            "      Map<String, String> stringMap();",
+            "      Set<String> stringSet();",
+            "    }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
+            + "          Set<String> test.Outer.TestModule1.Empties.stringSet()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
+            + "          Map<String,String> test.Outer.TestModule1.Empties.stringMap()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedSetError).in(component).onLine(43)
-        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(37)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(38);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -695,8 +1016,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -737,8 +1060,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -779,8 +1104,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -812,8 +1139,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
@@ -821,4 +1150,221 @@
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentShort.class)",
+        "interface ComponentShort {",
+        "}");
+    String errorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSource())
+        .that(shortLifetime)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentLong {",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "}");
+    String longErrorMessage =
+        "test.ComponentLong contains a cycle in its component dependencies:\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong";
+    String mediumErrorMessage =
+        "test.ComponentMedium contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium";
+    String shortErrorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSources())
+        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(longErrorMessage).in(longLifetime)
+        .and()
+        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
+        .and()
+        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+  }
+
+  @Test
+  @Ignore
+  public void subcomponentBindingConflictsWithParent() {
+    JavaFileObject parentChildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentChildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentChildConflict {}");
+    JavaFileObject parentGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentGrandchildConflict {}");
+    JavaFileObject childGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ChildGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ChildGrandchildConflict {}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = Parent.ParentModule.class)",
+            "interface Parent {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
+            "",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "",
+            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Grandchild.GrandchildModule.class)",
+            "interface Grandchild {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
+            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "",
+            "  @Module",
+            "  static class GrandchildModule {",
+            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentChildConflict,
+                parentGrandchildConflict,
+                childGrandchildConflict,
+                parent,
+                child,
+                grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@ParentChildConflict Object is rebound in test.Child:\n"
+                + "      @Provides @ParentChildConflict Object"
+                + " test.Parent.ParentModule.parentChildConflict()\n"
+                + "      @Provides @ParentChildConflict Object"
+                + " test.Child.ChildModule.parentChildConflict()\n")
+        .in(parent)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@ParentGrandchildConflict Object is rebound in test.Grandchild:\n"
+                + "      @Provides @ParentGrandchildConflict Object"
+                + " test.Parent.ParentModule.parentGrandchildConflict()\n"
+                + "      @Provides @ParentGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()\n")
+        .in(parent)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@ChildGrandchildConflict Object is rebound in test.Grandchild:\n"
+                + "      @Provides @ChildGrandchildConflict Object"
+                + " test.Child.ChildModule.childGrandchildConflict()\n"
+                + "      @Provides @ChildGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.childGrandchildConflict()\n")
+        .in(child)
+        .onLine(12);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
similarity index 65%
rename from compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
rename to compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index 40ceb7ede..5a1097968 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -7,12 +22,13 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
-public class PackageProxyTest {
-  @Test public void basicPackageProxy() {
+public class InaccessibleTypeTest {
+  @Test public void basicInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
         "",
@@ -62,7 +78,6 @@
         "test.DaggerTestComponent",
         "package test;",
         "",
-        "import foreign.DaggerTestComponent_PackageProxy;",
         "import foreign.NoDepClass_Factory;",
         "import foreign.NonPublicClass1_Factory;",
         "import foreign.NonPublicClass2_Factory;",
@@ -71,10 +86,12 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
+        "  @SuppressWarnings(\"rawtypes\")",
+        "  private Provider nonPublicClass1Provider;",
+        "  @SuppressWarnings(\"rawtypes\")",
+        "  private Provider nonPublicClass2Provider;",
         "  private Provider<PublicClass> publicClassProvider;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
@@ -90,14 +107,15 @@
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.foreign_Proxy.nonPublicClass1Provider =",
+        "    this.nonPublicClass1Provider =",
         "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.nonPublicClass2Provider =",
+        "    this.nonPublicClass2Provider =",
         "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
         "    this.publicClassProvider = PublicClass_Factory.create(",
-        "        foreign_Proxy.nonPublicClass1Provider,",
-        "        foreign_Proxy.nonPublicClass2Provider,",
+        "        nonPublicClass1Provider,",
+        "        nonPublicClass2Provider,",
         "        NoDepClass_Factory.create());",
         "  }",
         "",
@@ -115,19 +133,20 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
             publicClassFile,
             nonPublicClass1File,
             nonPublicClass2File,
             componentFile))
+        .withCompilerOptions("-Xlint:-processing", "-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
 
-  @Test public void memberInjectionPackageProxy() {
+  @Test public void memberInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
         "package test;",
         "",
@@ -184,63 +203,51 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import foreign.B;",
-        "import foreign.B_MembersInjector;",
-        "import foreign.C_MembersInjector;",
-        "import foreign.DaggerTestComponent_PackageProxy;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<D> dMembersInjector;",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
-        "  private MembersInjector<B> bMembersInjector;",
-        "  private MembersInjector<A> aMembersInjector;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.cMembersInjector =",
-        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
-        "    this.bMembersInjector = B_MembersInjector.create(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
-        "    this.aMembersInjector = A_MembersInjector.create(",
-        "        bMembersInjector, NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectA(A a) {",
-        "    aMembersInjector.injectMembers(a);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assert_().about(javaSources())
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<A> aMembersInjector;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectA(A a) {",
+            "    aMembersInjector.injectMembers(a);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
             aClassFile,
@@ -248,6 +255,7 @@
             cClassFile,
             dClassFile,
             componentFile))
+        .withCompilerOptions("-Xlint:-processing", "-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 6310b1d16..a4429453e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -37,6 +37,9 @@
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -133,7 +136,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
         "  private final Provider<T> tProvider;",
         "",
@@ -170,34 +173,37 @@
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
-        "",
-        "  public GenericClass_Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
-        "    return new GenericClass_Factory<A, B>(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
+            "",
+            "  public GenericClass_Factory(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    assert genericClassMembersInjector != null;",
+            "    this.genericClassMembersInjector = genericClassMembersInjector;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+            "    genericClassMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
+            "    return new GenericClass_Factory<A, B>(genericClassMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -220,7 +226,7 @@
         "import javax.annotation.Generated;",
         "",
         "@SuppressWarnings(\"rawtypes\")",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public enum GenericClass_Factory implements Factory<GenericClass> {",
         "  INSTANCE;",
         "",
@@ -257,7 +263,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
         "  private final Provider<B> bProvider;",
@@ -305,7 +311,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
@@ -365,7 +371,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aAndA2AndPaAndLaProvider;",
         "  private final Provider<A> qaProvider;",
@@ -517,7 +523,7 @@
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
   }
 
-  @Test public void privateInjectField() {
+  @Test public void privateInjectFieldError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
         "package test;",
         "",
@@ -531,6 +537,51 @@
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
+  
+  @Test public void privateInjectFieldWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectField {",
+        "  @Inject private String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
+  
+  @Test public void staticInjectFieldError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectField {",
+        "  @Inject static String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);
+  }
+  
+  @Test public void staticInjectFieldWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectField {",
+        "  @Inject static String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
 
   @Test public void multipleQualifiersOnField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierInjectField",
@@ -562,20 +613,65 @@
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
   }
 
-  @Test public void privateInjectMethod() {
+  @Test public void privateInjectMethodError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "",
         "class PrivateInjectMethod {",
-        "  @Inject private void method();",
+        "  @Inject private void method(){}",
         "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
+  
+  @Test public void privateInjectMethodWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectMethod {",
+        "  @Inject private void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
+  
+  @Test public void staticInjectMethodError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectMethod {",
+        "  @Inject static void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);
+  }
+  
+  @Test public void staticInjectMethodWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectMethod {",
+        "  @Inject static void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
 
   @Test public void genericInjectMethod() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericInjectMethod",
@@ -608,6 +704,102 @@
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
 
+  @Test public void injectConstructorDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(Produced<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectConstructorDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(Producer<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void injectFieldDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject Produced<String> str;",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectFieldDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject Producer<String> str;",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void injectMethodDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject void inject(Produced<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectMethodDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject void inject(Producer<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
   @Test public void injectConstructor() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
         "package test;",
@@ -625,7 +817,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -660,42 +852,44 @@
         "  @Inject AllInjections(String s) {}",
         "  @Inject void s(String s) {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.AllInjections_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class AllInjections_Factory ",
-        "    implements Factory<AllInjections> {",
-        "",
-        "  private final MembersInjector<AllInjections> membersInjector;",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections_Factory(MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public AllInjections get() {",
-        "    AllInjections instance = new AllInjections(sProvider.get());",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<AllInjections> create(",
-        "      MembersInjector<AllInjections> membersInjector, ",
-        "      Provider<String> sProvider) {",
-        "    return new AllInjections_Factory(membersInjector, sProvider);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.AllInjections_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class AllInjections_Factory ",
+            "    implements Factory<AllInjections> {",
+            "",
+            "  private final MembersInjector<AllInjections> allInjectionsMembersInjector;",
+            "  private final Provider<String> sProvider;",
+            "",
+            "  public AllInjections_Factory(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    assert allInjectionsMembersInjector != null;",
+            "    this.allInjectionsMembersInjector = allInjectionsMembersInjector;",
+            "    assert sProvider != null;",
+            "    this.sProvider = sProvider;",
+            "  }",
+            "",
+            "  @Override public AllInjections get() {",
+            "    AllInjections instance = new AllInjections(sProvider.get());",
+            "    allInjectionsMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<AllInjections> create(",
+            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
+            "      Provider<String> sProvider) {",
+            "    return new AllInjections_Factory(allInjectionsMembersInjector, sProvider);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -715,34 +909,35 @@
         "class B extends A {",
         "  @Inject B() {}",
         "}");
-    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
-        "test.B_Factory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_Factory implements Factory<B> {",
-        "",
-        "  private final MembersInjector<B> membersInjector;",
-        "",
-        "  public B_Factory(MembersInjector<B> membersInjector) {",
-        "    assert membersInjector != null;",
-        "    this.membersInjector = membersInjector;",
-        "  }",
-        "",
-        "  @Override public B get() {",
-        "    B instance = new B();",
-        "    membersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
-        "    return new B_Factory(membersInjector);",
-        "  }",
-        "}");
+    JavaFileObject expectedFactory =
+        JavaFileObjects.forSourceLines(
+            "test.B_Factory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class B_Factory implements Factory<B> {",
+            "",
+            "  private final MembersInjector<B> bMembersInjector;",
+            "",
+            "  public B_Factory(MembersInjector<B> bMembersInjector) {",
+            "    assert bMembersInjector != null;",
+            "    this.bMembersInjector = bMembersInjector;",
+            "  }",
+            "",
+            "  @Override public B get() {",
+            "    B instance = new B();",
+            "    bMembersInjector.injectMembers(instance);",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<B> create(MembersInjector<B> bMembersInjector) {",
+            "    return new B_Factory(bMembersInjector);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -758,7 +953,7 @@ public void wildcardDependency() {
         "import javax.inject.Inject;",
         "",
         "class InjectConstructor {",
-        "  @Inject InjectConstructor(List<? extends Object> objects) {}",
+        "  @Inject InjectConstructor(List<?> objects) {}",
         "}");
     JavaFileObject expected = JavaFileObjects.forSourceLines(
         "test.InjectConstructor_Factory",
@@ -769,13 +964,13 @@ public void wildcardDependency() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
-        "  private final Provider<List<? extends Object>> objectsProvider;",
+        "  private final Provider<List<?>> objectsProvider;",
         "",
-        "  public InjectConstructor_Factory(Provider<List<? extends Object>> objectsProvider) {",
+        "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
         "    assert objectsProvider != null;",
         "    this.objectsProvider = objectsProvider;",
         "  }",
@@ -785,7 +980,7 @@ public void wildcardDependency() {
         "  }",
         "",
         "  public static Factory<InjectConstructor> create(",
-        "      Provider<List<? extends Object>> objectsProvider) {",
+        "      Provider<List<?>> objectsProvider) {",
         "    return new InjectConstructor_Factory(objectsProvider);",
         "  }",
         "}");
@@ -817,7 +1012,7 @@ public void basicNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -869,7 +1064,7 @@ public void nestedNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.Outer;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -921,17 +1116,16 @@ public void samePackageNameCollision() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import other.pkg.CommonName;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
-        "  private final Provider<CommonName> otherPackageProvider;",
-        "  private final Provider<test.CommonName> samePackageProvider;",
+        "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
+        "  private final Provider<CommonName> samePackageProvider;",
         "",
-        "  public InjectConstructor_Factory(Provider<CommonName> otherPackageProvider,",
-        "      Provider<test.CommonName> samePackageProvider) {",
+        "  public InjectConstructor_Factory(Provider<other.pkg.CommonName> otherPackageProvider,",
+        "      Provider<CommonName> samePackageProvider) {",
         "    assert otherPackageProvider != null;",
         "    this.otherPackageProvider = otherPackageProvider;",
         "    assert samePackageProvider != null;",
@@ -943,8 +1137,8 @@ public void samePackageNameCollision() {
         "  }",
         "",
         "  public static Factory<InjectConstructor> create(",
-        "      Provider<CommonName> otherPackageProvider,",
-        "      Provider<test.CommonName> samePackageProvider) {",
+        "      Provider<other.pkg.CommonName> otherPackageProvider,",
+        "      Provider<CommonName> samePackageProvider) {",
         "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
         "  }",
         "}");
@@ -971,7 +1165,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public enum SimpleType_Factory implements Factory<SimpleType> {",
         "  INSTANCE;",
         "",
@@ -1015,16 +1209,16 @@ public void noDeps() {
         "",
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public enum OuterType$A_Factory implements Factory<A> {",
+        "",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public enum OuterType$A_Factory implements Factory<OuterType.A> {",
         "  INSTANCE;",
         "",
-        "  @Override public A get() {",
-        "    return new A();",
+        "  @Override public OuterType.A get() {",
+        "    return new OuterType.A();",
         "  }",
         "",
-        "  public static Factory<A> create() {",
+        "  public static Factory<OuterType.A> create() {",
         "    return INSTANCE;",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index cf5a94a2f..ab2212722 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -23,8 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class MapBindingComponentProcessorTest {
@@ -117,7 +118,7 @@ public void mapBindingsWithEnumKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
@@ -137,6 +138,7 @@ public void mapBindingsWithEnumKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -175,7 +177,7 @@ public void mapBindingsWithEnumKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -183,14 +185,14 @@ public void mapBindingsWithEnumKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -216,6 +218,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
@@ -232,6 +235,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
@@ -239,17 +243,6 @@ public void mapBindingsWithStringKey() {
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = true)",
-        "@Retention(RUNTIME)",
-        "public @interface StringKey {",
-        "  String value();",
-        "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
         "package test;",
         "",
@@ -285,7 +278,7 @@ public void mapBindingsWithStringKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
@@ -305,6 +298,7 @@ public void mapBindingsWithStringKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfStringAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -341,7 +335,7 @@ public void mapBindingsWithStringKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -349,17 +343,16 @@ public void mapBindingsWithStringKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            stringKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -384,7 +377,8 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @ClassKey(Integer.class) Handler provideAdminHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -400,11 +394,12 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @ClassKey(Long.class) Handler provideLoginHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject classKeyFile = JavaFileObjects.forSourceLines("test.ClassKey",
+    JavaFileObject wrappedClassKeyFile = JavaFileObjects.forSourceLines("test.WrappedClassKey",
         "package test;",
         "import dagger.MapKey;",
         "import java.lang.annotation.Retention;",
@@ -412,7 +407,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@MapKey(unwrapValue = false)",
         "@Retention(RUNTIME)",
-        "public @interface ClassKey {",
+        "public @interface WrappedClassKey {",
         "  Class<?> value();",
         "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
@@ -440,7 +435,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<ClassKey, Provider<Handler>> dispatcher();",
+        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
@@ -450,12 +445,12 @@ public void mapBindingsWithWrappedKey() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<ClassKey, Provider<Handler>>>",
-        "      mapOfClassKeyAndProviderOfHandlerProvider;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+        "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -470,23 +465,24 @@ public void mapBindingsWithWrappedKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution1 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution2 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution2 =",
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<ClassKey, Handler>builder(2)",
-        "            .put(ClassKeyCreator.createClassKey(Integer.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(ClassKeyCreator.createClassKey(Long.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
         "  @Override",
-        "  public Map<ClassKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfClassKeyAndProviderOfHandlerProvider.get();",
+        "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -508,7 +504,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -516,17 +512,17 @@ public void mapBindingsWithWrappedKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            classKeyFile,
+            wrappedClassKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -621,7 +617,7 @@ public void mapBindingsWithNonProviderValue() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
@@ -642,6 +638,7 @@ public void mapBindingsWithNonProviderValue() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -682,7 +679,7 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -690,14 +687,14 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -716,7 +713,6 @@ public void injectMapWithoutMapBinding() {
     JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
         "package test;",
         "",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import java.util.HashMap;",
@@ -735,7 +731,6 @@ public void injectMapWithoutMapBinding() {
         "",
         "import dagger.Component;",
         "import java.util.Map;",
-        "import javax.inject.Provider;",
         "",
         "@Component(modules = {MapModule.class})",
         "interface TestComponent {",
@@ -748,7 +743,7 @@ public void injectMapWithoutMapBinding() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Map<String, String>> provideAMapProvider;",
         "",
@@ -765,6 +760,7 @@ public void injectMapWithoutMapBinding() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
         "  }",
@@ -789,15 +785,123 @@ public void injectMapWithoutMapBinding() {
         "",
         "    public Builder mapModule(MapModule mapModule) {",
         "      if (mapModule == null) {",
-        "        throw new NullPointerException(\"mapModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModule = mapModule;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
         .processedWith(new ComponentProcessor()).compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test
+  public void mapBindingsWithDuplicateKeys() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "    return \"one again\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("The same map key is bound more than once")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForAKeyAgain()")
+        .and()
+        .withErrorCount(1);
+  }
+
+  @Test
+  public void mapBindingsWithInconsistentKeyAnnotations() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "    return \"two\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyTwoFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKeyTwo",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey(unwrapValue = true)",
+            "public @interface StringKeyTwo {",
+            "  String value();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("uses more than one @MapKey annotation type")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForBKey()")
+        .and()
+        .withErrorCount(1);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 531ae722b..98e88ca99 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -23,8 +23,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class MapKeyProcessorTest {
@@ -49,26 +51,27 @@ public void mapKeyCreatorFile() {
         "    ADMIN,",
         "    LOGIN;",
         "}");
-    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class PathKeyCreator {",
-        "  @com.google.auto.value.AutoAnnotation",
-        "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
-        "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
-        "  }",
-        "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines(
+            "test.PathKeyCreator",
+            "package test;",
+            "",
+            "import com.google.auto.value.AutoAnnotation;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class PathKeyCreator {",
+            "  @AutoAnnotation",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -95,28 +98,28 @@ public void nestedMapKeyCreatorFile() {
         "    LOGIN;",
         "}");
     JavaFileObject generatedKeyCreator =
-        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+        JavaFileObjects.forSourceLines(
+            "test.Container$PathKeyCreator",
             "package test;",
             "",
+            "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
-            "import test.Container.PathKey",
             "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class Container$PathKeyCreator {",
-            "  @com.google.auto.value.AutoAnnotation",
-            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "  @AutoAnnotation",
+            "  public static Container.PathKey createPathKey("
+                + "PathEnum value, String relativePath) {",
             "    return new AutoAnnotation_Container$PathKeyCreator_createPathKey(",
             "        value, relativePath);",
             "  }",
             "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -205,7 +208,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
@@ -225,6 +228,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -263,7 +267,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -271,23 +275,24 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -379,7 +384,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
@@ -399,6 +404,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -437,7 +443,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -445,23 +451,24 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 25762ea94..ccc2f97bb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -15,8 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,6 +33,9 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
 public class MembersInjectionTest {
@@ -57,12 +68,11 @@ public void parentClass_noInjectedMembers() {
         "test.DaggerTestComponent",
         "package test;",
         "",
-        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Child> childProvider;",
         "",
@@ -79,9 +89,10 @@ public void parentClass_noInjectedMembers() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.childProvider =",
-        "        Child_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "        Child_Factory.create(MembersInjectors.<Child>noOp());",
         "  }",
         "",
         "  @Override",
@@ -141,59 +152,58 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<Parent> parentMembersInjector;",
-        "  private MembersInjector<Child> childMembersInjector;",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
-        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = Child_Factory.create(childMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<Child> childMembersInjector;",
+            "  private Provider<Child> childProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
+            "    this.childProvider = Child_Factory.create(childMembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return childProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void fieldAndMethodGenerics() {
@@ -209,14 +219,15 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -229,24 +240,36 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.bProvider = bProvider;",
         "  }",
         "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
         "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get())",
+        "    instance.register(bProvider.get());",
         "  }",
         "",
-        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
         "  }",
+        "",
+        "  public static <A, B> void injectRegister(",
+        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
+        "    instance.register(bProvider.get());",
+        "  }",
+        "",
         "}");
-    assertAbout(javaSource()).that(file)
+    assertAbout(javaSource())
+        .that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void subclassedGenericMembersInjectors() {
@@ -289,51 +312,62 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.Child_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
-        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<T> tProvider;",
+        "  private final Provider<T> tAndXProvider;",
+        "  private final Provider<A> aAndYProvider;",
+        "  private final Provider<A2> a2Provider;",
         "",
         "  public Child_MembersInjector(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    assert tAndXProvider != null;",
+        "    this.tAndXProvider = tAndXProvider;",
+        "    assert aAndYProvider != null;",
+        "    this.aAndYProvider = aAndYProvider;",
+        "    assert a2Provider != null;",
+        "    this.a2Provider = a2Provider;",
+        "  }",
+        "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
         "  }",
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
+        "    ((Parent) instance).x = tAndXProvider.get();",
+        "    ((Parent) instance).y = aAndYProvider.get();",
+        "    ((Parent) instance).a2 = a2Provider.get();",
+        "    instance.a = aAndYProvider.get();",
+        "    instance.t = tAndXProvider.get();",
+        "  }",
+        "",
+        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
         "    instance.a = aProvider.get();",
-        "    instance.t = tProvider.get();",
         "  }",
         "",
-        "  public static <T> MembersInjector<Child<T>> create(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
+        "    instance.t = tProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(a, a2, parent, child))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void fieldInjection() {
@@ -349,7 +383,8 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.FieldInjection_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -357,10 +392,9 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection_MembersInjector ",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
-        "",
         "  private final Provider<String> stringProvider;",
         "",
         "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
@@ -368,7 +402,12 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+        "    return new FieldInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -377,14 +416,27 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new FieldInjection_MembersInjector(stringProvider);",
+        "  public static void injectString(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectLazyString(",
+        "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+        "    instance.lazyString = DoubleCheckLazy.create(lazyStringProvider);",
+        "  }",
+        "",
+        "  public static void injectStringProvider(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.stringProvider = stringProvider;",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void methodInjection() {
@@ -410,9 +462,9 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection_MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public final class MethodInjection_MembersInjector",
+        "     implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
@@ -421,7 +473,13 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -431,18 +489,38 @@ public void parentClass_injectedMembersInSupertype() {
         "        stringProvider);",
         "  }",
         "",
-        "  public static MembersInjector<MethodInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new MethodInjection_MembersInjector(stringProvider);",
+        "  public static void injectNoArgs(MethodInjection instance) {",
+        "    instance.noArgs();",
+        "  }",
+        "",
+        "  public static void injectOneArg(",
+        "      MethodInjection instance, Provider<String> stringProvider) {",
+        "    instance.oneArg(stringProvider.get());",
+        "  }",
+        "",
+        "  public static void injectManyArgs(",
+        "      MethodInjection instance,",
+        "      Provider<String> stringProvider,",
+        "      Provider<String> lazyStringProvider,",
+        "      Provider<String> stringProvider2) {",
+        "    instance.manyArgs(",
+        "        stringProvider.get(),",
+        "        DoubleCheckLazy.create(lazyStringProvider),",
+        "        stringProvider2);",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+  @Test
+  public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -463,14 +541,15 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection_MembersInjector ",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
         "  private final Provider<String> stringAndSProvider;",
         "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
+        "  public MixedMemberInjection_MembersInjector(",
+        "      Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
@@ -478,7 +557,15 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection_MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -488,16 +575,32 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
         "",
-        "  public static MembersInjector<MixedMemberInjection> create(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    return new MixedMemberInjection_MembersInjector(",
-        "        stringAndSProvider, objectAndOProvider);",
+        "  public static void injectString(",
+        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectObject(",
+        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
+        "    instance.object = objectProvider.get();",
+        "  }",
+        "",
+        "  public static void injectSetString(",
+        "      MixedMemberInjection instance, Provider<String> sProvider) {",
+        "    instance.setString(sProvider.get());",
+        "  }",
+        "",
+        "  public static void injectSetObject(",
+        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
+        "    instance.setObject(oProvider.get());",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void injectConstructorAndMembersInjection() {
@@ -519,7 +622,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -530,7 +633,12 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(AllInjections instance) {",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -538,11 +646,13 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.s(sProvider.get());",
         "  }",
         "",
-        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "    return new AllInjections_MembersInjector(sProvider);",
+        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedMembersInjector);
@@ -569,94 +679,345 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
+        GENERATED_ANNOTATION_JAVAPOET,
+        "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
-        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
+        "  public B_MembersInjector(Provider<String> sProvider) {",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(B instance) {",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(",
-        "      MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    return new B_MembersInjector(supertypeInjector, sProvider);",
+        "  public static void injectS(B instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
-  @Test public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterType {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
-        "}");
+  @Test
+  public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
+          "test.OuterType",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import javax.inject.Inject;",
+          "",
+          "final class OuterType {",
+          "  static class A {",
+          "    @Inject A() {}",
+          "  }",
+          "  static class B {",
+          "    @Inject A a;",
+          "  }",
+          "  @Component interface SimpleComponent {",
+          "    A a();",
+          "    void inject(B b);",
+          "  }",
+          "}");
     JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-        "    return new OuterType$B_MembersInjector(aProvider);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+          "test.OuterType$B_MembersInjector",
+          "package test;",
+          "",
+          "import dagger.MembersInjector;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "",
+          GENERATED_ANNOTATION_JAVAPOET,
+          "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
+          "  private final Provider<OuterType.A> aProvider;",
+          "",
+          "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
+          "    assert aProvider != null;",
+          "    this.aProvider = aProvider;",
+          "  }",
+          "",
+          "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  @Override",
+          "  public void injectMembers(OuterType.B instance) {",
+          "    if (instance == null) {",
+          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+          "    }",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "",
+          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(bMembersInjector);
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void componentWithNestingAndGeneratedType() {
+    JavaFileObject nestedTypesFile =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "",
+            "final class OuterType {",
+            "  @Inject GeneratedType generated;",
+            "  static class A {",
+            "    @Inject A() {}",
+            "  }",
+            "  static class B {",
+            "    @Inject A a;",
+            "  }",
+            "  @Component interface SimpleComponent {",
+            "    A a();",
+            "    void inject(B b);",
+            "  }",
+            "}");
+    JavaFileObject bMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType$B_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
+            "  private final Provider<OuterType.A> aProvider;",
+            "",
+            "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+            "    return new OuterType$B_MembersInjector(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(OuterType.B instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "",
+            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(nestedTypesFile)
+        .processedWith(
+            new ComponentProcessor(),
+            new AbstractProcessor() {
+              private boolean done;
+
+              @Override
+              public Set<String> getSupportedAnnotationTypes() {
+                return ImmutableSet.of("*");
+              }
+
+              @Override
+              public boolean process(
+                  Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+                if (!done) {
+                  done = true;
+                  try (Writer writer =
+                          processingEnv
+                              .getFiler()
+                              .createSourceFile("test.GeneratedType")
+                              .openWriter()) {
+                    writer.write(
+                        Joiner.on('\n')
+                            .join(
+                                "package test;",
+                                "",
+                                "import javax.inject.Inject;",
+                                "",
+                                "class GeneratedType {",
+                                "  @Inject GeneratedType() {}",
+                                "}"));
+                  } catch (IOException e) {
+                    throw new RuntimeException(e);
+                  }
+                }
+                return false;
+              }
+            })
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void lowerCaseNamedMembersInjector_forLowerCaseType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class foo {",
+            "  @Inject String string;",
+            "}");
+    JavaFileObject fooModule =
+        JavaFileObjects.forSourceLines(
+            "test.fooModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class fooModule {",
+            "  @Provides String string() { return \"foo\"; }",
+            "}");
+    JavaFileObject fooComponent =
+        JavaFileObjects.forSourceLines(
+            "test.fooComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = fooModule.class)",
+            "interface fooComponent {",
+            "  void inject(foo target);",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(foo, fooModule, fooComponent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+  }
+
+  @Test
+  public void fieldInjectionForShadowedMember() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Parent { ",
+            "  @Inject Foo object;",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Child extends Parent { ",
+            "  @Inject Bar object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C { ",
+            "  void inject(Child child);",
+            "}");
+
+    JavaFileObject expectedMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.Child_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class Child_MembersInjector implements MembersInjector<Child> {",
+            "  private final Provider<Foo> objectProvider;",
+            "  private final Provider<Bar> objectProvider2;",
+            "",
+            "  public Child_MembersInjector(",
+            "        Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
+            "    assert objectProvider != null;",
+            "    this.objectProvider = objectProvider;",
+            "    assert objectProvider2 != null;",
+            "    this.objectProvider2 = objectProvider2;",
+            "  }",
+            "",
+            "  public static MembersInjector<Child> create(",
+            "      Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
+            "    return new Child_MembersInjector(objectProvider, objectProvider2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(Child instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(",
+            "          \"Cannot inject members into a null reference\");",
+            "    }",
+            "    ((Parent) instance).object = objectProvider.get();",
+            "    instance.object = objectProvider2.get();",
+            "  }",
+            "",
+            "  public static void injectObject(Child instance, Provider<Bar> objectProvider) {",
+            "    instance.object = objectProvider.get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(foo, bar, parent, child, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
index 0ae01b40c..03ec35d9b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -15,17 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 1eeda25e3..cd44b97e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.Provides;
 import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -36,7 +37,9 @@
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -322,11 +325,13 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
-    assertAbout(javaSources()).that(ImmutableList.of(module))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-            "java.lang.Void", "Module"));
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
 
   @Test public void referencedModulesMustNotBeAbstract() {
@@ -370,7 +375,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -416,7 +421,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -457,7 +462,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -541,7 +546,7 @@ private String formatModuleErrorMessage(String msg) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -612,7 +617,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -663,7 +668,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideWildcardListFactory implements "
             + "Factory<Set<List<List<?>>>> {",
         "  private final TestModule module;",
@@ -710,7 +715,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -762,6 +767,39 @@ private String formatModuleErrorMessage(String msg) {
         .in(moduleFile).onLine(12);
   }
 
+  @Test
+  public void providesMethodThrowsChecked() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides int i() throws Exception {",
+            "    return 0;",
+            "  }",
+            "",
+            "  @Provides String s() throws Throwable {",
+            "    return \"\";",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .in(moduleFile)
+        .onLine(8)
+        .and()
+        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .in(moduleFile)
+        .onLine(12);
+  }
+
   @Test
   public void providedTypes() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
@@ -893,24 +931,38 @@ public void publicModuleNonPublicIncludes() {
 
   @Test
   public void genericSubclassedModule() {
-    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.util.List;",
-        "import java.util.ArrayList;",
-        "",
-        "@Module",
-        "abstract class ParentModule<A extends CharSequence,",
-        "                            B,",
-        "                            C extends Number & Comparable<C>> {",
-        "  @Provides List<B> provideListB(B b) {",
-        "    List<B> list = new ArrayList<B>();",
-        "    list.add(b);",
-        "    return list;",
-        "  }",
-        "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "import java.util.List;",
+            "import java.util.ArrayList;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "@Module",
+            "abstract class ParentModule<A extends CharSequence,",
+            "                            B,",
+            "                            C extends Number & Comparable<C>> {",
+            "  @Provides List<B> provideListB(B b) {",
+            "    List<B> list = new ArrayList<B>();",
+            "    list.add(b);",
+            "    return list;",
+            "  }",
+            "",
+            "  @Provides(type = SET) B provideBElement(B b) {",
+            "    return b;",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"b\") B provideBEntry(B b) {",
+            "    return b;",
+            "  }",
+            "}");
     JavaFileObject numberChild = JavaFileObjects.forSourceLines("test.ChildNumberModule",
         "package test;",
         "",
@@ -942,43 +994,116 @@ public void genericSubclassedModule() {
         "  List<Number> numberList();",
         "  List<Integer> integerList();",
         "}");
-    JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
-        "test.ParentModule_ProvidesListBFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
-        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
-        "  private final ParentModule<A, B, C> module;",
-        "  private final Provider<B> bProvider;",
-        "",
-        "  public ParentModule_ProvideListBFactory(",
-        "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public List<B> get() {  ",
-        "    List<B> provided = module.provideListB(bProvider.get());",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
-        "  }",
-        "",
-        "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
-        "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
-        "  }",
-        "}");
+    JavaFileObject listBFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideListBFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideListBFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public List<B> get() {  ",
+            "    List<B> provided = module.provideListB(bProvider.get());",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
+    JavaFileObject bElementFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideBElementFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideBElementFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<B> get() {  ",
+            "    return Collections.<B>singleton(module.provideBElement(bProvider.get()));",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<Set<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
+    JavaFileObject bEntryFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule_ProvideBEntryFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class ParentModule_ProvideBEntryFactory<A extends CharSequence,",
+            "    B, C extends Number & Comparable<C>> implements Factory<B>> {",
+            "  private final ParentModule<A, B, C> module;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public ParentModule_ProvideBEntryFactory(",
+            "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public B get() {  ",
+            "    B provided = module.provideBEntry(bProvider.get());",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "    return new ParentModule_ProvideBEntryFactory<A, B, C>(module, bProvider);",
+            "  }",
+            "}");
     JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
         "test.ChildNumberModule_ProvideNumberFactory",
         "package test;",
@@ -986,7 +1111,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
         "  private final ChildNumberModule module;",
         "",
@@ -1015,7 +1140,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class ChildIntegerModule_ProvideIntegerFactory",
         "    implements Factory<Integer> {",
         "  private final ChildIntegerModule module;",
@@ -1038,10 +1163,103 @@ public void genericSubclassedModule() {
         "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, numberChild, integerChild, component))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(listBFactory, numberFactory, integerFactory);
+        .and()
+        .generatesSources(
+            listBFactory, bElementFactory, bEntryFactory, numberFactory, integerFactory);
+  }
+
+  @Test public void parameterizedModuleWithStaticProvidesMethodOfGenericType() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.List;",
+            "import java.util.ArrayList;",
+            "import java.util.Map;",
+            "import java.util.HashMap;",
+            "",
+            "@Module abstract class ParameterizedModule<T> {",
+            "  @Provides List<T> provideListT() {",
+            "    return new ArrayList<>();",
+            "  }",
+            "",
+            "  @Provides static Map<String, Number> provideMapStringNumber() {",
+            "    return new HashMap<>();",
+            "  }",
+            "",
+            "  @Provides static Object provideNonGenericType() {",
+            "    return new Object();",
+            "  }",
+            "}");
+
+    JavaFileObject provideMapStringNumberFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideMapStringNumberFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "    implements Factory<Map<String, Number>> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Map<String, Number> get() {",
+            "    Map<String, Number> provided = ParameterizedModule.provideMapStringNumber();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Map<String, Number>> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    JavaFileObject provideNonGenericTypeFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "    implements Factory<Object> {",
+            "  INSTANCE;",
+            "",
+            "  @Override",
+            "  public Object get() {",
+            "    Object provided = ParameterizedModule.provideNonGenericType();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(" + NPE_LITERAL + ");",
+            "    }",
+            "    return provided;",
+            "  }",
+            "",
+            "  public static Factory<Object> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
   }
 
   @Test public void providesMethodMultipleQualifiers() {
@@ -1065,4 +1283,44 @@ public void genericSubclassedModule() {
         .failsToCompile()
         .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
   }
+
+  @Test public void providerDependsOnProduced() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Producer;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(Producer<Integer> producer) {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void providerDependsOnProducer() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Produced;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(Produced<Integer> produced) {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
new file mode 100644
index 000000000..9ec7469a5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class MultibindingsValidatorTest {
+
+  private static final JavaFileObject SOME_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.SomeQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface SomeQualifier {}");
+
+  private static final JavaFileObject OTHER_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.OtherQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface OtherQualifier {}");
+
+  @Test
+  public void abstractClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static abstract class Empties {",
+            "    abstract Set<Object> emptySet();",
+            "    @SomeQualifier abstract Set<Object> emptyQualifiedSet();",
+            "    abstract Map<String, Object> emptyMap();",
+            "    @SomeQualifier abstract Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void concreteClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static class Empties {",
+            "    Set<Object> emptySet() { return null; }",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet() { return null; }",
+            "    Map<String, Object> emptyMap() { return null; }",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap() { return null; }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void interfaceHasTypeParameters() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties<T> {",
+            "    Set<T> emptySet();",
+            "    @SomeQualifier Set<T> emptyQualifiedSet();",
+            "    Map<String, T> emptyMap();",
+            "    @SomeQualifier Map<String, T> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings types must not have type parameters")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void topLevel() {
+    JavaFileObject testInterface =
+        JavaFileObjects.forSourceLines(
+            "test.TestInterface",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Multibindings",
+            "interface Empties {",
+            "  Set<Object> emptySet();",
+            "  @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "  Map<String, Object> emptyMap();",
+            "  @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testInterface, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testInterface)
+        .onLine(8);
+  }
+
+  @Test
+  public void notWithinModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    Set<Object> emptySet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    Map<String, Object> emptyMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testModule)
+        .onLine(9);
+  }
+
+  @Test
+  public void badMethods() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    void voidMethod();",
+            "    int primitive();",
+            "    Map rawMap();",
+            "    Map<?, ?> wildcardMap();",
+            "    Map<String, Provider<Object>> providerMap();",
+            "    Map<String, Producer<Object>> producerMap();",
+            "    Map<String, Produced<Object>> producedMap();",
+            "    Set rawSet();",
+            "    Set<?> wildcardSet();",
+            "    Set<Provider<Object>> providerSet();",
+            "    Set<Producer<Object>> producerSet();",
+            "    Set<Produced<Object>> producedSet();",
+            "    @SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();",
+            "    @SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(15)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(16)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(19)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(20)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(21)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(22)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(24)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(25)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(26)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(27)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(28);
+  }
+
+  @Test
+  public void badMethodsOnSupertype() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  interface BaseEmpties {",
+            "    void voidMethod();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface Empties extends BaseEmpties {}",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.TestModule.BaseEmpties.voidMethod()] "
+                + "@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18);
+  }
+
+  @Test
+  public void duplicateKeys() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface EmptySets {",
+            "    Set<Object> emptySet();",
+            "    Set<Object> emptySet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedSets {",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyMaps {",
+            "    Map<String, Object> emptyMap();",
+            "    Map<String, Object> emptyMap2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedMaps {",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap2();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Too many @Multibindings methods for Set<Object>:")
+        .in(testModule)
+        .onLine(11)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for @test.SomeQualifier Set<Object>:")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining(
+            "Too many @Multibindings methods for @test.SomeQualifier Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(29);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 9e209bb00..41fae8ad1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -35,7 +36,9 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -338,6 +341,32 @@ private String formatModuleErrorMessage(String msg) {
         .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
   }
 
+  @Test
+  public void producesMethodThrowsThrowable() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces int produceInt() throws Throwable {",
+            "    return 0;",
+            "  }",
+            "",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_THROWS)
+        .in(moduleFile)
+        .onLine(8);
+  }
+
   @Test
   public void privateModule() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
@@ -378,6 +407,31 @@ public void enclosedInPrivateModule() {
         .in(moduleFile).onLine(7);
   }
 
+  @Test
+  public void includesNonModule() {
+    JavaFileObject xFile =
+        JavaFileObjects.forSourceLines("test.X", "package test;", "", "public final class X {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "",
+            "@ProducerModule(includes = X.class)",
+            "public final class FooModule {",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(xFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+                "X",
+                "one of @Module, @ProducerModule"));
+  }
+
   @Test
   public void publicModuleNonPublicIncludes() {
     JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
@@ -440,699 +494,65 @@ public void publicModuleNonPublicIncludes() {
         "    return null;",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.collect.ImmutableSet;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<Set<String>> future =",
-        "        Producers.submitToExecutor(new Callable<Set<String>>() {",
-        "      @Override public Set<String> call() {",
-        "        return ImmutableSet.of(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return Futures.immediateFuture(module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider));",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodSingleArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(int a) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    return Futures.transform(aProducerFuture,",
-        "        new AsyncFunction<Integer, String>() {",
-        "          @Override public ListenableFuture<String> apply(Integer a) {",
-        "            return module.produceString(a);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedException() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString()",
-        "      throws InterruptedException, IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call()",
-        "            throws InterruptedException, IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() throws IOException {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() throws IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
-        "          throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args)",
-        "              throws IOException {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerMonitor;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "  private final TestModule module;",
+            "  private final Executor executor;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Executor executor,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executor != null;",
+            "    this.executor = executor;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute(",
+            "      final ProducerMonitor monitor) {",
+            "    return Futures.transformAsync(",
+            "      Futures.<Void>immediateFuture(null),",
+            "      new AsyncFunction<Void, String>() {",
+            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "          monitor.methodStarting();",
+            "          try {",
+            "            return module.produceString();",
+            "          } finally {",
+            "            monitor.methodFinished();",
+            "          }",
+            "        }",
+            "      }, executor);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(factoryFile);
+        .and()
+        .generatesSources(factoryFile);
   }
 
   private static final JavaFileObject QUALIFIER_A =
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index b5ebd972b..1437e6f8a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -23,6 +23,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProductionComponentProcessorTest {
@@ -78,10 +79,11 @@
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is not annotated with @Module or @ProducerModule");
+        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test public void simpleComponent() {
@@ -123,94 +125,136 @@
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestClass_SimpleComponent",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.TestClass.A;",
-        "import test.TestClass.AModule;",
-        "import test.TestClass.B;",
-        "import test.TestClass.BModule;",
-        "import test.TestClass.SimpleComponent;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Producer<A> aProducer;",
-        "",
-        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestClass$BModule_BFactory.create(",
-        "        builder.bModule, TestClass$C_Factory.create());",
-        "    this.aProducer = new TestClass$AModule_AFactory(",
-        "        builder.aModule, builder.executor, Producers.producerFromProvider(bProvider));",
-        "  }",
-        "",
-        "  @Override",
-        "  public ListenableFuture<A> a() {",
-        "    return aProducer.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AModule aModule;",
-        "    private BModule bModule;",
-        "    private Executor executor;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      if (aModule == null) {",
-        "        this.aModule = new AModule();",
-        "      }",
-        "      if (bModule == null) {",
-        "        this.bModule = new BModule();",
-        "      }",
-        "      if (executor == null) {",
-        "        throw new IllegalStateException(\"executor must be set\");",
-        "      }",
-        "      return new DaggerTestClass_SimpleComponent(this);",
-        "    }",
-        "",
-        "    public Builder aModule(AModule aModule) {",
-        "      if (aModule == null) {",
-        "        throw new NullPointerException(\"aModule\");",
-        "      }",
-        "      this.aModule = aModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder bModule(BModule bModule) {",
-        "      if (bModule == null) {",
-        "        throw new NullPointerException(\"bModule\");",
-        "      }",
-        "      this.bModule = bModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder executor(Executor executor) {",
-        "      if (executor == null) {",
-        "        throw new NullPointerException(\"executor\");",
-        "      }",
-        "      this.executor = executor;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestClass_SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor.Factory;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.TestClass.A;",
+            "import test.TestClass.AModule;",
+            "import test.TestClass.B;",
+            "import test.TestClass.BModule;",
+            "import test.TestClass.SimpleComponent;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
+            "  private Provider<Set<Factory>> setOfFactoryProvider;",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
+            "  private Provider<B> bProvider;",
+            "  private Producer<A> aProducer;",
+            "",
+            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.setOfFactoryContribution1Provider =",
+            "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
+            "            .create();",
+            "    this.setOfFactoryProvider = SetFactory.create(setOfFactoryContribution1Provider);",
+            "    this.monitorProvider =",
+            "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
+            "            builder.testClass$SimpleComponent_MonitoringModule,",
+            "            simpleComponentProvider,",
+            "            setOfFactoryProvider);",
+            "    this.bProvider = TestClass$BModule_BFactory.create(",
+            "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.aProducer = new TestClass$AModule_AFactory(",
+            "        builder.aModule,",
+            "        builder.executor,",
+            "        monitorProvider,",
+            "        Producers.producerFromProvider(bProvider));",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<A> a() {",
+            "    return aProducer.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule;",
+            "    private BModule bModule;",
+            "    private AModule aModule;",
+            "    private Executor executor;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        this.testClass$SimpleComponent_MonitoringModule =",
+            "            new TestClass$SimpleComponent_MonitoringModule();",
+            "      }",
+            "      if (bModule == null) {",
+            "        this.bModule = new BModule();",
+            "      }",
+            "      if (aModule == null) {",
+            "        this.aModule = new AModule();",
+            "      }",
+            "      if (executor == null) {",
+            "        throw new IllegalStateException(Executor.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerTestClass_SimpleComponent(this);",
+            "    }",
+            "",
+            "    public Builder aModule(AModule aModule) {",
+            "      if (aModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.aModule = aModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder bModule(BModule bModule) {",
+            "      if (bModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.bModule = bModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder testClass$SimpleComponent_MonitoringModule(",
+            "        TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule) {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.testClass$SimpleComponent_MonitoringModule =",
+            "          testClass$SimpleComponent_MonitoringModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder executor(Executor executor) {",
+            "      if (executor == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.executor = executor;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 9f577b722..6fc871684 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -161,4 +161,110 @@
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
+
+  @Test
+  public void monitoringDependsOnUnboundType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET)",
+            "    ProductionComponentMonitor.Factory monitorFactory(A unbound) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(33);
+  }
+
+  @Test
+  public void monitoringDependsOnProduction() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET) ProductionComponentMonitor.Factory monitorFactory(A a) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces A a() {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory> is a"
+            + " provision, which cannot depend on a production.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(36);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
new file mode 100644
index 000000000..6bf0c9ee0
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -0,0 +1,121 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class RepeatedModuleValidationTest {
+  private static final JavaFileObject MODULE_FILE =
+      JavaFileObjects.forSourceLines(
+          "test.TestModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module",
+          "final class TestModule {}");
+
+  @Test
+  public void moduleRepeatedInSubcomponentFactoryMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent(TestModule module);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is present in test.TestComponent.")
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(51);
+  }
+
+  @Test
+  public void moduleRepeatedInSubcomponentBuilderMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder testModule(TestModule testModule);",
+            "    TestSubcomponent build();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    // TODO(gak): assert about the warning when we have that ability
+  }
+
+  @Test
+  public void moduleRepeatedButNotPassed() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 91035b291..76287e946 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -24,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public final class SubcomponentValidationTest {
@@ -43,15 +44,26 @@
         "import dagger.Subcomponent;",
         "",
         "@Subcomponent(modules = ModuleWithParameters.class)",
-        "interface ChildComponent {}");
+        "interface ChildComponent {",
+        "  Object object();",
+        "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
         "package test;",
         "",
         "import dagger.Module;",
+        "import dagger.Provides;",
         "",
         "@Module",
         "final class ModuleWithParameters {",
-        "  ModuleWithParameters(Object whatever) {}",
+        "  private final Object object;",
+        "",
+        "  ModuleWithParameters(Object object) {",
+        "    this.object = object;",
+        "  }",
+        "",
+        "  @Provides Object object() {",
+        "    return object;",
+        "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
         .processedWith(new ComponentProcessor())
@@ -244,4 +256,567 @@
         .failsToCompile()
         .withErrorContaining("@Singleton");
   }
+
+  @Test
+  public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {
+    JavaFileObject parentComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent childComponent();",
+            "  Dep1 getDep1();",
+            "  Dep2 getDep2();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface ChildComponent {",
+            "  Object getObject();",
+            "}");
+    JavaFileObject childModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class ChildModule {",
+            "  @Provides Object provideObject(A a) { return null; }",
+            "}");
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject public A(NeedsDep1 a, Dep1 b, Dep2 c) { }",
+            "  @Inject public void methodA() { }",
+            "}");
+    JavaFileObject needsDep1File =
+        JavaFileObjects.forSourceLines(
+            "test.NeedsDep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class NeedsDep1 {",
+            "  @Inject public NeedsDep1(Dep1 d) { }",
+            "}");
+    JavaFileObject dep1File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep1 {",
+            "  @Inject public Dep1() { }",
+            "  @Inject public void dep1Method() { }",
+            "}");
+    JavaFileObject dep2File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep2",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep2 {",
+            "  @Inject public Dep2() { }",
+            "  @Inject public void dep2Method() { }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private MembersInjector<Dep1> dep1MembersInjector;",
+            "  private Provider<Dep1> dep1Provider;",
+            "  private MembersInjector<Dep2> dep2MembersInjector;",
+            "  private Provider<Dep2> dep2Provider;",
+            "",
+            "  private DaggerParentComponent(Builder builder) {  ",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {  ",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {  ",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {  ",
+            "    this.dep1MembersInjector = Dep1_MembersInjector.create();",
+            "    this.dep1Provider = Dep1_Factory.create(dep1MembersInjector);",
+            "    this.dep2MembersInjector = Dep2_MembersInjector.create();",
+            "    this.dep2Provider = Dep2_Factory.create(dep2MembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep1 getDep1() {  ",
+            "    return dep1Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep2 getDep2() {  ",
+            "    return dep2Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ChildComponent childComponent() {  ",
+            "    return new ChildComponentImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {  ",
+            "    }",
+            "  ",
+            "    public ParentComponent build() {  ",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildComponentImpl implements ChildComponent {",
+            "    private final ChildModule childModule;",
+            "    private MembersInjector<A> aMembersInjector;",
+            "    private Provider<NeedsDep1> needsDep1Provider;",
+            "    private Provider<A> aProvider;",
+            "    private Provider<Object> provideObjectProvider;",
+            "  ",
+            "    private ChildComponentImpl() {  ",
+            "      this.childModule = new ChildModule();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {  ",
+            "      this.aMembersInjector = A_MembersInjector.create();",
+            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
+            "          DaggerParentComponent.this.dep1Provider);",
+            "      this.aProvider = A_Factory.create(",
+            "          aMembersInjector,",
+            "          needsDep1Provider,",
+            "          DaggerParentComponent.this.dep1Provider,",
+            "          DaggerParentComponent.this.dep2Provider);",
+            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
+            "          childModule, aProvider);",
+            "    }",
+            "  ",
+            "    @Override",
+            "    public Object getObject() {  ",
+            "      return provideObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentComponentFile,
+                childComponentFile,
+                childModuleFile,
+                aFile,
+                needsDep1File,
+                dep1File,
+                dep2File))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Foo.Sub newFooSubcomponent();",
+            "  NoConflict newNoConflictSubcomponent();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface Sub {",
+            "    Bar.Sub newBarSubcomponent();",
+            "  }",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Bar {",
+            "  @Subcomponent interface Sub {",
+            "    test.subpackage.Sub newSubcomponentInSubpackage();",
+            "  }",
+            "}");
+    JavaFileObject baz =
+        JavaFileObjects.forSourceLines(
+            "test.subpackage.Sub",
+            "package test.subpackage;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+    JavaFileObject noConflict =
+        JavaFileObjects.forSourceLines(
+            "test.NoConflict",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface NoConflict {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Bar.Sub;",
+            "import test.Foo;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Foo.Sub newFooSubcomponent() {",
+            "    return new Foo_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public NoConflict newNoConflictSubcomponent() {",
+            "    return new NoConflictImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_SubImpl implements Foo.Sub {",
+            "",
+            "    @Override",
+            "    public Sub newBarSubcomponent() {",
+            "      return new Bar_SubImpl();",
+            "    }",
+            "",
+            "    private final class Bar_SubImpl implements Sub {",
+            "",
+            "      @Override",
+            "      public test.subpackage.Sub newSubcomponentInSubpackage() {",
+            "        return new subpackage_SubImpl();",
+            "      }",
+            "",
+            "      private final class subpackage_SubImpl implements test.subpackage.Sub {}",
+            "    }",
+            "  }",
+            "  private final class NoConflictImpl implements NoConflict {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentSimpleNamesDisambiguated() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Sub newSubcomponent();",
+            "}");
+    JavaFileObject sub =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface Sub {",
+            "  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();",
+            "}");
+    JavaFileObject deepSub =
+        JavaFileObjects.forSourceLines(
+            "test.deep.many.levels.that.match.test.Sub",
+            "package test.deep.many.levels.that.match.test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.deep.many.levels.that.match.test.Sub;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public test.Sub newSubcomponent() {",
+            "    return new test_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class test_SubImpl implements test.Sub {",
+            "",
+            "    @Override",
+            "    public Sub newDeepSubcomponent() {",
+            "      return new match_test_SubImpl();",
+            "    }",
+            "",
+            "    private final class match_test_SubImpl implements Sub {}",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, sub, deepSub))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  top1.a.b.c.d.E.F.Sub top1();",
+            "  top2.a.b.c.d.E.F.Sub top2();",
+            "}");
+    JavaFileObject top1 =
+        JavaFileObjects.forSourceLines(
+            "top1.a.b.c.d.E",
+            "package top1.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+    JavaFileObject top2 =
+        JavaFileObjects.forSourceLines(
+            "top2.a.b.c.d.E",
+            "package top2.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import top1.a.b.c.d.E.F.Sub;",
+            "import top2.a.b.c.d.E.F;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub top1() {",
+            "    return new top1_a_b_c_d_E_F_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public F.Sub top2() {",
+            "    return new top2_a_b_c_d_E_F_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class top1_a_b_c_d_E_F_SubImpl implements Sub {}",
+            "  private final class top2_a_b_c_d_E_F_SubImpl implements F.Sub {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, top1, top2))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C {",
+            "  test.Foo.C newFooC();",
+            "}");
+    JavaFileObject subcomponentWithSameSimpleNameAsParent =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface C {}",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Foo.C;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements test.C {",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static test.C create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C newFooC() {",
+            "    return new Foo_CImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public test.C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_CImpl implements C {}",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
new file mode 100644
index 000000000..d7f445125
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(JUnit4.class)
+public class ValidationReportTest {
+  private static final JavaFileObject TEST_CLASS_FILE =
+      JavaFileObjects.forSourceLines("test.TestClass",
+          "package test;",
+          "",
+          "final class TestClass {}");
+
+  @Test
+  public void basicReport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void messageOnDifferentElement() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error", getTypeElement(String.class));
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("[java.lang.String] simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void subreport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                ValidationReport<TypeElement> parentReport =
+                    ValidationReport.about(getTypeElement(String.class))
+                        .addSubreport(reportBuilder.build())
+                        .build();
+                assertThat(parentReport.isClean()).isFalse();
+                parentReport.printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  private static abstract class SimpleTestProcessor extends AbstractProcessor {
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      test();
+      return false;
+    }
+
+    protected final TypeElement getTypeElement(Class<?> clazz) {
+      return getTypeElement(clazz.getCanonicalName());
+    }
+
+    protected final TypeElement getTypeElement(String canonicalName) {
+      return processingEnv.getElementUtils().getTypeElement(canonicalName);
+    }
+
+    abstract void test();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
index acf895e74..eff01b849 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -120,4 +120,9 @@
     assertThat(className.canonicalName()).isEqualTo(
         "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
   }
+
+  @Test public void fromClass_classFileName() {
+    ClassName className = ClassName.fromClass(InnerClass.class);
+    assertThat(className.classFileName('_')).isEqualTo("ClassNameTest_OuterClass_InnerClass");
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 349b2feee..e4c662fc5 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -25,6 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
@@ -74,7 +75,7 @@
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
-      "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+      GENERATED_ANNOTATION,
       "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
       "  private Provider<Integer> primitiveIntProvider;",
       "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
@@ -92,6 +93,7 @@
       "    return builder().build();",
       "  }",
       "",
+      "  @SuppressWarnings(\"unchecked\")",
       "  private void initialize(final Builder builder) {",
       "    this.primitiveIntProvider =",
       "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
@@ -124,7 +126,7 @@
       "",
       "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
       "      if (primitiveModule == null) {",
-      "        throw new NullPointerException(\"primitiveModule\");",
+      "        throw new NullPointerException();",
       "      }",
       "      this.primitiveModule = primitiveModule;",
       "      return this;",
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 59419abd3..e04cc03e3 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -30,12 +30,11 @@
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
  * with an example. Start with a module that computes a different integer for
  * each use:<pre><code>
- *   &#64;Module
- *   public class CounterModule {
- *
+ *   {@literal @Module}
+ *   final class CounterModule {
  *     int next = 100;
  *
- *     &#64;Provides Integer provideInteger() {
+ *     {@literal @Provides} Integer provideInteger() {
  *       System.out.println("computing...");
  *       return next++;
  *     }
@@ -44,11 +43,10 @@
  *
  * <h3>Direct Injection</h3>
  * This class injects that integer and prints it 3 times:<pre><code>
- *   public class DirectCounter {
- *
- *     &#64Inject Integer value;
+ *   final class DirectCounter {
+ *     {@literal @Inject} Integer value;
  *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(value);
  *       System.out.println(value);
@@ -69,11 +67,10 @@
  * This class injects a {@linkplain javax.inject.Provider provider} for the
  * integer. It calls {@code Provider.get()} 3 times and prints each result:
  * <pre><code>
- *   public class ProviderCounter {
- *
- *     &#64;Inject Provider<Integer> provider;
+ *   final class ProviderCounter {
+ *     {@literal @Inject Provider<Integer> provider;}
  *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(provider.get());
  *       System.out.println(provider.get());
@@ -95,11 +92,10 @@
  * <h3>Lazy Injection</h3>
  * This class injects a {@code Lazy} for the integer. Like the provider above,
  * it calls {@code Lazy.get()} 3 times and prints each result:<pre><code>
- *   public static class LazyCounter {
+ *   final class LazyCounter {
+ *     {@literal @Inject Lazy<Integer> lazy;}
  *
- *     &#64;Inject Lazy<Integer> lazy;
- *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(lazy.get());
  *       System.out.println(lazy.get());
@@ -122,17 +118,17 @@
  * in isolation of other {@code Lazy} instances. In this example, two {@code
  * LazyCounter} objects are created and {@code print()} is called on each:
  * <pre><code>
- *     public void run() {
- *       ObjectGraph graph = ObjectGraph.create(new CounterModule());
+ *   final class LazyCounters {
+ *     {@literal @Inject} LazyCounter counter1;
+ *     {@literal @Inject} LazyCounter counter2;
  *
- *       LazyCounter counter1 = graph.get(LazyCounter.class);
+ *     void print() {
  *       counter1.print();
- *
- *       LazyCounter counter2 = graph.get(LazyCounter.class);
  *       counter2.print();
  *     }
+ *   }
  * </code></pre>
- * The program's output demonstrates that each {@code Lazy} works independently:
+ * The output demonstrates that each {@code Lazy} works independently:
  * <pre><code>
  *   printing...
  *   computing...
@@ -145,8 +141,8 @@
  *   101
  *   101
  * </code></pre>
- * Use {@linkplain javax.inject.Singleton @Singleton} to share one instance
- * among all clients, and {@code Lazy} for lazy computation in a single client.
+ * Use {@link javax.inject.Singleton @Singleton} to share one instance among all
+ * clients, and {@code Lazy} for lazy computation in a single client.
  */
 public interface Lazy<T> {
   /**
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 3ebd13b31..106c00183 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -34,19 +34,19 @@
  *
  * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
- * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
- * an annotation called {@code @StringKey}:
+ * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key
+ * {@code SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
  *
  * <pre><code>
  * {@literal @}MapKey
- * {@literal @}interface StringKey {
- *   String value();
+ * {@literal @}interface SomeEnumKey {
+ *   SomeEnum value();
  * }
  *
  * {@literal @}Module
  * class SomeModule {
  *   {@literal @}Provides(type = MAP)
- *   {@literal @}StringKey("foo")
+ *   {@literal @}SomeEnumKey(SomeEnum.FOO)
  *   Integer provideFooValue() {
  *     return 2;
  *   }
@@ -54,8 +54,8 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<String, Integer> map) {
- *     assert map.get("foo") == 2;
+ *   SomeInjectedType(Map<SomeEnum, Integer> map) {
+ *     assert map.get(SomeEnum.FOO) == 2;
  *   }
  * }
  * </code></pre>
@@ -63,6 +63,9 @@
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
  *
+ * <p>See {@link dagger.mapkeys} for standard unwrapped map key annotations for keys that are boxed
+ * primitives, strings, or classes.
+ *
  * <h2>Annotations as keys</h2>
  *
  * <p>If {@link #unwrapValue} is false, then the annotation itself is used as the map key. For
@@ -94,6 +97,7 @@
  *
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
  * order to call {@link Map#get(Object)} on the provided map.)
+ *
  */
 @Documented
 @Target(ANNOTATION_TYPE)
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
new file mode 100644
index 000000000..d02d4177b
--- /dev/null
+++ b/core/src/main/java/dagger/Multibindings.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+@Documented
+@Target(TYPE)
+@Beta
+public @interface Multibindings {}
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index b0524b4ef..741a54a2d 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -46,6 +46,7 @@
      * returned value is contributed to the set. The object graph will pass dependencies to the
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
+     *
      */
     SET,
 
@@ -53,6 +54,7 @@
      * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
+     *
      */
     SET_VALUES,
 
@@ -61,6 +63,7 @@
      * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
      * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
      * the accumulation of values will be immutable.
+     *
      */
     @Beta
     MAP;
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 0ef47011f..988f17b49 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -16,9 +16,11 @@
 package dagger;
 
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * A subcomponent that inherits the bindings from a parent {@link Component} or
@@ -28,6 +30,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Target(TYPE)
 @Documented
 public @interface Subcomponent {
diff --git a/core/src/main/java/dagger/internal/DelegateFactory.java b/core/src/main/java/dagger/internal/DelegateFactory.java
new file mode 100644
index 000000000..d1e864d17
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DelegateFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+
+/**
+ * A DelegateFactory that is used to stitch Provider/Lazy indirection based dependency cycles.
+ * 
+ * @since 2.0.1
+ */
+public final class DelegateFactory<T> implements Factory<T> {
+  private Provider<T> delegate;
+
+  @Override
+  public T get() {
+    if (delegate == null) {
+      throw new IllegalStateException();
+    }
+    return delegate.get();
+  }
+
+  public void setDelegatedProvider(Provider<T> delegate) {
+    if (delegate == null) {
+      throw new IllegalArgumentException();
+    }
+    if (this.delegate != null) {
+      throw new IllegalStateException();
+    }
+    this.delegate = delegate;
+  }
+}
+
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
index 6db11f381..8257c3beb 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -40,7 +40,6 @@ private DoubleCheckLazy(Provider<T> provider) {
   @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
-    // to suppress it.
     Object result = instance;
     if (result == UNINITIALIZED) {
       synchronized (this) {
@@ -57,6 +56,16 @@ public T get() {
     if (provider == null) {
       throw new NullPointerException();
     }
+    if (provider instanceof Lazy) {
+      @SuppressWarnings("unchecked")
+      final Lazy<T> lazy = (Lazy<T>) provider;
+      // Avoids memoizing a value that is already memoized.
+      // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
+      // are different types using covariant return on get(). Right now this is used with
+      // ScopedProvider<T> exclusively, which is implemented such that P and L are always the same
+      // so it will be fine for that case.
+      return lazy;
+    }
     return new DoubleCheckLazy<T>(provider);
   }
 }
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 00c0fd33a..b5c96e702 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -31,6 +32,9 @@
  *
  */
 public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private static final MapProviderFactory<Object, Object> EMPTY =
+      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
   /**
@@ -40,7 +44,15 @@
     return new Builder<K, V>(size);
   }
 
-  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+  /**
+   * Returns a factory of an empty map.
+   */
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> MapProviderFactory<K, V> empty() {
+    return (MapProviderFactory<K, V>) EMPTY;
+  }
+
+  private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     this.contributingMap = unmodifiableMap(contributingMap);
   }
 
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
index 15917dd27..b25db380a 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.Lazy;
 import javax.inject.Provider;
 
 /**
@@ -23,7 +24,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-public final class ScopedProvider<T> implements Provider<T> {
+public final class ScopedProvider<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private final Factory<T> factory;
diff --git a/core/src/main/java/dagger/mapkeys/ClassKey.java b/core/src/main/java/dagger/mapkeys/ClassKey.java
new file mode 100644
index 000000000..21497c681
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/ClassKey.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * A {@link MapKey} annotation for maps with {@code Class<?>} keys.
+ * 
+ * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
+ * member whose type is {@code Class<? extends Something>}.
+ */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface ClassKey {
+  Class<?> value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/IntKey.java b/core/src/main/java/dagger/mapkeys/IntKey.java
new file mode 100644
index 000000000..011b49fe8
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/IntKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@code int} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface IntKey {
+  int value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/LongKey.java b/core/src/main/java/dagger/mapkeys/LongKey.java
new file mode 100644
index 000000000..183b74d02
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/LongKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@code long} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface LongKey {
+  long value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/StringKey.java b/core/src/main/java/dagger/mapkeys/StringKey.java
new file mode 100644
index 000000000..7455a9bc5
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/StringKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@link String} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface StringKey {
+  String value();
+}
\ No newline at end of file
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 53de228ff..340c59c54 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -37,6 +37,7 @@
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
+      <scope>provided</scope>
       <optional>true</optional>
     </dependency>
 
@@ -54,7 +55,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-activity-graphs/AndroidManifest.xml
rename to examples/android-activity-graphs/src/main/AndroidManifest.xml
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 332aeb66b..fb934e6d6 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -37,6 +37,7 @@
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
+      <scope>provided</scope>
       <optional>true</optional>
     </dependency>
 
@@ -50,7 +51,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-simple/AndroidManifest.xml
rename to examples/android-simple/src/main/AndroidManifest.xml
diff --git a/examples/pom.xml b/examples/pom.xml
index 7e809b403..b6eabf29e 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -64,12 +64,13 @@
           </configuration>
         </plugin>
         <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <groupId>com.simpligility.maven.plugins</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.2</version>
+          <version>4.3.0</version>
           <configuration>
             <sdk>
-              <platform>16</platform>
+              <platform>23</platform>
+              <path>${env.ANDROID_HOME}</path>
             </sdk>
           </configuration>
         </plugin>
diff --git a/pom.xml b/pom.xml
index d584d49d0..18bb74aca 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,15 +44,18 @@
     <!-- Compilation -->
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
+    <javax.annotation.version>2.0.1</javax.annotation.version>
     <javawriter.version>2.5.0</javawriter.version>
-    <auto.common.version>1.0-SNAPSHOT</auto.common.version>
-    <auto.factory.version>1.0-SNAPSHOT</auto.factory.version>
+    <auto.common.version>0.5</auto.common.version>
+    <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
-    <guava.version>18.0</guava.version>
+    <guava.version>19.0-rc2</guava.version>
+    <google.java.format.version>0.1-alpha</google.java.format.version>
+
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.7</compile-testing.version>
+    <compile-testing.version>0.8</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
     <truth.version>0.26</truth.version>
@@ -88,6 +91,16 @@
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject</artifactId>
         <version>${javax.inject.version}</version>
+      </dependency>
+       <dependency>
+        <groupId>javax.inject</groupId>
+        <artifactId>javax.inject-tck</artifactId>
+        <version>${javax.inject.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>${javax.annotation.version}</version>
       </dependency>
       <dependency>
         <groupId>com.squareup</groupId>
@@ -104,6 +117,11 @@
         <artifactId>guava-testlib</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.googlejavaformat</groupId>
+        <artifactId>google-java-format</artifactId>
+        <version>${google.java.format.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
diff --git a/producers/pom.xml b/producers/pom.xml
index 32ecaf0a5..edaeca428 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -35,6 +35,11 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -49,5 +54,15 @@
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 3fbbee24c..db5c133ff 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -15,8 +15,12 @@
  */
 package dagger.producers;
 
+import com.google.common.base.Objects;
 import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
+import javax.annotation.Nullable;
+
+import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
@@ -39,11 +43,91 @@
  * @author Jesse Beder
  */
 @Beta
-public interface Produced<T> {
+public abstract class Produced<T> {
   /**
    * Returns the result of a production.
    *
    * @throws ExecutionException if the production threw an exception
    */
-  T get() throws ExecutionException;
+  public abstract T get() throws ExecutionException;
+
+  /**
+   * Two {@code Produced} objects compare equal if both are successful with equal values, or both
+   * are failed with equal exceptions.
+   */
+  @Override
+  public abstract boolean equals(Object o);
+
+  /** Returns an appropriate hash code to match {@link #equals). */
+  @Override
+  public abstract int hashCode();
+
+  /** Returns a successful {@code Produced}, whose {@link #get} will return the given value. */
+  public static <T> Produced<T> successful(@Nullable T value) {
+    return new Successful<T>(value);
+  }
+
+  /**
+   * Returns a failed {@code Produced}, whose {@link #get} will throw an
+   * {@code ExecutionException} with the given cause.
+   */
+  public static <T> Produced<T> failed(Throwable throwable) {
+    return new Failed<T>(checkNotNull(throwable));
+  }
+
+  private static final class Successful<T> extends Produced<T> {
+    @Nullable private final T value;
+
+    private Successful(@Nullable T value) {
+      this.value = value;
+    }
+
+    @Override public T get() {
+      return value;
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Successful) {
+        Successful<?> that = (Successful<?>) o;
+        return Objects.equal(this.value, that.value);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return value == null ? 0 : value.hashCode();
+    }
+  }
+
+  private static final class Failed<T> extends Produced<T> {
+    private final Throwable throwable;
+
+    private Failed(Throwable throwable) {
+      this.throwable = checkNotNull(throwable);
+    }
+
+    @Override public T get() throws ExecutionException {
+      throw new ExecutionException(throwable);
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Failed) {
+        Failed<?> that = (Failed<?>) o;
+        return this.throwable.equals(that.throwable);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return throwable.hashCode();
+    }
+  }
+
+  private Produced() {}
 }
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 6aa9ea8f0..f3f7db027 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -35,7 +35,7 @@
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
  * component instance, no matter how many times that binding is used as a dependency.
- * TODO(user): Decide on how scope works for producers.
+ * TODO(beder): Decide on how scope works for producers.
  *
  * <h2>Component methods</h2>
  *
@@ -62,7 +62,7 @@
  * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
  * {@code CancellationException}), then exception is handled as in
  * {@link com.google.common.util.concurrent.Futures#transform}.
- * <!-- TODO(user): Explain this more thoroughly, and update the javadocs of those utilities. -->
+ * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
  * @author Jesse Beder
  */
@@ -80,4 +80,43 @@
    * A list of types that are to be used as component dependencies.
    */
   Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @ProductionComponent.Builder}. If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the builder type, or a supertype of the builder.
+   * <li> There <b>must</b> be an abstract method whose parameter is
+   *      {@link java.util.concurrent.Executor}.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not
+   *      required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   *
+   * For example, this could be a valid {@code ProductionComponent} with a builder: <pre><code>
+   * {@literal @}ProductionComponent(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   {@literal ListenableFuture<MyWidget>} myWidget();
+   *
+   *   {@literal @}ProductionComponent.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder executor(Executor executor);
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
+
diff --git a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
new file mode 100644
index 000000000..2832fcf65
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A subcomponent that inherits the bindings from a parent {@link Component}, {@link Subcomponent},
+ * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a
+ * subcomponent with a parent are described in the documentation for {@link Component}.
+ *
+ * @author Jesse Beder
+ */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
+@Target(TYPE)
+@Documented
+public @interface ProductionSubcomponent {
+  /**
+   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
+   * used to generate the subcomponent implementation.  Note that through the use of
+   * {@link Module#includes} or {@link ProducerModule#includes} the full set of modules used to
+   * implement the subcomponent may include more modules that just those listed here.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A builder for a subcomponent.  This follows all the rules of
+   * {@link ProductionComponent.Builder}, except it must appear in classes annotated with
+   * {@link ProductionSubcomponent} instead of {@code ProductionComponent}. Components can have
+   * methods that return a {@link ProductionSubcomponent.Builder}-annotated type, allowing the user
+   * to set modules on the subcomponent using their defined API.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
+}
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 43659980b..8c4fe0b40 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -17,6 +17,15 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.producers.monitoring.internal.Monitors;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import javax.annotation.Nullable;
+import javax.inject.Provider;
 
 /**
  * An abstract {@link Producer} implementation that memoizes the result of its compute method.
@@ -25,10 +34,22 @@
  * @since 2.0
  */
 public abstract class AbstractProducer<T> implements Producer<T> {
+  private final Provider<ProductionComponentMonitor> monitorProvider;
+  @Nullable private final ProducerToken token;
   private volatile ListenableFuture<T> instance = null;
 
+  protected AbstractProducer() {
+    this(Monitors.noOpProductionComponentMonitorProvider(), null);
+  }
+
+  protected AbstractProducer(
+      Provider<ProductionComponentMonitor> monitorProvider, @Nullable ProducerToken token) {
+    this.monitorProvider = checkNotNull(monitorProvider);
+    this.token = token;
+  }
+
   /** Computes this producer's future, which is then cached in {@link #get}. */
-  protected abstract ListenableFuture<T> compute();
+  protected abstract ListenableFuture<T> compute(ProducerMonitor monitor);
 
   @Override
   public final ListenableFuture<T> get() {
@@ -38,10 +59,13 @@
       synchronized (this) {
         result = instance;
         if (result == null) {
-          instance = result = compute();
+          ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          monitor.requested();
+          instance = result = compute(monitor);
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
+          monitor.addCallbackTo(result);
         }
       }
     }
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
new file mode 100644
index 000000000..7217e8c11
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
+ * {@code Map<K, Produced<V>>} which is populated by calls to the delegate {@link Producer#get}
+ * methods.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
+  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+
+  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    this.mapProducerProducer = mapProducerProducer;
+  }
+
+  /**
+   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
+   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
+   * order of the input map.
+   *
+   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
+   * future will succeed and the corresponding {@code Produced<V>} will fail with a
+   * {@link NullPointerException}.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * component futures fails or is canceled, this one is, too.
+   */
+  public static <K, V> MapOfProducedProducer<K, V> create(
+      Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  }
+
+  @Override
+  public ListenableFuture<Map<K, Produced<V>>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.transformAsync(
+        mapProducerProducer.get(),
+        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+          @Override
+          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
+            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
+            return Futures.transform(
+                Futures.allAsList(
+                    Iterables.transform(
+                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
+                  @Override
+                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+                    return ImmutableMap.copyOf(entries);
+                  }
+                });
+          }
+        });
+  }
+
+  private static final Function<
+          Map.Entry<Object, Producer<Object>>,
+          ListenableFuture<Map.Entry<Object, Produced<Object>>>>
+      ENTRY_UNWRAPPER =
+          new Function<
+              Map.Entry<Object, Producer<Object>>,
+              ListenableFuture<Map.Entry<Object, Produced<Object>>>>() {
+            @Override
+            public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
+                final Map.Entry<Object, Producer<Object>> entry) {
+              return Futures.transform(
+                  Producers.createFutureProduced(entry.getValue().get()),
+                  new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
+                    @Override
+                    public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
+                      return Maps.immutableEntry(entry.getKey(), value);
+                    }
+                  });
+            }
+          };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
+  private static <K, V>
+      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>
+          entryUnwrapper() {
+    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>)
+        (Function) ENTRY_UNWRAPPER;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
new file mode 100644
index 000000000..18338d055
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.Map;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
+ * immediate future of {@code Map<K, Producer<V>>} when calling {@link #get}.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
+  private static final MapOfProducerProducer<Object, Object> EMPTY =
+      new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
+
+  private final ImmutableMap<K, Producer<V>> contributingMap;
+
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  /** Returns a producer of an empty map. */
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> MapOfProducerProducer<K, V> empty() {
+    return (MapOfProducerProducer<K, V>) EMPTY;
+  }
+
+  private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
+  }
+
+  @Override
+  public ListenableFuture<Map<K, Producer<V>>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
+  }
+
+  /**
+   * A builder to help build the {@link MapOfProducerProducer}
+   */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(beder): It would be nice to use the size, but ImmutableMap doesn't allow a pre-sized
+      // map, and Dagger's internal Collections implementation is package-private.
+      this.mapBuilder = ImmutableMap.builder();
+    }
+
+    /** Returns a new {@link MapOfProducerProducer}. */
+    public MapOfProducerProducer<K, V> build() {
+      return new MapOfProducerProducer<K, V>(mapBuilder.build());
+    }
+
+    /** Associates k with producerOfValue in {@code Builder}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
new file mode 100644
index 000000000..61d6a28ac
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
+ * {@code Map<K, V>} which is populated by calls to the delegate {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
+  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+
+  private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    this.mapProducerProducer = mapProducerProducer;
+  }
+
+  /**
+   * Returns a producer of {@code Map<K, V>}, where the map is derived from the given map of
+   * producers by waiting for those producers' resulting futures. The iteration order mirrors the
+   * order of the input map.
+   *
+   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
+   * future will fail with a {@link NullPointerException}.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * component futures fails or is canceled, this one is, too.
+   */
+  public static <K, V> MapProducer<K, V> create(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    return new MapProducer<K, V>(mapProducerProducer);
+  }
+
+  @Override
+  public ListenableFuture<Map<K, V>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.transformAsync(
+        mapProducerProducer.get(),
+        new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
+          @Override
+          public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
+            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
+            return Futures.transform(
+                Futures.allAsList(
+                    Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
+                new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
+                  @Override
+                  public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
+                    return ImmutableMap.copyOf(entries);
+                  }
+                });
+          }
+        });
+  }
+
+  private static final Function<
+          Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>
+      ENTRY_UNWRAPPER =
+          new Function<
+              Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>() {
+            @Override
+            public ListenableFuture<Map.Entry<Object, Object>> apply(
+                final Map.Entry<Object, Producer<Object>> entry) {
+              return Futures.transform(
+                  entry.getValue().get(),
+                  new Function<Object, Map.Entry<Object, Object>>() {
+                    @Override
+                    public Map.Entry<Object, Object> apply(Object value) {
+                      return Maps.immutableEntry(entry.getKey(), value);
+                    }
+                  });
+            }
+          };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
+  private static <K, V>
+      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
+    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>>)
+        (Function) ENTRY_UNWRAPPER;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index c850caa33..499de2a50 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -17,17 +17,13 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.FutureFallback;
+import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
 import javax.inject.Provider;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -49,37 +45,35 @@
    * cancelling the input future will trigger the resulting future to succeed with a failing
    * {@code Produced}.
    */
-  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
-    return Futures.withFallback(
-        Futures.transform(future, new Function<T, Produced<T>>() {
-          @Override public Produced<T> apply(final T value) {
-            return new Produced<T>() {
-              @Override public T get() {
-                return value;
+    return Futures.catchingAsync(
+        Futures.transform(
+            future,
+            new Function<T, Produced<T>>() {
+              @Override
+              public Produced<T> apply(final T value) {
+                return Produced.successful(value);
               }
-            };
-          }
-        }), Producers.<T>futureFallbackForProduced());
+            }),
+        Throwable.class,
+        Producers.<T>futureFallbackForProduced());
 
   }
 
-  private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
-      new FutureFallback<Produced<Object>>() {
-    @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
-      Produced<Object> produced = new Produced<Object>() {
-        @Override public Object get() throws ExecutionException {
-          throw new ExecutionException(t);
+  private static final AsyncFunction<Throwable, Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
+      new AsyncFunction<Throwable, Produced<Object>>() {
+        @Override
+        public ListenableFuture<Produced<Object>> apply(Throwable t) throws Exception {
+          Produced<Object> produced = Produced.failed(t);
+          return Futures.immediateFuture(produced);
         }
       };
-      return Futures.immediateFuture(produced);
-    }
-  };
 
-  @SuppressWarnings({"unchecked", "rawtypes"})  // bivariant implementation
-  private static <T> FutureFallback<Produced<T>> futureFallbackForProduced() {
-    return (FutureFallback) FUTURE_FALLBACK_FOR_PRODUCED;
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariant implementation
+  private static <T> AsyncFunction<Throwable, Produced<T>> futureFallbackForProduced() {
+    return (AsyncFunction) FUTURE_FALLBACK_FOR_PRODUCED;
   }
 
   /**
@@ -94,19 +88,6 @@
     });
   }
 
-  /**
-   * Submits a callable to an executor, returning the future representing the task. This mirrors
-   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
-   * {@link Executor}.
-   *
-   * @throws RejectedExecutionException if this task cannot be accepted for execution.
-   */
-  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
-    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
-    executor.execute(future);
-    return future;
-  }
-
   /**
    * Returns a producer that immediately executes the binding logic for the given provider every
    * time it is called.
@@ -114,11 +95,32 @@
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
     return new AbstractProducer<T>() {
-      @Override protected ListenableFuture<T> compute() {
+      @Override
+      protected ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
         return Futures.immediateFuture(provider.get());
       }
     };
   }
 
+  /** Returns a producer that succeeds with the given value. */
+  public static <T> Producer<T> immediateProducer(final T value) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+
+  /** Returns a producer that fails with the given exception. */
+  public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFailedFuture(throwable);
+      }
+    };
+  }
+
   private Producers() {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
new file mode 100644
index 000000000..e51bcad42
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
+ * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  @SafeVarargs
+  public static <T> Producer<Set<Produced<T>>> create(Producer<Set<T>>... producers) {
+    return new SetOfProducedProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final ImmutableSet<Producer<Set<T>>> contributingProducers;
+
+  private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
+   * elements given by each of the producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then that corresponding
+   * {@code Produced} element will fail with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
+   * {@link Produced}.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
+    List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
+        new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureProducedSets.add(Producers.createFutureProduced(futureSet));
+    }
+    return Futures.transform(
+        Futures.allAsList(futureProducedSets),
+        new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
+          @Override
+          public Set<Produced<T>> apply(List<Produced<Set<T>>> producedSets) {
+            ImmutableSet.Builder<Produced<T>> builder = ImmutableSet.builder();
+            for (Produced<Set<T>> producedSet : producedSets) {
+              try {
+                Set<T> set = producedSet.get();
+                if (set == null) {
+                  // TODO(beder): This is a vague exception. Can we somehow point to the failing
+                  // producer? See the similar comment in the component writer about null
+                  // provisions.
+                  builder.add(
+                      Produced.<T>failed(
+                          new NullPointerException(
+                              "Cannot contribute a null set into a producer set binding when it's"
+                                  + " injected as Set<Produced<T>>.")));
+                } else {
+                  for (T value : set) {
+                    if (value == null) {
+                      builder.add(
+                          Produced.<T>failed(
+                              new NullPointerException(
+                                  "Cannot contribute a null element into a producer set binding"
+                                      + " when it's injected as Set<Produced<T>>.")));
+                    } else {
+                      builder.add(Produced.successful(value));
+                    }
+                  }
+                }
+              } catch (ExecutionException e) {
+                builder.add(Produced.<T>failed(e.getCause()));
+              }
+            }
+            return builder.build();
+          }
+        });
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 399dbd031..5b3c0902d 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -20,6 +20,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -37,14 +38,15 @@
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
    */
-  public static <T> Producer<Set<T>> create(
-      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+  @SafeVarargs
+  public static <T> Producer<Set<T>> create(Producer<Set<T>>... producers) {
     return new SetProducer<T>(ImmutableSet.copyOf(producers));
   }
 
   private final Set<Producer<Set<T>>> contributingProducers;
 
   private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    super();
     this.contributingProducers = contributingProducers;
   }
 
@@ -61,7 +63,7 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<T>> compute() {
+  public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Set<T>>> futureSets =
         new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
     for (Producer<Set<T>> producer : contributingProducers) {
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
new file mode 100644
index 000000000..f18046231
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.Produces;
+
+/**
+ * A hook for monitoring the execution of individual {@linkplain Produces producer methods}. See
+ * {@link ProductionComponentMonitor} for how to install these monitors.
+ *
+ * <p>The lifecycle of the monitor, under normal conditions, is:
+ * <ul>
+ *   <li>{@link #requested()}
+ *   <li>{@link #methodStarting()}
+ *   <li>The method is called
+ *   <li>{@link #methodFinished()}
+ *   <li>If the method returns a value, then:
+ *   <ul>
+ *     <li>{@link #succeeded(Object)} if the method returned normally; or
+ *     <li>{@link #failed(Throwable)} if the method threw an exception.
+ *   </ul>
+ *   <li>If the method returns a future, then:
+ *   <ul>
+ *     <li>{@link #succeeded(Object)} if the method returned normally, and the future succeeded; or
+ *     <li>{@link #failed(Throwable)} if the method threw an exception, or returned normally and the
+ *         future failed.
+ *   </ul>
+ * </ul>
+ *
+ * <p>If any input to the monitored producer fails, {@link #failed(Throwable)} will be called
+ * immediately with the failed input's exception. If more than one input fails, an arbitrary failed
+ * input's exception is used.
+ *
+ * <p>For example, given an entry point A that depends on B, which depends on C, when the entry
+ * point A is called, this will trigger the following sequence of events, assuming all methods and
+ * futures complete successfully:
+ * <ul>
+ *   <li>A requested
+ *   <li>B requested
+ *   <li>C requested
+ *   <li>C methodStarting
+ *   <li>C methodFinished
+ *   <li>C succeeded
+ *   <li>B methodStarting
+ *   <li>B methodFinished
+ *   <li>B succeeded
+ *   <li>A methodStarting
+ *   <li>A methodFinished
+ *   <li>A succeeded
+ * </ul>
+ *
+ * <p>If any of the monitor's methods throw, then the exception will be logged and processing will
+ * continue unaffected.
+ *
+ * @author Jesse Beder
+ */
+public abstract class ProducerMonitor {
+  /**
+   * Called when the producer's output is requested; that is, when the first method is called that
+   * requires the production of this producer's output.
+   *
+   * <p>Note that if a method depends on {@link Producer Producer<T>}, then this does not count as
+   * requesting {@code T}; that is only triggered by calling {@link Producer#get()}.
+   *
+   * <p>When multiple monitors are installed, the order that each monitor will call this method is
+   * unspecified, but will remain consistent throughout the course of the execution of a component.
+   */
+  public void requested() {}
+
+  /**
+   * Called when the producer method is about to start executing.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #requested()}.
+   */
+  public void methodStarting() {}
+
+  /**
+   * Called when the producer method has finished executing. This will be called from the same
+   * thread as {@link #methodStarting()}.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #requested()}.
+   */
+  public void methodFinished() {}
+
+  /**
+   * Called when the producer’s future has completed successfully with a value.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #requested()}.
+   */
+  public void succeeded(Object o) {}
+
+  /**
+   * Called when the producer's future has failed with an exception.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #requested()}.
+   */
+  public void failed(Throwable t) {}
+
+  /**
+   * Adds this monitor's completion methods as a callback to the future. This is only intended to be
+   * overridden in the framework!
+   */
+  public <T> void addCallbackTo(ListenableFuture<T> future) {
+    Futures.addCallback(
+        future,
+        new FutureCallback<T>() {
+          @Override
+          public void onSuccess(T value) {
+            succeeded(value);
+          }
+
+          @Override
+          public void onFailure(Throwable t) {
+            failed(t);
+          }
+        });
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
new file mode 100644
index 000000000..071f32cb8
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording the timing of the execution of individual
+ * {@linkplain Produces producer methods}. See {@link ProductionComponentTimingRecorder} for how to
+ * install these monitors.
+ *
+ * <p>If any of the recorder's methods throw, then the exception will be logged and processing will
+ * continue unaffected.
+ *
+ * <p>All timings are measured at nanosecond precision, but not necessarily nanosecond resolution.
+ * That is, timings will be reported in nanoseconds, but the timing source will not necessarily
+ * update at nanosecond resolution. For example, {@link System#nanoTime()) would satisfy these
+ * constraints.
+ *
+ * @author Jesse Beder
+ */
+public abstract class ProducerTimingRecorder {
+  /**
+   * Reports that the producer method has finished executing with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param startedNanos the wall-clock time, in nanoseconds, when the producer method started
+   *     executing, measured from when the first method on the
+   *     {@linkplain ProductionComponent production component} was called.
+   * @param durationNanos the wall-clock time, in nanoseconds, that the producer method took to
+   *     execute.
+   */
+  public void recordMethod(long startedNanos, long durationNanos) {}
+
+  /**
+   * Reports that the producer's future has succeeded with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordSuccess(long latencyNanos) {}
+
+  /**
+   * Reports that the producer's future has failed with the given statistics.
+   *
+   * @param exception the exception that the future failed with.
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordFailure(Throwable exception, long latencyNanos) {}
+
+  /**
+   * Reports that the producer was skipped because one of its inputs failed.
+   *
+   * @param exception the exception that its input failed with. If multiple inputs failed, this
+   *    exception will be chosen arbitrarily from the input failures.
+   */
+  public void recordSkip(Throwable exception) {}
+
+  /** Returns a producer recorder that does nothing. */
+  public static ProducerTimingRecorder noOp() {
+    return NO_OP;
+  }
+
+  private static final ProducerTimingRecorder NO_OP = new ProducerTimingRecorder() {};
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
new file mode 100644
index 000000000..5834206ee
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/** A token that represents an individual {@linkplain Produces producer method}. */
+public final class ProducerToken {
+  private final Class<?> classToken;
+
+  private ProducerToken(Class<?> classToken) {
+    this.classToken = classToken;
+  }
+
+  /**
+   * Creates a token for a class token that represents the generated factory for a producer method.
+   *
+   * <p><b>Do not use this!</b> This is intended to be called by generated code only, and its
+   * signature may change at any time.
+   */
+  public static ProducerToken create(Class<?> classToken) {
+    return new ProducerToken(checkNotNull(classToken));
+  }
+
+  /** Two tokens are equal if they represent the same method. */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    } else if (o instanceof ProducerToken) {
+      ProducerToken that = (ProducerToken) o;
+      return this.classToken.equals(that.classToken);
+    } else {
+      return false;
+    }
+  }
+
+  /** Returns an appropriate hash code to match {@link #equals). */
+  @Override
+  public int hashCode() {
+    return classToken.hashCode();
+  }
+
+  /** Returns a representation of the method. */
+  @Override
+  public String toString() {
+    return classToken.toString();
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
new file mode 100644
index 000000000..4dc2903fa
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for monitoring execution of {@linkplain ProductionComponent production components}. To
+ * install a {@code ProductionComponentMonitor}, contribute to a set binding of
+ * {@code ProductionComponentMonitor.Factory}. The factory will be asked to create one monitor for
+ * the component, and the resulting single instance will be used to create individual monitors for
+ * producers.
+ *
+ * <p>For example: <pre><code>
+ *   {@literal @Module}
+ *   final class MyMonitorModule {
+ *     {@literal @Provides(type = SET)} ProductionComponentMonitor.Factory provideMonitorFactory(
+ *         MyProductionComponentMonitor.Factory monitorFactory) {
+ *       return monitorFactory;
+ *     }
+ *   }
+ *
+ *   {@literal @ProductionComponent(modules = {MyMonitorModule.class, MyProducerModule.class})}
+ *   interface MyComponent {
+ *     {@literal ListenableFuture<SomeType>} someType();
+ *   }
+ * </code></pre>
+ *
+ * <p>If any of these methods throw, then the exception will be logged, and the framework will act
+ * as though a no-op monitor was returned.
+ *
+ * @author Jesse Beder
+ */
+public interface ProductionComponentMonitor {
+  /** Returns a monitor for an individual {@linkplain Produces producer method}. */
+  ProducerMonitor producerMonitorFor(ProducerToken token);
+
+  public interface Factory {
+    /** Creates a component-specific monitor when the component is created. */
+    ProductionComponentMonitor create(Object component);
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
new file mode 100644
index 000000000..debe06d9a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording timing of the execution of
+ * {@linkplain ProductionComponent production components}. To install a
+ * {@code ProductionComponentTimingRecorder}, contribute to a set binding of
+ * {@code ProductionComponentTimingRecorder.Factory}, and include the {@code TimingMonitorModule} to
+ * the component. The factory will be asked to create one timing recorder for the component, and the
+ * resulting instance will be used to create individual timing recorders for producers.
+ *
+ * <p>If any of these methods throw, then the exception will be logged, and the framework will act
+ * as though a no-op timing recorder was returned.
+ *
+ * @author Jesse Beder
+ */
+public interface ProductionComponentTimingRecorder {
+  /** Returns a timing recorder for an individual {@linkplain Produces producer method}. */
+  ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token);
+
+  public interface Factory {
+    /** Creates a component-specific timing recorder when the component is created. */
+    ProductionComponentTimingRecorder create(Object component);
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
new file mode 100644
index 000000000..a4bfa17c1
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+/**
+ * A monitor that measures the timing of the execution of a producer method, and logs those timings
+ * with the given recorder.
+ */
+final class TimingProducerMonitor extends ProducerMonitor {
+  private final ProducerTimingRecorder recorder;
+  private final Stopwatch stopwatch;
+  private final Stopwatch componentStopwatch;
+  private long startNanos = -1;
+
+  TimingProducerMonitor(
+      ProducerTimingRecorder recorder, Ticker ticker, Stopwatch componentStopwatch) {
+    this.recorder = recorder;
+    this.stopwatch = Stopwatch.createUnstarted(ticker);
+    this.componentStopwatch = componentStopwatch;
+  }
+
+  @Override
+  public void methodStarting() {
+    startNanos = componentStopwatch.elapsed(NANOSECONDS);
+    stopwatch.start();
+  }
+
+  @Override
+  public void methodFinished() {
+    // TODO(beder): Is a system ticker the appropriate way to track CPU time? Should we use
+    // ThreadCpuTicker instead?
+    long durationNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordMethod(startNanos, durationNanos);
+  }
+
+  @Override
+  public void succeeded(Object o) {
+    long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordSuccess(latencyNanos);
+  }
+
+  @Override
+  public void failed(Throwable t) {
+    if (stopwatch.isRunning()) {
+      long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+      recorder.recordFailure(t, latencyNanos);
+    } else {
+      recorder.recordSkip(t);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
new file mode 100644
index 000000000..e6ae829a3
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+/**
+ * A monitor that measures the timing of the execution of a production component, and logs those
+ * timings with the given recorder.
+ *
+ * <p>This assumes that the given recorders do not throw or return null; for example, by using
+ * {@link TimingRecorders#delegatingProductionComponentTimingRecorderFactory}.
+ */
+final class TimingProductionComponentMonitor implements ProductionComponentMonitor {
+  private final ProductionComponentTimingRecorder recorder;
+  private final Ticker ticker;
+  private final Stopwatch stopwatch;
+
+  TimingProductionComponentMonitor(ProductionComponentTimingRecorder recorder, Ticker ticker) {
+    this.recorder = recorder;
+    this.ticker = ticker;
+    this.stopwatch = Stopwatch.createStarted(ticker);
+  }
+
+  @Override
+  public ProducerMonitor producerMonitorFor(ProducerToken token) {
+    return new TimingProducerMonitor(recorder.producerTimingRecorderFor(token), ticker, stopwatch);
+  }
+
+  static final class Factory implements ProductionComponentMonitor.Factory {
+    private final ProductionComponentTimingRecorder.Factory recorderFactory;
+    private final Ticker ticker;
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {
+      this(recorderFactory, Ticker.systemTicker());
+    }
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory, Ticker ticker) {
+      this.recorderFactory = recorderFactory;
+      this.ticker = ticker;
+    }
+
+    @Override
+    public ProductionComponentMonitor create(Object component) {
+      return new TimingProductionComponentMonitor(recorderFactory.create(component), ticker);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
new file mode 100644
index 000000000..842a55a36
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Utility methods relating to timing.
+ *
+ * @author Jesse Beder
+ */
+final class TimingRecorders {
+  private static final Logger logger = Logger.getLogger(TimingRecorders.class.getName());
+
+  /**
+   * Returns a timing recorder factory that delegates to the given factories, and ensures that any
+   * method called on this object, even transitively, does not throw a {@link RuntimeException} or
+   * return null.
+   *
+   * <p>If the delegate recorders throw an {@link Error}, then that will escape this recorder
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  static ProductionComponentTimingRecorder.Factory
+      delegatingProductionComponentTimingRecorderFactory(
+          Collection<ProductionComponentTimingRecorder.Factory> factories) {
+    switch (factories.size()) {
+      case 0:
+        return noOpProductionComponentTimingRecorderFactory();
+      case 1:
+        return new NonThrowingProductionComponentTimingRecorder.Factory(
+            Iterables.getOnlyElement(factories));
+      default:
+        return new DelegatingProductionComponentTimingRecorder.Factory(factories);
+    }
+  }
+
+  /**
+   * A component recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ProductionComponentTimingRecorder delegate;
+
+    NonThrowingProductionComponentTimingRecorder(ProductionComponentTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      try {
+        ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+        return recorder == null
+            ? ProducerTimingRecorder.noOp()
+            : new NonThrowingProducerTimingRecorder(recorder);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderForException(e, delegate, token);
+        return ProducerTimingRecorder.noOp();
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ProductionComponentTimingRecorder.Factory delegate;
+
+      Factory(ProductionComponentTimingRecorder.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        try {
+          ProductionComponentTimingRecorder recorder = delegate.create(component);
+          return recorder == null
+              ? noOpProductionComponentTimingRecorder()
+              : new NonThrowingProductionComponentTimingRecorder(recorder);
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return noOpProductionComponentTimingRecorder();
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ProducerTimingRecorder delegate;
+
+    NonThrowingProducerTimingRecorder(ProducerTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      try {
+        delegate.recordMethod(startedNanos, durationNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      try {
+        delegate.recordSuccess(latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      try {
+        delegate.recordFailure(exception, latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      try {
+        delegate.recordSkip(exception);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+      }
+    }
+  }
+
+  /**
+   * A component recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ImmutableList<ProductionComponentTimingRecorder> delegates;
+
+    DelegatingProductionComponentTimingRecorder(
+        ImmutableList<ProductionComponentTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerTimingRecorder> recordersBuilder = ImmutableList.builder();
+      for (ProductionComponentTimingRecorder delegate : delegates) {
+        try {
+          ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+          if (recorder != null) {
+            recordersBuilder.add(recorder);
+          }
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerTimingRecorder> recorders = recordersBuilder.build();
+      switch (recorders.size()) {
+        case 0:
+          return ProducerTimingRecorder.noOp();
+        case 1:
+          return new NonThrowingProducerTimingRecorder(Iterables.getOnlyElement(recorders));
+        default:
+          return new DelegatingProducerTimingRecorder(recorders);
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ImmutableList<? extends ProductionComponentTimingRecorder.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentTimingRecorder.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        ImmutableList.Builder<ProductionComponentTimingRecorder> recordersBuilder =
+            ImmutableList.builder();
+        for (ProductionComponentTimingRecorder.Factory delegate : delegates) {
+          try {
+            ProductionComponentTimingRecorder recorder = delegate.create(component);
+            if (recorder != null) {
+              recordersBuilder.add(recorder);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentTimingRecorder> recorders = recordersBuilder.build();
+        switch (recorders.size()) {
+          case 0:
+            return noOpProductionComponentTimingRecorder();
+          case 1:
+            return new NonThrowingProductionComponentTimingRecorder(
+                Iterables.getOnlyElement(recorders));
+          default:
+            return new DelegatingProductionComponentTimingRecorder(recorders);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ImmutableList<ProducerTimingRecorder> delegates;
+
+    DelegatingProducerTimingRecorder(ImmutableList<ProducerTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordMethod(startedNanos, durationNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+        }
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSuccess(latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+        }
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordFailure(exception, latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+        }
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSkip(exception);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+        }
+      }
+    }
+  }
+
+  /** Returns a recorder factory that returns no-op component recorders. */
+  public static ProductionComponentTimingRecorder.Factory
+      noOpProductionComponentTimingRecorderFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY;
+  }
+
+  /** Returns a component recorder that returns no-op producer recorders. */
+  public static ProductionComponentTimingRecorder noOpProductionComponentTimingRecorder() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER;
+  }
+
+  private static final ProductionComponentTimingRecorder.Factory
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY =
+          new ProductionComponentTimingRecorder.Factory() {
+            @Override
+            public ProductionComponentTimingRecorder create(Object component) {
+              return noOpProductionComponentTimingRecorder();
+            }
+          };
+
+  private static final ProductionComponentTimingRecorder
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER =
+          new ProductionComponentTimingRecorder() {
+            @Override
+            public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+              return ProducerTimingRecorder.noOp();
+            }
+          };
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentTimingRecorder.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.Factory.create on"
+            + " factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerTimingRecorderForException(
+      RuntimeException e, ProductionComponentTimingRecorder recorder, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.producerTimingRecorderFor"
+            + "on recorder "
+            + recorder
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerTimingRecorderMethodException(
+      RuntimeException e, ProducerTimingRecorder recorder, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerTimingRecorder."
+            + method
+            + " on recorder "
+            + recorder,
+        e);
+  }
+
+  private TimingRecorders() {}
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
new file mode 100644
index 000000000..2a76c5f71
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.inject.Provider;
+
+/**
+ * A class that provides a {@link ProductionComponentMonitor} for use in production components.
+ *
+ * <p>This caches the underlying the monitor, since we want a single instance for each component.
+ */
+public final class MonitorCache {
+  private static final Logger logger = Logger.getLogger(MonitorCache.class.getName());
+
+  private volatile ProductionComponentMonitor monitor;
+
+  /**
+   * Returns the underlying monitor. This will only actually compute the monitor the first time it
+   * is called; subsequent calls will simply return the cached value, so the arguments to this
+   * method are ignored. It is expected (though not checked) that this method is called with
+   * equivalent arguments each time (like a {@link dagger.Provides @Provides} method would).
+   */
+  public ProductionComponentMonitor monitor(
+      Provider<?> componentProvider,
+      Provider<Set<ProductionComponentMonitor.Factory>> monitorFactorySetProvider) {
+    ProductionComponentMonitor result = monitor;
+    if (result == null) {
+      synchronized (this) {
+        result = monitor;
+        if (result == null) {
+          try {
+            ProductionComponentMonitor.Factory factory =
+                Monitors.delegatingProductionComponentMonitorFactory(
+                    monitorFactorySetProvider.get());
+            result = monitor = factory.create(componentProvider.get());
+          } catch (RuntimeException e) {
+            logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
+            result = monitor = Monitors.noOpProductionComponentMonitor();
+          }
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
new file mode 100644
index 000000000..d0ff778f0
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.inject.Provider;
+
+/**
+ * Utility methods relating to monitoring, for use in generated producers code.
+ *
+ * @author Jesse Beder
+ */
+public final class Monitors {
+  private static final Logger logger = Logger.getLogger(Monitors.class.getName());
+
+  /**
+   * Returns a monitor factory that delegates to the given factories, and ensures that any method
+   * called on this object, even transitively, does not throw a {@link RuntimeException} or return
+   * null.
+   *
+   * <p>If the delegate monitors throw an {@link Error}, then that will escape this monitor
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(
+      Collection<? extends ProductionComponentMonitor.Factory> factories) {
+    if (factories.isEmpty()) {
+      return noOpProductionComponentMonitorFactory();
+    } else if (factories.size() == 1) {
+      return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));
+    } else {
+      return new DelegatingProductionComponentMonitor.Factory(factories);
+    }
+  }
+
+  /**
+   * A component monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ProductionComponentMonitor delegate;
+
+    NonThrowingProductionComponentMonitor(ProductionComponentMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      try {
+        ProducerMonitor monitor = delegate.producerMonitorFor(token);
+        return monitor == null ? noOpProducerMonitor() : new NonThrowingProducerMonitor(monitor);
+      } catch (RuntimeException e) {
+        logProducerMonitorForException(e, delegate, token);
+        return noOpProducerMonitor();
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ProductionComponentMonitor.Factory delegate;
+
+      Factory(ProductionComponentMonitor.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        try {
+          ProductionComponentMonitor monitor = delegate.create(component);
+          return monitor == null
+              ? noOpProductionComponentMonitor()
+              : new NonThrowingProductionComponentMonitor(monitor);
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return noOpProductionComponentMonitor();
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerMonitor extends ProducerMonitor {
+    private final ProducerMonitor delegate;
+
+    NonThrowingProducerMonitor(ProducerMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void requested() {
+      try {
+        delegate.requested();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "requested");
+      }
+    }
+
+    @Override
+    public void methodStarting() {
+      try {
+        delegate.methodStarting();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodStarting");
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      try {
+        delegate.methodFinished();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodFinished");
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      try {
+        delegate.succeeded(o);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      try {
+        delegate.failed(t);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "failed", t);
+      }
+    }
+  }
+
+  /**
+   * A component monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ImmutableList<ProductionComponentMonitor> delegates;
+
+    DelegatingProductionComponentMonitor(ImmutableList<ProductionComponentMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerMonitor> monitorsBuilder = ImmutableList.builder();
+      for (ProductionComponentMonitor delegate : delegates) {
+        try {
+          ProducerMonitor monitor = delegate.producerMonitorFor(token);
+          if (monitor != null) {
+            monitorsBuilder.add(monitor);
+          }
+        } catch (RuntimeException e) {
+          logProducerMonitorForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerMonitor> monitors = monitorsBuilder.build();
+      if (monitors.isEmpty()) {
+        return noOpProducerMonitor();
+      } else if (monitors.size() == 1) {
+        return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));
+      } else {
+        return new DelegatingProducerMonitor(monitors);
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ImmutableList<? extends ProductionComponentMonitor.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentMonitor.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        ImmutableList.Builder<ProductionComponentMonitor> monitorsBuilder = ImmutableList.builder();
+        for (ProductionComponentMonitor.Factory delegate : delegates) {
+          try {
+            ProductionComponentMonitor monitor = delegate.create(component);
+            if (monitor != null) {
+              monitorsBuilder.add(monitor);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentMonitor> monitors = monitorsBuilder.build();
+        if (monitors.isEmpty()) {
+          return noOpProductionComponentMonitor();
+        } else if (monitors.size() == 1) {
+          return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));
+        } else {
+          return new DelegatingProductionComponentMonitor(monitors);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerMonitor extends ProducerMonitor {
+    private final ImmutableList<ProducerMonitor> delegates;
+
+    DelegatingProducerMonitor(ImmutableList<ProducerMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void requested() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.requested();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "requested");
+        }
+      }
+    }
+
+    @Override
+    public void methodStarting() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.methodStarting();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodStarting");
+        }
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.methodFinished();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodFinished");
+        }
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.succeeded(o);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+        }
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.failed(t);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "failed", t);
+        }
+      }
+    }
+  }
+
+  /** Returns a monitor factory that returns no-op component monitors. */
+  public static ProductionComponentMonitor.Factory noOpProductionComponentMonitorFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY;
+  }
+
+  /** Returns a component monitor that returns no-op producer monitors. */
+  public static ProductionComponentMonitor noOpProductionComponentMonitor() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR;
+  }
+
+  /** Returns a producer monitor that does nothing. */
+  public static ProducerMonitor noOpProducerMonitor() {
+    return NO_OP_PRODUCER_MONITOR;
+  }
+
+  /** Returns a provider of a no-op component monitor. */
+  public static Provider<ProductionComponentMonitor> noOpProductionComponentMonitorProvider() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER;
+  }
+
+  private static final ProductionComponentMonitor.Factory
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY =
+          new ProductionComponentMonitor.Factory() {
+            @Override
+            public ProductionComponentMonitor create(Object component) {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
+  private static final ProductionComponentMonitor NO_OP_PRODUCTION_COMPONENT_MONITOR =
+      new ProductionComponentMonitor() {
+        @Override
+        public ProducerMonitor producerMonitorFor(ProducerToken token) {
+          return noOpProducerMonitor();
+        }
+      };
+
+  private static final ProducerMonitor NO_OP_PRODUCER_MONITOR =
+      new ProducerMonitor() {
+        @Override
+        public <T> void addCallbackTo(ListenableFuture<T> future) {
+          // overridden to avoid adding a do-nothing callback
+        }
+      };
+
+  private static final Provider<ProductionComponentMonitor>
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER =
+          new Provider() {
+            @Override
+            public ProductionComponentMonitor get() {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.Factory.create on factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerMonitorForException(
+      RuntimeException e, ProductionComponentMonitor monitor, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.producerMonitorFor on monitor "
+            + monitor
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerMonitorMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor." + method + " on monitor " + monitor,
+        e);
+  }
+
+  private static void logProducerMonitorArgMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method, Object arg) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor."
+            + method
+            + " on monitor "
+            + monitor
+            + " with "
+            + arg,
+        e);
+  }
+
+  private Monitors() {}
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/package-info.java b/producers/src/main/java/dagger/producers/monitoring/package-info.java
new file mode 100644
index 000000000..d10408706
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/package-info.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package provides hooks for monitoring producers.
+ *
+ * <p>The interfaces in this package are not stable. Do not use these interfaces unless you are
+ * prepared to be broken.
+ */
+package dagger.producers.monitoring;
diff --git a/producers/src/test/java/dagger/producers/ProducedTest.java b/producers/src/test/java/dagger/producers/ProducedTest.java
new file mode 100644
index 000000000..165e7301c
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/ProducedTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.testing.EqualsTester;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Produced}.
+ */
+@RunWith(JUnit4.class)
+public class ProducedTest {
+  @Test public void successfulProduced() throws ExecutionException {
+    Object o = new Object();
+    assertThat(Produced.successful(5).get()).isEqualTo(5);
+    assertThat(Produced.successful("monkey").get()).isEqualTo("monkey");
+    assertThat(Produced.successful(o).get()).isSameAs(o);
+  }
+
+  @Test public void failedProduced() {
+    RuntimeException cause = new RuntimeException("monkey");
+    try {
+      Produced.failed(cause).get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+
+  @Test public void producedEquivalence() {
+    RuntimeException e1 = new RuntimeException("monkey");
+    RuntimeException e2 = new CancellationException();
+    new EqualsTester()
+        .addEqualityGroup(Produced.successful(132435), Produced.successful(132435))
+        .addEqualityGroup(Produced.successful("hi"), Produced.successful("hi"))
+        .addEqualityGroup(Produced.failed(e1), Produced.failed(e1))
+        .addEqualityGroup(Produced.failed(e2), Produced.failed(e2))
+        .testEquals();
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index e307166f5..6cb6bdbcc 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -17,25 +17,54 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
-  @Test public void get_nullPointerException() {
-    Producer<Object> producer = new AbstractProducer<Object>() {
-      @Override public ListenableFuture<Object> compute() {
-        return null;
-      }
-    };
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void get_nullPointerException() {
+    Producer<Object> producer = new DelegateProducer<>(componentMonitorProvider, null);
     try {
       producer.get();
       fail();
@@ -44,15 +73,74 @@
   }
 
   @Test public void get() throws Exception {
-    Producer<Integer> producer = new AbstractProducer<Integer>() {
-      int i = 0;
+    Producer<Integer> producer =
+        new AbstractProducer<Integer>(componentMonitorProvider, null) {
+          int i = 0;
 
-      @Override public ListenableFuture<Integer> compute() {
-        return Futures.immediateFuture(i++);
-      }
-    };
+          @Override
+          public ListenableFuture<Integer> compute(ProducerMonitor unusedMonitor) {
+            return Futures.immediateFuture(i++);
+          }
+        };
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
   }
+
+  @Test
+  public void monitor_success() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).requested();
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    delegateFuture.set(-42);
+    assertThat(future.get()).isEqualTo(-42);
+    verify(monitor).succeeded(-42);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test
+  public void monitor_failure() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).requested();
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    Throwable t = new RuntimeException("monkey");
+    delegateFuture.setException(t);
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+    }
+    verify(monitor).failed(t);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void monitor_null() throws Exception {
+    new DelegateProducer<>(null, Futures.immediateFuture(42));
+  }
+
+  static final class DelegateProducer<T> extends AbstractProducer<T> {
+    private final ListenableFuture<T> delegate;
+
+    DelegateProducer(
+        Provider<ProductionComponentMonitor> componentMonitorProvider,
+        ListenableFuture<T> delegate) {
+      super(componentMonitorProvider, null);
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+      return delegate;
+    }
+  }
 }
diff --git a/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
new file mode 100644
index 000000000..95d110da4
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import dagger.producers.Producer;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class MapOfProducerProducerTest {
+  @Test
+  public void success() throws Exception {
+    MapOfProducerProducer<Integer, String> mapOfProducerProducer =
+        MapOfProducerProducer.<Integer, String>builder(2)
+            .put(15, Producers.<String>immediateProducer("fifteen"))
+            .put(42, Producers.<String>immediateProducer("forty two"))
+            .build();
+    Map<Integer, Producer<String>> map = mapOfProducerProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+  }
+
+  @Test
+  public void failingContributionDoesNotFailMap() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    MapOfProducerProducer<Integer, String> mapOfProducerProducer =
+        MapOfProducerProducer.<Integer, String>builder(2)
+            .put(15, Producers.<String>immediateProducer("fifteen"))
+            .put(42, Producers.<String>immediateFailedProducer(cause))
+            .build();
+    Map<Integer, Producer<String>> map = mapOfProducerProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    try {
+      map.get(42).get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/MapProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
new file mode 100644
index 000000000..7ede26921
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.producers.Producer;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class MapProducerTest {
+  @Test
+  public void success() throws Exception {
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateProducer(
+                ImmutableMap.<Integer, Producer<String>>of(
+                    15,
+                    Producers.<String>immediateProducer("fifteen"),
+                    42,
+                    Producers.<String>immediateProducer("forty two"))));
+    Map<Integer, String> map = mapProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry(15, "fifteen");
+    assertThat(map).containsEntry(42, "forty two");
+  }
+
+  @Test
+  public void failingContribution() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateProducer(
+                ImmutableMap.<Integer, Producer<String>>of(
+                    15,
+                    Producers.<String>immediateProducer("fifteen"),
+                    42,
+                    Producers.<String>immediateFailedProducer(cause))));
+    try {
+      mapProducer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+
+  @Test
+  public void failingInput() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateFailedProducer(cause));
+    try {
+      mapProducer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index 43564089f..e2707b342 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -17,12 +17,10 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Provider;
@@ -98,16 +96,6 @@
     }
   }
 
-  @Test public void submitToExecutor() throws Exception {
-    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
-      @Override public Integer call() {
-        return 42;
-      }
-    }, MoreExecutors.directExecutor());
-    assertThat(future.isDone()).isTrue();
-    assertThat(future.get()).isEqualTo(42);
-  }
-
   @Test public void producerFromProvider() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
new file mode 100644
index 000000000..e36ba05a4
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Tests {@link SetOfProducedProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetOfProducedProducerTest {
+  @Test
+  public void success() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1),
+            Produced.successful(2),
+            Produced.successful(5),
+            Produced.successful(7));
+  }
+
+  @Test
+  public void failure() throws Exception {
+    RuntimeException e = new RuntimeException("monkey");
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateFailedProducer(e));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1), Produced.successful(2), Produced.<Integer>failed(e));
+  }
+
+  @Test
+  public void delegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(Producers.<Set<Integer>>immediateProducer(null));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(null),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(7, 3)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(3, 7);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void delegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Sets.newHashSet(Arrays.asList(5, 2, null))));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(2, 5);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  static final class Results<T> {
+    final ImmutableSet<T> successes;
+    final ImmutableSet<ExecutionException> failures;
+
+    private Results(ImmutableSet<T> successes, ImmutableSet<ExecutionException> failures) {
+      this.successes = successes;
+      this.failures = failures;
+    }
+
+    static <T> Results<T> create(Set<Produced<T>> setOfProduced) {
+      ImmutableSet.Builder<T> successes = ImmutableSet.builder();
+      ImmutableSet.Builder<ExecutionException> failures = ImmutableSet.builder();
+      for (Produced<T> produced : setOfProduced) {
+        try {
+          successes.add(produced.get());
+        } catch (ExecutionException e) {
+          failures.add(e);
+        }
+      }
+      return new Results<T>(successes.build(), failures.build());
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index 1f8ff7c3a..a38830f0a 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -16,7 +16,6 @@
 package dagger.producers.internal;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import java.util.Collections;
@@ -35,16 +34,18 @@
 @RunWith(JUnit4.class)
 public class SetProducerTest {
   @Test public void success() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(5, 7)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
     assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
   }
 
   @Test public void delegateSetNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(null));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(null));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -55,10 +56,10 @@
   }
 
   @Test public void delegateElementNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(
-            Collections.<Integer>singleton(null)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -67,16 +68,4 @@
       assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
     }
   }
-
-  private static final class ImmediateProducer<T> implements Producer<T> {
-    private final T value;
-
-    ImmediateProducer(T value) {
-      this.value = value;
-    }
-
-    @Override public ListenableFuture<T> get() {
-      return Futures.immediateFuture(value);
-    }
-  }
 }
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
new file mode 100644
index 000000000..bceecf1aa
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.testing.FakeTicker;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingProductionComponentMonitorTest {
+  private static final class ProducerClassA {}
+
+  private static final class ProducerClassB {}
+
+  @Mock private ProductionComponentTimingRecorder.Factory productionComponentTimingRecorderFactory;
+  @Mock private ProductionComponentTimingRecorder productionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder producerTimingRecorderA;
+  @Mock private ProducerTimingRecorder producerTimingRecorderB;
+
+  private FakeTicker ticker;
+  private ProductionComponentMonitor.Factory monitorFactory;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(productionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(productionComponentTimingRecorder);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassA.class)))
+        .thenReturn(producerTimingRecorderA);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassB.class)))
+        .thenReturn(producerTimingRecorderB);
+    ticker = new FakeTicker();
+    monitorFactory =
+        new TimingProductionComponentMonitor.Factory(
+            productionComponentTimingRecorderFactory, ticker);
+  }
+
+  @Test
+  public void normalExecution_success() {
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.succeeded(new Object());
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.succeeded(new Object());
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordSuccess(1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordSuccess(2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+
+  @Test
+  public void normalExecution_failure() {
+    Throwable failureA = new RuntimeException("monkey");
+    Throwable failureB = new RuntimeException("gorilla");
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.failed(failureA);
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.failed(failureB);
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordFailure(failureA, 1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordFailure(failureB, 2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
new file mode 100644
index 000000000..cf54d9670
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingRecordersTest {
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroRecordersReturnsNoOp() {
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.<ProductionComponentTimingRecorder.Factory>of());
+    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());
+  }
+
+  @Test
+  public void singleRecorder_nullProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_nullProducerTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderFailure() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordFailure(t, 100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_throwingProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordSuccess(any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void multipleRecorders_nullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_someNullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {
+    setUpNormalMultipleRecorders();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {
+    setUpNormalMultipleRecorders();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderA)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderB)
+        .recordSuccess(any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderC)
+        .recordMethod(any(Long.class), any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  private void setUpNormalSingleRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorder);
+  }
+
+  private void setUpNormalMultipleRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderB);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderC);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderB);
+    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderC);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
new file mode 100644
index 000000000..224d8e0b6
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -0,0 +1,485 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class MonitorsTest {
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactory;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitor;
+  @Mock private ProducerMonitor mockProducerMonitor;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryA;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryB;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryC;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorA;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorB;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorC;
+  @Mock private ProducerMonitor mockProducerMonitorA;
+  @Mock private ProducerMonitor mockProducerMonitorB;
+  @Mock private ProducerMonitor mockProducerMonitorC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroMonitorsReturnsNoOp() {
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.<ProductionComponentMonitor.Factory>of());
+    assertThat(factory).isSameAs(Monitors.noOpProductionComponentMonitorFactory());
+  }
+
+  @Test
+  public void singleMonitor_nullProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitorFactory() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactory)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void singleMonitor_nullProducerMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitor)
+        .producerMonitorFor(any(ProducerToken.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).requested();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).requested();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("gorilla");
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).requested();
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void multipleMonitors_nullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void multipleMonitors_throwingProductionComponentMonitorFactories() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryA)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void multipleMonitors_someNullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProductionComponentMonitorFactories() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorSuccess() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorFailure() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).requested();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsFailure() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).requested();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.requested();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).requested();
+    order.verify(mockProducerMonitorB).requested();
+    order.verify(mockProducerMonitorC).requested();
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  private void setUpNormalSingleMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitor);
+  }
+
+  private void setUpNormalMultipleMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorB);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorC);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    when(mockProductionComponentMonitorB.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorB);
+    when(mockProductionComponentMonitorC.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorC);
+  }
+}
