diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index f5b42d6c9..ab8d9a4ed 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -84,6 +84,8 @@ java_library(
         "ContributionType.java",
         "DaggerElements.java",
         "DaggerStatistics.java",
+        "DaggerStatisticsCollector.java",
+        "DaggerStatisticsRecorder.java",
         "DaggerTypes.java",
         "DiagnosticFormatting.java",
         "Expression.java",
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index e21453dc4..fa030534f 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -54,7 +54,7 @@
   @Inject ImmutableList<ProcessingStep> processingSteps;
   @Inject BindingGraphPlugins bindingGraphPlugins;
   @Inject CompilerOptions compilerOptions;
-  @Inject DaggerStatistics daggerStatistics;
+  @Inject DaggerStatisticsCollector statisticsCollector;
 
   // TODO(ronshapiro): inject a multibinding for all instances that retain caches?
   @Inject ModuleDescriptor.Factory moduleDescriptorFactory;
@@ -110,7 +110,7 @@ public SourceVersion getSupportedSourceVersion() {
         .build()
         .inject(this);
 
-    daggerStatistics.processingStarted();
+    statisticsCollector.processingStarted();
     bindingGraphPlugins.initializePlugins();
     return processingSteps;
   }
@@ -183,7 +183,7 @@ Builder testingPlugins(
   @Override
   protected void postRound(RoundEnvironment roundEnv) {
     if (roundEnv.processingOver()) {
-      daggerStatistics.processingStopped();
+      statisticsCollector.processingStopped();
     } else {
       try {
         injectBindingRegistry.generateSourcesForRequiredBindings(
diff --git a/java/dagger/internal/codegen/DaggerStatistics.java b/java/dagger/internal/codegen/DaggerStatistics.java
index a103f0287..c6bd9a4f6 100644
--- a/java/dagger/internal/codegen/DaggerStatistics.java
+++ b/java/dagger/internal/codegen/DaggerStatistics.java
@@ -16,31 +16,17 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.base.Preconditions;
-import com.google.common.base.Stopwatch;
-import com.google.common.base.Ticker;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-@Singleton // for state sharing
-final class DaggerStatistics {
-
-  private final Stopwatch totalRuntimeStopwatch;
-
-  @Inject
-  DaggerStatistics(
-      Ticker ticker) {
-    totalRuntimeStopwatch = Stopwatch.createUnstarted(ticker);
+import com.google.auto.value.AutoValue;
+import java.time.Duration;
+
+/** Statistics collected over the course of Dagger annotation processing. */
+@AutoValue
+abstract class DaggerStatistics {
+  /** Creates a new {@link DaggerStatistics}. */
+  static DaggerStatistics create(Duration totalProcessingTime) {
+    return new AutoValue_DaggerStatistics(totalProcessingTime);
   }
 
-  void processingStarted() {
-    Preconditions.checkState(!totalRuntimeStopwatch.isRunning());
-    totalRuntimeStopwatch.start();
-  }
-
-  void processingStopped() {
-    Preconditions.checkState(totalRuntimeStopwatch.isRunning());
-    totalRuntimeStopwatch.stop();
-
-  }
+  /** Total time spent in Dagger annotation processing. */
+  abstract Duration totalProcessingTime();
 }
diff --git a/java/dagger/internal/codegen/DaggerStatisticsCollector.java b/java/dagger/internal/codegen/DaggerStatisticsCollector.java
new file mode 100644
index 000000000..5ccafe0dd
--- /dev/null
+++ b/java/dagger/internal/codegen/DaggerStatisticsCollector.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+import java.time.Duration;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/** Collects {@link DaggerStatistics} over the course of Dagger annotation processing. */
+@Singleton // for state sharing
+final class DaggerStatisticsCollector {
+
+  private final Stopwatch totalRuntimeStopwatch;
+  private final Optional<DaggerStatisticsRecorder> statisticsRecorder;
+
+  @Inject
+  DaggerStatisticsCollector(Ticker ticker, Optional<DaggerStatisticsRecorder> statisticsRecorder) {
+    this.totalRuntimeStopwatch = Stopwatch.createUnstarted(ticker);
+    this.statisticsRecorder = statisticsRecorder;
+  }
+
+  /** Called when Dagger annotation processing starts. */
+  void processingStarted() {
+    checkState(!totalRuntimeStopwatch.isRunning());
+    totalRuntimeStopwatch.start();
+  }
+
+  /** Called when Dagger annotation processing completes. */
+  void processingStopped() {
+    checkState(totalRuntimeStopwatch.isRunning());
+    totalRuntimeStopwatch.stop();
+
+    statisticsRecorder.ifPresent(
+        recorder -> {
+          DaggerStatistics statistics = DaggerStatistics.create(elapsedTime(totalRuntimeStopwatch));
+          recorder.recordStatistics(statistics);
+        });
+  }
+
+  @SuppressWarnings("StopwatchNanosToDuration") // intentional
+  private Duration elapsedTime(Stopwatch stopwatch) {
+    // Using the java 7 method here as opposed to the Duration-returning version to avoid issues
+    // when other annotation processors rely on java 7's guava
+    return Duration.ofNanos(stopwatch.elapsed(NANOSECONDS));
+  }
+}
diff --git a/java/dagger/internal/codegen/DaggerStatisticsRecorder.java b/java/dagger/internal/codegen/DaggerStatisticsRecorder.java
new file mode 100644
index 000000000..66f41d110
--- /dev/null
+++ b/java/dagger/internal/codegen/DaggerStatisticsRecorder.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+/** Records collected {@link DaggerStatistics}. */
+interface DaggerStatisticsRecorder {
+  /** Records the given {@code statistics}. */
+  void recordStatistics(DaggerStatistics statistics);
+}
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
index fb4efb793..b5cbc81ba 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -23,6 +23,7 @@
 import dagger.Provides;
 import dagger.Reusable;
 import java.util.Map;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -79,4 +80,9 @@ DaggerElements daggerElements() {
   CompilerOptions compilerOptions() {
     return CompilerOptions.create(processingEnvironment);
   }
+
+  @Provides
+  Optional<DaggerStatisticsRecorder> daggerStatisticsRecorder() {
+    return Optional.empty();
+  }
 }
