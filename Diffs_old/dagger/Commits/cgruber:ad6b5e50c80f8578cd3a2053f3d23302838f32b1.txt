diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index b66d7e3c2..7053e2742 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -104,14 +104,14 @@
    */
   abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
 
-  /** The package in which each {@link FrameworkKey} initialization must happen.  */
-  abstract ImmutableSetMultimap<String, FrameworkKey> initializationByPackage();
+  /** The package in which each {@link Key} initialization must happen.  */
+  abstract ImmutableSetMultimap<String, Key> initializationByPackage();
 
   /**
-   * The ordering of {@link FrameworkKey keys} that will allow all of the {@link Factory} and
+   * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
    * {@link MembersInjector} implementations to initialize properly.
    */
-  abstract ImmutableList<FrameworkKey> initializationOrdering();
+  abstract ImmutableList<Key> initializationOrdering();
 
   static final class Factory {
     private final Elements elements;
@@ -228,7 +228,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
           ImmutableSetMultimap.builder();
       ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
           ImmutableMap.builder();
-      SetMultimap<FrameworkKey, Binding> resolvedBindings =
+      SetMultimap<Key, Binding> resolvedBindings =
           MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
 
       ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
@@ -238,9 +238,9 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
             resolvedProvisionBindings, resolvedMembersInjectionBindings);
       }
 
-      ImmutableSetMultimap.Builder<String, FrameworkKey> initializationByPackageBuilder =
+      ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
           ImmutableSetMultimap.builder();
-      for (Entry<FrameworkKey, Binding> resolvedBindingEntry : resolvedBindings.entries()) {
+      for (Entry<Key, Binding> resolvedBindingEntry : resolvedBindings.entries()) {
         initializationByPackageBuilder.put(
             resolvedBindingEntry.getValue().bindingPackage().or(
                   MoreElements.getPackage(componentDefinitionType).getQualifiedName().toString()),
@@ -261,13 +261,12 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
 
     private void resolveRequest(DependencyRequest request,
         ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-        SetMultimap<FrameworkKey, Binding> resolvedBindings,
+        SetMultimap<Key, Binding> resolvedBindings,
         ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
         ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindingsBuilder)
             throws SourceFileGenerationException {
-      FrameworkKey frameworkKey = request.frameworkKey();
       Key requestKey = request.key();
-      if (resolvedBindings.containsKey(frameworkKey)) {
+      if (resolvedBindings.containsKey(requestKey)) {
         return;
       }
       switch (request.kind()) {
@@ -288,7 +287,7 @@ private void resolveRequest(DependencyRequest request,
               resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
                   explicitBindings, resolvedBindings, resolvedProvisionsBindingBuilder,
                   resolvedMembersInjectionBindingsBuilder);
-              resolvedBindings.put(frameworkKey, implicitBinding);
+              resolvedBindings.put(requestKey, implicitBinding);
               resolvedProvisionsBindingBuilder.put(request.key(), implicitBinding);
             } else {
               // no explicit binding, look it up
@@ -304,7 +303,7 @@ private void resolveRequest(DependencyRequest request,
                 resolveRequest(dependency, explicitBindings, resolvedBindings,
                     resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
               }
-              resolvedBindings.put(frameworkKey, provisionBinding.get());
+              resolvedBindings.put(requestKey, provisionBinding.get());
               resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
             }
           } else {
@@ -315,7 +314,7 @@ private void resolveRequest(DependencyRequest request,
                     resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
               }
             }
-            resolvedBindings.putAll(frameworkKey, explicitBindingsForKey);
+            resolvedBindings.putAll(requestKey, explicitBindingsForKey);
             resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
           }
           break;
@@ -330,7 +329,7 @@ private void resolveRequest(DependencyRequest request,
             resolveRequest(dependency, explicitBindings, resolvedBindings,
                 resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
           }
-          resolvedBindings.put(frameworkKey, membersInjectionBinding);
+          resolvedBindings.put(requestKey, membersInjectionBinding);
           resolvedMembersInjectionBindingsBuilder.put(requestKey, membersInjectionBinding);
           break;
         default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 82f23237a..6cd17baf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -33,7 +33,6 @@
 import dagger.Component;
 import dagger.Factory;
 import dagger.MapKey;
-import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
@@ -61,7 +60,6 @@
 import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -217,10 +215,10 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
     }
 
-    ImmutableMap.Builder<FrameworkKey, Snippet> memberSelectSnippetsBuilder =
+    ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<String, Set<FrameworkKey>> packageEntry :
+    for (Entry<String, Set<Key>> packageEntry :
         Multimaps.asMap(input.initializationByPackage()).entrySet()) {
       String packageName = packageEntry.getKey();
 
@@ -256,19 +254,21 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         fieldModifiers = EnumSet.of(PUBLIC);
       }
 
-      for (FrameworkKey frameworkKey : packageEntry.getValue()) {
-        Key key = frameworkKey.key();
+      for (Key key : packageEntry.getValue()) {
         TypeName frameworkTypeName = ParameterizedTypeName.create(
-            ClassName.fromClass(frameworkKey.frameworkClass()),
+            ClassName.fromClass(key.kind().frameworkClass()),
             TypeNames.forTypeMirror(key.type()));
 
         final String fieldName;
-        if (frameworkKey.frameworkClass().equals(Provider.class)) {
-          fieldName = providerNames.get(key);
-        } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
-          fieldName = membersInjectorNames.get(key);
-        } else {
-          throw new IllegalStateException();
+        switch (key.kind()) {
+          case PROVIDER:
+            fieldName = providerNames.get(key);
+            break;
+          case MEMBERS_INJECTOR:
+            fieldName = membersInjectorNames.get(key);
+            break;
+          default:
+            throw new AssertionError();
         }
 
         FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
@@ -278,7 +278,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
             .addAll(proxySelector.asSet())
             .add(frameworkField.name())
             .build();
-        memberSelectSnippetsBuilder.put(frameworkKey,
+        memberSelectSnippetsBuilder.put(key,
             Snippet.memberSelectSnippet(memberSelectTokens));
       }
     }
@@ -292,64 +292,63 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
+    ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    List<List<FrameworkKey>> partitions = Lists.partition(input.initializationOrdering(), 100);
+    List<List<Key>> partitions = Lists.partition(input.initializationOrdering(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
       initializeMethod.addModifiers(PRIVATE);
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
-      for (FrameworkKey frameworkKey : partitions.get(i)) {
-        Key key = frameworkKey.key();
-        Snippet memberSelectSnippet = memberSelectSnippets.get(frameworkKey);
-
-        if (frameworkKey.frameworkClass().equals(Provider.class)) {
-          Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
-          BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
-          switch (bindingsType) {
-            case SET:
-              ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
-              for (ProvisionBinding binding : bindings) {
-                setFactoryParameters.add(initializeFactoryForBinding(binding,
-                    input.dependencyMethodIndex(), componentContributionFields,
-                    memberSelectSnippets));
-              }
-              Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                  ClassName.fromClass(SetFactory.class),
-                  Snippet.makeParametersSnippet(setFactoryParameters.build()));
-              initializeMethod.body().addSnippet("this.%s = %s;",
-                  memberSelectSnippet, initializeSetSnippet);
-              break;
-            case MAP:
-              if (!bindings.isEmpty()) {
-                Snippet initializeMapSnippet =
-                    initializeMapBinding(componentContributionFields, input.dependencyMethodIndex(),
-                        memberSelectSnippets, bindings);
+      for (Key key : partitions.get(i)) {
+        Snippet memberSelectSnippet = memberSelectSnippets.get(key);
+        switch (key.kind()) {
+          case PROVIDER:
+            Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+            BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
+            switch (bindingsType) {
+              case SET:
+                ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
+                for (ProvisionBinding binding : bindings) {
+                  setFactoryParameters.add(initializeFactoryForBinding(binding,
+                      input.dependencyMethodIndex(), componentContributionFields,
+                      memberSelectSnippets));
+                }
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    ClassName.fromClass(SetFactory.class),
+                    Snippet.makeParametersSnippet(setFactoryParameters.build()));
                 initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeMapSnippet);
-              }
-              break;
-            case UNIQUE:
-              ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-              initializeMethod.body().addSnippet("this.%s = %s;",
-                  memberSelectSnippet,
-                  initializeFactoryForBinding(binding, input.dependencyMethodIndex(),
-                      componentContributionFields, memberSelectSnippets));
-              break;
-            default:
-              throw new IllegalStateException();
-          }
-        } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
-          MembersInjectionBinding binding = resolvedMembersInjectionBindings.get(key);
-          initializeMethod.body().addSnippet("this.%s = %s;",
-              memberSelectSnippet,
-              initializeMembersInjectorForBinding(binding,
-                  memberSelectSnippets));
-        } else {
-          throw new IllegalStateException(
-              "unknown framework class: " + frameworkKey.frameworkClass());
+                    memberSelectSnippet, initializeSetSnippet);
+                break;
+              case MAP:
+                if (!bindings.isEmpty()) {
+                  Snippet initializeMapSnippet =
+                      initializeMapBinding(componentContributionFields,
+                          input.dependencyMethodIndex(), memberSelectSnippets, bindings);
+                  initializeMethod.body().addSnippet("this.%s = %s;",
+                      memberSelectSnippet, initializeMapSnippet);
+                }
+                break;
+              case UNIQUE:
+                ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet,
+                    initializeFactoryForBinding(binding, input.dependencyMethodIndex(),
+                        componentContributionFields, memberSelectSnippets));
+                break;
+              default:
+                throw new IllegalStateException();
+            }
+            break;
+          case MEMBERS_INJECTOR:
+            MembersInjectionBinding binding = resolvedMembersInjectionBindings.get(key);
+            initializeMethod.body().addSnippet("this.%s = %s;",
+                memberSelectSnippet,
+                initializeMembersInjectorForBinding(binding, memberSelectSnippets));
+            break;
+          default:
+            throw new AssertionError();
         }
       }
     }
@@ -362,9 +361,9 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                   requestElement.getSimpleName().toString());
       interfaceMethod.annotate(Override.class);
       interfaceMethod.addModifiers(PUBLIC);
-      FrameworkKey frameworkKey = interfaceRequest.frameworkKey();
+      Key key = interfaceRequest.key();
       if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        Snippet membersInjectorName = memberSelectSnippets.get(frameworkKey);
+        Snippet membersInjectorName = memberSelectSnippets.get(key);
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
         interfaceMethod.addParameter(
@@ -376,7 +375,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         }
       } else {
         interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(memberSelectSnippets.get(frameworkKey),
+            frameworkTypeUsageStatement(memberSelectSnippets.get(key),
                 interfaceRequest.kind()));
       }
     }
@@ -390,7 +389,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
@@ -413,7 +412,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       }
       if (binding.memberInjectionRequest().isPresent()) {
         Snippet snippet = memberSelectSnippets.get(
-            binding.memberInjectionRequest().get().frameworkKey());
+            binding.memberInjectionRequest().get().key());
         if (snippet != null) {
           parameters.add(snippet);
         } else {
@@ -434,14 +433,14 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
     if (binding.injectionSites().isEmpty()) {
       if (binding.parentInjectorRequest().isPresent()) {
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
             memberSelectSnippets.get(
-                parentInjectorRequest.frameworkKey()));
+                parentInjectorRequest.key()));
       } else {
         return Snippet.format("%s.noOp()",
             ClassName.fromClass(MembersInjectors.class));
@@ -457,10 +456,10 @@ private static Snippet initializeMembersInjectorForBinding(
   }
 
   private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
-      parameters.add(memberSelectSnippets.get(dependency.frameworkKey()));
+      parameters.add(memberSelectSnippets.get(dependency.key()));
     }
     return parameters.build();
   }
@@ -468,7 +467,7 @@ private static Snippet initializeMembersInjectorForBinding(
   private Snippet initializeMapBinding(
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets,
+      ImmutableMap<Key, Snippet> memberSelectSnippets,
       Set<ProvisionBinding> bindings) {
     Iterator<ProvisionBinding> iterator = bindings.iterator();
     // get type information from first binding in iterator
@@ -476,8 +475,7 @@ private Snippet initializeMapBinding(
     if (isNonProviderMap(firstBinding)) {
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies())
-              .frameworkKey()));
+          memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
     } else {
       DeclaredType declaredMapType =
           Util.getDeclaredTypeOfMap(firstBinding.providedKey().type());
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index feef7e2a4..cad93e194 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -65,24 +65,6 @@
   abstract Key key();
   abstract Element requestElement();
 
-  FrameworkKey frameworkKey() {
-    final Class<?> frameworkClass;
-    switch (kind()) {
-      case INSTANCE:
-      case LAZY:
-      case PROVIDER:
-        frameworkClass = Provider.class;
-        break;
-      case MEMBERS_INJECTOR:
-        checkArgument(key().isValidMembersInjectionKey());
-        frameworkClass = MembersInjector.class;
-        break;
-      default:
-        throw new AssertionError();
-    }
-    return FrameworkKey.create(this.key(), frameworkClass);
-  }
-
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -138,7 +120,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          keyFactory.forQualifiedType(qualifier,
+          keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod);
     }
@@ -146,7 +128,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
     DependencyRequest forMembersInjectedType(TypeElement type) {
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
           // TODO(gak): handle this better
-          keyFactory.forType(types.erasure(type.asType())),
+          keyFactory.forMembersInjectedType(types.erasure(type.asType())),
           type);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 884c2a6d1..99380a368 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -132,23 +132,26 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
+    ImmutableMap<Key, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+    for (Entry<Key, String> nameEntry : names.entrySet()) {
       final FieldWriter field;
-      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
-        ParameterizedTypeName providerType = ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = factoryWriter.addField(providerType, nameEntry.getValue());
-      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
-        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
-      } else {
-        throw new IllegalStateException();
+      switch (nameEntry.getKey().kind()) {
+        case PROVIDER:
+          ParameterizedTypeName providerType = ParameterizedTypeName.create(
+              ClassName.fromClass(Provider.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = factoryWriter.addField(providerType, nameEntry.getValue());
+          break;
+        case MEMBERS_INJECTOR:
+          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+              ClassName.fromClass(MembersInjector.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
+          break;
+        default:
+          throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
@@ -160,7 +163,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(names.get(dependency.frameworkKey())),
+          Snippet.format(names.get(dependency.key())),
           dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
deleted file mode 100644
index a8104979d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import dagger.MembersInjector;
-import javax.inject.Provider;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A value object that pairs a {@link Key} with a framework class (e.g.: {@link Provider},
- * {@link MembersInjector}) related to that key.
- *
- *  @author Gregory Kick
- *  @since 2.0
- */
-@AutoValue
-abstract class FrameworkKey {
-  static FrameworkKey create(Key key, Class<?> frameworkClass) {
-    return new AutoValue_FrameworkKey(checkNotNull(key), checkNotNull(frameworkClass));
-  }
-
-  static FrameworkKey forProvisionBinding(ProvisionBinding binding) {
-    return new AutoValue_FrameworkKey(binding.providedKey(), Provider.class);
-  }
-
-  abstract Key key();
-  abstract Class<?> frameworkClass();
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
index 03dee149f..83f0b27f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -150,14 +150,14 @@ void validateGraph(TypeElement component,
     }
 
     for (DependencyRequest componentMethodRequest : componentMethodRequests(component)) {
-      Deque<FrameworkKey> cycleStack = Queues.newArrayDeque();
+      Deque<Key> cycleStack = Queues.newArrayDeque();
       Deque<DependencyRequest> dependencyPath = Queues.newArrayDeque();
       resolveRequest(
           componentMethodRequest,
           componentMethodRequest,
           reportBuilder,
           explicitBindingsByKey(explicitBindingsBuilder.build()),
-          new LinkedHashSet<FrameworkKey>(),
+          new LinkedHashSet<Key>(),
           cycleStack,
           dependencyPath);
     }
@@ -193,13 +193,13 @@ private void resolveRequest(DependencyRequest request,
       DependencyRequest rootRequest,
       ValidationReport.Builder<TypeElement> reportBuilder,
       ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-      Set<FrameworkKey> resolvedBindings,
-      Deque<FrameworkKey> cycleStack,
+      Set<Key> resolvedBindings,
+      Deque<Key> cycleStack,
       Deque<DependencyRequest> dependencyPath) {
 
-    FrameworkKey frameworkKey = request.frameworkKey();
-    if (cycleStack.contains(frameworkKey) && !isComponent(frameworkKey.key().type())) {
-      resolvedBindings.add(frameworkKey); // it's present, but bad, and we report that.
+    Key requestKey = request.key();
+    if (cycleStack.contains(requestKey) && !isComponent(requestKey.type())) {
+      resolvedBindings.add(requestKey); // it's present, but bad, and we report that.
       dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
       dependencyPath.push(request); // add current request.
       dependencyPath.pollLast(); // strip off original request from the component method.
@@ -217,14 +217,13 @@ private void resolveRequest(DependencyRequest request,
 
       return;
     }
-    if (resolvedBindings.contains(frameworkKey)) {
+    if (resolvedBindings.contains(requestKey)) {
       return;
     }
 
     dependencyPath.push(request);
-    cycleStack.push(frameworkKey);
+    cycleStack.push(requestKey);
     try {
-      Key requestKey = request.key();
       switch (request.kind()) {
         case INSTANCE:
         case LAZY:
@@ -242,7 +241,7 @@ private void resolveRequest(DependencyRequest request,
               resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
                   rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
                   dependencyPath);
-              resolvedBindings.add(frameworkKey);
+              resolvedBindings.add(requestKey);
             } else {
               // no explicit binding, look it up or fail.
               Optional<ProvisionBinding> provisionBinding =
@@ -253,7 +252,7 @@ private void resolveRequest(DependencyRequest request,
                   resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
                       resolvedBindings, cycleStack, dependencyPath);
                 }
-                resolvedBindings.add(frameworkKey);
+                resolvedBindings.add(requestKey);
               }
             }
           } else {
@@ -282,7 +281,7 @@ private void resolveRequest(DependencyRequest request,
                     resolvedBindings, cycleStack, dependencyPath);
               }
             }
-            resolvedBindings.add(frameworkKey);
+            resolvedBindings.add(requestKey);
           }
           break;
         case MEMBERS_INJECTOR:
@@ -295,7 +294,7 @@ private void resolveRequest(DependencyRequest request,
               resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
                   resolvedBindings, cycleStack, dependencyPath);
             }
-            resolvedBindings.add(frameworkKey);
+            resolvedBindings.add(requestKey);
           }
           break;
         default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index bb3d2f4d0..42bda5e26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -95,7 +95,7 @@ void registerProvisionBinding(ProvisionBinding binding) {
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        keyFactory.forType(binding.bindingElement().asType()), binding);
+        keyFactory.forMembersInjectedType(binding.bindingElement().asType()), binding);
     checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
         previousValue);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index fcdefa7f7..4425324c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -19,10 +19,11 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
-import com.google.common.base.Objects;
+import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.MapKey;
+import dagger.MembersInjector;
 import dagger.Provides;
 import java.util.Map;
 import java.util.Set;
@@ -55,6 +56,29 @@
  */
 @AutoValue
 abstract class Key {
+  /**
+   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
+   * key is for a {@link Provider} or a {@link MembersInjector}.
+   */
+  enum Kind {
+    PROVIDER(Provider.class),
+    MEMBERS_INJECTOR(MembersInjector.class),
+    ;
+
+    private final Class<?> frameworkClass;
+
+    Kind(Class<?> frameworkClass) {
+      this.frameworkClass = frameworkClass;
+    }
+
+    Class<?> frameworkClass() {
+      return frameworkClass;
+    }
+  }
+
+  /** Returns the particular kind of this key. */
+  abstract Kind kind();
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -98,8 +122,9 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
 
   @Override
   public String toString() {
-    return Objects.toStringHelper(Key.class)
+    return MoreObjects.toStringHelper(Key.class)
         .omitNullValues()
+        .addValue(kind())
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
@@ -136,7 +161,8 @@ Key forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(componentMethod.getReturnType());
       Optional<AnnotationMirror> qualifier = getQualifier(componentMethod);
-      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+      return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+          MoreTypes.equivalence().wrap(returnType));
     }
 
     Key forProvidesMethod(ExecutableElement e) {
@@ -148,10 +174,12 @@ Key forProvidesMethod(ExecutableElement e) {
       Optional<AnnotationMirror> qualifier = getQualifier(e);
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(setType));
         case MAP:
           AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
           MapKey mapKey =
@@ -162,12 +190,14 @@ Key forProvidesMethod(ExecutableElement e) {
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType =
               types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(mapType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(mapType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(returnType));
         default:
           throw new AssertionError();
       }
@@ -179,24 +209,31 @@ Key forInjectConstructor(ExecutableElement e) {
       checkArgument(!getQualifier(e).isPresent());
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
-      return new AutoValue_Key(
+      return new AutoValue_Key(Kind.PROVIDER,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
     }
 
-    Key forType(TypeMirror type) {
-      return new AutoValue_Key(
+    Key forComponent(TypeMirror type) {
+      return new AutoValue_Key(Kind.PROVIDER,
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    Key forMembersInjectedType(TypeMirror type) {
+      return new AutoValue_Key(Kind.MEMBERS_INJECTOR,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
+      return new AutoValue_Key(Kind.PROVIDER,
+          rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     /**
      * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
-     * valid key can be inferred from the given key.  Specifically, if the key represents a 
+     * valid key can be inferred from the given key.  Specifically, if the key represents a
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
@@ -210,7 +247,8 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
               elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
           TypeMirror mapType = types.getDeclaredType(
               elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
-          return Optional.<Key>of(new AutoValue_Key(possibleMapKey.wrappedQualifier(),
+          return Optional.<Key>of(new AutoValue_Key(Kind.PROVIDER,
+              possibleMapKey.wrappedQualifier(),
               MoreTypes.equivalence().wrap(mapType)));
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 3b38b57d1..bf3b9635a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -128,27 +128,30 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
+    ImmutableMap<Key, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(
             ImmutableSet.copyOf(binding.dependencies()));
 
-    ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
+    ImmutableMap.Builder<Key, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+    for (Entry<Key, String> nameEntry : names.entrySet()) {
       final FieldWriter field;
-      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
-        ParameterizedTypeName providerType = ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = injectorWriter.addField(providerType, nameEntry.getValue());
-      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
-        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
-      } else {
-        throw new IllegalStateException();
+      switch (nameEntry.getKey().kind()) {
+        case PROVIDER:
+          ParameterizedTypeName providerType = ParameterizedTypeName.create(
+              ClassName.fromClass(Provider.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = injectorWriter.addField(providerType, nameEntry.getValue());
+          break;
+        case MEMBERS_INJECTOR:
+          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+              ClassName.fromClass(MembersInjector.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
+          break;
+        default:
+          throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
@@ -156,13 +159,13 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
       dependencyFieldsBuilder.put(nameEntry.getKey(), field);
     }
-    ImmutableMap<FrameworkKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<Key, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(fieldDependency.frameworkKey());
+          FieldWriter singleField = depedencyFields.get(fieldDependency.key());
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
               frameworkTypeUsageStatement(Snippet.format(singleField.name()),
@@ -172,7 +175,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
             FieldWriter field =
-            depedencyFields.get(methodDependency.frameworkKey());
+            depedencyFields.get(methodDependency.key());
             parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
                 methodDependency.kind()));
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index abb8f945d..9cd1b85cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -311,7 +311,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<String>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          keyFactory.forType(componentDefinitionType.asType()),
+          keyFactory.forComponent(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
           Optional.<DependencyRequest>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 182948a2f..8506b867b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -139,21 +139,21 @@
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    * provider.
    */
-  static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
+  static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>()
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
             .orderValuesBy(DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       dependenciesByKeyBuilder.put(
-          dependency.frameworkKey(), dependency);
+          dependency.key(), dependency);
     }
-    ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
+    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
-    Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
-    ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
-    for (Entry<FrameworkKey, Collection<DependencyRequest>> entry :
+    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
+    for (Entry<Key, Collection<DependencyRequest>> entry :
       dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 2946e5ffd..62ba6f402 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -16,12 +16,13 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import java.util.List;
+import dagger.internal.codegen.Key.Kind;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -29,7 +30,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -67,7 +67,9 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     assert_().that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(keyFactory.forType(typeElement.asType()));
+        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(typeElement.asType())));
   }
 
   static final class InjectedClass {
@@ -82,7 +84,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     assert_().that(keyFactory.forProvidesMethod(providesMethod))
-        .isEqualTo(keyFactory.forType(stringType));
+        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(stringType)));
   }
 
   @Module(library = true)
@@ -147,13 +151,15 @@ String provideQualifiedString() {
   @Test public void forProvidesMethod_sets() {
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
     TypeElement moduleElement =
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
       assert_().that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(keyFactory.forType(setOfStringsType));
+          .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+              Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+              MoreTypes.equivalence().wrap(setOfStringsType)));
     }
   }
 
@@ -168,24 +174,38 @@ String provideQualifiedString() {
     }
   }
 
-  interface PrimitiveTypes {
-    int foo();
-    Integer bar();
+  @Module(library = true)
+  static final class PrimitiveTypes {
+    @Provides int foo() {
+      return 0;
+    }
+  }
+
+  @Module(library = true)
+  static final class BoxedPrimitiveTypes {
+    @Provides Integer foo() {
+      return 0;
+    }
   }
 
   @Test public void primitiveKeysMatchBoxedKeys() {
-    TypeElement holder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
-    List<ExecutableElement> methods = (List<ExecutableElement>) holder.getEnclosedElements();
+    TypeElement primitiveHolder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
+    ExecutableElement intMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(primitiveHolder.getEnclosedElements()));
+    TypeElement boxedPrimitiveHolder =
+        elements.getTypeElement(BoxedPrimitiveTypes.class.getCanonicalName());
+    ExecutableElement integerMethod = Iterables.getOnlyElement(
+        ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));
 
     // TODO(user): Truth subject for TypeMirror and TypeElement
-    TypeMirror intType = methods.get(0).getReturnType();
+    TypeMirror intType = intMethod.getReturnType();
     assert_().that(intType.getKind().isPrimitive()).isTrue();
-    TypeMirror integerType = methods.get(1).getReturnType();
+    TypeMirror integerType = integerMethod.getReturnType();
     assert_().that(integerType.getKind().isPrimitive()).isFalse();
     assert_().that(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
-    Key intKey = keyFactory.forType(intType);
-    Key integerKey = keyFactory.forType(integerType);
+    Key intKey = keyFactory.forProvidesMethod(intMethod);
+    Key integerKey = keyFactory.forProvidesMethod(integerMethod);
     assert_().that(intKey).isEqualTo(integerKey);
   }
 }
