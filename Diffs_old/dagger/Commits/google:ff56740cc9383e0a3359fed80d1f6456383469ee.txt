diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index c4a264aa6..41c6a16f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -36,7 +36,7 @@
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
- * implementation of annotations marked with &#064MapKey where necessary.
+ * implementation of annotations marked with {@link MapKey @MapKey} where necessary.
  *
  * @author Chenying Hou
  * @since 2.0
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 5be196420..84a988f50 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -172,7 +172,7 @@ static CodeBlock getMapKeyExpression(Element bindingElement) {
    * when creating the value in a method body.
    *
    * <p>For example, inside an annotation, a nested array of {@code int}s is simply
-   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
+   * {@code {1, 2, 3}}, but in code it would have to be {@code new int[] {1, 2, 3}}.
    */
   private static class MapKeyExpression
       extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 7d724017e..452edb8a4 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -34,17 +34,15 @@
  * example, {@code @Component interface MyComponent {...}} will produce an implementation named
  * {@code DaggerMyComponent}.
  *
- * <a name="component-methods">
+ * <a name="component-methods"></a>
  * <h2>Component methods</h2>
- * </a>
  *
  * <p>Every type annotated with {@code @Component} must contain at least one abstract component
  * method. Component methods may have any name, but must have signatures that conform to either
  * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts.
  *
- * <a name="provision-methods">
+ * <a name="provision-methods"></a>
  * <h3>Provision methods</h3>
- * </a>
  *
  * <p>Provision methods have no parameters and return an {@link Inject injected} or
  * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The
@@ -65,9 +63,8 @@
  *   {@literal Lazy<SomeType>} getLazySomeType();
  * </code></pre>
  *
- * <a name="members-injection-methods">
+ * <a name="members-injection-methods"></a>
  * <h3>Members-injection methods</h3>
- * </a>
  *
  * <p>Members-injection methods have a single parameter and inject dependencies into each of the
  * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method
@@ -103,9 +100,8 @@
  *   }
  * </code></pre>
  *
- * <a name="instantiation">
+ * <a name="instantiation"></a>
  * <h2>Instantiation</h2>
- * </a>
  *
  * <p>Component implementations are primarily instantiated via a generated
  * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
@@ -137,9 +133,8 @@
  * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
  * equivalent.
  *
- * <a name="scope">
+ * <a name="scope"></a>
  * <h2>Scope</h2>
- * </a>
  *
  * <p>Each Dagger component can be associated with a scope by annotating it with the
  * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one
@@ -159,17 +154,15 @@
  * self-contained implementations, exiting a scope is as simple as dropping all references to the
  * component instance.
  *
- * <a name="component-relationships">
+ * <a name="component-relationships"></a>
  * <h2>Component relationships</h2>
- * </a>
  *
  * <p>While there is much utility in isolated components with purely unscoped bindings, many
  * applications will call for multiple components with multiple scopes to interact. Dagger provides
  * two mechanisms for relating components.
  *
- * <a name="subcomponents">
+ * <a name="subcomponents"></a>
  * <h3>Subcomponents</h3>
- * </a>
  *
  * <p>The simplest way to relate two components is by declaring a {@link Subcomponent}. A
  * subcomponent behaves exactly like a component, but has its implementation generated within
@@ -190,9 +183,8 @@
  *   }
  * </code></pre>
  *
- * <a name="component-dependencies">
+ * <a name="component-dependencies"></a>
  * <h3>Component dependencies</h3>
- * </a>
  *
  * <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
  * tightly coupled with the parents; they may use any binding defined by their ancestor component
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 106c00183..e65c99f62 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -54,7 +54,7 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<SomeEnum, Integer> map) {
+ *   SomeInjectedType({@literal Map<SomeEnum, Integer>} map) {
  *     assert map.get(SomeEnum.FOO) == 2;
  *   }
  * }
@@ -89,7 +89,7 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<MyMapKey, Integer> map) {
+ *   SomeInjectedType({@literal Map<MyMapKey, Integer>} map) {
  *     assert map.get(new MyMapKeyImpl("foo", MyEnum.BAR)) == 2;
  *   }
  * }
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 7f7c591a7..264a8b016 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -29,7 +29,7 @@
  * method's return type is bound to its returned value. The {@linkplain Component component}
  * implementation will pass dependencies to the method as parameters.
  *
- * <h3>Nullability
+ * <h3>Nullability</h3>
  *
  * <p>Dagger forbids injecting {@code null} by default. Component implemenations that invoke
  * {@code @Provides} methods that return {@code null} will throw a {@link NullPointerException}
diff --git a/core/src/main/java/dagger/internal/Factory.java b/core/src/main/java/dagger/internal/Factory.java
index 3e2774cec..8451989ba 100644
--- a/core/src/main/java/dagger/internal/Factory.java
+++ b/core/src/main/java/dagger/internal/Factory.java
@@ -15,12 +15,13 @@
  */
 package dagger.internal;
 
+import dagger.Provides;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Scope;
 
 /**
- * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may<i> apply
+ * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may</i> apply
  * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise
  * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to
  * {@link #get}.
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index ffc42316d..59af18274 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -60,7 +60,7 @@
   @Override
   public abstract boolean equals(Object o);
 
-  /** Returns an appropriate hash code to match {@link #equals). */
+  /** Returns an appropriate hash code to match {@link #equals(Object)}. */
   @Override
   public abstract int hashCode();
 
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index ec56d1576..3640dfe66 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -46,7 +46,7 @@
  * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
  * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
  * are all valid production method declarations: <pre><code>
- *   ListenableFuture<SomeType> getSomeType();
+ *   {@literal ListenableFuture<SomeType>} getSomeType();
  *   {@literal Producer<Set<SomeType>>} getSomeTypes();
  *   {@literal @Response ListenableFuture<Html>} getResponse();
  * </code></pre>
@@ -123,4 +123,3 @@
   @Documented
   @interface Builder {}
 }
-
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index b59104286..402b566e9 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -76,8 +76,8 @@
    * Called when the producer's output is requested; that is, when the first method is called that
    * requires the production of this producer's output.
    *
-   * <p>Note that if a method depends on {@link Producer Producer<T>}, then this does not count as
-   * requesting {@code T}; that is only triggered by calling {@link Producer#get()}.
+   * <p>Note that if a method depends on {@code Producer<T>}, then this does not count as requesting
+   * {@code T}; that is only triggered by calling {@link Producer#get()}.
    *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
index 071f32cb8..bdff4a198 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -28,7 +28,7 @@
  *
  * <p>All timings are measured at nanosecond precision, but not necessarily nanosecond resolution.
  * That is, timings will be reported in nanoseconds, but the timing source will not necessarily
- * update at nanosecond resolution. For example, {@link System#nanoTime()) would satisfy these
+ * update at nanosecond resolution. For example, {@link System#nanoTime()} would satisfy these
  * constraints.
  *
  * @author Jesse Beder
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
index 5834206ee..eee6d077f 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -50,7 +50,7 @@ public boolean equals(Object o) {
     }
   }
 
-  /** Returns an appropriate hash code to match {@link #equals). */
+  /** Returns an appropriate hash code to match {@link #equals(Object)}. */
   @Override
   public int hashCode() {
     return classToken.hashCode();
