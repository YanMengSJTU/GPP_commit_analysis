diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
new file mode 100644
index 000000000..48acbabac
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = {MonitoringModule.class, StubModule.class, ServingModule.class})
+interface MonitoredComponent {
+  ListenableFuture<String> output();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
new file mode 100644
index 000000000..0c4209076
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class MonitoringModule {
+  private final ProductionComponentMonitor.Factory monitorFactory;
+
+  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {
+    this.monitorFactory = monitorFactory;
+  }
+
+  @Provides(type = SET)
+  ProductionComponentMonitor.Factory monitorFactory() {
+    return monitorFactory;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
new file mode 100644
index 000000000..d5bec22ce
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Qualifier;
+import producerstest.monitoring.StubModule.ForServer1;
+import producerstest.monitoring.StubModule.ForServer2;
+
+@ProducerModule
+final class ServingModule {
+  @Qualifier
+  @interface RequestData {}
+
+  @Qualifier
+  @interface IntermediateData {}
+
+  @Produces
+  @RequestData
+  static String requestData() {
+    return "Hello, World!";
+  }
+
+  @Produces
+  @IntermediateData
+  static ListenableFuture<String> callServer1(
+      @RequestData String data, @ForServer1 StringStub stub) {
+    return stub.run(data);
+  }
+
+  @Produces
+  static ListenableFuture<String> callServer2(
+      @IntermediateData String data, @ForServer2 StringStub stub) {
+    return stub.run(data);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
new file mode 100644
index 000000000..195dd283d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface StringStub {
+  ListenableFuture<String> run(String input);
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
new file mode 100644
index 000000000..dc8ab6260
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Qualifier;
+
+@Module
+final class StubModule {
+  @Qualifier
+  @interface ForServer1 {}
+
+  @Qualifier
+  @interface ForServer2 {}
+
+  private final StringStub server1;
+  private final StringStub server2;
+
+  StubModule(StringStub server1, StringStub server2) {
+    this.server1 = server1;
+    this.server2 = server2;
+  }
+
+  @Provides
+  @ForServer1
+  StringStub server1() {
+    return server1;
+  }
+
+  @Provides
+  @ForServer2
+  StringStub server2() {
+    return server2;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
index 0ef22ae6b..9a5602990 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -23,6 +23,7 @@
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,12 +43,20 @@
 public class ProducerFactoryTest {
   @Mock private ProductionComponentMonitor componentMonitor;
   private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
 
   @Before
   public void setUpMocks() {
     MockitoAnnotations.initMocks(this);
     monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
     when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
   }
 
   @Test
@@ -55,7 +64,7 @@ public void noArgMethod() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     Producer<String> producer =
         new SimpleProducerModule_StrFactory(
-            componentMonitor, MoreExecutors.directExecutor());
+            MoreExecutors.directExecutor(), componentMonitorProvider);
     assertThat(producer.get().get()).isEqualTo("str");
     InOrder order = inOrder(componentMonitor, monitor);
     order.verify(componentMonitor).producerMonitorFor(token);
@@ -70,7 +79,7 @@ public void noArgMethod() throws Exception {
     Producer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
         new SimpleProducerModule_StrWithArgFactory(
-            componentMonitor, MoreExecutors.directExecutor(), intProducer);
+            MoreExecutors.directExecutor(), componentMonitorProvider, intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
     assertThat(producer.get().get()).isEqualTo("str with arg");
@@ -85,7 +94,7 @@ public void successMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            componentMonitor, MoreExecutors.directExecutor(), strFutureProducer);
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -112,7 +121,7 @@ public void failureMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            componentMonitor, MoreExecutors.directExecutor(), strFutureProducer);
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -142,7 +151,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
     Producer<String> producer =
         new SimpleProducerModule_ThrowingProducerFactory(
-            componentMonitor, MoreExecutors.directExecutor());
+            MoreExecutors.directExecutor(), componentMonitorProvider);
     assertThat(producer.get().isDone()).isTrue();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -162,8 +171,8 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
   }
 
   @Test(expected = NullPointerException.class)
-  public void nullComponentMonitor() throws Exception {
-    new SimpleProducerModule_StrFactory(null, MoreExecutors.directExecutor());
+  public void nullComponentMonitorProvider() throws Exception {
+    new SimpleProducerModule_StrFactory(MoreExecutors.directExecutor(), null);
   }
 
   private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
new file mode 100644
index 000000000..3efb2b5b1
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+/** Tests for production components using monitoring. */
+@RunWith(JUnit4.class)
+public final class MonitoringTest {
+  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;
+  @Mock private StringStub server1;
+  @Mock private StringStub server2;
+  private SettableFuture<String> server1Future;
+  private SettableFuture<String> server2Future;
+  private FakeProductionComponentMonitor componentMonitor;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    componentMonitor = new FakeProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+    server1Future = SettableFuture.create();
+    server2Future = SettableFuture.create();
+    when(server1.run(any(String.class))).thenReturn(server1Future);
+    when(server2.run(any(String.class))).thenReturn(server2Future);
+  }
+
+  @Test
+  public void basicMonitoring() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server1Future.set("server 1 response");
+    inOrder.verify(callServer1Monitor).succeeded("server 1 response");
+    inOrder.verify(callServer2Monitor).methodStarting();
+    inOrder.verify(callServer2Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server2Future.set("server 2 response");
+    inOrder.verify(callServer2Monitor).succeeded("server 2 response");
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    assertThat(output.get()).isEqualTo("server 2 response");
+  }
+
+  @Test
+  public void basicMonitoringWithFailure() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    RuntimeException cause = new RuntimeException("monkey");
+    server1Future.setException(cause);
+    inOrder.verify(callServer1Monitor).failed(cause);
+    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    try {
+      output.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(Throwables.getRootCause(e)).isSameAs(cause);
+    }
+  }
+
+  private static final class FakeProductionComponentMonitor implements ProductionComponentMonitor {
+    final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ProducerMonitor monitor = mock(ProducerMonitor.class);
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 759711a3b..fd585f23b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -58,7 +58,6 @@
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
-import dagger.producers.monitoring.internal.Monitors;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.HashMap;
@@ -97,9 +96,9 @@
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
 import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
-import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
@@ -1023,11 +1022,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
       case FUTURE_PRODUCTION:
         {
           List<Snippet> parameters =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 3);
-          // TODO(beder): Pass the actual ProductionComponentMonitor.
-          parameters.add(
-              Snippet.format(
-                  "%s.noOpProductionComponentMonitor()", ClassName.fromClass(Monitors.class)));
+              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
           }
@@ -1108,8 +1103,9 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
   private List<Snippet> getProducerDependencyParameters(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(
-            types, binding.dependencies()).asMap().values()) {
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
+            .asMap()
+            .values()) {
       BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
           .transform(DependencyRequest.BINDING_KEY_FUNCTION));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index a292d03a7..df0ea7113 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -284,6 +284,9 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
       }
+      if (kind.equals(Kind.PRODUCTION_COMPONENT)) {
+        modules.add(descriptorForMonitoringModule(componentDefinitionType));
+      }
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
@@ -434,6 +437,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
       return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
+
+    /**
+     * Returns a descriptor for a generated module that handles monitoring for production
+     * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
+     *
+     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+     *     processor to retry in a later processing round.
+     */
+    private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
+      String generatedMonitorModuleName =
+          SourceFiles.generatedMonitoringModuleName(componentDefinitionType).canonicalName();
+      TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
+      if (monitoringModule == null) {
+        throw new TypeNotPresentException(generatedMonitorModuleName, null);
+      }
+      return moduleDescriptorFactory.create(monitoringModule);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 23a889b33..c35058ba3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -133,8 +133,10 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
+    MonitoringModuleGenerator monitoringModuleGenerator = new MonitoringModuleGenerator(filer);
 
-    DependencyRequest.Factory dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
@@ -152,12 +154,13 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements,
-        injectBindingRegistry,
-        keyFactory,
-        provisionBindingFactory,
-        productionBindingFactory);
+    BindingGraph.Factory bindingGraphFactory =
+        new BindingGraph.Factory(
+            elements,
+            injectBindingRegistry,
+            keyFactory,
+            provisionBindingFactory,
+            productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
@@ -182,6 +185,7 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             membersInjectionBindingFactory,
             injectBindingRegistry),
+        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index b51d70e75..49fcd9c9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -29,23 +29,27 @@
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
 import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -114,6 +118,12 @@ BindingKey bindingKey() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
+  /**
+   * An optional name for this request when it's referred to in generated code. If absent, it will
+   * use a name derived from {@link #requestElement}.
+   */
+  abstract Optional<String> overriddenVariableName();
+
   /**
    * Factory for {@link DependencyRequest}s.
    *
@@ -121,9 +131,11 @@ BindingKey bindingKey() {
    * which may mean that the type will be generated in a later round of processing.
    */
   static final class Factory {
+    private final Elements elements;
     private final Key.Factory keyFactory;
 
-    Factory(Key.Factory keyFactory) {
+    Factory(Elements elements, Key.Factory keyFactory) {
+      this.elements = elements;
       this.keyFactory = keyFactory;
     }
 
@@ -140,11 +152,13 @@ BindingKey bindingKey() {
     ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
-          .transform(new Function<VariableElement, DependencyRequest>() {
-            @Override public DependencyRequest apply(VariableElement input) {
-              return forRequiredVariable(input);
-            }
-          })
+          .transform(
+              new Function<VariableElement, DependencyRequest>() {
+                @Override
+                public DependencyRequest apply(VariableElement input) {
+                  return forRequiredVariable(input);
+                }
+              })
           .toSet();
     }
 
@@ -164,15 +178,20 @@ DependencyRequest forImplicitMapBinding(
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
           mapOfValueRequest.enclosingType(),
-          false /* doesn't allow null */);
+          false /* doesn't allow null */,
+          Optional.<String>absent());
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
+      return forRequiredVariable(variableElement, Optional.<String>absent());
+    }
+
+    DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier,
-          getEnclosingType(variableElement));
+      return newDependencyRequest(
+          variableElement, type, qualifier, getEnclosingType(variableElement), name);
     }
 
     DependencyRequest forRequiredResolvedVariable(DeclaredType container,
@@ -181,7 +200,8 @@ DependencyRequest forRequiredResolvedVariable(DeclaredType container,
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier, container);
+      return newDependencyRequest(
+          variableElement, resolvedType, qualifier, container, Optional.<String>absent());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -193,8 +213,12 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           "Component provision methods must be empty: %s",
           provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
-          getEnclosingType(provisionMethod));
+      return newDependencyRequest(
+          provisionMethod,
+          provisionMethodType.getReturnType(),
+          qualifier,
+          getEnclosingType(provisionMethod),
+          Optional.<String>absent());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -211,13 +235,15 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       if (isTypeOf(ListenableFuture.class, type)) {
         return new AutoValue_DependencyRequest(
             Kind.FUTURE,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
+            keyFactory.forQualifiedType(
+                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
             container,
-            false /* doesn't allow null */);
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, container);
+        return newDependencyRequest(
+            productionMethod, type, qualifier, container, Optional.<String>absent());
       }
     }
 
@@ -231,32 +257,53 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
       if (returnType.getKind().equals(DECLARED)
           && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       }
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+      return new AutoValue_DependencyRequest(
+          Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
           type,
-          false /* doesn't allow null */);
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
+    DependencyRequest forProductionComponentMonitorProvider() {
+      TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
+      for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
+        if (constructor.getParameters().size() == 2) {
+          // the 2-arg constructor has the appropriate dependency as its first arg
+          return forRequiredVariable(constructor.getParameters().get(0), Optional.of("monitor"));
+        }
+      }
+      throw new AssertionError("expected 2-arg constructor in AbstractProducer");
     }
 
-    private DependencyRequest newDependencyRequest(Element requestElement,
-        TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
+    private DependencyRequest newDependencyRequest(
+        Element requestElement,
+        TypeMirror type,
+        Optional<AnnotationMirror> qualifier,
+        DeclaredType container,
+        Optional<String> name) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
@@ -266,11 +313,13 @@ private DependencyRequest newDependencyRequest(Element requestElement,
       // TODO(sameb): should Produced/Producer always require non-nullable?
       boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
           || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
-      return new AutoValue_DependencyRequest(kindAndType.kind(),
+      return new AutoValue_DependencyRequest(
+          kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
           container,
-          allowsNull);
+          allowsNull,
+          name);
     }
 
     @AutoValue
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 1643adbc4..5ba5635cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -33,6 +33,9 @@
 final class DependencyVariableNamer implements Function<DependencyRequest, String> {
   @Override
   public String apply(DependencyRequest dependency) {
+    if (dependency.overriddenVariableName().isPresent()) {
+      return dependency.overriddenVariableName().get();
+    }
     String variableName = dependency.requestElement().getSimpleName().toString();
     switch (dependency.kind()) {
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
new file mode 100644
index 000000000..a4e020b32
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.producers.monitoring.internal.MonitorCache;
+
+import java.util.Set;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.FINAL;
+
+/** Generates a monitoring module for use with production components. */
+final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
+  private static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.create(
+          Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
+
+  MonitoringModuleGenerator(Filer filer) {
+    super(filer);
+  }
+
+  @Override
+  ClassName nameGeneratedType(TypeElement componentElement) {
+    return SourceFiles.generatedMonitoringModuleName(componentElement);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(TypeElement componentElement) {
+    return ImmutableSet.of(componentElement);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
+    return Optional.of(componentElement);
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, TypeElement componentElement) {
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+    classWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    classWriter.annotate(Module.class);
+    classWriter.addModifiers(FINAL);
+
+    // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
+    MethodWriter emptySetBindingMethod =
+        classWriter.addMethod(SET_OF_FACTORIES, "defaultSetOfFactories");
+    emptySetBindingMethod.addModifiers(STATIC);
+    emptySetBindingMethod.annotate(Provides.class).setMember("type", Provides.Type.SET_VALUES);
+    emptySetBindingMethod
+        .body()
+        .addSnippet("return %s.of();", ClassName.fromClass(ImmutableSet.class));
+
+    FieldWriter providerField = classWriter.addField(MonitorCache.class, "monitorCache");
+    providerField.addModifiers(PRIVATE, FINAL);
+    providerField.setInitializer("new %s()", ClassName.fromClass(MonitorCache.class));
+    MethodWriter monitorMethod = classWriter.addMethod(ProductionComponentMonitor.class, "monitor");
+    monitorMethod.annotate(Provides.class);
+    monitorMethod.addParameter(
+        ParameterizedTypeName.create(Provider.class, ClassName.fromTypeElement(componentElement)),
+        "component");
+    monitorMethod.addParameter(
+        ParameterizedTypeName.create(Provider.class, SET_OF_FACTORIES), "factories");
+    monitorMethod.body().addSnippet("return monitorCache.monitor(component, factories);");
+
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
new file mode 100644
index 000000000..91b10e7ef
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * A processing step that is responsible for generating a special module for a
+ * {@link ProductionComponent}.
+ */
+final class MonitoringModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MonitoringModuleGenerator monitoringModuleGenerator;
+
+  MonitoringModuleProcessingStep(
+      Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {
+    this.messager = messager;
+    this.monitoringModuleGenerator = monitoringModuleGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ProductionComponent.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.get(ProductionComponent.class))) {
+      try {
+        monitoringModuleGenerator.generate(element);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index a7da5a4eb..90a0337bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -44,8 +44,8 @@
 import dagger.producers.Produces;
 import dagger.producers.internal.AbstractProducer;
 import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
@@ -105,11 +105,15 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ConstructorWriter constructorWriter = factoryWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
 
-    constructorWriter.addParameter(ProductionComponentMonitor.class, "componentMonitor");
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.implicitDependencies());
+
     constructorWriter
         .body()
         .addSnippet(
-            "super(componentMonitor.producerMonitorFor(%s.create(%s.class)));",
+            "super(%s, %s.create(%s.class));",
+            fields.get(binding.monitorRequest().get().bindingKey()).name(),
             ClassName.fromClass(ProducerToken.class),
             factoryWriter.name());
 
@@ -135,13 +139,10 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryWriter.setSuperclass(
         ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
-    getMethodWriter.annotate(Override.class);
-    getMethodWriter.addModifiers(PROTECTED);
-
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
+    MethodWriter computeMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
+    computeMethodWriter.annotate(Override.class);
+    computeMethodWriter.addModifiers(PROTECTED);
+    computeMethodWriter.addParameter(ProducerMonitor.class, "monitor").addModifiers(FINAL);
 
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
@@ -155,14 +156,16 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
     boolean returnsFuture =
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
-    ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
-        .from(binding.dependencies())
-        .filter(new Predicate<DependencyRequest>() {
-          @Override public boolean apply(DependencyRequest dependency) {
-            return isAsyncDependency(dependency);
-          }
-        })
-        .toList();
+    ImmutableList<DependencyRequest> asyncDependencies =
+        FluentIterable.from(binding.implicitDependencies())
+            .filter(
+                new Predicate<DependencyRequest>() {
+                  @Override
+                  public boolean apply(DependencyRequest dependency) {
+                    return isAsyncDependency(dependency);
+                  }
+                })
+            .toList();
 
     for (DependencyRequest dependency : asyncDependencies) {
       ParameterizedTypeName futureType = ParameterizedTypeName.create(
@@ -170,13 +173,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           asyncDependencyType(dependency));
       String name = fields.get(dependency.bindingKey()).name();
       Snippet futureAccess = Snippet.format("%s.get()", name);
-      getMethodWriter.body().addSnippet("%s %sFuture = %s;",
-          futureType,
-          name,
-          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-              ? Snippet.format("%s.createFutureProduced(%s)",
-                  ClassName.fromClass(Producers.class), futureAccess)
-              : futureAccess);
+      computeMethodWriter
+          .body()
+          .addSnippet(
+              "%s %sFuture = %s;",
+              futureType,
+              name,
+              dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+                  ? Snippet.format(
+                      "%s.createFutureProduced(%s)",
+                      ClassName.fromClass(Producers.class),
+                      futureAccess)
+                  : futureAccess);
     }
 
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
@@ -200,7 +208,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
             getInvocationSnippet(!returnsFuture, binding, futureTransform.parameterSnippets()));
-    getMethodWriter
+    computeMethodWriter
         .body()
         .addSnippet(
             "return %s.transform(%s, %s, executor);",
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 624ebc7fd..1666fbf8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -20,9 +20,11 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Provides;
 import dagger.producers.Produces;
+import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -44,7 +46,7 @@
  */
 @AutoValue
 abstract class ProductionBinding extends ContributionBinding {
-  
+
   @Override
   Binding.Type bindingType() {
     return Binding.Type.PRODUCTION;
@@ -54,13 +56,26 @@
   Provides.Type provisionType() {
     return Provides.Type.valueOf(productionType().name());
   }
-  
+
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Similar optimizations to ContributionBinding.implicitDependencies().
+    if (!monitorRequest().isPresent()) {
+      return super.implicitDependencies();
+    } else {
+      return Sets.union(monitorRequest().asSet(), super.implicitDependencies());
+    }
+  }
+
   /** Returns provision type that was used to bind the key. */
   abstract Produces.Type productionType();
 
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
+  /** If this production requires a monitor, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> monitorRequest();
+
   @Override
   ContributionType contributionType() {
     switch (productionType()) {
@@ -81,10 +96,8 @@ ContributionType contributionType() {
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Types types,
-        Key.Factory keyFactory,
-        DependencyRequest.Factory
-        dependencyRequestFactory) {
+    Factory(
+        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
@@ -106,6 +119,8 @@ ProductionBinding forProducesMethod(
               declaredContainer,
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
+      DependencyRequest monitorRequest =
+          dependencyRequestFactory.forProductionComponentMonitorProvider();
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
@@ -120,7 +135,8 @@ ProductionBinding forProducesMethod(
           Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
-          ImmutableList.copyOf(producesMethod.getThrownTypes()));
+          ImmutableList.copyOf(producesMethod.getThrownTypes()),
+          Optional.of(monitorRequest));
     }
 
     ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
@@ -143,7 +159,8 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC,
           Produces.Type.MAP,
-          ImmutableList.<TypeMirror>of());
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent());
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -162,7 +179,8 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()));
+          ImmutableList.copyOf(componentMethod.getThrownTypes()),
+          Optional.<DependencyRequest>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 834d400d3..7ad0acbc4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -280,6 +280,13 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
         .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
+  static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
+    ClassName componentName = ClassName.fromTypeElement(componentElement);
+    return componentName
+        .topLevelClassName()
+        .peerNamed(componentName.classFileName() + "_MonitoringModule");
+  }
+
   private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index b2cb45134..8dbf27bc3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -15,9 +15,10 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import java.io.IOException;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -27,6 +28,7 @@
 
 public final class AnnotationWriter implements Writable, HasClassReferences {
   private final ClassName annotationName;
+  private final Set<HasClassReferences> memberReferences = Sets.newLinkedHashSet();
   private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
 
   AnnotationWriter(ClassName annotationName) {
@@ -45,6 +47,12 @@ public void setMember(String name, String value) {
     memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
   }
 
+  public <T extends Enum<T>> void setMember(String name, T value) {
+    Snippet snippet = Snippet.format("%s.%s", ClassName.fromClass(value.getClass()), value);
+    memberMap.put(name, snippet);
+    memberReferences.add(snippet);
+  }
+
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('@');
@@ -65,6 +73,9 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of(annotationName);
+    return FluentIterable.from(memberReferences)
+        .append(annotationName)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 7766f244a..b47a43c1c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -57,7 +57,7 @@
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
   private List<? extends VariableElement> sampleProviderParameters() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 2c017c923..f9c287859 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -475,30 +475,36 @@ public void publicModuleNonPublicIncludes() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerMonitor;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
-            "      ProductionComponentMonitor componentMonitor,",
             "      TestModule module,",
-            "      Executor executor) {",
+            "      Executor executor,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
             "    super(",
-            "        componentMonitor.producerMonitorFor(",
-            "            ProducerToken.create(TestModule_ProduceStringFactory.class)));",
+            "        monitorProvider,",
+            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
             "    assert module != null;",
             "    this.module = module;",
             "    assert executor != null;",
             "    this.executor = executor;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute() {",
+            "  @Override protected ListenableFuture<String> compute(",
+            "      final ProducerMonitor monitor) {",
             "    return Futures.transform(",
             "      Futures.<Void>immediateFuture(null),",
             "      new AsyncFunction<Void, String>() {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index fd9f875c6..c8d92061a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -129,9 +129,13 @@
             "package test;",
             "",
             "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.SetFactory;",
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.internal.Monitors;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor.Factory;",
+            "import java.util.Set;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -143,6 +147,10 @@
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
             "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
+            "  private Provider<Set<Factory>> setOfFactoryProvider;",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<B> bProvider;",
             "  private Producer<A> aProducer;",
             "",
@@ -156,12 +164,22 @@
             "  }",
             "",
             "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.setOfFactoryContribution1Provider =",
+            "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
+            "            .create();",
+            "    this.setOfFactoryProvider = SetFactory.create(setOfFactoryContribution1Provider);",
+            "    this.monitorProvider =",
+            "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
+            "            builder.testClass$SimpleComponent_MonitoringModule,",
+            "            simpleComponentProvider,",
+            "            setOfFactoryProvider);",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
             "    this.aProducer = new TestClass$AModule_AFactory(",
-            "        Monitors.noOpProductionComponentMonitor(),",
             "        builder.aModule,",
             "        builder.executor,",
+            "        monitorProvider,",
             "        Producers.producerFromProvider(bProvider));",
             "  }",
             "",
@@ -171,6 +189,8 @@
             "  }",
             "",
             "  public static final class Builder {",
+            "    private TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule;",
             "    private BModule bModule;",
             "    private AModule aModule;",
             "    private Executor executor;",
@@ -179,6 +199,10 @@
             "    }",
             "",
             "    public SimpleComponent build() {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        this.testClass$SimpleComponent_MonitoringModule =",
+            "            new TestClass$SimpleComponent_MonitoringModule();",
+            "      }",
             "      if (bModule == null) {",
             "        this.bModule = new BModule();",
             "      }",
@@ -208,6 +232,17 @@
             "      return this;",
             "    }",
             "",
+            "    public Builder testClass$SimpleComponent_MonitoringModule(",
+            "        TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule) {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.testClass$SimpleComponent_MonitoringModule =",
+            "          testClass$SimpleComponent_MonitoringModule;",
+            "      return this;",
+            "    }",
+            "",
             "    public Builder executor(Executor executor) {",
             "      if (executor == null) {",
             "        throw new NullPointerException();",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 9f577b722..6fc871684 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -161,4 +161,110 @@
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
+
+  @Test
+  public void monitoringDependsOnUnboundType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET)",
+            "    ProductionComponentMonitor.Factory monitorFactory(A unbound) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(33);
+  }
+
+  @Test
+  public void monitoringDependsOnProduction() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET) ProductionComponentMonitor.Factory monitorFactory(A a) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces A a() {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory> is a"
+            + " provision, which cannot depend on a production.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(36);
+  }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 0fca60f0f..f7e8ec0e5 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -18,10 +18,15 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.Monitors;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import javax.annotation.Nullable;
+import javax.inject.Provider;
+
 /**
  * An abstract {@link Producer} implementation that memoizes the result of its compute method.
  *
@@ -29,19 +34,22 @@
  * @since 2.0
  */
 public abstract class AbstractProducer<T> implements Producer<T> {
-  protected final ProducerMonitor monitor;
+  private final Provider<ProductionComponentMonitor> monitorProvider;
+  @Nullable private final ProducerToken token;
   private volatile ListenableFuture<T> instance = null;
 
   protected AbstractProducer() {
-    this(Monitors.noOpProducerMonitor());
+    this(Monitors.noOpProductionComponentMonitorProvider(), null);
   }
 
-  protected AbstractProducer(ProducerMonitor monitor) {
-    this.monitor = checkNotNull(monitor);
+  protected AbstractProducer(
+      Provider<ProductionComponentMonitor> monitorProvider, @Nullable ProducerToken token) {
+    this.monitorProvider = checkNotNull(monitorProvider);
+    this.token = token;
   }
 
   /** Computes this producer's future, which is then cached in {@link #get}. */
-  protected abstract ListenableFuture<T> compute();
+  protected abstract ListenableFuture<T> compute(ProducerMonitor monitor);
 
   @Override
   public final ListenableFuture<T> get() {
@@ -51,7 +59,8 @@ protected AbstractProducer(ProducerMonitor monitor) {
       synchronized (this) {
         result = instance;
         if (result == null) {
-          instance = result = compute();
+          ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          instance = result = compute(monitor);
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 9223cad5f..4156e99e0 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -22,6 +22,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -95,7 +96,7 @@
     checkNotNull(provider);
     return new AbstractProducer<T>() {
       @Override
-      protected ListenableFuture<T> compute() {
+      protected ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
         return Futures.immediateFuture(provider.get());
       }
     };
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 2207d7c16..e51bcad42 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -21,6 +21,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -64,7 +65,7 @@ private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProduce
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<Produced<T>>> compute() {
+  public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
         new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
     for (Producer<Set<T>> producer : contributingProducers) {
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 0846f867d..5b3c0902d 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -20,6 +20,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -62,7 +63,7 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<T>> compute() {
+  public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Set<T>>> futureSets =
         new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
     for (Producer<Set<T>> producer : contributingProducers) {
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
new file mode 100644
index 000000000..2a76c5f71
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.inject.Provider;
+
+/**
+ * A class that provides a {@link ProductionComponentMonitor} for use in production components.
+ *
+ * <p>This caches the underlying the monitor, since we want a single instance for each component.
+ */
+public final class MonitorCache {
+  private static final Logger logger = Logger.getLogger(MonitorCache.class.getName());
+
+  private volatile ProductionComponentMonitor monitor;
+
+  /**
+   * Returns the underlying monitor. This will only actually compute the monitor the first time it
+   * is called; subsequent calls will simply return the cached value, so the arguments to this
+   * method are ignored. It is expected (though not checked) that this method is called with
+   * equivalent arguments each time (like a {@link dagger.Provides @Provides} method would).
+   */
+  public ProductionComponentMonitor monitor(
+      Provider<?> componentProvider,
+      Provider<Set<ProductionComponentMonitor.Factory>> monitorFactorySetProvider) {
+    ProductionComponentMonitor result = monitor;
+    if (result == null) {
+      synchronized (this) {
+        result = monitor;
+        if (result == null) {
+          try {
+            ProductionComponentMonitor.Factory factory =
+                Monitors.delegatingProductionComponentMonitorFactory(
+                    monitorFactorySetProvider.get());
+            result = monitor = factory.create(componentProvider.get());
+          } catch (RuntimeException e) {
+            logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
+            result = monitor = Monitors.noOpProductionComponentMonitor();
+          }
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index 6d7949021..f27ce37b1 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -24,6 +24,7 @@
 import java.util.Collection;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.inject.Provider;
 
 /**
  * Utility methods relating to monitoring, for use in generated producers code.
@@ -284,6 +285,11 @@ public static ProducerMonitor noOpProducerMonitor() {
     return NO_OP_PRODUCER_MONITOR;
   }
 
+  /** Returns a provider of a no-op component monitor. */
+  public static Provider<ProductionComponentMonitor> noOpProductionComponentMonitorProvider() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER;
+  }
+
   private static final ProductionComponentMonitor.Factory
       NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY =
           new ProductionComponentMonitor.Factory() {
@@ -309,6 +315,15 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
         }
       };
 
+  private static final Provider<ProductionComponentMonitor>
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER =
+          new Provider() {
+            @Override
+            public ProductionComponentMonitor get() {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
   private static void logCreateException(
       RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {
     logger.log(
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 33eb17082..923ea70a1 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -20,34 +20,51 @@
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import org.mockito.Mockito;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
+  @Mock private ProductionComponentMonitor componentMonitor;
   private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
 
   @Before
   public void initMocks() {
+    MockitoAnnotations.initMocks(this);
     monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
   }
 
   @Test
   public void get_nullPointerException() {
-    Producer<Object> producer = new DelegateProducer<>(monitor, null);
+    Producer<Object> producer = new DelegateProducer<>(componentMonitorProvider, null);
     try {
       producer.get();
       fail();
@@ -57,11 +74,11 @@ public void get_nullPointerException() {
 
   @Test public void get() throws Exception {
     Producer<Integer> producer =
-        new AbstractProducer<Integer>(monitor) {
+        new AbstractProducer<Integer>(componentMonitorProvider, null) {
           int i = 0;
 
           @Override
-          public ListenableFuture<Integer> compute() {
+          public ListenableFuture<Integer> compute(ProducerMonitor unusedMonitor) {
             return Futures.immediateFuture(i++);
           }
         };
@@ -73,7 +90,7 @@ public void get_nullPointerException() {
   @Test
   public void monitor_success() throws Exception {
     SettableFuture<Integer> delegateFuture = SettableFuture.create();
-    Producer<Integer> producer = new DelegateProducer<>(monitor, delegateFuture);
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
@@ -87,7 +104,7 @@ public void monitor_success() throws Exception {
   @Test
   public void monitor_failure() throws Exception {
     SettableFuture<Integer> delegateFuture = SettableFuture.create();
-    Producer<Integer> producer = new DelegateProducer<>(monitor, delegateFuture);
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
@@ -112,13 +129,15 @@ public void monitor_null() throws Exception {
   static final class DelegateProducer<T> extends AbstractProducer<T> {
     private final ListenableFuture<T> delegate;
 
-    DelegateProducer(ProducerMonitor monitor, ListenableFuture<T> delegate) {
-      super(monitor);
+    DelegateProducer(
+        Provider<ProductionComponentMonitor> componentMonitorProvider,
+        ListenableFuture<T> delegate) {
+      super(componentMonitorProvider, null);
       this.delegate = delegate;
     }
 
     @Override
-    public ListenableFuture<T> compute() {
+    public ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
       return delegate;
     }
   }
