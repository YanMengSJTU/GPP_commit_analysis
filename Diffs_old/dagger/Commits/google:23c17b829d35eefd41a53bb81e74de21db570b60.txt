diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
index 1fc92a561..cc174aba7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -19,12 +19,15 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.TreeSet;
+import javax.inject.Named;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -96,4 +99,39 @@
   @Binds
   @ElementsIntoSet
   abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  abstract Object bind123ForMap(@Named("For-123") String string);
+
+  @Binds
+  @IntoMap
+  @IntKey(456)
+  abstract Object bind456ForMap(@Named("For-456") String string);
+
+  @Provides
+  @IntoMap
+  @IntKey(789)
+  static Object provide789ForMap() {
+    return "789-string";
+  }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  @SomeQualifier
+  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
+  
+  @Provides
+  @Named("For-123")
+  static String provide123String() {
+    return "123-string";
+  }
+
+  @Provides
+  @Named("For-456")
+  static String provide456String() {
+    return "456-string";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
index 0a2a18efb..25befc452 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
@@ -16,7 +16,9 @@
 package test.bind;
 
 import dagger.Component;
+import java.util.Map;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -39,4 +41,10 @@
   Set<Object> objects();
 
   Set<CharSequence> charSequences();
+
+  Map<Integer, Object> integerObjectMap();
+
+  Map<Integer, Provider<Object>> integerProviderOfObjectMap();
+
+  @SomeQualifier Map<Integer, Object> qualifiedIntegerObjectMap();
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
index d91daeb06..636ff62f8 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
@@ -15,6 +15,7 @@
  */
 package test.bind;
 
+import com.google.common.collect.ImmutableMap;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -22,6 +23,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+// TODO(ronshapiro): rename to BindsTest
 @RunWith(JUnit4.class)
 public class BindTest {
 
@@ -51,5 +53,15 @@ public void multibindings() {
     assertThat(component.foosOfNumbers()).hasSize(2);
     assertThat(component.objects()).hasSize(3);
     assertThat(component.charSequences()).hasSize(5);
+
+    assertThat(component.integerObjectMap())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(123, "123-string", 456, "456-string", 789, "789-string"));
+    assertThat(component.integerProviderOfObjectMap()).hasSize(3);
+    assertThat(component.integerProviderOfObjectMap().get(123).get()).isEqualTo("123-string");
+    assertThat(component.integerProviderOfObjectMap().get(456).get()).isEqualTo("456-string");
+    assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo("789-string");
+
+    assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java
new file mode 100644
index 000000000..4440f4ac0
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class BindsCollectionsWithoutMultibindingsTest {
+  @Module
+  abstract static class M {
+    @Provides
+    static HashSet<String> provideHashSet() {
+      HashSet<String> set = new HashSet<>();
+      set.add("binds");
+      set.add("set");
+      return set;
+    }
+
+    @Binds
+    abstract Set<String> bindStringSet(HashSet<String> set);
+
+    @Provides
+    static HashMap<String, String> provideHashMap() {
+      HashMap<String, String> map = new HashMap<>();
+      map.put("binds", "map");
+      map.put("without", "multibindings");
+      return map;
+    }
+
+    @Binds
+    abstract Map<String, String> bindStringMap(HashMap<String, String> map);
+  }
+
+  @Component(modules = M.class)
+  interface C {
+    Set<String> set();
+
+    Map<String, String> map();
+  }
+
+  @Test
+  public void works() {
+    C component = DaggerBindsCollectionsWithoutMultibindingsTest_C.create();
+
+    assertThat(component.set()).containsExactly("binds", "set");
+    assertThat(component.map())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                "binds", "map",
+                "without", "multibindings"));
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
index 23789d672..770950413 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
@@ -20,6 +20,8 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
@@ -32,10 +34,14 @@
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.Executor;
+import javax.inject.Named;
 import javax.inject.Qualifier;
 import javax.inject.Singleton;
 
-@ProducerModule(includes = SimpleBindingModule.ExecutorModule.class)
+@ProducerModule(includes = {
+    SimpleBindingModule.ExecutorModule.class,
+    SimpleBindingModule.ProvisionModuleForMap.class
+})
 abstract class SimpleBindingModule {
   @Binds
   abstract Object bindObject(FooOfStrings impl);
@@ -120,4 +126,51 @@ static Executor provideExecutor() {
       return MoreExecutors.directExecutor();
     }
   }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  abstract Object bind123ForMap(@Named("For-123") String string);
+
+  @Binds
+  @IntoMap
+  @IntKey(456)
+  abstract Object bind456ForMap(@Named("For-456") String string);
+
+  @Produces
+  @IntoMap
+  @IntKey(789)
+  static Object produce789ForMap() {
+    return "789-string";
+  }
+
+  @Module
+  abstract static class ProvisionModuleForMap {
+    @Provides @Named("Provision string") static String provideProvisionString() {
+      return "provision-string";
+    }
+
+    @Binds
+    @IntoMap
+    @IntKey(-1)
+    abstract Object bindNegative1ForMap(@Named("Provision string") String string);
+  }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  @SomeQualifier
+  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
+
+  @Produces
+  @Named("For-123")
+  static String produce123String() {
+    return "123-string";
+  }
+
+  @Produces
+  @Named("For-456")
+  static String produce456String() {
+    return "456-string";
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
index 6c69b79f2..60448facf 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
@@ -16,8 +16,12 @@
 package producerstest.bind;
 
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
+import java.util.Map;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import producerstest.bind.SimpleBindingModule.SomeQualifier;
 
@@ -38,4 +42,12 @@
   ListenableFuture<Set<Object>> objects();
 
   ListenableFuture<Set<CharSequence>> charSequences();
+
+  ListenableFuture<Map<Integer, Object>> integerObjectMap();
+
+  ListenableFuture<Map<Integer, Producer<Object>>> integerProducerOfObjectMap();
+
+  ListenableFuture<Map<Integer, Produced<Object>>> integerProducedOfObjectMap();
+
+  @SomeQualifier ListenableFuture<Map<Integer, Object>> qualifiedIntegerObjectMap();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
index 88c675c97..7c6cf8087 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
@@ -15,6 +15,10 @@
  */
 package producerstest.bind;
 
+import com.google.common.collect.ImmutableMap;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -50,5 +54,28 @@ public void multibindings() throws Exception {
     assertThat(component.foosOfNumbers().get()).hasSize(2);
     assertThat(component.objects().get()).hasSize(3);
     assertThat(component.charSequences().get()).hasSize(5);
+
+    assertThat(component.integerObjectMap().get())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                123, "123-string", 456, "456-string", 789, "789-string", -1, "provision-string"));
+
+    Map<Integer, Producer<Object>> integerProducerOfObjectMap =
+        component.integerProducerOfObjectMap().get();
+    assertThat(integerProducerOfObjectMap).hasSize(4);
+    assertThat(integerProducerOfObjectMap.get(123).get().get()).isEqualTo("123-string");
+    assertThat(integerProducerOfObjectMap.get(456).get().get()).isEqualTo("456-string");
+    assertThat(integerProducerOfObjectMap.get(789).get().get()).isEqualTo("789-string");
+    assertThat(integerProducerOfObjectMap.get(-1).get().get()).isEqualTo("provision-string");
+
+    assertThat(component.integerProducedOfObjectMap().get())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                123, Produced.successful("123-string"),
+                456, Produced.successful("456-string"),
+                789, Produced.successful("789-string"),
+                -1, Produced.successful("provision-string")));
+
+    assertThat(component.qualifiedIntegerObjectMap().get()).hasSize(1);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 45ebf760e..afd8f0e2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -63,12 +63,12 @@
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
@@ -347,24 +347,18 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             Set<ContributionBinding> multibindings = new LinkedHashSet<>();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
-            ImmutableSet.Builder<DelegateDeclaration> delegateDeclarationsBuilder =
-                ImmutableSet.builder();
 
             for (Key keyOrImplicitKey : explicitAndImplicitKeys(key)) {
               contributionBindings.addAll(getExplicitBindings(keyOrImplicitKey));
+              contributionBindings.addAll(
+                  delegateBindings(getDelegateDeclarations(keyOrImplicitKey)));
+
               multibindings.addAll(getExplicitMultibindings(keyOrImplicitKey));
-              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(keyOrImplicitKey));
-              delegateDeclarationsBuilder.addAll(getDelegateDeclarations(keyOrImplicitKey));
               multibindings.addAll(
                   delegateBindings(getDelegateMultibindingDeclarations(keyOrImplicitKey)));
-            }
-
-            ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
-                multibindingDeclarationsBuilder.build();
-            ImmutableSet<DelegateDeclaration> delegateDeclarations =
-                delegateDeclarationsBuilder.build();
 
-            contributionBindings.addAll(delegateBindings(delegateDeclarations));
+              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(keyOrImplicitKey));
+            }
 
             // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
@@ -386,18 +380,21 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.syntheticMapOfValuesBinding(request));
             }
 
+            ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
+                multibindingDeclarationsBuilder.build();
+
             Iterable<? extends HasBindingType> multibindingsAndDeclarations =
                 Iterables.concat(multibindings, multibindingDeclarations);
             if (Iterables.any(
                 multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
-              /* If there are production multibindings, add a synthetic binding that depends on each
-               * individual multibinding. */
+            /* If there are production multibindings, add a synthetic binding that depends on each
+             * individual multibinding. */
               contributionBindings.add(
                   productionBindingFactory.syntheticMultibinding(request, multibindings));
             } else if (Iterables.any(
                 multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
-              /* If there are provision multibindings but not production ones, add a synthetic
-               * binding that depends on each individual multibinding. */
+            /* If there are provision multibindings but not production ones, add a synthetic
+             * binding that depends on each individual multibinding. */
               contributionBindings.add(
                   provisionBindingFactory.syntheticMultibinding(request, multibindings));
             }
@@ -406,8 +403,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
              * declarations, use an implicit @Inject- constructed binding if there is one. */
             if (contributionBindings.isEmpty()
                 && multibindings.isEmpty()
-                && multibindingDeclarations.isEmpty()
-                && delegateDeclarations.isEmpty()) {
+                && multibindingDeclarations.isEmpty()) {
               contributionBindings.addAll(
                   injectBindingRegistry.getOrFindProvisionBinding(key).asSet());
             }
@@ -439,13 +435,25 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             .build();
       }
 
-      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> key) {
-        if (!key.isPresent()) {
+      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey) {
+        if (!maybeKey.isPresent()) {
           return false;
         }
-        return !getExplicitMultibindings(key.get()).isEmpty()
-            || !getMultibindingDeclarations(key.get()).isEmpty()
-            || !getDelegateDeclarations(key.get()).isEmpty();
+
+        Key key = maybeKey.get();
+        if (!getExplicitMultibindings(key).isEmpty()
+            || !getMultibindingDeclarations(key).isEmpty()) {
+          return true;
+        }
+
+        ImmutableSet<ContributionBinding> delegateBindings =
+            delegateBindings(getDelegateMultibindingDeclarations(key));
+        for (ContributionBinding delegateBinding : delegateBindings) {
+          if (delegateBinding.key().withoutBindingMethodIdentifier().equals(key)) {
+            return true;
+          }
+        }
+        return false;
       }
 
       private ImmutableSet<ContributionBinding> delegateBindings(
@@ -605,7 +613,8 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return multibindingDeclarations.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key key) {
+      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key requestKey) {
+        Key key = keyFactory.convertToDelegateKey(requestKey);
         ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
             ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
@@ -614,7 +623,14 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateDeclarations.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateMultibindingDeclarations(Key key) {
+      private ImmutableSet<DelegateDeclaration> getDelegateMultibindingDeclarations(
+          Key requestKey) {
+        if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
+          // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All @IntoMap
+          // requests must be for Map<K, Framework<V>>.
+          return ImmutableSet.of();
+        }
+        Key key = keyFactory.convertToDelegateKey(requestKey);
         ImmutableSet.Builder<DelegateDeclaration> delegateMultibindingDeclarations =
             ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f2a96204f..7eb4663ad 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -82,6 +82,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
@@ -432,7 +433,7 @@ private void validateResolvedBinding(DependencyPath path) {
           }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
-                inlineSyntheticContributions(resolvedBinding).contributionBindings();
+                inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
             validateMapKeySet(path, multibindings);
             validateMapKeyAnnotationTypes(path, multibindings);
           }
@@ -470,12 +471,16 @@ private void validateResolvedBinding(DependencyPath path) {
      *     {@code Y}.
      * </ul>
      *
-     * then {@code inlineSyntheticBindings(bindingsForKey1)} has bindings {@code A}, {@code C}, and
-     * {@code D}, with multibinding declarations {@code X} and {@code Y}.
+     * then {@code inlineSyntheticNondelegateContributions(bindingsForKey1)} has bindings {@code A},
+     * {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
      *
      * <p>The replacement is repeated until none of the bindings are synthetic.
      */
-    private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
+    // TODO(dpb): The actual operation we want is to inline bindings without real binding elements.
+    // Delegate bindings are the first example of synthetic bindings that have real binding elements
+    // and nonsynthetic dependencies.
+    private ResolvedBindings inlineSyntheticNondelegateContributions(
+        ResolvedBindings resolvedBinding) {
       if (!FluentIterable.from(resolvedBinding.contributionBindings())
           .transform(ContributionBinding.KIND)
           .anyMatch(IS_SYNTHETIC_KIND)) {
@@ -496,7 +501,8 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
             queued.allContributionBindings().entries()) {
           BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
           ContributionBinding binding = bindingEntry.getValue();
-          if (binding.isSyntheticBinding()) {
+          if (binding.isSyntheticBinding()
+              && !binding.bindingKind().equals(SYNTHETIC_DELEGATE_BINDING)) {
             for (DependencyRequest dependency : binding.dependencies()) {
               queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
@@ -514,7 +520,7 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
 
     private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
         ResolvedBindings resolvedBinding) {
-      ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
+      ResolvedBindings inlined = inlineSyntheticNondelegateContributions(resolvedBinding);
       return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
           .putAll(indexByContributionType(inlined.contributionBindings()))
           .putAll(indexByContributionType(inlined.multibindingDeclarations()))
@@ -1029,7 +1035,7 @@ private void reportDuplicateBindings(DependencyPath path) {
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineSyntheticContributions(resolvedBinding).contributionBindings();
+          inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
       bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index dc8929ceb..dd97aa422 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -24,6 +24,7 @@
 import dagger.multibindings.IntoMap;
 import dagger.producers.ProducerModule;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -78,21 +79,15 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
     }
   }
 
-  @Override
-  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMultibindings(builder);
-    if (isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
-      builder.addError("@Binds @IntoMap is not yet supported");
-    }
-  }
-
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    List<? extends VariableElement> parameters = builder.getSubject().getParameters();
+    ExecutableElement method = builder.getSubject();
+    List<? extends VariableElement> parameters = method.getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = builder.getSubject().getReturnType();
+      TypeMirror leftHandSide = method.getReturnType();
       TypeMirror rightHandSide = parameter.asType();
-      switch (ContributionType.fromBindingMethod(builder.getSubject())) {
+      ContributionType contributionType = ContributionType.fromBindingMethod(method);
+      switch (contributionType) {
         case SET_VALUES:
           if (!SetType.isSet(leftHandSide)) {
             builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
@@ -110,18 +105,28 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
               rightHandSide,
               methodParameterType(parameterizedSetType, "add"));
           break;
+        case MAP:
+          DeclaredType parameterizedMapType =
+              types.getDeclaredType(mapElement(), unboundedWildcard(), leftHandSide);
+          validateTypesAreAssignable(
+              builder,
+              rightHandSide,
+              methodParameterTypes(parameterizedMapType, "put").get(1));
+          break;
         case UNIQUE:
           validateTypesAreAssignable(builder, rightHandSide, leftHandSide);
           break;
         default:
-          // @IntoMap not yet supported
+          throw new AssertionError(
+              String.format(
+                  "Unknown contribution type (%s) for method: %s", contributionType, method));
       }
     } else {
       builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
     }
   }
 
-  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
+  private ImmutableList<TypeMirror> methodParameterTypes(DeclaredType type, String methodName) {
     ImmutableList.Builder<ExecutableElement> methodsForName = ImmutableList.builder();
     for (ExecutableElement method :
         ElementFilter.methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {
@@ -130,10 +135,14 @@ private TypeMirror methodParameterType(DeclaredType type, String methodName) {
       }
     }
     ExecutableElement method = getOnlyElement(methodsForName.build());
-    return getOnlyElement(
+    return ImmutableList.<TypeMirror>copyOf(
         MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());
   }
 
+  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
+    return getOnlyElement(methodParameterTypes(type, methodName));
+  }
+
   private void validateTypesAreAssignable(
       ValidationReport.Builder<ExecutableElement> builder,
       TypeMirror rightHandSide,
@@ -146,4 +155,12 @@ private void validateTypesAreAssignable(
   private TypeElement setElement() {
     return elements.getTypeElement(Set.class.getName());
   }
+
+  private TypeElement mapElement() {
+    return elements.getTypeElement(Map.class.getName());
+  }
+
+  private TypeMirror unboundedWildcard() {
+    return types.getWildcardType(null, null);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index fe22d2b11..627d6a86b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -30,6 +30,7 @@
 import dagger.MapKey;
 import dagger.Provides;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.producers.Producer;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index 7997581ef..e2bf84705 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -40,6 +40,8 @@
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -67,7 +69,8 @@ DelegateDeclaration create(
           keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
           bindsMethod,
           Optional.of(contributingElement),
-          delegateRequest);
+          delegateRequest,
+          wrapOptionalInEquivalence(getMapKey(bindsMethod)));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 29f804b3b..9ca9ef07f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -270,7 +270,7 @@ private TypeElement getProducerElement() {
     }
 
     private TypeElement getClassElement(Class<?> cls) {
-      return elements.getTypeElement(cls.getCanonicalName());
+      return elements.getTypeElement(cls.getName());
     }
 
     Key forComponentMethod(ExecutableElement componentMethod) {
@@ -322,7 +322,7 @@ private Key forProvidesOrProducesMethod(
         returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
+          bindingMethodKeyType(returnType, method, contributionType, Optional.of(frameworkType));
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
@@ -334,7 +334,7 @@ private Key forProvidesOrProducesMethod(
      * Returns the key for a {@link Multibinds @Multibinds} method or a method in a
      * {@link Multibindings @Multibindings} interface.
      *
-     * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
+     * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
      * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
      */
     Key forMultibindsMethod(
@@ -360,11 +360,7 @@ Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
       TypeMirror returnType = normalize(types, methodType.getReturnType());
       TypeMirror keyType =
           bindingMethodKeyType(
-              // TODO(ronshapiro): Map<K, Framework<V>> can't be determined at this point. When
-              // @IntoMap support is added, consider replacing getProviderElement() with a
-              // placeholder type, which is then replaced when the DelegateDeclaration is translated
-              // into a Provision or ProductionBinding
-              returnType, method, contributionType, getProviderElement());
+              returnType, method, contributionType, Optional.<TypeElement>absent());
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
@@ -377,14 +373,18 @@ private TypeMirror bindingMethodKeyType(
         TypeMirror returnType,
         ExecutableElement method,
         ContributionType contributionType,
-        TypeElement frameworkType) {
+        Optional<TypeElement> frameworkType) {
       switch (contributionType) {
         case UNIQUE:
           return returnType;
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFrameworkType(mapKeyType(method), frameworkType, returnType);
+          if (frameworkType.isPresent()) {
+            return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
+          } else {
+            return types.getDeclaredType(getMapElement(), mapKeyType(method), returnType);
+          }
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(SetType.isSet(returnType));
@@ -394,6 +394,20 @@ private TypeMirror bindingMethodKeyType(
       }
     }
 
+    /**
+     * Returns the key for a binding associated with a {@link DelegateDeclaration}.
+     *
+     * If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map<K, V>} key
+     * from {@link DelegateDeclaration#key()} to {@code Map<K, FrameworkType<V>>}. If {@code
+     * delegateDeclaration} is not a map contribution, its key is returned.
+     */
+    Key forDelegateBinding(
+        DelegateDeclaration delegateDeclaration, Class<?> frameworkType) {
+      return delegateDeclaration.contributionType().equals(ContributionType.MAP)
+          ? wrapMapValue(delegateDeclaration.key(), frameworkType)
+          : delegateDeclaration.key();
+    }
+
     /**
      * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
      */
@@ -477,6 +491,41 @@ Key forProductionImplementationExecutor() {
           .or(maybeWrapMapValue(possibleMapKey, Producer.class));
     }
 
+    /**
+     * Keys for map contributions from {@link dagger.Provides} and {@link dagger.producers.Produces}
+     * are in the form {@code Map<K, Framework<V>>}, but keys for {@link Binds} methods are just
+     * {@code Map<K, V>} since the framework type is not known until graph resolution. This
+     * translates from the {@code @Provides}/{@code @Produces} format into the {@code @Binds}
+     * format. If {@link Key#type() possibleMapKey.type()} is not a {@code Map<K, Framework<V>>},
+     * returns {@code possibleMapKey}.
+     */
+    Key convertToDelegateKey(Key possibleMapKey) {
+      if (!MapType.isMap(possibleMapKey)) {
+        return possibleMapKey;
+      }
+      MapType mapType = MapType.from(possibleMapKey);
+      TypeMirror wrappedValueType;
+      if (mapType.valuesAreTypeOf(Provider.class)) {
+        wrappedValueType = mapType.unwrappedValueType(Provider.class);
+      } else if (mapType.valuesAreTypeOf(Producer.class)) {
+        wrappedValueType = mapType.unwrappedValueType(Producer.class);
+      } else {
+        return possibleMapKey;
+      }
+      return possibleMapKey.withType(
+          types, types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType));
+    }
+
+    /**
+     * Converts a {@link Key} of type {@code Map<K, V>} to {@code Map<K, Provider<V>>}.
+     */
+    private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
+      checkArgument(
+          FrameworkTypes.isFrameworkType(
+              elements.getTypeElement(newWrappingClass.getName()).asType()));
+      return maybeWrapMapValue(key, newWrappingClass).get();
+    }
+
     /**
      * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
      * {@code Map<K, CurrentWrappingClass<V>>}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index aa481cf0b..70cc61fde 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -79,6 +79,14 @@ boolean valuesAreTypeOf(Class<?> clazz) {
     return MoreTypes.isType(valueType()) && MoreTypes.isTypeOf(clazz, valueType());
   }
 
+  /**
+   * Returns {@code true} if the {@linkplain #valueType() value type} of the {@link Map} is a
+   * {@linkplain FrameworkTypes#isFrameworkType(TypeMirror) framework type}.
+   */
+  boolean valuesAreFrameworkType() {
+    return FrameworkTypes.isFrameworkType(valueType());
+  }
+  
   /**
    * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 2ad2ea892..b062789dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -200,15 +201,16 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
 
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
+      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Producer.class);
       return new AutoValue_ProductionBinding(
           delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
-          delegateDeclaration.key(),
+          key,
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           delegateBinding.nullableType(),
           Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          delegateDeclaration.wrappedMapKey(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 748b3733f..8a8ac1cfd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -286,15 +287,16 @@ ProvisionBinding forSubcomponentBuilderMethod(
 
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
+      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Provider.class);
       return new AutoValue_ProvisionBinding(
           delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
-          delegateDeclaration.key(),
+          key,
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          delegateDeclaration.wrappedMapKey(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 57c702b7b..16ce9b532 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -99,12 +99,6 @@ public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
   }
 
-  @Test
-  public void intoMap() {
-    assertThatMethod("@Binds @IntoMap @IntKey(1) abstract Object bindObject(String string);")
-        .hasError("@Binds @IntoMap is not yet supported");
-  }
-
   @Test
   public void setElementsNotAssignable() {
     assertThatMethod(
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index f81916ff5..ae7bb4b89 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -592,6 +592,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
         "",
+        "import dagger.Binds;",
         "import dagger.Component;",
         "import dagger.MapKey;",
         "import dagger.Module;",
@@ -603,6 +604,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "import java.util.HashSet;",
         "import java.util.Map;",
         "import java.util.Set;",
+        "import javax.inject.Qualifier;",
         "",
         "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
         "final class Outer {",
@@ -611,13 +613,21 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "    String value();",
         "  }",
         "",
+        "  @Qualifier @interface SomeQualifier {}",
+        "",
         "  @Module",
-        "  static class TestModule1 {",
+        "  abstract static class TestModule1 {",
         "    @Provides @IntoMap",
         "    @StringKey(\"foo\")",
-        "    String stringMapEntry() { return \"\"; }",
+        "    static String stringMapEntry() { return \"\"; }",
+        "",
+        "    @Binds @IntoMap @StringKey(\"bar\")",
+        "    abstract String bindStringMapEntry(@SomeQualifier String value);",
+        "",
+        "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
+        "    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
         "",
-        "    @Provides @IntoSet String stringSetElement() { return \"\"; }",
+        "    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \"\"; }",
         "  }",
         "",
         "  @Module",
@@ -641,6 +651,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             + "      Set bindings and declarations:\n"
             + "          @Provides @dagger.multibindings.IntoSet String "
             + "test.Outer.TestModule1.stringSetElement()\n"
+            + "          @Binds @dagger.multibindings.IntoSet String "
+            + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
@@ -651,6 +663,9 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             + "          @Provides @dagger.multibindings.IntoMap "
             + "@test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
+            + "          @Binds @dagger.multibindings.IntoMap "
+            + "@test.Outer.StringKey(\"bar\") String"
+            + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
@@ -660,11 +675,11 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(42)
+        .onLine(52)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(43);
+        .onLine(53);
   }
 
   @Test
