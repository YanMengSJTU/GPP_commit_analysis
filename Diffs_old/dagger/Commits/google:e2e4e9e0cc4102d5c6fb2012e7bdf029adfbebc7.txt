diff --git a/README.md b/README.md
index 587128c7c..37cb9aab8 100644
--- a/README.md
+++ b/README.md
@@ -138,8 +138,7 @@ the GitHub project's master branch.
 
 ## License
 
-    Copyright 2012 Square, Inc.
-    Copyright 2012 Google, Inc.
+    Copyright 2012 The Dagger Authors
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
index 293504518..9fe099f33 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
@@ -24,5 +24,6 @@
   void inject(ChildOfStringArray subfoo);
   void inject(ChildOfArrayOfParentOfStringArray subfoo);
   void inject(ChildOfPrimitiveIntArray subfoo);
+  void inject(RawFrameworkTypes rawFrameworkTypes);
 
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
new file mode 100644
index 000000000..88a473177
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.membersinject;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+// https://github.com/google/dagger/issues/419
+@SuppressWarnings({"rawtypes", "unused"})
+class RawFrameworkTypes {
+  void nonInjectMethodWithARawProvider(Provider rawProvider) {}
+  void nonInjectMethodWithARawLazy(Lazy rawLazy) {}
+  void nonInjectMethodWithARawMembersInjector(MembersInjector rawMembersInjector) {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 1c04441cd..7c2096668 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -17,8 +17,6 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -26,7 +24,6 @@
 import dagger.internal.codegen.Key.HasKey;
 import java.util.Set;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 
 /** An object that declares or specifies a binding. */
@@ -72,30 +69,6 @@ public TypeElement apply(Element element) {
         }
       };
 
-  /**
-   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
-   * method.
-   */
-  boolean requiresModuleInstance() {
-    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
-      return false;
-    }
-    Set<Modifier> modifiers = bindingElement().get().getModifiers();
-    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
-  }
-
-  /**
-   * A predicate that passes for binding declarations for which {@link #requiresModuleInstance()} is
-   * {@code true}.
-   */
-  static final Predicate<BindingDeclaration> REQUIRES_MODULE_INSTANCE =
-      new Predicate<BindingDeclaration>() {
-        @Override
-        public boolean apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.requiresModuleInstance();
-        }
-      };
-
   /**
    * A predicate that passes for binding declarations for which {@link #bindingElement()} is
    * present.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index e184632b2..ab91f9db4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -129,7 +129,7 @@
         .preOrderTraversal(this)
         .transformAndConcat(RESOLVED_BINDINGS)
         .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .filter(BindingDeclaration.REQUIRES_MODULE_INSTANCE)
+        .filter(ContributionBinding.REQUIRES_MODULE_INSTANCE)
         .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 851f2d6e4..933ebd332 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -151,11 +151,7 @@
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
-    try {
-      componentGenerator.generate(bindingGraph);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
+    componentGenerator.generate(bindingGraph, messager);
   }
 
   private ImmutableSet<Element> getElementsFromAnnotations(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index eec00e88f..56bc049d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -22,6 +22,8 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
@@ -44,6 +46,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -167,6 +170,30 @@ static Kind forMultibindingKey(Key key) {
    */
   protected abstract Kind bindingKind();
 
+  /**
+   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
+   * method.
+   */
+  boolean requiresModuleInstance() {
+    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
+      return false;
+    }
+    Set<Modifier> modifiers = bindingElement().get().getModifiers();
+    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
+  }
+
+  /**
+   * A predicate that passes for binding declarations for which {@link #requiresModuleInstance()} is
+   * {@code true}.
+   */
+  static final Predicate<ContributionBinding> REQUIRES_MODULE_INSTANCE =
+      new Predicate<ContributionBinding>() {
+        @Override
+        public boolean apply(ContributionBinding bindingDeclaration) {
+          return bindingDeclaration.requiresModuleInstance();
+        }
+      };
+
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 07d99080a..9a50c3ccc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -115,9 +115,14 @@
      * this kind that represents the dependency request.
      */
     Optional<KindAndType> from(TypeMirror type) {
-      return frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)
-          ? Optional.of(this.ofType(getOnlyElement(asDeclared(type).getTypeArguments())))
-          : Optional.<KindAndType>absent();
+      if (frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)) {
+        List<? extends TypeMirror> typeArguments = asDeclared(type).getTypeArguments();
+        if (typeArguments.isEmpty()) {
+          return Optional.absent();
+        }
+        return Optional.of(this.ofType(getOnlyElement(typeArguments)));
+      }
+      return Optional.<KindAndType>absent();
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index c59715b50..2dfe472c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -19,19 +19,19 @@
 import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
 import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
-import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Types;
 
@@ -67,33 +67,26 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.get(MapKey.class)) {
-      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+    for (TypeElement mapKeyAnnotation : typesIn(elementsByAnnotation.get(MapKey.class))) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotation);
       mapKeyReport.printMessagesTo(messager);
 
       if (mapKeyReport.isClean()) {
-        MapKey mapkey = element.getAnnotation(MapKey.class);
+        MapKey mapkey = mapKeyAnnotation.getAnnotation(MapKey.class);
         if (mapkey.unwrapValue()) {
           DeclaredType keyType =
-              getUnwrappedMapKeyType(MoreTypes.asDeclared(element.asType()), types);
-          if (keyType.asElement().getKind() == ElementKind.ANNOTATION_TYPE) {
-            writeCreatorClass(
+              getUnwrappedMapKeyType(MoreTypes.asDeclared(mapKeyAnnotation.asType()), types);
+          if (keyType.asElement().getKind().equals(ANNOTATION_TYPE)) {
+            mapKeyGenerator.generate(
                 unwrappedMapKeyWithAnnotationValue(
-                    MoreElements.asType(element), MoreTypes.asTypeElement(keyType)));
+                    mapKeyAnnotation, MoreTypes.asTypeElement(keyType)),
+                messager);
           }
         } else {
-          writeCreatorClass(wrappedMapKey(MoreElements.asType(element)));
+          mapKeyGenerator.generate(wrappedMapKey(mapKeyAnnotation), messager);
         }
       }
     }
     return ImmutableSet.of();
   }
-
-  private void writeCreatorClass(MapKeyCreatorSpecification mapKeyCreatorType) {
-    try {
-      mapKeyGenerator.generate(mapKeyCreatorType);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 2d99ece96..b7b94d67d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -148,11 +148,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
           for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
             for (ExecutableElement method :
                 elementsWithAnnotation(moduleMethods, generator.factoryMethodAnnotation())) {
-              try {
-                generator.generate(method, moduleElement);
-              } catch (SourceFileGenerationException e) {
-                e.printMessageTo(messager);
-              }
+              generator.generate(method, moduleElement, messager);
             }
           }
         }
@@ -197,8 +193,7 @@ private boolean moduleMethodsAreValid(
     Class<? extends Annotation> factoryMethodAnnotation();
 
     /** Generates the factory source file for the given method and module. */
-    void generate(ExecutableElement method, TypeElement moduleElement)
-        throws SourceFileGenerationException;
+    void generate(ExecutableElement method, TypeElement moduleElement, Messager messager);
   }
 
   private static final class ProvisionModuleMethodFactoryGenerator
@@ -219,9 +214,9 @@ void generate(ExecutableElement method, TypeElement moduleElement)
     }
 
     @Override
-    public void generate(ExecutableElement method, TypeElement moduleElement)
-        throws SourceFileGenerationException {
-      factoryGenerator.generate(provisionBindingFactory.forProvidesMethod(method, moduleElement));
+    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {
+      factoryGenerator.generate(
+          provisionBindingFactory.forProvidesMethod(method, moduleElement), messager);
     }
   }
 
@@ -244,10 +239,9 @@ public void generate(ExecutableElement method, TypeElement moduleElement)
     }
 
     @Override
-    public void generate(ExecutableElement method, TypeElement moduleElement)
-        throws SourceFileGenerationException {
+    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {
       producerFactoryGenerator.generate(
-          productionBindingFactory.forProducesMethod(method, moduleElement));
+          productionBindingFactory.forProducesMethod(method, moduleElement), messager);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index 03e229ddb..1bd095e29 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -50,11 +50,7 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.values()) {
-      try {
-        monitoringModuleGenerator.generate(MoreElements.asType(element));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      monitoringModuleGenerator.generate(MoreElements.asType(element), messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
index 3b5722378..d508a51e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
@@ -50,11 +50,7 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.values()) {
-      try {
-        productionExecutorModuleGenerator.generate(MoreElements.asType(element));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      productionExecutorModuleGenerator.generate(MoreElements.asType(element), messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 7c41b1c53..4c7e0bc86 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -33,6 +33,7 @@
 import java.io.Writer;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
 import javax.tools.JavaFileObject;
@@ -61,6 +62,18 @@
     generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
 
+  /**
+   * Generates a source file to be compiled for {@code T}. Writes any generation exception to {@code
+   * messager} and does not throw.
+   */
+  void generate(T input, Messager messager) {
+    try {
+      generate(input);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
+
   /** Generates a source file to be compiled for {@code T}. */
   void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 1eee259c5..34ee72c2f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
@@ -1082,4 +1083,35 @@ public void fieldInjectionForShadowedMember() {
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test public void rawFrameworkTypes() {
+    JavaFileObject file =
+        JavaFileObjects.forSourceLines(
+            "test.RawFrameworkTypes",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class RawProviderField {",
+            "  @Inject Provider fieldWithRawProvider;",
+            "}",
+            "",
+            "class RawProviderParameter {",
+            "  @Inject void methodInjection(Provider rawProviderParameter) {}",
+            "}",
+            "",
+            "@Component",
+            "interface C {",
+            "  void inject(RawProviderField rawProviderField);",
+            "  void inject(RawProviderParameter rawProviderParameter);",
+            "}");
+    assertThat(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
+        .and()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
+  }
 }
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 77e305676..6e7376b4b 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -29,8 +29,8 @@
 
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
- * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
- * have the name of the type annotated with {@code @ProductionComponent} prepended with
+ * implementation is to be generated from a set of {@linkplain #modules modules}. The generated
+ * class will have the name of the type annotated with {@code @ProductionComponent} prepended with
  * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
  * produce an implementation named {@code DaggerMyComponent}.
  *
