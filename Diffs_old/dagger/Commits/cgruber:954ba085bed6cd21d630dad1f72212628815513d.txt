diff --git a/BUILD b/BUILD
index a04bf43ca..be3588f0a 100644
--- a/BUILD
+++ b/BUILD
@@ -56,6 +56,20 @@ jarjar_library(
     ],
 )
 
+android_library(
+    name = "android",
+    exported_plugins = ["//java/dagger/android/processor:plugin"],
+    exports = ["//java/dagger/android"],
+)
+
+android_library(
+    name = "android-support",
+    exports = [
+        ":android",
+        "//java/dagger/android/support",
+    ],
+)
+
 load("//tools:javadoc.bzl", "javadoc_library")
 
 # coalesced javadocs used for the gh-pages site
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2a58dcecb..0006c072b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -25,6 +25,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -718,11 +719,7 @@ private ComponentRequirement requirementForBuilderMethod(
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
       ClassName monitoringModuleName =
           SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
-      String generatedMonitorModuleName = monitoringModuleName.toString();
-      TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
-      if (monitoringModule == null) {
-        throw new TypeNotPresentException(generatedMonitorModuleName, null);
-      }
+      TypeElement monitoringModule = checkTypePresent(monitoringModuleName.toString(), elements);
       return moduleDescriptorFactory.create(monitoringModule);
     }
 
@@ -738,12 +735,8 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
         TypeElement componentDefinitionType) {
       ClassName productionExecutorModuleName =
           SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
-      String generatedProductionExecutorModuleName = productionExecutorModuleName.toString();
       TypeElement productionExecutorModule =
-          elements.getTypeElement(generatedProductionExecutorModuleName);
-      if (productionExecutorModule == null) {
-        throw new TypeNotPresentException(generatedProductionExecutorModuleName, null);
-      }
+          checkTypePresent(productionExecutorModuleName.toString(), elements);
       return moduleDescriptorFactory.create(productionExecutorModule);
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
index 8c8e0952f..fe19903b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -169,4 +169,16 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
     }
     return ImmutableSet.copyOf(suppressedWarnings.value());
   }
+
+  /**
+   * Invokes {@link Elements#getTypeElement(CharSequence)}, throwing {@link TypeNotPresentException}
+   * if it is not accessible in the current compilation.
+   */
+  static TypeElement checkTypePresent(String typeName, Elements elements) {
+    TypeElement type = elements.getTypeElement(typeName);
+    if (type == null) {
+      throw new TypeNotPresentException(typeName, null);
+    }
+    return type;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c539bcaa2..52211589f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -16,12 +16,18 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
+import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -32,6 +38,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Module;
@@ -79,8 +86,8 @@
     private final Class<? extends Annotation> methodAnnotation;
 
     /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #moduleAnnotation() annotation types}.
+     * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+     * #moduleAnnotation() annotation types}.
      *
      * @throws IllegalArgumentException if the element is annotated with more than one of the
      *     annotation types
@@ -210,8 +217,35 @@ ModuleDescriptor create(TypeElement moduleElement) {
             .map(MoreTypes::asTypeElement)
             .map(this::create)
             .forEach(includedModules::add);
+
+        collectImplicitlyIncludedModules(includedModules, moduleElement);
       }
       return includedModules;
     }
+
+    // @ContributesAndroidInjector generates a module that is implicitly included in the enclosing
+    // module
+    private void collectImplicitlyIncludedModules(
+        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+      TypeElement contributesAndroidInjector =
+          elements.getTypeElement("dagger.android.ContributesAndroidInjector");
+      if (contributesAndroidInjector == null) {
+        return;
+      }
+      for (ExecutableElement method : methodsIn(moduleElement.getEnclosedElements())) {
+        if (isAnnotationPresent(method, contributesAndroidInjector.asType())) {
+          includedModules.add(
+              create(checkTypePresent(implicitlyIncludedModuleName(method), elements)));
+        }
+      }
+    }
+
+    private String implicitlyIncludedModuleName(ExecutableElement method) {
+      return getPackage(method).getQualifiedName()
+          + "."
+          + classFileName(ClassName.get(MoreElements.asType(method.getEnclosingElement())))
+          + "_"
+          + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
+    }
   }
 }
diff --git a/java/dagger/android/ContributesAndroidInjector.java b/java/dagger/android/ContributesAndroidInjector.java
new file mode 100644
index 000000000..b8c63b268
--- /dev/null
+++ b/java/dagger/android/ContributesAndroidInjector.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import java.lang.annotation.Target;
+
+/**
+ * Generates an {@link AndroidInjector} for the return type of this method. The injector is
+ * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}'s
+ * component.
+ *
+ * <p>This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
+ * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
+ * MyService}, etc). The method should have no parameters.
+ *
+ * <p>For more information, see <a href="https://google.github.io/dagger/android">the docs</a>
+ */
+@Target(METHOD)
+public @interface ContributesAndroidInjector {
+  /** Modules to be installed in the generated {@link dagger.Subcomponent}. */
+  Class<?>[] modules() default {};
+}
diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
new file mode 100644
index 000000000..4c4b6379d
--- /dev/null
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
+import dagger.Module;
+import dagger.android.ContributesAndroidInjector;
+import java.util.List;
+import java.util.Optional;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * A descriptor of a generated {@link Module} and {@link dagger.Subcomponent} to be generated from a
+ * {@link ContributesAndroidInjector} method.
+ */
+@AutoValue
+abstract class AndroidInjectorDescriptor {
+  /** The type to be injected; the return type of the {@link ContributesAndroidInjector} method. */
+  abstract ClassName injectedType();
+
+  /**
+   * The base framework type of {@link #injectedType()}, e.g. {@code Activity}, {@code Fragment},
+   * etc.
+   */
+  abstract ClassName frameworkType();
+
+  /** Scopes to apply to the generated {@link dagger.Subcomponent}. */
+  abstract ImmutableSet<AnnotationSpec> scopes();
+
+  /** @see ContributesAndroidInjector#modules() */
+  abstract ImmutableSet<ClassName> modules();
+
+  /** The {@link Module} that contains the {@link ContributesAndroidInjector} method. */
+  abstract ClassName enclosingModule();
+
+  /** Simple name of the {@link ContributesAndroidInjector} method. */
+  abstract String methodName();
+
+  /**
+   * The {@link dagger.MapKey} annotation that groups {@link #frameworkType()}s, e.g.
+   * {@code @ActivityKey(MyActivity.class)}.
+   */
+  AnnotationSpec mapKeyAnnotation() {
+    String packageName =
+        frameworkType().packageName().contains(".support.")
+            ? "dagger.android.support"
+            : "dagger.android";
+    return AnnotationSpec.builder(ClassName.get(packageName, frameworkType().simpleName() + "Key"))
+        .addMember("value", "$T.class", injectedType())
+        .build();
+  }
+
+  @AutoValue.Builder
+  abstract static class Builder {
+    abstract Builder injectedType(ClassName injectedType);
+
+    abstract ImmutableSet.Builder<AnnotationSpec> scopesBuilder();
+
+    abstract ImmutableSet.Builder<ClassName> modulesBuilder();
+
+    abstract Builder frameworkType(ClassName frameworkType);
+
+    abstract Builder enclosingModule(ClassName enclosingModule);
+
+    abstract Builder methodName(String methodName);
+
+    abstract AndroidInjectorDescriptor build();
+  }
+
+  static final class Validator {
+    private final Types types;
+    private final Elements elements;
+    private final Messager messager;
+
+    Validator(Types types, Elements elements, Messager messager) {
+      this.types = types;
+      this.elements = elements;
+      this.messager = messager;
+    }
+
+    /**
+     * Validates a {@link ContributesAndroidInjector} method, returning an {@link
+     * AndroidInjectorDescriptor} if it is valid, or {@link Optional#empty()} otherwise.
+     */
+    Optional<AndroidInjectorDescriptor> createIfValid(ExecutableElement method) {
+      ErrorReporter reporter = new ErrorReporter(method, messager);
+
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        reporter.reportError("@ContributesAndroidInjector methods must be abstract");
+      }
+
+      if (!method.getParameters().isEmpty()) {
+        reporter.reportError("@ContributesAndroidInjector methods cannot have parameters");
+      }
+
+      AndroidInjectorDescriptor.Builder builder = new AutoValue_AndroidInjectorDescriptor.Builder();
+      builder.methodName(method.getSimpleName().toString());
+      TypeElement enclosingElement = MoreElements.asType(method.getEnclosingElement());
+      if (!isAnnotationPresent(enclosingElement, Module.class)) {
+        reporter.reportError("@ContributesAndroidInjector methods must be in a @Module");
+      }
+      builder.enclosingModule(ClassName.get(enclosingElement));
+
+      TypeMirror injectedType = method.getReturnType();
+      Optional<TypeMirror> maybeFrameworkType =
+          annotationsAndFrameworkTypes(elements)
+              .values()
+              .stream()
+              .filter(frameworkType -> types.isAssignable(injectedType, frameworkType))
+              .findFirst();
+      if (maybeFrameworkType.isPresent()) {
+        builder.frameworkType((ClassName) TypeName.get(maybeFrameworkType.get()));
+        if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
+          builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
+        } else {
+          reporter.reportError(
+              "@ContributesAndroidInjector methods cannot return parameterized types");
+        }
+      } else {
+        reporter.reportError(String.format("%s is not a framework type", injectedType));
+      }
+
+      AnnotationMirror annotation =
+          getAnnotationMirror(method, ContributesAndroidInjector.class).get();
+      for (TypeMirror module :
+          getAnnotationValue(annotation, "modules").accept(new AllTypesVisitor(), null)) {
+        if (isAnnotationPresent(MoreTypes.asElement(module), Module.class)) {
+          builder.modulesBuilder().add((ClassName) TypeName.get(module));
+        } else {
+          reporter.reportError(String.format("%s is not a @Module", module), annotation);
+        }
+      }
+
+      for (AnnotationMirror scope : getAnnotatedAnnotations(method, Scope.class)) {
+        builder.scopesBuilder().add(AnnotationSpec.get(scope));
+      }
+
+      for (AnnotationMirror qualifier : getAnnotatedAnnotations(method, Qualifier.class)) {
+        reporter.reportError(
+            "@ContributesAndroidInjector methods cannot have qualifiers", qualifier);
+      }
+
+      return reporter.hasError ? Optional.empty() : Optional.of(builder.build());
+    }
+
+    // TODO(ronshapiro): use ValidationReport once it is moved out of the compiler
+    private static class ErrorReporter {
+      private final Element subject;
+      private final Messager messager;
+      private boolean hasError;
+
+      ErrorReporter(Element subject, Messager messager) {
+        this.subject = subject;
+        this.messager = messager;
+      }
+
+      void reportError(String error) {
+        hasError = true;
+        messager.printMessage(Kind.ERROR, error, subject);
+      }
+
+      void reportError(String error, AnnotationMirror annotation) {
+        hasError = true;
+        messager.printMessage(Kind.ERROR, error, subject, annotation);
+      }
+    }
+  }
+
+  private static final class AllTypesVisitor
+      extends SimpleAnnotationValueVisitor8<ImmutableSet<TypeMirror>, Void> {
+    @Override
+    public ImmutableSet<TypeMirror> visitArray(List<? extends AnnotationValue> values, Void aVoid) {
+      return ImmutableSet.copyOf(
+          values.stream().flatMap(v -> v.accept(this, null).stream()).collect(toList()));
+    }
+
+    @Override
+    public ImmutableSet<TypeMirror> visitType(TypeMirror a, Void aVoid) {
+      return ImmutableSet.of(a);
+    }
+
+    @Override
+    protected ImmutableSet<TypeMirror> defaultAction(Object o, Void aVoid) {
+      throw new AssertionError(o);
+    }
+  }
+}
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index ae9c08dce..a63b0b81a 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -21,8 +21,7 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static java.util.stream.Collectors.toMap;
-import static javax.lang.model.util.ElementFilter.methodsIn;
+import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -31,12 +30,9 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
-import dagger.MapKey;
 import dagger.android.AndroidInjector;
 import java.lang.annotation.Annotation;
-import java.util.List;
 import java.util.Set;
-import java.util.stream.Stream;
 import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
@@ -46,7 +42,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
@@ -68,39 +63,6 @@
     this.annotationsAndFrameworkTypes = annotationsAndFrameworkTypes(elements);
   }
 
-  private ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes(
-      Elements elements) {
-    return ImmutableMap.copyOf(
-        Stream.of(
-                elements.getPackageElement("dagger.android"),
-                elements.getPackageElement("dagger.android.support"))
-            .filter(element -> element != null)
-            .flatMap(element -> element.getEnclosedElements().stream())
-            .filter(element -> isAnnotationPresent(element, MapKey.class))
-            .filter(element -> element.getAnnotation(MapKey.class).unwrapValue())
-            .flatMap(AndroidMapKeyValidator::classForAnnotationElement)
-            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
-  }
-
-  @SuppressWarnings("unchecked")
-  private static Stream<Class<? extends Annotation>> classForAnnotationElement(Element element) {
-    try {
-      return Stream.of((Class<? extends Annotation>)
-          Class.forName(MoreElements.asType(element).getQualifiedName().toString()));
-    } catch (ClassNotFoundException e) {
-      return Stream.of();
-    }
-  }
-
-  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
-    List<ExecutableElement> mapKeyMethods =
-        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
-    TypeMirror returnType = getOnlyElement(mapKeyMethods).getReturnType();
-    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
-    return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
-        .getExtendsBound();
-  }
-
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
     return annotationsAndFrameworkTypes.keySet();
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
new file mode 100644
index 000000000..61eee8e75
--- /dev/null
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toMap;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import dagger.MapKey;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.stream.Stream;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
+
+final class AndroidMapKeys {
+
+  /**
+   * Returns the Android framework types available to the compiler, keyed by their associated {@code
+   * dagger.android} {@link MapKey}s. This will always contain the types that are defined by the
+   * framework, and only contain the support library types if they are on the classpath of the
+   * current compilation.
+   */
+  static ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes(
+      Elements elements) {
+    return ImmutableMap.copyOf(
+        Stream.of(
+                elements.getPackageElement("dagger.android"),
+                elements.getPackageElement("dagger.android.support"))
+            .filter(packageElement -> packageElement != null)
+            .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(type -> isAnnotationPresent(type, MapKey.class))
+            .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
+            .flatMap(AndroidMapKeys::classForAnnotationElement)
+            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
+  }
+
+  private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
+    try {
+      @SuppressWarnings("unchecked")
+      Class<? extends Annotation> clazz =
+          (Class<? extends Annotation>) Class.forName(type.getQualifiedName().toString());
+      return Stream.of(clazz);
+    } catch (ClassNotFoundException e) {
+      return Stream.of();
+    }
+  }
+
+  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
+    List<ExecutableElement> mapKeyMethods =
+        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
+    TypeMirror returnType = getOnlyElement(mapKeyMethods).getReturnType();
+    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
+    return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
+        .getExtendsBound();
+  }
+}
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index b69bb4e2e..7bb44474a 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -19,8 +19,13 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.lang.model.SourceVersion;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
@@ -30,11 +35,15 @@
 public final class AndroidProcessor extends BasicAnnotationProcessor {
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
+    Filer filer = new FormattingFiler(processingEnv.getFiler());
+    Messager messager = processingEnv.getMessager();
+    Elements elements = processingEnv.getElementUtils();
+    Types types = processingEnv.getTypeUtils();
+
     return ImmutableList.of(
-        new AndroidMapKeyValidator(
-            processingEnv.getElementUtils(),
-            processingEnv.getTypeUtils(),
-            processingEnv.getMessager()));
+        new AndroidMapKeyValidator(elements, types, messager),
+        new ContributesAndroidInjectorGenerator(
+            filer, new AndroidInjectorDescriptor.Validator(types, elements, messager)));
   }
 
   @Override
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index 9167fad25..1c561980f 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -37,6 +37,8 @@ java_library(
         "//third_party:auto_service",
         "//third_party:auto_value",
         "//third_party:auto_common",
+        "//third_party:javapoet",
+        "//third_party:google_java_format",
         "//core",
         # https://github.com/bazelbuild/bazel/issues/2517
         "//java/dagger/android:libandroid.jar",
@@ -46,6 +48,7 @@ java_library(
 
 java_plugin(
     name = "plugin",
+    generates_api = 1,
     processor_class = "dagger.android.processor.AndroidProcessor",
     deps = [":processor"],
 )
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
new file mode 100644
index 000000000..10236dfbb
--- /dev/null
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.WildcardTypeName;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjector;
+import dagger.android.ContributesAndroidInjector;
+import dagger.multibindings.IntoMap;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/** Generates the implementation specified in {@link ContributesAndroidInjector}. */
+final class ContributesAndroidInjectorGenerator implements ProcessingStep {
+
+  private final Filer filer;
+  private final AndroidInjectorDescriptor.Validator validator;
+
+  ContributesAndroidInjectorGenerator(Filer filer, AndroidInjectorDescriptor.Validator validator) {
+    this.filer = filer;
+    this.validator = validator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ContributesAndroidInjector.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
+      validator.createIfValid(method).ifPresent(this::generate);
+    }
+    return ImmutableSet.of();
+  }
+
+  private void generate(AndroidInjectorDescriptor descriptor) {
+    ClassName moduleName =
+        descriptor
+            .enclosingModule()
+            .topLevelClassName()
+            .peerClass(
+                Joiner.on('_').join(descriptor.enclosingModule().simpleNames())
+                    + "_"
+                    + LOWER_CAMEL.to(UPPER_CAMEL, descriptor.methodName()));
+
+    String baseName = descriptor.injectedType().simpleName();
+    ClassName subcomponentName = moduleName.nestedClass(baseName + "Subcomponent");
+    ClassName subcomponentBuilderName = subcomponentName.nestedClass("Builder");
+
+    TypeSpec module =
+        classBuilder(moduleName)
+            .addModifiers(PUBLIC, ABSTRACT)
+            .addAnnotation(
+                AnnotationSpec.builder(Module.class)
+                    .addMember("subcomponents", "$T.class", subcomponentName)
+                    .build())
+            .addMethod(bindAndroidInjectorFactory(descriptor, subcomponentBuilderName))
+            .addType(subcomponent(descriptor, subcomponentName, subcomponentBuilderName))
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
+            .build();
+    try {
+      JavaFile.builder(moduleName.packageName(), module)
+          .skipJavaLangImports(true)
+          .build()
+          .writeTo(filer);
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private MethodSpec bindAndroidInjectorFactory(
+      AndroidInjectorDescriptor descriptor, ClassName subcomponentBuilderName) {
+    return methodBuilder("bindAndroidInjectorFactory")
+        .addAnnotation(Binds.class)
+        .addAnnotation(IntoMap.class)
+        .addAnnotation(descriptor.mapKeyAnnotation())
+        .addModifiers(ABSTRACT)
+        .returns(
+            parameterizedTypeName(
+                AndroidInjector.Factory.class,
+                WildcardTypeName.subtypeOf(descriptor.frameworkType())))
+        .addParameter(subcomponentBuilderName, "builder")
+        .build();
+  }
+
+  private TypeSpec subcomponent(
+      AndroidInjectorDescriptor descriptor,
+      ClassName subcomponentName,
+      ClassName subcomponentBuilderName) {
+    AnnotationSpec.Builder subcomponentAnnotation = AnnotationSpec.builder(Subcomponent.class);
+    for (ClassName module : descriptor.modules()) {
+      subcomponentAnnotation.addMember("modules", CodeBlock.of("$T.class", module));
+    }
+
+    return interfaceBuilder(subcomponentName)
+        .addModifiers(PUBLIC)
+        .addAnnotation(subcomponentAnnotation.build())
+        .addAnnotations(descriptor.scopes())
+        .addSuperinterface(parameterizedTypeName(AndroidInjector.class, descriptor.injectedType()))
+        .addType(subcomponentBuilder(descriptor, subcomponentBuilderName))
+        .build();
+  }
+
+  private TypeSpec subcomponentBuilder(
+      AndroidInjectorDescriptor descriptor, ClassName subcomponentBuilderName) {
+    return classBuilder(subcomponentBuilderName)
+        .addAnnotation(Builder.class)
+        .addModifiers(PUBLIC, ABSTRACT, STATIC)
+        .superclass(parameterizedTypeName(AndroidInjector.Builder.class, descriptor.injectedType()))
+        .build();
+  }
+
+  private static ParameterizedTypeName parameterizedTypeName(
+      Class<?> clazz, TypeName... typeArguments) {
+    return ParameterizedTypeName.get(ClassName.get(clazz), typeArguments);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index fe26ff507..578f19b10 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -120,7 +120,7 @@ public void componentStructureFollowsControllerStructure() {
 
   @Test
   @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
-  public void AllControllersAreDirectChildrenOfApplication() {
+  public void allControllersAreDirectChildrenOfApplication() {
     assertThat(activity.componentHierarchy)
         .containsExactly(
             AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
@@ -163,6 +163,49 @@ public void AllControllersAreDirectChildrenOfApplication() {
     changeConfiguration();
   }
 
+  @Test
+  @Config(manifest = MANIFEST, application = UsesGeneratedModulesApplication.class)
+  public void usesGeneratedModules() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyIntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyBroadcastReceiverSubcomponent.class);
+
+    assertThat(contentProvider.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyContentProviderSubcomponent.class);
+
+    changeConfiguration();
+
+    TestActivityWithScope activityWithScope =
+        Robolectric.setupActivity(TestActivityWithScope.class);
+    assertThat(activityWithScope.scopedStringProvider.get())
+        .isSameAs(activityWithScope.scopedStringProvider.get());
+  }
+
   // https://github.com/google/dagger/issues/598
   private void changeConfiguration() {
     Configuration oldConfiguration = activity.getResources().getConfiguration();
diff --git a/javatests/dagger/android/support/functional/TestActivityWithScope.java b/javatests/dagger/android/support/functional/TestActivityWithScope.java
new file mode 100644
index 000000000..d7cb89143
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivityWithScope.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatActivity;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+public final class TestActivityWithScope extends DaggerAppCompatActivity {
+  @Inject Provider<String> scopedStringProvider;
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
new file mode 100644
index 000000000..ff43e3959
--- /dev/null
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.android.AndroidInjector;
+import dagger.android.ContributesAndroidInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.DaggerApplication;
+import dagger.multibindings.IntoSet;
+import java.lang.annotation.Retention;
+import java.util.UUID;
+import javax.inject.Scope;
+
+public final class UsesGeneratedModulesApplication extends DaggerApplication {
+
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerUsesGeneratedModulesApplication_ApplicationComponent.create();
+  }
+
+  @Component(modules = {ApplicationModule.class, AndroidSupportInjectionModule.class})
+  interface ApplicationComponent extends AndroidInjector<UsesGeneratedModulesApplication> {}
+
+  @Module
+  abstract static class ApplicationModule {
+    @Provides
+    @IntoSet
+    static Class<?> addToComponentHierarchy() {
+      return ApplicationComponent.class;
+    }
+
+    @ActivityScope
+    @ContributesAndroidInjector(modules = ActivityScopedModule.class)
+    abstract TestActivityWithScope contributeTestActivityWithScopeInjector();
+
+    @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
+    abstract TestActivity contributeTestActivityInjector();
+
+    @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
+    abstract TestParentFragment contributeTestParentFragmentInjector();
+
+    @ContributesAndroidInjector(modules = DummyChildFragmentSubcomponent.AddToHierarchy.class)
+    abstract TestChildFragment contributeTestChildFragmentInjector();
+
+    @ContributesAndroidInjector(modules = DummyServiceSubcomponent.AddToHierarchy.class)
+    abstract TestService contributeTestServiceInjector();
+
+    @ContributesAndroidInjector(modules = DummyIntentServiceSubcomponent.AddToHierarchy.class)
+    abstract TestIntentService contributeTestIntentServiceInjector();
+
+    @ContributesAndroidInjector(modules = DummyBroadcastReceiverSubcomponent.AddToHierarchy.class)
+    abstract TestBroadcastReceiver contributeTestBroadcastReceiverInjector();
+
+    @ContributesAndroidInjector(modules = DummyContentProviderSubcomponent.AddToHierarchy.class)
+    abstract TestContentProvider contributeTestContentProviderInjector();
+  }
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ActivityScope {}
+
+  @Module
+  static class ActivityScopedModule {
+    @Provides
+    @ActivityScope
+    static String provideScopedString() {
+      return UUID.randomUUID().toString();
+    }
+  }
+
+  interface DummyActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyActivitySubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyParentFragmentSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyParentFragmentSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyChildFragmentSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyChildFragmentSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyServiceSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyServiceSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyIntentServiceSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyIntentServiceSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyBroadcastReceiverSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyBroadcastReceiverSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyContentProviderSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyContentProviderSubcomponent.class;
+      }
+    }
+  }
+}
