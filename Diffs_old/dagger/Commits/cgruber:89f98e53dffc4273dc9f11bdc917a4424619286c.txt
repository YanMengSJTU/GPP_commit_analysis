diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
index 6277e621a..3c8ee5823 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
@@ -17,8 +17,11 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
+import java.util.Map;
 import java.util.Set;
+import producerstest.MultibindingProducerModule.PossiblyThrowingMap;
 import producerstest.MultibindingProducerModule.PossiblyThrowingSet;
 
 @ProductionComponent(modules = MultibindingProducerModule.class)
@@ -30,4 +33,14 @@
 
   @PossiblyThrowingSet
   ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
+
+  ListenableFuture<Map<Integer, String>> map();
+
+  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducers();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducers();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
index 09cd5bdbc..780ac7219 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
@@ -18,11 +18,13 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.mapkeys.IntKey;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
 import javax.inject.Qualifier;
 
+import static dagger.producers.Produces.Type.MAP;
 import static dagger.producers.Produces.Type.SET;
 import static dagger.producers.Produces.Type.SET_VALUES;
 
@@ -31,6 +33,9 @@
   @Qualifier
   @interface PossiblyThrowingSet {}
 
+  @Qualifier
+  @interface PossiblyThrowingMap {}
+
   @Produces(type = SET)
   static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
@@ -73,4 +78,30 @@ static String successfulStringForSet() {
   static String throwingStringForSet() {
     throw new RuntimeException("monkey");
   }
+
+  @Produces(type = MAP)
+  @IntKey(42)
+  static ListenableFuture<String> futureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces(type = MAP)
+  @IntKey(15)
+  static String valueFor15() {
+    return "fifteen";
+  }
+
+  @Produces(type = MAP)
+  @PossiblyThrowingMap
+  @IntKey(42)
+  static ListenableFuture<String> successfulFutureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces(type = MAP)
+  @PossiblyThrowingMap
+  @IntKey(15)
+  static String throwingValueFor15() {
+    throw new RuntimeException("monkey");
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
index 4ddc7c6bc..3b189d4d0 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
@@ -16,9 +16,12 @@
 package producerstest;
 
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
 import dagger.producers.Produced;
+import dagger.producers.Producer;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import org.junit.Test;
@@ -26,6 +29,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
 public class MultibindingTest {
@@ -70,4 +74,57 @@ public void setBindingOfProducedWithFailures() throws Exception {
     assertThat(failures).hasSize(1);
     assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
   }
+
+  @Test
+  public void mapBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, String> map = multibindingComponent.map().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry(15, "fifteen");
+    assertThat(map).containsEntry(42, "forty two");
+  }
+
+  @Test
+  public void mapOfProducerBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducers().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+  }
+
+  @Test
+  public void mapBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    try {
+      multibindingComponent.possiblyThrowingMap().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void mapOfProducerBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Map<Integer, Producer<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProducers().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    ListenableFuture<String> future = map.get(15).get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 9edcd3295..e5168ac1b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -52,6 +52,8 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.MapOfProducerProducer;
+import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
@@ -796,17 +798,10 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
 
   private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-
-    if (Iterables.any(
-        resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))) {
-      // TODO(beder): Implement producer map bindings.
-      throw new IllegalStateException("producer map bindings not implemented yet");
-    }
     for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       Optional<MemberSelect> multibindingContributionSnippet =
           getMultibindingContributionSnippet(binding);
-      if (MapType.from(binding.key().type()).valuesAreTypeOf(Provider.class)
-          && multibindingContributionSnippet.isPresent()
+      if (multibindingContributionSnippet.isPresent()
           && multibindingContributionSnippet.get().owningClass().equals(name)) {
         initializationSnippets.add(
             Snippet.format(
@@ -1048,9 +1043,20 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
             MapType.isMap(binding.key().type()),
             "Expected synthetic binding to be for a map: %s",
             binding);
+        final ClassName contributionClassName;
+        switch (binding.bindingType()) {
+          case PRODUCTION:
+            contributionClassName = ClassName.fromClass(MapProducer.class);
+            break;
+          case PROVISION:
+            contributionClassName = ClassName.fromClass(MapFactory.class);
+            break;
+          default:
+            throw new AssertionError();
+        }
         return Snippet.format(
             "%s.create(%s)",
-            ClassName.fromClass(MapFactory.class),
+            contributionClassName,
             getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
                 .getSnippetFor(name));
 
@@ -1114,13 +1120,19 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
 
   private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
     MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
+    boolean hasProductionContribution =
+        Iterables.any(
+            resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION));
     ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
     snippets.add(
         Snippet.format(
             "%s.<%s, %s>builder(%d)",
-            ClassName.fromClass(MapProviderFactory.class),
+            ClassName.fromClass(
+                hasProductionContribution ? MapOfProducerProducer.class : MapProviderFactory.class),
             TypeNames.forTypeMirror(mapType.keyType()),
-            TypeNames.forTypeMirror(mapType.unwrappedValueType(Provider.class)),
+            TypeNames.forTypeMirror(
+                mapType.unwrappedValueType(
+                    hasProductionContribution ? Producer.class : Provider.class)),
             resolvedBindings.contributionBindings().size()));
 
     for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 73600608a..56cb6d25a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -27,7 +27,6 @@
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Provides.Type;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -41,13 +40,13 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
+import dagger.producers.Produces.Type;
 import dagger.producers.internal.AbstractProducer;
 import dagger.producers.internal.Producers;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import java.util.List;
 import java.util.concurrent.Executor;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -207,7 +206,8 @@ public boolean apply(DependencyRequest dependency) {
             futureTypeName,
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
-            getInvocationSnippet(!returnsFuture, binding, futureTransform.parameterSnippets()));
+            getInvocationSnippet(
+                !returnsFuture, binding, providedTypeName, futureTransform.parameterSnippets()));
     computeMethodWriter
         .body()
         .addSnippet(
@@ -450,10 +450,14 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
    * @param binding The binding to generate the invocation snippet for.
+   * @param providedTypeName The type name that should be provided by this producer.
    * @param parameterSnippets The snippets for all the parameters to the producer method.
    */
   private Snippet getInvocationSnippet(
-      boolean wrapWithFuture, ProductionBinding binding, ImmutableList<Snippet> parameterSnippets) {
+      boolean wrapWithFuture,
+      ProductionBinding binding,
+      TypeName providedTypeName,
+      ImmutableList<Snippet> parameterSnippets) {
      Snippet moduleSnippet = Snippet.format("%s.%s(%s)",
         binding.bindingElement().getModifiers().contains(STATIC)
             ? ClassName.fromTypeElement(binding.bindingTypeElement())
@@ -487,7 +491,7 @@ private Snippet getInvocationSnippet(
             ? Snippet.format(
                 "%s.<%s>immediateFuture(%s)",
                 ClassName.fromClass(Futures.class),
-                TypeNames.forTypeMirror(binding.key().type()),
+                providedTypeName,
                 valueSnippet)
             : valueSnippet;
     return Snippet.format(
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
new file mode 100644
index 000000000..18338d055
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.Map;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
+ * immediate future of {@code Map<K, Producer<V>>} when calling {@link #get}.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
+  private static final MapOfProducerProducer<Object, Object> EMPTY =
+      new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
+
+  private final ImmutableMap<K, Producer<V>> contributingMap;
+
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  /** Returns a producer of an empty map. */
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> MapOfProducerProducer<K, V> empty() {
+    return (MapOfProducerProducer<K, V>) EMPTY;
+  }
+
+  private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
+  }
+
+  @Override
+  public ListenableFuture<Map<K, Producer<V>>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
+  }
+
+  /**
+   * A builder to help build the {@link MapOfProducerProducer}
+   */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(beder): It would be nice to use the size, but ImmutableMap doesn't allow a pre-sized
+      // map, and Dagger's internal Collections implementation is package-private.
+      this.mapBuilder = ImmutableMap.builder();
+    }
+
+    /** Returns a new {@link MapOfProducerProducer}. */
+    public MapOfProducerProducer<K, V> build() {
+      return new MapOfProducerProducer<K, V>(mapBuilder.build());
+    }
+
+    /** Associates k with producerOfValue in {@code Builder}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
new file mode 100644
index 000000000..61d6a28ac
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
+ * {@code Map<K, V>} which is populated by calls to the delegate {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
+  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+
+  private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    this.mapProducerProducer = mapProducerProducer;
+  }
+
+  /**
+   * Returns a producer of {@code Map<K, V>}, where the map is derived from the given map of
+   * producers by waiting for those producers' resulting futures. The iteration order mirrors the
+   * order of the input map.
+   *
+   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
+   * future will fail with a {@link NullPointerException}.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * component futures fails or is canceled, this one is, too.
+   */
+  public static <K, V> MapProducer<K, V> create(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+    return new MapProducer<K, V>(mapProducerProducer);
+  }
+
+  @Override
+  public ListenableFuture<Map<K, V>> compute(ProducerMonitor unusedMonitor) {
+    return Futures.transformAsync(
+        mapProducerProducer.get(),
+        new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
+          @Override
+          public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
+            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
+            return Futures.transform(
+                Futures.allAsList(
+                    Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
+                new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
+                  @Override
+                  public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
+                    return ImmutableMap.copyOf(entries);
+                  }
+                });
+          }
+        });
+  }
+
+  private static final Function<
+          Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>
+      ENTRY_UNWRAPPER =
+          new Function<
+              Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>() {
+            @Override
+            public ListenableFuture<Map.Entry<Object, Object>> apply(
+                final Map.Entry<Object, Producer<Object>> entry) {
+              return Futures.transform(
+                  entry.getValue().get(),
+                  new Function<Object, Map.Entry<Object, Object>>() {
+                    @Override
+                    public Map.Entry<Object, Object> apply(Object value) {
+                      return Maps.immutableEntry(entry.getKey(), value);
+                    }
+                  });
+            }
+          };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
+  private static <K, V>
+      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
+    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>>)
+        (Function) ENTRY_UNWRAPPER;
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
new file mode 100644
index 000000000..95d110da4
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import dagger.producers.Producer;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class MapOfProducerProducerTest {
+  @Test
+  public void success() throws Exception {
+    MapOfProducerProducer<Integer, String> mapOfProducerProducer =
+        MapOfProducerProducer.<Integer, String>builder(2)
+            .put(15, Producers.<String>immediateProducer("fifteen"))
+            .put(42, Producers.<String>immediateProducer("forty two"))
+            .build();
+    Map<Integer, Producer<String>> map = mapOfProducerProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+  }
+
+  @Test
+  public void failingContributionDoesNotFailMap() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    MapOfProducerProducer<Integer, String> mapOfProducerProducer =
+        MapOfProducerProducer.<Integer, String>builder(2)
+            .put(15, Producers.<String>immediateProducer("fifteen"))
+            .put(42, Producers.<String>immediateFailedProducer(cause))
+            .build();
+    Map<Integer, Producer<String>> map = mapOfProducerProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    try {
+      map.get(42).get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/MapProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
new file mode 100644
index 000000000..7ede26921
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.producers.Producer;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class MapProducerTest {
+  @Test
+  public void success() throws Exception {
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateProducer(
+                ImmutableMap.<Integer, Producer<String>>of(
+                    15,
+                    Producers.<String>immediateProducer("fifteen"),
+                    42,
+                    Producers.<String>immediateProducer("forty two"))));
+    Map<Integer, String> map = mapProducer.get().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry(15, "fifteen");
+    assertThat(map).containsEntry(42, "forty two");
+  }
+
+  @Test
+  public void failingContribution() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateProducer(
+                ImmutableMap.<Integer, Producer<String>>of(
+                    15,
+                    Producers.<String>immediateProducer("fifteen"),
+                    42,
+                    Producers.<String>immediateFailedProducer(cause))));
+    try {
+      mapProducer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+
+  @Test
+  public void failingInput() throws Exception {
+    RuntimeException cause = new RuntimeException("monkey");
+    Producer<Map<Integer, String>> mapProducer =
+        MapProducer.create(
+            Producers.<Map<Integer, Producer<String>>>immediateFailedProducer(cause));
+    try {
+      mapProducer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+}
