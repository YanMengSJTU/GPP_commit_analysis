diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index da282f6bc..d7eb38720 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -90,6 +90,7 @@
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
@@ -102,7 +103,6 @@
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
-import static dagger.internal.codegen.TypeNames.SCOPED_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SET_FACTORY;
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
@@ -997,12 +997,9 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
   }
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
-    return CodeBlocks.format(
-        "$T.create($L)",
-        scope.equals(reusableScope(elements))
-            ? SIMPLE_LAZILY_INITIALIZED_PROVIDER
-            : SCOPED_PROVIDER,
-        factoryCreate);
+    return scope.equals(reusableScope(elements))
+        ? CodeBlocks.format("$T.create($L)", SIMPLE_LAZILY_INITIALIZED_PROVIDER, factoryCreate)
+        : CodeBlocks.format("$T.provider($L)", DOUBLE_CHECK, factoryCreate);
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index acd56f102..61edc72e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -37,7 +37,7 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 
 /**
  * Utilities for generating files.
@@ -125,8 +125,7 @@ static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return CodeBlocks.format(
-            "$T.create($L)", DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
+        return CodeBlocks.format("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
         return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index a4cc8c5d4..b88c6caa0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -24,13 +24,12 @@
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.internal.DelegateFactory;
-import dagger.internal.DoubleCheckLazy;
+import dagger.internal.DoubleCheck;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.SimpleLazilyInitializedProvider;
 import dagger.producers.Produced;
@@ -56,8 +55,8 @@
 
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
-  static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
   static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
+  static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
@@ -78,7 +77,6 @@
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
-  static final ClassName SCOPED_PROVIDER = ClassName.get(ScopedProvider.class);
   static final ClassName SIMPLE_LAZILY_INITIALIZED_PROVIDER =
       ClassName.get(SimpleLazilyInitializedProvider.class);
   static final ClassName SET = ClassName.get(Set.class);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index dbf7987c4..582800e6d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -219,53 +219,54 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return SomeInjectableType_Factory.create();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return SomeInjectableType_Factory.create().get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return SomeInjectableType_Factory.create();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -298,63 +299,63 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import dagger.internal.ScopedProvider;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return someInjectableTypeProvider;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.someInjectableTypeProvider =",
+            "        DoubleCheck.provider(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return someInjectableTypeProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(someInjectableTypeProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return someInjectableTypeProvider;",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a4b796e76..2c4643ad5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -363,79 +363,81 @@
         "                       @QualifierA String qs, Lazy<String> ls,",
         "                       B b, B b2, Provider<B> pb, @QualifierA B qb, Lazy<B> lb) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final Provider<A> aAndA2AndPaAndLaProvider;",
-        "  private final Provider<A> qaProvider;",
-        "  private final Provider<String> sAndS2AndPsAndLsProvider;",
-        "  private final Provider<String> qsProvider;",
-        "  private final Provider<B> bAndB2AndPbAndLbProvider;",
-        "  private final Provider<B> qbProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,",
-        "      Provider<String> sAndS2AndPsAndLsProvider,",
-        "      Provider<String> qsProvider,",
-        "      Provider<B> bAndB2AndPbAndLbProvider,",
-        "      Provider<B> qbProvider) {",
-        "    assert aAndA2AndPaAndLaProvider != null;",
-        "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
-        "    assert qaProvider != null;",
-        "    this.qaProvider = qaProvider;",
-        "    assert sAndS2AndPsAndLsProvider != null;",
-        "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
-        "    assert qsProvider != null;",
-        "    this.qsProvider = qsProvider;",
-        "    assert bAndB2AndPbAndLbProvider != null;",
-        "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
-        "    assert qbProvider != null;",
-        "    this.qbProvider = qbProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    return new GenericClass<A, B>(",
-        "      aAndA2AndPaAndLaProvider.get(),",
-        "      aAndA2AndPaAndLaProvider.get(),",
-        "      aAndA2AndPaAndLaProvider,",
-        "      qaProvider.get(),",
-        "      DoubleCheckLazy.create(aAndA2AndPaAndLaProvider),",
-        "      sAndS2AndPsAndLsProvider.get(),",
-        "      sAndS2AndPsAndLsProvider.get(),",
-        "      sAndS2AndPsAndLsProvider,",
-        "      qsProvider.get(),",
-        "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
-        "      bAndB2AndPbAndLbProvider.get(),",
-        "      bAndB2AndPbAndLbProvider.get(),",
-        "      bAndB2AndPbAndLbProvider,",
-        "      qbProvider.get(),",
-        "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,",
-        "      Provider<String> sAndS2AndPsAndLsProvider,",
-        "      Provider<String> qsProvider,",
-        "      Provider<B> bAndB2AndPbAndLbProvider,",
-        "      Provider<B> qbProvider) {",
-        "    return new GenericClass_Factory<A, B>(",
-        "        aAndA2AndPaAndLaProvider,",
-        "        qaProvider,",
-        "        sAndS2AndPsAndLsProvider,",
-        "        qsProvider,",
-        "        bAndB2AndPbAndLbProvider,",
-        "        qbProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+            "  private final Provider<A> qaProvider;",
+            "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+            "  private final Provider<String> qsProvider;",
+            "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+            "  private final Provider<B> qbProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> qaProvider,",
+            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<String> qsProvider,",
+            "      Provider<B> bAndB2AndPbAndLbProvider,",
+            "      Provider<B> qbProvider) {",
+            "    assert aAndA2AndPaAndLaProvider != null;",
+            "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+            "    assert qaProvider != null;",
+            "    this.qaProvider = qaProvider;",
+            "    assert sAndS2AndPsAndLsProvider != null;",
+            "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+            "    assert qsProvider != null;",
+            "    this.qsProvider = qsProvider;",
+            "    assert bAndB2AndPbAndLbProvider != null;",
+            "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+            "    assert qbProvider != null;",
+            "    this.qbProvider = qbProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    return new GenericClass<A, B>(",
+            "      aAndA2AndPaAndLaProvider.get(),",
+            "      aAndA2AndPaAndLaProvider.get(),",
+            "      aAndA2AndPaAndLaProvider,",
+            "      qaProvider.get(),",
+            "      DoubleCheck.lazy(aAndA2AndPaAndLaProvider),",
+            "      sAndS2AndPsAndLsProvider.get(),",
+            "      sAndS2AndPsAndLsProvider.get(),",
+            "      sAndS2AndPsAndLsProvider,",
+            "      qsProvider.get(),",
+            "      DoubleCheck.lazy(sAndS2AndPsAndLsProvider),",
+            "      bAndB2AndPbAndLbProvider.get(),",
+            "      bAndB2AndPbAndLbProvider.get(),",
+            "      bAndB2AndPbAndLbProvider,",
+            "      qbProvider.get(),",
+            "      DoubleCheck.lazy(bAndB2AndPbAndLbProvider));",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> qaProvider,",
+            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<String> qsProvider,",
+            "      Provider<B> bAndB2AndPbAndLbProvider,",
+            "      Provider<B> qbProvider) {",
+            "    return new GenericClass_Factory<A, B>(",
+            "        aAndA2AndPaAndLaProvider,",
+            "        qaProvider,",
+            "        sAndS2AndPsAndLsProvider,",
+            "        qsProvider,",
+            "        bAndB2AndPbAndLbProvider,",
+            "        qbProvider);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 1b585f603..5443aac01 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -382,54 +382,55 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.FieldInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class FieldInjection_MembersInjector",
-        "    implements MembersInjector<FieldInjection> {",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
-        "    return new FieldInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(FieldInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringProvider.get();",
-        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static void injectString(",
-        "      FieldInjection instance, Provider<String> stringProvider) {",
-        "    instance.string = stringProvider.get();",
-        "  }",
-        "",
-        "  public static void injectLazyString(",
-        "      FieldInjection instance, Provider<String> lazyStringProvider) {",
-        "    instance.lazyString = DoubleCheckLazy.create(lazyStringProvider);",
-        "  }",
-        "",
-        "  public static void injectStringProvider(",
-        "      FieldInjection instance, Provider<String> stringProvider) {",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.FieldInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class FieldInjection_MembersInjector",
+            "    implements MembersInjector<FieldInjection> {",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+            "    return new FieldInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(FieldInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.string = stringProvider.get();",
+            "    instance.lazyString = DoubleCheck.lazy(stringProvider);",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static void injectString(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.string = stringProvider.get();",
+            "  }",
+            "",
+            "  public static void injectLazyString(",
+            "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+            "    instance.lazyString = DoubleCheck.lazy(lazyStringProvider);",
+            "  }",
+            "",
+            "  public static void injectStringProvider(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .processedWith(new ComponentProcessor())
@@ -452,62 +453,65 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject void manyArgs(",
         "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MethodInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class MethodInjection_MembersInjector",
-        "     implements MembersInjector<MethodInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<MethodInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new MethodInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(MethodInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.noArgs();",
-        "    instance.oneArg(stringProvider.get());",
-        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
-        "        stringProvider);",
-        "  }",
-        "",
-        "  public static void injectNoArgs(MethodInjection instance) {",
-        "    instance.noArgs();",
-        "  }",
-        "",
-        "  public static void injectOneArg(",
-        "      MethodInjection instance, Provider<String> stringProvider) {",
-        "    instance.oneArg(stringProvider.get());",
-        "  }",
-        "",
-        "  public static void injectManyArgs(",
-        "      MethodInjection instance,",
-        "      Provider<String> stringProvider,",
-        "      Provider<String> lazyStringProvider,",
-        "      Provider<String> stringProvider2) {",
-        "    instance.manyArgs(",
-        "        stringProvider.get(),",
-        "        DoubleCheckLazy.create(lazyStringProvider),",
-        "        stringProvider2);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.MethodInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class MethodInjection_MembersInjector",
+            "     implements MembersInjector<MethodInjection> {",
+            "",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<MethodInjection> create(",
+            "      Provider<String> stringProvider) {",
+            "    return new MethodInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(MethodInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.noArgs();",
+            "    instance.oneArg(stringProvider.get());",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(stringProvider),",
+            "        stringProvider);",
+            "  }",
+            "",
+            "  public static void injectNoArgs(MethodInjection instance) {",
+            "    instance.noArgs();",
+            "  }",
+            "",
+            "  public static void injectOneArg(",
+            "      MethodInjection instance, Provider<String> stringProvider) {",
+            "    instance.oneArg(stringProvider.get());",
+            "  }",
+            "",
+            "  public static void injectManyArgs(",
+            "      MethodInjection instance,",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> lazyStringProvider,",
+            "      Provider<String> stringProvider2) {",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(lazyStringProvider),",
+            "        stringProvider2);",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index c20c6aa81..64cfba626 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -252,9 +252,9 @@ public void dependsOnProductionExecutor() {
             "package test;",
             "",
             "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.DoubleCheck;",
             "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.ScopedProvider;",
             "import dagger.internal.SetFactory;",
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
@@ -286,14 +286,14 @@ public void dependsOnProductionExecutor() {
             "  private void initialize(final Builder builder) {",
             "    this.simpleComponentProvider =",
             "        InstanceFactory.<Executor>create(builder.executor);",
-            "     this.executorProvider =",
-            "         ScopedProvider.create(",
-            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                 .create(simpleComponentProvider));",
+            "    this.executorProvider =",
+            "        DoubleCheck.provider(",
+            "            TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+            "                .create(simpleComponentProvider));",
             "    this.simpleComponentProvider2 =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.monitorProvider =",
-            "        ScopedProvider.create(",
+            "        DoubleCheck.provider(",
             "            TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "                simpleComponentProvider2,",
             "                SetFactory.<ProductionComponentMonitor.Factory>create());",
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheck.java
similarity index 63%
rename from core/src/main/java/dagger/internal/DoubleCheckLazy.java
rename to core/src/main/java/dagger/internal/DoubleCheck.java
index 8257c3beb..10f5f076d 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,21 +18,19 @@
 import dagger.Lazy;
 import javax.inject.Provider;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 /**
- * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
- * using the double-check idiom described in Effective Java 2: Item 71.
- *
- * @author Gregory Kick
- * @since 2.0
+ * A {@link Lazy} and {@link Provider} implementation that memoizes the value returned from a
+ * delegate using the double-check idiom described in Item 71 of <i>Effective Java 2</i>.
  */
-// TODO(gak): Unify the duplicated code between this and ScopedProvider.
-public final class DoubleCheckLazy<T> implements Lazy<T> {
+public final class DoubleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private final Provider<T> provider;
   private volatile Object instance = UNINITIALIZED;
 
-  private DoubleCheckLazy(Provider<T> provider) {
+  private DoubleCheck(Provider<T> provider) {
     assert provider != null;
     this.provider = provider;
   }
@@ -52,20 +50,23 @@ public T get() {
     return (T) result;
   }
 
-  public static <T> Lazy<T> create(Provider<T> provider) {
-    if (provider == null) {
-      throw new NullPointerException();
-    }
+  /** Returns a new provider that caches the value from the given factory. */
+  public static <T> Provider<T> provider(Factory<T> factory) {
+    return new DoubleCheck<T>(checkNotNull(factory));
+  }
+
+  /** Returns a {@link Lazy} that caches the value from the given provider. */
+  public static <T> Lazy<T> lazy(Provider<T> provider) {
     if (provider instanceof Lazy) {
       @SuppressWarnings("unchecked")
       final Lazy<T> lazy = (Lazy<T>) provider;
       // Avoids memoizing a value that is already memoized.
       // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
       // are different types using covariant return on get(). Right now this is used with
-      // ScopedProvider<T> exclusively, which is implemented such that P and L are always the same
-      // so it will be fine for that case.
+      // DoubleCheck<T> exclusively, which is implemented such that P and L are always
+      // the same, so it will be fine for that case.
       return lazy;
     }
-    return new DoubleCheckLazy<T>(provider);
+    return new DoubleCheck<T>(checkNotNull(provider));
   }
 }
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index 59b1fcb8b..400d26825 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -21,8 +21,8 @@
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
  * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with the {@link ScopedProvider} is valid and
- * may be desired for testing or contractual guarantees.
+ * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider(Factory)} is
+ * valid and may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
deleted file mode 100644
index b25db380a..000000000
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import javax.inject.Provider;
-
-/**
- * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-public final class ScopedProvider<T> implements Provider<T>, Lazy<T> {
-  private static final Object UNINITIALIZED = new Object();
-
-  private final Factory<T> factory;
-  private volatile Object instance = UNINITIALIZED;
-
-  private ScopedProvider(Factory<T> factory) {
-    assert factory != null;
-    this.factory = factory;
-  }
-
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
-  @Override
-  public T get() {
-    // double-check idiom from EJ2: Item 71
-    Object result = instance;
-    if (result == UNINITIALIZED) {
-      synchronized (this) {
-        result = instance;
-        if (result == UNINITIALIZED) {
-          instance = result = factory.get();
-        }
-      }
-    }
-    return (T) result;
-  }
-
-  /** Returns a new scoped provider for the given factory. */
-  public static <T> Provider<T> create(Factory<T> factory) {
-    if (factory == null) {
-      throw new NullPointerException();
-    }
-    return new ScopedProvider<T>(factory);
-  }
-}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
similarity index 84%
rename from core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
rename to core/src/test/java/dagger/internal/DoubleCheckTest.java
index 579e0405f..af110f49b 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,14 +37,32 @@
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
-public class DoubleCheckLazyTest {
+public class DoubleCheckTest {
+  @Test
+  public void provider_nullPointerException() {
+    try {
+      DoubleCheck.provider(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void lazy_nullPointerException() {
+    try {
+      DoubleCheck.lazy(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
   @Test public void get() throws Exception {
     int numThreads = 10;
     ExecutorService executor = Executors.newFixedThreadPool(numThreads);
 
     final CountDownLatch latch = new CountDownLatch(numThreads);
     LatchedProvider provider = new LatchedProvider(latch);
-    final Lazy<Object> lazy = DoubleCheckLazy.create(provider);
+    final Lazy<Object> lazy = DoubleCheck.lazy(provider);
 
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
@@ -66,19 +84,6 @@
     assert_().that(results.size()).isEqualTo(1);
   }
 
-  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
-  @Ignore @Test public void get_null() {
-    Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
-      @Override public Object get() {
-        return null;
-      }
-    });
-    try {
-      lazy.get();
-      fail();
-    } catch (NullPointerException expected) {}
-  }
-
   private static class LatchedProvider implements Provider<Object> {
     final AtomicInteger provisions;
     final CountDownLatch latch;
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
deleted file mode 100644
index 84b02c510..000000000
--- a/core/src/test/java/dagger/internal/ScopedProviderTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import javax.inject.Provider;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
-/**
- * Tests {@link ScopedProvider}.
- */
-@RunWith(JUnit4.class)
-public class ScopedProviderTest {
-  @Test public void create_nullPointerException() {
-    try {
-      ScopedProvider.create(null);
-      fail();
-    } catch (NullPointerException expected) { }
-  }
-
-  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
-  @Ignore @Test public void get_nullPointerException() {
-    Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
-      @Override public Object get() {
-        return null;
-      }
-    });
-    try {
-      scopedProvider.get();
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void get() {
-    Provider<Integer> scopedProvider = ScopedProvider.create(new Factory<Integer>() {
-      int i = 0;
-
-      @Override public Integer get() {
-        return i++;
-      }
-    });
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-  }
-}
