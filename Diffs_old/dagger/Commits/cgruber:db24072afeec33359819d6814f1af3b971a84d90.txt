diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3b9235915..8d55abccc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -89,7 +89,7 @@
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
-import static dagger.internal.codegen.MemberSelect.emptyMapProviderFactory;
+import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
@@ -123,12 +123,8 @@
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
-  private final Map<Binding, InitializationState> contributionInitializationStates =
-      new HashMap<>();
   protected ClassWriter componentWriter;
   private final Map<BindingKey, MemberSelect> memberSelectSnippets = new HashMap<>();
-  private final Map<ContributionBinding, MemberSelect> multibindingContributionSnippets =
-      new HashMap<>();
   protected ConstructorWriter constructorWriter;
   protected Optional<ClassName> builderName = Optional.absent();
 
@@ -219,10 +215,6 @@ protected MemberSelect getMemberSelect(BindingKey key) {
     return memberSelectSnippets.get(key);
   }
 
-  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
-    return Optional.fromNullable(multibindingContributionSnippets.get(binding));
-  }
-
   /**
    * Returns the initialization state of the factory field for a binding key in this component.
    */
@@ -236,16 +228,6 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
-  private InitializationState getContributionInitializationState(Binding binding) {
-    return contributionInitializationStates.containsKey(binding)
-        ? contributionInitializationStates.get(binding)
-        : UNINITIALIZED;
-  }
-
-  private void setContributionInitializationState(Binding binding, InitializationState state) {
-    contributionInitializationStates.put(binding, state);
-  }
-
   ImmutableSet<JavaWriter> write() {
     if (javaWriters.isEmpty()) {
       writeComponent();
@@ -470,38 +452,18 @@ private void addField(ResolvedBindings resolvedBindings) {
       return;
     }
 
-    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
-    boolean useRawType = bindingPackage.isPresent()
-        && !bindingPackage.get().equals(name.packageName());
-    if (resolvedBindings.isMultibindings()) {
-      // note that here we rely on the order of the resolved bindings being from parent to child
-      // otherwise, the numbering wouldn't work
-      int contributionNumber = 0;
-      for (ContributionBinding contributionBinding : resolvedBindings.contributionBindings()) {
-        contributionNumber++;
-        if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
-          FrameworkField contributionBindingField =
-              FrameworkField.createForSyntheticContributionBinding(
-                  contributionNumber, contributionBinding);
-          FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
-
-          multibindingContributionSnippets.put(
-              contributionBinding,
-              localField(name, contributionField.name()));
-        }
-      }
-    }
-
-    FrameworkField bindingField = FrameworkField.createForResolvedBindings(resolvedBindings);
-    FieldWriter frameworkField = addFrameworkField(useRawType, bindingField);
+    FieldWriter frameworkField = addFrameworkField(resolvedBindings);
 
     memberSelectSnippets.put(
         bindingKey,
         localField(name, frameworkField.name()));
   }
 
-  private FieldWriter addFrameworkField(boolean useRawType,
-      FrameworkField contributionBindingField) {
+  private FieldWriter addFrameworkField(ResolvedBindings resolvedBindings) {
+    boolean useRawType = useRawType(resolvedBindings);
+
+    FrameworkField contributionBindingField =
+        FrameworkField.createForResolvedBindings(resolvedBindings);
     FieldWriter contributionField =
         componentWriter.addField(
             useRawType
@@ -515,6 +477,11 @@ private FieldWriter addFrameworkField(boolean useRawType,
     return contributionField;
   }
 
+  private boolean useRawType(ResolvedBindings resolvedBindings) {
+    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
+  }
+
   /**
    * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
    * no-op members injection binding, then we don't need a field to hold its factory. In that case,
@@ -524,36 +491,31 @@ private FieldWriter addFrameworkField(boolean useRawType,
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
-        if (resolvedBindings.isMultibindings()
-            && resolvedBindings.contributionBindings().isEmpty()) {
-          switch (resolvedBindings.contributionType()) {
-            case MAP:
-              return Optional.of(emptyMapProviderFactory(
-                  MapType.from(resolvedBindings.key().type())));
-
-            case SET:
-              return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
+        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          switch (contributionBinding.bindingKind()) {
+            case SYNTHETIC_MULTIBOUND_MAP:
+              BindingType bindingType = contributionBinding.bindingType();
+              MapType mapType = MapType.from(contributionBinding.key().type());
+              return Optional.of(
+                  emptyFrameworkMapFactory(
+                      frameworkMapFactoryClassName(bindingType),
+                      mapType.keyType(),
+                      mapType.unwrappedValueType(bindingType.frameworkClass())));
+
+            case SYNTHETIC_MULTIBOUND_SET:
+              return Optional.of(
+                  emptySetFactoryStaticMemberSelect(
+                      contributionBinding.bindingType(), contributionBinding.key()));
 
-            case UNIQUE:
             default:
-              throw new AssertionError("Multibindings must be map or set, not " + resolvedBindings);
+              return Optional.of(
+                  staticMethod(
+                      generatedClassNameForBinding(contributionBinding),
+                      Snippet.format("create()")));
           }
         }
-        if (resolvedBindings.contributionBindings().size() != 1) {
-          return Optional.absent();
-        }
-        ContributionBinding contributionBinding =
-            getOnlyElement(resolvedBindings.contributionBindings());
-        if (contributionBinding.contributionType().isMultibinding()
-            || !contributionBinding.bindingType().equals(BindingType.PROVISION)) {
-          return Optional.absent();
-        }
-        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-            && !contributionBinding.scope().isPresent()) {
-          return Optional.of(
-              staticMethod(
-                  generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
-        }
         break;
 
       case MEMBERS_INJECTION:
@@ -572,18 +534,18 @@ private FieldWriter addFrameworkField(boolean useRawType,
   }
 
   /**
-   * A static member select for a call to {@code F.create()} where {@code F} is either
-   * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
-   * set bindings.
+   * A static member select for an empty set factory. Calls
+   * {@link SetFactory#create(javax.inject.Provider...)},
+   * {@link SetProducer#create(dagger.producers.Producer...)}, or
+   * {@link SetOfProducedProducer#create(dagger.producers.Producer...)}, depending on the set
+   * bindings.
    */
-  private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
-    ClassName setFactoryClassName = setFactoryClassName(setBindings);
-    return emptySetProvider(setFactoryClassName,
-        SetType.from(setBindings.bindingKey().key().type()));
+  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
+    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key.type()));
   }
 
   /**
-   * Returns a {@link Set} factory class name appropriate for the set bindings.
+   * The {@link Set} factory class name appropriate for set bindings.
    *
    * <ul>
    * <li>{@link SetFactory} for provision bindings.
@@ -591,11 +553,11 @@ private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindi
    * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
    * </ul>
    */
-  private ClassName setFactoryClassName(ResolvedBindings setBindings) {
-    if (setBindings.bindingType().equals(BindingType.PROVISION)) {
+  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
+    if (bindingType.equals(BindingType.PROVISION)) {
       return ClassName.fromClass(SetFactory.class);
     } else {
-      SetType setType = SetType.from(setBindings.bindingKey().key().type());
+      SetType setType = SetType.from(key.type());
       return ClassName.fromClass(
           setType.elementsAreTypeOf(Produced.class)
               ? SetOfProducedProducer.class
@@ -603,6 +565,46 @@ private ClassName setFactoryClassName(ResolvedBindings setBindings) {
     }
   }
 
+  /**
+   * The {@link Map}-of-value factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapFactory} for provision bindings.
+   * <li>{@link MapProducer} for production bindings.
+   * </ul>
+   */
+  private static ClassName mapFactoryClassName(ContributionBinding binding) {
+    switch (binding.bindingType()) {
+      case PRODUCTION:
+        return ClassName.fromClass(
+            MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
+                ? MapOfProducedProducer.class
+                : MapProducer.class);
+
+      case PROVISION:
+      case MEMBERS_INJECTION:
+        return ClassName.fromClass(MapFactory.class);
+
+      default:
+        throw new AssertionError(binding.toString());
+    }
+  }
+
+  /**
+   * The {@link Map}-of-framework factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapProviderFactory} for provision bindings.
+   * <li>{@link MapOfProducerProducer} for production bindings.
+   * </ul>
+   */
+  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
+    return ClassName.fromClass(
+        bindingType.equals(BindingType.PRODUCTION)
+            ? MapOfProducerProducer.class
+            : MapProviderFactory.class);
+  }
+
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -737,87 +739,26 @@ private void initializeFrameworkTypes() {
    * ensure that things like local variables always behave as expected by the initialization logic.
    */
   private Optional<Snippet> initializeFrameworkType(BindingKey bindingKey) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-
-    // There's no field for inherited bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
+    // If the field is inherited or the member select is static, don't initialize.
+    MemberSelect memberSelect = getMemberSelect(bindingKey);
+    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
       return Optional.absent();
     }
-
+    
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
-        switch (resolvedBindings.contributionType()) {
-          case SET:
-            return Optional.of(initializeSetMultibindings(resolvedBindings));
-          case MAP:
-            return Optional.of(initializeMapMultibindings(resolvedBindings));
-          case UNIQUE:
-            return initializeUniqueContributionBinding(resolvedBindings);
-          default:
-            throw new AssertionError();
-        }
+        return initializeContributionBinding(bindingKey);
 
       case MEMBERS_INJECTION:
-        return initializeMembersInjectionBinding(resolvedBindings);
+        return initializeMembersInjectionBinding(bindingKey);
 
       default:
         throw new AssertionError();
     }
   }
 
-  private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-
-    ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-      Optional<MemberSelect> multibindingContributionSnippet =
-          getMultibindingContributionSnippet(binding);
-      checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
-      Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
-      if (multibindingContributionSnippet.get().owningClass().equals(name)
-          // the binding might already be initialized by a different set binding that shares the
-          // same contributions (e.g., Set<T> and Set<Produced<T>>)
-          && getContributionInitializationState(binding)
-              .equals(InitializationState.UNINITIALIZED)) {
-        Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
-        initializationSnippets.add(Snippet.format("this.%s = %s;", snippet, initializeSnippet));
-        setContributionInitializationState(binding, InitializationState.INITIALIZED);
-      }
-      parameterSnippets.add(snippet);
-    }
-    Snippet initializeSetSnippet =
-        Snippet.format(
-            "%s.create(%s)",
-            setFactoryClassName(resolvedBindings),
-            makeParametersSnippet(parameterSnippets.build()));
-    initializationSnippets.add(
-        initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
-
-    return Snippet.concat(initializationSnippets.build());
-  }
-
-  private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-      Optional<MemberSelect> multibindingContributionSnippet =
-          getMultibindingContributionSnippet(binding);
-      if (multibindingContributionSnippet.isPresent()
-          && multibindingContributionSnippet.get().owningClass().equals(name)) {
-        initializationSnippets.add(
-            Snippet.format(
-                "this.%s = %s;",
-                multibindingContributionSnippet.get().getSnippetFor(name),
-                initializeFactoryForContributionBinding(binding)));
-      }
-    }
-    initializationSnippets.add(
-        initializeMember(resolvedBindings.bindingKey(), initializeMapBinding(resolvedBindings)));
-
-    return Snippet.concat(initializationSnippets.build());
-  }
-
-  private Optional<Snippet> initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
-    ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+  private Optional<Snippet> initializeContributionBinding(BindingKey bindingKey) {
+    ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
     if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
       return Optional.absent();
     }
@@ -826,13 +767,13 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
         Snippet.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(
-                    resolvedBindings.bindingKey(),
-                    initializeFactoryForContributionBinding(binding)))));
+                initializeMember(bindingKey, initializeFactoryForContributionBinding(binding)))));
   }
 
-  private Optional<Snippet> initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
-    MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
+  private Optional<Snippet> initializeMembersInjectionBinding(BindingKey bindingKey) {
+    MembersInjectionBinding binding =
+        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
+
     if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
       return Optional.absent();
     }
@@ -841,8 +782,7 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
         Snippet.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(
-                    resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)))));
+                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
   }
 
   /**
@@ -1038,33 +978,19 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
         }
 
       case SYNTHETIC_MAP:
-        checkState(
-            MapType.isMap(binding.key().type()),
-            "Expected synthetic binding to be for a map: %s",
-            binding);
-        final ClassName contributionClassName;
-        switch (binding.bindingType()) {
-          case PRODUCTION:
-            if (MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)) {
-              contributionClassName = ClassName.fromClass(MapOfProducedProducer.class);
-            } else {
-              contributionClassName = ClassName.fromClass(MapProducer.class);
-            }
-            break;
-          case PROVISION:
-            contributionClassName = ClassName.fromClass(MapFactory.class);
-            break;
-          default:
-            throw new AssertionError();
-        }
         return Snippet.format(
             "%s.create(%s)",
-            contributionClassName,
-            getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
-                .getSnippetFor(name));
+            mapFactoryClassName(binding),
+            getMemberSelectSnippet(getOnlyElement(binding.dependencies()).bindingKey()));
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return initializeFactoryForSetMultibinding(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return initializeFactoryForMapMultibinding(binding);
 
       default:
-        throw new AssertionError();
+        throw new AssertionError(binding.toString());
     }
   }
 
@@ -1094,49 +1020,61 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
   private ImmutableList<Snippet> getDependencyParameterSnippets(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
-      BindingKey requestedKey = frameworkDependency.bindingKey();
-      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetFor(name);
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
-      if (resolvedBindings.frameworkClass().equals(Provider.class)
-          && frameworkDependency.frameworkClass().equals(Producer.class)) {
-        parameters.add(
-            Snippet.format(
-                "%s.producerFromProvider(%s)",
-                ClassName.fromClass(Producers.class),
-                frameworkSnippet));
-      } else {
-        parameters.add(frameworkSnippet);
-      }
+      parameters.add(getDependencySnippet(frameworkDependency));
     }
     return parameters.build();
   }
 
-  private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
-    MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
-    boolean hasProductionContribution =
-        Iterables.any(
-            resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION));
+  /**
+   * The snippet for a dependency.
+   */
+  private Snippet getDependencySnippet(FrameworkDependency frameworkDependency) {
+    BindingKey requestedKey = frameworkDependency.bindingKey();
+    Snippet frameworkSnippet = getMemberSelectSnippet(requestedKey);
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+    if (resolvedBindings.frameworkClass().equals(Provider.class)
+        && frameworkDependency.frameworkClass().equals(Producer.class)) {
+      return Snippet.format(
+          "%s.producerFromProvider(%s)", ClassName.fromClass(Producers.class), frameworkSnippet);
+    } else {
+      return frameworkSnippet;
+    }
+  }
+
+  private Snippet initializeFactoryForSetMultibinding(ContributionBinding binding) {
+    return Snippet.format(
+        "%s.create(%s)",
+        setFactoryClassName(binding.bindingType(), binding.key()),
+        makeParametersSnippet(getDependencyParameterSnippets(binding)));
+  }
+
+  private Snippet initializeFactoryForMapMultibinding(ContributionBinding binding) {
+    ImmutableSet<FrameworkDependency> frameworkDependencies =
+        FrameworkDependency.frameworkDependenciesForBinding(binding);
+
     ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
     snippets.add(
         Snippet.format(
             "%s.<%s, %s>builder(%d)",
-            ClassName.fromClass(
-                hasProductionContribution ? MapOfProducerProducer.class : MapProviderFactory.class),
+            frameworkMapFactoryClassName(binding.bindingType()),
             TypeNames.forTypeMirror(mapType.keyType()),
             TypeNames.forTypeMirror(
-                mapType.unwrappedValueType(
-                    hasProductionContribution ? Producer.class : Provider.class)),
-            resolvedBindings.contributionBindings().size()));
+                mapType.unwrappedValueType(binding.bindingType().frameworkClass())),
+            frameworkDependencies.size()));
 
-    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
       snippets.add(
           Snippet.format(
-              "    .put(%s, %s)",
-              getMapKeySnippet(binding.bindingElement()),
-              getMultibindingContributionSnippet(binding).get().getSnippetFor(name)));
+              ".put(%s, %s)",
+              getMapKeySnippet(contributionBinding.bindingElement()),
+              getDependencySnippet(frameworkDependency)));
     }
 
-    snippets.add(Snippet.format("    .build()"));
+    snippets.add(Snippet.format(".build()"));
 
     return Snippet.concat(snippets.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 26a410c62..a85b8f6a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
 import dagger.Subcomponent;
+import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
@@ -65,6 +66,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -280,6 +282,7 @@ private BindingGraph create(
       final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
+      final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
@@ -303,6 +306,15 @@ private BindingGraph create(
         assert multibindingDeclarations != null;
         this.multibindingDeclarations = multibindingDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
+
+        ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
+            ImmutableSetMultimap.builder();
+        for (ContributionBinding binding : explicitBindingsSet) {
+          if (binding.key().bindingMethod().isPresent()) {
+            explicitMultibindingsBuilder.put(binding.key().withoutBindingMethod(), binding);
+          }
+        }
+        this.explicitMultibindings = explicitMultibindingsBuilder.build();
       }
 
       /**
@@ -331,17 +343,20 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
+            Set<ContributionBinding> multibindings = new LinkedHashSet<>();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
             // Add explicit bindings and declarations (those from modules and components).
             contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
+            multibindings.addAll(getExplicitMultibindings(bindingKey.key()));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
 
             // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
             // Set<T>.
             Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
             contributionBindings.addAll(getExplicitBindings(implicitSetKey));
+            multibindings.addAll(getExplicitMultibindings(implicitSetKey));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
@@ -353,14 +368,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             Optional<Key> implicitMapProviderKey =
                 keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProviderMapBindings =
-                getExplicitBindings(implicitMapProviderKey);
+                getExplicitMultibindings(implicitMapProviderKey);
             ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProviderKey);
 
             Optional<Key> implicitMapProducerKey =
                 keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
-                getExplicitBindings(implicitMapProducerKey);
+                getExplicitMultibindings(implicitMapProducerKey);
             ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProducerKey);
 
@@ -381,9 +396,27 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.implicitMapOfProviderBinding(request));
             }
 
+            Iterable<? extends HasBindingType> multibindingsAndDeclarations =
+                Iterables.concat(multibindings, multibindingDeclarations);
+            if (Iterables.any(
+                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
+              /* If there are production multibindings, add a synthetic binding that depends on each
+               * individual multibinding. */
+              contributionBindings.add(
+                  productionBindingFactory.syntheticMultibinding(request, multibindings));
+            } else if (Iterables.any(
+                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
+              /* If there are provision multibindings but not production ones, add a synthetic
+               * binding that depends on each individual multibinding. */
+              contributionBindings.add(
+                  provisionBindingFactory.syntheticMultibinding(request, multibindings));
+            }
+
             /* If there are no explicit or synthetic bindings or multibinding declarations, use an
              * implicit @Inject- constructed binding if there is one. */
-            if (contributionBindings.isEmpty() && multibindingDeclarations.isEmpty()) {
+            if (contributionBindings.isEmpty()
+                && multibindings.isEmpty()
+                && multibindingDeclarations.isEmpty()) {
               contributionBindings.addAll(
                   injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
             }
@@ -500,6 +533,26 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
             : ImmutableSet.<ContributionBinding>of();
       }
 
+      /**
+       * Returns the explicit multibindings whose key (minus its {@link Key#bindingMethod()})
+       * matches the {@code requestKey} from this and all ancestor resolvers.
+       */
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
+        ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          explicitMultibindingsForKey.addAll(resolver.explicitMultibindings.get(requestKey));
+        }
+        return explicitMultibindingsForKey.build();
+      }
+
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getExplicitMultibindings(optionalKey.get())
+            : ImmutableSet.<ContributionBinding>of();
+      }
+
       /**
        * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
        * ancestor resolvers.
@@ -687,8 +740,10 @@ public Boolean call() {
         }
 
         private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
-          return resolvedBindings.isMultibindings()
-              && explicitBindings.containsKey(resolvedBindings.key());
+          return FluentIterable.from(resolvedBindings.contributionBindings())
+                  .transform(ContributionBinding.KIND)
+                  .anyMatch(IS_SYNTHETIC_MULTIBINDING_KIND)
+              && explicitMultibindings.containsKey(resolvedBindings.key());
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 413896c38..872277fd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -77,7 +77,6 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
-import static com.google.common.collect.Iterables.skip;
 import static com.google.common.collect.Maps.filterKeys;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
@@ -85,7 +84,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -286,44 +286,32 @@ private boolean validateResolvedBinding(
 
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          ImmutableSet<ContributionBinding> contributionBindings =
-              resolvedBinding.contributionBindings();
           if (Iterables.any(
               resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          if (!validateNullability(path.peek().request(), contributionBindings)) {
+          if (!validateNullability(path.peek().request(), resolvedBinding.contributionBindings())) {
             return false;
           }
-          if (Iterables.any(contributionBindings, BindingType.isOfType(BindingType.PRODUCTION))
-              && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path);
+          if (resolvedBinding.contributionBindings().size() > 1) {
+            reportDuplicateBindings(path);
             return false;
           }
-          ImmutableSet<ContributionType> contributionTypes =
-              declarationsByType(resolvedBinding).keySet();
-          if (contributionTypes.size() > 1) {
-            reportMultipleBindingTypes(path);
+          ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
+          if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
+              && doesPathRequireProvisionOnly(path)) {
+            reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (contributionBindings.size() <= 1) {
-            return true;
-          }
-          switch (getOnlyElement(contributionTypes)) {
-            case UNIQUE:
-              reportDuplicateBindings(path);
-              return false;
-            case MAP:
-              boolean duplicateMapKeys = hasDuplicateMapKeys(path, contributionBindings);
-              boolean inconsistentMapKeyAnnotationTypes =
-                  hasInconsistentMapKeyAnnotationTypes(path, contributionBindings);
-              return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
-            case SET:
-              break;
-            default:
-              throw new AssertionError();
+          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
+            ImmutableSet<ContributionBinding> multibindings =
+                inlineSyntheticContributions(resolvedBinding).contributionBindings();
+            boolean duplicateMapKeys = reportIfDuplicateMapKeys(path, multibindings);
+            boolean inconsistentMapKeyAnnotationTypes =
+                reportIfInconsistentMapKeyAnnotationTypes(path, multibindings);
+            return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
           }
           break;
         case MEMBERS_INJECTION:
@@ -346,8 +334,8 @@ private boolean validateResolvedBinding(
 
     /**
      * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
-     * bindings and multibinding declarations of their dependencies.
+     * that any synthetic {@link ContributionBinding}s are replaced by the contribution bindings and
+     * multibinding declarations of their dependencies.
      *
      * <p>For example, if:
      *
@@ -365,8 +353,9 @@ private boolean validateResolvedBinding(
      * <p>The replacement is repeated until none of the bindings are synthetic.
      */
     private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
-      if (!Iterables.any(
-          resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
+      if (!FluentIterable.from(resolvedBinding.contributionBindings())
+          .transform(ContributionBinding.KIND)
+          .anyMatch(IS_SYNTHETIC_KIND)) {
         return resolvedBinding;
       }
       
@@ -375,23 +364,21 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
 
-      Queue<Map.Entry<ComponentDescriptor, ContributionBinding>> contributionQueue =
-          new ArrayDeque<>(resolvedBinding.allContributionBindings().entries());
-
-      for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry =
-              contributionQueue.poll();
-          bindingEntry != null;
-          bindingEntry = contributionQueue.poll()) {
-        ContributionBinding binding = bindingEntry.getValue();
-        if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
-          BindingKey syntheticBindingDependency =
-              getOnlyElement(binding.dependencies()).bindingKey();
-          ResolvedBindings dependencyBindings =
-              subject.resolvedBindings().get(syntheticBindingDependency);
-          multibindingDeclarations.addAll(dependencyBindings.multibindingDeclarations());
-          contributionQueue.addAll(dependencyBindings.allContributionBindings().entries());
-        } else {
-          contributions.put(bindingEntry);
+      Queue<ResolvedBindings> queue = new ArrayDeque<>();
+      queue.add(resolvedBinding);
+
+      for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
+        multibindingDeclarations.addAll(queued.multibindingDeclarations());
+        for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
+            queued.allContributionBindings().entries()) {
+          ContributionBinding binding = bindingEntry.getValue();
+          if (binding.isSyntheticBinding()) {
+            for (DependencyRequest dependency : binding.dependencies()) {
+              queue.add(subject.resolvedBindings().get(dependency.bindingKey()));
+            }
+          } else {
+            contributions.put(bindingEntry);
+          }
         }
       }
       return ResolvedBindings.forContributionBindings(
@@ -443,7 +430,7 @@ private boolean validateNullability(
      * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
      * for the same map key.
      */
-    private boolean hasDuplicateMapKeys(
+    private boolean reportIfDuplicateMapKeys(
         Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
       boolean hasDuplicateMapKeys = false;
       for (Collection<ContributionBinding> mapBindingsForMapKey :
@@ -460,7 +447,7 @@ private boolean hasDuplicateMapKeys(
      * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
      * {@link MapKey} annotation type.
      */
-    private boolean hasInconsistentMapKeyAnnotationTypes(
+    private boolean reportIfInconsistentMapKeyAnnotationTypes(
         Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
@@ -896,6 +883,12 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
+      if (FluentIterable.from(resolvedBinding.contributionBindings())
+          .transform(ContributionBinding.KIND)
+          .anyMatch(IS_SYNTHETIC_KIND)) {
+        reportMultipleBindingTypes(path);
+        return;
+      }
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
@@ -915,6 +908,11 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
           declarationsByType(resolvedBinding);
+      verify(
+          declarationsByType.keySet().size() > 1,
+          "expected multiple binding types for %s: %s",
+          resolvedBinding.bindingKey(),
+          declarationsByType);
       for (ContributionType type :
           Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
@@ -1013,11 +1011,13 @@ private void reportCycle(
      * really broken.
      */
     private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
-      DependencyRequest lastDependencyRequest = cycle.get(0);
-      for (DependencyRequest dependencyRequest : skip(cycle, 1)) {
+      for (int i = 1; i < cycle.size(); i++) {
+        DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
           case PROVIDER:
-            if (!isImplicitProviderMapForValueMap(dependencyRequest, lastDependencyRequest)) {
+            if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
+              i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
+            } else {
               return true;
             }
             break;
@@ -1035,7 +1035,6 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
           default:
             break;
         }
-        lastDependencyRequest = dependencyRequest;
       }
       return false;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 2906292b0..e66907977 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -78,7 +78,7 @@ public SourceVersion getSupportedSourceVersion() {
     HasSourceElementFormatter hasSourceElementFormatter =
         new HasSourceElementFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
-    KeyFormatter keyFormatter = new KeyFormatter();
+    KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index dbe84067d..71cb38afd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
@@ -38,6 +39,8 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -61,7 +64,7 @@
       return Sets.union(membersInjectionRequest().asSet(), dependencies());
     }
   }
-  
+
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -80,9 +83,20 @@
    * implicitly by the framework.
    */
   boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_MAP);
+    return IS_SYNTHETIC_KIND.apply(bindingKind());
   }
 
+  /**
+   * A function that returns the kind of a binding.
+   */
+  static final Function<ContributionBinding, Kind> KIND =
+      new Function<ContributionBinding, Kind>() {
+        @Override
+        public Kind apply(ContributionBinding binding) {
+          return binding.bindingKind();
+        }
+      };
+
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> membersInjectionRequest();
 
@@ -97,6 +111,18 @@ boolean isSyntheticBinding() {
      */
     SYNTHETIC_MAP,
 
+    /**
+     * A synthetic binding for a multibound set that depends on the individual multibinding
+     * {@link Provides @Provides} or {@link Produces @Produces} methods.
+     */
+    SYNTHETIC_MULTIBOUND_SET,
+
+    /**
+     * A synthetic binding for a multibound map that depends on the individual multibinding
+     * {@link Provides @Provides} or {@link Produces @Produces} methods.
+     */
+    SYNTHETIC_MULTIBOUND_MAP,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
@@ -131,6 +157,36 @@ boolean isSyntheticBinding() {
      * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
      */
     COMPONENT_PRODUCTION,
+    ;
+
+    /**
+     * A predicate that tests whether a kind is for synthetic bindings.
+     */
+    static final Predicate<Kind> IS_SYNTHETIC_KIND =
+        Predicates.in(
+            immutableEnumSet(SYNTHETIC_MAP, SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+
+    /**
+     * A predicate that tests whether a kind is for synthetic multibindings.
+     */
+    static final Predicate<Kind> IS_SYNTHETIC_MULTIBINDING_KIND =
+        Predicates.in(immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+
+    /**
+     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the
+     * request's key.
+     */
+    static Kind forMultibindingRequest(DependencyRequest request) {
+      Key key = request.key();
+      if (SetType.isSet(key.type())) {
+        return SYNTHETIC_MULTIBOUND_SET;
+      } else if (MapType.isMap(key.type())) {
+        return SYNTHETIC_MULTIBOUND_MAP;
+      } else {
+        throw new IllegalArgumentException(
+            String.format("request is not for a set or map: %s", request));
+      }
+    }
   }
 
   /**
@@ -141,12 +197,8 @@ boolean isSyntheticBinding() {
   /**
    * A predicate that passes for bindings of a given kind.
    */
-  static Predicate<ContributionBinding> isOfKind(final Kind kind) {
-    return new Predicate<ContributionBinding>() {
-      @Override
-      public boolean apply(ContributionBinding binding) {
-        return binding.bindingKind().equals(kind);
-      }};
+  static Predicate<ContributionBinding> isOfKind(Kind kind) {
+    return Predicates.compose(Predicates.equalTo(kind), KIND);
   }
 
   /** The provision type that was used to bind the key. */
@@ -180,10 +232,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 
       case INJECTION:
+      case SYNTHETIC_MULTIBOUND_SET:
+      case SYNTHETIC_MULTIBOUND_MAP:
         return implicitDependencies().isEmpty()
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-
+        
       default:
         return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 453215667..f0a726a91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -201,6 +201,42 @@ DependencyRequest forImplicitMapBinding(
           Optional.<String>absent());
     }
 
+    /**
+     * Creates a dependency request, with the same element as {@code request}, for one individual
+     * {@code multibindingContribution}.
+     */
+    DependencyRequest forMultibindingContribution(
+        DependencyRequest request, ContributionBinding multibindingContribution) {
+      checkArgument(
+          multibindingContribution.contributionType().isMultibinding(),
+          "multibindingContribution must be a multibinding: %s",
+          multibindingContribution);
+      checkArgument(
+          multibindingContribution.key().bindingMethod().isPresent(),
+          "multibindingContribution's key must have a binding method identifier: %s",
+          multibindingContribution);
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          multibindingContribution.key(),
+          request.requestElement(),
+          request.enclosingType(),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
+    /**
+     * Creates dependency requests, with the same element as {@code request}, for each individual
+     * multibinding contribution in {@code multibindingContributions}.
+     */
+    ImmutableSet<DependencyRequest> forMultibindingContributions(
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
+      for (ContributionBinding multibindingContribution : multibindingContributions) {
+        requests.add(forMultibindingContribution(request, multibindingContribution));
+      }
+      return requests.build();
+    }
+
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.<String>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 41406f80c..2077864d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -195,9 +195,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_CONTRIBUTION_TYPES_FORMAT =
-      "More than one binding present of different types %s";
-
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings or declarations:\n";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index baad3b393..1cf914e5d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,19 +15,19 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-
 /**
  * A value object that represents a field used by Dagger-generated code.
  *
@@ -52,70 +52,57 @@ static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, St
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
     TypeMirror type = MapType.from(key.type()).valueType();
+    String suffix = MoreTypes.asDeclared(type).asElement().getSimpleName().toString();
     return new AutoValue_FrameworkField(
         (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
         (ParameterizedTypeName) TypeNames.forTypeMirror(type),
-        name);
-  }
-
-  static FrameworkField createForSyntheticContributionBinding(
-      int contributionNumber, ContributionBinding contributionBinding) {
-    switch (contributionBinding.contributionType()) {
-      case MAP:
-        return createForMapBindingContribution(
-            contributionBinding.key(),
-            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
-                + "Contribution"
-                + contributionNumber);
-
-      case SET:
-      case UNIQUE:
-        return createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            contributionBinding.key(),
-            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
-                + "Contribution"
-                + contributionNumber);
-      default:
-        throw new AssertionError();
-    }
+        name.endsWith(suffix) ? name : name + suffix);
   }
 
   static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
-    return createWithTypeFromKey(
-        resolvedBindings.frameworkClass(),
-        resolvedBindings.bindingKey().key(),
-        frameworkFieldName(resolvedBindings));
+    if (resolvedBindings.isMultibindingContribution()
+        && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
+      return createForMapBindingContribution(
+          resolvedBindings.key(), frameworkFieldName(resolvedBindings));
+    } else {
+      return createWithTypeFromKey(
+          resolvedBindings.frameworkClass(),
+          resolvedBindings.key(),
+          frameworkFieldName(resolvedBindings));
+    }
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && resolvedBindings.contributionType().equals(ContributionType.UNIQUE)) {
-      ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
-      if (!binding.bindingKind().equals(ContributionBinding.Kind.SYNTHETIC_MAP)) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement());
+    if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (!binding.isSyntheticBinding()) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
       }
     }
-    return KeyVariableNamer.INSTANCE.apply(bindingKey.key());
+    return KeyVariableNamer.INSTANCE.apply(resolvedBindings.key());
   }
 
-  private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
-      new ElementKindVisitor6<String, Void>() {
+  private static final ElementVisitor<String, Binding> BINDING_ELEMENT_NAME =
+      new ElementKindVisitor6<String, Binding>() {
+
+        @Override
+        protected String defaultAction(Element e, Binding p) {
+          throw new IllegalArgumentException("Unexpected binding " + p);
+        }
+
         @Override
-        public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-          return visit(e.getEnclosingElement());
+        public String visitExecutableAsConstructor(ExecutableElement e, Binding p) {
+          return visit(e.getEnclosingElement(), p);
         }
 
         @Override
-        public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+        public String visitExecutableAsMethod(ExecutableElement e, Binding p) {
           return e.getSimpleName().toString();
         }
 
         @Override
-        public String visitType(TypeElement e, Void p) {
-          return CaseFormat.UPPER_CAMEL.to(
-              CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
+        public String visitType(TypeElement e, Binding p) {
+          return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
         }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 77a92ed3a..af635fcba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -91,11 +91,28 @@
    * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+  
+  /**
+   * For multibinding contributions, this is the binding method element. Each multibound map and set
+   * is represented by a
+   * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
+   * synthetic binding} that depends on the specific contributions to that map or set. Each such
+   * contribution binding therefore needs a key that identifies the specific binding, and not only
+   * the qualified type that is bound.
+   */
+  abstract Optional<SourceElement> bindingMethod();
 
+  /**
+   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
+   * for the type of this key.
+   */
   Optional<AnnotationMirror> qualifier() {
     return unwrapOptionalEquivalence(wrappedQualifier());
   }
 
+  /**
+   * The type represented by this key.
+   */
   TypeMirror type() {
     return wrappedType().get();
   }
@@ -105,9 +122,31 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
     return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
   }
 
-  Key withType(Types types, TypeMirror newType) {
-    return new AutoValue_Key(wrappedQualifier(),
-        MoreTypes.equivalence().wrap(normalize(types, newType)));
+  /**
+   * A key whose {@link #qualifier()} and {@link #bindingMethod()} are equivalent to this one's, but
+   * with {@code newType} (normalized) as its {@link #type()}.
+   */
+  private Key withType(Types types, TypeMirror newType) {
+    return new AutoValue_Key(
+        wrappedQualifier(),
+        MoreTypes.equivalence().wrap(normalize(types, newType)),
+        bindingMethod());
+  }
+
+  /**
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but
+   * with {@code bindingMethod} as its {@link #bindingMethod()}.
+   */
+  private Key withBindingMethod(SourceElement bindingMethod) {
+    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(bindingMethod));
+  }
+
+  /**
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
+   * absent {@link #bindingMethod()}.
+   */
+  Key withoutBindingMethod() {
+    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.<SourceElement>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -162,6 +201,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
+        .add("bindingMethod", bindingMethod().orNull())
         .toString();
   }
 
@@ -258,29 +298,36 @@ Key forSubcomponentBuilderMethod(
       return forMethod(subcomponentBuilderMethod, returnType);
     }
 
-    Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
-      checkNotNull(method);
-      checkArgument(method.getKind().equals(METHOD));
+    Key forProvidesMethod(SourceElement sourceElement) {
+      checkArgument(sourceElement.element().getKind().equals(METHOD));
+      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       Provides providesAnnotation = method.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
       TypeMirror keyType =
           providesOrProducesKeyType(
               returnType,
               method,
               Optional.of(providesAnnotation.type()),
               Optional.<Produces.Type>absent());
-      return forMethod(method, keyType);
+      Key key = forMethod(method, keyType);
+      return providesAnnotation.type().equals(Provides.Type.UNIQUE)
+          ? key
+          : key.withBindingMethod(sourceElement);
     }
 
     // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
-    Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
-      checkNotNull(method);
-      checkArgument(method.getKind().equals(METHOD));
+    Key forProducesMethod(SourceElement sourceElement) {
+      checkArgument(sourceElement.element().getKind().equals(METHOD));
+      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       Produces producesAnnotation = method.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
       TypeMirror unfuturedType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         unfuturedType =
@@ -292,7 +339,10 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
               method,
               Optional.<Provides.Type>absent(),
               Optional.of(producesAnnotation.type()));
-      return forMethod(method, keyType);
+      Key key = forMethod(method, keyType);
+      return producesAnnotation.type().equals(Produces.Type.UNIQUE)
+          ? key
+          : key.withBindingMethod(sourceElement);
     }
     
     /**
@@ -362,31 +412,36 @@ private TypeMirror mapKeyType(ExecutableElement method) {
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
-          MoreTypes.equivalence().wrap(keyType));
+          MoreTypes.equivalence().wrap(keyType),
+          Optional.<SourceElement>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(type));
+          MoreTypes.equivalence().wrap(type),
+          Optional.<SourceElement>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
-          MoreTypes.equivalence().wrap(normalize(types, type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)),
+          Optional.<SourceElement>absent());
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index 6e695f33a..a670c1bae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -15,21 +15,38 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+
 /**
- * Formats a {@link Key} into a {@link String} suitable for use in error messages
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
  *
  * @author Christian Gruber
  * @since 2.0
  */
 final class KeyFormatter extends Formatter<Key> {
+  
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
 
   @Override public String format(Key request) {
+    if (request.bindingMethod().isPresent()) {
+      // If there's a binding method, its signature is enough.
+      SourceElement bindingMethod = request.bindingMethod().get();
+      return methodSignatureFormatter.format(
+          MoreElements.asExecutable(bindingMethod.element()),
+          Optional.of(MoreTypes.asDeclared(bindingMethod.contributedBy().get().asType())));
+    }
     StringBuilder builder = new StringBuilder();
     if (request.qualifier().isPresent()) {
       builder.append(request.qualifier().get());
       builder.append(' ');
     }
-    builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
+    builder.append(request.type());
     return builder.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 54fc45e87..89312acb7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -24,10 +24,11 @@
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.internal.MapOfProducerProducer;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 
@@ -98,14 +99,23 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
   }
 
   /**
-   * Returns the {@link MemberSelect} an empty implementation of {@link MapProviderFactory}.
+   * A {@link MemberSelect} for an empty map of framework types.
+   *
+   * @param frameworkMapFactoryClass either {@link MapProviderFactory}
+   *     or {@link MapOfProducerProducer}
    */
-  static MemberSelect emptyMapProviderFactory(MapType mapType) {
+  static MemberSelect emptyFrameworkMapFactory(
+      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
+    checkArgument(
+        frameworkMapFactoryClass.equals(ClassName.fromClass(MapProviderFactory.class))
+            || frameworkMapFactoryClass.equals(ClassName.fromClass(MapOfProducerProducer.class)),
+        "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
+        frameworkMapFactoryClass);
     return new ParameterizedStaticMethod(
-        ClassName.fromClass(MapProviderFactory.class),
-        ImmutableList.of(mapType.keyType(), mapType.unwrappedValueType(Provider.class)),
+        frameworkMapFactoryClass,
+        ImmutableList.of(keyType, unwrappedValueType),
         Snippet.format("empty()"),
-        ClassName.fromClass(MapProviderFactory.class));
+        frameworkMapFactoryClass);
   }
 
   /**
@@ -193,4 +203,4 @@ boolean staticMember() {
    * Returns a {@link Snippet} suitable for accessing the member from the given {@code usingClass}.
    */
   abstract Snippet getSnippetFor(ClassName usingClass);
-}
\ No newline at end of file
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 078977e16..896458650 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import java.util.Iterator;
 import java.util.List;
@@ -26,7 +27,6 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -94,6 +94,20 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
+  public String format(SourceElement sourceElement) {
+    return format(
+        MoreElements.asExecutable(sourceElement.element()),
+        sourceElement
+            .contributedBy()
+            .transform(
+                new Function<TypeElement, DeclaredType>() {
+                  @Override
+                  public DeclaredType apply(TypeElement contributingModule) {
+                    return MoreTypes.asDeclared(contributingModule.asType());
+                  }
+                }));
+  }
+
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
@@ -104,12 +118,6 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   }
 
   private static String nameOfType(TypeMirror type) {
-    if (type.getKind().isPrimitive()) {
-      return MoreTypes.asPrimitiveType(type).toString();
-    } else if (type.getKind() == TypeKind.VOID) {
-      return "void";
-    } else {
-      return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
-    }
+    return stripCommonTypePrefixes(type.toString());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 954b91eeb..1c4871e5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -159,12 +159,10 @@ ModuleDescriptor create(TypeElement moduleElement) {
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
-          bindings.add(
-              provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement.asType()));
+          bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
         }
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
-          bindings.add(
-              productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
+          bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
         }
       }
       
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 1afda7d90..00d73bda1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -110,15 +110,18 @@
         if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
           // all of the provides methods in this module are valid!
           // time to generate some factories!
-          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
-              .transform(new Function<ExecutableElement, ProvisionBinding>() {
-                @Override
-                public ProvisionBinding apply(ExecutableElement providesMethod) {
-                  return provisionBindingFactory.forProvidesMethod(providesMethod,
-                      providesMethod.getEnclosingElement().asType());
-                }
-              })
-              .toSet();
+          ImmutableSet<ProvisionBinding> bindings =
+              FluentIterable.from(moduleProvidesMethods)
+                  .transform(
+                      new Function<ExecutableElement, ProvisionBinding>() {
+                        @Override
+                        public ProvisionBinding apply(ExecutableElement providesMethod) {
+                          return provisionBindingFactory.forProvidesMethod(
+                              providesMethod,
+                              MoreElements.asType(providesMethod.getEnclosingElement()));
+                        }
+                      })
+                  .toSet();
 
           try {
             for (ProvisionBinding binding : bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index cc167e599..d3873e969 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -113,15 +113,18 @@
           if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
             // all of the produces methods in this module are valid!
             // time to generate some factories!
-            ImmutableSet<ProductionBinding> bindings = FluentIterable.from(moduleProducesMethods)
-                .transform(new Function<ExecutableElement, ProductionBinding>() {
-                  @Override
-                  public ProductionBinding apply(ExecutableElement producesMethod) {
-                    return productionBindingFactory.forProducesMethod(producesMethod,
-                        producesMethod.getEnclosingElement().asType());
-                  }
-                })
-                .toSet();
+            ImmutableSet<ProductionBinding> bindings =
+                FluentIterable.from(moduleProducesMethods)
+                    .transform(
+                        new Function<ExecutableElement, ProductionBinding>() {
+                          @Override
+                          public ProductionBinding apply(ExecutableElement producesMethod) {
+                            return productionBindingFactory.forProducesMethod(
+                                producesMethod,
+                                MoreElements.asType(producesMethod.getEnclosingElement()));
+                          }
+                        })
+                    .toSet();
 
             try {
               for (ProductionBinding binding : bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 391d804e4..ab8a5d33f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -26,9 +26,9 @@
 import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
@@ -93,19 +93,17 @@ public BindingType bindingType() {
     }
 
     ProductionBinding forProducesMethod(
-        ExecutableElement producesMethod, TypeMirror contributedBy) {
-      checkNotNull(producesMethod);
+        ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
+      Key key = keyFactory.forProducesMethod(sourceElement);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, producesMethod));
-      Key key = keyFactory.forProducesMethod(resolvedMethod, producesMethod);
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              declaredContainer,
+              MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       DependencyRequest monitorRequest =
@@ -114,7 +112,7 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
-          SourceElement.forElement(producesMethod, MoreTypes.asTypeElement(declaredContainer)),
+          sourceElement,
           key,
           dependencies,
           findBindingPackage(key),
@@ -148,6 +146,25 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Optional.<DependencyRequest>absent());
     }
 
+    /**
+     * A binding that depends explicitly on a set of individual provision or production multibinding
+     * contribution methods.
+     */
+    ProductionBinding syntheticMultibinding(
+        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      return new AutoValue_ProductionBinding(
+          SourceElement.forElement(request.requestElement()),
+          request.key(),
+          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
+          findBindingPackage(request.key()),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.forMultibindingRequest(request),
+          Produces.Type.UNIQUE,
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent());
+    }
+
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7b2fb5d8e..346fdc4b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -29,7 +29,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -152,24 +151,23 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       return Optional.absent();
     }
 
-    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror contributedBy) {
-      checkNotNull(providesMethod);
+    ProvisionBinding forProvidesMethod(
+        ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
-      Key key = keyFactory.forProvidesMethod(resolvedMethod, providesMethod);
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+      Key key = keyFactory.forProvidesMethod(sourceElement);
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              declaredContainer,
+              MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(providesMethod, MoreTypes.asTypeElement(declaredContainer)),
+          sourceElement,
           key,
           dependencies,
           findBindingPackage(key),
@@ -205,6 +203,25 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
+    /**
+     * A binding that depends explicitly on a set of individual provision multibinding contribution
+     * methods.
+     */
+    ProvisionBinding syntheticMultibinding(
+        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+      return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(request.requestElement()),
+          request.key(),
+          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
+          findBindingPackage(request.key()),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.forMultibindingRequest(request),
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          scopeOf(request.requestElement()));
+    }
+
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 62b102245..6eae6ccd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -24,7 +24,6 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
-import dagger.MembersInjector;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
@@ -35,10 +34,10 @@
 import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
 
 /**
- * The collection of bindings that have been resolved for a binding key.
+ * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
+ * exactly one binding.
  *
  * @author Gregory Kick
  */
@@ -233,18 +232,21 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
   }
 
   /**
-   * {@code true} if this is a multibindings contribution.
+   * {@code true} if this is a multibinding contribution.
    */
-  boolean isMultibindings() {
-    return !(contributionBindings().isEmpty() && multibindingDeclarations().isEmpty())
-        && contributionType().isMultibinding();
+  boolean isMultibindingContribution() {
+    return contributionBindings().size() == 1
+        && contributionBinding().contributionType().isMultibinding();
   }
 
   /**
-   * {@code true} if this is a unique contribution binding.
+   * Returns the single contribution binding.
+   *
+   * @throws IllegalStateException if there is not exactly one element in
+   *     {@link #contributionBindings()}, which will never happen for contributions in valid graphs
    */
-  boolean isUniqueContribution() {
-    return !contributionBindings().isEmpty() && !contributionType().isMultibinding();
+  ContributionBinding contributionBinding() {
+    return getOnlyElement(contributionBindings());
   }
 
   /**
@@ -272,7 +274,11 @@ public BindingType bindingType() {
   public ContributionType contributionType() {
     ImmutableSet<ContributionType> types = contributionTypes();
     checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
-    checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
+    checkState(
+        types.size() == 1,
+        "More than one binding present of different types for %s: %s",
+        bindingKey(),
+        bindingsAndDeclarationsByContributionType());
     return getOnlyElement(types);
   }
 
@@ -322,15 +328,6 @@ public ContributionType contributionType() {
    * The framework class associated with these bindings.
    */
   Class<?> frameworkClass() {
-    switch (bindingKey().kind()) {
-      case CONTRIBUTION:
-        return Iterables.any(contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))
-            ? BindingType.PRODUCTION.frameworkClass()
-            : BindingType.PROVISION.frameworkClass();
-      case MEMBERS_INJECTION:
-        return MembersInjector.class;
-      default:
-        throw new AssertionError();
-    }
+    return bindingType().frameworkClass();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
index 29949629b..b8bcf5263 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -15,12 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
@@ -48,6 +51,16 @@ TypeElement enclosingTypeElement() {
     return BINDING_TYPE_ELEMENT.visit(element());
   }
 
+  /**
+   * The type of {@link #element()}, considered as a member of {@link #contributedBy()} if it is
+   * present.
+   */
+  TypeMirror asMemberOfContributingType(Types types) {
+    return contributedBy().isPresent()
+        ? types.asMemberOf(MoreTypes.asDeclared(contributedBy().get().asType()), element())
+        : element().asType();
+  }
+
   private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
       new SimpleElementVisitor6<TypeElement, Void>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 36963a7e8..9fe1fb7a1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -94,12 +94,6 @@ protected MemberSelect getMemberSelect(BindingKey key) {
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
 
-  @Override
-  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
-    return super.getMultibindingContributionSnippet(binding)
-        .or(parent.getMultibindingContributionSnippet(binding));
-  }
-
   private ExecutableType resolvedSubcomponentFactoryMethod() {
     return MoreTypes.asExecutable(
         types.asMemberOf(
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index ba235258a..b6dbd268a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -852,11 +852,7 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
-            "  private Provider<Set<Object>> setOfObjectProvider;",
-            "  private Provider<Object> mapOfStringAndProviderOfObjectContribution1;",
-            "  private Provider<Map<String, Provider<Object>>>",
-            "      mapOfStringAndProviderOfObjectProvider;",
+            "  private Provider<Object> parentKeyObjectProvider;",
             "",
             "  private DaggerParent(Builder builder) {",
             "    assert builder != null;",
@@ -873,15 +869,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.setOfObjectContribution1Provider =",
-            "        ParentModule_ParentObjectFactory.create();",
-            "    this.setOfObjectProvider = SetFactory.create(setOfObjectContribution1Provider);",
-            "    this.mapOfStringAndProviderOfObjectContribution1 =",
+            "    this.parentKeyObjectProvider =",
             "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "    this.mapOfStringAndProviderOfObjectProvider =",
-            "        MapProviderFactory.<String, Object>builder(1)",
-            "            .put(\"parent key\", mapOfStringAndProviderOfObjectContribution1)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
@@ -911,6 +900,9 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "    private Provider<Map<String, Provider<Object>>>",
+            "        mapOfStringAndProviderOfObjectProvider;",
             "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
             "",
             "    private ChildImpl() {",
@@ -919,13 +911,19 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
+            "      this.setOfObjectProvider = SetFactory.create(",
+            "          ParentModule_ParentObjectFactory.create());",
+            "      this.mapOfStringAndProviderOfObjectProvider =",
+            "          MapProviderFactory.<String, Object>builder(1)",
+            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
+            "              .build();",
             "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          DaggerParent.this.mapOfStringAndProviderOfObjectProvider);",
+            "          mapOfStringAndProviderOfObjectProvider);",
             "    }",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
-            "      return DaggerParent.this.setOfObjectProvider.get();",
+            "      return setOfObjectProvider.get();",
             "    }",
             "",
             "    @Override",
@@ -1011,83 +1009,84 @@ public void subcomponentOmitsInheritedBindings() {
         "interface TestComponent {",
         "  Set<String> strings();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.SetFactory;",
-        "import java.util.Set;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Set<String>> setOfStringContribution1Provider;",
-        "  private Provider<Set<String>> setOfStringContribution2Provider;",
-        "  private Provider<Set<String>> setOfStringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.setOfStringContribution1Provider =",
-        "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
-        "    this.setOfStringContribution2Provider =",
-        "        SetModule_StringFactory.create(builder.setModule);",
-        "    this.setOfStringProvider = SetFactory.create(",
-        "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Set<String> strings() {",
-        "    return setOfStringProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private EmptySetModule emptySetModule;",
-        "    private SetModule setModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (emptySetModule == null) {",
-        "        this.emptySetModule = new EmptySetModule();",
-        "      }",
-        "      if (setModule == null) {",
-        "        this.setModule = new SetModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
-        "      if (emptySetModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.emptySetModule = emptySetModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder setModule(SetModule setModule) {",
-        "      if (setModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.setModule = setModule;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Set<String>> emptySetProvider;",
+            "  private Provider<Set<String>> stringProvider;",
+            "  private Provider<Set<String>> setOfStringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.emptySetProvider =",
+            "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
+            "    this.stringProvider =",
+            "        SetModule_StringFactory.create(builder.setModule);",
+            "    this.setOfStringProvider = SetFactory.create(",
+            "        emptySetProvider, stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<String> strings() {",
+            "    return setOfStringProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private EmptySetModule emptySetModule;",
+            "    private SetModule setModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (emptySetModule == null) {",
+            "        this.emptySetModule = new EmptySetModule();",
+            "      }",
+            "      if (setModule == null) {",
+            "        this.setModule = new SetModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+            "      if (emptySetModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.emptySetModule = emptySetModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder setModule(SetModule setModule) {",
+            "      if (setModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.setModule = setModule;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 86e84690a..33a897670 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -315,6 +315,8 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
                 "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
                 "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
                 "      test.Outer.CModule.c(test.Outer.C c)",
                 "          [parameter: test.Outer.C c]");
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index c1d622dfd..3eef6ab97 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -32,7 +32,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -70,10 +69,13 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     assertThat(
-        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType()))
-        .isEqualTo(new AutoValue_Key(
-            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-            MoreTypes.equivalence().wrap(typeElement.asType())));
+            keyFactory.forInjectConstructorWithResolvedType(
+                constructor.getEnclosingElement().asType()))
+        .isEqualTo(
+            new AutoValue_Key(
+                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                MoreTypes.equivalence().wrap(typeElement.asType()),
+                Optional.<SourceElement>absent()));
   }
 
   static final class InjectedClass {
@@ -88,10 +90,12 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     assertThat(
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
-        .isEqualTo(new AutoValue_Key(
-            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-            MoreTypes.equivalence().wrap(stringType)));
+            keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement)))
+        .isEqualTo(
+            new AutoValue_Key(
+                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                MoreTypes.equivalence().wrap(stringType),
+                Optional.<SourceElement>absent()));
   }
 
   @Module
@@ -109,8 +113,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key =
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+    Key key = keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -122,7 +125,7 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key provisionKey =
-        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+        keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -163,11 +166,13 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(
-          keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
-              .isEqualTo(new AutoValue_Key(
+      SourceElement sourceElement = SourceElement.forElement(providesMethod, moduleElement);
+      assertThat(keyFactory.forProvidesMethod(sourceElement))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType)));
+                  MoreTypes.equivalence().wrap(setOfStringsType),
+                  Optional.of(sourceElement)));
     }
   }
 
@@ -212,9 +217,9 @@ String provideQualifiedString() {
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
-    Key intKey = keyFactory.forProvidesMethod((ExecutableType) intMethod.asType(), intMethod);
+    Key intKey = keyFactory.forProvidesMethod(SourceElement.forElement(intMethod, primitiveHolder));
     Key integerKey =
-        keyFactory.forProvidesMethod((ExecutableType) integerMethod.asType(), integerMethod);
+        keyFactory.forProvidesMethod(SourceElement.forElement(integerMethod, boxedPrimitiveHolder));
     assertThat(intKey).isEqualTo(integerKey);
   }
 
@@ -224,11 +229,13 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(
-          (ExecutableType) producesMethod.asType(), producesMethod))
-              .isEqualTo(new AutoValue_Key(
+      assertThat(
+              keyFactory.forProducesMethod(SourceElement.forElement(producesMethod, moduleElement)))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(stringType)));
+                  MoreTypes.equivalence().wrap(stringType),
+                  Optional.<SourceElement>absent()));
     }
   }
 
@@ -251,11 +258,13 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(
-          (ExecutableType) producesMethod.asType(), producesMethod))
-          .isEqualTo(new AutoValue_Key(
+      SourceElement sourceElement = SourceElement.forElement(producesMethod, moduleElement);
+      assertThat(keyFactory.forProducesMethod(sourceElement))
+          .isEqualTo(
+              new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType)));
+                  MoreTypes.equivalence().wrap(setOfStringsType),
+                  Optional.of(sourceElement)));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index ab2212722..1d70c289d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -110,88 +110,88 @@ public void mapBindingsWithEnumKey() {
         "interface TestComponent {",
         "  Map<PathEnum, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathEnum, Provider<Handler>>>",
-        "      mapOfPathEnumAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(PathEnum.ADMIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(PathEnum.LOGIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -270,86 +270,88 @@ public void mapBindingsWithStringKey() {
         "interface TestComponent {",
         "  Map<String, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<String, Provider<Handler>>>",
-        "      mapOfStringAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfStringAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfStringAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfStringAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<String, Handler>builder(2)",
-        "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
-        "            .put(\"Login\", mapOfStringAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<String, Provider<Handler>> dispatcher() {",
-        "    return mapOfStringAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<String, Provider<Handler>>>",
+            "      mapOfStringAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfStringAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<String, Handler>builder(2)",
+            "            .put(\"Admin\", provideAdminHandlerProvider)",
+            "            .put(\"Login\", provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<Handler>> dispatcher() {",
+            "    return mapOfStringAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -437,88 +439,90 @@ public void mapBindingsWithWrappedKey() {
         "interface TestComponent {",
         "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
-        "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
-        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
-        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
-        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+            "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+            "                provideAdminHandlerProvider)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -608,92 +612,92 @@ public void mapBindingsWithNonProviderValue() {
         "interface TestComponent {",
         "  Map<PathEnum, Handler> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapFactory;",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathEnum, Provider<Handler>>>",
-        "      mapOfPathEnumAndProviderOfHandlerProvider;",
-        "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(PathEnum.ADMIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(PathEnum.LOGIN,",
-        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "    this.mapOfPathEnumAndHandlerProvider =",
-        "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathEnum, Handler> dispatcher() {",
-        "    return mapOfPathEnumAndHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "    this.mapOfPathEnumAndHandlerProvider =",
+            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Handler> dispatcher() {",
+            "    return mapOfPathEnumAndHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 98e88ca99..88cc79b0d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -200,88 +200,90 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathKey, Provider<Handler>>>",
-        "      mapOfPathKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -376,88 +378,90 @@ public void mapKeyComponentFileWithDefaultField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MapProviderFactory;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<PathKey, Provider<Handler>>>",
-        "      mapOfPathKeyAndProviderOfHandlerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
-        "            .build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModuleOne mapModuleOne;",
-        "    private MapModuleTwo mapModuleTwo;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModuleOne == null) {",
-        "        this.mapModuleOne = new MapModuleOne();",
-        "      }",
-        "      if (mapModuleTwo == null) {",
-        "        this.mapModuleTwo = new MapModuleTwo();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-        "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleOne = mapModuleOne;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-        "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModuleTwo = mapModuleTwo;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      if (mapModuleOne == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleOne = mapModuleOne;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      if (mapModuleTwo == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.mapModuleTwo = mapModuleTwo;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1437e6f8a..ade310cbf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -150,7 +150,6 @@
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
             "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
             "  private Provider<Set<Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<B> bProvider;",
@@ -168,10 +167,9 @@
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
             "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "    this.setOfFactoryContribution1Provider =",
+            "    this.setOfFactoryProvider = SetFactory.create(",
             "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
-            "            .create();",
-            "    this.setOfFactoryProvider = SetFactory.create(setOfFactoryContribution1Provider);",
+            "            .create());",
             "    this.monitorProvider =",
             "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "            builder.testClass$SimpleComponent_MonitoringModule,",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 6fc871684..145e856f2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -257,8 +257,9 @@ public void monitoringDependsOnProduction() {
             "  }",
             "}");
     String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory> is a"
-            + " provision, which cannot depend on a production.";
+        "@Provides(type=SET) dagger.producers.monitoring.ProductionComponentMonitor.Factory"
+            + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
+            + " which cannot depend on a production.";
     assertAbout(javaSource())
         .that(component)
         .processedWith(new ComponentProcessor())
