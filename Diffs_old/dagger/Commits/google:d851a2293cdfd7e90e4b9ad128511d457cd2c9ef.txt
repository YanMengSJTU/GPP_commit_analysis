diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
new file mode 100644
index 000000000..56491a1e2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import dagger.Module;
+
+// https://github.com/google/dagger/issues/279
+public class ComponentsWithNestedModules {
+  @Component(modules = RegularComponent.SharedModule.class)
+  public interface RegularComponent {
+    @Module class SharedModule {}
+  }
+
+  @Component(modules = ExtendsRegularComponent.SharedModule.class)
+  public interface ExtendsRegularComponent extends RegularComponent {
+    @Module(includes = RegularComponent.SharedModule.class)
+    class SharedModule {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
new file mode 100644
index 000000000..c5fa3fa68
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class BlueModule {
+  @Provides(type = SET)
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
new file mode 100644
index 000000000..1bf133794
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface BlueScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
new file mode 100644
index 000000000..9a160ff4b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class GreenModule  {
+  @Provides(type = SET)
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
new file mode 100644
index 000000000..57bb5ae7c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface GreenScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
new file mode 100644
index 000000000..8e5e03ee3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Component;
+import java.util.Set;
+
+@BlueScope
+@GreenScope
+@Component(modules = {BlueModule.class, GreenModule.class, TurquoiseModule.class})
+interface ScopedComponent {
+  Set<Object> set();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
new file mode 100644
index 000000000..7947ccfbd
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class TurquoiseModule {
+  @Provides(type = SET)
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+
+  @Provides(type = SET)
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index ebb067d6f..504139aa2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -18,7 +18,7 @@
 import dagger.Component;
 import javax.inject.Singleton;
 
-@Component(modules = ParentModule.class)
+@Component(modules = {ParentModule.class, UnresolvableChildComponentModule.class})
 @Singleton
 interface ParentComponent extends ParentGetters {
   ChildComponent newChildComponent();
@@ -28,4 +28,10 @@
   ChildComponentRequiringModules newChildComponentRequiringModules(
       ChildModuleWithParameters cmwp,
       ChildModuleWithState childModuleWithState);
+
+  /**
+   * Requests a qualified version of this subcomponent builder, which does not install it as a
+   * subcomponent, but instead, uses the explicit binding of this qualified builder.
+   */
+  @SomeQualifier UnresolvableChildComponent.Builder unresolvableChildComponentBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
new file mode 100644
index 000000000..83606e538
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface SomeQualifier {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
new file mode 100644
index 000000000..c4cb79a5f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A qualifier representing an unbound type, to verify that the compiler does not attempt to
+ * generate code depending on it.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface Unbound {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
new file mode 100644
index 000000000..8e19b5e86
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+/**
+ * A subcomponent that's not resolvable in any parent component, for testing that qualified methods
+ * on components that return subcomponents do not trigger actual subcomponents.
+ */
+@Subcomponent
+interface UnresolvableChildComponent {
+  /**
+   * Requests a type that is never bound in any component that this subcomponent might be installed
+   * in. If this subcomponent is ever attempted to be installed in a component, then it will produce
+   * a compiler error.
+   */
+  @Unbound
+  String unboundString();
+
+  @Subcomponent.Builder
+  interface Builder {
+    UnresolvableChildComponent build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
new file mode 100644
index 000000000..0c273f737
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class UnresolvableChildComponentModule {
+  /**
+   * Provides a qualified version of the {@link UnresolvableChildComponent}'s builder. If the
+   * subcomponent were actually installed in a component, this would be a duplicate binding; but
+   * since that doesn't happen, this binding is OK.
+   */
+  @Provides
+  @SomeQualifier
+  static UnresolvableChildComponent.Builder unresolvableChildComponentBuilder() {
+    return new UnresolvableChildComponent.Builder() {
+      @Override
+      public UnresolvableChildComponent build() {
+        return new UnresolvableChildComponent() {
+          @Override
+          public String unboundString() {
+            return "unbound";
+          }
+        };
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
new file mode 100644
index 000000000..aa289b12c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void testScope() {
+    ScopedComponent component = DaggerScopedComponent.create();
+    assertThat(component.set()).hasSize(4);
+    assertThat(component.set()).isEqualTo(component.set());
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index cb6292513..ee89254b0 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -111,5 +111,11 @@ public void passedModules() {
   @Test
   public void dependenceisInASubcomponent() {
     assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
-  }  
+  }
+
+  @Test
+  public void qualifiedSubcomponentIsBound() {
+    assertThat(parentComponent.unresolvableChildComponentBuilder().build().unboundString())
+        .isEqualTo("unbound");
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index efbd5a593..845e52426 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -21,6 +21,7 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
+import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
@@ -48,4 +49,17 @@
 
   @PossiblyThrowingMap
   ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
+
+  ListenableFuture<Set<Object>> objs();
+
+  ListenableFuture<Set<Produced<Object>>> producedObjs();
+
+  ListenableFuture<Map<Object, Object>> objMap();
+
+  ListenableFuture<Map<Object, Produced<Object>>> objMapOfProduced();
+
+  ListenableFuture<Map<Object, Producer<Object>>> objMapOfProducer();
+
+  @ObjCount
+  ListenableFuture<Integer> objCount();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index dbeefeede..d63da4d50 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -18,12 +18,16 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Multibindings;
 import dagger.mapkeys.IntKey;
+import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.Map;
+import java.util.Set;
+import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
-import java.util.Set;
 
 import static dagger.producers.Produces.Type.MAP;
 import static dagger.producers.Produces.Type.SET;
@@ -99,4 +103,17 @@ static String valueFor15() {
   static String throwingValueFor15() {
     throw new RuntimeException("monkey");
   }
+
+  @Multibindings
+  interface MultiBindings {
+    Set<Object> objs();
+
+    Map<Object, Object> objMap();
+  }
+
+  @Produces
+  @ObjCount
+  static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
+    return objs.size() + objMap.size();
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
index 1a41b4330..c638270ed 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -32,5 +32,10 @@
   @Qualifier
   @interface PossiblyThrowingMap {}
 
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface ObjCount {}
+
   private Qualifiers() {}
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
new file mode 100644
index 000000000..da1c7b257
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProductionScope;
+
+@Module
+final class ScopedModule {
+  @Provides
+  @ProductionScope
+  static Object newScopedObject() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
new file mode 100644
index 000000000..646eda45e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.producers.ProductionScope;
+import javax.inject.Inject;
+
+@ProductionScope
+final class ScopedObject {
+  @Inject
+  ScopedObject() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
new file mode 100644
index 000000000..c7801c06a
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = {ScopedModule.class, SetProducerModule.class})
+interface SetComponent {
+  ScopedObject scopedObject();
+
+  ListenableFuture<Set<Object>> set();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
new file mode 100644
index 000000000..a5fc81e16
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import static dagger.producers.Produces.Type.SET;
+
+/**
+ * A module that provides two entries into a set; but since the inputs are scoped, the set should
+ * only have one value.
+ */
+@ProducerModule
+final class SetProducerModule {
+  @Produces(type = SET)
+  static Object setValue1(Object value) {
+    return value;
+  }
+
+  @Produces(type = SET)
+  static Object setValue2(Object value) {
+    return value;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
new file mode 100644
index 000000000..b44e4e21d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import producerstest.subcomponent.sub.ChildComponent;
+
+final class MultiPackageSubcomponents {
+  @Component(modules = IntModule.class)
+  interface ParentComponent {
+    ChildComponent.Builder childComponentBuilder();
+  }
+
+  @Module
+  static final class IntModule {
+    @Provides
+    static int i() {
+      return 42;
+    }
+  }
+
+  private MultiPackageSubcomponents() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
index 3ebd6078d..b998c5a3d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
@@ -51,7 +51,7 @@ static String fromParent() {
   interface ParentComponent {
     InjectsChildBuilder injectsChildBuilder();
 
-    ChildComponent.Builder newChildComponentBuilder();
+    ChildComponentWithExecutor.Builder newChildComponentBuilder();
   }
 
   @ProducerModule
@@ -84,23 +84,36 @@ static String fromChild(@FromParent String fromParent) {
 
     GrandchildComponent.Builder newGrandchildComponentBuilder();
 
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildComponent build();
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponentWithExecutor {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
     @ProductionSubcomponent.Builder
     interface Builder {
       Builder executor(Executor executor);
 
-      ChildComponent build();
+      ChildComponentWithExecutor build();
     }
   }
 
   static final class InjectsChildBuilder {
-    private final Provider<ChildComponent.Builder> childBuilder;
+    private final Provider<ChildComponentWithExecutor.Builder> childBuilder;
 
     @Inject
-    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+    InjectsChildBuilder(Provider<ChildComponentWithExecutor.Builder> childBuilder) {
       this.childBuilder = childBuilder;
     }
 
-    ChildComponent.Builder childBuilder() {
+    ChildComponentWithExecutor.Builder childBuilder() {
       return childBuilder.get();
     }
   }
@@ -121,8 +134,6 @@ static String fromGranchild(@FromChild String fromChild) {
 
     @ProductionSubcomponent.Builder
     interface Builder {
-      Builder executor(Executor executor);
-
       GrandchildComponent build();
     }
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
new file mode 100644
index 000000000..0e0fae51d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+final class SubcomponentsWithBoundExecutor {
+  @Qualifier
+  @interface FromParent {}
+
+  @Qualifier
+  @interface FromChild {}
+
+  @Qualifier
+  @interface FromGrandchild {}
+
+  static final class CountingExecutor implements Executor {
+    private final AtomicInteger executionCount;
+
+    CountingExecutor(AtomicInteger executionCount) {
+      this.executionCount = executionCount;
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+      executionCount.incrementAndGet();
+      runnable.run();
+    }
+  }
+
+  @Module
+  static final class ExecutorModule {
+    private final AtomicInteger constructionCount;
+    private final AtomicInteger executionCount;
+
+    ExecutorModule(AtomicInteger constructionCount, AtomicInteger executionCount) {
+      this.constructionCount = constructionCount;
+      this.executionCount = executionCount;
+    }
+
+    @Provides
+    @Production
+    Executor executor() {
+      constructionCount.incrementAndGet();
+      return new CountingExecutor(executionCount);
+    }
+  }
+
+  @Module
+  static final class ParentModule {
+    @Provides
+    @FromParent
+    static String fromParent() {
+      return "parent";
+    }
+  }
+
+  @Component(modules = {ParentModule.class, ExecutorModule.class})
+  interface ParentComponent {
+    InjectsChildBuilder injectsChildBuilder();
+
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ParentProducerModule {
+    @Produces
+    @FromParent
+    static String fromParent() {
+      return "parentproduction";
+    }
+  }
+
+  @ProductionComponent(modules = {ParentProducerModule.class, ExecutorModule.class})
+  interface ParentProductionComponent {
+    ChildComponent.Builder newChildComponentBuilder();
+
+    @ProductionComponent.Builder
+    interface Builder {
+      Builder executorModule(ExecutorModule executorModule);
+
+      ParentProductionComponent build();
+    }
+  }
+
+  @ProducerModule
+  static final class ChildProducerModule {
+    @Produces
+    @FromChild
+    static String fromChild(@FromParent String fromParent) {
+      return "child:" + fromParent;
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponent {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildComponent build();
+    }
+  }
+
+  static final class InjectsChildBuilder {
+    private final Provider<ChildComponent.Builder> childBuilder;
+
+    @Inject
+    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+      this.childBuilder = childBuilder;
+    }
+
+    ChildComponent.Builder childBuilder() {
+      return childBuilder.get();
+    }
+  }
+
+  @ProducerModule
+  static final class GrandchildProducerModule {
+    @Produces
+    @FromGrandchild
+    static String fromGranchild(@FromChild String fromChild) {
+      return "grandchild:" + fromChild;
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponent {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      GrandchildComponent build();
+    }
+  }
+
+  private SubcomponentsWithBoundExecutor() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
new file mode 100644
index 000000000..a53bb3564
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent.sub;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+
+@ProductionSubcomponent(modules = ChildModule.class)
+public interface ChildComponent {
+  ListenableFuture<String> str();
+
+  @ProductionSubcomponent.Builder
+  interface Builder {
+    Builder executor(Executor executor);
+    ChildComponent build();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
new file mode 100644
index 000000000..43b79f4b5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent.sub;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ChildModule {
+  @Produces
+  static String str(int n) {
+    return "Hello, World " + n;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
index 9a5602990..67d47ead5 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -1,18 +1,18 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
@@ -23,6 +23,7 @@
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import org.junit.Before;
 import org.junit.Test;
@@ -43,6 +44,7 @@
 public class ProducerFactoryTest {
   @Mock private ProductionComponentMonitor componentMonitor;
   private ProducerMonitor monitor;
+  private Provider<Executor> executorProvider;
   private Provider<ProductionComponentMonitor> componentMonitorProvider;
 
   @Before
@@ -50,6 +52,14 @@ public void setUpMocks() {
     MockitoAnnotations.initMocks(this);
     monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
     when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    // TODO(beder): Use Providers.of when available.
+    executorProvider =
+        new Provider<Executor>() {
+          @Override
+          public Executor get() {
+            return MoreExecutors.directExecutor();
+          }
+        };
     componentMonitorProvider =
         new Provider<ProductionComponentMonitor>() {
           @Override
@@ -63,8 +73,7 @@ public ProductionComponentMonitor get() {
   public void noArgMethod() throws Exception {
     ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     Producer<String> producer =
-        new SimpleProducerModule_StrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider);
+        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
     assertThat(producer.get().get()).isEqualTo("str");
     InOrder order = inOrder(componentMonitor, monitor);
     order.verify(componentMonitor).producerMonitorFor(token);
@@ -74,12 +83,13 @@ public void noArgMethod() throws Exception {
     order.verifyNoMoreInteractions();
   }
 
-  @Test public void singleArgMethod() throws Exception {
+  @Test
+  public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
     Producer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
         new SimpleProducerModule_StrWithArgFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, intProducer);
+            executorProvider, componentMonitorProvider, intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
     assertThat(producer.get().get()).isEqualTo("str with arg");
@@ -94,7 +104,7 @@ public void successMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+            executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -121,7 +131,7 @@ public void failureMonitor() throws Exception {
     Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+            executorProvider, componentMonitorProvider, strFutureProducer);
     assertThat(producer.get().isDone()).isFalse();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -151,7 +161,7 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
     Producer<String> producer =
         new SimpleProducerModule_ThrowingProducerFactory(
-            MoreExecutors.directExecutor(), componentMonitorProvider);
+            executorProvider, componentMonitorProvider);
     assertThat(producer.get().isDone()).isTrue();
 
     InOrder order = inOrder(componentMonitor, monitor);
@@ -172,12 +182,13 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
 
   @Test(expected = NullPointerException.class)
   public void nullComponentMonitorProvider() throws Exception {
-    new SimpleProducerModule_StrFactory(MoreExecutors.directExecutor(), null);
+    new SimpleProducerModule_StrFactory(executorProvider, null);
   }
 
   private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
     return new Producer<T>() {
-      @Override public ListenableFuture<T> get() {
+      @Override
+      public ListenableFuture<T> get() {
         return future;
       }
     };
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 15ce7592c..0919fded2 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -158,4 +158,22 @@ public void mapOfProducedBindingWithFailures() throws Exception {
       assertThat(e.getCause()).hasMessage("monkey");
     }
   }
+
+  @Test
+  public void emptySet() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.objs().get()).isEmpty();
+    assertThat(multibindingComponent.producedObjs().get()).isEmpty();
+    assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
+  }
+
+  @Test
+  public void emptyMap() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.objMap().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
new file mode 100644
index 000000000..36ce255e5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void scope() throws Exception {
+    SetComponent component =
+        DaggerSetComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(component.set().get()).hasSize(1);
+    assertThat(component.scopedObject()).isSameAs(component.scopedObject());
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
new file mode 100644
index 000000000..ad5c86d22
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Executor;
+import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
+import producerstest.subcomponent.sub.ChildComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class MultiPackageSubcomponentTest {
+
+  @Test
+  public void childComponent() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerMultiPackageSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.childComponentBuilder().executor(executor).build();
+    assertThat(child.str().get()).isEqualTo("Hello, World 42");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
index ef15bdd23..ddd43403e 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
@@ -23,6 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import producerstest.subcomponent.Subcomponents.ChildComponent;
+import producerstest.subcomponent.Subcomponents.ChildComponentWithExecutor;
 import producerstest.subcomponent.Subcomponents.GrandchildComponent;
 import producerstest.subcomponent.Subcomponents.ParentComponent;
 import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
@@ -33,7 +34,7 @@
   public void topLevelComponent_child() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
     assertThat(child.fromChild().get()).isEqualTo("child:parent");
   }
 
@@ -41,7 +42,8 @@ public void topLevelComponent_child() throws Exception {
   public void topLevelComponent_injectsChildBuilder() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.injectsChildBuilder().childBuilder().executor(executor).build();
+    ChildComponentWithExecutor child =
+        parent.injectsChildBuilder().childBuilder().executor(executor).build();
     assertThat(child.fromChild().get()).isEqualTo("child:parent");
   }
 
@@ -49,9 +51,8 @@ public void topLevelComponent_injectsChildBuilder() throws Exception {
   public void topLevelComponent_grandchild() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild =
-        child.newGrandchildComponentBuilder().executor(executor).build();
+    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
     assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
   }
 
@@ -60,7 +61,7 @@ public void topLevelProductionComponent_child() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentProductionComponent parent =
         DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().build();
     assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
   }
 
@@ -69,9 +70,8 @@ public void topLevelProductionComponent_grandchild() throws Exception {
     Executor executor = MoreExecutors.directExecutor();
     ParentProductionComponent parent =
         DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild =
-        child.newGrandchildComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
     assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
new file mode 100644
index 000000000..389a8d4b6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
+import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentWithBoundExecutorTest {
+  private ParentComponent parentComponent;
+  private ParentProductionComponent parentProductionComponent;
+  private final AtomicInteger executorConstructionCount = new AtomicInteger();
+  private final AtomicInteger executionCount = new AtomicInteger();
+
+  @Before
+  public void setUp() {
+    parentComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+    parentProductionComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentProductionComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+  }
+
+  @Test
+  public void topLevelComponent_child() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_injectsChildBuilder() throws Exception {
+    ChildComponent child = parentComponent.injectsChildBuilder().childBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_grandchild() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_child() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchild() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(3);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 8467c30fc..66203083e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -36,6 +36,7 @@
 import dagger.internal.DelegateFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
+import dagger.internal.Preconditions;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -61,7 +62,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
-import javax.tools.Diagnostic.Kind;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
@@ -74,12 +74,11 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
 import static dagger.internal.codegen.MemberSelect.localField;
@@ -123,11 +122,15 @@
  * Creates the implementation class for a component or subcomponent.
  */
 abstract class AbstractComponentWriter {
+  private static final String NOOP_BUILDER_METHOD_JAVADOC =
+      "This module is declared, but an instance is not used in the component. This method is a "
+          + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
   protected final Types types;
   protected final Key.Factory keyFactory;
-  protected final Kind nullableValidationType;
+  protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
@@ -156,14 +159,14 @@
       Types types,
       Elements elements,
       Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType,
+      CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentImplNames) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
     this.name = name;
     this.graph = graph;
     this.subcomponentImplNames = subcomponentImplNames;
@@ -369,17 +372,17 @@ private void addBuilderMethods(
             parameterNames.getUniqueName(
                 Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
         builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
-        builderMethod.addCode(nullCheck(parameterName));
         if (graph.componentRequirements().contains(builderMethodType)) {
           // required type
           builderMethod.addStatement(
-              "this.$N = $L", builderFields.get(builderMethodType), parameterName);
+              "this.$N = $T.checkNotNull($L)",
+              builderFields.get(builderMethodType),
+              Preconditions.class,
+              parameterName);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
           // owned, but not required
-          builderMethod.addCode(
-              "// This module is declared, but not used in the component. This method is a "
-                  + "no-op\n");
+          builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else {
           // neither owned nor required, so it must be an inherited module
@@ -399,12 +402,18 @@ private void addBuilderMethods(
             methodBuilder(componentRequirementName)
                 .returns(builderName.get())
                 .addModifiers(PUBLIC)
-                .addParameter(ClassName.get(componentRequirement), componentRequirementName)
-                .addCode(nullCheck(componentRequirementName));
+                .addParameter(ClassName.get(componentRequirement), componentRequirementName);
         if (graph.componentRequirements().contains(componentRequirement)) {
           builderMethod.addStatement(
-              "this.$N = $L", builderFields.get(componentRequirement), componentRequirementName);
+              "this.$N = $T.checkNotNull($L)",
+              builderFields.get(componentRequirement),
+              Preconditions.class,
+              componentRequirementName);
         } else {
+          builderMethod.addStatement("$T.checkNotNull($L)",
+              Preconditions.class,
+              componentRequirementName);
+          builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
           builderMethod.addAnnotation(Deprecated.class);
         }
         builderMethod.addStatement("return this");
@@ -743,7 +752,7 @@ private void initializeFrameworkTypes() {
     if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
       return Optional.absent();
     }
-    
+
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         return initializeContributionBinding(bindingKey);
@@ -864,17 +873,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           // What should we do?
           CodeBlock getMethodBody =
               binding.nullableType().isPresent()
-                      || nullableValidationType.equals(Diagnostic.Kind.WARNING)
+                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
                   ? CodeBlocks.format("return $L;", callFactoryMethod)
-                  : CodeBlocks.format(
-                      Joiner.on('\n')
-                          .join(
-                              "$T provided = $L;",
-                              "if (provided == null) {",
-                              "  throw new NullPointerException($S);",
-                              "}",
-                              "return provided;"),
-                      bindingKeyTypeName,
+                  : CodeBlocks.format("return $T.checkNotNull($L, $S);",
+                      Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
           return CodeBlocks.format(
@@ -929,6 +931,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               : factoryCreate;
         }
 
+      case EXECUTOR_DEPENDENCY:
+        return CodeBlocks.format(
+            "$T.<$T>create($L)",
+            INSTANCE_FACTORY,
+            bindingKeyTypeName,
+            getComponentContributionExpression(
+                graph.componentDescriptor().executorDependency().get()));
+
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
@@ -959,9 +969,6 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
             arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
           }
-          arguments.add(
-              getComponentContributionExpression(
-                  graph.componentDescriptor().executorDependency().get()));
           arguments.addAll(getDependencyArguments(binding));
 
           return CodeBlocks.format(
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 26d3b61d4..71e1361ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -151,8 +151,8 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   /**
    * The scope of this binding.
    */
-  Scope scope() {
-    return Scope.unscoped();
+  Optional<Scope> scope() {
+    return Optional.absent();
   }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a85b8f6a4..869af2334 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -197,6 +197,12 @@ private BindingGraph create(
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
+      // immediate binding for the executor, if it's provided to the builder
+      if (componentDescriptor.executorDependency().isPresent()) {
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forExecutorDependency(componentDefinitionType));
+      }
+
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class)
@@ -493,10 +499,10 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
 
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the † compatibility mode
-        Scope bindingScope = binding.scope();
+        Optional<Scope> bindingScope = binding.scope();
         if (bindingScope.isPresent()) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
+            if (requestResolver.componentDescriptor.scopes().contains(bindingScope.get())) {
               return Optional.of(requestResolver);
             }
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 15c540ede..90a897d0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -42,6 +42,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.SourceElement.HasSourceElement;
+import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -63,6 +64,7 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -104,10 +106,10 @@
 
 public class BindingGraphValidator {
 
+  private final Elements elements;
   private final Types types;
+  private final CompilerOptions compilerOptions;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final ValidationType scopeCycleValidationType;
-  private final Diagnostic.Kind nullableValidationType;
   private final HasSourceElementFormatter hasSourceElementFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
@@ -115,19 +117,19 @@
   private final Key.Factory keyFactory;
 
   BindingGraphValidator(
+      Elements elements,
       Types types,
+      CompilerOptions compilerOptions,
       InjectBindingRegistry injectBindingRegistry,
-      ValidationType scopeCycleValidationType,
-      Diagnostic.Kind nullableValidationType,
       HasSourceElementFormatter hasSourceElementFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter,
       Key.Factory keyFactory) {
+    this.elements = elements;
     this.types = types;
+    this.compilerOptions = compilerOptions;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.scopeCycleValidationType = scopeCycleValidationType;
-    this.nullableValidationType = nullableValidationType;
     this.hasSourceElementFormatter = hasSourceElementFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
@@ -173,7 +175,7 @@ void validateSubgraph() {
               new HashSet<DependencyRequest>());
         }
       }
-      
+
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
           filterKeys(
                   subject.componentDescriptor().subcomponents(),
@@ -305,6 +307,22 @@ private boolean validateResolvedBinding(
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
+          if (compilerOptions.usesProducers()) {
+            Key productionImplementationExecutorKey =
+                keyFactory.forProductionImplementationExecutor();
+            // only forbid depending on the production executor if it's not the Dagger-specific
+            // binding to the implementation
+            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
+              Key productionExecutorKey = keyFactory.forProductionExecutor();
+              for (DependencyRequest request : contributionBinding.dependencies()) {
+                if (request.key().equals(productionExecutorKey)
+                    || request.key().equals(productionImplementationExecutorKey)) {
+                  reportDependsOnProductionExecutor(path);
+                  return false;
+                }
+              }
+            }
+          }
           if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
             ImmutableSet<ContributionBinding> multibindings =
                 inlineSyntheticContributions(resolvedBinding).contributionBindings();
@@ -358,7 +376,7 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
           .anyMatch(IS_SYNTHETIC_KIND)) {
         return resolvedBinding;
       }
-      
+
       ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
           ImmutableSetMultimap.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
@@ -418,7 +436,7 @@ private boolean validateNullability(
               nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
-              nullableValidationType,
+              compilerOptions.nullableValidationKind(),
               request.requestElement());
           valid = false;
         }
@@ -597,9 +615,11 @@ private void validateComponentHierarchy(
         componentStack.push(componentType);
         appendIndentedComponentsList(message, componentStack);
         componentStack.pop();
-        reportBuilder.addItem(message.toString(),
-            scopeCycleValidationType.diagnosticKind().get(),
-            rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+        reportBuilder.addItem(
+            message.toString(),
+            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+            rootComponent,
+            getAnnotationMirror(rootComponent, Component.class).get());
       } else {
         Optional<AnnotationMirror> componentAnnotation =
             getAnnotationMirror(componentType, Component.class);
@@ -624,27 +644,32 @@ private void validateComponentHierarchy(
      */
     private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Scope scope = descriptor.scope();
+      ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
-      if (scope.isPresent()) {
+      if (!scopes.isEmpty()) {
+        Scope singletonScope = Scope.singletonScope(elements);
         // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (scopeCycleValidationType.diagnosticKind().isPresent()
-            && scope.isSingleton()) {
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()
+            && scopes.contains(singletonScope)) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
             StringBuilder message = new StringBuilder(
                 "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            reportBuilder.addItem(message.toString(),
-                scopeCycleValidationType.diagnosticKind().get(),
+            reportBuilder.addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
                 descriptor.componentDefinitionType(),
                 descriptor.componentAnnotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder(scope.getReadableSource())
-              .append(' ')
+          StringBuilder message = new StringBuilder();
+          for (Scope scope : scopes) {
+            message.append(scope.getReadableSource()).append(' ');
+          }
+          message
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
@@ -654,10 +679,10 @@ private void validateDependencyScopes() {
               descriptor.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
-          if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
+          if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
-                new ArrayDeque<Scope>(),
+                new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
           }
         }
@@ -730,41 +755,53 @@ public boolean apply(TypeElement input) {
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
-        Deque<Scope> scopeStack,
+        Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      Scope scope = Scope.scopeOf(componentType);
-      if (scope.isPresent()) {
-        if (scopeStack.contains(scope)) {
-          scopedDependencyStack.push(componentType);
-          // Current scope has already appeared in the component chain.
-          StringBuilder message = new StringBuilder();
-          message.append(rootComponent.getQualifiedName());
-          message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
-          appendIndentedComponentsList(message, scopedDependencyStack);
-          if (scopeCycleValidationType.diagnosticKind().isPresent()) {
-            reportBuilder.addItem(message.toString(),
-                scopeCycleValidationType.diagnosticKind().get(),
-                rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+      ImmutableSet<Scope> scopes = Scope.scopesOf(componentType);
+      if (stackOverlaps(scopeStack, scopes)) {
+        scopedDependencyStack.push(componentType);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
+          reportBuilder.addItem(
+              message.toString(),
+              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+              rootComponent,
+              getAnnotationMirror(rootComponent, Component.class)
+                  .or(getAnnotationMirror(rootComponent, ProductionComponent.class))
+                  .get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        // TODO(beder): transitively check scopes of production components too.
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
+          if (scopedDependencies.size() == 1) {
+            // empty can be ignored (base-case), and > 1 is a different error reported separately.
+            scopeStack.push(scopes);
+            scopedDependencyStack.push(componentType);
+            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                scopeStack, scopedDependencyStack);
+            scopedDependencyStack.pop();
+            scopeStack.pop();
           }
-          scopedDependencyStack.pop();
-        } else {
-          Optional<AnnotationMirror> componentAnnotation =
-              getAnnotationMirror(componentType, Component.class);
-          if (componentAnnotation.isPresent()) {
-            ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-                MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
-            if (scopedDependencies.size() == 1) {
-              // empty can be ignored (base-case), and > 1 is a different error reported separately.
-              scopeStack.push(scope);
-              scopedDependencyStack.push(componentType);
-              validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                  scopeStack, scopedDependencyStack);
-              scopedDependencyStack.pop();
-              scopeStack.pop();
-            }
-          } // else: we skip component dependencies which are not components
+        } // else: we skip component dependencies which are not components
+      }
+    }
+
+    private <T> boolean stackOverlaps(Deque<ImmutableSet<T>> stack, ImmutableSet<T> set) {
+      for (ImmutableSet<T> entry : stack) {
+        if (!Sets.intersection(entry, set).isEmpty()) {
+          return true;
         }
       }
+      return false;
     }
 
     /**
@@ -773,12 +810,12 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      */
     void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      Scope componentScope = subject.componentDescriptor().scope();
+      ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-          Scope bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+          Optional<Scope> bindingScope = contributionBinding.scope();
+          if (bindingScope.isPresent() && !componentScopes.contains(bindingScope.get())) {
             // Scoped components cannot reference bindings to @Provides methods or @Inject
             // types decorated by a different scope annotation. Unscoped components cannot
             // reference to scoped @Provides methods or @Inject types decorated by any
@@ -792,7 +829,7 @@ void validateComponentScope() {
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
-                    bindingScope.getReadableSource()
+                    bindingScope.get().getReadableSource()
                         + " class "
                         + contributionBinding.bindingTypeElement().getQualifiedName());
                 break;
@@ -807,10 +844,12 @@ void validateComponentScope() {
       if (!incompatiblyScopedMethods.isEmpty()) {
         TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
-        if (componentScope.isPresent()) {
+        if (!componentScopes.isEmpty()) {
           message.append(" scoped with ");
-          message.append(componentScope.getReadableSource());
-          message.append(" may not reference bindings with different scopes:\n");
+          for (Scope scope : componentScopes) {
+            message.append(scope.getReadableSource()).append(' ');
+          }
+          message.append("may not reference bindings with different scopes:\n");
         } else {
           message.append(" (unscoped) may not reference scoped bindings:\n");
         }
@@ -880,6 +919,14 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
+    @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    private void reportDependsOnProductionExecutor(Deque<ResolvedRequest> path) {
+      StringBuilder builder = new StringBuilder();
+      new Formatter(builder)
+          .format(ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatRootRequestKey(path));
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
@@ -1079,8 +1126,7 @@ private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathEleme
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      Scope scope = Scope.scopeOf(scopedComponent);
-      if (scope.isPresent()) {
+      for (Scope scope : Scope.scopesOf(scopedComponent)) {
         message.append(scope.getReadableSource()).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
@@ -1095,7 +1141,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
       @Override public boolean apply(TypeElement input) {
-        return Scope.scopeOf(input).isPresent();
+        return !Scope.scopesOf(input).isEmpty();
       }
     }).toSet();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 626308d79..047f455af 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -17,7 +17,6 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
@@ -57,10 +56,6 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
-  static CodeBlock nullCheck(String thingToCheck) {
-    return format("if ($L == null) { throw new NullPointerException(); } ", thingToCheck);
-  }
-
   static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
     return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
new file mode 100644
index 000000000..aa92fa5c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Ascii;
+import dagger.producers.Produces;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.util.Elements;
+import javax.tools.Diagnostic;
+
+/** A collection of options that dictate how the compiler will run. */
+final class CompilerOptions {
+  private final boolean usesProducers;
+  private final Diagnostic.Kind nullableValidationKind;
+  private final Diagnostic.Kind privateMemberValidationKind;
+  private final Diagnostic.Kind staticMemberValidationKind;
+  private final ValidationType scopeCycleValidationType;
+
+  CompilerOptions(ProcessingEnvironment processingEnv, Elements elements) {
+    this(
+        elements.getTypeElement(Produces.class.getCanonicalName()) != null,
+        nullableValidationType(processingEnv).diagnosticKind().get(),
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get(),
+        scopeValidationType(processingEnv));
+  }
+
+  CompilerOptions(
+      boolean usesProducers,
+      Diagnostic.Kind nullableValidationKind,
+      Diagnostic.Kind privateMemberValidationKind,
+      Diagnostic.Kind staticMemberValidationKind,
+      ValidationType scopeCycleValidationType) {
+    this.usesProducers = usesProducers;
+    this.nullableValidationKind = nullableValidationKind;
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+    this.scopeCycleValidationType = scopeCycleValidationType;
+  }
+
+  boolean usesProducers() {
+    return usesProducers;
+  }
+
+  Diagnostic.Kind nullableValidationKind() {
+    return nullableValidationKind;
+  }
+
+  Diagnostic.Kind privateMemberValidationKind() {
+    return privateMemberValidationKind;
+  }
+
+  Diagnostic.Kind staticMemberValidationKind() {
+    return staticMemberValidationKind;
+  }
+
+  ValidationType scopeCycleValidationType() {
+    return scopeCycleValidationType;
+  }
+
+  static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
+      "dagger.disableInterComponentScopeValidation";
+
+  static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
+
+  static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY = "dagger.privateMemberValidation";
+
+  static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
+
+  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.allOf(ValidationType.class));
+  }
+
+  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        NULLABLE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static <T extends Enum<T>> T valueOf(
+      ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
+    Map<String, String> options = processingEnv.getOptions();
+    if (options.containsKey(key)) {
+      try {
+        T type =
+            Enum.valueOf(defaultValue.getDeclaringClass(), Ascii.toUpperCase(options.get(key)));
+        if (!validValues.contains(type)) {
+          throw new IllegalArgumentException(); // let handler below print out good msg.
+        }
+        return type;
+      } catch (IllegalArgumentException e) {
+        processingEnv
+            .getMessager()
+            .printMessage(
+                Diagnostic.Kind.ERROR,
+                "Processor option -A"
+                    + key
+                    + " may only have the values "
+                    + validValues
+                    + " (case insensitive), found: "
+                    + options.get(key));
+      }
+    }
+    return defaultValue;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 5d929868f..2d1d98149 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -61,6 +61,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -171,6 +172,19 @@ boolean isTopLevel() {
       return isTopLevel;
     }
 
+    boolean isProducer() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return false;
+        case PRODUCTION_COMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
+          return true;
+        default:
+          throw new AssertionError();
+      }
+    }
+
     private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
         new Function<Kind, Class<? extends Annotation>>() {
           @Override
@@ -262,9 +276,9 @@ boolean isTopLevel() {
   abstract Optional<TypeElement> executorDependency();
 
   /**
-   * The scope of the component.
+   * The scopes of the component.
    */
-  abstract Scope scope();
+  abstract ImmutableSet<Scope> scopes();
 
   abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
@@ -406,11 +420,6 @@ private ComponentDescriptor create(
         }
       }
 
-      Optional<TypeElement> executorDependency =
-          kind.equals(Kind.PRODUCTION_COMPONENT) || kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
-              ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
-              : Optional.<TypeElement>absent();
-
       ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
@@ -421,6 +430,7 @@ private ComponentDescriptor create(
               && (parentKind.get().equals(Kind.COMPONENT)
                   || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
         modules.add(descriptorForMonitoringModule(componentDefinitionType));
+        modules.add(descriptorForProductionExecutorModule(componentDefinitionType));
       }
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
@@ -467,8 +477,14 @@ private ComponentDescriptor create(
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
+      Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
 
-      Scope scope = Scope.scopeOf(componentDefinitionType);
+      ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
+      if (kind.isProducer()) {
+        scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
+      }
+
+      Optional<TypeElement> executorDependency = createExecutorDependency(kind, builderSpec);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -477,10 +493,10 @@ private ComponentDescriptor create(
           modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
-          scope,
+          scopes,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
-          createBuilderSpec(builderType));
+          builderSpec);
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(
@@ -501,21 +517,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
               componentMethod,
               dependencyRequestFactory.forComponentMembersInjectionMethod(
                   componentMethod, resolvedComponentMethod));
-        } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
-          return ComponentMethodDescriptor.forSubcomponent(
-              ComponentMethodKind.SUBCOMPONENT, componentMethod);
-        } else if (isAnnotationPresent(
-            MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
-          return ComponentMethodDescriptor.forSubcomponent(
-              ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
-        } else if (isAnnotationPresent(
-            MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
-          return ComponentMethodDescriptor.forSubcomponent(
-              ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
-        } else if (isAnnotationPresent(
-            MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
-          return ComponentMethodDescriptor.forSubcomponent(
-              ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
+        } else if (!getQualifier(componentMethod).isPresent()) {
+          if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
+            return ComponentMethodDescriptor.forSubcomponent(
+                ComponentMethodKind.SUBCOMPONENT, componentMethod);
+          } else if (isAnnotationPresent(
+              MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
+            return ComponentMethodDescriptor.forSubcomponent(
+                ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
+          } else if (isAnnotationPresent(
+              MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
+            return ComponentMethodDescriptor.forSubcomponent(
+                ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
+          } else if (isAnnotationPresent(
+              MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
+            return ComponentMethodDescriptor.forSubcomponent(
+                ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
+          }
         }
       }
 
@@ -575,6 +593,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
 
+    private Optional<TypeElement> createExecutorDependency(
+        Kind componentKind, Optional<BuilderSpec> builderSpec) {
+      if (!componentKind.isProducer()) {
+        return Optional.absent();
+      }
+      TypeElement executorTypeElement = elements.getTypeElement(Executor.class.getCanonicalName());
+      if (!builderSpec.isPresent()) {
+        // if there's no builder, we'll add an executor() method to the generated builder so it
+        // must be specified
+        // TODO(beder): Remove this behavior.
+        return Optional.of(executorTypeElement);
+      }
+      return builderSpec.get().methodMap().containsKey(executorTypeElement)
+          ? Optional.of(executorTypeElement)
+          : Optional.<TypeElement>absent();
+    }
+
     /**
      * Returns a descriptor for a generated module that handles monitoring for production
      * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
@@ -592,6 +627,27 @@ private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefi
       }
       return moduleDescriptorFactory.create(monitoringModule);
     }
+
+    /**
+     * Returns a descriptor for a generated module that handles the producer executor for production
+     * components. This module is generated in the {@link ProductionExecutorModuleProcessingStep}.
+     *
+     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+     *     processor to retry in a later processing round.
+     */
+    // TODO(beder): Replace this with a single class when the producers client library exists.
+    private ModuleDescriptor descriptorForProductionExecutorModule(
+        TypeElement componentDefinitionType) {
+      ClassName productionExecutorModuleName =
+          SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
+      String generatedProductionExecutorModuleName = productionExecutorModuleName.toString();
+      TypeElement productionExecutorModule =
+          elements.getTypeElement(generatedProductionExecutorModuleName);
+      if (productionExecutorModule == null) {
+        throw new TypeNotPresentException(generatedProductionExecutorModuleName, null);
+      }
+      return moduleDescriptorFactory.create(productionExecutorModule);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 2b47e3baa..b1b530b09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,7 +24,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -36,19 +35,19 @@
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
-  private final Diagnostic.Kind nullableValidationType;
+  private final CompilerOptions compilerOptions;
 
   ComponentGenerator(
       Filer filer,
       Elements elements,
       Types types,
       Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType) {
+      CompilerOptions compilerOptions) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -68,8 +67,7 @@ ClassName nameGeneratedType(BindingGraph input) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        new ComponentWriter(
-                types, elements, keyFactory, nullableValidationType, componentName, input)
+        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input)
             .write());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e66907977..90126f9db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -17,22 +17,15 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
-import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import java.util.EnumSet;
-import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -57,11 +50,10 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   public Set<String> getSupportedOptions() {
     return ImmutableSet.of(
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        NULLABLE_VALIDATION_KEY,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY
-    );
+        CompilerOptions.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        CompilerOptions.NULLABLE_VALIDATION_KEY,
+        CompilerOptions.PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        CompilerOptions.STATIC_MEMBER_VALIDATION_TYPE_KEY);
   }
 
   @Override
@@ -71,8 +63,7 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
-    Diagnostic.Kind nullableDiagnosticType =
-        nullableValidationType(processingEnv).diagnosticKind().get();
+    CompilerOptions compilerOptions = new CompilerOptions(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
@@ -81,12 +72,8 @@ public SourceVersion getSupportedSourceVersion() {
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
-    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get());
-    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(compilerOptions);
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(compilerOptions);
     MembersInjectedTypeValidator membersInjectedTypeValidator =
         new MembersInjectedTypeValidator(injectFieldValidator, injectMethodValidator);
     ModuleValidator moduleValidator =
@@ -107,14 +94,16 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
 
-    this.factoryGenerator = new FactoryGenerator(filer, elements, nullableDiagnosticType);
+    this.factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions);
     this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, elements);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
+    ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
+        new ProductionExecutorModuleGenerator(filer, elements);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, keyFactory);
@@ -161,10 +150,10 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
+            elements,
             types,
+            compilerOptions,
             injectBindingRegistry,
-            scopeValidationType(processingEnv),
-            nullableDiagnosticType,
             hasSourceElementFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
@@ -175,6 +164,7 @@ public SourceVersion getSupportedSourceVersion() {
         new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
         new ModuleProcessingStep(
             messager,
@@ -221,64 +211,4 @@ protected void postProcess() {
       e.printMessageTo(processingEnv.getMessager());
     }
   }
-
-  private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
-      "dagger.disableInterComponentScopeValidation";
-
-  private static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
-
-  private static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY =
-      "dagger.privateMemberValidation";
-
-  private static final String STATIC_MEMBER_VALIDATION_TYPE_KEY =
-      "dagger.staticMemberValidation";
-
-  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.allOf(ValidationType.class));
-  }
-
-  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        NULLABLE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(processingEnv,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
-
-  private static <T extends Enum<T>> T valueOf(ProcessingEnvironment processingEnv, String key,
-      T defaultValue, Set<T> validValues) {
-    Map<String, String> options = processingEnv.getOptions();
-    if (options.containsKey(key)) {
-      try {
-        T type = Enum.valueOf(
-            defaultValue.getDeclaringClass(),
-            Ascii.toUpperCase(options.get(key)));
-        if (!validValues.contains(type)) {
-          throw new IllegalArgumentException(); // let handler below print out good msg.
-        }
-        return type;
-      } catch (IllegalArgumentException e) {
-        processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
-            + key + " may only have the values " + validValues
-            + " (case insensitive), found: " + options.get(key));
-      }
-    }
-    return defaultValue;
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 6a7750fa2..d6492f41d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -35,7 +35,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic.Kind;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -54,14 +53,14 @@
       Types types,
       Elements elements,
       Key.Factory keyFactory,
-      Kind nullableValidationType,
+      CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
     super(
         types,
         elements,
         keyFactory,
-        nullableValidationType,
+        compilerOptions,
         name,
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index a9f1ffa35..76e8c0d64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -89,7 +89,7 @@
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
     for (AnnotationMirror mirror : mirrors) {
-      if (mirror.getAnnotationType().asElement().getSimpleName().toString().equals("Nullable")) {
+      if (mirror.getAnnotationType().asElement().getSimpleName().contentEquals("Nullable")) {
         return Optional.of(mirror.getAnnotationType());
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 71cb38afd..6aec6a795 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -142,6 +142,13 @@ public Kind apply(ContributionBinding binding) {
      */
     SUBCOMPONENT_BUILDER,
 
+    /**
+     * The executor provided in a builder for a production component. This executor is used to
+     * schedule producer methods, and its specification on the component builder is to provide an
+     * implicit provision for it.
+     */
+    EXECUTOR_DEPENDENCY,
+
     // Production kinds
 
     /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f0a726a91..cbc579105 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -342,6 +342,17 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Optional.<String>absent());
     }
 
+    DependencyRequest forProductionImplementationExecutor() {
+      Key key = keyFactory.forProductionImplementationExecutor();
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          key,
+          MoreTypes.asElement(key.type()),
+          MoreTypes.asDeclared(key.type()),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
     DependencyRequest forProductionComponentMonitorProvider() {
       TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
       for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2077864d7..3737805e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -203,6 +203,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision, which cannot depend on a production.";
+  
+  static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
+      "%s may not depend on the production executor.";
 
   static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
       "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
@@ -226,6 +229,10 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
+  static final String PRODUCTION_COMPONENT_SCOPE =
+      "Production components may not declare any @Scope other than @ProductionScope; they are "
+          + "automatically scoped with @ProductionScope if no scope is applied.";
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 94ec0e5af..ce97a2ce3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,6 +30,8 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.Preconditions;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -73,14 +75,11 @@
  */
 final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
 
-  private final Diagnostic.Kind nullableValidationType;
+  private final CompilerOptions compilerOptions;
 
-  FactoryGenerator(
-      Filer filer,
-      Elements elements,
-      Diagnostic.Kind nullableValidationType) {
+  FactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
     super(filer, elements);
-    this.nullableValidationType = nullableValidationType;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -242,28 +241,23 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             "return $T.<$T>singleton($L)",
             Collections.class, paramTypeName, providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
-          || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+          || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
         }
         getMethodBuilder.addStatement("return $L", providesMethodInvocation);
       } else {
-        String failMsg = CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
-        getMethodBuilder
-            .addStatement(
-                "$T provided = $L", getMethodBuilder.build().returnType, providesMethodInvocation)
-            .addCode("if (provided == null) { ")
-            .addStatement("throw new $T($S)", NullPointerException.class, failMsg)
-            .addCode("}")
-            .addStatement("return provided");
+        getMethodBuilder.addStatement("return $T.checkNotNull($L, $S)",
+            Preconditions.class,
+            providesMethodInvocation,
+            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
       }
     } else if (binding.membersInjectionRequest().isPresent()) {
-      getMethodBuilder.addStatement(
-          "$1T instance = new $1T($2L)", providedTypeName, parametersCodeBlock);
-      getMethodBuilder.addStatement(
-          "$L.injectMembers(instance)",
-          fields.get(binding.membersInjectionRequest().get().bindingKey()).name());
-      getMethodBuilder.addStatement("return instance");
+      getMethodBuilder.addStatement("return $T.injectMembers($L, new $T($L))",
+          MembersInjectors.class,
+          fields.get(binding.membersInjectionRequest().get().bindingKey()).name(),
+          providedTypeName,
+          parametersCodeBlock);
     } else {
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
index d73930aee..9441f7172 100644
--- a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
@@ -21,9 +21,8 @@
 import dagger.internal.codegen.SourceElement.HasSourceElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 
 /**
  * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
@@ -38,16 +37,19 @@
   @Override
   public String format(HasSourceElement hasElement) {
     SourceElement sourceElement = hasElement.sourceElement();
-    checkArgument(
-        sourceElement.element().asType().getKind().equals(TypeKind.EXECUTABLE),
-        "Not yet supporting nonexecutable elements: %s",
-        hasElement);
-
-    Optional<TypeElement> contributedBy = sourceElement.contributedBy();
-    return methodSignatureFormatter.format(
-        MoreElements.asExecutable(sourceElement.element()),
-        contributedBy.isPresent()
-            ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
-            : Optional.<DeclaredType>absent());
+    switch (sourceElement.element().asType().getKind()) {
+      case EXECUTABLE:
+        Optional<TypeElement> contributedBy = sourceElement.contributedBy();
+        return methodSignatureFormatter.format(
+            MoreElements.asExecutable(sourceElement.element()),
+            contributedBy.isPresent()
+                ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
+                : Optional.<DeclaredType>absent());
+      case DECLARED:
+        return stripCommonTypePrefixes(sourceElement.element().asType().toString());
+      default:
+        throw new IllegalArgumentException(
+            "Formatting unsupported for element: " + sourceElement.element());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index 96822b190..198ae7136 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -21,7 +21,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
@@ -40,13 +39,10 @@
  * @since 2.0
  */
 final class InjectFieldValidator {
-  private Kind privateMemberValidationKind;
-  private Kind staticMemberValidationKind;
-  
-  public InjectFieldValidator(
-      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
+  private CompilerOptions compilerOptions;
+
+  public InjectFieldValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
   }
 
   ValidationReport<VariableElement> validate(VariableElement fieldElement) {
@@ -57,11 +53,13 @@ public InjectFieldValidator(
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, privateMemberValidationKind, fieldElement);
+      builder.addItem(
+          PRIVATE_INJECT_FIELD, compilerOptions.privateMemberValidationKind(), fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
-      builder.addItem(STATIC_INJECT_FIELD, staticMemberValidationKind, fieldElement);
+      builder.addItem(
+          STATIC_INJECT_FIELD, compilerOptions.staticMemberValidationKind(), fieldElement);
     }
     
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index b151ee4fa..3ad6e7d74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -22,7 +22,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
@@ -42,13 +41,10 @@
  * @since 2.0
  */
 final class InjectMethodValidator {
-  private Kind privateMemberValidationKind;
-  private Kind staticMemberValidationKind;
-  
-  public InjectMethodValidator(
-      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
+  private CompilerOptions compilerOptions;
+
+  public InjectMethodValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
   }
 
   ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
@@ -59,11 +55,13 @@ public InjectMethodValidator(
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, privateMemberValidationKind, methodElement);
+      builder.addItem(
+          PRIVATE_INJECT_METHOD, compilerOptions.privateMemberValidationKind(), methodElement);
     }
     
     if (modifiers.contains(STATIC)) {
-      builder.addItem(STATIC_INJECT_METHOD, staticMemberValidationKind, methodElement);
+      builder.addItem(
+          STATIC_INJECT_METHOD, compilerOptions.staticMemberValidationKind(), methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index b3b245dfb..c911fda7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -32,20 +32,6 @@
  * @since 2.0
  */
 final class InjectionAnnotations {
-  static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
-    checkNotNull(e);
-    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(e);
-    switch (scopeAnnotations.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.<AnnotationMirror>of(scopeAnnotations.iterator().next());
-      default:
-        throw new IllegalArgumentException(
-            e + " was annotated with more than one @Scope annotation");
-    }
-  }
-
   static Optional<AnnotationMirror> getQualifier(Element e) {
     checkNotNull(e);
     ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index af635fcba..a1650b0b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -32,9 +32,12 @@
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.Production;
 import dagger.producers.Produces;
+import dagger.producers.internal.ProductionImplementation;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
@@ -67,7 +70,7 @@
  */
 @AutoValue
 abstract class Key {
-  
+
   /** An object that is associated with a {@link Key}. */
   interface HasKey {
     /** The key associated with this object. */
@@ -91,7 +94,7 @@
    * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
-  
+
   /**
    * For multibinding contributions, this is the binding method element. Each multibound map and set
    * is represented by a
@@ -344,7 +347,7 @@ Key forProducesMethod(SourceElement sourceElement) {
           ? key
           : key.withBindingMethod(sourceElement);
     }
-    
+
     /**
      * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
      *
@@ -444,6 +447,18 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
           Optional.<SourceElement>absent());
     }
 
+    Key forProductionExecutor() {
+      return forQualifiedType(
+          Optional.of(SimpleAnnotationMirror.of(getClassElement(Production.class))),
+          getClassElement(Executor.class).asType());
+    }
+
+    Key forProductionImplementationExecutor() {
+      return forQualifiedType(
+          Optional.of(SimpleAnnotationMirror.of(getClassElement(ProductionImplementation.class))),
+          getClassElement(Executor.class).asType());
+    }
+
     /**
      * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index e831ef296..476469a59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -39,11 +39,13 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -110,6 +112,8 @@ ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
     TypeSpec.Builder mapKeyCreatorBuilder =
         classBuilder(generatedTypeName.simpleName()).addModifiers(PUBLIC, FINAL);
 
+    mapKeyCreatorBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+
     for (TypeElement annotationElement :
         nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
       mapKeyCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 20b45fd53..bb3794ca5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -17,6 +17,7 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeSpec;
@@ -36,6 +37,7 @@
 import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.element.Modifier.FINAL;
 
@@ -60,8 +62,10 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
         classBuilder(generatedTypeName.simpleName())
-            .addAnnotation(Module.class)
-            .addModifiers(FINAL)
+            .addAnnotation(
+                AnnotationSpec.builder(Module.class)
+                    .build())
+            .addModifiers(PUBLIC, FINAL)
 
             // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
             .addMethod(
@@ -71,19 +75,15 @@ ClassName nameGeneratedType(TypeElement componentElement) {
                     .addAnnotation(PROVIDES_SET_VALUES)
                     .addStatement("return $T.of()", ClassName.get(ImmutableSet.class))
                     .build())
-
             .addField(
                 FieldSpec.builder(MonitorCache.class, "monitorCache", PRIVATE, FINAL)
                     .initializer("new $T()", MonitorCache.class)
                     .build())
-
             .addMethod(
                 methodBuilder("monitor")
                     .returns(ProductionComponentMonitor.class)
                     .addAnnotation(Provides.class)
-                    .addParameter(
-                        providerOf(ClassName.get(componentElement.asType())),
-                        "component")
+                    .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
                     .addParameter(providerOf(SET_OF_FACTORIES), "factories")
                     .addStatement("return monitorCache.monitor(component, factories)")
                     .build()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 6dfa0952b..9aa21f4ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -48,7 +48,6 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
-import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
@@ -118,8 +117,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
-    addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
-
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
@@ -179,10 +176,16 @@ public boolean apply(DependencyRequest dependency) {
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
             getInvocationCodeBlock(
-                !returnsFuture, binding, providedTypeName, futureTransform.parameterCodeBlocks()));
+                generatedTypeName,
+                !returnsFuture,
+                binding,
+                providedTypeName,
+                futureTransform.parameterCodeBlocks()));
     computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, $L, executor)",
-        FUTURES, futureTransform.futureCodeBlock(), transformCodeBlock);
+        "return $T.transformAsync($L, $L, executorProvider.get())",
+        FUTURES,
+        futureTransform.futureCodeBlock(),
+        transformCodeBlock);
 
     factoryBuilder.addMethod(constructorBuilder.build());
     factoryBuilder.addMethod(computeMethodBuilder.build());
@@ -436,6 +439,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
   private CodeBlock getInvocationCodeBlock(
+      ClassName generatedTypeName,
       boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
@@ -443,7 +447,7 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
         binding.bindingElement().getModifiers().contains(STATIC)
             ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-            : "module",
+            : CodeBlocks.format("$T.this.module", generatedTypeName),
         binding.bindingElement().getSimpleName(),
         makeParametersCodeBlock(parameterCodeBlocks));
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index ab8a5d33f..4630567f0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -64,10 +64,12 @@ public BindingType bindingType() {
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Similar optimizations to ContributionBinding.implicitDependencies().
-    if (!monitorRequest().isPresent()) {
+    if (!executorRequest().isPresent() && !monitorRequest().isPresent()) {
       return super.implicitDependencies();
     } else {
-      return Sets.union(monitorRequest().asSet(), super.implicitDependencies());
+      return Sets.union(
+          Sets.union(executorRequest().asSet(), monitorRequest().asSet()),
+          super.implicitDependencies());
     }
   }
 
@@ -77,6 +79,9 @@ public BindingType bindingType() {
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
+  /** If this production requires an executor, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> executorRequest();
+
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
@@ -106,6 +111,8 @@ ProductionBinding forProducesMethod(
               MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
+      DependencyRequest executorRequest =
+          dependencyRequestFactory.forProductionImplementationExecutor();
       DependencyRequest monitorRequest =
           dependencyRequestFactory.forProductionComponentMonitorProvider();
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
@@ -121,6 +128,7 @@ ProductionBinding forProducesMethod(
           kind,
           producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
+          Optional.of(executorRequest),
           Optional.of(monitorRequest));
     }
 
@@ -143,6 +151,7 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Kind.SYNTHETIC_MAP,
           Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
 
@@ -162,6 +171,7 @@ ProductionBinding syntheticMultibinding(
           Kind.forMultibindingRequest(request),
           Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
 
@@ -180,6 +190,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
+          Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
new file mode 100644
index 000000000..1b8e5ab6d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Production;
+import dagger.producers.ProductionScope;
+import dagger.producers.internal.ProductionImplementation;
+
+import java.util.concurrent.Executor;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.FINAL;
+
+/** Generates a producer executor module for use with production components. */
+// TODO(beder): Replace this with a single class when the producers client library exists.
+final class ProductionExecutorModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
+
+  ProductionExecutorModuleGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
+  }
+
+  @Override
+  ClassName nameGeneratedType(TypeElement componentElement) {
+    return SourceFiles.generatedProductionExecutorModuleName(componentElement);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
+    return Optional.of(componentElement);
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
+    return Optional.of(
+        classBuilder(generatedTypeName.simpleName())
+            .addAnnotation(
+                AnnotationSpec.builder(Module.class)
+                    .build())
+            .addModifiers(FINAL)
+            .addMethod(
+                methodBuilder("executor")
+                    .returns(Executor.class)
+                    .addModifiers(STATIC)
+                    .addAnnotation(Provides.class)
+                    .addAnnotation(ProductionScope.class)
+                    .addAnnotation(ProductionImplementation.class)
+                    .addParameter(
+                        ParameterSpec.builder(Executor.class, "executor")
+                            .addAnnotation(Production.class)
+                            .build())
+                    .addStatement("return executor")
+                    .build()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
new file mode 100644
index 000000000..24a728738
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * A processing step that is responsible for generating a special module for a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+final class ProductionExecutorModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ProductionExecutorModuleGenerator productionExecutorModuleGenerator;
+
+  ProductionExecutorModuleProcessingStep(
+      Messager messager, ProductionExecutorModuleGenerator productionExecutorModuleGenerator) {
+    this.messager = messager;
+    this.productionExecutorModuleGenerator = productionExecutorModuleGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.values()) {
+      try {
+        productionExecutorModuleGenerator.generate(MoreElements.asType(element));
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 346fdc4b3..aa08f5c2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
+import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -39,7 +40,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -63,7 +63,7 @@ public BindingType bindingType() {
   abstract Optional<ProvisionBinding> unresolved();
 
   @Override
-  abstract Scope scope();
+  abstract Optional<Scope> scope();
   
   static final class Factory {
     private final Elements elements;
@@ -113,7 +113,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Scope scope = Scope.scopeOf(constructorElement.getEnclosingElement());
+      Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
@@ -165,7 +165,7 @@ ProvisionBinding forProvidesMethod(
               MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Scope scope = Scope.scopeOf(providesMethod);
+      Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           sourceElement,
           key,
@@ -200,7 +200,7 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           Kind.SYNTHETIC_MAP,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          scopeOf(implicitMapOfProviderRequest.requestElement()));
+          Scope.uniqueScopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     /**
@@ -219,7 +219,7 @@ ProvisionBinding syntheticMultibinding(
           Kind.forMultibindingRequest(request),
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          scopeOf(request.requestElement()));
+          Scope.uniqueScopeOf(request.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -234,14 +234,14 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.unscoped());
+          Optional.<Scope>absent());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Scope scope = Scope.scopeOf(componentMethod);
+      Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
@@ -271,7 +271,23 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Kind.SUBCOMPONENT_BUILDER,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.unscoped());
+          Optional.<Scope>absent());
+    }
+
+    ProvisionBinding forExecutorDependency(TypeElement componentElement) {
+      TypeElement executorElement = elements.getTypeElement(Executor.class.getCanonicalName());
+      checkNotNull(executorElement);
+      return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentElement),
+          keyFactory.forProductionExecutor(),
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          Optional.<DeclaredType>absent(),
+          Optional.<DependencyRequest>absent(),
+          Kind.EXECUTOR_DEPENDENCY,
+          Provides.Type.UNIQUE,
+          Optional.<ProvisionBinding>absent(),
+          Optional.<Scope>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index bcb009d1e..962440fd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -17,72 +17,75 @@
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
-import javax.annotation.Nullable;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.producers.ProductionScope;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 
-import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 
 /**
  * A representation of the scope (or lack of it) associated with a component, providing method
  * or injection location.
  */
 final class Scope {
-
-  /**
-   * An internal representation for an unscoped binding.
-   */
-  private static final Scope UNSCOPED = new Scope();
-
   /**
    * The underlying {@link AnnotationMirror} that represents the scope annotation.
    */
-  @Nullable
   private final AnnotationMirror annotationMirror;
 
-  private Scope(@Nullable AnnotationMirror annotationMirror) {
-    this.annotationMirror = annotationMirror;
+  private Scope(AnnotationMirror annotationMirror) {
+    this.annotationMirror = checkNotNull(annotationMirror);
   }
 
-  private Scope() {
-    this(null);
+  /** Returns all of the associated scoped annotations from the source code element. */
+  static ImmutableSet<Scope> scopesOf(Element element) {
+    return FluentIterable.from(getScopes(element)).
+        transform(new Function<AnnotationMirror, Scope>() {
+          @Override public Scope apply(AnnotationMirror annotationMirror) {
+            return new Scope(annotationMirror);
+          }
+        }).toSet();
   }
 
   /**
-   * Returns representation for an unscoped binding.
+   * Returns at most one associated scoped annotation from the source code element, throwing an
+   * exception if there are more than one.
    */
-  static Scope unscoped() {
-    return UNSCOPED;
-  }
-
-  /**
-   * If the source code element has an associated scoped annotation then returns a representation
-   * of that scope, otherwise returns a representation for an unscoped binding.
-   */
-  static Scope scopeOf(Element element) {
-    Optional<AnnotationMirror> scopeAnnotation = getScopeAnnotation(element);
-    return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
+  static Optional<Scope> uniqueScopeOf(Element element) {
+    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(element);
+    if (scopeAnnotations.isEmpty()) {
+      return Optional.absent();
+    }
+    return Optional.of(new Scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
 
   /**
-   * Returns true if the scope is present, i.e. it's not unscoped binding.
+   * Returns a representation for producer scope;
    */
-  public boolean isPresent() {
-    return annotationMirror != null;
+  static Scope productionScope(Elements elements) {
+    return new Scope(
+        SimpleAnnotationMirror.of(
+            elements.getTypeElement(ProductionScope.class.getCanonicalName())));
   }
 
   /**
-   * Returns true if the scope represents the {@link Singleton @Singleton} annotation.
+   * Returns a representation for singleton scope.
    */
-  public boolean isSingleton() {
-    return annotationMirror != null
-        && isTypeOf(Singleton.class, annotationMirror.getAnnotationType());
+  static Scope singletonScope(Elements elements) {
+    return new Scope(
+        SimpleAnnotationMirror.of(
+            elements.getTypeElement(Singleton.class.getCanonicalName())));
   }
 
   /**
@@ -140,6 +143,6 @@ public int hashCode() {
    */
   @Override
   public String toString() {
-    return annotationMirror == null ? "UNSCOPED" : annotationMirror.toString();
+    return annotationMirror.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
new file mode 100644
index 000000000..c94eafea6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/** A representation of an annotation with no fields. */
+final class SimpleAnnotationMirror implements AnnotationMirror {
+  private final DeclaredType type;
+
+  private SimpleAnnotationMirror(DeclaredType type) {
+    this.type = type;
+  }
+
+  @Override
+  public DeclaredType getAnnotationType() {
+    return type;
+  }
+
+  @Override
+  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues() {
+    return ImmutableMap.of();
+  }
+
+  @Override
+  public String toString() {
+    return "@" + type;
+  }
+
+  static AnnotationMirror of(TypeElement element) {
+    checkArgument(element.getKind().equals(ElementKind.ANNOTATION_TYPE));
+    checkArgument(element.getEnclosedElements().isEmpty());
+    return new SimpleAnnotationMirror(MoreTypes.asDeclared(element.asType()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 0e3e6e6fd..acd56f102 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -255,6 +255,10 @@ static ClassName generatedMonitoringModuleName(
     return siblingClassName(componentElement, "_MonitoringModule");
   }
 
+  static ClassName generatedProductionExecutorModuleName(TypeElement componentElement) {
+    return siblingClassName(componentElement, "_ProductionExecutorModule");
+  }
+
   // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code
   // which could use this.
   private static ClassName siblingClassName(TypeElement typeElement, String suffix) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 118713147..641fefd7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -25,6 +25,7 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import java.util.List;
 import java.util.Set;
@@ -41,7 +42,6 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -64,7 +64,7 @@ public SubcomponentWriter(
         parent.types,
         parent.elements,
         parent.keyFactory,
-        parent.nullableValidationType,
+        parent.compilerOptions,
         subcomponentName(parent, subgraph),
         subgraph,
         parent.subcomponentImplNames);
@@ -184,8 +184,10 @@ private void writeSubcomponentWithoutBuilder(
         String actualModuleName = contributionField.name;
         constructor
             .addParameter(moduleType, actualModuleName)
-            .addCode(nullCheck(actualModuleName))
-            .addStatement("this.$1L = $1L", actualModuleName);
+            .addStatement(
+                "this.$1L = $2T.checkNotNull($1L)",
+                actualModuleName,
+                Preconditions.class);
 
         MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 05f510121..2a39030b4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -130,6 +130,7 @@ public void testUsesBuildAndSetterNames() {
         "test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
@@ -173,10 +174,7 @@ public void testUsesBuildAndSetterNames() {
         "",
         "    @Override",
         "    public Builder setTestModule(TestModule testModule) {",
-        "      if (testModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.testModule = testModule;",
+        "      this.testModule = Preconditions.checkNotNull(testModule);",
         "      return this;",
         "    }",
         "  }",
@@ -231,6 +229,7 @@ public void testIgnoresModulesNotInApi() {
         "test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
@@ -285,10 +284,7 @@ public void testIgnoresModulesNotInApi() {
         "",
         "    @Override",
         "    public Builder testModule1(TestModule1 testModule1) {",
-        "      if (testModule1 == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.testModule1 = testModule1;",
+        "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
         "      return this;",
         "    }",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index d389dfcb1..7cb18f3e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -484,6 +484,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
@@ -531,10 +532,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    }",
         "",
         "    public Builder testModule(TestModule testModule) {",
-        "      if (testModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.testModule = testModule;",
+        "      this.testModule = Preconditions.checkNotNull(testModule);",
         "      return this;",
         "    }",
         "  }",
@@ -620,6 +618,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
@@ -647,49 +646,37 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "    @Deprecated",
         "    public Builder testModule(TestModule testModule) {",
-        "      if (testModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(testModule)",
         "      return this;",
         "    }",
         "",
         "    @Deprecated",
         "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
-        "      if (parentTestIncluded == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(parentTestIncluded)",
         "      return this;",
         "    }",
         "",
         "    @Deprecated",
         "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
-        "      if (alwaysIncluded == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(alwaysIncluded)",
         "      return this;",
         "    }",
         "",
         "    @Deprecated",
         "    public Builder depModule(DepModule depModule) {",
-        "      if (depModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(depModule)",
         "      return this;",
         "    }",
         "",
         "    @Deprecated",
         "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
-        "      if (parentDepIncluded == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(parentDepIncluded)",
         "      return this;",
         "    }",
         "",
         "    @Deprecated",
         "    public Builder refByDep(RefByDep refByDep) {",
-        "      if (refByDep == null) {",
-        "        throw new NullPointerException();",
-        "      }",
+        "      Preconditions.checkNotNull(refByDep)",
         "      return this;",
         "    }",
         "  }",
@@ -841,6 +828,7 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "import dagger.internal.MapFactory;",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import dagger.internal.SetFactory;",
             "import java.util.Map;",
             "import java.util.Set;",
@@ -888,10 +876,7 @@ public void subcomponentOmitsInheritedBindings() {
             "    }",
             "",
             "    public Builder parentModule(ParentModule parentModule) {",
-            "      if (parentModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.parentModule = parentModule;",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
             "      return this;",
             "    }",
             "  }",
@@ -1011,6 +996,7 @@ public void subcomponentOmitsInheritedBindings() {
             "test.DaggerTestComponent",
             "package test;",
             "",
+            "import dagger.internal.Preconditions;",
             "import dagger.internal.SetFactory;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
@@ -1068,18 +1054,12 @@ public void subcomponentOmitsInheritedBindings() {
             "    }",
             "",
             "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
-            "      if (emptySetModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.emptySetModule = emptySetModule;",
+            "      this.emptySetModule = Preconditions.checkNotNull(emptySetModule);",
             "      return this;",
             "    }",
             "",
             "    public Builder setModule(SetModule setModule) {",
-            "      if (setModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.setModule = setModule;",
+            "      this.setModule = Preconditions.checkNotNull(setModule);",
             "      return this;",
             "    }",
             "  }",
@@ -1456,6 +1436,7 @@ public void subcomponentOmitsInheritedBindings() {
         "package test;",
         "",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
@@ -1478,11 +1459,7 @@ public void subcomponentOmitsInheritedBindings() {
         "    this.aProvider = new Factory<A>() {",
         "      private final AComponent aComponent = builder.aComponent;",
         "      @Override public A get() {",
-        "        A provided = aComponent.a();",
-        "        if (provided == null) {",
-        "          throw new NullPointerException(" + NPE_LITERAL + ");",
-        "        }",
-        "        return provided;",
+        "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
         "      }",
         "    };",
         "    this.bProvider = B_Factory.create(aProvider);",
@@ -1508,10 +1485,7 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "",
         "    public Builder aComponent(AComponent aComponent) {",
-        "      if (aComponent == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.aComponent = aComponent;",
+        "      this.aComponent = Preconditions.checkNotNull(aComponent);",
         "      return this;",
         "    }",
         "  }",
@@ -1570,6 +1544,7 @@ public void subcomponentOmitsInheritedBindings() {
         "test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
@@ -1625,18 +1600,12 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "",
         "    public Builder testModule(TestModule testModule) {",
-        "      if (testModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.testModule = testModule;",
+        "      this.testModule = Preconditions.checkNotNull(testModule);",
         "      return this;",
         "    }",
         "",
         "    public Builder testModule(other.test.TestModule testModule) {",
-        "      if (testModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.testModule2 = testModule;",
+        "      this.testModule2 = Preconditions.checkNotNull(testModule);",
         "      return this;",
         "    }",
         "  }",
@@ -2241,8 +2210,7 @@ public void unprocessedMembersInjectorNotes() {
                       public boolean apply(Element element) {
                         return MoreElements.getPackage(element)
                             .getQualifiedName()
-                            .toString()
-                            .equals("test.inject");
+                            .contentEquals("test.inject");
                       }
                     })))
         .compilesWithoutError();
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index de998be5f..a4b796e76 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -180,6 +180,7 @@
             "",
             "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
+            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
@@ -194,9 +195,8 @@
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
-            "    GenericClass<A, B> instance = new GenericClass<A, B>();",
-            "    genericClassMembersInjector.injectMembers(instance);",
-            "    return instance;",
+            "    return MembersInjectors.injectMembers(",
+            "        genericClassMembersInjector, new GenericClass<A, B>());",
             "  }",
             "",
             "  public static <A, B> Factory<GenericClass<A, B>> create(",
@@ -290,7 +290,7 @@
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
-  
+
   @Test public void boundedGenerics() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
         "package test;",
@@ -381,7 +381,7 @@
         "  private final Provider<B> qbProvider;",
         "",
         "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,", 
+        "      Provider<A> qaProvider,",
         "      Provider<String> sAndS2AndPsAndLsProvider,",
         "      Provider<String> qsProvider,",
         "      Provider<B> bAndB2AndPbAndLbProvider,",
@@ -414,7 +414,7 @@
         "      qsProvider.get(),",
         "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
         "      bAndB2AndPbAndLbProvider.get(),",
-        "      bAndB2AndPbAndLbProvider.get(),", 
+        "      bAndB2AndPbAndLbProvider.get(),",
         "      bAndB2AndPbAndLbProvider,",
         "      qbProvider.get(),",
         "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
@@ -422,7 +422,7 @@
         "",
         "  public static <A, B> Factory<GenericClass<A, B>> create(",
         "      Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,", 
+        "      Provider<A> qaProvider,",
         "      Provider<String> sAndS2AndPsAndLsProvider,",
         "      Provider<String> qsProvider,",
         "      Provider<B> bAndB2AndPbAndLbProvider,",
@@ -537,7 +537,7 @@
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
-  
+
   @Test public void privateInjectFieldWarning() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
         "package test;",
@@ -552,7 +552,7 @@
         .processedWith(new ComponentProcessor())
         .compilesWithoutError(); // TODO: Verify warning message when supported
   }
-  
+
   @Test public void staticInjectFieldError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
         "package test;",
@@ -567,7 +567,7 @@
         .failsToCompile()
         .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);
   }
-  
+
   @Test public void staticInjectFieldWarning() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
         "package test;",
@@ -627,7 +627,7 @@
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
-  
+
   @Test public void privateInjectMethodWarning() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
         "package test;",
@@ -642,7 +642,7 @@
         .processedWith(new ComponentProcessor())
         .compilesWithoutError(); // TODO: Verify warning message when supported
   }
-  
+
   @Test public void staticInjectMethodError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
         "package test;",
@@ -657,7 +657,7 @@
         .failsToCompile()
         .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);
   }
-  
+
   @Test public void staticInjectMethodWarning() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
         "package test;",
@@ -859,6 +859,7 @@
             "",
             "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
+            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -879,9 +880,8 @@
             "  }",
             "",
             "  @Override public AllInjections get() {",
-            "    AllInjections instance = new AllInjections(sProvider.get());",
-            "    allInjectionsMembersInjector.injectMembers(instance);",
-            "    return instance;",
+            "    return MembersInjectors.injectMembers(",
+            "        allInjectionsMembersInjector, new AllInjections(sProvider.get()));",
             "  }",
             "",
             "  public static Factory<AllInjections> create(",
@@ -916,6 +916,7 @@
             "",
             "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
+            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
@@ -929,9 +930,7 @@
             "  }",
             "",
             "  @Override public B get() {",
-            "    B instance = new B();",
-            "    bMembersInjector.injectMembers(instance);",
-            "    return instance;",
+            "    return MembersInjectors.injectMembers(bMembersInjector, new B());",
             "  }",
             "",
             "  public static Factory<B> create(MembersInjector<B> bMembersInjector) {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 1d70c289d..058c25bf2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -116,6 +116,7 @@ public void mapBindingsWithEnumKey() {
             "package test;",
             "",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -176,18 +177,12 @@ public void mapBindingsWithEnumKey() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
@@ -276,6 +271,7 @@ public void mapBindingsWithStringKey() {
             "package test;",
             "",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -336,18 +332,12 @@ public void mapBindingsWithStringKey() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
@@ -445,6 +435,7 @@ public void mapBindingsWithWrappedKey() {
             "package test;",
             "",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -507,18 +498,12 @@ public void mapBindingsWithWrappedKey() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
@@ -619,6 +604,7 @@ public void mapBindingsWithNonProviderValue() {
             "",
             "import dagger.internal.MapFactory;",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -682,18 +668,12 @@ public void mapBindingsWithNonProviderValue() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
@@ -743,6 +723,7 @@ public void injectMapWithoutMapBinding() {
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
+        "import dagger.internal.Preconditions;",
         "import java.util.Map;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -788,10 +769,7 @@ public void injectMapWithoutMapBinding() {
         "    }",
         "",
         "    public Builder mapModule(MapModule mapModule) {",
-        "      if (mapModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.mapModule = mapModule;",
+        "      this.mapModule = Preconditions.checkNotNull(mapModule);",
         "      return this;",
         "    }",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index b70f0479c..1fbd7fd11 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -60,6 +60,8 @@ public void mapKeyCreatorFile() {
             "",
             GENERATED_ANNOTATION,
             "public final class PathKeyCreator {",
+            "  private PathKeyCreator() {}",
+            "",
             "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
             "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
@@ -106,6 +108,8 @@ public void nestedMapKeyCreatorFile() {
             "",
             GENERATED_ANNOTATION,
             "public final class Container$PathKeyCreator {",
+            "  private Container$PathKeyCreator() {}",
+            "",
             "  @AutoAnnotation",
             "  public static Container.PathKey createPathKey("
                 + "PathEnum value, String relativePath) {",
@@ -205,6 +209,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "package test;",
             "",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -267,18 +272,12 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
@@ -383,6 +382,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "package test;",
             "",
             "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -445,18 +445,12 @@ public void mapKeyComponentFileWithDefaultField() {
             "    }",
             "",
             "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      if (mapModuleOne == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleOne = mapModuleOne;",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
             "      return this;",
             "    }",
             "",
             "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      if (mapModuleTwo == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.mapModuleTwo = mapModuleTwo;",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
             "      return this;",
             "    }",
             "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index cda08be2d..39d439196 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -372,6 +372,7 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
@@ -384,11 +385,7 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public String get() {",
-        "    String provided = module.provideString();",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
+        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
         "  }",
         "",
         "  public static Factory<String> create(TestModule module) {",
@@ -541,6 +538,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "import dagger.MembersInjector;",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import java.util.List;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -568,12 +566,9 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    List<Object> provided =",
-        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
+        "    return Preconditions.checkNotNull(",
+        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
+        "        " + NPE_LITERAL + ");",
         "  }",
         "",
         "  public static Factory<List<Object>> create(",
@@ -711,6 +706,7 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
@@ -724,11 +720,7 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    Set<String> provided = module.provideStrings();",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
+        "    return Preconditions.checkNotNull(module.provideStrings(), " + NPE_LITERAL + ");",
         "  }",
         "",
         "  public static Factory<Set<String>> create(TestModule module) {",
@@ -999,6 +991,7 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.List;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -1019,11 +1012,8 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public List<B> get() {  ",
-            "    List<B> provided = module.provideListB(bProvider.get());",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(" + NPE_LITERAL + ");",
-            "    }",
-            "    return provided;",
+            "    return Preconditions.checkNotNull(module.provideListB(bProvider.get()),",
+            "        " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
@@ -1072,6 +1062,7 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -1091,11 +1082,8 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public B get() {  ",
-            "    B provided = module.provideBEntry(bProvider.get());",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(" + NPE_LITERAL + ");",
-            "    }",
-            "    return provided;",
+            "    return Preconditions.checkNotNull(module.provideBEntry(bProvider.get()), ",
+            "        " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
@@ -1108,6 +1096,7 @@ public void genericSubclassedModule() {
         "package test;",
         "",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
@@ -1121,11 +1110,7 @@ public void genericSubclassedModule() {
         "",
         "  @Override",
         "  public Number get() {  ",
-        "    Number provided = module.provideNumber();",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
+        "    return Preconditions.checkNotNull(module.provideNumber(), " + NPE_LITERAL + ");",
         "  }",
         "",
         "  public static Factory<Number> create(ChildNumberModule module) {",
@@ -1137,6 +1122,7 @@ public void genericSubclassedModule() {
         "package test;",
         "",
         "import dagger.internal.Factory;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
@@ -1151,11 +1137,7 @@ public void genericSubclassedModule() {
         "",
         "  @Override",
         "  public Integer get() {  ",
-        "    Integer provided = module.provideInteger();",
-        "    if (provided == null) {",
-        "      throw new NullPointerException(" + NPE_LITERAL + ");",
-        "    }",
-        "    return provided;",
+        "    return Preconditions.checkNotNull(module.provideInteger(), " + NPE_LITERAL + ");",
         "  }",
         "",
         "  public static Factory<Integer> create(ChildIntegerModule module) {",
@@ -1204,6 +1186,7 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "",
@@ -1214,11 +1197,8 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Map<String, Number> get() {",
-            "    Map<String, Number> provided = ParameterizedModule.provideMapStringNumber();",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(" + NPE_LITERAL + ");",
-            "    }",
-            "    return provided;",
+            "    return Preconditions.checkNotNull(ParameterizedModule.provideMapStringNumber(),",
+            "        " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static Factory<Map<String, Number>> create() {",
@@ -1232,6 +1212,7 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
@@ -1241,11 +1222,8 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Object get() {",
-            "    Object provided = ParameterizedModule.provideNonGenericType();",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(" + NPE_LITERAL + ");",
-            "    }",
-            "    return provided;",
+            "    return Preconditions.checkNotNull(ParameterizedModule.provideNonGenericType(),",
+            "        " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static Factory<Object> create() {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 41a40a88c..4ef4f8100 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -480,6 +480,25 @@ public void publicModuleNonPublicIncludes() {
         .in(publicModuleFile).onLine(8);
   }
 
+  @Test public void argumentNamedModuleCompiles() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(int module) {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
   @Test public void singleProducesMethodNoArgsFuture() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -513,20 +532,20 @@ public void publicModuleNonPublicIncludes() {
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
-            "  private final Executor executor;",
+            "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
-            "      Executor executor,",
+            "      Provider<Executor> executorProvider,",
             "      Provider<ProductionComponentMonitor> monitorProvider) {",
             "    super(",
             "        monitorProvider,",
             "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
             "    assert module != null;",
             "    this.module = module;",
-            "    assert executor != null;",
-            "    this.executor = executor;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
             "    assert monitorProvider != null;",
             "    this.monitorProvider = monitorProvider;",
             "  }",
@@ -539,12 +558,12 @@ public void publicModuleNonPublicIncludes() {
             "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
             "          monitor.methodStarting();",
             "          try {",
-            "            return module.produceString();",
+            "            return TestModule_ProduceStringFactory.this.module.produceString();",
             "          } finally {",
             "            monitor.methodFinished();",
             "          }",
             "        }",
-            "      }, executor);",
+            "      }, executorProvider.get());",
             "  }",
             "}");
     assertAbout(javaSource())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index c645056a5..9090fb58e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -23,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -86,6 +88,125 @@
         .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
+  @Test
+  public void builderWithExecutorAndProvidedExecutor() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides @Production Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}");
+    JavaFileObject producerModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class SimpleModule {",
+            "  @Produces String str() {",
+            "    return \"\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
+            "interface SimpleComponent {",
+            "  ListenableFuture<String> str();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    Builder executor(Executor executor);",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is bound multiple times");
+  }
+
+  @Test
+  public void dependsOnProductionExecutor() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides @Production Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}");
+    JavaFileObject producerModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProducerModule",
+            "final class SimpleModule {",
+            "  @Produces String str(@Production Executor executor) {",
+            "    return \"\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
+            "interface SimpleComponent {",
+            "  ListenableFuture<String> str();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("may not depend on the production executor");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
@@ -132,6 +253,8 @@
             "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.ScopedProvider;",
             "import dagger.internal.SetFactory;",
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
@@ -144,7 +267,9 @@
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Executor> simpleComponentProvider;",
+            "  private Provider<Executor> executorProvider;",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider2;",
             "  private Provider<Set<ProductionComponentMonitor.Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
@@ -161,7 +286,13 @@
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = ",
+            "    this.simpleComponentProvider =",
+            "        InstanceFactory.<Executor>create(builder.executor);",
+            "     this.executorProvider =",
+            "         ScopedProvider.create(",
+            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+            "                 .create(simpleComponentProvider));",
+            "    this.simpleComponentProvider2 =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.setOfFactoryProvider = SetFactory.create(",
             "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
@@ -169,13 +300,13 @@
             "    this.monitorProvider =",
             "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "            builder.testClass$SimpleComponent_MonitoringModule,",
-            "            simpleComponentProvider,",
+            "            simpleComponentProvider2,",
             "            setOfFactoryProvider);",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
             "    this.aProducer = new TestClass$AModule_AFactory(",
             "        builder.aModule,",
-            "        builder.executor,",
+            "        executorProvider,",
             "        monitorProvider,",
             "        Producers.producerFromProvider(bProvider));",
             "  }",
@@ -214,37 +345,33 @@
             "    }",
             "",
             "    public Builder aModule(TestClass.AModule aModule) {",
-            "      if (aModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.aModule = aModule;",
+            "      this.aModule = Preconditions.checkNotNull(aModule);",
             "      return this;",
             "    }",
             "",
             "    public Builder bModule(TestClass.BModule bModule) {",
-            "      if (bModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.bModule = bModule;",
+            "      this.bModule = Preconditions.checkNotNull(bModule);",
             "      return this;",
             "    }",
             "",
             "    public Builder testClass$SimpleComponent_MonitoringModule(",
             "        TestClass$SimpleComponent_MonitoringModule",
             "        testClass$SimpleComponent_MonitoringModule) {",
-            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
-            "        throw new NullPointerException();",
-            "      }",
             "      this.testClass$SimpleComponent_MonitoringModule =",
-            "          testClass$SimpleComponent_MonitoringModule;",
+            "          Preconditions.checkNotNull(testClass$SimpleComponent_MonitoringModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testClass$SimpleComponent_ProductionExecutorModule(",
+            "        TestClass$SimpleComponent_ProductionExecutorModule",
+            "        testClass$SimpleComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testClass$SimpleComponent_ProductionExecutorModule);",
             "      return this;",
             "    }",
             "",
             "    public Builder executor(Executor executor) {",
-            "      if (executor == null) {",
-            "        throw new NullPointerException();",
-            "      }",
-            "      this.executor = executor;",
+            "      this.executor = Preconditions.checkNotNull(executor);",
             "      return this;",
             "    }",
             "  }",
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index e4c662fc5..ae438514a 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -72,6 +72,7 @@
       "test.DaggerPrimitiveComponent",
       "package test;",
       "",
+      "import dagger.internal.Preconditions;",
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
@@ -125,10 +126,7 @@
       "    }",
       "",
       "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
-      "      if (primitiveModule == null) {",
-      "        throw new NullPointerException();",
-      "      }",
-      "      this.primitiveModule = primitiveModule;",
+      "      this.primitiveModule = Preconditions.checkNotNull(primitiveModule);",
       "      return this;",
       "    }",
       "  }",
diff --git a/core/pom.xml b/core/pom.xml
index eab9dd8b5..6baee3510 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -80,6 +80,18 @@
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
         </configuration>
       </plugin>
+      <plugin>
+        <artifactId>maven-source-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>attach-sources</id>
+            <phase>generate-resources</phase>
+            <goals>
+              <goal>jar-no-fork</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <artifactId>maven-jar-plugin</artifactId>
         <executions>
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 741a54a2d..7f7c591a7 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -25,9 +25,22 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to its returned value. The object graph will
- * pass dependencies to the method as parameters.
+ * Annotates methods of a {@linkplain Module module} to create a provider method binding. The
+ * method's return type is bound to its returned value. The {@linkplain Component component}
+ * implementation will pass dependencies to the method as parameters.
+ *
+ * <h3>Nullability
+ *
+ * <p>Dagger forbids injecting {@code null} by default. Component implemenations that invoke
+ * {@code @Provides} methods that return {@code null} will throw a {@link NullPointerException}
+ * immediately thereafter. {@code @Provides} methods may opt into allowing {@code null} by
+ * annotating the method with any {@code @Nullable} annotation like
+ * {@code javax.annotation.Nullable} or {@code android.support.annotation.Nullable}.
+ *
+ * <p>If a {@code @Provides} method is marked {@code @Nullable}, Dagger will <em>only</em>
+ * allow injection into sites that are marked {@code @Nullable} as well. A component that
+ * attempts to pair a {@code @Nullable} provision with a non-{@code @Nullable} injection site
+ * will fail to compile.
  *
  * @author Bob Lee
  */
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
index ee4c7b4cf..5be2b8ee2 100644
--- a/core/src/main/java/dagger/internal/MembersInjectors.java
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -18,6 +18,8 @@
 import dagger.MembersInjector;
 import javax.inject.Inject;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 /**
  * Basic {@link MembersInjector} implementations used by the framework.
  *
@@ -25,6 +27,16 @@
  * @since 2.0
  */
 public final class MembersInjectors {
+  /**
+   * Injects members into {@code instance} using {@code membersInjector}.  This method is a
+   * convenience for cases in which you would want to chain members injection, but can't because
+   * {@link MembersInjector#injectMembers} returns {@code void}.
+   */
+  public static <T> T injectMembers(MembersInjector<T> membersInjector, T instance) {
+    membersInjector.injectMembers(instance);
+    return instance;
+  }
+
   /**
    * Returns a {@link MembersInjector} implementation that injects no members
    *
@@ -40,9 +52,7 @@
     INSTANCE;
 
     @Override public void injectMembers(Object instance) {
-      if (instance == null) {
-        throw new NullPointerException();
-      }
+      checkNotNull(instance);
     }
   }
 
@@ -56,7 +66,7 @@
    */
   @SuppressWarnings("unchecked")
   public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
-    return (MembersInjector<T>) delegate;
+    return (MembersInjector<T>) checkNotNull(delegate);
   }
 
   private MembersInjectors() {}
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
new file mode 100644
index 000000000..1877cd0eb
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * An adaptation of Guava's {@code com.google.common.base.Preconditions} that is specially tailored
+ * to support checks applied in Dagger's generated code.
+ */
+public final class Preconditions {
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   */
+  public static <T> T checkNotNull(T reference) {
+    if (reference == null) {
+      throw new NullPointerException();
+    }
+    return reference;
+  }
+
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessage the exception message to use if the check fails
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   */
+  public static <T> T checkNotNull(T reference, String errorMessage) {
+    if (reference == null) {
+      throw new NullPointerException(errorMessage);
+    }
+    return reference;
+  }
+
+  private Preconditions() {}
+}
+
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 9b73e79db..90dbb23eb 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -23,6 +23,7 @@
 import javax.inject.Provider;
 
 import static dagger.internal.Collections.newLinkedHashSetWithExpectedSize;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
 /**
@@ -40,6 +41,19 @@
   private static final String ARGUMENTS_MUST_BE_NON_NULL =
       "SetFactory.create() requires its arguments to be non-null";
 
+  private static final Factory<Set<Object>> EMPTY_FACTORY =
+      new Factory<Set<Object>>() {
+        @Override
+        public Set<Object> get() {
+          return emptySet();
+        }
+      };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Factory<Set<T>> create() {
+    return (Factory<Set<T>>) (Factory) EMPTY_FACTORY;
+  }
+
   /**
    * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
    * result.
@@ -48,7 +62,7 @@
     assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
     return factory;
   }
-  
+
   /**
    * Returns a new factory that creates {@link Set} instances that form the union of the given
    * {@link Provider} instances.  Callers must not modify the providers array after invoking this
@@ -94,7 +108,7 @@ private SetFactory(List<Provider<Set<T>>> contributingProviders) {
     int size = 0;
 
     // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
-    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is 
+    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
     List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
diff --git a/gwt/pom.xml b/gwt/pom.xml
new file mode 100644
index 000000000..5629c581e
--- /dev/null
+++ b/gwt/pom.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2015 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>dagger-gwt</artifactId>
+  <name>Dagger GWT integration</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+      <classifier>sources</classifier>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!--
+        Include JSR 330 sources in dagger-gwt to avoid implicit
+        compilation warnings in downstream projects.
+      -->
+      <plugin>
+        <artifactId>maven-dependency-plugin</artifactId>
+        <version>2.10</version>
+        <executions>
+          <execution>
+            <id>unpack-jsr330-sources</id>
+            <goals>
+              <goal>unpack</goal>
+            </goals>
+            <configuration>
+              <artifactItems>
+                <artifactItem>
+                  <groupId>javax.inject</groupId>
+                  <artifactId>javax.inject</artifactId>
+                  <version>${javax.inject.version}</version>
+                  <type>java-source</type>
+                  <overWrite>true</overWrite>
+                  <outputDirectory>${project.build.outputDirectory}/dagger/super/</outputDirectory>
+                </artifactItem>
+              </artifactItems>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+
+</project>
diff --git a/gwt/src/main/resources/dagger/Dagger.gwt.xml b/gwt/src/main/resources/dagger/Dagger.gwt.xml
new file mode 100644
index 000000000..f81c5c00c
--- /dev/null
+++ b/gwt/src/main/resources/dagger/Dagger.gwt.xml
@@ -0,0 +1,19 @@
+<!--
+ Copyright (C) 2015 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<module>
+  <source path=""/>
+  <super-source path="super"/>
+</module>
diff --git a/pom.xml b/pom.xml
index 18bb74aca..851aaea16 100644
--- a/pom.xml
+++ b/pom.xml
@@ -34,6 +34,7 @@
   <modules>
     <module>compiler</module>
     <module>core</module>
+    <module>gwt</module>
     <!-- examples are handled in a default profile (see below) -->
     <module>producers</module>
   </modules>
@@ -239,6 +240,7 @@
       <modules>
         <module>core</module>
         <module>compiler</module>
+        <module>gwt</module>
         <module>examples</module>
         <module>producers</module>
       </modules>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index db5c133ff..ffc42316d 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -18,6 +18,7 @@
 import com.google.common.base.Objects;
 import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
+import javax.annotation.CheckReturnValue;
 import javax.annotation.Nullable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -43,6 +44,7 @@
  * @author Jesse Beder
  */
 @Beta
+@CheckReturnValue
 public abstract class Produced<T> {
   /**
    * Returns the result of a production.
diff --git a/producers/src/main/java/dagger/producers/Production.java b/producers/src/main/java/dagger/producers/Production.java
new file mode 100644
index 000000000..2ecdec809
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Production.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Qualifies a type that will be provided to the framework for use internally.
+ *
+ * <p>The only type that may be so qualified is {@link java.util.concurrent.Executor}. In this case,
+ * the resulting executor is used to schedule {@linkplain Produces producer methods} in a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@Beta
+public @interface Production {}
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index f3f7db027..ec56d1576 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -64,6 +64,13 @@
  * {@link com.google.common.util.concurrent.Futures#transform}.
  * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
+ * <h2>Executor</h2>
+ *
+ * <p>The component must include a binding for <code>{@literal @}Production Executor</code>;
+ * this binding will be called exactly once, and the provided executor will be used by the framework
+ * to schedule all producer methods (for this component, and any {@link ProductionSubcomponent} it
+ * may have.
+ *
  * @author Jesse Beder
  */
 @Documented
@@ -90,8 +97,6 @@
    *      (This is typically the {@code build()} method.)
    * <li> All other abstract methods must take a single argument and must return void,
    *      the builder type, or a supertype of the builder.
-   * <li> There <b>must</b> be an abstract method whose parameter is
-   *      {@link java.util.concurrent.Executor}.
    * <li> Each component dependency <b>must</b> have an abstract setter method.
    * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
    *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
@@ -109,7 +114,6 @@
    *   {@literal @}ProductionComponent.Builder
    *   interface Builder {
    *     MyComponent build();
-   *     Builder executor(Executor executor);
    *     Builder backendModule(BackendModule bm);
    *     Builder frontendModule(FrontendModule fm);
    *   }
diff --git a/producers/src/main/java/dagger/producers/ProductionScope.java b/producers/src/main/java/dagger/producers/ProductionScope.java
new file mode 100644
index 000000000..8e3a405d8
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionScope.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scope annotation for provision bindings that are tied to the lifetime of a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Scope
+public @interface ProductionScope {}
diff --git a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
index 2832fcf65..1eecca1b3 100644
--- a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
@@ -30,6 +30,10 @@
  * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a
  * subcomponent with a parent are described in the documentation for {@link Component}.
  *
+ * <p>The executor for a production subcomponent is supplied by binding
+ * <code>{@literal @}Production Executor</code>, similar to {@link ProductionComponent}. Note that
+ * this binding may be in an ancestor component.
+ *
  * @author Jesse Beder
  */
 @Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
diff --git a/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
new file mode 100644
index 000000000..b5cfa927a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Qualifies a type that will be used as an internal implementation detail in the framework.
+ *
+ * <p>This is only intended to be used by the framework. It is the internal counterpart to
+ * {@link dagger.producers.Production}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@Beta
+public @interface ProductionImplementation {}
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index e51bcad42..2862f6c3c 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -36,6 +36,10 @@
  * @since 2.0
  */
 public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
+  public static <T> Producer<Set<T>> create() {
+    return SetProducer.create();
+  }
+
   /**
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 5b3c0902d..271d31b4d 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -34,6 +34,27 @@
  * @since 2.0
  */
 public final class SetProducer<T> extends AbstractProducer<Set<T>> {
+  private static final Producer<Set<Object>> EMPTY_PRODUCER =
+      new Producer<Set<Object>>() {
+        @Override
+        public ListenableFuture<Set<Object>> get() {
+          return Futures.<Set<Object>>immediateFuture(ImmutableSet.<Object>of());
+        }
+      };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Producer<Set<T>> create() {
+    return (Producer<Set<T>>) (Producer) EMPTY_PRODUCER;
+  }
+
+  /**
+   * Returns the supplied producer.  If there's just one producer, there's no need to wrap it or its
+   * result.
+   */
+  public static <T> Producer<Set<T>> create(Producer<Set<T>> producer) {
+    return producer;
+  }
+
   /**
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index e2707b342..c654b64c6 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -70,7 +70,7 @@
 
   private <T> ExecutionException getProducedException(Produced<T> produced) {
     try {
-      produced.get();
+      T unused = produced.get();
       throw new IllegalArgumentException("produced did not throw");
     } catch (ExecutionException e) {
       return e;
