diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a2bdf2fe9..b77283674 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -632,7 +632,8 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         if (binding.scope().isPresent() && binding.scope().get().equals(reusableScope(elements))) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
             // If a @Reusable binding was resolved in an ancestor, use that component.
-            if (requestResolver.resolvedBindings.containsKey(binding.bindingKey())) {
+            if (requestResolver.resolvedBindings.containsKey(
+                BindingKey.contribution(binding.key()))) {
               return Optional.of(requestResolver);
             }
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 34a2786a1..3e8c642a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1055,7 +1055,8 @@ private void reportDuplicateBindings(DependencyPath path) {
         Iterable<ContributionBinding> duplicateBindings) {
       ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
       for (ContributionBinding binding : duplicateBindings) {
-        ResolvedBindings resolvedBindings = subject.resolvedBindings().get(binding.bindingKey());
+        ResolvedBindings resolvedBindings =
+            subject.resolvedBindings().get(BindingKey.contribution(binding.key()));
         owningComponentsBuilder.addAll(
             resolvedBindings.allContributionBindings().inverse().get(binding));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index c9114f733..0da899abe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -47,7 +47,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 
@@ -206,10 +205,6 @@ static Kind forMultibindingRequest(DependencyRequest request) {
    */
   protected abstract Kind bindingKind();
 
-  BindingKey bindingKey() {
-    return BindingKey.contribution(key());
-  }
-
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
@@ -225,11 +220,10 @@ BindingKey bindingKey() {
   /**
    * Returns the {@link FactoryCreationStrategy} appropriate for a binding.
    *
-   * <p>Delegate bindings
-   * use the {@link FactoryCreationStrategy#DELEGATE} strategy.
+   * <p>Delegate bindings use the {@link FactoryCreationStrategy#DELEGATE} strategy.
    *
-   * <p>Bindings without dependencies that don't require a module instance use the
-   * {@link FactoryCreationStrategy#ENUM_INSTANCE} strategy.
+   * <p>Bindings without dependencies that don't require a module instance use the {@link
+   * FactoryCreationStrategy#ENUM_INSTANCE} strategy.
    *
    * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 0cf6c5351..31de3a1a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.common.AnnotationMirrors;
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index a524f207a..939f15ff1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.common.util.concurrent.AsyncFunction;
@@ -91,13 +92,16 @@
   static final ClassName VOID_CLASS = ClassName.get(Void.class);
 
   static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.get(
-          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+      ParameterizedTypeName.get(Set.class, ProductionComponentMonitor.Factory.class);
 
   static ParameterizedTypeName listOf(TypeName typeName) {
     return ParameterizedTypeName.get(LIST, typeName);
   }
 
+  static ParameterizedTypeName setOf(TypeName elementType) {
+    return ParameterizedTypeName.get(SET, elementType);
+  }
+
   static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
     return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
   }
