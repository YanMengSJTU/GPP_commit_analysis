diff --git a/compiler/pom.xml b/compiler/pom.xml
index d41306c8d..cd68d9c2a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -92,11 +92,6 @@
       <artifactId>guava-testlib</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>javapoet</artifactId>
-      <version>1.4.0</version>
-    </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
       <artifactId>mockito-core</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
deleted file mode 100644
index db7b9cf2f..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.squareup.javapoet.AnnotationSpec;
-
-final class AnnotationSpecs {
-
-  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
-  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
-
-  private static AnnotationSpec suppressWarnings(String value) {
-    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
-  }
-
-  private AnnotationSpecs() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
deleted file mode 100644
index 66cfdd59c..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.squareup.javapoet.CodeBlock;
-import java.util.Iterator;
-
-final class CodeBlocks {
-
-  /** Shorthand for a {@link CodeBlock} with a single format and an argument list. */
-  static CodeBlock format(String format, Object... args) {
-    return CodeBlock.builder().add(format, args).build();
-  }
-
-  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
-    return join(codeBlocks, ", ");
-  }
-
-  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
-    CodeBlock.Builder builder = CodeBlock.builder();
-    Iterator<CodeBlock> iterator = codeBlocks.iterator();
-    while (iterator.hasNext()) {
-      builder.add(iterator.next());
-      if (iterator.hasNext()) {
-        builder.add(delimiter);
-      }
-    }
-    return builder.build();
-  }
-
-  private CodeBlocks() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 379a60236..304df6c2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -19,6 +19,8 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
 import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -32,7 +34,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends JavaWriterSourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d9d7dcff0..65419786a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -70,7 +70,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends JavaWriterSourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index baad3b393..13950bc9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -23,7 +23,6 @@
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -42,19 +41,13 @@ static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, St
     ParameterizedTypeName frameworkType =
         ParameterizedTypeName.create(
             ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
-    com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType =
-        com.squareup.javapoet.ParameterizedTypeName.get(
-            com.squareup.javapoet.ClassName.get(frameworkClass),
-            com.squareup.javapoet.TypeName.get(key.type()));
     return new AutoValue_FrameworkField(
-        javapoetFrameworkType, frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
-    TypeMirror type = MapType.from(key.type()).valueType();
     return new AutoValue_FrameworkField(
-        (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
-        (ParameterizedTypeName) TypeNames.forTypeMirror(type),
+        (ParameterizedTypeName) TypeNames.forTypeMirror(MapType.from(key.type()).valueType()),
         name);
   }
 
@@ -119,7 +112,6 @@ public String visitType(TypeElement e, Void p) {
         }
       };
 
-  abstract com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType();
   abstract ParameterizedTypeName frameworkType();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
deleted file mode 100644
index 745fe7b79..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.Iterables;
-import com.google.common.io.CharSink;
-import com.google.common.io.CharSource;
-import com.google.googlejavaformat.java.Formatter;
-import com.google.googlejavaformat.java.FormatterException;
-import com.squareup.javapoet.AnnotationSpec;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.JavaFile;
-import com.squareup.javapoet.TypeSpec;
-import java.io.IOException;
-import java.io.Writer;
-import javax.annotation.Generated;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-import javax.tools.JavaFileObject;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
- *
- * <p>This differs from {@link JavaWriterSourceFileGenerator} only in that it uses JavaPoet for
- * constructing the source code model. It is intended for this to take on all usages of JavaWriter.
- *
- * @param <T> The input type from which source is to be generated.
- */
-abstract class JavaPoetSourceFileGenerator<T> implements SourceFileGenerator<T> {
-  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
-
-  private static final AnnotationSpec GENERATED =
-      AnnotationSpec.builder(Generated.class)
-          .addMember("value", "$S", ComponentProcessor.class.getName())
-          .addMember("comments", "$S", GENERATED_COMMENTS)
-          .build();
-
-  private final Filer filer;
-  private final boolean generatedAnnotationAvailable;
-
-  JavaPoetSourceFileGenerator(Filer filer, Elements elements) {
-    this.filer = checkNotNull(filer);
-    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
-  }
-
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    try {
-      Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
-      if (!type.isPresent()) {
-        return;
-      }
-      JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
-
-      final JavaFileObject sourceFile = filer.createSourceFile(
-          generatedTypeName.toString(),
-          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));
-      try {
-        new Formatter().formatSource(
-            CharSource.wrap(javaFile.toString()),
-            new CharSink() {
-              @Override public Writer openStream() throws IOException {
-                return sourceFile.openWriter();
-              }
-            });
-      } catch (FormatterException e) {
-        throw new SourceFileGenerationException(
-            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(
-          Optional.<ClassName>absent(), e, getElementForErrorReporting(input));
-    }
-  }
-
-  private JavaFile buildJavaFile(
-      ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
-    if (generatedAnnotationAvailable) {
-      typeSpecBuilder.addAnnotation(GENERATED);
-    }
-    JavaFile.Builder javaFileBuilder =
-        JavaFile.builder(generatedTypeName.packageName(), typeSpecBuilder.build())
-            .skipJavaLangImports(true);
-    if (!generatedAnnotationAvailable) {
-      javaFileBuilder.addFileComment(
-          "Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
-    }
-    return javaFileBuilder.build();
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
-   * Optional#absent()} if no file should be generated.
-   */
-  // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.
-  // consider renaming to something like typeBuilder() which conveys the mutability of the result
-  abstract Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
deleted file mode 100644
index e43b1a5c5..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.TypeWriter;
-import java.io.IOException;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
- *
- * @param <T> The input type from which source is to be generated.
- * @author Gregory Kick
- * @since 2.0
- */
-abstract class JavaWriterSourceFileGenerator<T> implements SourceFileGenerator<T> {
-  private final Filer filer;
-  private final boolean generatedAnnotationAvailable;
-
-  JavaWriterSourceFileGenerator(Filer filer, Elements elements) {
-    this.filer = checkNotNull(filer);
-    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
-  }
-
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements =
-        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
-    try {
-      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
-      for (JavaWriter javaWriter : writers) {
-        javaWriter.markGenerated(generatedAnnotationAvailable);
-        try {
-          javaWriter.file(filer, originatingElements);
-        } catch (IOException e) {
-          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
-              e, getElementForErrorReporting(input));
-        }
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
-          getElementForErrorReporting(input));
-    }
-  }
-
-  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
-    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
-      @Override public ClassName apply(TypeWriter input) {
-        return input.name();
-      }
-    });
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Implementations should return {@link Element} instances from which the source is to be
-   * generated.
-   */
-  abstract Iterable<? extends Element> getOriginatingElements(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   * Returns a set of writers to be generated for {@code T} input.
-   */
-  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 1ef674f6b..432f8f578 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -53,7 +53,7 @@
  *
  * @since 2.0
  */
-final class MapKeyGenerator extends JavaWriterSourceFileGenerator<MapKeyCreatorSpecification> {
+final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
 
   /**
    * Specification of the {@link MapKey} annotation and the annotation type to generate.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1c9336e96..46d913437 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -17,28 +17,36 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeSpec;
-import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Modifiable;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
+import dagger.internal.codegen.writer.VariableWriter;
+import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Producer;
-import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
+import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
@@ -53,12 +61,10 @@
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -70,7 +76,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
@@ -81,70 +87,74 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return javapoetMembersInjectorNameForType(binding.bindingElement());
+    return membersInjectorNameForType(binding.bindingElement());
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(
+      MembersInjectionBinding binding) {
+    return FluentIterable.from(binding.injectionSites())
+        .transform(new Function<InjectionSite, Element>() {
+          @Override public Element apply(InjectionSite injectionSite) {
+            return injectionSite.element();
+          }
+        })
+        .toSet();
   }
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
-
+  
   @Override
-  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
     // Empty members injection bindings are special and don't need source files.
     if (binding.injectionSites().isEmpty()) {
-      return Optional.absent();
+      return ImmutableSet.of();
     }
+    Set<String> delegateMethods = new HashSet<>();
+
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
+    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+
+    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
     List<TypeVariableName> typeParameters = Lists.newArrayList();
     for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-      typeParameters.add(TypeVariableName.get(typeParameter));
+      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
     }
-
-    TypeSpec.Builder injectorTypeBuilder =
-        TypeSpec.classBuilder(generatedTypeName.simpleName())
-            .addModifiers(PUBLIC, FINAL)
-            .addTypeVariables(typeParameters);
-
-    TypeName injectedTypeName = TypeName.get(binding.key().type());
+    injectorWriter.addTypeParameters(typeParameters);
+    injectorWriter.addModifiers(PUBLIC, FINAL);
     TypeName implementedType =
-        ParameterizedTypeName.get(ClassName.get(MembersInjector.class), injectedTypeName);
-    injectorTypeBuilder.addSuperinterface(implementedType);
-
-    MethodSpec.Builder injectMembersBuilder =
-        MethodSpec.methodBuilder("injectMembers")
-            .returns(TypeName.VOID)
-            .addModifiers(PUBLIC)
-            .addAnnotation(Override.class)
-            .addParameter(injectedTypeName, "instance")
-            .addCode("if (instance == null) {")
-            .addStatement(
-                "throw new $T($S)",
-                NullPointerException.class,
-                "Cannot inject members into a null reference")
-            .addCode("}");
+        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
+    injectorWriter.addImplementedType(implementedType);
+
+    ConstructorWriter constructorWriter = injectorWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+    MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
+    injectMembersWriter.addModifiers(PUBLIC);
+    injectMembersWriter.annotate(Override.class);
+    injectMembersWriter.addParameter(injectedTypeName, "instance");
+    injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
+        "if (instance == null) {",
+        "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "}"));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
-    ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
-
-    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(PUBLIC);
-
+    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
+        ImmutableMap.builder();
+    
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
     // (Otherwise they may have visibility problems referring to the types.)
-    MethodSpec.Builder createMethodBuilder =
-        MethodSpec.methodBuilder("create")
-            .returns(implementedType)
-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
-            .addTypeVariables(typeParameters);
-
-    createMethodBuilder.addCode(
-        "return new $T(", javapoetParameterizedGeneratedTypeNameForBinding(binding));
-    ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
+    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
+    createMethodWriter.addTypeParameters(typeParameters);
+    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
 
     boolean usesRawFrameworkTypes = false;
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
@@ -156,69 +166,67 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       boolean useRawFrameworkType =
           !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
 
-      String fieldName = bindingField.name();
-      TypeName fieldType =
-          useRawFrameworkType
-              ? bindingField.javapoetFrameworkType().rawType
-              : bindingField.javapoetFrameworkType();
-      FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
-      ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
+      FieldWriter field =
+          injectorWriter.addField(
+              useRawFrameworkType
+                  ? bindingField.frameworkType().type()
+                  : bindingField.frameworkType(),
+              bindingField.name());
+
+      field.addModifiers(PRIVATE, FINAL);
+      VariableWriter constructorParameter =
+          constructorWriter.addParameter(field.type(), field.name());
+      VariableWriter createMethodParameter =
+          createMethodWriter.addParameter(constructorParameter.type(), constructorParameter.name());
 
       // If we're using the raw type for the field, then suppress the injectMembers method's
       // unchecked-type warning and the field's and the constructor and create-method's
       // parameters' raw-type warnings.
       if (useRawFrameworkType) {
         usesRawFrameworkTypes = true;
-        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        suppressRawTypesWarning(field);
+        suppressRawTypesWarning(constructorParameter);
+        suppressRawTypesWarning(createMethodParameter);
       }
-      constructorBuilder.addParameter(parameterBuilder.build());
-      createMethodBuilder.addParameter(parameterBuilder.build());
 
-      FieldSpec field = fieldBuilder.build();
-      injectorTypeBuilder.addField(field);
-      constructorBuilder.addStatement("assert $N != null", field);
-      constructorBuilder.addStatement("this.$N = $N", field, field);
+      constructorWriter.body().addSnippet("assert %s != null;", field.name());
+      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
       dependencyFieldsBuilder.put(bindingKey, field);
-      constructorInvocationParameters.add(CodeBlocks.format("$N", field));
     }
-    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
-    createMethodBuilder.addCode(");");
 
-    injectorTypeBuilder.addMethod(constructorBuilder.build());
-    injectorTypeBuilder.addMethod(createMethodBuilder.build());
+    createMethodWriter
+        .body()
+        .addSnippet(
+            "  return new %s(%s);",
+            parameterizedGeneratedTypeNameForBinding(binding),
+            Joiner.on(", ").join(constructorWriter.parameters().keySet()));
 
-    Set<String> delegateMethods = new HashSet<>();
-    ImmutableMap<BindingKey, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
-    List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
+    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      injectMembersBuilder.addCode(
-          visibleToMembersInjector(binding, injectionSite.element())
-              ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
-              : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
+      injectMembersWriter
+          .body()
+          .addSnippet(
+              visibleToMembersInjector(binding, injectionSite.element())
+                  ? directInjectMemberSnippet(binding, dependencyFields, injectionSite)
+                  : delegateInjectMemberSnippet(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
           && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
           && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
-        injectMethodsForSubclasses.add(
-            injectorMethodForSubclasses(
-                dependencyFields,
-                typeParameters,
-                injectedTypeName,
-                injectionSite.element(),
-                injectionSite.dependencies()));
+        writeInjectorMethodForSubclasses(
+            injectorWriter,
+            dependencyFields,
+            typeParameters,
+            injectedTypeName,
+            injectionSite.element(),
+            injectionSite.dependencies());
       }
     }
-
+    
     if (usesRawFrameworkTypes) {
-      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
-    }
-
-    injectorTypeBuilder.addMethod(injectMembersBuilder.build());
-    for (MethodSpec methodSpec : injectMethodsForSubclasses) {
-      injectorTypeBuilder.addMethod(methodSpec);
+      injectMembersWriter.annotate(SuppressWarnings.class).setValue("unchecked");
     }
 
-    return Optional.of(injectorTypeBuilder);
+    return ImmutableSet.of(writer);
   }
 
   /**
@@ -233,72 +241,65 @@ private static boolean visibleToMembersInjector(
   }
 
   /**
-   * Returns a code block that directly injects the instance's field or method.
+   * Returns a snippet that directly injects the instance's field or method.
    */
-  private CodeBlock directInjectMemberCodeBlock(
+  private Snippet directInjectMemberSnippet(
       MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
       InjectionSite injectionSite) {
-    return CodeBlocks.format(
-        injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
-        getInstanceCodeBlockWithPotentialCast(
+    return Snippet.format(
+        injectionSite.element().getKind().isField() ? "%s.%s = %s;" : "%s.%s(%s);",
+        getInstanceSnippetWithPotentialCast(
             injectionSite.element().getEnclosingElement(), binding.bindingElement()),
         injectionSite.element().getSimpleName(),
-        makeParametersCodeBlock(
-            parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
+        makeParametersSnippet(
+            parameterSnippets(dependencyFields, injectionSite.dependencies(), true)));
   }
 
   /**
-   * Returns a code block that injects the instance's field or method by calling a static method on
-   * the parent MembersInjector class.
+   * Returns a snippet that injects the instance's field or method by calling a static method on the
+   * parent members injector class.
    */
-  private CodeBlock delegateInjectMemberCodeBlock(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
-    return CodeBlocks.format(
-        "$L.$L($L);",
-        javapoetMembersInjectorNameForType(
+  private Snippet delegateInjectMemberSnippet(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields, InjectionSite injectionSite) {
+    return Snippet.format(
+        "%s.%s(%s);",
+        membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
-        makeParametersCodeBlock(
-            new ImmutableList.Builder<CodeBlock>()
-                .add(CodeBlocks.format("instance"))
-                .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
+        makeParametersSnippet(
+            new ImmutableList.Builder<Snippet>()
+                .add(Snippet.format("instance"))
+                .addAll(parameterSnippets(dependencyFields, injectionSite.dependencies(), false))
                 .build()));
   }
 
   /**
    * Returns the parameters for injecting a member.
    *
-   * @param passValue if {@code true}, each parameter code block will be the result of converting
-   *     the field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real
-   *     value; if {@code false}, each parameter code block will be just the field
+   * @param passValue if {@code true}, each parameter snippet will be the result of converting the
+   *     field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real value;
+   *     if {@code false}, each parameter snippet will be just the field
    */
-  private ImmutableList<CodeBlock> parameterCodeBlocks(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+  private ImmutableList<Snippet> parameterSnippets(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
       ImmutableSet<DependencyRequest> dependencies,
       boolean passValue) {
-    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
-      CodeBlock fieldCodeBlock =
-          CodeBlocks.format("$L", dependencyFields.get(dependency.bindingKey()).name);
+      Snippet fieldSnippet =
+          Snippet.format("%s", dependencyFields.get(dependency.bindingKey()).name());
       parameters.add(
-          passValue
-              ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
-              : fieldCodeBlock);
+          passValue ? frameworkTypeUsageStatement(fieldSnippet, dependency.kind()) : fieldSnippet);
     }
     return parameters.build();
   }
 
-  private CodeBlock getInstanceCodeBlockWithPotentialCast(
+  private Snippet getInstanceSnippetWithPotentialCast(
       Element injectionSiteElement, Element bindingElement) {
-    if (injectionSiteElement.equals(bindingElement)) {
-      return CodeBlocks.format("instance");
-    }
-    TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
-    if (injectionSiteName instanceof ParameterizedTypeName) {
-      injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
-    }
-    return CodeBlocks.format("(($T) instance)", injectionSiteName);
+    return (injectionSiteElement.equals(bindingElement))
+        ? Snippet.format("instance")
+        : Snippet.format("((%s)instance)", injectionSiteElement);
   }
 
   private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
@@ -307,42 +308,44 @@ private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
             CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
   }
 
-  private MethodSpec injectorMethodForSubclasses(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
+  private void writeInjectorMethodForSubclasses(
+      ClassWriter injectorWriter,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
       List<TypeVariableName> typeParameters,
       TypeName injectedTypeName,
       Element injectionElement,
       ImmutableSet<DependencyRequest> dependencies) {
-    MethodSpec.Builder methodBuilder =
-        MethodSpec.methodBuilder(injectionSiteDelegateMethodName(injectionElement))
-            .addModifiers(PUBLIC, STATIC)
-            .addParameter(injectedTypeName, "instance")
-            .addTypeVariables(typeParameters);
-    ImmutableList.Builder<CodeBlock> providedParameters = ImmutableList.builder();
+    MethodWriter methodWriter =
+        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
+    methodWriter.addModifiers(PUBLIC, STATIC);
+    methodWriter.addParameter(injectedTypeName, "instance");
+    methodWriter.addTypeParameters(typeParameters);
+    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
     Set<String> parameterNames = new HashSet<>();
     for (DependencyRequest dependency : dependencies) {
-      FieldSpec field = dependencyFields.get(dependency.bindingKey());
-      ParameterSpec parameter =
-          ParameterSpec.builder(
-                  field.type,
-                  staticInjectMethodDependencyParameterName(parameterNames, dependency, field))
-              .build();
-      methodBuilder.addParameter(parameter);
+      FieldWriter field = dependencyFields.get(dependency.bindingKey());
+      VariableWriter parameter =
+          methodWriter.addParameter(
+              field.type(),
+              staticInjectMethodDependencyParameterName(parameterNames, dependency, field));
       providedParameters.add(
-          frameworkTypeUsageStatement(CodeBlocks.format("$N", parameter), dependency.kind()));
+          frameworkTypeUsageStatement(Snippet.format("%s", parameter.name()), dependency.kind()));
     }
     if (injectionElement.getKind().isField()) {
-      methodBuilder.addStatement(
-          "instance.$L = $L",
-          injectionElement.getSimpleName(),
-          getOnlyElement(providedParameters.build()));
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s = %s;",
+              injectionElement.getSimpleName(),
+              getOnlyElement(providedParameters.build()));
     } else {
-      methodBuilder.addStatement(
-          "instance.$L($L)",
-          injectionElement.getSimpleName(),
-          makeParametersCodeBlock(providedParameters.build()));
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s(%s);",
+              injectionElement.getSimpleName(),
+              makeParametersSnippet(providedParameters.build()));
     }
-    return methodBuilder.build();
   }
 
   /**
@@ -353,14 +356,14 @@ private MethodSpec injectorMethodForSubclasses(
    * @param field the field used to hold the framework type for the dependency
    */
   private String staticInjectMethodDependencyParameterName(
-      Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
+      Set<String> parameterNames, DependencyRequest dependency, FieldWriter field) {
     StringBuilder parameterName =
         new StringBuilder(dependency.requestElement().getSimpleName().toString());
     switch (dependency.kind()) {
       case LAZY:
       case INSTANCE:
       case FUTURE:
-        String suffix = ((ParameterizedTypeName) field.type).rawType.simpleName();
+        String suffix = ((ParameterizedTypeName) field.type()).type().simpleName();
         if (parameterName.length() <= suffix.length()
             || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
           parameterName.append(suffix);
@@ -377,6 +380,10 @@ private String staticInjectMethodDependencyParameterName(
     return parameterName.toString();
   }
 
+  private void suppressRawTypesWarning(Modifiable modifiable) {
+    modifiable.annotate(SuppressWarnings.class).setValue("rawtypes");
+  }
+
   private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
       new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index f5f33af1b..c6b3344da 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -42,7 +42,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 
 /** Generates a monitoring module for use with production components. */
-final class MonitoringModuleGenerator extends JavaWriterSourceFileGenerator<TypeElement> {
+final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
   private static final TypeName SET_OF_FACTORIES =
       ParameterizedTypeName.create(
           Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 73600608a..154372b77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -68,7 +68,7 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends JavaWriterSourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
   ProducerFactoryGenerator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 05c4f3a6d..c2620981a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -36,7 +36,6 @@
  * @since 2.0
  */
 final class SourceFileGenerationException extends Exception {
-  // TODO(ronshapiro): remove these unused values
   private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
@@ -56,15 +55,6 @@
     this(generatedClassNames, cause, Optional.of(associatedElement));
   }
 
-  SourceFileGenerationException(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName,
-      Throwable cause,
-      Optional<? extends Element> associatedElement) {
-    super(createMessage(generatedClassName, cause.getMessage()), cause);
-    this.generatedClassNames = ImmutableSet.of();
-    this.associatedElement = checkNotNull(associatedElement);
-  }
-
   public ImmutableSet<ClassName> generatedClassNames() {
     return generatedClassNames;
   }
@@ -81,15 +71,6 @@ private static String createMessage(Iterable<ClassName> generatedClassNames, Str
         message);
   }
 
-  private static String createMessage(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName, String message) {
-    return String.format("Could not generate %s: %s.",
-        generatedClassName.isPresent()
-            ? generatedClassName.get()
-            : "unknown file",
-        message);
-  }
-
   void printMessageTo(Messager messager) {
     if (associatedElement.isPresent()) {
       messager.printMessage(ERROR, getMessage(), associatedElement.get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index ddb889f34..4dc35ca2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -15,14 +15,90 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.io.IOException;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
- * A template for types that generate source files from an annotation processor.
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
  *
  * @param <T> The input type from which source is to be generated.
  * @author Gregory Kick
  * @since 2.0
  */
-interface SourceFileGenerator<T> {
-  /** Generates a source file to be compiled for {@code T}. */
-  void generate(T input) throws SourceFileGenerationException;
+abstract class SourceFileGenerator<T> {
+  private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
+
+  SourceFileGenerator(Filer filer, Elements elements) {
+    this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
+  }
+
+  final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    ImmutableSet<Element> originatingElements =
+        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
+    try {
+      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
+      for (JavaWriter javaWriter : writers) {
+        javaWriter.markGenerated(generatedAnnotationAvailable);
+        try {
+          javaWriter.file(filer, originatingElements);
+        } catch (IOException e) {
+          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
+              e, getElementForErrorReporting(input));
+        }
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
+          getElementForErrorReporting(input));
+    }
+  }
+
+  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
+    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
+      @Override public ClassName apply(TypeWriter input) {
+        return input.name();
+      }
+    });
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Implementations should return {@link Element} instances from which the source is to be
+   * generated.
+   */
+  abstract Iterable<? extends Element> getOriginatingElements(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   */
+  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 6701a5d84..d5612ccaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,8 +16,6 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -27,7 +25,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
-import com.squareup.javapoet.CodeBlock;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
@@ -53,9 +50,6 @@
  * @since 2.0
  */
 class SourceFiles {
-
-  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('$');
-
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
@@ -201,27 +195,7 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         throw new AssertionError();
     }
   }
-
-  static CodeBlock frameworkTypeUsageStatement(
-      CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
-    switch (dependencyKind) {
-      case LAZY:
-        return CodeBlocks.format(
-            "$T.create($L)",
-            com.squareup.javapoet.ClassName.get(DoubleCheckLazy.class),
-            frameworkTypeMemberSelect);
-      case INSTANCE:
-      case FUTURE:
-        return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
-      case PROVIDER:
-      case PRODUCER:
-      case MEMBERS_INJECTOR:
-        return CodeBlocks.format("$L", frameworkTypeMemberSelect);
-      default:
-        throw new AssertionError();
-    }
-  }
-
+  
   /**
    * Returns the generated factory or members injector name for a binding.
    */
@@ -264,118 +238,52 @@ static ClassName generatedClassNameForBinding(Binding binding) {
   static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
   }
-
-  /**
-   * Returns the generated factory or members injector name for a binding.
-   */
-  static com.squareup.javapoet.ClassName javapoetGeneratedClassNameForBinding(Binding binding) {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(!contribution.isSyntheticBinding());
-        com.squareup.javapoet.ClassName enclosingClassName =
-            com.squareup.javapoet.ClassName.get(contribution.bindingTypeElement());
-        switch (contribution.bindingKind()) {
-          case INJECTION:
-          case PROVISION:
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
-            return enclosingClassName
-                .topLevelClassName()
-                .peerClass(
-                    classFileName(enclosingClassName)
-                        + "_"
-                        + factoryPrefix(contribution)
-                        + "Factory");
-
-          default:
-            throw new AssertionError();
-        }
-
-      case MEMBERS_INJECTION:
-        return javapoetMembersInjectorNameForType(binding.bindingTypeElement());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static com.squareup.javapoet.TypeName javapoetParameterizedGeneratedTypeNameForBinding(
-      Binding binding) {
-    com.squareup.javapoet.ClassName className = javapoetGeneratedClassNameForBinding(binding);
-    ImmutableList<com.squareup.javapoet.TypeName> typeParameters =
-        javapoetBindingTypeParameters(binding);
-    if (typeParameters.isEmpty()) {
-      return className;
-    } else {
-      return com.squareup.javapoet.ParameterizedTypeName.get(
-          className,
-          FluentIterable.from(typeParameters).toArray(com.squareup.javapoet.TypeName.class));
-    }
-  }
-
-  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
+  
+  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding)
       throws AssertionError {
+    TypeMirror bindingType;
     switch (binding.bindingType()) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contributionBinding = (ContributionBinding) binding;
         if (contributionBinding.contributionType().isMultibinding()) {
-          return Optional.absent();
+          return ImmutableList.of();
         }
         switch (contributionBinding.bindingKind()) {
           case INJECTION:
-            return Optional.of(contributionBinding.key().type());
-
+            bindingType = contributionBinding.key().type();
+            break;
+            
           case PROVISION:
             // For provision bindings, we parameterize creation on the types of
             // the module, not the types of the binding.
             // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
             // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().asType());
-
+            bindingType = contributionBinding.bindingTypeElement().asType();
+            break;
+            
           case IMMEDIATE:
           case FUTURE_PRODUCTION:
             // TODO(beder): Can these be treated just like PROVISION?
             throw new UnsupportedOperationException();
             
           default:
-            return Optional.absent();
+            return ImmutableList.of();
         }
+        break;
 
       case MEMBERS_INJECTION:
-        return Optional.of(binding.key().type());
+        bindingType = binding.key().type();
+        break;
 
       default:
         throw new AssertionError();
     }
-  }
-
-  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    TypeName bindingTypeName = TypeNames.forTypeMirror(typeMirror.get());
+    TypeName bindingTypeName = TypeNames.forTypeMirror(bindingType);
     return bindingTypeName instanceof ParameterizedTypeName
         ? ((ParameterizedTypeName) bindingTypeName).parameters()
         : ImmutableList.<TypeName>of();
   }
-
-  private static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    com.squareup.javapoet.TypeName bindingTypeName =
-        com.squareup.javapoet.TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof com.squareup.javapoet.ParameterizedTypeName
-        ? ImmutableList.copyOf(
-            ((com.squareup.javapoet.ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<com.squareup.javapoet.TypeName>of();
-  }
   
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
     ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
@@ -384,19 +292,6 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
         .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
-  static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
-      TypeElement typeElement) {
-    com.squareup.javapoet.ClassName injectedClassName =
-        com.squareup.javapoet.ClassName.get(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerClass(classFileName(injectedClassName) + "_MembersInjector");
-  }
-
-  static String classFileName(com.squareup.javapoet.ClassName className) {
-    return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
-  }
-
   static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
     ClassName componentName = ClassName.fromTypeElement(componentElement);
     return componentName
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 0a37c2294..08473a98f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -23,9 +23,4 @@
       "@Generated("
           + "comments = \"https://google.github.io/dagger\", "
           + "value = \"dagger.internal.codegen.ComponentProcessor\")";
-
-  public static final String GENERATED_ANNOTATION_JAVAPOET =
-      "@Generated("
-          + "value = \"dagger.internal.codegen.ComponentProcessor\", "
-          + "comments = \"https://google.github.io/dagger\")";
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 2d0a1bf74..5c58ad5f7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -34,7 +34,6 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -227,7 +226,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -240,11 +239,6 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.bProvider = bProvider;",
         "  }",
         "",
-        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
@@ -254,6 +248,11 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.register(bProvider.get());",
         "  }",
         "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "",
         "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
         "    instance.a = aProvider.get();",
         "  }",
@@ -320,7 +319,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
         "  private final Provider<T> tAndXProvider;",
@@ -337,23 +336,23 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.a2Provider = a2Provider;",
         "  }",
         "",
-        "  public static <T> MembersInjector<Child<T>> create(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    ((Parent) instance).x = tAndXProvider.get();",
-        "    ((Parent) instance).y = aAndYProvider.get();",
-        "    ((Parent) instance).a2 = a2Provider.get();",
+        "    ((test.Parent) instance).x = tAndXProvider.get();",
+        "    ((test.Parent) instance).y = aAndYProvider.get();",
+        "    ((test.Parent) instance).a2 = a2Provider.get();",
         "    instance.a = aAndYProvider.get();",
         "    instance.t = tAndXProvider.get();",
         "  }",
         "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
         "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
         "    instance.a = aProvider.get();",
         "  }",
@@ -392,7 +391,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
         "  private final Provider<String> stringProvider;",
@@ -402,10 +401,6 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
-        "    return new FieldInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
@@ -416,6 +411,10 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+        "    return new FieldInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
         "  public static void injectString(",
         "      FieldInjection instance, Provider<String> stringProvider) {",
         "    instance.string = stringProvider.get();",
@@ -462,7 +461,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MethodInjection_MembersInjector",
         "     implements MembersInjector<MethodInjection> {",
         "",
@@ -473,11 +472,6 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<MethodInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new MethodInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
@@ -489,6 +483,11 @@ public void parentClass_injectedMembersInSupertype() {
         "        stringProvider);",
         "  }",
         "",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
         "  public static void injectNoArgs(MethodInjection instance) {",
         "    instance.noArgs();",
         "  }",
@@ -541,7 +540,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -557,13 +556,6 @@ public void mixedMemberInjection() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  public static MembersInjector<MixedMemberInjection> create(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    return new MixedMemberInjection_MembersInjector(",
-        "        stringAndSProvider, objectAndOProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
@@ -575,6 +567,12 @@ public void mixedMemberInjection() {
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
         "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection_MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
         "  public static void injectString(",
         "      MixedMemberInjection instance, Provider<String> stringProvider) {",
         "    instance.string = stringProvider.get();",
@@ -622,7 +620,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -633,10 +631,6 @@ public void mixedMemberInjection() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "      return new AllInjections_MembersInjector(sProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
@@ -646,6 +640,10 @@ public void mixedMemberInjection() {
         "    instance.s(sProvider.get());",
         "  }",
         "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
         "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
         "    instance.s = sProvider.get();",
         "  }",
@@ -679,7 +677,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
@@ -688,10 +686,6 @@ public void mixedMemberInjection() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
-        "      return new B_MembersInjector(sProvider);",
-        "  }",
-        "",
         "  @Override",
         "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
@@ -700,6 +694,9 @@ public void mixedMemberInjection() {
         "    instance.s = sProvider.get();",
         "  }",
         "",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
         "  public static void injectS(B instance, Provider<String> sProvider) {",
         "    instance.s = sProvider.get();",
         "  }",
@@ -740,29 +737,31 @@ public void simpleComponentWithNesting() {
           "import dagger.MembersInjector;",
           "import javax.annotation.Generated;",
           "import javax.inject.Provider;",
+          "import test.OuterType.A;",
+          "import test.OuterType.B;",
           "",
-          GENERATED_ANNOTATION_JAVAPOET,
-          "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
-          "  private final Provider<OuterType.A> aProvider;",
+        GENERATED_ANNOTATION,
+          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+          "  private final Provider<A> aProvider;",
           "",
-          "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
+          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
           "    assert aProvider != null;",
           "    this.aProvider = aProvider;",
           "  }",
           "",
-          "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
-          "    return new OuterType$B_MembersInjector(aProvider);",
-          "  }",
-          "",
           "  @Override",
-          "  public void injectMembers(OuterType.B instance) {",
+          "  public void injectMembers(B instance) {",
           "    if (instance == null) {",
           "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
           "    }",
           "    instance.a = aProvider.get();",
           "  }",
           "",
-          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  public static void injectA(B instance, Provider<A> aProvider) {",
           "    instance.a = aProvider.get();",
           "  }",
           "}");
@@ -805,29 +804,31 @@ public void componentWithNestingAndGeneratedType() {
             "import dagger.MembersInjector;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
+            "import test.OuterType.A;",
+            "import test.OuterType.B;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
-            "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
-            "  private final Provider<OuterType.A> aProvider;",
+            GENERATED_ANNOTATION,
+            "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+            "  private final Provider<A> aProvider;",
             "",
-            "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
+            "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
             "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
             "  }",
             "",
-            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
-            "    return new OuterType$B_MembersInjector(aProvider);",
-            "  }",
-            "",
             "  @Override",
-            "  public void injectMembers(OuterType.B instance) {",
+            "  public void injectMembers(B instance) {",
             "    if (instance == null) {",
             "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
             "    }",
             "    instance.a = aProvider.get();",
             "  }",
             "",
-            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+            "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+            "    return new OuterType$B_MembersInjector(aProvider);",
+            "  }",
+            "",
+            "  public static void injectA(B instance, Provider<A> aProvider) {",
             "    instance.a = aProvider.get();",
             "  }",
             "}");
