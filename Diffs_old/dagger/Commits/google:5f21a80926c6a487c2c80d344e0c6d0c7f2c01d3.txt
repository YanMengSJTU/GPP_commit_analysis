diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index d06bb4407..0cb664293 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -18,7 +18,6 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.StringKey;
 import java.math.BigDecimal;
@@ -98,16 +97,15 @@ public MultibindingTest(MultibindingComponent multibindingComponent) {
   }
 
   @Test public void nestedKeyMap() {
-    assertThat(multibindingComponent.nestedKeyMap()).isEqualTo(
-        ImmutableMap.of(
-            nestedWrappedKey(Integer.class), "integer",
-            nestedWrappedKey(Long.class), "long"));
+    assertThat(multibindingComponent.nestedKeyMap())
+        .containsExactly(
+            nestedWrappedKey(Integer.class), "integer", nestedWrappedKey(Long.class), "long");
   }
 
   @Test
   public void unwrappedAnnotationKeyMap() {
     assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
-        .isEqualTo(ImmutableMap.of(testStringKey("foo\n"), "foo annotation"));
+        .containsExactly(testStringKey("foo\n"), "foo annotation");
   }
 
   @Test
@@ -115,63 +113,53 @@ public void wrappedAnnotationKeyMap() {
     @SuppressWarnings("unchecked")
     Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
     assertThat(multibindingComponent.wrappedAnnotationKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                testWrappedAnnotationKey(
-                    testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
-                "wrapped foo annotation"));
+        .containsExactly(
+            testWrappedAnnotationKey(
+                testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
+            "wrapped foo annotation");
   }
 
   @Test
   public void booleanKeyMap() {
-    assertThat(multibindingComponent.booleanKeyMap()).isEqualTo(ImmutableMap.of(true, "true"));
+    assertThat(multibindingComponent.booleanKeyMap()).containsExactly(true, "true");
   }
 
   @Test
   public void byteKeyMap() {
-    assertThat(multibindingComponent.byteKeyMap())
-        .isEqualTo(ImmutableMap.of((byte) 100, "100 byte"));
+    assertThat(multibindingComponent.byteKeyMap()).containsExactly((byte) 100, "100 byte");
   }
 
   @Test
   public void charKeyMap() {
     assertThat(multibindingComponent.characterKeyMap())
-        .isEqualTo(ImmutableMap.of('a', "a char", '\n', "newline char"));
+        .containsExactly('a', "a char", '\n', "newline char");
   }
 
   @Test
   public void classKeyMap() {
     assertThat(multibindingComponent.classKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                Integer.class, "integer",
-                Long.class, "long"));
+        .containsExactly(Integer.class, "integer", Long.class, "long");
   }
 
   @Test
   public void numberClassKeyMap() {
     assertThat(multibindingComponent.numberClassKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                BigDecimal.class, "bigdecimal",
-                BigInteger.class, "biginteger"));
+        .containsExactly(BigDecimal.class, "bigdecimal", BigInteger.class, "biginteger");
   }
 
   @Test
   public void intKeyMap() {
-    assertThat(multibindingComponent.integerKeyMap()).isEqualTo(ImmutableMap.of(100, "100 int"));
+    assertThat(multibindingComponent.integerKeyMap()).containsExactly(100, "100 int");
   }
 
   @Test
   public void longKeyMap() {
-    assertThat(multibindingComponent.longKeyMap())
-        .isEqualTo(ImmutableMap.of((long) 100, "100 long"));
+    assertThat(multibindingComponent.longKeyMap()).containsExactly((long) 100, "100 long");
   }
 
   @Test
   public void shortKeyMap() {
-    assertThat(multibindingComponent.shortKeyMap())
-        .isEqualTo(ImmutableMap.of((short) 100, "100 short"));
+    assertThat(multibindingComponent.shortKeyMap()).containsExactly((short) 100, "100 short");
   }
 
   @Test public void setBindings() {
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 3ffbcb37c..ee23fa206 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -54,6 +54,12 @@ static String str() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
+  @Produces
+  @ElementsIntoSet
+  static Set<ListenableFuture<String>> strFutures() {
+    return ImmutableSet.of(Futures.immediateFuture("baz1"), Futures.immediateFuture("baz2"));
+  }
+
   @Produces
   @ElementsIntoSet
   static Set<String> strs() {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 98b408633..79f58fdce 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -41,13 +41,15 @@ public void setBinding() throws Exception {
             "foo",
             "foo1",
             "foo2",
+            "baz1",
+            "baz2",
             "bar",
             "bar1",
             "bar2",
             "providedStr",
             "providedStr1",
             "providedStr2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(9);
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(11);
   }
 
   @Test
@@ -58,6 +60,8 @@ public void setBindingOfProduced() throws Exception {
             Produced.successful("foo"),
             Produced.successful("foo1"),
             Produced.successful("foo2"),
+            Produced.successful("baz1"),
+            Produced.successful("baz2"),
             Produced.successful("bar"),
             Produced.successful("bar1"),
             Produced.successful("bar2"),
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 4e4249670..6b191fce0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,10 +27,13 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -686,30 +689,38 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
   }
 
   // TODO(gak): extract this into a proper factory class
-  private RequestFulfillment getOrCreateRequestFulfillment(BindingKey bindingKey) {
-    RequestFulfillment requestFulfillment = requestFulfillments.get(bindingKey);
-    if (requestFulfillment == null) {
-      /* TODO(gak): it is super convoluted that we create the member selects separately and then
-       * look them up again this way. Now that we have RequestFulfillment, the next step is to
-       * create it and the MemberSelect and the field on demand rather than in a first pass. */
-      MemberSelect memberSelect = getMemberSelect(bindingKey);
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      switch (resolvedBindings.bindingType()) {
-        case MEMBERS_INJECTION:
-          requestFulfillment = new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-          break;
-        case PRODUCTION:
-          requestFulfillment = new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-          break;
-        case PROVISION:
-          requestFulfillment = new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-          break;
-        default:
-          throw new AssertionError();
-      }
-      requestFulfillments.put(bindingKey, requestFulfillment);
+  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
+    /* TODO(gak): it is super convoluted that we create the member selects separately and then
+     * look them up again this way. Now that we have RequestFulfillment, the next step is to
+     * create it and the MemberSelect and the field on demand rather than in a first pass. */
+    MemberSelect memberSelect = getMemberSelect(bindingKey);
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+    switch (resolvedBindings.bindingType()) {
+      case MEMBERS_INJECTION:
+        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+      case PRODUCTION:
+        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+      case PROVISION:
+        ProvisionBinding provisionBinding =
+            (ProvisionBinding) resolvedBindings.contributionBinding();
+        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
+            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+        if (provisionBinding.implicitDependencies().isEmpty()
+            && !provisionBinding.scope().isPresent()
+            && !provisionBinding.requiresModuleInstance()
+            && provisionBinding.bindingElement().isPresent()
+            && (provisionBinding.bindingKind().equals(INJECTION)
+                || provisionBinding.bindingKind().equals(PROVISION))
+            // TODO(gak): the accessibility limitation here needs to be addressed
+            && isElementAccessibleFrom(
+                provisionBinding.bindingElement().get(), name.packageName())) {
+          return new SimpleMethodRequestFulfillment(
+              bindingKey, provisionBinding, providerFieldRequestFulfillment);
+        }
+        return providerFieldRequestFulfillment;
+      default:
+        throw new AssertionError();
     }
-    return requestFulfillment;
   }
 
   private void implementInterfaceMethods() {
@@ -732,7 +743,8 @@ private void implementInterfaceMethods() {
           MethodSpec.Builder interfaceMethod =
               methodSpecForComponentMethod(methodElement, requestType);
           RequestFulfillment fulfillment =
-              getOrCreateRequestFulfillment(interfaceRequest.bindingKey());
+              requestFulfillments.computeIfAbsent(
+                  interfaceRequest.bindingKey(), this::createRequestFulfillment);
           CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
@@ -1111,8 +1123,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 7 */ simpleVariableName(dependencyType));
         }
 
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
+      case PRODUCTION:
         {
           List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d9f155dc9..f1434e0df 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -266,6 +266,10 @@ BindingGraph topLevelGraph() {
       return parent.isPresent() ? parent.get().topLevelGraph() : subject;
     }
 
+    ValidationReport.Builder<TypeElement> topLevelReport() {
+      return parent.isPresent() ? parent.get().topLevelReport() : reportBuilder;
+    }
+
     ValidationReport<TypeElement> buildReport() {
       return reportBuilder.build();
     }
@@ -1326,7 +1330,7 @@ private String formatCurrentDependencyRequestKey(DependencyPath path) {
     abstract DependencyRequest dependencyRequest();
 
     abstract ResolvedBindings resolvedBindings();
-    
+
     /**
      * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of
      * these bindings depends directly on {@link #dependencyRequest()}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 91c9f5a73..936b4d35f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -17,33 +17,56 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Functions.constant;
+import static com.google.common.base.Predicates.and;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.Map;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
 
-/**
- * Validates the relationships between parent components and subcomponents.
- */
+/** Validates the relationships between parent components and subcomponents. */
 final class ComponentHierarchyValidator {
+  private final CompilerOptions compilerOptions;
+  private final Elements elements;
+
+  ComponentHierarchyValidator(CompilerOptions compilerOptions, Elements elements) {
+    this.compilerOptions = compilerOptions;
+    this.elements = elements;
+  }
+
   ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
-    return validateSubcomponentMethods(
+    ValidationReport.Builder<TypeElement> report =
+        ValidationReport.about(componentDescriptor.componentDefinitionType());
+    validateSubcomponentMethods(
+        report,
         componentDescriptor,
         Maps.toMap(
             componentDescriptor.transitiveModuleTypes(),
             constant(componentDescriptor.componentDefinitionType())));
+
+    if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
+      validateScopeHierarchy(
+          report, componentDescriptor, LinkedHashMultimap.<ComponentDescriptor, Scope>create());
+    }
+    return report.build();
   }
 
-  private ValidationReport<TypeElement> validateSubcomponentMethods(
+  private void validateSubcomponentMethods(
+      ValidationReport.Builder<?> report,
       ComponentDescriptor componentDescriptor,
       ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
-    ValidationReport.Builder<TypeElement> reportBuilder =
-        ValidationReport.about(componentDescriptor.componentDefinitionType());
     for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
         componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
       ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
@@ -56,7 +79,7 @@
         if (originatingComponent != null) {
           /* Factory method tries to pass a module that is already present in the parent.
            * This is an error. */
-          reportBuilder.addError(
+          report.addError(
               String.format(
                   "%s is present in %s. A subcomponent cannot use an instance of a "
                       + "module that differs from its parent.",
@@ -64,19 +87,59 @@
               factoryMethodParameter);
         }
       }
-      reportBuilder.addSubreport(
-          validateSubcomponentMethods(
-              subcomponentDescriptor,
-              new ImmutableMap.Builder<TypeElement, TypeElement>()
-                  .putAll(existingModuleToOwners)
-                  .putAll(
-                      Maps.toMap(
-                          Sets.difference(
-                              subcomponentDescriptor.transitiveModuleTypes(),
-                              existingModuleToOwners.keySet()),
-                          constant(subcomponentDescriptor.componentDefinitionType())))
-                  .build()));
+      validateSubcomponentMethods(
+          report,
+          subcomponentDescriptor,
+          new ImmutableMap.Builder<TypeElement, TypeElement>()
+              .putAll(existingModuleToOwners)
+              .putAll(
+                  Maps.toMap(
+                      Sets.difference(
+                          subcomponentDescriptor.transitiveModuleTypes(),
+                          existingModuleToOwners.keySet()),
+                      constant(subcomponentDescriptor.componentDefinitionType())))
+              .build());
+    }
+  }
+
+  /**
+   * Checks that components do not have any scopes that are also applied on any of their ancestors.
+   */
+  private void validateScopeHierarchy(
+      ValidationReport.Builder<TypeElement> report,
+      ComponentDescriptor subject,
+      SetMultimap<ComponentDescriptor, Scope> scopesByComponent) {
+    scopesByComponent.putAll(subject, subject.scopes());
+
+    for (ComponentDescriptor child : subject.subcomponents()) {
+      validateScopeHierarchy(report, child, scopesByComponent);
+    }
+
+    scopesByComponent.removeAll(subject);
+
+    Predicate<Scope> subjectScopes =
+        subject.kind().isProducer()
+            // TODO(beder): validate that @ProductionScope is only applied on production components
+            ? and(in(subject.scopes()), not(equalTo(Scope.productionScope(elements))))
+            : in(subject.scopes());
+    SetMultimap<ComponentDescriptor, Scope> overlappingScopes =
+        Multimaps.filterValues(scopesByComponent, subjectScopes);
+    if (!overlappingScopes.isEmpty()) {
+      StringBuilder error =
+          new StringBuilder()
+              .append(subject.componentDefinitionType().getQualifiedName())
+              .append(" has conflicting scopes:");
+      for (Map.Entry<ComponentDescriptor, Scope> entry : overlappingScopes.entries()) {
+        Scope scope = entry.getValue();
+        error.append("\n  ")
+            .append(entry.getKey().componentDefinitionType().getQualifiedName())
+            .append(" also has ")
+            .append(scope.getReadableSource());
+      }
+      report.addItem(
+          error.toString(),
+          compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+          subject.componentDefinitionType());
     }
-    return reportBuilder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 0adc85b8f..0fe526112 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -171,8 +171,8 @@ public SourceVersion getSupportedSourceVersion() {
         new AnnotationCreatorGenerator(filer, elements);
     UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
         new UnwrappedMapKeyGenerator(filer, elements);
-
-    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
+    ComponentHierarchyValidator componentHierarchyValidator =
+        new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
             elements,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 7f89dd28e..da7398b3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -124,11 +124,8 @@
 
     // Production kinds
 
-    /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
-    IMMEDIATE,
-
-    /** A {@link Produces}-annotated method that returns a {@link ListenableFuture}. */
-    FUTURE_PRODUCTION,
+    /** A {@link Produces}-annotated method. */
+    PRODUCTION,
 
     /**
      * A production method on a production component's {@linkplain
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 8bc1f1bef..f1c004813 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -390,9 +390,19 @@ private Key forBindingMethod(
       TypeMirror returnType = methodType.getReturnType();
       if (frameworkType.isPresent()
           && frameworkType.get().equals(getClassElement(Producer.class))
-          && isType(returnType)
-          && isTypeOf(ListenableFuture.class, returnType)) {
-        returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+          && isType(returnType)) {
+        if (isTypeOf(ListenableFuture.class, returnType)) {
+          returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+        } else if (contributionType.equals(ContributionType.SET_VALUES)
+            && SetType.isSet(returnType)) {
+          SetType setType = SetType.from(returnType);
+          if (setType.elementsAreTypeOf(ListenableFuture.class)) {
+            returnType =
+                types.getDeclaredType(
+                    getClassElement(Set.class),
+                    setType.unwrappedElementType(ListenableFuture.class));
+          }
+        }
       }
       TypeMirror keyType =
           bindingMethodKeyType(returnType, method, contributionType, frameworkType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index bfea77daf..c2a53148d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -484,11 +484,21 @@ private CodeBlock getInvocationCodeBlock(
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
-    CodeBlock returnCodeBlock =
-        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
-            ? moduleCodeBlock
-            : CodeBlock.of(
-                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
+    final CodeBlock returnCodeBlock;
+    switch (binding.productionKind().get()) {
+      case IMMEDIATE:
+        returnCodeBlock =
+            CodeBlock.of("$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
+        break;
+      case FUTURE:
+        returnCodeBlock = moduleCodeBlock;
+        break;
+      case SET_OF_FUTURE:
+        returnCodeBlock = CodeBlock.of("$T.allAsSet($L)", PRODUCERS, moduleCodeBlock);
+        break;
+      default:
+        throw new AssertionError();
+    }
     return CodeBlock.of(
         Joiner.on('\n')
             .join(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index ed3dcba16..a25d339a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -66,6 +66,23 @@ public BindingType bindingType() {
         .build();
   }
 
+  /** What kind of object this produces method returns. */
+  enum ProductionKind {
+    /** A value. */
+    IMMEDIATE,
+    /** A {@code ListenableFuture<T>}. */
+    FUTURE,
+    /** A {@code Set<ListenableFuture<T>>}. */
+    SET_OF_FUTURE;
+  }
+
+  /**
+   * Returns the kind of object the produces method returns. All production bindings from
+   * {@code @Produces} methods will have a production kind, but synthetic production bindings may
+   * not.
+   */
+  abstract Optional<ProductionKind> productionKind();
+
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
@@ -91,6 +108,7 @@ private static Builder builder() {
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
+    abstract Builder productionKind(ProductionKind productionKind);
 
     abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
 
@@ -117,6 +135,7 @@ private static Builder builder() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
+      ContributionType contributionType = ContributionType.fromBindingMethod(producesMethod);
       Key key = keyFactory.forProducesMethod(producesMethod, contributedBy);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(
@@ -127,20 +146,27 @@ ProductionBinding forProducesMethod(
               resolvedMethod.getParameterTypes());
       DependencyRequest executorRequest =
           dependencyRequestFactory.forProductionImplementationExecutor();
-      DependencyRequest monitorRequest =
-          dependencyRequestFactory.forProductionComponentMonitor();
-      Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
-          ? Kind.FUTURE_PRODUCTION
-          : Kind.IMMEDIATE;
+      DependencyRequest monitorRequest = dependencyRequestFactory.forProductionComponentMonitor();
+      final ProductionKind productionKind;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())) {
+        productionKind = ProductionKind.FUTURE;
+      } else if (contributionType.equals(ContributionType.SET_VALUES)
+          && SetType.from(producesMethod.getReturnType())
+              .elementsAreTypeOf(ListenableFuture.class)) {
+        productionKind = ProductionKind.SET_OF_FUTURE;
+      } else {
+        productionKind = ProductionKind.IMMEDIATE;
+      }
       // TODO(beder): Add nullability checking with Java 8.
       return ProductionBinding.builder()
-          .contributionType(ContributionType.fromBindingMethod(producesMethod))
+          .contributionType(contributionType)
           .bindingElement(producesMethod)
           .contributingModule(contributedBy)
           .key(key)
           .dependencies(dependencies)
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
-          .bindingKind(kind)
+          .bindingKind(Kind.PRODUCTION)
+          .productionKind(productionKind)
           .thrownTypes(producesMethod.getThrownTypes())
           .executorRequest(executorRequest)
           .monitorRequest(monitorRequest)
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index d2d7f55c4..fc3470600 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -49,12 +50,22 @@
    * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
    */
   static Scope scope(AnnotationMirror scopeAnnotation) {
-    checkArgument(
-        isAnnotationPresent(
-            scopeAnnotation.getAnnotationType().asElement(), javax.inject.Scope.class));
+    checkArgument(isScope(scopeAnnotation));
     return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
   }
 
+  /** Returns {@code true} if {@code scopeAnnotation} is a {@link javax.inject.Scope} annotation. */
+  static boolean isScope(AnnotationMirror scopeAnnotation) {
+    return isScope(MoreElements.asType(scopeAnnotation.getAnnotationType().asElement()));
+  }
+
+  /**
+   * Returns {@code true} if {@code scopeAnnotationType} is a {@link javax.inject.Scope} annotation.
+   */
+  static boolean isScope(TypeElement scopeAnnotationType) {
+    return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);
+  }
+
   /**
    * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
new file mode 100644
index 000000000..9eb91f534
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.util.concurrent.Futures;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.element.ExecutableElement;
+
+/**
+ * A request fulfillment implementation that invokes methods or constructors directly to fulfill
+ * requests whenever possible. In cases where direct invocation is not possible, this implementation
+ * delegates to one that uses a {@link javax.inject.Provider}.
+ */
+final class SimpleMethodRequestFulfillment extends RequestFulfillment {
+  private final ProvisionBinding provisionBinding;
+  private final RequestFulfillment providerDelegate;
+
+  SimpleMethodRequestFulfillment(
+      BindingKey bindingKey,
+      ProvisionBinding provisionBinding,
+      RequestFulfillment providerDelegate) {
+    super(bindingKey);
+    checkArgument(provisionBinding.implicitDependencies().isEmpty());
+    checkArgument(!provisionBinding.scope().isPresent());
+    checkArgument(!provisionBinding.requiresModuleInstance());
+    checkArgument(provisionBinding.bindingElement().isPresent());
+    this.provisionBinding = provisionBinding;
+    this.providerDelegate = providerDelegate;
+  }
+
+  @Override
+  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    switch (request.kind()) {
+      case INSTANCE:
+        return invokeMethod();
+      case FUTURE:
+        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod());
+      default:
+        return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
+    }
+  }
+
+  private CodeBlock invokeMethod() {
+    // we use the type from the key to ensure we get the right generics
+    // TODO(gak): use <>?
+    ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        return CodeBlock.of("new $T()", provisionBinding.key().type());
+      case METHOD:
+        checkState(method.getModifiers().contains(STATIC));
+        return CodeBlock.of(
+            "$T.$L()", provisionBinding.bindingTypeElement().get(), method.getSimpleName());
+      default:
+        throw new IllegalStateException();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 5b61872e0..62571bdb9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -20,25 +20,24 @@
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
+import static dagger.internal.codegen.Util.optionalComparator;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Ordering;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
+import java.util.Comparator;
 import java.util.Iterator;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
@@ -57,26 +56,17 @@
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
-      new Ordering<DependencyRequest>() {
-        @Override
-        public int compare(DependencyRequest left, DependencyRequest right) {
-          return ComparisonChain.start()
-              // put fields before parameters
-              .compare(
-                  left.requestElement().transform(Element::getKind),
-                  right.requestElement().transform(Element::getKind),
-                  Util.<ElementKind>optionalComparator())
-              // order by dependency kind
-              .compare(left.kind(), right.kind())
-              // then sort by name
-              .compare(
-                  left.requestElement().transform(ELEMENT_SIMPLE_NAME),
-                  right.requestElement().transform(ELEMENT_SIMPLE_NAME),
-                  Util.<String>optionalComparator())
-              .result();
-        }
-      };
+  static final Comparator<DependencyRequest> DEPENDENCY_ORDERING =
+      // put fields before parameters
+      Comparator.comparing(
+              (DependencyRequest request) -> request.requestElement().transform(Element::getKind),
+              optionalComparator())
+          // order by dependency kind
+          .thenComparing(DependencyRequest::kind)
+          // then sort by name
+          .thenComparing(
+              request -> request.requestElement().transform(ELEMENT_SIMPLE_NAME),
+              optionalComparator());
 
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
@@ -87,7 +77,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * <li>is <i>probably</i> associated with the type being bound
    * <li>is unique within the class
    * </ul>
-   * 
+   *
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
@@ -163,8 +153,7 @@ static ClassName generatedClassNameForBinding(Binding binding) {
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
+          case PRODUCTION:
             return enclosingClassName
                 .topLevelClassName()
                 .peerClass(
@@ -216,8 +205,7 @@ static TypeName parameterizedGeneratedTypeNameForBinding(
             // The binding is just parameterized on <B>, but we need all of <A, B, C>.
             return Optional.of(contributionBinding.bindingTypeElement().get().asType());
 
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
+          case PRODUCTION:
             // TODO(beder): Can these be treated just like PROVISION?
             throw new UnsupportedOperationException();
             
@@ -275,8 +263,7 @@ private static String factoryPrefix(ContributionBinding binding) {
         return "";
 
       case PROVISION:
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
+      case PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
             UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0db1ca3cf..09c547d2c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -18,18 +18,18 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.collect.Lists.asList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
@@ -42,6 +42,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
 
@@ -58,13 +59,13 @@ static boolean requiresAPassedInstance(Elements elements, TypeElement typeElemen
         MoreElements.getLocalAndInheritedMethods(typeElement, elements);
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
+      if (method.getModifiers().contains(ABSTRACT)
+          && !MoreElements.isAnnotationPresent(method, Binds.class)) {
         /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
         return true;
       } else if (!method.getModifiers().contains(STATIC)
-          && (isAnnotationPresent(method, Provides.class)
-              || isAnnotationPresent(method, Produces.class))) {
+          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
         foundInstanceMethod = true;
       }
     }
@@ -165,7 +166,7 @@ public TypeElement visitType(TypeElement e, Void p) {
   static boolean isAnyAnnotationPresent(
       Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
     for (Class<? extends Annotation> annotation : annotationClasses) {
-      if (isAnnotationPresent(element, annotation)) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
         return true;
       }
     }
@@ -177,8 +178,20 @@ static boolean isAnyAnnotationPresent(
       Element element,
       Class<? extends Annotation> first,
       Class<? extends Annotation>... otherAnnotations) {
-    return isAnnotationPresent(element, first)
-        || isAnyAnnotationPresent(element, ImmutableList.copyOf(otherAnnotations));
+    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
+  }
+
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
+   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
+   */
+  // TODO(dpb): Move to MoreElements.
+  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .map(AnnotationMirror::getAnnotationType)
+        .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
   }
 
   /**
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index f2a24384f..aa493b864 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -60,38 +60,39 @@ public void testEmptyBuilder() {
         "     SimpleComponent build();",
         "  }",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static SimpleComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  private static final class Builder implements SimpleComponent.Builder {",
-        "    @Override",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static SimpleComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
new file mode 100644
index 000000000..db2702f58
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {ComponentHierarchyValidator}. */
+@RunWith(JUnit4.class)
+public class ComponentHierarchyValidatorTest {
+  @Test
+  public void singletonSubcomponent() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Subcomponent",
+            "interface Child {}");
+
+    assertThat(component, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("conflicting scopes")
+        .and().withErrorContaining("test.Parent also has @Singleton");
+
+    assertThat(component, subcomponent)
+        .withCompilerOptions("-Adagger.disableInterComponentScopeValidation=none")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+  
+  @Test
+  public void productionComponents_productionScopeImplicitOnBoth() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "  Object productionScopedObject();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.ProductionScope;",
+            "",
+            "@ProducerModule",
+            "class ParentModule {",
+            "  @Provides @ProductionScope Object parentScopedObject() { return new Object(); }",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String productionScopedString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.ProductionScope;",
+            "",
+            "@ProducerModule",
+            "class ChildModule {",
+            "  @Provides @ProductionScope String childScopedString() { return new String(); }",
+            "}");
+    assertThat(component, subcomponent, parentModule, childModule)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index ba44cc802..0c79fb47f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -245,7 +245,7 @@
             "",
             "  @Override",
             "  public SomeInjectableType someInjectableType() {",
-            "    return SomeInjectableType_Factory.create().get();",
+            "    return new SomeInjectableType();",
             "  }",
             "",
             "  @Override",
@@ -382,55 +382,57 @@
         "  }",
         "}");
 
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerOuterType_SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerOuterType_SimpleComponent implements OuterType.SimpleComponent {",
-        "  private MembersInjector<OuterType.B> bMembersInjector;",
-        "",
-        "  private DaggerOuterType_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static OuterType.SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bMembersInjector =",
-        "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public OuterType.A a() {",
-        "    return OuterType_A_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public void inject(OuterType.B b) {",
-        "    bMembersInjector.injectMembers(b);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public OuterType.SimpleComponent build() {",
-        "      return new DaggerOuterType_SimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerOuterType_SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerOuterType_SimpleComponent",
+            "    implements OuterType.SimpleComponent {",
+            "  private MembersInjector<OuterType.B> bMembersInjector;",
+            "",
+            "  private DaggerOuterType_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static OuterType.SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bMembersInjector =",
+            "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public OuterType.A a() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void inject(OuterType.B b) {",
+            "    bMembersInjector.injectMembers(b);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public OuterType.SimpleComponent build() {",
+            "      return new DaggerOuterType_SimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1094,7 +1096,7 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "",
             "  @Override",
             "  public String notSubcomponent() {",
-            "    return ParentModule_NotSubcomponentFactory.create().get();",
+            "    return ParentModule.notSubcomponent();",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1860,63 +1862,64 @@ public void testDefaultPackage() {
         "  C c();",
         "  X x();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Provider<A> aProvider;",
-        "  private Provider<X> xProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = B_Factory.create(C_Factory.create());",
-        "    this.aProvider = A_Factory.create(bProvider);",
-        "    this.xProvider = X_Factory.create(C_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public C c() {",
-        "    return C_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public X x() {",
-        "    return xProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "  private Provider<X> xProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = B_Factory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "    this.xProvider = X_Factory.create(C_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return aProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C c() {",
+            "    return new C();",
+            "  }",
+            "",
+            "  @Override",
+            "  public X x() {",
+            "    return xProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -1965,40 +1968,41 @@ public void testDefaultPackage() {
         "@Component",
         "interface SimpleComponent extends SupertypeA, SupertypeB {",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(
             injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -2047,40 +2051,41 @@ public void testDefaultPackage() {
         "interface ComponentWithDep {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(
             injectableTypeFile, componentSupertype, depComponentFile, componentFile))
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index f4e1e49d2..6f850cdb0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static java.util.Arrays.asList;
@@ -67,7 +66,8 @@
     String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
         + "      @Provides @Singleton String test.ScopedModule.string()\n"
         + "      @Singleton class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
+    assertAbout(javaSources())
+        .that(asList(componentFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(errorMessage);
@@ -118,7 +118,8 @@
         + "may not reference bindings with different scopes:\n"
         + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
         + "      @test.PerTest class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
+    assertAbout(javaSources())
+        .that(asList(componentFile, scopeFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(errorMessage);
@@ -188,7 +189,7 @@
         "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
         + "      @Singleton test.SingletonComponentA\n"
         + "      @Singleton test.SingletonComponentB";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(
             asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
         .processedWith(new ComponentProcessor())
@@ -229,7 +230,7 @@
     String errorMessage =
         "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
         + "      @Singleton test.ScopedComponent";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, scopedComponent, unscopedComponent))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -276,7 +277,7 @@
     String errorMessage =
         "This @Singleton component cannot depend on scoped components:\n"
         + "      @test.SimpleScope test.SimpleScopedComponent";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, simpleScope, simpleScoped, singletonScoped))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -342,7 +343,7 @@
         + "      @test.ScopeA test.ComponentLong\n"
         + "      @test.ScopeB test.ComponentMedium\n"
         + "      @test.ScopeA test.ComponentShort";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 14107541a..9f04042c3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -35,7 +35,10 @@
 public class GraphValidationTest {
   private static final JavaFileObject NULLABLE =
       JavaFileObjects.forSourceLines(
-          "test.Nullable", "package test;", "public @interface Nullable {}");
+          "test.Nullable", // force one-string-per-line format
+          "package test;",
+          "",
+          "public @interface Nullable {}");
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
index 87a24c168..3dfd29566 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 import com.google.common.collect.ImmutableList;
@@ -38,82 +38,91 @@
       "}");
 
   @Test public void multipleRequests_constructor() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.ConstructorInjectsMultiple",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "class ConstructorInjectsMultiple {",
-                "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component",
-                "interface SimpleComponent {",
-                "  ConstructorInjectsMultiple get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.ConstructorInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "class ConstructorInjectsMultiple {",
+                    "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component",
+                    "interface SimpleComponent {",
+                    "  ConstructorInjectsMultiple get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
 
   @Test public void multipleRequests_field() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "class FieldInjectsMultiple {",
-                "  @Inject Dep d1;",
-                "  @Inject Dep d2;",
-                "  @Inject FieldInjectsMultiple() {}",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component",
-                "interface SimpleComponent {",
-                "  FieldInjectsMultiple get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.FieldInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "class FieldInjectsMultiple {",
+                    "  @Inject Dep d1;",
+                    "  @Inject Dep d2;",
+                    "  @Inject FieldInjectsMultiple() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component",
+                    "interface SimpleComponent {",
+                    "  FieldInjectsMultiple get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
 
   @Test public void multipleRequests_providesMethod() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "class SimpleModule {",
-                "  @Provides Object provide(Dep d1, Dep d2) {",
-                "    return null;",
-                "  }",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component(modules = SimpleModule.class)",
-                "interface SimpleComponent {",
-                "  Object get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.FieldInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class SimpleModule {",
+                    "  @Provides Object provide(Dep d1, Dep d2) {",
+                    "    return null;",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = SimpleModule.class)",
+                    "interface SimpleComponent {",
+                    "  Object get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 4befaf1d1..4cf5a9122 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -16,7 +16,7 @@
 
 package dagger.tests.integration.operation;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static java.util.Arrays.asList;
@@ -133,10 +133,11 @@
       "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(component, primitiveInjectable, primitiveModule))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedComponent);
+        .and()
+        .generatesSources(expectedComponent);
   }
 }
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 3ee7c5ffe..c27beb222 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -19,6 +19,7 @@
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static java.util.Collections.unmodifiableMap;
 
+import dagger.Lazy;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -30,9 +31,9 @@
  *
  * @author Chenying Hou
  * @since 2.0
- *
  */
-public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+public final class MapProviderFactory<K, V>
+    implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
   private static final MapProviderFactory<Object, Object> EMPTY =
       new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
 
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index c5c223e8a..eda82aaa0 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -17,7 +17,6 @@
 package dagger.internal;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.Lists;
@@ -102,12 +101,12 @@ public Object call() throws Exception {
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
 
-    assert_().that(provider.provisions.get()).isEqualTo(1);
+    assertThat(provider.provisions.get()).isEqualTo(1);
     Set<Object> results = Sets.newIdentityHashSet();
     for (Future<Object> future : futures) {
       results.add(future.get());
     }
-    assert_().that(results.size()).isEqualTo(1);
+    assertThat(results).hasSize(1);
   }
 
   private static class LatchedProvider implements Provider<Object> {
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index b89aa0792..14474723a 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -16,7 +16,7 @@
 
 package dagger.internal;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 
 import org.junit.Rule;
 import org.junit.Test;
@@ -31,9 +31,9 @@
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
   }
 
   @Test public void create_throwsNullPointerException() {
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
index 1c3c80154..3b17641e0 100644
--- a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -16,7 +16,7 @@
 
 package dagger.internal;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -69,8 +69,7 @@ public void iterationOrder() {
     expectedMap.put("three", p3);
     expectedMap.put("one", p5);
     expectedMap.put("four", p4);
-    assert_()
-        .that(factory.get().entrySet())
+    assertThat(factory.get().entrySet())
         .containsExactlyElementsIn(expectedMap.entrySet())
         .inOrder();
   }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index bf24784df..4d9d17c4c 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -25,6 +25,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -88,6 +89,24 @@
     });
   }
 
+  /**
+   * Creates a new {@code ListenableFuture} whose value is a set containing the values of all its
+   * input futures, if all succeed. If any input fails, the returned future fails immediately.
+   *
+   * <p>This is the set equivalent of {@link Futures#allAsList}.
+   */
+  public static <T> ListenableFuture<Set<T>> allAsSet(
+      Iterable<? extends ListenableFuture<? extends T>> futures) {
+    return Futures.transform(
+        Futures.allAsList(futures),
+        new Function<List<T>, Set<T>>() {
+          @Override
+          public Set<T> apply(List<T> values) {
+            return ImmutableSet.copyOf(values);
+          }
+        });
+  }
+
   /**
    * Returns a producer that immediately executes the binding logic for the given provider every
    * time it is called.
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index 141e174c4..910b73ca0 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
@@ -97,6 +98,32 @@
     }
   }
 
+  @Test
+  public void allAsSet_success() throws Exception {
+    ListenableFuture<Set<String>> future =
+        Producers.allAsSet(
+            ImmutableList.of(
+                Futures.immediateFuture("monkey"), Futures.immediateFuture("gorilla")));
+    assertThat(future.isDone()).isTrue();
+    assertThat(future.get()).containsExactly("monkey", "gorilla");
+  }
+
+  @Test
+  public void allAsSet_failure() throws Exception {
+    ListenableFuture<Set<String>> future =
+        Producers.allAsSet(
+            ImmutableList.of(
+                Futures.immediateFuture("monkey"),
+                Futures.<String>immediateFailedFuture(new RuntimeException("gorilla"))));
+    assertThat(future.isDone()).isTrue();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("gorilla");
+    }
+  }
+
   @Test public void producerFromProvider() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
