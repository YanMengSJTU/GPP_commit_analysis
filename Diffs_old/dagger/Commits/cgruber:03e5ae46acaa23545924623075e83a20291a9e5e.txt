diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index ceb8065bb..af74000a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1063,11 +1063,12 @@ private void reportCycle(
       Element rootRequestElement = requestPath.get(0).requestElement();
       ImmutableList<DependencyRequest> cycle =
           requestPath.subList(indexOfDuplicatedKey, requestPath.size());
-      Diagnostic.Kind kind = cycleHasProviderOrLazy(cycle) ? WARNING : ERROR;
+      ImmutableSet<DependencyRequest> providersBreakingCycle = providersBreakingCycle(cycle);
+      Diagnostic.Kind kind = providersBreakingCycle.isEmpty() ? ERROR : WARNING;
       if (kind == WARNING
           && (suppressCycleWarnings(rootRequestElement)
               || suppressCycleWarnings(rootRequestElement.getEnclosingElement())
-              || suppressCycleWarnings(cycle))) {
+              || suppressCycleWarnings(providersBreakingCycle))) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
@@ -1090,15 +1091,18 @@ private void reportCycle(
     }
 
     /**
-     * Returns {@code true} if any step of a dependency cycle after the first is a {@link Provider}
-     * or {@link Lazy} or a {@code Map<K, Provider<V>>}.
+     * Returns any steps in a dependency cycle that "break" the cycle. These are any
+     * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
+     * request in the cycle.
      *
      * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
      * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
      * {@link Provider#get() get()} methods are called during provision and so the cycle is not
      * really broken.
      */
-    private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
+    private ImmutableSet<DependencyRequest> providersBreakingCycle(
+        ImmutableList<DependencyRequest> cycle) {
+      ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
       for (int i = 1; i < cycle.size(); i++) {
         DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
@@ -1106,17 +1110,18 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
               i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
             } else {
-              return true;
+              providers.add(dependencyRequest);
             }
             break;
 
           case LAZY:
-            return true;
+            providers.add(dependencyRequest);
+            break;
 
           case INSTANCE:
             TypeMirror type = dependencyRequest.key().type();
             if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
-              return true;
+              providers.add(dependencyRequest);
             }
             break;
 
@@ -1124,7 +1129,7 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             break;
         }
       }
-      return false;
+      return providers.build();
     }
 
     /**
@@ -1146,8 +1151,8 @@ private boolean suppressCycleWarnings(Element requestElement) {
     return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
   }
 
-  private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathElements) {
-    for (DependencyRequest dependencyRequest : pathElements) {
+  private boolean suppressCycleWarnings(Iterable<DependencyRequest> dependencyRequests) {
+    for (DependencyRequest dependencyRequest : dependencyRequests) {
       if (suppressCycleWarnings(dependencyRequest.requestElement())) {
         return true;
       }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index d4f697393..9d902de05 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -403,7 +403,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "  }",
             "",
             "  static class B {",
-            "    @Inject B(C bParam, D dParam) {}",
+            "    @Inject B(C cParam, D dParam) {}",
             "  }",
             "",
             "  static class C {",
@@ -431,8 +431,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
                 "          [parameter: javax.inject.Provider<test.Outer.A> aParam]",
                 "      test.Outer.A.<init>(test.Outer.B bParam)",
                 "          [parameter: test.Outer.B bParam]",
-                "      test.Outer.B.<init>(test.Outer.C bParam, test.Outer.D dParam)",
-                "          [parameter: test.Outer.C bParam]");
+                "      test.Outer.B.<init>(test.Outer.C cParam, test.Outer.D dParam)",
+                "          [parameter: test.Outer.C cParam]");
     assertAbout(javaSource())
         .that(component)
         .withCompilerOptions("-Xlint:-processing", "-Xlint:-rawtypes")
@@ -462,7 +462,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "  }",
             "",
             "  static class B {",
-            "    @Inject B(C bParam, D dParam) {}",
+            "    @Inject B(C cParam, D dParam) {}",
             "  }",
             "",
             "  static class C {",
@@ -534,7 +534,53 @@ public void cyclicDependencySimpleProviderIndirectionWarningSuppressed_atDepende
     // TODO(dpb): Enable when testing warnings is released.
     //  .compilesWithoutWarnings();
   }
-  
+
+  @Ignore
+  @Test
+  public void cyclicDependencySimpleProviderIndirectionWarningNotSuppressed_atDependencyRequest() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(@SuppressWarnings(\"dependency-cycle\") C cParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .withCompilerOptions("-Xlint:-processing", "-Xlint:-rawtypes")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    // TODO(dpb): Enable when testing warnings is released.
+    //  .withWarningContaining("dependency cycle");
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
