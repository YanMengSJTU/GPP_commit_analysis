diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d9923a91f..e21e39325 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -488,6 +489,10 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
+  private boolean graphHasContributionBinding(Key key) {
+    return graph.resolvedBindings().containsKey(contribution(key));
+  }
+
   private void addFrameworkFields() {
     for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
       addField(resolvedBindings);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9ca87cf2f..cab990195 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -170,6 +170,7 @@ public SourceVersion getSupportedSourceVersion() {
         new AnnotationCreatorGenerator(filer, elements);
     UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
         new UnwrappedMapKeyGenerator(filer, elements);
+
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f4d1d9f91..acc607f48 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -132,7 +132,7 @@ KindAndType ofType(TypeMirror type) {
 
   abstract Kind kind();
   abstract Key key();
-
+  
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index dd37e9c07..a0cf43c49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -297,26 +297,16 @@ public Key apply(HasKey hasKey) {
       this.elements = checkNotNull(elements);
     }
 
-    private DeclaredType setOf(TypeMirror elementType) {
-      return types.getDeclaredType(
-          elements.getTypeElement(Set.class.getCanonicalName()), elementType);
-    }
-
-    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
-    }
-
-    private TypeElement getProviderElement() {
-      return elements.getTypeElement(Provider.class.getCanonicalName());
+    private TypeElement getClassElement(Class<?> cls) {
+      return elements.getTypeElement(cls.getCanonicalName());
     }
 
-    private TypeElement getProducerElement() {
-      return elements.getTypeElement(Producer.class.getCanonicalName());
+    private DeclaredType setOf(TypeMirror elementType) {
+      return types.getDeclaredType(getClassElement(Set.class), elementType);
     }
 
-    private TypeElement getClassElement(Class<?> cls) {
-      return elements.getTypeElement(cls.getName());
+    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+      return types.getDeclaredType(getClassElement(Map.class), keyType, valueType);
     }
 
     Key forComponentMethod(ExecutableElement componentMethod) {
@@ -356,11 +346,13 @@ Key forSubcomponentBuilder(TypeMirror builderType) {
     }
 
     Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(method, contributingModule, Optional.of(getProviderElement()));
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Provider.class)));
     }
 
     Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(method, contributingModule, Optional.of(getProducerElement()));
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Producer.class)));
     }
 
     /** Returns the key bound by a {@link Binds} method. */
@@ -386,7 +378,7 @@ private Key forBindingMethod(
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
       if (frameworkType.isPresent()
-          && frameworkType.get().equals(getProducerElement())
+          && frameworkType.get().equals(getClassElement(Producer.class))
           && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index a76585853..49c1e01a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -16,12 +16,15 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -36,28 +39,45 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
-/**
- * A representation of the scope (or lack of it) associated with a component, providing method
- * or injection location.
- */
-final class Scope {
+/** A javax.inject.Scope. */
+@AutoValue
+abstract class Scope {
+
+  /** The underlying {@link AnnotationMirror} that represents the scope annotation. */
+  abstract Equivalence.Wrapper<AnnotationMirror> scopeAnnotation();
+
   /**
-   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
    */
-  private final AnnotationMirror annotationMirror;
+  static Scope scope(AnnotationMirror scopeAnnotation) {
+    checkArgument(
+        isAnnotationPresent(
+            scopeAnnotation.getAnnotationType().asElement(), javax.inject.Scope.class));
+    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
+  }
 
-  private Scope(AnnotationMirror annotationMirror) {
-    this.annotationMirror = checkNotNull(annotationMirror);
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  static Scope scope(TypeElement scopeType) {
+    return scope(SimpleAnnotationMirror.of(scopeType));
   }
 
-  /** Returns all of the associated scoped annotations from the source code element. */
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
+    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
+  }
+
+  /** Returns all of the associated scopes for a source code element. */
   static ImmutableSet<Scope> scopesOf(Element element) {
-    return FluentIterable.from(getScopes(element)).
-        transform(new Function<AnnotationMirror, Scope>() {
-          @Override public Scope apply(AnnotationMirror annotationMirror) {
-            return new Scope(annotationMirror);
-          }
-        }).toSet();
+    return FluentIterable.from(getScopes(element))
+        .transform(
+            new Function<AnnotationMirror, Scope>() {
+              @Override
+              public Scope apply(AnnotationMirror annotationMirror) {
+                return scope(annotationMirror);
+              }
+            })
+        .toSet();
   }
 
   /**
@@ -69,7 +89,7 @@ private Scope(AnnotationMirror annotationMirror) {
     if (scopeAnnotations.isEmpty()) {
       return Optional.absent();
     }
-    return Optional.of(new Scope(Iterables.getOnlyElement(scopeAnnotations)));
+    return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
 
   /**
@@ -93,12 +113,6 @@ static Scope reusableScope(Elements elements) {
     return scope(elements, Reusable.class);
   }
 
-  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
-    return new Scope(
-        SimpleAnnotationMirror.of(
-            elements.getTypeElement(scopeAnnotationClass.getCanonicalName())));
-  }
-
   /**
    * Returns the readable source representation (name with @ prefix) of the annotation type.
    *
@@ -123,29 +137,7 @@ public String getQualifiedName() {
    * The scope annotation element.
    */
   public TypeElement scopeAnnotationElement() {
-    return MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
-  }
-
-  /**
-   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
-   * {@link AnnotationMirrors#equivalence()}.
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    } else if (obj instanceof Scope) {
-      Scope that = (Scope) obj;
-      return AnnotationMirrors.equivalence()
-        .equivalent(this.annotationMirror, that.annotationMirror);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return AnnotationMirrors.equivalence().hash(annotationMirror);
+    return MoreTypes.asTypeElement(scopeAnnotation().get().getAnnotationType());
   }
 
   /**
@@ -153,6 +145,6 @@ public int hashCode() {
    */
   @Override
   public String toString() {
-    return annotationMirror.toString();
+    return scopeAnnotation().get().toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 0c59583fb..180fc66fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -77,7 +76,11 @@ TypeMirror unwrappedElementType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(elementsAreTypeOf(wrappingClass));
+    checkArgument(
+        elementsAreTypeOf(wrappingClass),
+        "expected elements to be %s, but this type is %s",
+        wrappingClass,
+        declaredSetType());
     return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 1e3cb30ba..c1e7883c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -80,12 +80,14 @@
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
+
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
+
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
 
