diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 9fff9a199..703ebb384 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -593,10 +593,8 @@ private boolean useRawType(Optional<String> bindingPackage) {
   }
 
   /**
-   * A static member select for an empty set factory. Calls
-   * {@link SetFactory#create(javax.inject.Provider...)},
-   * {@link SetProducer#create(dagger.producers.Producer...)}, or
-   * {@link SetOfProducedProducer#create(dagger.producers.Producer...)}, depending on the set
+   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
+   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
    * bindings.
    */
   private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index d4772f3a5..5095ebbdc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -28,10 +28,5 @@ private static AnnotationSpec suppressWarnings(String value) {
     return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
   }
 
-  static final AnnotationSpec PROVIDES_SET_VALUES =
-      AnnotationSpec.builder(Provides.class)
-          .addMember("type", "$T.SET_VALUES", ClassName.get(Provides.Type.class))
-          .build();
-
   private AnnotationSpecs() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 6a2a513f4..837d0b2fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -70,16 +70,6 @@ TypeElement bindingTypeElement() {
     return contributingModule().transform(AS_DECLARED_TYPE);
   }
 
-  /**
-   * The type of {@link #bindingElement()}, considered as a member of {@link #contributingModule()}
-   * if it is present.
-   */
-  TypeMirror declaredType(Types types) {
-    return contributingModuleType().isPresent()
-        ? types.asMemberOf(contributingModuleType().get(), bindingElement())
-        : bindingElement().asType();
-  }
-
   static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
       new Function<BindingDeclaration, Set<TypeElement>>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 3cdf9832e..0a0b5b109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -199,19 +199,6 @@ public boolean apply(DependencyRequest request) {
       return builder.build();
     }
 
-    ImmutableSet<DependencyRequest> forRequiredVariables(
-        List<? extends VariableElement> variables) {
-      return FluentIterable.from(variables)
-          .transform(
-              new Function<VariableElement, DependencyRequest>() {
-                @Override
-                public DependencyRequest apply(VariableElement input) {
-                  return forRequiredVariable(input);
-                }
-              })
-          .toSet();
-    }
-
     /**
      * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
      * to satisfy the {@code mapOfValueRequest}.
@@ -481,12 +468,5 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
           },
           null);
     }
-
-    static DeclaredType getEnclosingType(Element element) {
-      while (!MoreElements.isType(element)) {
-        element = element.getEnclosingElement();
-      }
-      return MoreTypes.asDeclared(element.asType());
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 76339ca17..cbb82fc58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -205,9 +205,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
 
-  static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
-      "%s is listed as a module, but is an abstract class or interface";
-
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
       "%s is listed as a module, but is not annotated with %s";
 
@@ -268,10 +265,6 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
-  static final String PRODUCTION_COMPONENT_SCOPE =
-      "Production components may not declare any @Scope other than @ProductionScope; they are "
-          + "automatically scoped with @ProductionScope if no scope is applied.";
-
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
@@ -283,9 +276,6 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
 
   static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
 
-  static final String MALFORMED_MODULE_METHOD_FORMAT =
-      "Cannot generated a graph because method %s on module %s was malformed";
-
   static String nullableToNonNullable(String typeName, String bindingString) {
     return String.format(
             "%s is not nullable, but is being provided by %s",
@@ -450,7 +440,7 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final ProductionComponentBuilderMessages INSTANCE =
         new ProductionComponentBuilderMessages();
@@ -461,7 +451,8 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  static final class ProductionSubcomponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionSubcomponentBuilderMessages
+      extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final ProductionSubcomponentBuilderMessages INSTANCE =
         new ProductionSubcomponentBuilderMessages();
@@ -471,14 +462,6 @@ protected String process(String s) {
       return s.replaceAll("component", "production subcomponent")
           .replaceAll("Component", "ProductionSubcomponent");
     }
-
-    String builderMethodRequiresNoArgs() {
-      return "Methods returning a @ProductionSubcomponent.Builder must have no arguments";
-    }
-
-    String moreThanOneRefToSubcomponent() {
-      return "Only one method can create a given production subcomponent. %s is created by: %s";
-    }
   }
 
   /** Error messages related to {@link Multibindings @Multibindings}. */
@@ -498,7 +481,7 @@ static String tooManyMethodsForKey(String formattedKey) {
 
     private MultibindingsMessages() {}
   }
-  
+
   /**
    * Error messages related to {@link Multibinds @Multibinds} methods and methods in
    * {@link Multibindings} interfaces.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 93f88bee1..8eb4a2006 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -50,14 +49,6 @@
     return format(object);
   }
 
-  /**
-   * Formats {@code items}, one per line.
-   */
-  public void formatIndentedList(
-      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
-    formatIndentedList(builder, indentLevel, items, ImmutableList.<T>of());
-  }
-
   /**
    * Formats {@code items}, one per line. Stops after {@code limit} items.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 4343d3654..777dabe3b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -145,7 +145,7 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        CodeBlock.of("create()"),
+        CodeBlock.of("empty()"),
         SET);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c875d23c7..bfb655672 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -46,7 +46,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -62,8 +61,6 @@
     };
   }
 
-  abstract AnnotationMirror moduleAnnotation();
-
   abstract TypeElement moduleElement();
 
   abstract ImmutableSet<ModuleDescriptor> includedModules();
@@ -80,13 +77,6 @@
    */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
-  enum DefaultCreationStrategy {
-    PASSED,
-    CONSTRUCTED,
-  }
-
-  abstract DefaultCreationStrategy defaultCreationStrategy();
-
   enum Kind {
     MODULE(
         Module.class, Provides.class, ImmutableSet.of(Module.class)),
@@ -161,11 +151,9 @@
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      Optional<AnnotationMirror> probableModuleAnnotation = getModuleAnnotation(moduleElement);
-      checkState(probableModuleAnnotation.isPresent(),
+      checkState(getModuleAnnotation(moduleElement).isPresent(),
           "%s did not have an AnnotationMirror for @Module",
           moduleElement.getQualifiedName());
-      AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
@@ -194,21 +182,13 @@ ModuleDescriptor create(TypeElement moduleElement) {
         }
       }
 
-      DefaultCreationStrategy defaultCreationStrategy =
-          (componentCanMakeNewInstances(moduleElement)
-              && moduleElement.getTypeParameters().isEmpty())
-                  ? ModuleDescriptor.DefaultCreationStrategy.CONSTRUCTED
-                  : ModuleDescriptor.DefaultCreationStrategy.PASSED;
-
       return new AutoValue_ModuleDescriptor(
-          moduleAnnotation,
           moduleElement,
           ImmutableSet.copyOf(
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
-          delegates.build(),
-          defaultCreationStrategy);
+          delegates.build());
     }
 
     private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
index 4b7252cf6..b32338e93 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -21,7 +21,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** A {@link Validator} for methods in {@link Multibindings @Multibindings} interfaces. */
+/** A validator for methods in {@link Multibindings @Multibindings} interfaces. */
 final class MultibindingsMethodValidator extends MultibindsMethodValidator {
 
   MultibindingsMethodValidator(Elements elements, Types types) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 3b07faad7..d31a7d990 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -40,12 +40,12 @@
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 
 /**
- * A {@link Validator} for {@link Multibinds @Multibinds} methods or methods in
- * {@link Multibindings @Multibindings} interfaces.
+ * A validator for {@link Multibinds @Multibinds} methods or methods in {@link Multibindings
+ * @Multibindings} interfaces.
  */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
-  /** Creates a {@link Validator} for {@link Multibinds @Multibinds} methods. */
+  /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   MultibindsMethodValidator(Elements elements, Types types) {
     this(elements, types, Multibinds.class, ImmutableSet.of(Module.class, ProducerModule.class));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 6b5c00510..49d465cb3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -257,14 +257,6 @@ boolean isMultibindingContribution() {
         && contributionBinding().contributionType().isMultibinding();
   }
 
-  /**
-   * {@code true} if this is a {@linkplain ContributionBinding#isSyntheticBinding() synthetic}
-   * contribution.
-   */
-  boolean isSyntheticContribution() {
-    return contributionBindings().size() == 1 && contributionBinding().isSyntheticBinding();
-  }
-
   /**
    * Returns the single contribution binding.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index d8590efd8..0c136b3d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -105,9 +105,8 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
    *
-   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
-   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
-   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   * This does not return any annotation values as according to {@link javax.inject.Scope} scope
+   * annotations are not supposed to use them.
    */
   public String getReadableSource() {
     return stripCommonTypePrefixes("@" + getQualifiedName());
@@ -115,10 +114,6 @@ public String getReadableSource() {
 
   /**
    * Returns the fully qualified name of the annotation type.
-   *
-   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
-   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
-   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
    */
   public String getQualifiedName() {
     Preconditions.checkState(annotationMirror != null,
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index f16e38364..1b7903c22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -46,7 +45,6 @@
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import javax.inject.Provider;
 
 /**
@@ -58,11 +56,9 @@
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
-  static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
   static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
-  static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
   static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1b62f4875..2885c6ebc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -252,7 +252,7 @@ public void simpleComponent() {
             "        DoubleCheck.provider(",
             "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "                simpleComponentProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>create());",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
             "    this.bProvider = TestClass_BModule_BFactory.create(",
             "        builder.bModule, TestClass_C_Factory.create());",
             "    this.bProducer = Producers.producerFromProvider(bProvider);",
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index d2148ca18..dd0d92711 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -46,7 +46,7 @@
       };
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Factory<Set<T>> create() {
+  public static <T> Factory<Set<T>> empty() {
     return (Factory) EMPTY_FACTORY;
   }
 
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index d0c445260..390949993 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -40,8 +40,8 @@
  * @since 2.0
  */
 public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
-  public static <T> Producer<Set<T>> create() {
-    return SetProducer.create();
+  public static <T> Producer<Set<T>> empty() {
+    return SetProducer.empty();
   }
 
   /**
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index e3c0dde94..10e27e60f 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -47,7 +47,7 @@
       };
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Producer<Set<T>> create() {
+  public static <T> Producer<Set<T>> empty() {
     return (Producer) EMPTY_PRODUCER;
   }
 
