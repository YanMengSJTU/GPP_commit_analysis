diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
index 3c884159f..62da35da5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -19,6 +19,7 @@
 import dagger.Component;
 import java.util.Set;
 import test.multipackage.a.AModule;
+import test.multipackage.a.UsesInaccessible;
 import test.multipackage.sub.FooChildComponent;
 
 /**
@@ -39,4 +40,6 @@
   Set<String> setOfString();
 
   FooChildComponent fooChildComponent();
+
+  UsesInaccessible usesInaccessible();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index 01208d919..cede7c36a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -18,7 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+import java.util.HashSet;
+import java.util.Set;
+import javax.inject.Inject;
 
 @Module
 public final class AModule {
@@ -27,4 +33,28 @@
   static String provideString() {
     return "a";
   }
+
+  @Provides
+  @IntoSet
+  static Inaccessible provideInaccessible(Inaccessible inaccessible) {
+    return inaccessible;
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Inaccessible> provideSetOfInaccessibles() {
+    return new HashSet<>();
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("inaccessible")
+  static Inaccessible provideInaccessibleToMap(Inaccessible inaccessible) {
+    return inaccessible;
+  }
+
+  static class Inaccessible {
+    @Inject Inaccessible() {}
+  }
+
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
new file mode 100644
index 000000000..8dab62c78
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+
+import javax.inject.Inject;
+
+import test.multipackage.a.AModule.Inaccessible;
+
+@SuppressWarnings("unused")
+public class UsesInaccessible {
+  @Inject
+  UsesInaccessible(
+      Inaccessible inaccessible,
+      Set<Inaccessible> inaccessibleSet,
+      Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 58f54084f..1c0030a35 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -516,7 +516,14 @@ private FieldSpec addFrameworkField(
   }
 
   private boolean useRawType(ResolvedBindings resolvedBindings) {
-    Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+    return useRawType(resolvedBindings.bindingPackage());
+  }
+
+  private boolean useRawType(Binding binding) {
+    return useRawType(binding.bindingPackage());
+  }
+
+  private boolean useRawType(Optional<String> bindingPackage) {
     return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
   }
 
@@ -1084,8 +1091,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
   /**
    * The expressions that represent factory arguments for the dependencies of a binding.
    */
-  private ImmutableList<CodeBlock> getDependencyArguments(
-      Binding binding) {
+  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
       parameters.add(getDependencyArgument(frameworkDependency));
@@ -1108,10 +1114,47 @@ private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency)
   }
 
   private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    return CodeBlock.of(
-        "$T.create($L)",
-        setFactoryClassName(binding.bindingType(), binding.key()),
-        makeParametersCodeBlock(getDependencyArguments(binding)));
+    CodeBlock.Builder builder =
+        CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
+    boolean useRawTypes = useRawType(binding);
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key().type());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    builder.add("builder()");
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      builder.add(
+          ".$L($L)",
+          setFactoryBuilderMethodName(frameworkDependency),
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyArgument(frameworkDependency)));
+    }
+    return builder.add(".build()").build();
+  }
+
+  /**
+   * The method name which will add a provider for {@code binding} to the {@link
+   * dagger.internal.SetFactory.Builder}, {@link SetProducer.Builder} or {@link
+   * dagger.producers.internal.SetOfProducedProducer.Builder}.
+   */
+  private String setFactoryBuilderMethodName(FrameworkDependency frameworkDependency) {
+    ContributionType contributionType =
+        graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+    String frameworkClassName = frameworkDependency.frameworkClass().getSimpleName();
+    switch (contributionType) {
+      case SET:
+        return "add" + frameworkClassName;
+      case SET_VALUES:
+        return "addSet" + frameworkClassName;
+      default:
+        throw new AssertionError(frameworkDependency + " is not a set multibinding");
+    }
   }
 
   private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
@@ -1120,14 +1163,15 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
-    codeBlocks.add(
-        CodeBlock.of(
-            "$T.<$T, $T>builder($L)",
-            frameworkMapFactoryClassName(binding.bindingType()),
-            TypeName.get(mapType.keyType()),
-            TypeName.get(
-                mapType.unwrappedValueType(binding.bindingType().frameworkClass())),
-            frameworkDependencies.size()));
+    CodeBlock.Builder builderCall =
+        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
+    boolean useRawTypes = useRawType(binding);
+    if (!useRawTypes) {
+      builderCall.add("<$T, $T>", TypeName.get(mapType.keyType()),
+          TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));
+    }
+    builderCall.add("builder($L)", frameworkDependencies.size());
+    codeBlocks.add(builderCall.build());
 
     for (FrameworkDependency frameworkDependency : frameworkDependencies) {
       BindingKey bindingKey = frameworkDependency.bindingKey();
@@ -1137,13 +1181,23 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
           CodeBlock.of(
               ".put($L, $L)",
               getMapKeyExpression(contributionBinding.bindingElement()),
-              getDependencyArgument(frameworkDependency)));
+              potentiallyCast(
+                  useRawTypes,
+                  frameworkDependency.frameworkClass(),
+                  getDependencyArgument(frameworkDependency))));
     }
     codeBlocks.add(CodeBlock.of(".build()"));
 
     return CodeBlocks.concat(codeBlocks.build());
   }
 
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
   private static String simpleVariableName(TypeElement typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 2cb9c7890..bd3d859c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -37,6 +37,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
@@ -229,6 +230,25 @@ FactoryCreationStrategy factoryCreationStrategy() {
     }
   }
 
+  /**
+   * The {@link TypeMirror type} for the {@code Factory<T>} or {@code Producer<T>} which is created
+   * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
+   * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
+   */
+  final TypeMirror factoryType() {
+    switch (contributionType()) {
+      case MAP:
+        return MapType.from(key().type()).unwrappedValueType(frameworkClass());
+      case SET:
+        return SetType.from(key().type()).elementType();
+      case SET_VALUES:
+      case UNIQUE:
+        return key().type();
+      default:
+        throw new AssertionError();
+    }
+  }
+
   /**
    * Indexes map-multibindings by map key (the result of calling
    * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index cb2a5141e..19e3a6669 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -32,13 +32,10 @@
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
-import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -53,7 +50,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -97,11 +93,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
-    TypeMirror keyType =
-        binding.contributionType().equals(ContributionType.MAP)
-            ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
-            : binding.key().type();
-    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName providedTypeName = TypeName.get(binding.factoryType());
     ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
     Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
     TypeSpec.Builder factoryBuilder;
@@ -235,14 +227,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
-      if (binding.contributionType().equals(SET)) {
-        TypeName paramTypeName = TypeName.get(
-            MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
-        // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
-        getMethodBuilder.addStatement(
-            "return $T.<$T>singleton($L)",
-            Collections.class, paramTypeName, providesMethodInvocation);
-      } else if (binding.nullableType().isPresent()
+      if (binding.nullableType().isPresent()
           || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 14e732c65..3d1951809 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -29,8 +29,17 @@
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
- * A field that holds a {@link javax.inject.Provider}, {@link dagger.producers.Producer}, or other
- * framework type.
+ * A value object that represents a field in the generated Component class.
+ *
+ * <p>Examples:
+ * <ul>
+ *   <li>{@code Provider<String>}
+ *   <li>{@code Producer<Widget>}
+ *   <li>{@code Provider<Map<SomeMapKey, MapValue>>}.
+ * </ul>
+ *
+ * @author Jesse Beder
+ * @since 2.0
  */
 @AutoValue
 abstract class FrameworkField {
@@ -65,11 +74,18 @@ static FrameworkField forResolvedBindings(
   }
 
   private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
-    return resolvedBindings.isMultibindingContribution()
-            && resolvedBindings.contributionType().equals(ContributionType.MAP)
-        ? MapType.from(resolvedBindings.key().type())
-            .unwrappedValueType(resolvedBindings.frameworkClass())
-        : resolvedBindings.key().type();
+    if (resolvedBindings.isMultibindingContribution()) {
+      switch (resolvedBindings.contributionType()) {
+        case MAP:
+          return MapType.from(resolvedBindings.key().type())
+              .unwrappedValueType(resolvedBindings.frameworkClass());
+        case SET:
+          return SetType.from((resolvedBindings.key().type())).elementType();
+        default:
+          // do nothing
+      }
+    }
+    return resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 8fbd1d0f1..e1cbc85d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -43,12 +43,10 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
-import static dagger.internal.codegen.ContributionType.MAP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.FUTURES;
-import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
@@ -88,11 +86,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeMirror keyType =
-        binding.contributionType().equals(MAP)
-            ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
-            : binding.key().type();
-    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName providedTypeName = TypeName.get(binding.factoryType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
@@ -474,22 +468,11 @@ private CodeBlock getInvocationCodeBlock(
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
-    final CodeBlock valueCodeBlock;
-    if (binding.contributionType().equals(ContributionType.SET)) {
-      if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
-        valueCodeBlock =
-            CodeBlock.of("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
-      } else {
-        valueCodeBlock = CodeBlock.of("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
-      }
-    } else {
-      valueCodeBlock = moduleCodeBlock;
-    }
     CodeBlock returnCodeBlock =
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
-            ? valueCodeBlock
+            ? moduleCodeBlock
             : CodeBlock.of(
-                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
+                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
     return CodeBlock.of(
         Joiner.on('\n')
             .join(
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index fc1779e68..d0ec03b68 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -971,8 +971,8 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.create(",
-            "          ParentModule_ParentObjectFactory.create());",
+            "      this.setOfObjectProvider = SetFactory.<Object>builder()",
+            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
             "      this.mapOfStringAndProviderOfObjectProvider =",
             "          MapProviderFactory.<String, Object>builder(1)",
             "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
@@ -1083,7 +1083,7 @@ public void subcomponentOmitsInheritedBindings() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Set<String>> emptySetProvider;",
-            "  private Provider<Set<String>> stringProvider;",
+            "  private Provider<String> stringProvider;",
             "  private Provider<Set<String>> setOfStringProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
@@ -1105,8 +1105,11 @@ public void subcomponentOmitsInheritedBindings() {
             "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
             "    this.stringProvider =",
             "        SetModule_StringFactory.create(builder.setModule);",
-            "    this.setOfStringProvider = SetFactory.create(",
-            "        emptySetProvider, stringProvider);",
+            "    this.setOfStringProvider = ",
+            "        SetFactory.<String>builder()",
+            "            .addSetProvider(emptySetProvider)",
+            "            .addProvider(stringProvider)",
+            "            .build();",
             "  }",
             "",
             "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index d32aac54f..df2a92978 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -623,12 +623,11 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
+        "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
+        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
         "  public TestModule_ProvideStringFactory(TestModule module) {",
@@ -636,11 +635,11 @@ private String formatModuleErrorMessage(String msg) {
         "    this.module = module;",
         "  }",
         "",
-        "  @Override public Set<String> get() {",
-        "    return Collections.<String>singleton(module.provideString());",
+        "  @Override public String get() {",
+        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
         "  }",
         "",
-        "  public static Factory<Set<String>> create(TestModule module) {",
+        "  public static Factory<String> create(TestModule module) {",
         "    return new TestModule_ProvideStringFactory(module);",
         "  }",
         "}");
@@ -672,14 +671,13 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.internal.Factory;",
-        "import java.util.Collections;",
+        "import dagger.internal.Preconditions;",
         "import java.util.List;",
-        "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
         GENERATED_ANNOTATION,
         "public final class TestModule_ProvideWildcardListFactory implements "
-            + "Factory<Set<List<List<?>>>> {",
+            + "Factory<List<List<?>>> {",
         "  private final TestModule module;",
         "",
         "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
@@ -687,11 +685,11 @@ private String formatModuleErrorMessage(String msg) {
         "    this.module = module;",
         "  }",
         "",
-        "  @Override public Set<List<List<?>>> get() {",
-        "    return Collections.<List<List<?>>>singleton(module.provideWildcardList());",
+        "  @Override public List<List<?>> get() {",
+        "    return Preconditions.checkNotNull(module.provideWildcardList(), " + NPE_LITERAL + ");",
         "  }",
         "",
-        "  public static Factory<Set<List<List<?>>>> create(TestModule module) {",
+        "  public static Factory<List<List<?>>> create(TestModule module) {",
         "    return new TestModule_ProvideWildcardListFactory(module);",
         "  }",
         "}");
@@ -1040,14 +1038,13 @@ public void genericSubclassedModule() {
             "package test;",
             "",
             "import dagger.internal.Factory;",
-            "import java.util.Collections;",
-            "import java.util.Set;",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
-            "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
+            "    B, C extends Number & Comparable<C>> implements Factory<B> {",
             "  private final ParentModule<A, B, C> module;",
             "  private final Provider<B> bProvider;",
             "",
@@ -1060,12 +1057,13 @@ public void genericSubclassedModule() {
             "  }",
             "",
             "  @Override",
-            "  public Set<B> get() {  ",
-            "    return Collections.<B>singleton(module.provideBElement(bProvider.get()));",
+            "  public B get() {  ",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideBElement(bProvider.get()), " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
-            "      Factory<Set<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+            "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
             "  }",
             "}");
diff --git a/core/src/main/java/dagger/internal/Collections.java b/core/src/main/java/dagger/internal/Collections.java
index 55f26ebab..136e8e0bb 100644
--- a/core/src/main/java/dagger/internal/Collections.java
+++ b/core/src/main/java/dagger/internal/Collections.java
@@ -15,8 +15,8 @@
  */
 package dagger.internal;
 
+import java.util.HashSet;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 
 final class Collections {
   /**
@@ -28,11 +28,11 @@ private Collections() {
   }
 
   /**
-   * Creates a {@link LinkedHashSet} instance, with a high enough "initial capacity" that it
-   * <em>should</em> hold {@code expectedSize} elements without growth.
+   * Creates a {@link HashSet} instance, with a high enough "intial capcity" that it <em>should</em>
+   * hold {@code expectedSize} elements without growth.
    */
-  static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
-    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize));
+  static <T> HashSet<T> newHashSetWithExpectedSize(int expectedSize) {
+    return new HashSet<T>(calculateInitialCapacity(expectedSize));
   }
 
   /**
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index b17156cfe..9e93b3423 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -22,7 +22,8 @@
 import java.util.Set;
 import javax.inject.Provider;
 
-import static dagger.internal.Collections.newLinkedHashSetWithExpectedSize;
+import static dagger.internal.Collections.newHashSetWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
@@ -35,12 +36,6 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  /**
-   * A message for NPEs that trigger on bad argument lists.
-   */
-  private static final String ARGUMENTS_MUST_BE_NON_NULL =
-      "SetFactory.create() requires its arguments to be non-null";
-
   private static final Factory<Set<Object>> EMPTY_FACTORY =
       new Factory<Set<Object>>() {
         @Override
@@ -54,32 +49,36 @@
     return (Factory) EMPTY_FACTORY;
   }
 
-  /**
-   * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
-   * result.
-   */
-  public static <T> Factory<Set<T>> create(Factory<Set<T>> factory) {
-    assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
-    return factory;
+  public static <T> SetFactory.Builder<T> builder() {
+    return new Builder<T>();
   }
 
-  /**
-   * Returns a new factory that creates {@link Set} instances that form the union of the given
-   * {@link Provider} instances.  Callers must not modify the providers array after invoking this
-   * method; no copy is made.
-   */
-  public static <T> Factory<Set<T>> create(
-      @SuppressWarnings("unchecked") Provider<Set<T>>... providers) {
-    assert providers != null : ARGUMENTS_MUST_BE_NON_NULL;
+  public static final class Builder<T> {
+    private final List<Provider<T>> individualProviders = new ArrayList<Provider<T>>();
+    private final List<Provider<Set<T>>> setProviders = new ArrayList<Provider<Set<T>>>();
+
+    public Builder<T> addProvider(Provider<T> individualProvider) {
+      assert individualProvider != null : "Codegen error? Null provider";
+      individualProviders.add(individualProvider);
+      return this;
+    }
 
-    List<Provider<Set<T>>> contributingProviders = Arrays.asList(providers);
+    public Builder<T> addSetProvider(Provider<Set<T>> multipleProvider) {
+      assert multipleProvider != null : "Codegen error? Null provider";
+      setProviders.add(multipleProvider);
+      return this;
+    }
 
-    assert !contributingProviders.contains(null)
-        : "Codegen error?  Null within provider list.";
-    assert !hasDuplicates(contributingProviders)
-        : "Codegen error?  Duplicates in the provider list";
+    public SetFactory<T> build() {
+      assert !hasDuplicates(individualProviders)
+          : "Codegen error?  Duplicates in the provider list";
+      assert !hasDuplicates(setProviders)
+          : "Codegen error?  Duplicates in the provider list";
 
-    return new SetFactory<T>(contributingProviders);
+      return new SetFactory<T>(
+          new ArrayList<Provider<T>>(individualProviders),
+          new ArrayList<Provider<Set<T>>>(setProviders));
+    }
   }
 
   /**
@@ -90,10 +89,12 @@ private static boolean hasDuplicates(List<? extends Object> original) {
     return original.size() != asSet.size();
   }
 
-  private final List<Provider<Set<T>>> contributingProviders;
+  private final List<Provider<T>> individualProviders;
+  private final List<Provider<Set<T>>> setProviders;
 
-  private SetFactory(List<Provider<Set<T>>> contributingProviders) {
-    this.contributingProviders = contributingProviders;
+  private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>> setProviders) {
+    this.individualProviders = individualProviders;
+    this.setProviders = setProviders;
   }
 
   /**
@@ -105,32 +106,28 @@ private SetFactory(List<Provider<Set<T>>> contributingProviders) {
    */
   @Override
   public Set<T> get() {
-    int size = 0;
-
+    int size = individualProviders.size();
     // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
     // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
-    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
-    for (int i = 0, c = contributingProviders.size(); i < c; i++) {
-      Provider<Set<T>> provider = contributingProviders.get(i);
-      Set<T> providedSet = provider.get();
-      if (providedSet == null) {
-        throw new NullPointerException(provider + " returned null");
-      }
-      providedSets.add(providedSet);
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(setProviders.size());
+    for (int i = 0, c = setProviders.size(); i < c; i++) {
+      Set<T> providedSet = setProviders.get(i).get();
       size += providedSet.size();
+      providedSets.add(providedSet);
     }
 
-    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    Set<T> providedValues = newHashSetWithExpectedSize(size);
+    for (int i = 0, c = individualProviders.size(); i < c; i++) {
+      providedValues.add(checkNotNull(individualProviders.get(i).get()));
+    }
     for (int i = 0, c = providedSets.size(); i < c; i++) {
       for (T element : providedSets.get(i)) {
-        if (element == null) {
-          throw new NullPointerException("a null element was provided");
-        }
-        result.add(element);
+        providedValues.add(checkNotNull(element));
       }
     }
-    return unmodifiableSet(result);
+
+    return unmodifiableSet(providedValues);
   }
 }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index 04b982281..9b5ad90df 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -15,9 +15,8 @@
  */
 package dagger.internal;
 
-import com.google.common.collect.ContiguousSet;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Range;
+import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -28,8 +27,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.collect.DiscreteDomain.integers;
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
@@ -37,97 +35,69 @@
   @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Test
-  public void providerReturnsNullSet() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return null;
-      }
-    }, incrementingIntegerProvider(0));
+  public void providerReturnsNull() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder().addSetProvider(providerOf((Set<Integer>) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
-  public void providerReturnsNullSet_single() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return null;
-      }
-    });
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder().addProvider(providerOf((Integer) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
   public void providerReturnsSetWithNullElement() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
-        result.add(1);
-        result.add(null);
-        result.add(3);
-        return result;
-      }
-    });
-    thrown.expect(NullPointerException.class);
-    factory.get();
-  }
-
-  @Test
-  public void providerReturnsSetWithNullElement_single() {
-    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
-        result.add(1);
-        result.add(null);
-        result.add(3);
-        return result;
-      }
-    }, incrementingIntegerProvider(0));
+    Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder().addSetProvider(providerOf(set)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
-  public void invokesProvidersEverytTime() {
-    Factory<Set<Integer>> factory = SetFactory.create(
-        incrementingIntegerProvider(0),
-        incrementingIntegerProvider(10),
-        incrementingIntegerProvider(20));
-    assert_().that(factory.get()).containsExactly(0, 10, 20);
-    assert_().that(factory.get()).containsExactly(1, 11, 21);
-    assert_().that(factory.get()).containsExactly(2, 12, 22);
+  public void invokesProvidersEveryTime() {
+    Factory<Set<Integer>> factory =
+        SetFactory.<Integer>builder()
+            .addProvider(incrementingIntegerProvider(0))
+            .addProvider(incrementingIntegerProvider(10))
+            .addSetProvider(incrementingIntegerSetProvider(20))
+            .addSetProvider(incrementingIntegerSetProvider(30))
+            .build();
+    assertThat(factory.get()).containsExactly(0, 10, 20, 21, 30, 31);
+    assertThat(factory.get()).containsExactly(1, 11, 22, 23, 32, 33);
+    assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);
   }
 
-  @Test
-  public void iterationOrder() {
-    Factory<Set<Integer>> factory = SetFactory.create(
-        integerSetProvider(Range.closed(5, 9)),
-        integerSetProvider(Range.closed(3, 6)),
-        integerSetProvider(Range.closed(0, 5)));
-    assert_().that(factory.get()).containsExactly(5, 6, 7, 8, 9, 3, 4, 0, 1, 2).inOrder();
+  private static <T> Provider<T> providerOf(final T value) {
+    return new Provider<T>() {
+      @Override
+      public T get() {
+        return value;
+      }
+    };
   }
 
-  private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Set<Integer>>() {
+    return new Provider<Integer>() {
       @Override
-      public Set<Integer> get() {
-        return ImmutableSet.of(value.getAndIncrement());
+      public Integer get() {
+        return value.getAndIncrement();
       }
     };
   }
 
-  private static Provider<Set<Integer>> integerSetProvider(Range<Integer> range) {
-    final ContiguousSet<Integer> set = ContiguousSet.create(range, integers());
+  private static Provider<Set<Integer>> incrementingIntegerSetProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
     return new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
-        return set;
+        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
       }
     };
   }
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 2862f6c3c..297d8be86 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -27,6 +27,8 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
  * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
@@ -40,19 +42,52 @@
     return SetProducer.create();
   }
 
+  public static <T> SetOfProducedProducer.Builder<T> builder() {
+    return new Builder<T>();
+  }
+
+  public static final class Builder<T> {
+    private final List<Producer<T>> individualProducers = new ArrayList<Producer<T>>();
+    private final List<Producer<Set<T>>> setProducers = new ArrayList<Producer<Set<T>>>();
+
+    public Builder<T> addProducer(Producer<T> individualProducer) {
+      assert individualProducer != null : "Codegen error? Null producer";
+      individualProducers.add(individualProducer);
+      return this;
+    }
+
+    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+      assert multipleProducer != null : "Codegen error? Null producer";
+      setProducers.add(multipleProducer);
+      return this;
+    }
+
+    public SetOfProducedProducer<T> build() {
+      assert !hasDuplicates(individualProducers)
+          : "Codegen error?  Duplicates in the producer list";
+      assert !hasDuplicates(setProducers)
+          : "Codegen error?  Duplicates in the producer list";
+
+      return new SetOfProducedProducer<T>(
+          ImmutableSet.<Producer<T>>copyOf(individualProducers),
+          ImmutableSet.<Producer<Set<T>>>copyOf(setProducers));
+    }
+  }
+
   /**
-   * Returns a new producer that creates {@link Set} futures from the union of the given
-   * {@link Producer} instances.
+   * Returns true if at least one pair of items in (@code original) are equals.
    */
-  @SafeVarargs
-  public static <T> Producer<Set<Produced<T>>> create(Producer<Set<T>>... producers) {
-    return new SetOfProducedProducer<T>(ImmutableSet.copyOf(producers));
+  private static boolean hasDuplicates(List<? extends Object> original) {
+    return original.size() != ImmutableSet.copyOf(original).size();
   }
 
-  private final ImmutableSet<Producer<Set<T>>> contributingProducers;
+  private final ImmutableSet<Producer<T>> individualProducers;
+  private final ImmutableSet<Producer<Set<T>>> setProducers;
 
-  private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProducers) {
-    this.contributingProducers = contributingProducers;
+  private SetOfProducedProducer(
+      ImmutableSet<Producer<T>> individualProducers, ImmutableSet<Producer<Set<T>>> setProducers) {
+    this.individualProducers = individualProducers;
+    this.setProducers = setProducers;
   }
 
   /**
@@ -71,14 +106,19 @@ private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProduce
   @Override
   public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
-        new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
-    for (Producer<Set<T>> producer : contributingProducers) {
-      ListenableFuture<Set<T>> futureSet = producer.get();
-      if (futureSet == null) {
-        throw new NullPointerException(producer + " returned null");
-      }
-      futureProducedSets.add(Producers.createFutureProduced(futureSet));
+        new ArrayList<ListenableFuture<Produced<Set<T>>>>(
+            individualProducers.size() + setProducers.size());
+    for (Producer<T> producer : individualProducers) {
+      // TODO(ronshapiro): Don't require individual productions to be added to a set just to be
+      // materialized into futureProducedSets.
+      futureProducedSets.add(
+          Producers.createFutureProduced(
+              Producers.createFutureSingletonSet(checkNotNull(producer.get()))));
+    }
+    for (Producer<Set<T>> producer : setProducers) {
+      futureProducedSets.add(Producers.createFutureProduced(checkNotNull(producer.get())));
     }
+
     return Futures.transform(
         Futures.allAsList(futureProducedSets),
         new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 090010d65..7a5010d5a 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -25,6 +25,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
  * a future {@link Set} whose elements are populated by subsequent calls to the delegate
@@ -47,28 +49,51 @@
     return (Producer) EMPTY_PRODUCER;
   }
 
-  /**
-   * Returns the supplied producer.  If there's just one producer, there's no need to wrap it or its
-   * result.
-   */
-  public static <T> Producer<Set<T>> create(Producer<Set<T>> producer) {
-    return producer;
+  public static <T> SetProducer.Builder<T> builder() {
+    return new Builder<T>();
+  }
+
+  public static final class Builder<T> {
+    private final List<Producer<T>> individualProducers = new ArrayList<Producer<T>>();
+    private final List<Producer<Set<T>>> setProducers = new ArrayList<Producer<Set<T>>>();
+
+    public Builder<T> addProducer(Producer<T> individualProducer) {
+      assert individualProducer != null : "Codegen error? Null producer";
+      individualProducers.add(individualProducer);
+      return this;
+    }
+
+    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+      assert multipleProducer != null : "Codegen error? Null producer";
+      setProducers.add(multipleProducer);
+      return this;
+    }
+
+    public SetProducer<T> build() {
+      assert !hasDuplicates(individualProducers)
+          : "Codegen error?  Duplicates in the producer list";
+      assert !hasDuplicates(setProducers)
+          : "Codegen error?  Duplicates in the producer list";
+
+      return new SetProducer<T>(
+          ImmutableSet.copyOf(individualProducers), ImmutableSet.copyOf(setProducers));
+    }
   }
 
   /**
-   * Returns a new producer that creates {@link Set} futures from the union of the given
-   * {@link Producer} instances.
+   * Returns true if at least one pair of items in (@code original) are equals.
    */
-  @SafeVarargs
-  public static <T> Producer<Set<T>> create(Producer<Set<T>>... producers) {
-    return new SetProducer<T>(ImmutableSet.copyOf(producers));
+  private static boolean hasDuplicates(List<? extends Object> original) {
+    return original.size() != ImmutableSet.copyOf(original).size();
   }
 
-  private final Set<Producer<Set<T>>> contributingProducers;
+  private final ImmutableSet<Producer<T>> individualProducers;
+  private final ImmutableSet<Producer<Set<T>>> setProducers;
 
-  private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
-    super();
-    this.contributingProducers = contributingProducers;
+  private SetProducer(
+      ImmutableSet<Producer<T>> individualProducers, ImmutableSet<Producer<Set<T>>> setProducers) {
+    this.individualProducers = individualProducers;
+    this.setProducers = setProducers;
   }
 
   /**
@@ -85,14 +110,27 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    */
   @Override
   public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
+    List<ListenableFuture<T>> individualFutures =
+        new ArrayList<ListenableFuture<T>>(individualProducers.size());
+    for (Producer<T> producer : individualProducers) {
+      individualFutures.add(checkNotNull(producer.get()));
+    }
+
     List<ListenableFuture<Set<T>>> futureSets =
-        new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
-    for (Producer<Set<T>> producer : contributingProducers) {
-      ListenableFuture<Set<T>> futureSet = producer.get();
-      if (futureSet == null) {
-        throw new NullPointerException(producer + " returned null");
-      }
-      futureSets.add(futureSet);
+        new ArrayList<ListenableFuture<Set<T>>>(setProducers.size() + 1);
+    futureSets.add(
+        Futures.transform(
+            Futures.allAsList(individualFutures),
+            // TODO(ronshapiro): make static instances of these transformation functions
+            new Function<List<T>, Set<T>>() {
+              @Override
+              public Set<T> apply(List<T> list) {
+                return ImmutableSet.copyOf(list);
+              }
+            }));
+
+    for (Producer<Set<T>> producer : setProducers) {
+      futureSets.add(checkNotNull(producer.get()));
     }
     return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
       @Override public Set<T> apply(List<Set<T>> sets) {
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
index e36ba05a4..c8b8f59c4 100644
--- a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -38,13 +38,13 @@
   @Test
   public void success() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
+        SetOfProducedProducer.<Integer>builder()
+            .addProducer(Producers.immediateProducer(1))
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .build();
     assertThat(producer.get().get())
         .containsExactly(
             Produced.successful(1),
-            Produced.successful(2),
             Produced.successful(5),
             Produced.successful(7));
   }
@@ -53,18 +53,21 @@ public void success() throws Exception {
   public void failure() throws Exception {
     RuntimeException e = new RuntimeException("monkey");
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateFailedProducer(e));
+        SetOfProducedProducer.<Integer>builder()
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addProducer(Producers.<Integer>immediateFailedProducer(e))
+            .build();
     assertThat(producer.get().get())
         .containsExactly(
             Produced.successful(1), Produced.successful(2), Produced.<Integer>failed(e));
   }
 
   @Test
-  public void delegateSetNpe() throws Exception {
+  public void delegateNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(Producers.<Set<Integer>>immediateProducer(null));
+        SetOfProducedProducer.<Integer>builder()
+            .addProducer(Producers.<Integer>immediateProducer(null))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
@@ -73,13 +76,13 @@ public void delegateSetNpe() throws Exception {
   }
 
   @Test
-  public void oneOfDelegateSetNpe() throws Exception {
+  public void delegateSetNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(null),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(7, 3)));
+        SetOfProducedProducer.<Integer>builder()
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
-    assertThat(results.successes).containsExactly(3, 7);
+    assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
     assertThat(Iterables.getOnlyElement(results.failures).getCause())
         .isInstanceOf(NullPointerException.class);
@@ -88,8 +91,10 @@ public void oneOfDelegateSetNpe() throws Exception {
   @Test
   public void delegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+        SetOfProducedProducer.<Integer>builder()
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
     assertThat(results.failures).hasSize(1);
@@ -100,8 +105,11 @@ public void delegateElementNpe() throws Exception {
   @Test
   public void oneOfDelegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
-        SetOfProducedProducer.create(
-            Producers.<Set<Integer>>immediateProducer(Sets.newHashSet(Arrays.asList(5, 2, null))));
+        SetOfProducedProducer.<Integer>builder()
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(
+                    Sets.newHashSet(Arrays.asList(5, 2, null))))
+            .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).containsExactly(2, 5);
     assertThat(results.failures).hasSize(1);
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index a38830f0a..158c37785 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -33,19 +33,22 @@
  */
 @RunWith(JUnit4.class)
 public class SetProducerTest {
-  @Test public void success() throws Exception {
+  @Test
+  public void success() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
-    assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
+        SetProducer.<Integer>builder()
+            .addProducer(Producers.immediateProducer(1))
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .build();
+    assertThat(producer.get().get()).containsExactly(1, 5, 7);
   }
 
-  @Test public void delegateSetNpe() throws Exception {
+  @Test
+  public void delegateNpe() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(null));
+        SetProducer.<Integer>builder()
+            .addProducer(Producers.<Integer>immediateProducer(null))
+            .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -55,11 +58,29 @@
     }
   }
 
-  @Test public void delegateElementNpe() throws Exception {
+  @Test
+  public void delegateSetNpe() throws Exception {
     Producer<Set<Integer>> producer =
-        SetProducer.create(
-            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
-            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+        SetProducer.<Integer>builder()
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .build();
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  @Test
+  public void delegateElementNpe() throws Exception {
+    Producer<Set<Integer>> producer =
+        SetProducer.<Integer>builder()
+            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addSetProducer(
+                Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
+            .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
