diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index db890b246..5b791b674 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -476,31 +476,26 @@ private void addField(ResolvedBindings resolvedBindings) {
     Optional<String> bindingPackage = bindingPackageFor(resolvedBindings.bindings());
     boolean useRawType = bindingPackage.isPresent()
         && !bindingPackage.get().equals(name.packageName());
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+    if (resolvedBindings.isMultibindings()) {
       ImmutableSet<ContributionBinding> contributionBindings =
           resolvedBindings.contributionBindings();
-      if (ContributionBinding.contributionTypeFor(contributionBindings).isMultibinding()) {
-        // note that here we rely on the order of the resolved bindings being from parent to child
-        // otherwise, the numbering wouldn't work
-        int contributionNumber = 0;
-        for (ContributionBinding contributionBinding : contributionBindings) {
-          if (!contributionBinding.isSyntheticBinding()) {
-            contributionNumber++;
-            if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
-              FrameworkField contributionBindingField =
-                  FrameworkField.createForSyntheticContributionBinding(
-                      contributionNumber, contributionBinding);
-              FieldWriter contributionField =
-                  addFrameworkField(useRawType, contributionBindingField);
-
-              ImmutableList<String> contributionSelectTokens =
-                  new ImmutableList.Builder<String>()
-                      .add(contributionField.name())
-                      .build();
-              multibindingContributionSnippets.put(
-                  contributionBinding,
-                  MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
-            }
+      // note that here we rely on the order of the resolved bindings being from parent to child
+      // otherwise, the numbering wouldn't work
+      int contributionNumber = 0;
+      for (ContributionBinding contributionBinding : contributionBindings) {
+        if (!contributionBinding.isSyntheticBinding()) {
+          contributionNumber++;
+          if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
+            FrameworkField contributionBindingField =
+                FrameworkField.createForSyntheticContributionBinding(
+                    contributionNumber, contributionBinding);
+            FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
+
+            ImmutableList<String> contributionSelectTokens =
+                ImmutableList.of(contributionField.name());
+            multibindingContributionSnippets.put(
+                contributionBinding,
+                MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index ec9f4bbdc..701f8b21b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -60,7 +60,6 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Sets.union;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -123,9 +122,7 @@
             new Function<ResolvedBindings, Set<ContributionBinding>>() {
               @Override
               public Set<ContributionBinding> apply(ResolvedBindings input) {
-                return (input.bindingKey().kind().equals(CONTRIBUTION))
-                    ? input.contributionBindings()
-                    : ImmutableSet.<ContributionBinding>of();
+                return input.contributionBindings();
               }
             })
         .transformAndConcat(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f8010c301..90c27c3fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -717,34 +717,33 @@ void validateComponentScope() {
       Scope componentScope = subject.componentDescriptor().scope();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
-        if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-          for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-            Scope bindingScope = contributionBinding.scope();
-            if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
-              // Scoped components cannot reference bindings to @Provides methods or @Inject
-              // types decorated by a different scope annotation. Unscoped components cannot
-              // reference to scoped @Provides methods or @Inject types decorated by any
-              // scope annotation.
-              switch (contributionBinding.bindingKind()) {
-                case PROVISION:
-                  ExecutableElement provisionMethod =
-                      MoreElements.asExecutable(contributionBinding.bindingElement());
-                  incompatiblyScopedMethodsBuilder.add(
-                      methodSignatureFormatter.format(provisionMethod));
-                  break;
-                case INJECTION:
-                  incompatiblyScopedMethodsBuilder.add(
-                      bindingScope.getReadableSource()
-                          + " class "
-                          + contributionBinding.bindingTypeElement().getQualifiedName());
-                  break;
-                default:
-                  throw new IllegalStateException();
-              }
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
+          Scope bindingScope = contributionBinding.scope();
+          if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+            // Scoped components cannot reference bindings to @Provides methods or @Inject
+            // types decorated by a different scope annotation. Unscoped components cannot
+            // reference to scoped @Provides methods or @Inject types decorated by any
+            // scope annotation.
+            switch (contributionBinding.bindingKind()) {
+              case PROVISION:
+                ExecutableElement provisionMethod =
+                    MoreElements.asExecutable(contributionBinding.bindingElement());
+                incompatiblyScopedMethodsBuilder.add(
+                    methodSignatureFormatter.format(provisionMethod));
+                break;
+              case INJECTION:
+                incompatiblyScopedMethodsBuilder.add(
+                    bindingScope.getReadableSource()
+                        + " class "
+                        + contributionBinding.bindingTypeElement().getQualifiedName());
+                break;
+              default:
+                throw new IllegalStateException();
             }
           }
         }
       }
+
       ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
       if (!incompatiblyScopedMethods.isEmpty()) {
         TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 024097ef0..f95ce4a57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -25,7 +25,6 @@
 import com.google.common.collect.Multimap;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
@@ -96,35 +95,26 @@
   }
 
   /**
-   * All contribution bindings, regardless of owning component.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#CONTRIBUTION}.
+   * All contribution bindings, regardless of owning component. Empty if this is a members-injection
+   * binding.
    */
   ImmutableSet<ContributionBinding> contributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
   /**
-   * The contribution bindings that were resolved in {@link #owningComponent()}.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#CONTRIBUTION}.
+   * The contribution bindings that were resolved in {@link #owningComponent()}. Empty if this is a
+   * members-injection binding.
    */
   ImmutableSet<ContributionBinding> ownedContributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
     return allContributionBindings().get(owningComponent());
   }
 
   /**
-   * The members-injection binding, regardless of owning component.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   * The members-injection binding, regardless of owning component. Empty if these are contribution
+   * bindings.
    */
   Optional<MembersInjectionBinding> membersInjectionBinding() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         FluentIterable.from(allMembersInjectionBindings().values()).toSet();
     return membersInjectionBindings.isEmpty()
@@ -133,13 +123,10 @@
   }
 
   /**
-   * The members-injection binding that was resolved in {@link #owningComponent()}.
-   *
-   * @throws IllegalStateException if {@link #bindingKey()} is not a
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   * The members-injection binding that was resolved in {@link #owningComponent()}. Empty if these
+   * are contribution bindings.
    */
   Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
     return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
@@ -212,8 +199,7 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
    * {@code true} if this is a multibindings contribution.
    */
   boolean isMultibindings() {
-    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && !contributionBindings().isEmpty()
+    return !contributionBindings().isEmpty()
         && contributionTypeFor(contributionBindings()).isMultibinding();
   }
 
@@ -221,8 +207,7 @@ boolean isMultibindings() {
    * {@code true} if this is a unique contribution binding.
    */
   boolean isUniqueContribution() {
-    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && !contributionBindings().isEmpty()
+    return !contributionBindings().isEmpty()
         && !contributionTypeFor(contributionBindings()).isMultibinding();
   }
 }
