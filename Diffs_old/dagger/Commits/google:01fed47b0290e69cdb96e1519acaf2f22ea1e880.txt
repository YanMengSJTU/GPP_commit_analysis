diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
new file mode 100644
index 000000000..561ad4a89
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = MultibindingProducerModule.class)
+interface MultibindingComponent {
+  ListenableFuture<Set<String>> strs();
+  ListenableFuture<Integer> strCount();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
new file mode 100644
index 000000000..407e78813
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
@@ -0,0 +1,49 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+@ProducerModule
+final class MultibindingProducerModule {
+  @Produces(type = SET) ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("foo");
+  }
+
+  @Produces(type = SET) String str() {
+    return "bar";
+  }
+
+  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
+    return Futures.immediateFuture(ImmutableSet.of("foo1", "foo2"));
+  }
+
+  @Produces(type = SET_VALUES) Set<String> strs() {
+    return ImmutableSet.of("bar1", "bar2");
+  }
+
+  @Produces int strCount(Set<String> strs) {
+    return strs.size();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
new file mode 100644
index 000000000..d20de2384
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test public void multibinding() throws Exception {
+    MultibindingComponent multibindingComponent = Dagger_MultibindingComponent.builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index c44e4f69b..187b71e7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -61,6 +61,7 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
@@ -94,7 +95,6 @@
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -562,22 +562,22 @@ private void writeFields(BindingGraph input,
           // otherwise, the numbering wouldn't work
           int contributionNumber = 0;
           for (ContributionBinding contributionBinding : contributionBindings) {
-            if (isSytheticProvisionBinding(contributionBinding)) {
+            if (!contributionBinding.isSyntheticBinding()) {
               contributionNumber++;
               if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
                 FrameworkField contributionBindingField =
-                    frameworkFieldForSyntheticProvisionBinding(
+                    frameworkFieldForSyntheticContributionBinding(
                           bindingKey, contributionNumber, contributionBinding);
                 FieldWriter contributionField = classWithFields.addField(
                     contributionBindingField.frameworkType(), contributionBindingField.name());
                 contributionField.addModifiers(fieldModifiers);
 
-                ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
+                ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
                     .addAll(proxySelector.asSet())
                     .add(contributionField.name())
                     .build();
                 multibindingContributionSnippetsBuilder.put(contributionBinding,
-                    Snippet.memberSelectSnippet(contirubtionSelectTokens));
+                    Snippet.memberSelectSnippet(contributionSelectTokens));
               }
             }
           }
@@ -693,40 +693,33 @@ private void initializeFrameworkTypes(BindingGraph input,
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
-                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
-                    .isEmpty()) {
-                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
-                  ImmutableSet<ProvisionBinding> provisionBindings =
-                      (ImmutableSet<ProvisionBinding>) bindings;
-                  ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                  for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (multibindingContributionSnippets.containsKey(provisionBinding)) {
-                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          snippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              componentWriter.name(),
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields,
-                              memberSelectSnippets));
-                      parameterSnippets.add(snippet);
-                    } else if (parentMultibindingContributionSnippets
-                        .containsKey(provisionBinding)) {
-                      parameterSnippets.add(
-                          parentMultibindingContributionSnippets.get(provisionBinding));
-                    } else {
-                      throw new IllegalStateException();
-                    }
+                boolean hasOnlyProvisions =
+                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
+                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+                for (ContributionBinding binding : bindings) {
+                  if (multibindingContributionSnippets.containsKey(binding)) {
+                    Snippet initializeSnippet = initializeFactoryForContributionBinding(
+                        binding,
+                        input,
+                        componentWriter.name(),
+                        componentContributionFields,
+                        memberSelectSnippets);
+                    Snippet snippet = multibindingContributionSnippets.get(binding);
+                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+                    parameterSnippets.add(snippet);
+                  } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
+                    parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
+                  } else {
+                    throw new IllegalStateException();
                   }
-                  Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                      ClassName.fromClass(SetFactory.class),
-                      Snippet.makeParametersSnippet(parameterSnippets.build()));
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet, initializeSetSnippet);
-                } else {
-                  // TODO(user): Implement producer set bindings.
-                  throw new IllegalStateException("producer set bindings not implemented yet");
                 }
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    hasOnlyProvisions
+                        ? ClassName.fromClass(SetFactory.class)
+                        : ClassName.fromClass(SetProducer.class),
+                    Snippet.makeParametersSnippet(parameterSnippets.build()));
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
                 if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
@@ -780,7 +773,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                           input.componentDescriptor().dependencyMethodIndex(),
                           componentContributionFields, memberSelectSnippets));
                 } else {
-                  throw new IllegalStateException();
+                  throw new AssertionError();
                 }
                 break;
               default:
@@ -804,41 +797,30 @@ private void initializeFrameworkTypes(BindingGraph input,
     }
   }
 
-  private static FrameworkField frameworkFieldForSyntheticProvisionBinding(BindingKey bindingKey,
+  private static FrameworkField frameworkFieldForSyntheticContributionBinding(BindingKey bindingKey,
       int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
-    FrameworkField contributionBindingField;
     switch (contributionBinding.bindingType()) {
       case MAP:
-        contributionBindingField = FrameworkField.createForMapBindingContribution(
-            Provider.class,
+        return FrameworkField.createForMapBindingContribution(
+            contributionBinding.frameworkClass(),
             BindingKey.create(bindingKey.kind(), contributionBinding.key()),
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       case SET:
-        contributionBindingField = FrameworkField.createWithTypeFromKey(
-            Provider.class,
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       case UNIQUE:
-        contributionBindingField = FrameworkField.createWithTypeFromKey(
-            Provider.class,
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       default:
         throw new AssertionError();
     }
-    return contributionBindingField;
-  }
-
-  private static boolean isSytheticProvisionBinding(ContributionBinding contributionBinding) {
-    return !(contributionBinding instanceof ProvisionBinding
-        && ((ProvisionBinding) contributionBinding)
-            .bindingKind().equals(SYNTHETIC_PROVISON));
   }
 
   private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
@@ -908,6 +890,31 @@ public String visitType(TypeElement e, Void p) {
     }
   }
 
+  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding,
+      BindingGraph input,
+      ClassName componentName,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    if (binding instanceof ProvisionBinding) {
+      return initializeFactoryForProvisionBinding(
+          (ProvisionBinding) binding,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else if (binding instanceof ProductionBinding) {
+      return initializeFactoryForProductionBinding(
+          (ProductionBinding) binding,
+          input,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else {
+      throw new AssertionError();
+    }
+}
+
   private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
       ClassName componentName,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 2a7c617d9..0630dfc7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.Ordering;
 import java.util.EnumSet;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
@@ -49,7 +50,7 @@ boolean isMultibinding() {
   }
 
   abstract BindingType bindingType();
-  
+
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -61,6 +62,20 @@ boolean isMultibinding() {
    */
   abstract Optional<TypeElement> contributedBy();
 
+  /**
+   * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
+   * implicitly by the framework.
+   */
+  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
+  // this field the source of truth for synthetic bindings.
+  abstract boolean isSyntheticBinding();
+
+  /**
+   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
+   * ProvisionBinding.
+   */
+  abstract Class<?> frameworkClass();
+
   /**
    * Returns the set of {@link BindingType} enum values implied by a given
    * {@link ContributionBinding} collection.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index f92bf94c0..38d45e6a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
 import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -53,6 +54,11 @@
     IMMEDIATE,
     /** Represents a binding configured by {@link Produces} that returns a future. */
     FUTURE_PRODUCTION,
+    /**
+     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC_PRODUCTION,
     /**
      * Represents a binding from a production method on a component dependency that returns a
      * future. Methods that return immediate values are considered provision bindings.
@@ -87,6 +93,16 @@ BindingType bindingType() {
     }
   }
 
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Producer.class;
+  }
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -146,7 +162,7 @@ ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.FUTURE_PRODUCTION,
+          Kind.SYNTHETIC_PRODUCTION,
           Produces.Type.MAP,
           ImmutableList.<TypeMirror>of());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index ba5aaed38..1d660a9e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.Sets;
 import dagger.Provides;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -122,6 +123,16 @@ BindingType bindingType() {
     }
   }
 
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Provider.class;
+  }
+
   enum FactoryCreationStrategy {
     ENUM_INSTANCE,
     CLASS_CONSTRUCTOR,
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
new file mode 100644
index 000000000..234ff7ebd
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
+ * a future {@link Set} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetProducer<T> extends AbstractProducer<Set<T>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  public static <T> Producer<Set<T>> create(
+      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+    return new SetProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final Set<Producer<Set<T>>> contributingProducers;
+
+  private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
+   * producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then this future will fail
+   * with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * delegate futures fails or is canceled, this one is, too.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<T>> compute() {
+    List<ListenableFuture<Set<T>>> futureSets = new ArrayList<>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureSets.add(futureSet);
+    }
+    return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
+      @Override public Set<T> apply(List<Set<T>> sets) {
+        ImmutableSet.Builder<T> builder = new ImmutableSet.Builder<>();
+        for (Set<T> set : sets) {
+          builder.addAll(set);
+        }
+        return builder.build();
+      }
+    });
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
new file mode 100644
index 000000000..ac4c741ff
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link SetProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetProducerTest {
+  @Test public void success() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer(ImmutableSet.of(1, 2)),
+        immediateProducer(ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
+  }
+
+  @Test public void delegateSetNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer(ImmutableSet.of(1, 2)),
+        immediateProducer(null));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  @Test public void delegateElementNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer(ImmutableSet.of(1, 2)),
+        immediateProducer(Collections.singleton(null)));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  private static final class ImmediateProducer<T> implements Producer<T> {
+    private final T value;
+
+    ImmediateProducer(T value) {
+      this.value = value;
+    }
+
+    @Override public ListenableFuture<T> get() {
+      return Futures.immediateFuture(value);
+    }
+  }
+
+  private static <T> Producer<T> immediateProducer(T value) {
+    return new ImmediateProducer<T>(value);
+  }
+}
