diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 9019aa657..3fbbee24c 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -24,16 +24,17 @@
  * injected, you can also inject {@code Produced<T>}, which enables handling of any exceptions that
  * were thrown during the production of {@code T}.
  *
- * <p>For example: <pre>   {@code
- *
- *   @Produces Html getResponse(UserInfo criticalInfo, Produced<ExtraInfo> noncriticalInfo) {
+ * <p>For example: <pre><code>
+ *   {@literal @}Produces Html getResponse(
+ *       UserInfo criticalInfo, {@literal Produced<ExtraInfo>} noncriticalInfo) {
  *     try {
  *       return new Html(criticalInfo, noncriticalInfo.get());
  *     } catch (ExecutionException e) {
  *       logger.warning(e, "Noncritical info");
  *       return new Html(criticalInfo);
  *     }
- *   }}</pre>
+ *   }
+ * </code></pre>
  *
  * @author Jesse Beder
  */
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
index 5aeb4a03d..eb159bbf6 100644
--- a/producers/src/main/java/dagger/producers/Producer.java
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -24,66 +24,68 @@
  * produces the {@code T} until {@link #get} is called.
  *
  * <p>For example, you might inject {@code Producer} to lazily choose between several different
- * implementations of some type: <pre>   {@code
- *
- *   @Produces ListenableFuture<Heater> getHeater(
+ * implementations of some type: <pre><code>
+ *   {@literal @Produces ListenableFuture<Heater>} getHeater(
  *       HeaterFlag flag,
- *       @Electric Producer<Heater> electricHeater,
- *       @Gas Producer<Heater> gasHeater) {
+ *       {@literal @Electric Producer<Heater>} electricHeater,
+ *       {@literal @Gas Producer<Heater>} gasHeater) {
  *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();
- *   }}</pre>
+ *   }
+ * </code></pre>
  *
  * <p>Here is a complete example that demonstrates how calling {@code get()} will cause each
- * method to be executed: <pre>   {@code
+ * method to be executed: <pre><code>
  *
- *   @ProducerModule
+ *   {@literal @}ProducerModule
  *   final class MyModule {
- *     @Produces ListenableFuture<A> a() {
+ *     {@literal @Produces ListenableFuture<A>} a() {
  *       System.out.println("a");
  *       return Futures.immediateFuture(new A());
  *     }
  *
- *     @Produces ListenableFuture<B> b(A a) {
+ *     {@literal @Produces ListenableFuture<B>} b(A a) {
  *       System.out.println("b");
  *       return Futures.immediateFuture(new B(a));
  *     }
  *
- *     @Produces ListenableFuture<C> c(B b) {
+ *     {@literal @Produces ListenableFuture<C>} c(B b) {
  *       System.out.println("c");
  *       return Futures.immediateFuture(new C(b));
  *     }
  *
- *     @Produces @Delayed ListenableFuture<C> delayedC(A a, Producer<C> c) {
+ *     {@literal @Produces @Delayed ListenableFuture<C>} delayedC(A a, {@literal Producer<C>} c) {
  *       System.out.println("delayed c");
  *       return c.get();
  *     }
  *   }
  *
- *   @ProductionComponent(modules = MyModule.class)
+ *   {@literal @}ProductionComponent(modules = MyModule.class)
  *   interface MyComponent {
- *     @Delayed ListenableFuture<C> delayedC();
- *   }}</pre>
+ *     {@literal @Delayed ListenableFuture<C>} delayedC();
+ *   }
+ * </code></pre>
  * Suppose we instantiate the generated implementation of this component and call
- * {@code delayedC()}: <pre>   {@code
- *
+ * {@code delayedC()}: <pre><code>
  *   MyComponent component = DaggerMyComponent
  *       .builder()
  *       .executor(MoreExecutors.directExecutor())
  *       .build();
  *   System.out.println("Constructed component");
- *   ListenableFuture<C> cFuture = component.delayedC();
+ *   {@literal ListenableFuture<C>} cFuture = component.delayedC();
  *   System.out.println("Retrieved future");
  *   C c = cFuture.get();
- *   System.out.println("Retrieved c");}</pre>
+ *   System.out.println("Retrieved c");
+ * </code></pre>
  * Here, we're using {@code MoreExecutors.directExecutor} in order to illustrate how each call
- * directly causes code to execute. The above code will print: <pre>   {@code
+ * directly causes code to execute. The above code will print: <pre><code>
  *   Constructed component
  *   a
  *   delayed c
  *   b
  *   c
  *   Retrieved future
- *   Retrieved c}</pre>
+ *   Retrieved c
+ * </code></pre>
  *
  * @author Jesse Beder
  */
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index e4fe125ba..6aa9ea8f0 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -45,11 +45,11 @@
  * Production methods have no arguments and return either a {@link ListenableFuture} or
  * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
  * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
- * are all valid production method declarations: <pre>   {@code
- *
+ * are all valid production method declarations: <pre><code>
  *   ListenableFuture<SomeType> getSomeType();
- *   Producer<Set<SomeType>> getSomeTypes();
- *   @Response ListenableFuture<Html> getResponse();}</pre>
+ *   {@literal Producer<Set<SomeType>>} getSomeTypes();
+ *   {@literal @Response ListenableFuture<Html>} getResponse();
+ * </code></pre>
  *
  * <h2>Exceptions</h2>
  *
