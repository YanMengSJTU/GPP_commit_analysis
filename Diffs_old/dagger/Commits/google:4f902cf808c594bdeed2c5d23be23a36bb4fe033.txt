diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 0c143f026..558ee7d4d 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -250,6 +250,7 @@ java_library(
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
         "GeneratedComponentModel.java",
+        "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
@@ -265,6 +266,7 @@ java_library(
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
+        "MissingBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 7f72b64ef..92c0233ec 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -249,13 +249,20 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
   }
 
   private BindingExpression getBindingExpression(Key key, RequestKind requestKind) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
-    if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
-      if (!expressions.contains(key, requestKind)) {
-        expressions.put(key, requestKind, createBindingExpression(resolvedBindings, requestKind));
-      }
+    if (expressions.contains(key, requestKind)) {
       return expressions.get(key, requestKind);
     }
+    Optional<BindingExpression> expression = Optional.empty();
+    if (resolvedInThisComponent(key, requestKind)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+      expression = Optional.of(createBindingExpression(resolvedBindings, requestKind));
+    } else if (!resolvableBinding(key, requestKind) && generatedComponentModel.isAbstract()) {
+      expression = Optional.of(new MissingBindingExpression(key));
+    }
+    if (expression.isPresent()) {
+      expressions.put(key, requestKind, expression.get());
+      return expression.get();
+    }
     checkArgument(parent.isPresent(), "no expression found for %s-%s", key, requestKind);
     return parent.get().getBindingExpression(key, requestKind);
   }
@@ -263,6 +270,9 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
   /** Creates a binding expression. */
   private BindingExpression createBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
+    if (generatedInstanceForAbstractSubcomponent(resolvedBindings)) {
+      return new GeneratedInstanceBindingExpression(resolvedBindings);
+    }
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(requestKind.equals(RequestKind.MEMBERS_INJECTION));
@@ -279,6 +289,37 @@ private BindingExpression createBindingExpression(
     }
   }
 
+  /**
+   * Returns true if the binding exposes an instance of a generated type, but no concrete
+   * implementation of that type is available.
+   */
+  private boolean generatedInstanceForAbstractSubcomponent(ResolvedBindings resolvedBindings) {
+    return !resolvedBindings.contributionBindings().isEmpty()
+        && resolvedBindings.contributionBinding().requiresGeneratedInstance()
+        && generatedComponentModel.isAbstract();
+  }
+
+  /**
+   * Returns true if the binding can be resolved by the graph for this component or any parent
+   * component.
+   */
+  private boolean resolvableBinding(Key key, RequestKind requestKind) {
+    for (ComponentBindingExpressions expressions = this;
+        expressions != null;
+        expressions = expressions.parent.orElse(null)) {
+      if (expressions.resolvedInThisComponent(key, requestKind)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if the binding can be resolved by the graph for this component. */
+  private boolean resolvedInThisComponent(Key key, RequestKind requestKind) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
+  }
+
   /**
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 4b89ebe4c..a9f6aff16 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -24,6 +24,7 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -76,14 +77,15 @@ ClassName name() {
   }
 
   static Optional<ComponentBuilder> create(
-      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
     return hasBuilder(graph.componentDescriptor())
         ? Optional.of(
-            new Creator(componentName, graph, subcomponentNames, elements, types).create())
+            new Creator(generatedComponentModel, graph, subcomponentNames, elements, types)
+                .create())
         : Optional.empty();
   }
 
@@ -97,20 +99,20 @@ private static boolean hasBuilder(ComponentDescriptor component) {
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
-    private final ClassName componentName;
+    private final GeneratedComponentModel generatedComponentModel;
     private final ClassName builderName;
     private final Elements elements;
     private final Types types;
-    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
     Creator(
-        ClassName componentName,
+        GeneratedComponentModel generatedComponentModel,
         BindingGraph graph,
         SubcomponentNames subcomponentNames,
         Elements elements,
         Types types) {
-      this.componentName = componentName;
-      if (graph.componentDescriptor().kind().isTopLevel()) {
+      this.generatedComponentModel = generatedComponentModel;
+      ClassName componentName = generatedComponentModel.name();
+      if (!generatedComponentModel.isNested()) {
         builderName = componentName.nestedClass("Builder");
         builder = classBuilder(builderName).addModifiers(STATIC);
       } else {
@@ -125,21 +127,30 @@ private static boolean hasBuilder(ComponentDescriptor component) {
 
     ComponentBuilder create() {
       if (builderSpec().isPresent()) {
-        builder.addModifiers(PRIVATE);
+        if (generatedComponentModel.isAbstract()) {
+          builder.addModifiers(PROTECTED);
+        } else {
+          builder.addModifiers(PRIVATE);
+        }
         addSupertype(builder, builderSpec().get().builderDefinitionType());
       } else {
         builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
 
-      builderFields = builderFields(graph);
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
+
+      if (generatedComponentModel.isAbstract()) {
+        builder.addModifiers(ABSTRACT);
+      } else {
+        builder.addModifiers(FINAL);
+        builder.addMethod(buildMethod(builderFields)); // Can only instantiate concrete classes.
+      }
 
       builder
-          .addModifiers(FINAL)
           .addFields(builderFields.values())
-          .addMethod(buildMethod())
           // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
           // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods());
+          .addMethods(builderMethods(builderFields));
 
       return new ComponentBuilder(builder.build(), builderName, builderFields);
     }
@@ -160,7 +171,7 @@ ComponentBuilder create() {
       return builderFields.build();
     }
 
-    private MethodSpec buildMethod() {
+    private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       MethodSpec.Builder buildMethod;
       if (builderSpec().isPresent()) {
         ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
@@ -195,7 +206,7 @@ private MethodSpec buildMethod() {
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", componentName);
+      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
       return buildMethod.build();
     }
 
@@ -203,7 +214,8 @@ private MethodSpec buildMethod() {
      * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
      * is present, it will tailor the methods to match the spec.
      */
-    private ImmutableSet<MethodSpec> builderMethods() {
+    private ImmutableSet<MethodSpec> builderMethods(
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
       if (builderSpec().isPresent()) {
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index 200efb09f..be99cfe8b 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -32,6 +32,7 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -62,11 +63,16 @@ static GeneratedComponentModel buildComponentModel(
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
-    GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    GeneratedComponentModel generatedComponentModel;
+    if (graph.componentDescriptor().kind().isTopLevel()) {
+      generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    } else {
+      generatedComponentModel = GeneratedComponentModel.forBaseSubcomponent(name);
+    }
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
     OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
     Optional<ComponentBuilder> builder =
-        ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+        ComponentBuilder.create(generatedComponentModel, graph, subcomponentNames, elements, types);
     ComponentRequirementFields componentRequirementFields =
         new ComponentRequirementFields(graph, generatedComponentModel, builder);
     ComponentBindingExpressions bindingExpressions =
@@ -79,7 +85,23 @@ static GeneratedComponentModel buildComponentModel(
             types,
             elements,
             compilerOptions);
-    if (graph.componentDescriptor().kind().isTopLevel()) {
+    if (generatedComponentModel.isAbstract()) {
+      checkState(
+          compilerOptions.aheadOfTimeSubcomponents(),
+          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
+          graph.componentDescriptor().componentDefinitionType());
+      return new BaseSubcomponentModelBuilder(
+              types,
+              elements,
+              graph,
+              generatedComponentModel,
+              subcomponentNames,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              builder)
+          .build();
+    } else {
       return new RootComponentModelBuilder(
               types,
               elements,
@@ -92,41 +114,24 @@ static GeneratedComponentModel buildComponentModel(
               builder)
           .build();
     }
-    checkState(
-        compilerOptions.aheadOfTimeSubcomponents(),
-        "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
-        graph.componentDescriptor().componentDefinitionType());
-    return new BaseSubcomponentModelBuilder(
-            types,
-            elements,
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            optionalFactories,
-            bindingExpressions,
-            componentRequirementFields,
-            builder)
-        .build();
   }
 
   private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
     ClassName parentName = generatedComponentModel.name();
     ClassName childName =
         parentName.nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel childGeneratedComponentModel =
-        GeneratedComponentModel.forSubcomponent(childName);
+    GeneratedComponentModel childModel = GeneratedComponentModel.forSubcomponent(childName);
     Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(childName, childGraph, subcomponentNames, elements, types);
+        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
-        componentRequirementFields.forChildComponent(
-            childGraph, childGeneratedComponentModel, childBuilder);
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
     ComponentBindingExpressions childBindingExpressions =
         bindingExpressions.forChildComponent(
-            childGraph, childGeneratedComponentModel, childComponentRequirementFields);
+            childGraph, childModel, childComponentRequirementFields);
     return new SubComponentModelBuilder(
             this,
             childGraph,
-            childGeneratedComponentModel,
+            childModel,
             childBindingExpressions,
             childComponentRequirementFields,
             childBuilder)
@@ -170,7 +175,7 @@ private ComponentModelBuilder(
    * called once (and will throw on successive invocations). If the component must be regenerated,
    * use a new instance.
    */
-  protected GeneratedComponentModel build() {
+  protected final GeneratedComponentModel build() {
     checkState(
         !done,
         "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
@@ -218,7 +223,7 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
   }
 
-  private void addSubcomponents() {
+  protected void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
       generatedComponentModel.addSubcomponent(buildSubcomponentModel(subgraph));
     }
@@ -233,7 +238,9 @@ private void addConstructor() {
 
     ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
     MethodSpec.Builder constructor =
-        constructorBuilder().addModifiers(PRIVATE).addParameters(constructorParameters);
+        constructorBuilder()
+            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
+            .addParameters(constructorParameters);
 
     ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
     CodeBlock initializeParametersCodeBlock =
@@ -275,6 +282,8 @@ private void addConstructor() {
       return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
     } else if (graph.factoryMethod().isPresent()) {
       return getFactoryMethodParameterSpecs(graph);
+    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
+      return ImmutableList.of();
     } else {
       throw new AssertionError(
           "Expected either a component builder or factory method but found neither.");
@@ -405,7 +414,6 @@ private DeclaredType parentType() {
   }
 
   /** Builds the model for a top-level abstract base implementation of a subcomponent. */
-  // TODO(b/72748365): Implement.
   private static final class BaseSubcomponentModelBuilder extends ComponentModelBuilder {
     private final GeneratedComponentModel generatedComponentModel;
 
@@ -433,15 +441,19 @@ private DeclaredType parentType() {
     }
 
     @Override
-    protected GeneratedComponentModel build() {
-      return generatedComponentModel;
+    protected void addBuilderClass(TypeSpec builder) {
+      generatedComponentModel.addType(SUBCOMPONENT, builder);
     }
 
     @Override
-    protected void addBuilderClass(TypeSpec builder) {}
+    protected void addFactoryMethods() {
+      // Only construct instances of subcomponents that have concrete implementations.
+    }
 
     @Override
-    protected void addFactoryMethods() {}
+    protected void addSubcomponents() {
+      // TODO(b/72748365): Implement abstract inner subcomponents.
+    }
   }
 
   /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index f38fbdaec..62d6aa6fc 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -113,7 +113,8 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     if (componentBuilder.isPresent()) {
       FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
       return new BuilderField(requirement, generatedComponentModel, builderField);
-    } else if (graph.factoryMethodParameters().containsKey(requirement)) {
+    } else if (graph.factoryMethod().isPresent()
+        && graph.factoryMethodParameters().containsKey(requirement)) {
       ParameterSpec factoryParameter =
           ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
       return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9b7685103..c58a980b3 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -164,6 +164,17 @@ final boolean isSyntheticMultibinding() {
     }
   }
 
+  /** Whether the bound type has a generated implementation. */
+  final boolean requiresGeneratedInstance() {
+    switch (kind()) {
+      case COMPONENT:
+      case SUBCOMPONENT_BUILDER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Returns {@link BindingKind#MULTIBOUND_SET} or {@link
    * BindingKind#MULTIBOUND_MAP} if the key is a set or map.
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 3476160e1..01d986b06 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -18,6 +18,7 @@
 
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -33,9 +34,11 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -107,6 +110,8 @@
   }
 
   private final ClassName name;
+  private final NestingKind nestingKind;
+  private final boolean isAbstract;
   private final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
@@ -119,17 +124,23 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
 
-  private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
+  private GeneratedComponentModel(ClassName name, NestingKind nestingKind, Modifier... modifiers) {
     this.name = name;
+    this.nestingKind = nestingKind;
+    this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
     this.component = classBuilder(name).addModifiers(modifiers);
   }
 
   static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(name, PUBLIC, FINAL);
+    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, FINAL);
   }
 
   static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, PRIVATE, FINAL);
+    return new GeneratedComponentModel(name, NestingKind.MEMBER, PRIVATE, FINAL);
+  }
+
+  static GeneratedComponentModel forBaseSubcomponent(ClassName name) {
+    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, ABSTRACT);
   }
 
   /** Returns the name of the component. */
@@ -137,6 +148,16 @@ ClassName name() {
     return name;
   }
 
+  /** Returns whether or not the implementation is nested within another class. */
+  boolean isNested() {
+    return nestingKind.isNested();
+  }
+
+  /** Returns whether or not the implementation is abstract. */
+  boolean isAbstract() {
+    return isAbstract;
+  }
+
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
   boolean isTypeAccessible(TypeMirror type) {
     return isTypeAccessibleFrom(type, name.packageName());
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
new file mode 100644
index 000000000..112154433
--- /dev/null
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that requires an
+ * instance of a generated type. This expression is used in abstract implementations of a
+ * subcomponent when there are no concrete definitions of generated types available. The
+ * (unimplemented) method is added to the {@code GeneratedComponentModel} when this dependency
+ * expression is requested. The method is overridden when generating the concrete implementation of
+ * an ancestor component.
+ */
+final class GeneratedInstanceBindingExpression extends BindingExpression {
+  private final Key key;
+
+  GeneratedInstanceBindingExpression(ResolvedBindings resolvedBindings) {
+    this.key = resolvedBindings.key();
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
new file mode 100644
index 000000000..197c388c6
--- /dev/null
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that is missing
+ * when generating the abstract base class implementation of a subcomponent. The (unimplemented)
+ * method is added to the {@link GeneratedComponentModel} when the dependency expression is
+ * requested. The method is overridden when generating the implementation of an ancestor component.
+ */
+final class MissingBindingExpression extends BindingExpression {
+  private final Key key;
+
+  MissingBindingExpression(Key key) {
+    this.key = key;
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 890bdadbc..ac1b7cdbf 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -33,6 +33,67 @@
 public final class AheadOfTimeSubcomponentsTest {
   @Test
   public void simpleSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides String provideString() { return \"florp\"; }",
+            "}");
+
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  private TestModule testModule;",
+            "",
+            "  protected DaggerChild() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testModule = new TestModule();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(subcomponent, module);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void subcomponent_MissingBinding() {
     JavaFileObject subcomponent =
         JavaFileObjects.forSourceLines(
             "test.Child",
@@ -44,6 +105,7 @@ public void simpleSubcomponent() {
             "interface Child {",
             "  String string();",
             "}");
+
     JavaFileObject generatedSubcomponent =
         JavaFileObjects.forSourceLines(
             "test.DaggerChild",
@@ -51,7 +113,14 @@ public void simpleSubcomponent() {
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerChild {}");
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return null;",
+            "  }",
+            "}");
     Compilation compilation =
         daggerCompiler()
             .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
@@ -61,4 +130,103 @@ public void simpleSubcomponent() {
         .generatedSourceFile("test.DaggerChild")
         .hasSourceEquivalentTo(generatedSubcomponent);
   }
+
+  @Test
+  public void subcomponent_BuilderAndGeneratedInstanceBinding() {
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  Integer i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GrandchildModule module);",
+            "",
+            "    Grandchild build();",
+            "  }",
+            "}");
+
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides static Integer provideInteger() { return 0; }",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Integer i() {",
+            "    return GrandchildModule_ProvideIntegerFactory.proxyProvideInteger();",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements Grandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Grandchild.Builder grandchild();",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public Grandchild.Builder grandchild() {",
+            "    return null;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(child, grandchild, grandchildModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
 }
