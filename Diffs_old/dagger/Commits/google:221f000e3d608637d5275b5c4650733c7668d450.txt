diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/android/ActivityKey.java
deleted file mode 100644
index 772ff1b7f..000000000
--- a/java/dagger/android/ActivityKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.app.Activity;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of an {@link Activity}.
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface ActivityKey {
-  Class<? extends Activity> value();
-}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 58c162364..4e496f86b 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -16,11 +16,6 @@
 
 package dagger.android;
 
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.Service;
-import android.content.BroadcastReceiver;
-import android.content.ContentProvider;
 import dagger.Module;
 import dagger.internal.Beta;
 import dagger.multibindings.Multibinds;
@@ -35,51 +30,10 @@
 @Module
 public abstract class AndroidInjectionModule {
   @Multibinds
-  abstract Map<Class<?>, AndroidInjector.Factory<?>> allInjectorFactories();
+  abstract Map<Class<?>, AndroidInjector.Factory<?>> classKeyedInjectorFactories();
 
   @Multibinds
-  abstract Map<String, AndroidInjector.Factory<?>> allInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
-      activityInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
-      activityInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
-      fragmentInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
-      fragmentInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
-      serviceInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Service>>
-      serviceInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<
-          Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
-      broadcastReceiverInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
-      broadcastReceiverInjectorFactoriesWithStringKeys();
-
-  @Multibinds
-  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
-      contentProviderInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
-      contentProviderInjectorFactoriesWithStringKeys();
+  abstract Map<String, AndroidInjector.Factory<?>> stringKeyedInjectorFactories();
 
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BroadcastReceiverKey.java b/java/dagger/android/BroadcastReceiverKey.java
deleted file mode 100644
index db2974a0e..000000000
--- a/java/dagger/android/BroadcastReceiverKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.content.BroadcastReceiver;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface BroadcastReceiverKey {
-  Class<? extends BroadcastReceiver> value();
-}
diff --git a/java/dagger/android/ContentProviderKey.java b/java/dagger/android/ContentProviderKey.java
deleted file mode 100644
index 44123a4c6..000000000
--- a/java/dagger/android/ContentProviderKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.content.ContentProvider;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of a {@link ContentProvider}.
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface ContentProviderKey {
-  Class<? extends ContentProvider> value();
-}
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 86fddf511..9b6518066 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -54,15 +54,8 @@
   @Inject
   DispatchingAndroidInjector(
       Map<Class<?>, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithClassKeys,
-      Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithStringKeys,
-      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
-          boundedInjectorFactoriesWithClassKeys,
-      Map<String, Provider<AndroidInjector.Factory<? extends T>>>
-          boundedInjectorFactoriesWithStringKeys) {
-    this.injectorFactories =
-        secondaryMerge(
-            merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys),
-            merge(boundedInjectorFactoriesWithClassKeys, boundedInjectorFactoriesWithStringKeys));
+      Map<String, Provider<AndroidInjector.Factory<?>>> injectorFactoriesWithStringKeys) {
+    this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
   }
 
   /**
@@ -95,26 +88,6 @@
     return Collections.unmodifiableMap(safeCast);
   }
 
-  /**
-   * Merges the results of {@link #merge(Map, Map)} calls into one map.
-   *
-   * <p>An SPI plugin verifies the logical uniqueness of the keysets of these two (merged) maps so
-   * we're assured there's no overlap.
-   */
-  private static <K, V> Map<K, V> secondaryMerge(Map<K, V> firstMap, Map<K, V> secondMap) {
-    if (firstMap.isEmpty()) {
-      return secondMap;
-    }
-    if (secondMap.isEmpty()) {
-      return firstMap;
-    }
-
-    Map<K, V> merged = newLinkedHashMapWithExpectedSize(firstMap.size() + secondMap.size());
-    merged.putAll(firstMap);
-    merged.putAll(secondMap);
-    return merged;
-  }
-
   /**
    * Attempts to perform members-injection on {@code instance}, returning {@code true} if
    * successful, {@code false} otherwise.
diff --git a/java/dagger/android/FragmentKey.java b/java/dagger/android/FragmentKey.java
deleted file mode 100644
index 9c987dce8..000000000
--- a/java/dagger/android/FragmentKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.app.Fragment;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of a {@link Fragment}.
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface FragmentKey {
-  Class<? extends Fragment> value();
-}
diff --git a/java/dagger/android/ServiceKey.java b/java/dagger/android/ServiceKey.java
deleted file mode 100644
index 7bd88ce9d..000000000
--- a/java/dagger/android/ServiceKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.app.Service;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of a {@link Service}.
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface ServiceKey {
-  Class<? extends Service> value();
-}
diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 094259561..7c5ae073f 100644
--- a/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -20,7 +20,6 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.android.processor.AndroidMapKeys.frameworkTypesByMapKey;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -33,9 +32,7 @@
 import com.squareup.javapoet.TypeName;
 import dagger.Module;
 import dagger.android.ContributesAndroidInjector;
-import java.lang.annotation.Annotation;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
@@ -122,22 +119,11 @@
       builder.enclosingModule(ClassName.get(enclosingElement));
 
       TypeMirror injectedType = method.getReturnType();
-      Optional<? extends Class<? extends Annotation>> maybeMapKeyAnnotation =
-          frameworkTypesByMapKey(elements)
-              .entrySet()
-              .stream()
-              .filter(entry -> types.isAssignable(injectedType, entry.getValue()))
-              .map(Map.Entry::getKey)
-              .findFirst();
-      if (maybeMapKeyAnnotation.isPresent()) {
-        if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
-          builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
-        } else {
-          reporter.reportError(
-              "@ContributesAndroidInjector methods cannot return parameterized types");
-        }
+      if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
+        builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
       } else {
-        reporter.reportError(String.format("%s is not a framework type", injectedType));
+        reporter.reportError(
+            "@ContributesAndroidInjector methods cannot return parameterized types");
       }
 
       AnnotationMirror annotation =
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index 4003918de..9bc521086 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -20,15 +20,11 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.android.processor.AndroidMapKeys.frameworkTypesByMapKey;
 import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
 import dagger.MapKey;
@@ -46,7 +42,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
@@ -69,7 +64,6 @@
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
     return ImmutableSet.<Class<? extends Annotation>>builder()
-        .addAll(frameworkTypesByMapKey(elements).keySet())
         .add(AndroidInjectionKey.class)
         .add(ClassKey.class)
         .build();
@@ -99,16 +93,21 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       if (suppressedWarnings == null
           || !ImmutableSet.copyOf(suppressedWarnings.value())
               .contains("dagger.android.ScopedInjectorFactory")) {
+        AnnotationMirror mapKeyAnnotation =
+            getOnlyElement(getAnnotatedAnnotations(method, MapKey.class));
+        TypeElement mapKeyValueElement =
+            elements.getTypeElement(injectedTypeFromMapKey(mapKeyAnnotation).get());
         messager.printMessage(
             Kind.ERROR,
             String.format(
-                "%s bindings should not be scoped. Scoping this method may leak instances of %s. ",
-                AndroidInjector.Factory.class.getCanonicalName(), frameworkTypeForMapKey(method)),
+                "%s bindings should not be scoped. Scoping this method may leak instances of %s.",
+                AndroidInjector.Factory.class.getCanonicalName(),
+                mapKeyValueElement.getQualifiedName()),
             method);
       }
     }
 
-    validateReturnTypeMatchesMapKey(method, annotation);
+    validateReturnType(method);
 
     // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
     // in javac, so do a basic check for valid form
@@ -117,51 +116,17 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
     }
   }
 
-  /**
-   * Report an error if the method's return type doesn't match the expectations for the map key
-   * annotation.
-   *
-   * <ul>
-   *   <li>Methods annotated with {@code @ClassKey} must return {@code AndroidInjector.Factory<?>}.
-   *   <li>Methods annotated with {@code @AndroidInjectionKey} must return either {@code
-   *       AndroidInjector.Factory<?>} or {@code AndroidInjector.Factory<? extends AndroidType>},
-   *       where {@code AndroidType} is the Android component type extended by the map key class.
-   *   <li>Methods annotated with {@code @ActivityKey}, {@code FragmentKey}, etc., must return
-   *       {@code AndroidInjector.Factory<? extends Activity>}, {@code AndroidInjector.Factory<?
-   *       extends Fragment>}, etc.
-   * </ul>
-   */
-  private void validateReturnTypeMatchesMapKey(
-      ExecutableElement method, Class<? extends Annotation> mapKeyType) {
-    WildcardType any = types.getWildcardType(null, null);
-    WildcardType anyExtendsFrameworkType =
-        types.getWildcardType(frameworkTypeForMapKey(method), null);
-
-    if (mapKeyType == ClassKey.class) {
-      validateReturnType(method, injectorFactoryOf(any));
-    } else if (mapKeyType == AndroidInjectionKey.class) {
-      validateReturnType(
-          method,
-          injectorFactoryOf(any) ,
-          injectorFactoryOf(anyExtendsFrameworkType));
-    } else {
-      validateReturnType(method, injectorFactoryOf(anyExtendsFrameworkType));
-    }
-  }
-
-  private void validateReturnType(
-      ExecutableElement method,
-      DeclaredType idealReturnType,
-      DeclaredType... otherPossibleReturnTypes) {
-    Equivalence<TypeMirror> equivalence = MoreTypes.equivalence();
+  /** Report an error if the method's return type is not {@code AndroidInjector.Factory<?>}. */
+  private void validateReturnType(ExecutableElement method) {
     TypeMirror returnType = method.getReturnType();
-    if (Lists.asList(idealReturnType, otherPossibleReturnTypes).stream()
-        .noneMatch(validReturnType -> equivalence.equivalent(validReturnType, returnType))) {
+    DeclaredType requiredReturnType = injectorFactoryOf(types.getWildcardType(null, null));
+
+    if (!types.isSameType(returnType, requiredReturnType)) {
       messager.printMessage(
           Kind.ERROR,
           String.format(
               "%s should bind %s, not %s. See https://google.github.io/dagger/android",
-              method, idealReturnType, returnType),
+              method, requiredReturnType, returnType),
           method);
     }
   }
@@ -175,8 +140,8 @@ private void validateReturnType(
    * <pre>{@code
    * {@literal @Binds}
    * {@literal @IntoMap}
-   * {@literal @ActivityKey(GreenActivity.class)}
-   * abstract AndroidInjector.Factory<? extends Activity> bindBlueActivity(
+   * {@literal @ClassKey(GreenActivity.class)}
+   * abstract AndroidInjector.Factory<?> bindBlueActivity(
    *     BlueActivityComponent.Builder builder);
    * }</pre>
    */
@@ -195,20 +160,6 @@ private void validateMapKeyMatchesBindsParameter(
     }
   }
 
-  /** Returns the framework type that {@code method}'s map key annotation represents. */
-  private TypeMirror frameworkTypeForMapKey(ExecutableElement method) {
-    AnnotationMirror mapKeyAnnotation =
-        getOnlyElement(getAnnotatedAnnotations(method, MapKey.class));
-    TypeMirror mapKeyType =
-        elements.getTypeElement(injectedTypeFromMapKey(mapKeyAnnotation).get()).asType();
-    return frameworkTypesByMapKey(elements)
-        .values()
-        .stream()
-        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
-        .findFirst()
-        .get();
-  }
-
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index af011f8d0..fb1fc3853 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -17,78 +17,19 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static java.util.stream.Collectors.toMap;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableMap;
-import dagger.MapKey;
 import dagger.android.AndroidInjectionKey;
-import java.lang.annotation.Annotation;
-import java.util.List;
 import java.util.Optional;
-import java.util.stream.Stream;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.Elements;
 
 final class AndroidMapKeys {
-
-  /**
-   * Returns the Android framework types available to the compiler, keyed by their associated {@code
-   * dagger.android} {@link MapKey}s. This will always contain the types that are defined by the
-   * framework, and only contain the support library types if they are on the classpath of the
-   * current compilation.
-   */
-  static ImmutableMap<Class<? extends Annotation>, TypeMirror> frameworkTypesByMapKey(
-      Elements elements) {
-    return ImmutableMap.copyOf(
-        Stream.of(
-                elements.getPackageElement("dagger.android"),
-                elements.getPackageElement("dagger.android.support"))
-            .filter(packageElement -> packageElement != null)
-            .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
-            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
-            .filter(type -> isAnnotationPresent(type, MapKey.class))
-            .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
-            .flatMap(AndroidMapKeys::classForAnnotationElement)
-            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
-  }
-
-  private static boolean isNotAndroidInjectionKey(TypeElement type) {
-    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
-  }
-
-  private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
-    try {
-      @SuppressWarnings("unchecked")
-      Class<? extends Annotation> clazz =
-          (Class<? extends Annotation>) Class.forName(type.getQualifiedName().toString());
-      return Stream.of(clazz);
-    } catch (ClassNotFoundException e) {
-      return Stream.of();
-    }
-  }
-
-  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
-    List<ExecutableElement> mapKeyMethods =
-        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
-    TypeMirror returnType = getOnlyElement(mapKeyMethods).getReturnType();
-    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
-    return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
-        .getExtendsBound();
-  }
-
   /**
    * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
-   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
-   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   * it's {@link dagger.multibindings.ClassKey}, returns the fully-qualified class name of the
+   * annotation value. Otherwise returns {@link Optional#empty()}.
    */
   static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
     Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 85b277a97..d78b0cb39 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -16,29 +16,16 @@
 
 package dagger.android.support;
 
-import android.support.v4.app.Fragment;
 import dagger.Module;
 import dagger.android.AndroidInjectionModule;
-import dagger.android.AndroidInjector;
 import dagger.internal.Beta;
-import dagger.multibindings.Multibinds;
-import java.util.Map;
 
 /**
- * Configures bindings to ensure the usability of {@code dagger.android} and {@code
- * dagger.android.support} framework classes. This module should be installed in the root-most
- * component which will use these types.
+ * This module no longer provides any value beyond what is provided in {@link
+ * AndroidInjectionModule} and is just an alias. It will be removed in a future release.
  */
 @Beta
 @Module(includes = AndroidInjectionModule.class)
 public abstract class AndroidSupportInjectionModule {
-  @Multibinds
-  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
-      supportFragmentInjectorFactories();
-
-  @Multibinds
-  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
-      supportFragmentInjectorFactoriesWithStringKeys();
-
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
deleted file mode 100644
index 090e34da9..000000000
--- a/java/dagger/android/support/FragmentKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android.support;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import android.support.v4.app.Fragment;
-import dagger.MapKey;
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * {@link MapKey} annotation to key bindings by a type of a {@link Fragment}.
- *
- * @deprecated Use {@link dagger.multibindings.ClassKey} instead. See <a
- *     href="https://google.github.io/dagger/android">https://google.github.io/dagger/android</a>.
- */
-@Beta
-@MapKey
-@Documented
-@Target(METHOD)
-@Deprecated
-public @interface FragmentKey {
-  Class<? extends Fragment> value();
-}
diff --git a/java/dagger/errorprone/AndroidInjectorBindingMigrator.java b/java/dagger/errorprone/AndroidInjectorBindingMigrator.java
deleted file mode 100644
index 91c26b6ec..000000000
--- a/java/dagger/errorprone/AndroidInjectorBindingMigrator.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.errorprone;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.errorprone.BugPattern.SeverityLevel.SUGGESTION;
-import static com.google.errorprone.util.ASTHelpers.getSymbol;
-import static com.google.errorprone.util.ASTHelpers.getType;
-import static com.google.errorprone.util.ASTHelpers.hasAnnotation;
-
-import com.google.errorprone.BugPattern;
-import com.google.errorprone.BugPattern.ProvidesFix;
-import com.google.errorprone.VisitorState;
-import com.google.errorprone.bugpatterns.BugChecker;
-import com.google.errorprone.bugpatterns.BugChecker.MethodTreeMatcher;
-import com.google.errorprone.fixes.SuggestedFix;
-import com.google.errorprone.matchers.Description;
-import com.sun.source.tree.AnnotationTree;
-import com.sun.source.tree.MethodTree;
-import com.sun.tools.javac.code.Symbol;
-import com.sun.tools.javac.code.Type;
-import com.sun.tools.javac.code.Type.ClassType;
-import com.sun.tools.javac.code.Type.WildcardType;
-import com.sun.tools.javac.code.Types;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.IntoMap;
-
-/** A refactoring to update AndroidInjector bindings to their new form. */
-@BugPattern(
-    name = "AndroidInjectorBindingMigrator",
-    providesFix = ProvidesFix.REQUIRES_HUMAN_ATTENTION,
-    summary = "A refactoring to update AndroidInjector bindings to their new form.",
-    explanation =
-        "dagger.android is migrating the mechanism used to bind AndroidInjectors. This refactoring "
-            + "will migrate usages of the `dagger.android` class-based map keys to "
-            + "`@dagger.multibindings.ClassKey` and also modify the return type of those binding "
-            + "methods to AndroidInjector.Factory<?> (from AndroidInjector.Factory<? "
-            + "extends Activity>).",
-    severity = SUGGESTION)
-public final class AndroidInjectorBindingMigrator extends BugChecker implements MethodTreeMatcher {
-  private static final String ANDROID_INJECTOR_FACTORY = "dagger.android.AndroidInjector$Factory";
-  private static final String CLASS_KEY = ClassKey.class.getName();
-  private static final String ANDROID_INJECTION_KEY = "dagger.android.AndroidInjectionKey";
-
-  @Override
-  public Description matchMethod(MethodTree tree, VisitorState state) {
-    if (!hasAnnotation(tree, IntoMap.class, state)) {
-      return Description.NO_MATCH;
-    }
-
-    Symbol androidInjectorFactory = state.getSymbolFromString(ANDROID_INJECTOR_FACTORY);
-
-    if (androidInjectorFactory == null) {
-      return Description.NO_MATCH;
-    }
-
-    SuggestedFix.Builder suggestedFix = SuggestedFix.builder();
-    Types types = state.getTypes();
-
-    if (!androidInjectorFactory.equals(getSymbol(tree.getReturnType()))) {
-      return Description.NO_MATCH;
-    }
-
-    ClassType bindingType = (ClassType) getType(tree.getReturnType());
-    if (bindingType.isParameterized()) {
-      Type typeParameter = getOnlyElement(bindingType.getTypeArguments());
-      if (typeParameter instanceof WildcardType
-          && ((WildcardType) typeParameter).getExtendsBound() != null) {
-        suggestedFix.replace(tree.getReturnType(), "AndroidInjector.Factory<?>");
-      }
-    }
-
-    Type classKey = state.getTypeFromString(CLASS_KEY);
-    Type androidInjectionKey = state.getTypeFromString(ANDROID_INJECTION_KEY);
-    for (AnnotationTree annotationTree : tree.getModifiers().getAnnotations()) {
-      Type annotationType = getType(annotationTree.getAnnotationType());
-
-      if (hasAnnotation(annotationType.tsym, "dagger.MapKey", state)
-          && !types.isSameType(annotationType, classKey)
-          && !types.isSameType(annotationType, androidInjectionKey)) {
-        suggestedFix.replace(annotationTree.getAnnotationType(), "ClassKey").addImport(CLASS_KEY);
-      }
-    }
-
-    if (suggestedFix.isEmpty()) {
-      return Description.NO_MATCH;
-    }
-
-    return buildDescription(tree).addFix(suggestedFix.build()).build();
-  }
-}
diff --git a/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
new file mode 100644
index 000000000..c2d90249e
--- /dev/null
+++ b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.errorprone;
+
+import static com.google.errorprone.BugPattern.SeverityLevel.SUGGESTION;
+
+import com.google.errorprone.BugPattern;
+import com.google.errorprone.BugPattern.ProvidesFix;
+import com.google.errorprone.VisitorState;
+import com.google.errorprone.bugpatterns.BugChecker;
+import com.google.errorprone.bugpatterns.BugChecker.MemberSelectTreeMatcher;
+import com.google.errorprone.fixes.SuggestedFix;
+import com.google.errorprone.matchers.Description;
+import com.google.errorprone.matchers.Matcher;
+import com.google.errorprone.matchers.Matchers;
+import com.google.errorprone.util.ASTHelpers;
+import com.sun.source.tree.ExpressionTree;
+import com.sun.source.tree.MemberSelectTree;
+import com.sun.tools.javac.code.Symbol;
+
+/** A refactoring to update AndroidInjector bindings to their new form. */
+@BugPattern(
+    name = "AndroidSupportInjectionModuleMigrator",
+    providesFix = ProvidesFix.REQUIRES_HUMAN_ATTENTION,
+    summary = "Inlines usages of AndroidSupportInjectionModule to AndroidInjectionModule",
+    explanation =
+        "AndroidSupportInjectionModule is now an empty module and acts as an alias for "
+            + "AndroidInjectionModule. This migration rewrites usages of the former to the latter.",
+    severity = SUGGESTION)
+public final class AndroidSupportInjectionModuleMigrator extends BugChecker
+    implements MemberSelectTreeMatcher {
+  private static final Matcher<ExpressionTree> MODULE_CLASS_LITERAL =
+      Matchers.classLiteral(
+          (ExpressionTree expressionTree, VisitorState state) -> {
+            Symbol symbol = ASTHelpers.getSymbol(expressionTree);
+            if (symbol == null) {
+              return false;
+            }
+            return symbol
+                .getQualifiedName()
+                .contentEquals("dagger.android.support.AndroidSupportInjectionModule");
+          });
+
+  @Override
+  public Description matchMemberSelect(MemberSelectTree tree, VisitorState state) {
+    if (MODULE_CLASS_LITERAL.matches(tree, state)) {
+      return buildDescription(tree)
+          .addFix(
+              SuggestedFix.builder()
+                  .replace(tree, "AndroidInjectionModule.class")
+                  .addImport("dagger.android.AndroidInjectionModule")
+                  .build())
+          .build();
+    }
+    return Description.NO_MATCH;
+  }
+}
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
index 024a70418..cfa6e90b5 100644
--- a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -50,14 +50,6 @@
           "import android.app.Activity;",
           "",
           "public class BarActivity extends Activity {}");
-  private static final JavaFileObject BAZ_FRAGMENT =
-      JavaFileObjects.forSourceLines(
-          "test.BazFragment",
-          "package test;",
-          "",
-          "import android.app.Fragment;",
-          "",
-          "public class BazFragment extends Fragment {}");
 
   private static JavaFileObject moduleWithMethod(String... lines) {
     return JavaFileObjects.forSourceLines(
@@ -148,85 +140,6 @@ public void providesToBuilderNotFactory() {
                 + "dagger.android.AndroidInjector.Builder<?>");
   }
 
-  @Test
-  public void mapKeyDoesntMatchCoreType() {
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@FragmentKey(BazFragment.class)",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
-            "    FooActivity.Builder builder);");
-    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "should bind dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, "
-                + "not dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
-  }
-
-  @Test
-  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@AndroidInjectionKey(\"test.BazFragment\")",
-            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
-            "    FooActivity.Builder builder);");
-    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "should bind dagger.android.AndroidInjector.Factory<?>, not "
-                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
-  }
-
-  @Test
-  public void mapKeyDoesntMatchCoreType_supportFragments() {
-    JavaFileObject supportFragment =
-        JavaFileObjects.forSourceLines(
-            "test.SupportFragment",
-            "package test;",
-            "",
-            "import android.support.v4.app.Fragment;",
-            "import dagger.android.AndroidInjector;",
-            "",
-            "public class SupportFragment extends Fragment {",
-            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
-            "}");
-
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@dagger.android.FragmentKey(BazFragment.class)",
-            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
-            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
-    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "should bind dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, "
-                + "not dagger.android.AndroidInjector.Factory<? extends "
-                + "android.support.v4.app.Fragment>");
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
-        .inFile(module)
-        .onLine(LINES_BEFORE_METHOD + 3);
-  }
-
   @Test
   public void bindsToConcreteTypeInsteadOfWildcard() {
     JavaFileObject module =
@@ -261,19 +174,6 @@ public void bindsToBaseTypeInsteadOfWildcard() {
 
   @Test
   public void bindsCorrectType() {
-    JavaFileObject module =
-        moduleWithMethod(
-            "@Binds",
-            "@IntoMap",
-            "@ActivityKey(FooActivity.class)",
-            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
-            "    FooActivity.Builder builder);");
-    Compilation compilation = compile(module, FOO_ACTIVITY);
-    assertThat(compilation).succeededWithoutWarnings();
-  }
-
-  @Test
-  public void bindsCorrectType_unbounded() {
     JavaFileObject module =
         moduleWithMethod(
             "@Binds",
@@ -291,8 +191,7 @@ public void bindsCorrectType_AndroidInjectionKey() {
             "@Binds",
             "@IntoMap",
             "@AndroidInjectionKey(\"test.FooActivity\")",
-            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
-            "    FooActivity.Builder builder);");
+            "abstract AndroidInjector.Factory<?> bindCorrectType(FooActivity.Builder builder);");
     Compilation compilation = compile(module, FOO_ACTIVITY);
     assertThat(compilation).succeededWithoutWarnings();
   }
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
index 7ac0d53ac..1718737cb 100644
--- a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -156,30 +156,6 @@ public void parameterizedReturnType() {
         .onLineContaining("test()");
   }
 
-  @Test
-  public void notAFrameworkType() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.android.ContributesAndroidInjector;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @ContributesAndroidInjector",
-            "  abstract android.content.Intent intent();",
-            "}");
-
-    Compilation compilation = compile(module);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("is not a framework type")
-        .inFile(module)
-        .onLineContaining("intent()");
-  }
-
   @Test
   public void moduleIsntModule() {
     JavaFileObject module =
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
index fac8789fa..a84c7eba9 100644
--- a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -75,19 +75,6 @@ public void conflictingMapKeys() {
             "  @IntoMap",
             "  @AndroidInjectionKey(\"test.TestActivity\")",
             "  AndroidInjector.Factory<?> stringKey(TestInjectorFactory factory);",
-            "",
-            "  @Binds",
-            "  @IntoMap",
-            "  @ActivityKey(TestActivity.class)",
-            "  AndroidInjector.Factory<? extends Activity> boundedClassKey(",
-            "      TestInjectorFactory factory);",
-            "",
-            "  @Binds",
-            "  @IntoMap",
-            "  @AndroidInjectionKey(\"test.TestActivity\")",
-            "  AndroidInjector.Factory<? extends Activity> boundedStringKey(",
-            "      TestInjectorFactory factory);",
-
             "}");
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
@@ -114,9 +101,6 @@ public void conflictingMapKeys() {
         .onLineContaining("interface TestComponent");
     assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
     assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
-    assertThat(compilation).hadErrorContaining("boundedClassKey(test.TestInjectorFactory)");
-    assertThat(compilation).hadErrorContaining("boundedStringKey(test.TestInjectorFactory)");
-
     assertThat(compilation).hadErrorCount(1);
   }
 }
