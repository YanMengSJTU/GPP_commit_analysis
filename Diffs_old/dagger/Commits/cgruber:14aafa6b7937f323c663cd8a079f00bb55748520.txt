diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 62fabbf5b..39436072d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -46,6 +46,7 @@
 import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
 
 /**
  * The logical representation of a {@link Component} definition.
@@ -63,6 +64,11 @@
    */
   abstract TypeElement componentDefinitionType();
 
+  /**
+   *  The set of component dependencies listed in {@link Component#dependencies}.
+   */
+  abstract ImmutableSet<TypeElement> dependencies();
+
   /**
    * The list of {@link DependencyRequest} instances whose sources are methods on the component
    * definition type.  These are the user-requested dependencies.
@@ -137,6 +143,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           getAnnotationMirror(componentDefinitionType, Component.class).get();
       ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentModules(elements, componentMirror));
+      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
       ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
 
       ProvisionBinding componentBinding =
@@ -147,6 +155,22 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               .put(componentBinding.providedKey(), componentBinding);
 
 
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        ProvisionBinding componentDependencyBinding =
+            provisionBindingFactory.forComponent(componentDependency);
+        bindingIndexBuilder.put(
+            componentDependencyBinding.providedKey(), componentDependencyBinding);
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement dependencyMethod : dependencyMethods) {
+          if (isComponentProvisionMethod(dependencyMethod)) {
+            ProvisionBinding componentMethodBinding =
+                provisionBindingFactory.forComponentMethod(dependencyMethod);
+            bindingIndexBuilder.put(componentMethodBinding.providedKey(), componentMethodBinding);
+          }
+        }
+      }
+
       for (TypeElement module : transitiveModules) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods =
@@ -245,11 +269,17 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       return new AutoValue_ComponentDescriptor(
           componentDefinitionType,
+          componentDependencyTypes,
           interfaceRequestsBuilder.build(),
           moduleTypes,
           ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
           ImmutableMap.copyOf(resolvedMembersInjectionBindings),
           resolutionOrder.build().asList().reverse());
     }
+
+    private static boolean isComponentProvisionMethod(ExecutableElement method) {
+      return method.getParameters().isEmpty()
+          && !method.getReturnType().getKind().equals(VOID);
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 11e586cf5..98a8c8c1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -28,7 +28,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.ScopedProvider;
@@ -61,6 +63,7 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -135,14 +138,17 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
     ImmutableBiMap<Key, String> membersInjectorNames =
         generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
 
-    ImmutableBiMap<TypeElement, String> moduleNames =
-        ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
-            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
-            new Function<TypeElement, String>() {
-              @Override public String apply(TypeElement input) {
-                return input.getSimpleName().toString();
-              }
-            })));
+    // the full set of types that calling code uses to construct a component instance
+    ImmutableBiMap<TypeElement, String> componentContributionNames =
+        ImmutableBiMap.copyOf(Maps.asMap(
+            Sets.union(input.moduleDependencies(), input.dependencies()),
+            Functions.compose(
+                CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
+                new Function<TypeElement, String>() {
+                  @Override public String apply(TypeElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })));
 
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
@@ -154,7 +160,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
 
     boolean requiresBuilder = false;
 
-    for (Entry<TypeElement, String> entry : moduleNames.entrySet()) {
+    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
       TypeElement moduleElement = entry.getKey();
       String moduleName = entry.getValue();
       componentWriter.addField(moduleElement, moduleName)
@@ -226,7 +232,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             setFactoryParameters.add(initializeFactoryForBinding(
-                binding, moduleNames, providerNames,membersInjectorNames));
+                binding, componentContributionNames, providerNames,membersInjectorNames));
           }
           constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
               providerNames.get(key),
@@ -237,7 +243,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           constructorWriter.body().addSnippet("this.%s = %s;",
               providerNames.get(key),
               initializeFactoryForBinding(
-                  binding, moduleNames, providerNames, membersInjectorNames));
+                  binding, componentContributionNames, providerNames, membersInjectorNames));
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
         constructorWriter.body().addSnippet("this.%s = %s;",
@@ -290,6 +296,17 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
           TypeNames.forTypeMirror(binding.providedKey().type()));
+    } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
+      return Snippet.format(Joiner.on('\n').join(
+          "new %s<%2$s>() {",
+          "  @Override public %2$s get() {",
+          "    return %3$s.%4$s();",
+          "  }",
+          "}"),
+          ClassName.fromClass(Factory.class),
+          TypeNames.forTypeMirror(binding.providedKey().type()),
+          moduleNames.get(binding.bindingTypeElement()),
+          binding.bindingElement().getSimpleName().toString());
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 1bcb1b57d..cbe2d8b06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -41,6 +41,15 @@
     return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
   }
 
+  private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
+
+  static ImmutableList<TypeMirror> getComponentDependencies(Elements elements,
+      AnnotationMirror componentAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(componentAnnotation);
+    return getAttributeAsListOfTypes(elements, componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+  }
+
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 3effcc6fe..4148cb0b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -106,6 +106,14 @@ private TypeElement getSetElement() {
       return elements.getTypeElement(Set.class.getCanonicalName());
     }
 
+    Key forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      TypeMirror returnType = normalize(componentMethod.getReturnType());
+      Optional<AnnotationMirror> qualifier = getQualifier(componentMethod);
+      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+    }
+
     Key forProvidesMethod(ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(METHOD));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index c3276c1f7..9226c22c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -59,6 +59,8 @@
     PROVISION,
     /** Represents the implicit binding to the component. */
     COMPONENT,
+    /** Represents a binding from a provision method on a component dependency. */
+    COMPONENT_PROVISION,
   }
 
   /**
@@ -176,5 +178,19 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<AnnotationMirror>absent(),
           false);
     }
+
+    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      checkArgument(componentMethod.getParameters().isEmpty());
+      return new AutoValue_ProvisionBinding(
+          componentMethod,
+          ImmutableList.<DependencyRequest>of(),
+          Kind.COMPONENT_PROVISION,
+          Provides.Type.UNIQUE,
+          keyFactory.forComponentMethod(componentMethod),
+          getScopeAnnotation(componentMethod),
+          false);
+    }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 8aec49fdd..90a680d92 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -22,9 +22,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -36,7 +36,7 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -52,7 +52,7 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -66,7 +66,7 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -80,7 +80,7 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("module");
@@ -159,7 +159,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -243,7 +243,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -359,7 +359,7 @@
         "    }",
         "  }",
         "}");
-     ASSERT.about(javaSources()).that(ImmutableList.of(nestedTypesFile))
+    assert_().about(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(aFactory, bMembersInjector, generatedComponent);
@@ -464,7 +464,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -580,7 +580,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -663,7 +663,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -733,7 +733,7 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -811,10 +811,114 @@
         "    }",
         "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void componentDependency() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(A a) {}",
+        "}");
+    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface AComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = AComponent.class)",
+        "interface BComponent {",
+        "  B b();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_BComponent",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_BComponent implements BComponent {",
+        "  private final AComponent aComponent;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  private Dagger_BComponent(Builder builder) {  ",
+        "    assert builder != null;",
+        "    this.aComponent = builder.aComponent;",
+        "    this.aProvider = new Factory<A>() {",
+        "      @Override public A get() {",
+        "        return aComponent.a();",
+        "      }",
+        "    };",
+        "    this.bProvider = new B$$Factory(aProvider);",
+        "  }",
+        "",
+        "  public static Builder builder() {  ",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  @Override",
+        "  public B b() {  ",
+        "    return bProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AComponent aComponent;",
+        "  ",
+        "    private Builder() {  ",
+        "    }",
+        "  ",
+        "    public BComponent build() {  ",
+        "      if (aComponent == null) {",
+        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "      }",
+        "      return new Dagger_BComponent(this);",
+        "    }",
+        "  ",
+        "    public Builder aComponent(AComponent aComponent) {  ",
+        "      if (aComponent == null) {",
+        "        throw new NullPointerException(\"aComponent\");",
+        "      }",
+        "      this.aComponent = aComponent;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 43f33329a..cd676f142 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -63,4 +63,9 @@
    * component implementation.
    */
   Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
 }
