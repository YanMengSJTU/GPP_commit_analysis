diff --git a/compiler/pom.xml b/compiler/pom.xml
index 6b2990d91..0d8691a9d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -36,6 +36,10 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.auto</groupId>
+      <artifactId>auto-common</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
new file mode 100644
index 000000000..608b4c0a1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A utility class for working with {@link AnnotationMirror} instances.
+ *
+ * @author Gregory Kick
+ */
+final class AnnotationMirrors {
+  /**
+   * An alternative to {@link Element#getAnnotation} that returns an {@link AnnotationMirror} rather
+   * than the weird, half-implementation returned by that method.
+   */
+  static Optional<AnnotationMirror> getAnnotationMirror(Element element,
+      Class<? extends Annotation> annotationType) {
+    String annotationName = annotationType.getName();
+    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
+      if (MoreElements.asType(annotationMirror.getAnnotationType().asElement())
+          .getQualifiedName().contentEquals(annotationName)) {
+        return Optional.of(annotationMirror);
+      }
+    }
+    return Optional.absent();
+  }
+
+  /**
+   * Takes a {@link Map} like that returned from {@link Elements#getElementValuesWithDefaults} and
+   * key it by the member name rather than the {@link ExecutableElement}.
+   */
+  static ImmutableMap<String, AnnotationValue> simplifyAnnotationValueMap(
+      Map<? extends ExecutableElement, ? extends AnnotationValue> annotationValueMap) {
+    ImmutableMap.Builder<String, AnnotationValue> builder = ImmutableMap.builder();
+    for (Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
+        : annotationValueMap.entrySet()) {
+      builder.put(entry.getKey().getSimpleName().toString(), entry.getValue());
+    }
+    return builder.build();
+  }
+
+  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(Elements elements,
+      AnnotationMirror annotationMirror, String attributeName) {
+    checkNotNull(annotationMirror);
+    checkNotNull(attributeName);
+    ImmutableMap<String, AnnotationValue> valueMap =
+        simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
+    ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
+    @SuppressWarnings("unchecked")
+    List<? extends AnnotationValue> typeValues =
+        (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
+    for (AnnotationValue typeValue : typeValues) {
+      builder.add((TypeMirror) typeValue.getValue());
+    }
+    return builder.build();
+  }
+
+  private AnnotationMirrors() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 44faf5f3b..dc3641ff1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -15,12 +15,13 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 
-import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
 
 /**
  * An abstract type for classes representing a Dagger binding.  Particularly, contains the
@@ -32,12 +33,22 @@
  * @since 2.0
  */
 abstract class Binding {
-  /** The field or method annotated with {@link Inject}. */
+  /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
   /** The type enclosing the binding {@link #bindingElement()}. */
-  TypeElement enclosingType() {
-    return ElementUtil.asTypeElement(bindingElement().getEnclosingElement());
+  TypeElement bindingTypeElement() {
+    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override
+      protected TypeElement defaultAction(Element e, Void p) {
+        return MoreElements.asType(bindingElement().getEnclosingElement());
+      }
+
+      @Override
+      public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+    }, null);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
new file mode 100644
index 000000000..07d85ebc7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Queues;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Deque;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Queue;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * The logical representation of a {@link Component} definition.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ComponentDescriptor {
+  ComponentDescriptor() {}
+
+  /**
+   * The type (interface or abstract class) that defines the component. This is the element to which
+   * the {@link Component} annotation was applied.
+   */
+  abstract TypeElement componentDefinitionType();
+
+  /**
+   * The set of {@linkplain DependencyRequest dependency requests} representing  the provision
+   * methods in the component definition.  To access the method element itself, use
+   * {@link DependencyRequest#requestElement()}.
+   */
+  abstract ImmutableSet<DependencyRequest> provisionRequests();
+
+  /**
+   * The set of {@linkplain DependencyRequest dependency requests} representing the members
+   * injection methods in the component definition.  To access the method element itself, use
+   * {@link DependencyRequest#requestElement()}.
+   */
+  abstract ImmutableSet<DependencyRequest> membersInjectionRequests();
+
+  /**
+   * The total set of modules (those declared in {@link Component#modules} and their transitive
+   * dependencies) required to construct the object graph declared by the component.
+   */
+  abstract ImmutableSet<TypeElement> moduleDependencies();
+
+  /**
+   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that represents the full
+   * adjacency matrix for the object graph.
+   */
+  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings();
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final InjectBindingRegistry injectBindingRegistry;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, InjectBindingRegistry injectBindingRegistry,
+        ProvisionBinding.Factory provisionBindingFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.injectBindingRegistry = injectBindingRegistry;
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
+      Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+      LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
+      for (TypeElement moduleElement = moduleQueue.poll();
+          moduleElement != null;
+          moduleElement = moduleQueue.poll()) {
+        moduleElements.add(moduleElement);
+        AnnotationMirror moduleMirror =
+            getAnnotationMirror(moduleElement, Module.class).get();
+        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
+            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror));
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+      return ImmutableSet.copyOf(moduleElements);
+    }
+
+    ComponentDescriptor create(TypeElement componentDefinitionType) {
+      AnnotationMirror componentMirror =
+          getAnnotationMirror(componentDefinitionType, Component.class).get();
+      ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentModules(elements, componentMirror));
+      ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
+
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> bindingIndexBuilder =
+          ImmutableSetMultimap.builder();
+
+      for (TypeElement module : transitiveModules) {
+        // traverse the modules, collect the bindings
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(module));
+        for (ExecutableElement moduleMethod : moduleMethods) {
+          if (moduleMethod.getAnnotation(Provides.class) != null) {
+            ProvisionBinding providesMethodBinding =
+                provisionBindingFactory.forProvidesMethod(moduleMethod);
+            bindingIndexBuilder.put(providesMethodBinding.providedKey(), providesMethodBinding);
+          }
+        }
+      }
+
+      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
+
+      ImmutableSet.Builder<DependencyRequest> provisionRequestsBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<DependencyRequest> membersInjectionRequestsBuilder =
+          ImmutableSet.builder();
+
+      Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
+
+      for (ExecutableElement componentMethod
+          : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
+        if (componentMethod.getModifiers().contains(ABSTRACT)) {
+          List<? extends VariableElement> parameters = componentMethod.getParameters();
+          switch (parameters.size()) {
+            case 0:
+              // provision method
+              DependencyRequest provisionRequest =
+                  dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
+              provisionRequestsBuilder.add(provisionRequest);
+              requestsToResolve.addLast(provisionRequest);
+              break;
+            case 1:
+              // members injection method
+              membersInjectionRequestsBuilder.add(
+                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+              break;
+            default:
+              throw new IllegalStateException();
+          }
+        }
+      }
+
+      SetMultimap<Key, ProvisionBinding> resolvedBindings = LinkedHashMultimap.create();
+
+      for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
+          requestToResolve != null;
+          requestToResolve = requestsToResolve.pollLast()) {
+        Key key = requestToResolve.key();
+        if (!resolvedBindings.containsKey(key)) {
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
+          if (explicitBindingsForKey.isEmpty()) {
+            Optional<ProvisionBinding> injectBinding =
+                injectBindingRegistry.getBindingForKey(key);
+            if (injectBinding.isPresent()) {
+              requestsToResolve.addAll(injectBinding.get().dependencies());
+              resolvedBindings.put(key, injectBinding.get());
+            } else {
+              // TODO(gak): generate a factory for an @Inject dependency that wasn't run with the
+              // processor
+              throw new UnsupportedOperationException("@Injected classes that weren't run with the "
+                  + "compoenent processor are (briefly) unsupported.");
+            }
+          } else {
+            resolvedBindings.putAll(key, explicitBindingsForKey);
+          }
+          for (ProvisionBinding binding : explicitBindingsForKey) {
+            requestsToResolve.addAll(binding.dependencies());
+          }
+        }
+      }
+
+      return new AutoValue_ComponentDescriptor(
+          componentDefinitionType,
+          provisionRequestsBuilder.build(),
+          membersInjectionRequestsBuilder.build(),
+          moduleTypes,
+          ImmutableSetMultimap.copyOf(resolvedBindings));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
new file mode 100644
index 000000000..630b8f16a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.Collections2;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Component;
+import dagger.internal.SetFactory;
+
+import java.io.IOException;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates the implementation of the abstract types annotated with {@link Component}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  ComponentGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ComponentDescriptor input) {
+    ClassName componentDefinitionClassName =
+        ClassName.fromTypeElement(input.componentDefinitionType());
+    return componentDefinitionClassName.peerNamed(
+        "Dagger_" + componentDefinitionClassName.simpleName());
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ComponentDescriptor input) {
+    return ImmutableSet.of(input.componentDefinitionType());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ComponentDescriptor input) {
+    return Optional.of(input.componentDefinitionType());
+  }
+
+  @Override
+  void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input)
+      throws IOException {
+    writer.emitPackage(componentName.packageName());
+
+    writeImports(writer, componentName, input.provisionRequests(),
+        input.resolvedBindings().values());
+
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
+    writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
+        input.componentDefinitionType().getQualifiedName().toString());
+
+    ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
+
+    ImmutableBiMap<Key, String> providerNames = generateProviderNamesForBindings(resolvedBindings);
+
+    ImmutableBiMap<TypeElement, String> moduleNames =
+        ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
+            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
+            new Function<TypeElement, String>() {
+              @Override public String apply(TypeElement input) {
+                return input.getSimpleName().toString();
+              }
+            })));
+
+    writeModuleFields(writer, moduleNames);
+    writeProviderFields(writer, providerNames);
+
+    writeConstructor(writer, resolvedBindings, providerNames, moduleNames);
+
+    writeProvisionMethods(writer, input.provisionRequests(), providerNames);
+
+    writer.endType();
+  }
+
+  private void writeImports(JavaWriter writer, ClassName factoryClassName,
+      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableCollection<ProvisionBinding> bindings) throws IOException {
+    ImmutableSortedSet.Builder<ClassName> importsBuilder =
+        ImmutableSortedSet.<ClassName>naturalOrder()
+            .addAll(collectImportsFromDependencies(factoryClassName, provisionRequests))
+            .add(ClassName.fromClass(Generated.class))
+            .add(ClassName.fromClass(Provider.class));
+    for (ProvisionBinding binding : bindings) {
+      if (binding.provisionType().equals(SET) || binding.provisionType().equals(SET_VALUES)) {
+        importsBuilder.add(ClassName.fromClass(SetFactory.class));
+      }
+      for (TypeElement referencedType : MoreTypes.referencedTypes(binding.providedKey().type())) {
+        ClassName className = ClassName.fromTypeElement(referencedType);
+        if (!className.packageName().equals("java.lang")
+            && !className.packageName().equals(factoryClassName.packageName()))
+          importsBuilder.add(className);
+      }
+    }
+
+    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
+        .emitEmptyLine();
+  }
+
+  private void writeModuleFields(JavaWriter writer,
+      ImmutableBiMap<TypeElement, String> moduleDependencies) throws IOException {
+    for (Entry<TypeElement, String> entry : moduleDependencies.entrySet()) {
+      writer.emitField(entry.getKey().getQualifiedName().toString(), entry.getValue(),
+          EnumSet.of(PRIVATE, FINAL));
+    }
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(final JavaWriter writer,
+      ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<TypeElement, String> moduleNames)
+          throws IOException {
+    Map<String, String> variableMap =
+        Maps.transformValues(moduleNames.inverse(), new Function<TypeElement, String>() {
+      @Override
+      public String apply(TypeElement input) {
+        return writer.compressType(input.getQualifiedName().toString());
+      }
+    });
+
+    writer.beginConstructor(EnumSet.of(PUBLIC), flattenVariableMap(variableMap),
+        ImmutableList.<String>of());
+    for (String variableName : variableMap.keySet()) {
+      writer.beginControlFlow("if (%s == null)", variableName)
+          .emitStatement("throw new NullPointerException(\"%s\")", variableName)
+          .endControlFlow();
+      writer.emitStatement("this.%1$s = %1$s", variableName);
+    }
+
+    for (Entry<String, Key> providerFieldEntry
+        : Lists.reverse(providerNames.inverse().entrySet().asList())) {
+      Set<ProvisionBinding> bindings = resolvedBindings.get(providerFieldEntry.getValue());
+      if (ProvisionBinding.isSetBindingCollection(bindings)) {
+        ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
+        for (ProvisionBinding binding : bindings) {
+          setFactoryParameters.add(
+              initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
+        }
+        writer.emitStatement("this.%s = SetFactory.create(%n%s)",
+            providerFieldEntry.getKey(),
+            Joiner.on(",\n").join(setFactoryParameters.build()));
+      } else {
+        ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+        writer.emitStatement("this.%s = %s",
+            providerFieldEntry.getKey(),
+            initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
+      }
+    }
+
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
+      ImmutableBiMap<TypeElement, String> moduleNames,
+      ImmutableBiMap<Key, String> providerNames) {
+    List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+    if (binding.bindingKind().equals(PROVISION)) {
+      parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+    }
+    FluentIterable.from(binding.dependenciesByKey().keySet())
+        .transform(Functions.forMap(providerNames))
+        .copyInto(parameters);
+    return String.format("new %s(%s)",
+        writer.compressType(factoryNameForProvisionBinding(binding).toString()),
+        Joiner.on(", ").join(parameters));
+  }
+
+  private void writeProvisionMethods(JavaWriter writer,
+      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableBiMap<Key, String> providerNames) throws IOException {
+    for (DependencyRequest provisionRequest : provisionRequests) {
+      ExecutableElement requestElement = (ExecutableElement) provisionRequest.requestElement();
+      writer.emitAnnotation(Override.class)
+          .beginMethod(Util.typeToString(requestElement.getReturnType()),
+              requestElement.getSimpleName().toString(),
+              Sets.difference(requestElement.getModifiers(), EnumSet.of(ABSTRACT)));
+
+      String providerName = providerNames.get(provisionRequest.key());
+
+      // look up the provider in the Key->name map and invoke.  Done.
+      writer.emitStatement("return "
+          + providerUsageStatement(providerName, provisionRequest.kind()));
+      writer.endMethod();
+    }
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
new file mode 100644
index 000000000..11fd1a368
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.SourceVersion.RELEASE_6;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Inject;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * The annotation processor responsible for generating the classes that drive the Dagger 2.0
+ * implementation.
+ *
+ * TODO(gak): give this some better documentation
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@SupportedSourceVersion(RELEASE_6)
+public final class ComponentProcessor extends AbstractProcessor {
+  private ImmutableList<ProcessingStep> processingSteps;
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of(
+        Component.class.getName(),
+        Inject.class.getName(),
+        Module.class.getName(),
+        Provides.class.getName());
+  }
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+
+    Messager messager = processingEnv.getMessager();
+    Types types = processingEnv.getTypeUtils();
+    Elements elements = processingEnv.getElementUtils();
+    Filer filer = processingEnv.getFiler();
+
+    InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
+    ModuleValidator moduleValidator = new ModuleValidator();
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
+    ComponentValidator componentValidator = new ComponentValidator(elements);
+
+    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
+    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
+
+    Key.Factory keyFactory = new Key.Factory(types, elements);
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, types);
+    ProvisionBinding.Factory provisionBindingFactory =
+        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
+    MembersInjectionBinding.Factory methodInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    ComponentDescriptor.Factory componentDescriptorFactory =
+        new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
+            provisionBindingFactory, dependencyRequestFactory);
+
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, providerTypeRepository);
+    MembersInjectorGenerator membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, providerTypeRepository);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, providerTypeRepository);
+
+    this.processingSteps = ImmutableList.<ProcessingStep>of(
+        new InjectProcessingStep(
+            messager,
+            injectConstructorValidator,
+            injectFieldValidator,
+            injectMethodValidator,
+            provisionBindingFactory,
+            factoryGenerator,
+            methodInjectionBindingFactory,
+            membersInjectorGenerator,
+            injectBindingRegistry),
+        new ModuleProcesssingStep(
+            messager,
+            moduleValidator,
+            providesMethodValidator,
+            provisionBindingFactory,
+            factoryGenerator),
+        new ComponentProcesssingStep(
+            messager,
+            componentValidator,
+            componentDescriptorFactory,
+            componentGenerator));
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    for (ProcessingStep processingStep : processingSteps) {
+      processingStep.process(annotations, roundEnv);
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
new file mode 100644
index 000000000..9a2d4dfd5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+
+import dagger.Component;
+import dagger.internal.codegen.ComponentDescriptor.Factory;
+
+import java.util.Set;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * as part of the {@link ComponentProcessor}.
+ *
+ * @author Gregory Kick
+ */
+final class ComponentProcesssingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ComponentValidator componentValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final ComponentGenerator componentGenerator;
+
+  ComponentProcesssingStep(
+      Messager messager,
+      ComponentValidator componentValidator,
+      Factory componentDescriptorFactory,
+      ComponentGenerator componentGenerator) {
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    Set<? extends Element> componentElements = roundEnv.getElementsAnnotatedWith(Component.class);
+
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> report =
+          componentValidator.validate(componentTypeElement);
+      report.printMessagesTo(messager);
+
+      if (report.isClean()) {
+        try {
+          componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
+        } catch (SourceFileGenerationException e) {
+          e.printMessageTo(messager);
+        }
+      }
+    }
+
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
new file mode 100644
index 000000000..c28e21e02
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+
+import dagger.Component;
+import dagger.Module;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Performs superficial validation of the contract of the {@link Component} annotation.
+ *
+ * @author Gregory Kick
+ */
+// TODO(gak): this class does superficial component validation, but we need to do graph validation
+// as well
+final class ComponentValidator implements Validator<TypeElement> {
+  private final Elements elements;
+
+  ComponentValidator(Elements elements) {
+    this.elements = elements;
+  }
+
+  @Override
+  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addItem("@Component may only be applied to an interface or abstract class", subject);
+    }
+
+    AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
+    ImmutableList<TypeMirror> moduleTypes =
+        ConfigurationAnnotations.getComponentModules(elements, componentMirror);
+
+    // TODO(gak): make unused modules an error
+    for (TypeMirror moduleType: moduleTypes) {
+      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror e, Void p) {
+          builder.addItem(Util.typeToString(e) + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          checkState(t.getTypeArguments().isEmpty());
+          TypeElement moduleElement = MoreElements.asType(t.asElement());
+          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()) {
+            builder.addItem(moduleElement.getQualifiedName()
+                + " is listed as a module, but is not annotated with @Module", subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
new file mode 100644
index 000000000..150dce892
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
+
+import com.google.common.collect.ImmutableList;
+
+import dagger.Component;
+import dagger.Module;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
+ * and {@link Module}).
+ *
+ * @author Gregory Kick
+ */
+final class ConfigurationAnnotations {
+  private static final String MODULES_ATTRIBUTE = "modules";
+
+  static ImmutableList<TypeMirror> getComponentModules(Elements elements,
+      AnnotationMirror componentAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(componentAnnotation);
+    return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
+  }
+
+  private static final String INCLUDES_ATTRIBUTE = "includes";
+
+  static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
+      AnnotationMirror moduleAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(moduleAnnotation);
+    return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
+  }
+
+  private ConfigurationAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index e44e6b03f..0cb323c17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.auto.value.AutoValue;
@@ -25,6 +26,7 @@
 import com.google.common.collect.Iterables;
 
 import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.Provides;
 
 import java.util.List;
@@ -32,6 +34,8 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -60,7 +64,7 @@
 
   abstract Kind kind();
   abstract Key key();
-  abstract VariableElement requestElement();
+  abstract Element requestElement();
 
   static final class Factory {
     private final Elements elements;
@@ -71,35 +75,60 @@
       this.types = types;
     }
 
-    ImmutableSet<DependencyRequest> forVariables(List<? extends VariableElement> variables) {
+    ImmutableSet<DependencyRequest> forRequiredVariables(
+        List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
             @Override public DependencyRequest apply(VariableElement input) {
-              return forVariable(input);
+              return forRequiredVariable(input);
             }
           })
           .toSet();
     }
 
-    DependencyRequest forVariable(VariableElement variableElement) {
+    DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, type, qualifier);
+    }
+
+    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
+      checkNotNull(provisionMethod);
+      TypeMirror type = provisionMethod.getReturnType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
+      return newDependencyRequest(provisionMethod, type, qualifier);
+    }
+
+    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
+      checkNotNull(membersInjectionMethod);
+      DeclaredType membersInjectorType = types.getDeclaredType(
+          elements.getTypeElement(MembersInjector.class.getCanonicalName()),
+          Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType());
+      // this is where we need to wrap it in a MembersInjector
+      Optional<AnnotationMirror> qualifier =
+          InjectionAnnotations.getQualifier(membersInjectionMethod);
+      checkArgument(!qualifier.isPresent());
+      return newDependencyRequest(membersInjectionMethod, membersInjectorType, qualifier);
+    }
+
+    private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
+        Optional<AnnotationMirror> qualifier) {
       if (elements.getTypeElement(Provider.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType providerType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.PROVIDER,
             Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
-            variableElement);
+            requestElement);
       } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType lazyType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.LAZY,
             Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
-            variableElement);
+            requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
-            variableElement);
+            requestElement);
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java b/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java
deleted file mode 100644
index 3597b653e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.SimpleElementVisitor6;
-
-/**
- * A collection of utilities for working with {@link Element} instances.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class ElementUtil {
-  private static final ElementVisitor<TypeElement, Void> TYPE_ELEMENT_VISITOR =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          throw new IllegalArgumentException();
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
-  /**
-   * Returns the given {@link Element} as a {@link TypeElement} or throws
-   * {@link IllegalArgumentException} if the element is not of the correct
-   * {@linkplain ElementKind kind}.
-   */
-  static TypeElement asTypeElement(Element e) {
-    return e.accept(TYPE_ELEMENT_VISITOR, null);
-  }
-
-  private ElementUtil() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
rename to compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index f5aa2baa5..0e8d8a0bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,10 +15,23 @@
  */
 package dagger.internal.codegen;
 
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.Collections2;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
@@ -26,12 +39,13 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Factory;
 import dagger.MembersInjector;
+import dagger.Provides;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -41,16 +55,7 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNames;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -59,19 +64,17 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorFactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final ProviderTypeRepository providerTypeRepository;
 
-  InjectConstructorFactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  FactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
     super(filer);
     this.providerTypeRepository = providerTypeRepository;
   }
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    TypeElement providedElement = binding.enclosingType();
-    ClassName providedClassName = ClassName.fromTypeElement(providedElement);
-    return providedClassName.peerNamed(providedClassName.simpleName() + "$$Factory");
+    return factoryNameForProvisionBinding(binding);
   }
 
   @Override
@@ -87,76 +90,84 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding binding)
       throws IOException {
-    ClassName providedClassName = ClassName.fromTypeElement(binding.enclosingType());
+    TypeMirror providedType = binding.providedKey().type();
+    String providedTypeString = Util.typeToString(providedType);
 
     writer.emitPackage(factoryClassName.packageName());
 
-    List<ClassName> importsBuilder = new ArrayList<ClassName>();
-    importsBuilder.addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()));
-    importsBuilder.add(ClassName.fromClass(Factory.class));
-    importsBuilder.add(ClassName.fromClass(Generated.class));
-    if (binding.requiresMemberInjection()) {
-      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
-    }
-    ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
-        .transform(Functions.toStringFunction())
-        .toSortedSet(Ordering.natural());
-    writer.emitImports(imports).emitEmptyLine();
+    writeImports(writer, factoryClassName, binding, providedType);
 
-    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
         .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
             type(Factory.class, Util.typeToString(binding.providedKey().type())));
 
     final ImmutableBiMap<Key, String> providerNames =
-        generateProviderNames(ImmutableList.of(binding));
+        generateProviderNamesForDependencies(binding.dependencies());
 
     ImmutableMap.Builder<String, String> variableMapBuilder =
         new ImmutableMap.Builder<String, String>();
+    if (binding.bindingKind().equals(PROVISION)) {
+      variableMapBuilder.put("module", binding.bindingTypeElement().getQualifiedName().toString());
+    }
     if (binding.requiresMemberInjection()) {
-      variableMapBuilder.put("membersInjector",
-          type(MembersInjector.class, providedClassName.simpleName()));
+      variableMapBuilder.put("membersInjector", type(MembersInjector.class, providedTypeString));
     }
     ImmutableMap<String, String> variableMap = variableMapBuilder
         .putAll(providersAsVariableMap(providerNames))
         .build();
 
     if (binding.requiresMemberInjection()) {
-      writeMembersInjectorField(writer, providedClassName);
+      writeMembersInjectorField(writer, providedTypeString);
+    }
+    if (binding.bindingKind().equals(PROVISION)) {
+      writeModuleField(writer, binding.bindingTypeElement());
     }
     writeProviderFields(writer, providerNames);
 
     writeConstructor(writer, variableMap);
 
-    writer.emitAnnotation(Override.class)
-        .beginMethod(providedClassName.simpleName(), "get", EnumSet.of(PUBLIC));
-    String parameterString =
-        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
-            .transform(new Function<DependencyRequest, String>() {
-              @Override public String apply(DependencyRequest input) {
-                return providerUsageStatement(providerNames.get(input.key()), input.kind());
-              }
-            }));
-    if (binding.requiresMemberInjection()) {
-      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
-          providedClassName.simpleName(), parameterString);
-      writer.emitStatement("membersInjector.injectMembers(instance)");
-      writer.emitStatement("return instance");
-    } else {
-      writer.emitStatement("return new %s(%s)", providedClassName.simpleName(), parameterString);
-    }
-    writer.endMethod().emitEmptyLine();
+    writeGetMethod(writer, binding, providedTypeString, providerNames);
 
-    writeToString(writer, providedClassName);
+    // TODO(gak): write a sensible toString
 
     writer.endType();
   }
 
-  private void writeMembersInjectorField(JavaWriter writer, ClassName providedClassName)
+  private void writeImports(JavaWriter writer, ClassName factoryClassName, ProvisionBinding binding,
+      TypeMirror providedType) throws IOException {
+    ImmutableSortedSet.Builder<ClassName> importsBuilder =
+        ImmutableSortedSet.<ClassName>naturalOrder()
+            .addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()))
+            .add(ClassName.fromClass(Factory.class))
+            .add(ClassName.fromClass(Generated.class));
+    if (binding.provisionType().equals(Provides.Type.SET)) {
+      importsBuilder.add(ClassName.fromClass(Collections.class));
+    }
+    if (binding.requiresMemberInjection()) {
+      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
+    }
+    for (TypeElement referencedProvidedType : MoreTypes.referencedTypes(providedType)) {
+      ClassName className = ClassName.fromTypeElement(referencedProvidedType);
+      if (!className.packageName().equals("java.lang")
+          && !className.packageName().equals(factoryClassName.packageName()))
+      importsBuilder.add(className);
+    }
+
+    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
+        .emitEmptyLine();
+  }
+
+  private void writeMembersInjectorField(JavaWriter writer, String providedTypeString)
       throws IOException {
-    writer.emitField(type(MembersInjector.class, providedClassName.fullyQualifiedName()),
+    writer.emitField(type(MembersInjector.class, providedTypeString),
         "membersInjector", EnumSet.of(PRIVATE, FINAL));
   }
 
+  private void writeModuleField(JavaWriter writer, TypeElement moduleType) throws IOException {
+    writer.emitField(moduleType.getQualifiedName().toString(), "module",
+        EnumSet.of(PRIVATE, FINAL));
+  }
+
   private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
       throws IOException {
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
@@ -171,22 +182,54 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
 
   private void writeConstructor(JavaWriter writer, Map<String, String> variableMap)
       throws IOException {
-    writer.beginConstructor(EnumSet.of(PUBLIC),
-        flattenVariableMap(variableMap),
-        ImmutableList.<String>of());
-    for (String variableName : variableMap.keySet()) {
-      writer.emitStatement("assert %s != null", variableName);
-      writer.emitStatement("this.%1$s = %1$s", variableName);
+    if (!variableMap.isEmpty()) {
+      writer.beginConstructor(EnumSet.of(PUBLIC),
+          flattenVariableMap(variableMap),
+          ImmutableList.<String>of());
+      for (String variableName : variableMap.keySet()) {
+        writer.emitStatement("assert %s != null", variableName);
+        writer.emitStatement("this.%1$s = %1$s", variableName);
+      }
+      writer.endConstructor().emitEmptyLine();
     }
-    writer.endConstructor().emitEmptyLine();
   }
 
-  private void writeToString(JavaWriter writer, ClassName providedClassName) throws IOException {
+  private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
+      String providedTypeString, final ImmutableBiMap<Key, String> providerNames)
+          throws IOException {
     writer.emitAnnotation(Override.class)
-        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
-        .emitStatement("return \"%s<%s>\"",
-            Factory.class.getSimpleName(), providedClassName.simpleName())
-        .endMethod();
+        .beginMethod(providedTypeString, "get", EnumSet.of(PUBLIC));
+    String parameterString =
+        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+            .transform(new Function<DependencyRequest, String>() {
+              @Override public String apply(DependencyRequest input) {
+                return providerUsageStatement(providerNames.get(input.key()), input.kind());
+              }
+            }));
+    if (binding.bindingKind().equals(PROVISION)) {
+      switch (binding.provisionType()) {
+        case UNIQUE:
+        case SET_VALUES:
+          writer.emitStatement("return module.%s(%s)",
+              binding.bindingElement().getSimpleName(), parameterString);
+          break;
+        case SET:
+          writer.emitStatement("return Collections.singleton(module.%s(%s))",
+              binding.bindingElement().getSimpleName(), parameterString);
+          break;
+        default:
+          throw new AssertionError();
+      }
+    } else if (binding.requiresMemberInjection()) {
+      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
+          writer.compressType(providedTypeString), parameterString);
+      writer.emitStatement("membersInjector.injectMembers(instance)");
+      writer.emitStatement("return instance");
+    } else {
+      writer.emitStatement("return new %s(%s)",
+          writer.compressType(providedTypeString), parameterString);
+    }
+    writer.endMethod().emitEmptyLine();
   }
 
   private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
new file mode 100644
index 000000000..58875c286
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.Maps;
+
+import java.util.Map;
+
+import javax.inject.Inject;
+
+/**
+ * Maintains the collection of provision bindings from {@link Inject} constructors known to the
+ * annotation processor.
+ *
+ * @author Gregory Kick
+ */
+final class InjectBindingRegistry {
+  private final Map<Key, ProvisionBinding> bindingsByKey;
+
+  InjectBindingRegistry() {
+    this.bindingsByKey = Maps.newLinkedHashMap();
+  }
+
+  boolean isRegistered(Key key) {
+    return bindingsByKey.containsKey(key);
+  }
+
+  void registerBinding(ProvisionBinding binding) {
+    ProvisionBinding previousValue = bindingsByKey.put(binding.providedKey(), binding);
+    checkState(previousValue == null);
+  }
+
+  Optional<ProvisionBinding> getBindingForKey(Key key) {
+    return Optional.fromNullable(bindingsByKey.get(checkNotNull(key)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index c2ea00fa3..4776e0228 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -29,6 +29,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -68,7 +69,7 @@
     }
 
     TypeElement enclosingElement =
-        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+        MoreElements.asType(constructorElement.getEnclosingElement());
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
     if (typeModifiers.contains(PRIVATE)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
similarity index 67%
rename from compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 3a6f970ba..b0f80db7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -25,10 +25,7 @@
 import java.util.Collection;
 import java.util.Set;
 
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
@@ -37,8 +34,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementKindVisitor6;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
@@ -48,41 +43,36 @@
  * @since 2.0
  */
 @SupportedSourceVersion(RELEASE_6)
-public final class InjectProcessor extends AbstractProcessor {
-  private Messager messager;
-  private InjectConstructorValidator constructorValidator;
-  private InjectFieldValidator fieldValidator;
-  private InjectMethodValidator methodValidator;
-  private ProvisionBinding.Factory provisionBindingFactory;
-  private InjectConstructorFactoryGenerator factoryWriter;
-  private MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private MembersInjectorGenerator membersInjectorWriter;
-
-  @Override
-  public synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
-    this.messager = processingEnv.getMessager();
-    this.constructorValidator = new InjectConstructorValidator();
-    this.fieldValidator = new InjectFieldValidator();
-    this.methodValidator = new InjectMethodValidator();
-    Filer filer = processingEnv.getFiler();
-    Elements elements = processingEnv.getElementUtils();
-    Types types = processingEnv.getTypeUtils();
-    Key.Factory keyFactory = new Key.Factory(types, elements);
-    DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types);
-    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
-    this.provisionBindingFactory =
-        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
-    this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
-    this.membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(dependencyRequestFactory);
-    this.membersInjectorWriter = new MembersInjectorGenerator(filer, providerTypeRepository);
-  }
-
-  @Override
-  public Set<String> getSupportedAnnotationTypes() {
-    return ImmutableSet.of(Inject.class.getName());
+public final class InjectProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final InjectConstructorValidator constructorValidator;
+  private final InjectFieldValidator fieldValidator;
+  private final InjectMethodValidator methodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final MembersInjectorGenerator membersInjectorWriter;
+  private final InjectBindingRegistry factoryRegistrar;
+
+
+  InjectProcessingStep(Messager messager,
+      InjectConstructorValidator constructorValidator,
+      InjectFieldValidator fieldValidator,
+      InjectMethodValidator methodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      MembersInjectorGenerator membersInjectorWriter,
+      InjectBindingRegistry factoryRegistrar) {
+    this.messager = messager;
+    this.constructorValidator = constructorValidator;
+    this.fieldValidator = fieldValidator;
+    this.methodValidator = methodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.membersInjectorWriter = membersInjectorWriter;
+    this.factoryRegistrar = factoryRegistrar;
   }
 
   @Override
@@ -142,7 +132,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
         Multimaps.index(membersInjections.build(),
             new Function<MembersInjectionBinding, TypeElement>() {
               @Override public TypeElement apply(MembersInjectionBinding binding) {
-                return binding.enclosingType();
+                return binding.bindingTypeElement();
               }
             });
 
@@ -156,7 +146,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
     for (ProvisionBinding binding : provisions.build()) {
       try {
-        factoryWriter.generate(binding);
+        factoryGenerator.generate(binding);
+        factoryRegistrar.registerBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 2e2ff9aa1..f7ab2aa23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -53,7 +53,7 @@
 
   /**
    * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
-   * logical equality, so we use {@link Mirrors#equivalence()} for this object.
+   * logical equality, so we use {@link MoreTypes#equivalence()} for this object.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
@@ -71,11 +71,12 @@ public String toString() {
   }
 
   static Key create(TypeMirror type) {
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+    return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+        MoreTypes.equivalence().wrap(type));
   }
 
   static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
+    return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(type));
   }
 
   static final class Factory {
@@ -105,28 +106,20 @@ Key forProvidesMethod(ExecutableElement e) {
       Optional<AnnotationMirror> qualifier = getQualifier(e);
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(setType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(setType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
         default:
           throw new AssertionError();
       }
     }
 
-    Key forComponentMethod(ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      checkArgument(e.getParameters().isEmpty());
-      return new AutoValue_Key(getQualifier(e),
-          Mirrors.equivalence().wrap(normalize(e.getReturnType())));
-    }
-
     Key forInjectConstructor(ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(CONSTRUCTOR));
@@ -134,8 +127,7 @@ Key forInjectConstructor(ExecutableElement e) {
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
       return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
-          Mirrors.equivalence().wrap(type));
+          MoreTypes.equivalence().wrap(type));
     }
   }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
new file mode 100644
index 000000000..67adb4798
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.common.base.Function;
+
+import java.util.Iterator;
+
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Suggests a variable name for a type based on a {@link Key}. Prefer
+ * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class KeyVariableNamer implements Function<Key, String> {
+  @Override
+  public String apply(Key key) {
+    StringBuilder builder = new StringBuilder();
+
+    if (key.qualifier().isPresent()) {
+      if (!key.qualifier().get().getElementValues().isEmpty()) {
+        // TODO(gak): obviously we need to support this
+        throw new UnsupportedOperationException();
+      }
+      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
+    }
+
+    key.type().accept(new SimpleTypeVisitor6<Void, StringBuilder>() {
+      @Override
+      public Void visitDeclared(DeclaredType t, StringBuilder builder) {
+        builder.append(t.asElement().getSimpleName());
+        Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+        if (argumentIterator.hasNext()) {
+          builder.append("Of");
+          TypeMirror first = argumentIterator.next();
+          first.accept(this, builder);
+          while (argumentIterator.hasNext()) {
+            builder.append("And");
+            argumentIterator.next().accept(this, builder);
+          }
+        }
+        return null;
+      }
+    }, builder);
+
+    return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index c92a133cc..67974b3ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -41,7 +41,7 @@
   /**
    * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
    * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
-   * from different {@link #enclosingType() types}.
+   * from different {@link #bindingTypeElement() types}.
    */
   static Ordering<MembersInjectionBinding> injectionOrdering() {
     return INJECTION_ORDERING;
@@ -62,7 +62,7 @@ public int compare(MembersInjectionBinding left, MembersInjectionBinding right)
       };
 
   private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
-    return binding.enclosingType().getEnclosedElements().indexOf(binding.bindingElement());
+    return binding.bindingTypeElement().getEnclosedElements().indexOf(binding.bindingElement());
   }
 
   /**
@@ -81,7 +81,7 @@ MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
       checkArgument(methodElement.getKind().equals(METHOD));
       checkArgument(methodElement.getAnnotation(Inject.class) != null);
       return new AutoValue_MembersInjectionBinding(methodElement,
-          dependencyRequestFactory.forVariables(methodElement.getParameters()));
+          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
     }
 
     /** Returns the field injection binding for a field annotated with {@link Inject}. */
@@ -90,7 +90,7 @@ MembersInjectionBinding forInjectField(VariableElement fieldElement) {
       checkArgument(fieldElement.getKind().equals(FIELD));
       checkArgument(fieldElement.getAnnotation(Inject.class) != null);
       return new AutoValue_MembersInjectionBinding(fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forVariable(fieldElement)));
+          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
index ce8845bfd..ed0640340 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
@@ -50,7 +50,7 @@ static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindin
     TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
         .transform(new Function<MembersInjectionBinding, TypeElement>() {
           @Override public TypeElement apply(MembersInjectionBinding binding) {
-            return binding.enclosingType();
+            return binding.bindingTypeElement();
           }
         })
         .toSet());
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4555454c..a92a4adb2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,6 +15,17 @@
  */
 package dagger.internal.codegen;
 
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
@@ -43,17 +54,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.VariableElement;
 
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNames;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
  *
@@ -122,12 +122,13 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
     String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
     // @Generated("dagger.internal.codegen.InjectProcessor")
     // public final class Blah$$MembersInjector implements MembersInjector<Blah>
-    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
         .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
             membersInjectorType);
 
 
-    final ImmutableBiMap<Key, String> providerNames = generateProviderNames(descriptor.bindings());
+    final ImmutableBiMap<Key, String> providerNames =
+        generateProviderNamesForDependencies(dependencies);
 
     // Add the fields
     writeProviderFields(writer, providerNames);
@@ -173,8 +174,6 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
     }
     writer.endMethod();
 
-    writeToString(writer, injectedClassName);
-
     writer.endType();
   }
 
@@ -202,14 +201,6 @@ private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> pro
     writer.endConstructor().emitEmptyLine();
   }
 
-  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
-    writer.emitAnnotation(Override.class)
-        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
-        .emitStatement("return \"%s<%s>\"",
-            MembersInjector.class.getSimpleName(), injectedClassName.simpleName())
-        .endMethod();
-  }
-
   private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
     return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
       @Override public String apply(Key key) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
new file mode 100644
index 000000000..a4a8073a5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the {@link Module}
+ * (and {@link Provides}) annotation.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class ModuleProcesssingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ModuleValidator moduleValidator;
+  private final ProvidesMethodValidator providesMethodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+
+  ModuleProcesssingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      ProvidesMethodValidator providesMethodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator) {
+    this.messager = messager;
+    this.moduleValidator = moduleValidator;
+    this.providesMethodValidator = providesMethodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    // first, check and collect all provides methods
+    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
+    for (Element providesElement : roundEnv.getElementsAnnotatedWith(Provides.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
+    ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
+
+    // process each module
+    for (Element moduleElement : roundEnv.getElementsAnnotatedWith(Module.class)) {
+      ValidationReport<TypeElement> report =
+          moduleValidator.validate(MoreElements.asType(moduleElement));
+      report.printMessagesTo(messager);
+
+      if (report.isClean()) {
+        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+            ImmutableSet.builder();
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+        for (ExecutableElement methodElement : moduleMethods) {
+          if (methodElement.getAnnotation(Provides.class) != null) {
+            moduleProvidesMethodsBuilder.add(methodElement);
+          }
+        }
+        ImmutableSet<ExecutableElement> moduleProvidesMethods =
+            moduleProvidesMethodsBuilder.build();
+
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+          // all of the provides methods in this module are valid!
+          // time to generate some factories!
+          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+              .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                @Override
+                public ProvisionBinding apply(ExecutableElement providesMethod) {
+                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                }
+              })
+              .toSet();
+
+          try {
+            for (ProvisionBinding binding : bindings) {
+              factoryGenerator.generate(binding);
+            }
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+    }
+
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
new file mode 100644
index 000000000..c34dea47b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Module;
+
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link Validator} for {@link Module}s.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ModuleValidator implements Validator<TypeElement> {
+  @Override
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    // TODO(gak): port the module validation
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
similarity index 88%
rename from compiler/src/main/java/dagger/internal/codegen/Mirrors.java
rename to compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
index ad110df49..916bed5bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -22,6 +23,7 @@
 import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.WILDCARD;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSet.Builder;
@@ -29,6 +31,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -38,7 +41,9 @@
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * Utilities related to {@link TypeMirror} instances.
@@ -46,16 +51,16 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class Mirrors {
+final class MoreTypes {
   private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
     @Override
     protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
-      return Mirrors.equal(a, b);
+      return MoreTypes.equal(a, b);
     }
 
     @Override
     protected int doHash(TypeMirror t) {
-      return Mirrors.hash(t);
+      return MoreTypes.hash(t);
     }
   };
 
@@ -264,7 +269,7 @@ public Void visitArray(ArrayType t, Builder<TypeElement> p) {
 
       @Override
       public Void visitDeclared(DeclaredType t, Builder<TypeElement> p) {
-        p.add(ElementUtil.asTypeElement(t.asElement()));
+        p.add(MoreElements.asType(t.asElement()));
         for (TypeMirror typeArgument : t.getTypeArguments()) {
           typeArgument.accept(this, p);
         }
@@ -294,5 +299,33 @@ public Void visitWildcard(WildcardType t, Builder<TypeElement> p) {
     return elements.build();
   }
 
-  private Mirrors() {}
+  static TypeElement asTypeElement(Types types, TypeMirror mirror) {
+    checkNotNull(types);
+    checkNotNull(mirror);
+    Element element = types.asElement(mirror);
+    checkArgument(element != null);
+    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override
+      protected TypeElement defaultAction(Element e, Void p) {
+        throw new IllegalArgumentException();
+      }
+
+      @Override public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+    }, null);
+  }
+
+  static ImmutableSet<TypeElement> asTypeElements(Types types,
+      Iterable<? extends TypeMirror> mirrors) {
+    checkNotNull(types);
+    checkNotNull(mirrors);
+    ImmutableSet.Builder<TypeElement> builder = ImmutableSet.builder();
+    for (TypeMirror mirror : mirrors) {
+      builder.add(asTypeElement(types, mirror));
+    }
+    return builder.build();
+  }
+
+  private MoreTypes() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
new file mode 100644
index 000000000..50d2bcf6c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.Set;
+
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * This represents work to be done in an annotation processor that must run with other steps due to
+ * shared state between them or a particular execution order.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+interface ProcessingStep {
+  boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 329fcbd79..ed2197c45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -17,12 +17,15 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.Provides.Type.UNIQUE;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
@@ -30,6 +33,8 @@
 
 import dagger.Provides;
 
+import java.util.Iterator;
+
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -46,6 +51,22 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends Binding {
+  enum Kind {
+    /** Represents an {@link Inject} binding. */
+    INJECTION,
+    /** Represents a binding configured by {@link Provides}. */
+    PROVISION,
+  }
+
+  /**
+   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
+   * use {@link #provisionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
+
   /** The {@link Key} that is provided by this binding. */
   abstract Key providedKey();
 
@@ -55,19 +76,34 @@
   /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
   abstract boolean requiresMemberInjection();
 
+  private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
+
   /**
-   * Returns {@code true} if this binding contributes to a single logical binding. I.e. multiple
-   * bindings are allowed for the same {@link Key}.
+   * Returns {@code true} if the given bindings are all contributors to a set binding.
+   *
+   * @throws IllegalArgumentException if some of the bindings are set bindings and some are not.
    */
-  abstract boolean contributingBinding();
+  static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
+    checkNotNull(bindings);
+    Iterator<ProvisionBinding> iterator = bindings.iterator();
+    checkArgument(iterator.hasNext(), "no bindings");
+    boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
+    while (iterator.hasNext()) {
+      checkArgument(setBinding,
+          "more than one binding present, but found a non-set binding");
+      checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
+          "more than one binding present, but found a non-set binding");
+    }
+    return setBinding;
+  }
 
   static final class Factory {
     private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory keyRequestFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Key.Factory keyFactory, DependencyRequest.Factory keyRequestFactory) {
+    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.keyFactory = keyFactory;
-      this.keyRequestFactory = keyRequestFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
@@ -76,13 +112,15 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkArgument(constructorElement.getAnnotation(Inject.class) != null);
       Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
-      return new AutoValue_ProvisionBinding(constructorElement,
-          keyRequestFactory.forVariables(constructorElement.getParameters()),
+      return new AutoValue_ProvisionBinding(
+          constructorElement,
+          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters()),
+          Kind.INJECTION,
+          Provides.Type.UNIQUE,
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           requiresMemeberInjection(
-              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())),
-          false);
+              MoreElements.asType(constructorElement.getEnclosingElement())));
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -103,12 +141,14 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkArgument(providesMethod.getKind().equals(METHOD));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      return new AutoValue_ProvisionBinding(providesMethod,
-          keyRequestFactory.forVariables(providesMethod.getParameters()),
+      return new AutoValue_ProvisionBinding(
+          providesMethod,
+          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters()),
+          Kind.PROVISION,
+          providesAnnotation.type(),
           keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false,
-          !providesAnnotation.type().equals(UNIQUE));
+          false);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 164499fc8..4ce42b4ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -45,7 +45,7 @@
     this.filer = checkNotNull(filer);
   }
 
-  final void generate(T input) throws SourceFileGenerationException {
+  final ClassName generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
     JavaFileObject file = null;
@@ -58,6 +58,7 @@ final void generate(T input) throws SourceFileGenerationException {
       boolean thrownWriting = false;
       try {
         write(generatedTypeName, writer, input);
+        return generatedTypeName;
       } catch (Exception e) {
         thrownWriting = true;
         throw new SourceFileGenerationException(generatedTypeName, e,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 55d4ece15..71cc0d1bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -30,6 +30,7 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.SetMultimap;
 import com.squareup.javawriter.JavaWriter;
 
 import dagger.Lazy;
@@ -42,7 +43,9 @@
 import java.util.Map.Entry;
 
 import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementKindVisitor6;
 
 /**
  * Utilities for generating files.
@@ -74,7 +77,8 @@
     ImmutableSet<String> packagesToSkip  =
         ImmutableSet.of("java.lang", topLevelClassName.packageName());
     for (DependencyRequest dependency : dependencies) {
-      ImmutableSet<TypeElement> referencedTypes = Mirrors.referencedTypes(dependency.key().type());
+      ImmutableSet<TypeElement> referencedTypes =
+          MoreTypes.referencedTypes(dependency.key().type());
       switch (dependency.kind()) {
         case LAZY:
           builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
@@ -132,15 +136,13 @@
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    * provider.
    */
-  static ImmutableBiMap<Key, String> generateProviderNames(
-      Iterable<? extends Binding> bindings) {
+  static ImmutableBiMap<Key, String> generateProviderNamesForDependencies(
+      Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
         new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
             .orderValuesBy(DEPENDENCY_ORDERING);
-    for (Binding binding : bindings) {
-      for (DependencyRequest dependency : binding.dependencies()) {
-        dependenciesByKeyBuilder.put(dependency.key(), dependency);
-      }
+    for (DependencyRequest dependency : dependencies) {
+      dependenciesByKeyBuilder.put(dependency.key(), dependency);
     }
     ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
@@ -183,6 +185,44 @@
     return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
   }
 
+  // TODO(gak): this needs to suck less
+  static ImmutableBiMap<Key, String> generateProviderNamesForBindings(
+      SetMultimap<Key, ProvisionBinding> bindings) {
+    BiMap<Key, String> providerNames = HashBiMap.create(bindings.size());
+    for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
+      Collection<ProvisionBinding> bindingsForKey = entry.getValue();
+      final String name;
+      if (ProvisionBinding.isSetBindingCollection(bindingsForKey)) {
+        name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
+      } else {
+        ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+        switch (binding.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+            name = binding.bindingElement().accept(
+                new ElementKindVisitor6<String, Void>() {
+                  @Override
+                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                        e.getEnclosingElement().getSimpleName().toString());
+                  }
+
+                  @Override
+                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                    return e.getSimpleName().toString();
+                  }
+                }, null) + "Provider";
+            break;
+          default:
+            throw new AssertionError();
+        }
+      }
+      providerNames.put(entry.getKey(), name);
+    }
+    // return the map so that it is sorted by name
+    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+  }
+
   static String providerUsageStatement(String providerName,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
@@ -198,5 +238,30 @@ static String providerUsageStatement(String providerName,
     }
   }
 
+  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    switch (binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        return enclosingClassName.peerNamed(
+            enclosingClassName.simpleName() + "$$" + factoryPrefix(binding) + "Factory");
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static String factoryPrefix(ProvisionBinding binding) {
+    switch (binding.bindingKind()) {
+      case INJECTION:
+        return "";
+      case PROVISION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
new file mode 100644
index 000000000..9f26ab4df
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ComponentProcessorTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "final class NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "@interface NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = Object.class)",
+        "interface NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("module");
+  }
+
+  @Test public void simpleComponent() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
+        "  @Override public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "    return someInjectableTypeProvider;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentWithModule() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "interface B {}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides B b(C c) { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final TestModule testModule;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "",
+        "  public Dagger_TestComponent(TestModule testModule) {",
+        "    if (testModule == null) {",
+        "      throw new NullPointerException(\"testModule\");",
+        "    }",
+        "    this.testModule = testModule;",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "  }",
+        "",
+        "  @Override public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class EmptySetModule {",
+        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides(type = SET) String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.SetFactory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final EmptySetModule emptySetModule;",
+        "  private final SetModule setModule;",
+        "  private final Provider<Set<String>> setOfStringProvider;",
+        "",
+        "  public Dagger_TestComponent(EmptySetModule emptySetModule, SetModule setModule) {",
+        "    if (emptySetModule == null) {",
+        "      throw new NullPointerException(\"emptySetModule\");",
+        "    }",
+        "    this.emptySetModule = emptySetModule;",
+        "    if (setModule == null) {",
+        "      throw new NullPointerException(\"setModule\");",
+        "    }",
+        "    this.setModule = setModule;",
+        "    this.setOfStringProvider = SetFactory.create(",
+        "        new EmptySetModule$$EmptySetFactory(emptySetModule),",
+        "        new SetModule$$StringFactory(setModule));",
+        "  }",
+        "",
+        "  @Override public Set<String> strings() {",
+        "    return setOfStringProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
index 0cf99d282..f52f71efa 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
@@ -18,6 +18,7 @@
 import static org.junit.Assert.fail;
 import static org.truth0.Truth.ASSERT;
 
+import com.google.auto.common.MoreElements;
 import com.google.testing.compile.CompilationRule;
 
 import javax.lang.model.element.Element;
@@ -37,7 +38,7 @@
   @Test public void asTypeElement() {
     Element typeElement =
         compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    ASSERT.that(ElementUtil.asTypeElement(typeElement)).is(typeElement);
+    ASSERT.that(MoreElements.asType(typeElement)).is(typeElement);
   }
 
   @Test public void asTypeElement_notATypeElement() {
@@ -45,7 +46,7 @@
         compilation.getElements().getTypeElement(String.class.getCanonicalName());
     for (ExecutableElement e : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
       try {
-        ElementUtil.asTypeElement(e);
+        MoreElements.asType(e);
         fail();
       } catch (IllegalArgumentException expected) {
       }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index dc23b0bfd..329e5dc48 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -81,7 +81,7 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
         .in(file).onLine(6);
   }
@@ -97,7 +97,7 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
   }
 
@@ -110,7 +110,7 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
         .in(file).onLine(6);
   }
@@ -124,7 +124,7 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS)
         .in(file).onLine(6);
   }
@@ -140,7 +140,7 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
         .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
   }
@@ -155,7 +155,7 @@
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the constructor
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
@@ -170,7 +170,7 @@
         "  @Inject MultipleScopeClass() {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
         .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
   }
@@ -184,7 +184,7 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -197,7 +197,7 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -211,7 +211,7 @@
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
         .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
   }
@@ -225,7 +225,7 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -238,7 +238,7 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -251,7 +251,7 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -265,7 +265,7 @@
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
@@ -292,7 +292,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class FieldInjection$$MembersInjector ",
         "    implements MembersInjector<FieldInjection> {",
         "",
@@ -311,12 +311,8 @@
         "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
         "    instance.stringProvider = stringProvider;",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<FieldInjection>\";",
-        "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -345,7 +341,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class MethodInjection$$MembersInjector ",
         "    implements MembersInjector<MethodInjection> {",
         "",
@@ -365,12 +361,8 @@
         "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
         "        stringProvider);",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<MethodInjection>\";",
-        "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -397,7 +389,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class MixedMemberInjection$$MembersInjector ",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -421,12 +413,8 @@
         "    instance.setString(stringAndSProvider.get());",
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<MixedMemberInjection>\";",
-        "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -448,7 +436,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class InjectConstructor$$Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -462,12 +450,8 @@
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(sProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"Factory<InjectConstructor>\";",
-        "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -492,7 +476,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class AllInjections$$Factory ",
         "    implements Factory<AllInjections> {",
         "",
@@ -512,10 +496,6 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"Factory<AllInjections>\";",
-        "  }",
         "}");
     JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
         "test.AllInjections$$MembersInjector",
@@ -525,7 +505,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class AllInjections$$MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -543,12 +523,8 @@
         "    instance.s = sProvider.get();",
         "    instance.s(sProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<AllInjections>\";",
-        "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedFactory, expectedMembersInjector);
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3b1d41ae6..f903d3050 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -97,9 +97,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod);
-    ASSERT.that(Mirrors.equivalence().wrap(key.qualifier().get().getAnnotationType()))
-        .isEqualTo(Mirrors.equivalence().wrap(qualifierElement.asType()));
-    ASSERT.that(key.wrappedType()).isEqualTo(Mirrors.equivalence().wrap(stringType));
+    ASSERT.that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+        .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
+    ASSERT.that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
   @Module(library = true)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
new file mode 100644
index 000000000..a834625e4
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ModuleProcessorTest {
+  // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
+  // for @Inject
+
+  @Test public void providesMethodNotInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
+  }
+
+  @Test public void providesMethodAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "abstract class TestModule {",
+        "  @Provides abstract String provideString();",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
+  }
+
+  @Test public void providesMethodPrivate() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides private String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
+  }
+
+  @Test public void providesMethodStatic() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides static String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_STATIC);
+  }
+
+  @Test public void providesMethodReturnVoid() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides void provideNothing() {}",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
+  }
+
+  @Test public void providesMethodWithTypeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides <T> String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
+  }
+
+  @Test public void providesMethodSetValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void providesMethodSetValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
+  }
+
+  @Test public void providesMethodSetValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void singleProvidesMethodNoArgs() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test public void multipleProvidesMethods() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Arrays;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides List<Object> provideObjects(@QualifierA Object a, @QualifierB Object b) {",
+        "    return Arrays.asList(a, b);",
+        "  }",
+        "",
+        "  @Provides @QualifierA Object provideAObject() {",
+        "    return new Object();",
+        "  }",
+        "",
+        "  @Provides @QualifierB Object provideBObject() {",
+        "    return new Object();",
+        "  }",
+        "}");
+    JavaFileObject listFactoryFile = JavaFileObjects.forSourceLines(
+        "TestModule$$ProvideObjectsFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
+        "  private final TestModule module;",
+        "  private final Provider<Object> aProvider;",
+        "  private final Provider<Object> bProvider;",
+        "",
+        "  public TestModule$$ProvideObjectsFactory(TestModule module,",
+        "       Provider<Object> aProvider, Provider<Object> bProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override public List<Object> get() {",
+        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listFactoryFile);
+  }
+
+  @Test public void proviesSetElement() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET) String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    return Collections.singleton(module.provideString());",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void proviesSetValues() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringsFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringsFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringsFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    return module.provideStrings();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
similarity index 90%
rename from compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
rename to compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
index bef6c228e..44757ec30 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
@@ -15,6 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.type.TypeKind.VOID;
+import static org.truth0.Truth.ASSERT;
+
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -22,10 +26,12 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.EquivalenceTester;
 import com.google.testing.compile.CompilationRule;
+
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -40,20 +46,14 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static javax.lang.model.type.TypeKind.NONE;
-import static javax.lang.model.type.TypeKind.VOID;
-import static org.truth0.Truth.ASSERT;
-
-/**
- * Tests {@link Mirrors}.
- */
 @RunWith(JUnit4.class)
-public class MirrorsTest {
+public class MoreTypesTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   @Test
@@ -68,7 +68,7 @@ public void equivalence() {
         types.getDeclaredType(mapElement, objectType, objectType);
     TypeMirror mapType = mapElement.asType();
     WildcardType wildcard = types.getWildcardType(null, null);
-    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(Mirrors.equivalence())
+    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(MoreTypes.equivalence())
         .addEquivalenceGroup(types.getNullType())
         .addEquivalenceGroup(types.getNoType(NONE))
         .addEquivalenceGroup(types.getNoType(VOID))
@@ -190,27 +190,27 @@ public static void b() throws RuntimeException {}
     TypeElement charSequenceElement =
         elements.getTypeElement(CharSequence.class.getCanonicalName());
 
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f1").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f1").asType()))
         .has().exactly(objectElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f2").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f2").asType()))
         .has().exactly(setElement, stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f3").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f3").asType()))
         .has().exactly(mapElement, stringElement, objectElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f4").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f4").asType()))
         .has().exactly(integerElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f5").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f5").asType()))
         .has().exactly(setElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f6").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f6").asType()))
         .has().exactly(setElement, charSequenceElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f7").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f7").asType()))
         .has().exactly(mapElement, stringElement, setElement, charSequenceElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f8").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f8").asType()))
         .has().exactly(stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f9").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f9").asType()))
         .has().exactly(stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f12").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f12").asType()))
         .has().exactly(setElement, stringElement);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
deleted file mode 100644
index fda6afd03..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
-import static org.truth0.Truth.ASSERT;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.testing.compile.JavaFileObjects;
-
-import dagger.Provides;
-
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-import javax.tools.JavaFileObject;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ProvidesMethodValidatorTest {
-  @Test public void validate_notInModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "",
-        "final class TestModule {",
-        "  @Provides String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
-  }
-
-  @Test public void validate_abstract() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "abstract class TestModule {",
-        "  @Provides abstract String provideString();",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
-  }
-
-  @Test public void validate_private() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides private String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
-  }
-
-  @Test public void validate_static() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides static String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_STATIC);
-  }
-
-  @Test public void validate_void() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides void provideNothing() {}",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
-  }
-
-  @Test public void validate_typeParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides <T> String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
-  }
-
-  @Test public void validate_setValuesWildcard() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
-  }
-
-  @Test public void validate_setValuesRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set provideSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
-  }
-
-  @Test public void validate_setValuesNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "import java.util.List;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
-        .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
-  }
-
-  private Processor validationProcessor() {
-    return new AbstractProcessor() {
-      ProvidesMethodValidator validator;
-
-      @Override
-      public synchronized void init(ProcessingEnvironment processingEnv) {
-        super.init(processingEnv);
-        this.validator = new ProvidesMethodValidator(processingEnv.getElementUtils());
-      }
-
-      @Override public Set<String> getSupportedAnnotationTypes() {
-        return ImmutableSet.of(Provides.class.getName());
-      }
-
-      @Override
-      public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-        for (ExecutableElement element
-            : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(Provides.class))) {
-          validator.validate(element).printMessagesTo(processingEnv.getMessager());
-        }
-        return false;
-      }
-    };
-  }
-}
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index fc04dd606..dc4b62867 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -15,6 +15,11 @@
  */
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
@@ -51,6 +56,8 @@
  */
 // TODO(gak): add missing spec for @Scope
 // TODO(gak): add missing spec for component dependencies
+@Target(TYPE)
+@Documented
 public @interface Component {
   /**
    * A list of classes annotated with {@link Module} whose bindings are used to generate the
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
new file mode 100644
index 000000000..4da6a7752
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static java.util.Collections.unmodifiableSet;
+
+import dagger.Factory;
+
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
+ * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
+ * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class SetFactory<T> implements Factory<Set<T>> {
+  /**
+   * Returns a new factory that creates {@link Set} instances that from the union of the given
+   * {@link Provider} instances.
+   */
+  public static <T> Factory<Set<T>> create(Provider<Set<T>> first,
+      @SuppressWarnings("unchecked") Provider<Set<T>>... rest) {
+    if (first == null) {
+      throw new NullPointerException();
+    }
+    if (rest == null) {
+      throw new NullPointerException();
+    }
+    Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
+    contributingProviders.add(first);
+    for (Provider<Set<T>> provider : rest) {
+      if (provider == null) {
+        throw new NullPointerException();
+      }
+      contributingProviders.add(provider);
+    }
+    return new SetFactory<T>(contributingProviders);
+  }
+
+  private final Set<Provider<Set<T>>> contributingProviders;
+
+  private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
+    this.contributingProviders = contributingProviders;
+  }
+
+  /**
+   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
+   *
+   * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
+   *     are {@code null}
+   */
+  @Override
+  public Set<T> get() {
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
+    for (Provider<Set<T>> provider : contributingProviders) {
+      Set<T> providedSet = provider.get();
+      if (providedSet == null) {
+        throw new NullPointerException(provider + " returned null");
+      }
+      providedSets.add(providedSet);
+    }
+    int size = 0;
+    for (Set<T> providedSet : providedSets) {
+      size += providedSet.size();
+    }
+    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    for (Set<T> s : providedSets) {
+      for (T element : s) {
+        if (element == null) {
+          throw new NullPointerException("a null element was provided");
+        }
+        result.add(element);
+      }
+    }
+    return unmodifiableSet(result);
+  }
+
+  // TODO(gak): consider whether (expectedSize, 1.0f) is better for this use case since callers are
+  // typically only going to iterate
+  private static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
+    int initialCapacity = (expectedSize < 3)
+        ? expectedSize + 1
+        : (expectedSize < (1 << (Integer.SIZE - 2)))
+            ? expectedSize + expectedSize / 3
+            : Integer.MAX_VALUE;
+    return new LinkedHashSet<E>(initialCapacity);
+  }
+}
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
new file mode 100644
index 000000000..08d45f310
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static com.google.common.collect.DiscreteDomain.integers;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ContiguousSet;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Range;
+
+import dagger.Factory;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class SetFactoryTest {
+  @Rule public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullFirstProvider() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(null);
+  }
+
+  @Test
+  public void nullRest() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(incrementingIntegerProvider(1),
+        (Provider<Set<Integer>>[]) null);
+  }
+
+  @Test
+  public void nullProviderInRest() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(
+        incrementingIntegerProvider(1),
+        incrementingIntegerProvider(2),
+        null,
+        incrementingIntegerProvider(3));
+  }
+
+  @Test
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void providerReturnsSetWithNullElement() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void invokesProvidersEverytTime() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        incrementingIntegerProvider(0),
+        incrementingIntegerProvider(10),
+        incrementingIntegerProvider(20));
+    ASSERT.that(factory.get()).has().exactly(0, 10, 20);
+    ASSERT.that(factory.get()).has().exactly(1, 11, 21);
+    ASSERT.that(factory.get()).has().exactly(2, 12, 22);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        integerSetProvider(Range.closed(5, 9)),
+        integerSetProvider(Range.closed(3, 6)),
+        integerSetProvider(Range.closed(0, 5)));
+    ASSERT.that(factory.get()).iteratesAs(5, 6, 7, 8, 9, 3, 4, 0, 1, 2);
+  }
+
+  private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return ImmutableSet.of(value.getAndIncrement());
+      }
+    };
+  }
+
+  private static Provider<Set<Integer>> integerSetProvider(Range<Integer> range) {
+    final ContiguousSet<Integer> set = ContiguousSet.create(range, integers());
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return set;
+      }
+    };
+  }
+}
diff --git a/pom.xml b/pom.xml
index c08015be8..5bf001f76 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,8 +43,9 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.3.0</javawriter.version>
-    <guava.version>16.0.1</guava.version>
+    <javawriter.version>2.5.0</javawriter.version>
+    <auto.common.version>0.1</auto.common.version>
+    <guava.version>17.0</guava.version>
 
     <!-- Test Dependencies -->
     <compile-testing.version>0.5</compile-testing.version>
@@ -100,6 +101,11 @@
         <artifactId>guava-testlib</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.auto</groupId>
+        <artifactId>auto-common</artifactId>
+        <version>${auto.common.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
