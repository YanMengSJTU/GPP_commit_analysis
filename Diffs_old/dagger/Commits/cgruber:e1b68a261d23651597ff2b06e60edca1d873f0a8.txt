diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
similarity index 93%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
rename to compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
index 83606e538..cf68c3056 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.subcomponent;
+package test;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -24,4 +24,4 @@
 @Documented
 @Retention(RUNTIME)
 @Qualifier
-@interface SomeQualifier {}
+public @interface SomeQualifier {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
new file mode 100644
index 000000000..b0b126a0c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
new file mode 100644
index 000000000..14b98c944
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.bind;
+
+import javax.inject.Inject;
+
+final class FooOfObjects implements Foo<Object> {
+  @Inject FooOfObjects() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
new file mode 100644
index 000000000..2bf81689a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import javax.inject.Inject;
+
+final class FooOfStrings implements Foo<String> {
+  @Inject
+  FooOfStrings() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
new file mode 100644
index 000000000..857bf2147
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Bind;
+import dagger.Module;
+
+@Module
+interface InterfaceModule {
+  @Bind Foo<Object> bindFooOfObjects(FooOfObjects impl);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
new file mode 100644
index 000000000..ee33c8d86
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Bind;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+import test.SomeQualifier;
+
+@Module(includes = InterfaceModule.class)
+abstract class SimpleBindingModule {
+  @Bind
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Bind
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Bind
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Bind
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Provides
+  static Foo<Integer> provideFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
new file mode 100644
index 000000000..d92e6029f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Component;
+import javax.inject.Singleton;
+import test.SomeQualifier;
+
+@Singleton
+@Component(modules = SimpleBindingModule.class)
+public interface TestComponent {
+  Object object();
+
+  Foo<String> fooOfStrings();
+
+  Foo<Object> fooOfObjects();
+
+  @SomeQualifier
+  Foo<String> qualifiedFooOfStrings();
+
+  Foo<Integer> fooOfIntegers();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index 504139aa2..2e5316e43 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -17,6 +17,7 @@
 
 import dagger.Component;
 import javax.inject.Singleton;
+import test.SomeQualifier;
 
 @Component(modules = {ParentModule.class, UnresolvableChildComponentModule.class})
 @Singleton
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
index 0c273f737..c36fe316a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
@@ -17,6 +17,7 @@
 
 import dagger.Module;
 import dagger.Provides;
+import test.SomeQualifier;
 
 @Module
 final class UnresolvableChildComponentModule {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
new file mode 100644
index 000000000..04de60e00
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class BindTest {
+  @Test
+  public void bindDelegates() {
+    TestComponent component = DaggerTestComponent.create();
+    assertThat(component.object()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
+    assertThat(component.fooOfIntegers()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() {
+    TestComponent component = DaggerTestComponent.create();
+    assertThat(component.qualifiedFooOfStrings())
+        .isSameAs(component.qualifiedFooOfStrings());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index dafe78a5e..051abf2a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -112,6 +112,7 @@
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -344,7 +345,7 @@ private void addBuildMethod(
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else {
+      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
             builderField,
@@ -480,6 +481,8 @@ private void addField(ResolvedBindings resolvedBindings) {
       return;
     }
 
+    // TODO(gak): get rid of the field for unscoped delegated bindings
+
     FieldSpec frameworkField = addFrameworkField(resolvedBindings);
     memberSelects.put(
         bindingKey,
@@ -769,15 +772,35 @@ private void initializeFrameworkTypes() {
 
   private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
     ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
-    if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
-      return Optional.absent();
+    switch (binding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock = CodeBlocks.format(
+            "($T) $L",
+            binding.frameworkClass(),
+            getMemberSelect(
+                Iterables.getOnlyElement(binding.dependencies()).bindingKey())
+                    .getExpressionFor(name));
+        return Optional.of(
+            initializeMember(
+                bindingKey,
+                binding.scope().isPresent()
+                    ? decorateForScope(delegatingCodeBlock, binding.scope().get())
+                    : delegatingCodeBlock));
+      case ENUM_INSTANCE:
+        if (!binding.scope().isPresent()) {
+          return Optional.absent();
+        }
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return Optional.of(
+            CodeBlocks.concat(
+                ImmutableList.of(
+                    initializeDelegateFactoriesForUninitializedDependencies(binding),
+                    initializeMember(
+                        bindingKey, initializeFactoryForContributionBinding(binding)))));
+      default:
+        throw new AssertionError();
     }
-
-    return Optional.of(
-        CodeBlocks.concat(
-            ImmutableList.of(
-                initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(bindingKey, initializeFactoryForContributionBinding(binding)))));
   }
 
   private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java
new file mode 100644
index 000000000..3d094417b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.Iterables;
+import dagger.Bind;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
+import static dagger.internal.codegen.Validation.validateReturnType;
+import static dagger.internal.codegen.Validation.validateUncheckedThrows;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * A {@linkplain ValidationReport validator} for {@link Bind} methods.
+ */
+final class BindMethodValidator {
+  private final Elements elements;
+  private final Types types;
+  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>>
+      validationCache;
+
+  BindMethodValidator(Elements elements, Types types) {
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+    this.validationCache = CacheBuilder.newBuilder().build(new ValidationLoader());
+  }
+
+  private final class ValidationLoader
+      extends CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>> {
+    @Override
+    public ValidationReport<ExecutableElement> load(ExecutableElement bindMethodElement) {
+      ValidationReport.Builder<ExecutableElement> builder =
+          ValidationReport.about(bindMethodElement);
+
+      checkArgument(isAnnotationPresent(bindMethodElement, Bind.class));
+
+      Element enclosingElement = bindMethodElement.getEnclosingElement();
+      if (!isAnnotationPresent(enclosingElement, Module.class)
+          && !isAnnotationPresent(enclosingElement, ProducerModule.class)) {
+        builder.addError(
+            formatErrorMessage(
+                BINDING_METHOD_NOT_IN_MODULE,
+                String.format(
+                    // the first @ is in the format string
+                    "%s or @%s",
+                    Module.class.getSimpleName(),
+                    ProducerModule.class.getSimpleName())),
+            bindMethodElement);
+      }
+
+      if (!bindMethodElement.getTypeParameters().isEmpty()) {
+        builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), bindMethodElement);
+      }
+
+      Set<Modifier> modifiers = bindMethodElement.getModifiers();
+      if (!modifiers.contains(ABSTRACT)) {
+        builder.addError(formatErrorMessage(BIND_METHOD_NOT_ABSTRACT), bindMethodElement);
+      }
+      TypeMirror returnType = bindMethodElement.getReturnType();
+      validateReturnType(Bind.class, builder, returnType);
+
+      List<? extends VariableElement> parameters = bindMethodElement.getParameters();
+      if (parameters.size() == 1) {
+        VariableElement parameter = Iterables.getOnlyElement(parameters);
+        if (!types.isAssignable(parameter.asType(), returnType)) {
+          builder.addError(
+              formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindMethodElement);
+        }
+      } else {
+        builder.addError(
+            formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindMethodElement);
+      }
+
+      validateUncheckedThrows(elements, types, bindMethodElement, Bind.class, builder);
+
+      validateMethodQualifiers(builder, bindMethodElement);
+
+      return builder.build();
+    }
+  }
+
+  ValidationReport<ExecutableElement> validate(ExecutableElement bindMethodElement) {
+    return validationCache.getUnchecked(bindMethodElement);
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Bind.class.getSimpleName());
+  }
+
+  private String formatErrorMessage(String msg, String parameter) {
+    return String.format(msg, Bind.class.getSimpleName(), parameter);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9f9e1ed7d..210ee33d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -191,6 +191,7 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
     private BindingGraph create(
         Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
@@ -237,6 +238,7 @@ private BindingGraph create(
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
         multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
+        delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());
       }
 
       Resolver requestResolver =
@@ -244,7 +246,8 @@ private BindingGraph create(
               parentResolver,
               componentDescriptor,
               indexByKey(explicitBindingsBuilder.build()),
-              indexByKey(multibindingDeclarations.build()));
+              indexByKey(multibindingDeclarations.build()),
+              indexByKey(delegatesBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -283,6 +286,7 @@ private BindingGraph create(
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
+      final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
@@ -294,7 +298,8 @@ private BindingGraph create(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
-          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations) {
+          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations,
+          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
         assert componentDescriptor != null;
@@ -304,6 +309,8 @@ private BindingGraph create(
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         assert multibindingDeclarations != null;
         this.multibindingDeclarations = multibindingDeclarations;
+        assert delegateDeclarations != null;
+        this.delegateDeclarations = delegateDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
 
         ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
@@ -339,40 +346,47 @@ private BindingGraph create(
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
+        Key key = bindingKey.key();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
             Set<ContributionBinding> multibindings = new LinkedHashSet<>();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
+            ImmutableSet.Builder<DelegateDeclaration> delegateDeclarationsBuilder =
+                ImmutableSet.builder();
 
             // Add explicit bindings and declarations (those from modules and components).
-            contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
-            multibindings.addAll(getExplicitMultibindings(bindingKey.key()));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
+            contributionBindings.addAll(getExplicitBindings(key));
+            multibindings.addAll(getExplicitMultibindings(key));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
+            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(key));
 
             // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
             // Set<T>.
-            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(key);
             contributionBindings.addAll(getExplicitBindings(implicitSetKey));
             multibindings.addAll(getExplicitMultibindings(implicitSetKey));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
+            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(implicitSetKey));
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
+            ImmutableSet<DelegateDeclaration> delegateDeclarations =
+                delegateDeclarationsBuilder.build();
+
+            contributionBindings.addAll(delegateBindings(delegateDeclarations));
 
             // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
             // declarations.
-            Optional<Key> implicitMapProviderKey =
-                keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            Optional<Key> implicitMapProviderKey = keyFactory.implicitMapProviderKeyFrom(key);
             ImmutableSet<ContributionBinding> explicitProviderMapBindings =
                 getExplicitMultibindings(implicitMapProviderKey);
             ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProviderKey);
 
-            Optional<Key> implicitMapProducerKey =
-                keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            Optional<Key> implicitMapProducerKey = keyFactory.implicitMapProducerKeyFrom(key);
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
                 getExplicitMultibindings(implicitMapProducerKey);
             ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
@@ -411,13 +425,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.syntheticMultibinding(request, multibindings));
             }
 
-            /* If there are no explicit or synthetic bindings or multibinding declarations, use an
-             * implicit @Inject- constructed binding if there is one. */
+            /* If there are no explicit or synthetic bindings, multibinding declarations or delegate
+             * declarations, use an implicit @Inject- constructed binding if there is one. */
             if (contributionBindings.isEmpty()
                 && multibindings.isEmpty()
-                && multibindingDeclarations.isEmpty()) {
+                && multibindingDeclarations.isEmpty()
+                && delegateDeclarations.isEmpty()) {
               contributionBindings.addAll(
-                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
+                  injectBindingRegistry.getOrFindProvisionBinding(key).asSet());
             }
 
             return ResolvedBindings.forContributionBindings(
@@ -429,7 +444,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             Optional<MembersInjectionBinding> binding =
-                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
+                injectBindingRegistry.getOrFindMembersInjectionBinding(key);
             return binding.isPresent()
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
@@ -439,6 +454,32 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
+      private ImmutableSet<ContributionBinding> delegateBindings(
+          ImmutableSet<DelegateDeclaration> delegateDeclarations) {
+        ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
+        for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
+          DependencyRequest delegateRequest = delegateDeclaration.delegateRequest();
+          ResolvedBindings resolvedDelegate = lookUpBindings(delegateRequest);
+          for (ContributionBinding explicitDelegate : resolvedDelegate.contributionBindings()) {
+            switch (explicitDelegate.bindingType()) {
+              case PRODUCTION:
+                builder.add(
+                    productionBindingFactory.delegate(
+                        delegateDeclaration, (ProductionBinding) explicitDelegate));
+                break;
+              case PROVISION:
+                builder.add(
+                    provisionBindingFactory.delegate(
+                        delegateDeclaration, (ProvisionBinding) explicitDelegate));
+                break;
+              default:
+                throw new AssertionError();
+            }
+          }
+        }
+        return builder.build();
+      }
+
       private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
           indexBindingsByOwningComponent(
               DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
@@ -584,6 +625,22 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
             : ImmutableSet.<MultibindingDeclaration>of();
       }
 
+      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key key) {
+        ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          delegateDeclarations.addAll(resolver.delegateDeclarations.get(key));
+        }
+        return delegateDeclarations.build();
+      }
+
+      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getDelegateDeclarations(optionalKey.get())
+            : ImmutableSet.<DelegateDeclaration>of();
+      }
+
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
         Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1757f1733..70efa5aaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -880,6 +880,7 @@ void validateComponentScope() {
             // reference to scoped @Provides methods or @Inject types decorated by any
             // scope annotation.
             switch (contributionBinding.bindingKind()) {
+              case SYNTHETIC_DELEGATE_BINDING:
               case PROVISION:
                 ExecutableElement provisionMethod =
                     MoreElements.asExecutable(contributionBinding.bindingElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 77a63cfd3..531849cb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -84,6 +84,7 @@ public SourceVersion getSupportedSourceVersion() {
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
+    BindMethodValidator bindMethodValidator = new BindMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -113,6 +114,9 @@ public SourceVersion getSupportedSourceVersion() {
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
+    DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
+        new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
+
     this.injectBindingRegistry =
         new InjectBindingRegistry(
             elements,
@@ -129,7 +133,8 @@ public SourceVersion getSupportedSourceVersion() {
             elements,
             provisionBindingFactory,
             productionBindingFactory,
-            multibindingDeclarationFactory);
+            multibindingDeclarationFactory,
+            bindingDelegateDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -167,6 +172,7 @@ public SourceVersion getSupportedSourceVersion() {
             moduleValidator,
             providesMethodValidator,
             provisionBindingFactory,
+            bindMethodValidator,
             factoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
@@ -183,6 +189,7 @@ public SourceVersion getSupportedSourceVersion() {
             messager,
             moduleValidator,
             producesMethodValidator,
+            bindMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
         new ComponentProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index d47a3c68c..4fd5f414b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -143,7 +143,7 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
-    
+
     Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
     if (reusableAnnotation.isPresent()) {
       builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
@@ -240,7 +240,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(
-        subject, builder, moduleTypes, componentKind.moduleKinds());
+        subject, componentMirror, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 9e46214e5..cc008452d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -39,7 +39,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -195,12 +195,12 @@ protected void addFactoryMethods() {
 
   /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
   private boolean canInstantiateAllRequirements() {
-    return Iterables.all(
+    return !Iterables.any(
         graph.componentRequirements(),
         new Predicate<TypeElement>() {
           @Override
           public boolean apply(TypeElement dependency) {
-            return componentCanMakeNewInstances(dependency);
+            return requiresAPassedInstance(elements, dependency);
           }
         });
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 71cb38afd..250bed887 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -123,6 +123,12 @@ public Kind apply(ContributionBinding binding) {
      */
     SYNTHETIC_MULTIBOUND_MAP,
 
+    /**
+     * A binding (provision or production) that delegates from requests for one key to another.
+     * These are the bindings that satisfy {@code @Bind} declarations.
+     */
+    SYNTHETIC_DELEGATE_BINDING,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
@@ -164,7 +170,11 @@ public Kind apply(ContributionBinding binding) {
      */
     static final Predicate<Kind> IS_SYNTHETIC_KIND =
         Predicates.in(
-            immutableEnumSet(SYNTHETIC_MAP, SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+            immutableEnumSet(
+                SYNTHETIC_MAP,
+                SYNTHETIC_MULTIBOUND_SET,
+                SYNTHETIC_MULTIBOUND_MAP,
+                SYNTHETIC_DELEGATE_BINDING));
 
     /**
      * A predicate that tests whether a kind is for synthetic multibindings.
@@ -193,7 +203,7 @@ static Kind forMultibindingRequest(DependencyRequest request) {
    * The kind of this contribution binding.
    */
   protected abstract Kind bindingKind();
-  
+
   /**
    * A predicate that passes for bindings of a given kind.
    */
@@ -217,6 +227,8 @@ public ContributionType contributionType() {
     ENUM_INSTANCE,
     /** The factory must be created by calling the constructor. */
     CLASS_CONSTRUCTOR,
+    /** The factory is simply delegated to another. */
+    DELEGATE,
   }
 
   /**
@@ -226,18 +238,18 @@ public ContributionType contributionType() {
    */
   FactoryCreationStrategy factoryCreationStrategy() {
     switch (bindingKind()) {
+      case SYNTHETIC_DELEGATE_BINDING:
+        return FactoryCreationStrategy.DELEGATE;
       case PROVISION:
         return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
         return implicitDependencies().isEmpty()
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-        
       default:
         return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
new file mode 100644
index 000000000..bd4f516fe
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.Iterables;
+import dagger.Bind;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ContributionType.UNIQUE;
+
+/**
+ * The declaration for a delegate binding established by a {@link Bind} method.
+ */
+@AutoValue
+abstract class DelegateDeclaration implements HasKey, HasSourceElement, HasContributionType {
+  abstract DependencyRequest delegateRequest();
+
+  @Override
+  public ContributionType contributionType() {
+    return UNIQUE;
+  }
+
+  static final class Factory {
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(
+        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    DelegateDeclaration create(
+        ExecutableElement bindMethod, TypeElement contributingElement) {
+      checkArgument(MoreElements.isAnnotationPresent(bindMethod, Bind.class));
+      SourceElement sourceElement = SourceElement.forElement(bindMethod, contributingElement);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+      DependencyRequest delegateRequest =
+          dependencyRequestFactory.forRequiredResolvedVariable(
+              MoreTypes.asDeclared(contributingElement.asType()),
+              Iterables.getOnlyElement(bindMethod.getParameters()),
+              Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
+      return new AutoValue_DelegateDeclaration(
+          keyFactory.forBindMethod(sourceElement), sourceElement, delegateRequest);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index d6b79e250..2b53bb55d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -82,14 +82,14 @@
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
       "Dagger does not support injection into private fields";
-  
+
   static final String STATIC_INJECT_FIELD =
       "Dagger does not support injection into static fields";
 
   /* methods */
   static final String PRIVATE_INJECT_METHOD =
       "Dagger does not support injection into private methods";
-  
+
   static final String STATIC_INJECT_METHOD =
       "Dagger does not support injection into static methods";
 
@@ -100,7 +100,7 @@
   static final String CANNOT_INJECT_WILDCARD_TYPE =
       "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
           + "type such as <%s>.";
-  
+
   /*
    * Configuration errors
    *
@@ -120,13 +120,13 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String COMPONENT_ANNOTATED_REUSABLE =
       "@Reusable cannot be applied to components or subcomponents.";
-  
-  static final String PROVIDES_METHOD_RETURN_TYPE =
-      "@Provides methods must either return a primitive, an array, a type variable, or a declared"
+
+  static final String BINDING_METHOD_RETURN_TYPE =
+      "@%s methods must either return a primitive, an array, a type variable, or a declared"
           + " type.";
 
-  static final String PROVIDES_METHOD_THROWS =
-      "@Provides methods may only throw unchecked exceptions";
+  static final String BINDING_METHOD_THROWS_CHECKED =
+      "@%s methods may only throw unchecked exceptions";
 
   static final String PRODUCES_METHOD_NULLABLE =
       "@Nullable on @Produces methods does not do anything.";
@@ -155,11 +155,16 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
+  static final String BIND_METHOD_NOT_ABSTRACT = "@Bind methods must be abstract";
+
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
+  static final String BIND_METHOD_ONE_ASSIGNABLE_PARAMETER =
+      "@Bind methods must have only one parameter whose type is assignable to the return type";
+
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
 
@@ -175,6 +180,10 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
 
+  static final String INCOMPATIBLE_MODULE_METHODS =
+      "A @%1$s may contain non-static @%2$s methods or @Bind methods,"
+          + " but not both at the same time.  (Static @%2$s may be used with either.)";
+
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
 
@@ -193,8 +202,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String METHOD_OVERRIDES_PROVIDES_METHOD =
       "@%s methods may not be overridden in modules. Overrides: %s";
 
-  static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
-      "Cannot use more than one @Qualifier on a @Provides or @Produces method";
+  static final String BINDING_METHOD_MULTIPLE_QUALIFIERS =
+      "Cannot use more than one @Qualifier";
 
   /* mapKey errors*/
   static final String MAPKEY_WITHOUT_MEMBERS =
@@ -215,7 +224,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision, which cannot depend on a production.";
-  
+
   static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
       "%s may not depend on the production executor.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 2bbcb2414..22203c0ff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -146,6 +146,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
               constructorBuilder.get());
         }
         break;
+      case DELEGATE:
+        return Optional.absent();
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 635cc5421..7640bb948 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -28,12 +28,13 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Bind;
 import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.Production;
 import dagger.producers.Produces;
+import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
 import java.util.Map;
 import java.util.Set;
@@ -45,6 +46,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -54,6 +56,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -370,6 +373,27 @@ Key forMultibindingsMethod(
       return forMethod(method, keyType);
     }
 
+    /** Returns the key bound by a {@link Bind} method. */
+    Key forBindMethod(SourceElement bindMethodElement) {
+      ExecutableElement method = MoreElements.asExecutable(bindMethodElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(bindMethodElement.asMemberOfContributingType(types));
+      checkArgument(isAnnotationPresent(method, Bind.class));
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      return forMethod(method, returnType);
+    }
+
+    /** Returns the key for the single parameter of a {@link Bind} method. */
+    Key forBindParameter(SourceElement bindMethodElement) {
+      ExecutableElement method = MoreElements.asExecutable(bindMethodElement.element());
+      VariableElement parameterElement = Iterables.getOnlyElement(method.getParameters());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(bindMethodElement.asMemberOfContributingType(types));
+      checkArgument(isAnnotationPresent(method, Bind.class));
+      TypeMirror parameterType = Iterables.getOnlyElement(methodType.getParameterTypes());
+      return forQualifiedType(getQualifier(parameterElement), parameterType);
+    }
+
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
         ExecutableElement method,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 781296236..6197712bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.Bind;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -67,12 +68,17 @@
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
   abstract ImmutableSet<ContributionBinding> bindings();
-  
+
   /**
    * The multibinding declarations contained in this module.
    */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
+  /**
+   * The {@link Bind} method declarations that define delegate bindings.
+   */
+  abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
+
   enum DefaultCreationStrategy {
     PASSED,
     CONSTRUCTED,
@@ -138,16 +144,19 @@
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
+    private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
-        MultibindingDeclaration.Factory multibindingDeclarationFactory) {
+        MultibindingDeclaration.Factory multibindingDeclarationFactory,
+        DelegateDeclaration.Factory bindingDelegateDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
+      this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
@@ -158,6 +167,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
       AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
+      ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -165,8 +175,11 @@ ModuleDescriptor create(TypeElement moduleElement) {
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
           bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, Bind.class)) {
+          delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
+        }
       }
-      
+
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
@@ -189,6 +202,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
+          delegates.build(),
           defaultCreationStrategy);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 00d73bda1..f48be2ed5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Bind;
 import dagger.Module;
 import dagger.Provides;
 import java.lang.annotation.Annotation;
@@ -47,6 +48,7 @@
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProvidesMethodValidator providesMethodValidator;
+  private final BindMethodValidator bindMethodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -56,36 +58,30 @@
       ModuleValidator moduleValidator,
       ProvidesMethodValidator providesMethodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
+      BindMethodValidator bindMethodValidator,
       FactoryGenerator factoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.providesMethodValidator = providesMethodValidator;
+    this.bindMethodValidator = bindMethodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Module.class, Provides.class);
+    return ImmutableSet.of(Module.class, Provides.class, Bind.class);
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
-    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
-      if (providesElement.getKind().equals(METHOD)) {
-        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            providesMethodValidator.validate(providesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProvidesMethodsBuilder.add(providesMethodElement);
-        }
-      }
-    }
-    ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
+    ImmutableSet<ExecutableElement> validProvidesMethods =
+        validateProvidesMethods(elementsByAnnotation);
+
+    // second, check and collect all bind methods
+    ImmutableSet<ExecutableElement> validBindMethods = validateBindMethods(elementsByAnnotation);
 
     // process each module
     for (Element moduleElement :
@@ -97,18 +93,26 @@
       if (report.isClean()) {
         ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
             ImmutableSet.builder();
+        ImmutableSet.Builder<ExecutableElement> moduleBindMethodsBuilder =
+            ImmutableSet.builder();
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(moduleElement.getEnclosedElements());
         for (ExecutableElement methodElement : moduleMethods) {
           if (isAnnotationPresent(methodElement, Provides.class)) {
             moduleProvidesMethodsBuilder.add(methodElement);
           }
+          if (isAnnotationPresent(methodElement, Bind.class)) {
+            moduleBindMethodsBuilder.add(methodElement);
+          }
         }
         ImmutableSet<ExecutableElement> moduleProvidesMethods =
             moduleProvidesMethodsBuilder.build();
+        ImmutableSet<ExecutableElement> moduleBindMethods =
+            moduleBindMethodsBuilder.build();
 
-        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
-          // all of the provides methods in this module are valid!
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()
+            && Sets.difference(moduleBindMethods, validBindMethods).isEmpty()) {
+          // all of the provides and bind methods in this module are valid!
           // time to generate some factories!
           ImmutableSet<ProvisionBinding> bindings =
               FluentIterable.from(moduleProvidesMethods)
@@ -136,4 +140,41 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
     }
     return ImmutableSet.of();
   }
+
+  /* TODO(gak): Add an interface for Validators and combine these two methods and the ones in
+   * ProducerModuleProcessingStep */
+
+  private ImmutableSet<ExecutableElement> validateBindMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validBindMethodsBuilder = ImmutableSet.builder();
+    for (Element bindElement : elementsByAnnotation.get(Bind.class)) {
+      if (bindElement.getKind().equals(METHOD)) {
+        ExecutableElement bindMethodElement = (ExecutableElement) bindElement;
+        ValidationReport<ExecutableElement> methodReport =
+            bindMethodValidator.validate(bindMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validBindMethodsBuilder.add(bindMethodElement);
+        }
+      }
+    }
+    return validBindMethodsBuilder.build();
+  }
+
+  private ImmutableSet<ExecutableElement> validateProvidesMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
+    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
+    return validProvidesMethodsBuilder.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 9bb5fd1b5..ce2677547 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -26,10 +26,12 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
+import dagger.Bind;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.EnumSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -53,13 +55,14 @@
 import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
@@ -86,13 +89,30 @@
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
+
+    Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
     for (ExecutableElement moduleMethod : moduleMethods) {
       if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+        methodKinds.add(
+            moduleMethod.getModifiers().contains(STATIC)
+                ? ModuleMethodKind.STATIC_BINDING
+                : ModuleMethodKind.INSTANCE_BINDING);
+      } else if (isAnnotationPresent(moduleMethod, Bind.class)) {
+        methodKinds.add(ModuleMethodKind.ABSTRACT_DECLARATION);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
 
+    if (methodKinds.containsAll(
+        EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {
+      builder.addError(
+          String.format(
+              INCOMPATIBLE_MODULE_METHODS,
+              moduleKind.moduleAnnotation().getSimpleName(),
+              moduleKind.methodAnnotation().getSimpleName()));
+    }
+
     validateModuleVisibility(subject, moduleKind, builder);
     validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
@@ -106,6 +126,12 @@
     return builder.build();
   }
 
+  enum ModuleMethodKind {
+    ABSTRACT_DECLARATION,
+    INSTANCE_BINDING,
+    STATIC_BINDING,
+  }
+
   private void validateModifiers(
       TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
@@ -138,8 +164,8 @@ private void validateReferencedModules(
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
-    ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
+    ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
+    validateReferencedModules(subject, mirror, builder, includes, ImmutableSet.of(moduleKind));
   }
 
   private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
@@ -161,14 +187,15 @@ private void validateReferencedModules(
    */
   void validateReferencedModules(
       final TypeElement subject,
+      final AnnotationMirror moduleAnnotation,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes,
+      ImmutableList<TypeMirror> includes,
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
     final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
         includedModuleClasses(validModuleKinds);
 
-    for (TypeMirror includedType : includedTypes) {
-      includedType.accept(
+    for (TypeMirror includesType : includes) {
+      includesType.accept(
           new SimpleTypeVisitor6<Void, Void>() {
             @Override
             protected Void defaultAction(TypeMirror mirror, Void p) {
@@ -213,12 +240,6 @@ public String apply(
                                             }))),
                     subject);
               }
-              if (element.getModifiers().contains(ABSTRACT)) {
-                builder.addError(
-                    String.format(
-                        REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, element.getQualifiedName()),
-                    subject);
-              }
               return null;
             }
           },
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index d3873e969..40b2dd1b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Bind;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -48,6 +49,7 @@
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProducesMethodValidator producesMethodValidator;
+  private final BindMethodValidator bindMethodValidator;
   private final ProductionBinding.Factory productionBindingFactory;
   private final ProducerFactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -56,11 +58,13 @@
       Messager messager,
       ModuleValidator moduleValidator,
       ProducesMethodValidator producesMethodValidator,
+      BindMethodValidator bindMethodValidator,
       ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator factoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.producesMethodValidator = producesMethodValidator;
+    this.bindMethodValidator = bindMethodValidator;
     this.productionBindingFactory = productionBindingFactory;
     this.factoryGenerator = factoryGenerator;
   }
@@ -74,19 +78,11 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all produces methods
-    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
-    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
-      if (producesElement.getKind().equals(METHOD)) {
-        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            producesMethodValidator.validate(producesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProducesMethodsBuilder.add(producesMethodElement);
-        }
-      }
-    }
-    ImmutableSet<ExecutableElement> validProducesMethods = validProducesMethodsBuilder.build();
+    ImmutableSet<ExecutableElement> validProducesMethods =
+        validateProducesMethods(elementsByAnnotation);
+
+    // second, check and collect all bind methods
+    ImmutableSet<ExecutableElement> validBindMethods = validateBindMethods(elementsByAnnotation);
 
     // process each module
     for (Element moduleElement :
@@ -100,17 +96,24 @@
         if (report.isClean()) {
           ImmutableSet.Builder<ExecutableElement> moduleProducesMethodsBuilder =
               ImmutableSet.builder();
+          ImmutableSet.Builder<ExecutableElement> moduleBindMethodsBuilder =
+              ImmutableSet.builder();
           List<ExecutableElement> moduleMethods =
               ElementFilter.methodsIn(moduleElement.getEnclosedElements());
           for (ExecutableElement methodElement : moduleMethods) {
             if (isAnnotationPresent(methodElement, Produces.class)) {
               moduleProducesMethodsBuilder.add(methodElement);
             }
+            if (isAnnotationPresent(methodElement, Bind.class)) {
+              moduleBindMethodsBuilder.add(methodElement);
+            }
           }
           ImmutableSet<ExecutableElement> moduleProducesMethods =
               moduleProducesMethodsBuilder.build();
+          ImmutableSet<ExecutableElement> moduleBindMethods = moduleBindMethodsBuilder.build();
 
-          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
+          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()
+              && Sets.difference(moduleBindMethods, validBindMethods).isEmpty()) {
             // all of the produces methods in this module are valid!
             // time to generate some factories!
             ImmutableSet<ProductionBinding> bindings =
@@ -141,4 +144,38 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
     }
     return ImmutableSet.of();
   }
+
+  private ImmutableSet<ExecutableElement> validateProducesMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
+    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
+      if (producesElement.getKind().equals(METHOD)) {
+        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            producesMethodValidator.validate(producesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProducesMethodsBuilder.add(producesMethodElement);
+        }
+      }
+    }
+    return validProducesMethodsBuilder.build();
+  }
+
+  private ImmutableSet<ExecutableElement> validateBindMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validBindMethodsBuilder = ImmutableSet.builder();
+    for (Element bindElement : elementsByAnnotation.get(Bind.class)) {
+      if (bindElement.getKind().equals(METHOD)) {
+        ExecutableElement bindMethodElement = (ExecutableElement) bindElement;
+        ValidationReport<ExecutableElement> methodReport =
+            bindMethodValidator.validate(bindMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validBindMethodsBuilder.add(bindMethodElement);
+        }
+      }
+    }
+    return validBindMethodsBuilder.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index ce2479008..2771aa161 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -31,6 +31,7 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -50,14 +51,13 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import javax.lang.model.util.Types;
-
 /**
  * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
@@ -132,7 +132,7 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
-    ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
+    validateMethodQualifiers(builder, producesMethodElement);
 
     switch (producesAnnotation.type()) {
       case UNIQUE: // fall through
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 9aa840e50..3cc8ceb83 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -202,5 +202,21 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
+
+    ProductionBinding delegate(
+        DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
+      return new AutoValue_ProductionBinding(
+          delegateDeclaration.sourceElement(),
+          delegateDeclaration.key(),
+          ImmutableSet.of(delegateDeclaration.delegateRequest()),
+          findBindingPackage(delegateDeclaration.key()),
+          delegateBinding.nullableType(),
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC_DELEGATE_BINDING,
+          delegateBinding.productionType(),
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
+          Optional.<DependencyRequest>absent());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 61420df59..43b8562ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -30,6 +30,7 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -43,22 +44,17 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
+import static dagger.internal.codegen.Validation.validateReturnType;
+import static dagger.internal.codegen.Validation.validateUncheckedThrows;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import javax.lang.model.util.Types;
-
 /**
  * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
@@ -110,16 +106,7 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
     }
 
-    TypeMirror runtimeExceptionType =
-        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : providesMethodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, runtimeExceptionType)
-          && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(PROVIDES_METHOD_THROWS, providesMethodElement);
-        break;
-      }
-    }
+    validateUncheckedThrows(elements, types, providesMethodElement, Provides.class, builder);
 
     for (VariableElement parameter : providesMethodElement.getParameters()) {
       if (FrameworkTypes.isProducerType(parameter.asType())) {
@@ -139,10 +126,10 @@ private TypeElement getSetElement() {
     switch (providesAnnotation.type()) {
       case UNIQUE: // fall through
       case SET:
-        validateKeyType(builder, returnType);
+        validateReturnType(Provides.class, builder, returnType);
         break;
       case MAP:
-        validateKeyType(builder, returnType);
+        validateReturnType(Provides.class, builder, returnType);
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
         switch (mapKeys.size()) {
           case 0:
@@ -169,7 +156,9 @@ private TypeElement getSetElement() {
             builder.addError(
                 formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
           } else {
-            validateKeyType(builder,
+            validateReturnType(
+                Provides.class,
+                builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
           }
         }
@@ -181,17 +170,6 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
-  /** Validates that a Provides or Produces method doesn't have multiple qualifiers. */
-  static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement methodElement) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
-      }
-    }
-  }
-
   private String formatErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName());
   }
@@ -199,15 +177,4 @@ private String formatErrorMessage(String msg) {
   private String formatModuleErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
   }
-
-  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index ee3f692c6..7e935d30f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -63,7 +63,7 @@ public BindingType bindingType() {
 
   @Override
   abstract Optional<Scope> scope();
-  
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -177,7 +177,7 @@ ProvisionBinding forProvidesMethod(
           Optional.<ProvisionBinding>absent(),
           scope);
     }
-    
+
     /**
      * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
      */
@@ -277,5 +277,20 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
+
+    ProvisionBinding delegate(
+        DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
+      return new AutoValue_ProvisionBinding(
+          delegateDeclaration.sourceElement(),
+          delegateDeclaration.key(),
+          ImmutableSet.of(delegateDeclaration.delegateRequest()),
+          findBindingPackage(delegateDeclaration.key()),
+          delegate.nullableType(),
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC_DELEGATE_BINDING,
+          delegate.provisionType(),
+          Optional.<ProvisionBinding>absent(),
+          Scope.uniqueScopeOf(delegateDeclaration.sourceElement().element()));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1b941ceab..6e57fc4bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,8 +16,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import dagger.Bind;
+import dagger.Provides;
+import dagger.producers.Produces;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -25,6 +29,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -34,6 +39,32 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
+  /**
+   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
+   * within a component.
+   */
+  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {
+    ImmutableSet<ExecutableElement> methods =
+        MoreElements.getLocalAndInheritedMethods(typeElement, elements);
+    boolean foundInstanceMethod = false;
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Bind.class)) {
+        /* We found an abstract method that isn't a @Bind method.  That automatically means that
+         * a user will have to provide an instance because we don't know which subclass to use. */
+        return true;
+      } else if (!method.getModifiers().contains(STATIC)
+          && (isAnnotationPresent(method, Provides.class)
+              || isAnnotationPresent(method, Produces.class))) {
+        foundInstanceMethod = true;
+      }
+    }
+
+    if (foundInstanceMethod) {
+      return !componentCanMakeNewInstances(typeElement);
+    }
+
+    return false;
+  }
 
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validation.java b/compiler/src/main/java/dagger/internal/codegen/Validation.java
new file mode 100644
index 000000000..4a2c659b8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validation.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+
+final class Validation {
+
+  private Validation() {}
+
+  /** Validates that the given method only throws unchecked exceptions. */
+  static void validateUncheckedThrows(
+      Elements elements,
+      Types types,
+      ExecutableElement methodElement,
+      Class<? extends Annotation> methodAnnotation,
+      ValidationReport.Builder<ExecutableElement> builder) {
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(
+            String.format(BINDING_METHOD_THROWS_CHECKED, methodAnnotation.getSimpleName()),
+            methodElement);
+        break;
+      }
+    }
+  }
+
+  /** Validates that the return type of a binding method is an acceptable kind. */
+  static void validateReturnType(
+      Class<? extends Annotation> methodAnnotation,
+      ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror returnType) {
+    TypeKind kind = returnType.getKind();
+    if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      reportBuilder.addError(
+          String.format(BINDING_METHOD_RETURN_TYPE, methodAnnotation.getSimpleName()),
+          reportBuilder.getSubject());
+    }
+  }
+
+  /** Validates that a Provides, Produces or Bind method doesn't have multiple qualifiers. */
+  static void validateMethodQualifiers(
+      ValidationReport.Builder<ExecutableElement> builder, ExecutableElement methodElement) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+      }
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java
new file mode 100644
index 000000000..273b28a7e
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(Parameterized.class)
+public class BindMethodValidatorTest {
+  @Parameters
+  public static Collection<Object[]> data() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final Class<? extends Annotation> moduleAnnotation;
+
+  public BindMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    this.moduleAnnotation = moduleAnnotation;
+  }
+
+  @Test
+  public void nonAbstract() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Bind Object bindObject(String impl) { return null; }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("must be abstract")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void notAssignable() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Bind abstract String bindString(Object impl);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("assignable")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void moreThanOneParamter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Bind abstract Object bindObject(String s1, String s2);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("one parameter")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void typeParameters() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Bind abstract <S, T extends S> S bindS(T t);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("type parameters")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void notInModule() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "",
+            "abstract class TestModule {",
+            "  @Bind abstract Object bindObject(String s);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("within a @Module or @ProducerModule")
+        .in(moduleFile)
+        .onLine(6);
+  }
+
+  @Test
+  public void throwsException() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Bind;",
+            "import java.io.IOException;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Bind abstract Object bindObject(String s1) throws IOException;",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("only throw unchecked")
+        .in(moduleFile)
+        .onLine(8);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9b81750f0..a93b7b1e4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -46,7 +46,6 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
@@ -113,36 +112,6 @@
         .withErrorContaining("is not annotated with @Module");
   }
 
-  private void checkCannotReferToModuleOfType(String moduleType) {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        moduleType + " TestModule {}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface BadComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
-  }
-
-  @Test public void cannotReferToAbstractClassModules() {
-    checkCannotReferToModuleOfType("abstract class");
-  }
-
-  @Test public void cannotReferToInterfaceModules() {
-    checkCannotReferToModuleOfType("interface");
-  }
-
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 63c5821e5..0ecf8c017 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.CompileTester;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
@@ -25,19 +26,20 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -170,7 +172,7 @@ private String formatModuleErrorMessage(String msg) {
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+        .withErrorContaining(String.format(BINDING_METHOD_RETURN_TYPE, "Provides"));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
@@ -333,28 +335,6 @@ private String formatModuleErrorMessage(String msg) {
                 ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
 
-  @Test public void referencedModulesMustNotBeAbstract() {
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = AbstractModule.class)",
-        "class TestModule {}");
-    JavaFileObject abstractModule = JavaFileObjects.forSourceLines("test.AbstractModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "abstract class AbstractModule {}");
-    assertAbout(javaSources()).that(ImmutableList.of(module, abstractModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
-            "test.AbstractModule"));
-  }
-
   @Test public void singleProvidesMethodNoArgs() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -782,11 +762,11 @@ public void providesMethodThrowsChecked() {
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
         .in(moduleFile)
         .onLine(8)
         .and()
-        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
         .in(moduleFile)
         .onLine(12);
   }
@@ -1258,7 +1238,7 @@ public void genericSubclassedModule() {
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
 
   @Test public void providerDependsOnProduced() {
@@ -1300,4 +1280,72 @@ public void genericSubclassedModule() {
         .failsToCompile()
         .withErrorContaining("Produced may only be injected in @Produces methods");
   }
+
+  private static final String BIND_METHOD = "@Bind abstract Foo bindFoo(FooImpl impl);";
+  private static final String STATIC_PROVIDES_METHOD =
+      "@Provides static Bar provideBar() { return new Bar(); }";
+  private static final String INSTANCE_PROVIDES_METHOD =
+      "@Provides Baz provideBaz() { return new Baz(); }";
+  private static final String SOME_ABSTRACT_METHOD = "abstract void blah();";
+
+  @Test
+  public void moduleMethodPermutations() {
+    assertThatMethodCombination(BIND_METHOD, INSTANCE_PROVIDES_METHOD)
+        .failsToCompile()
+        .withErrorContaining("not both at the same time");
+    assertThatMethodCombination(BIND_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
+        .compilesWithoutError();
+  }
+
+  private CompileTester assertThatMethodCombination(String... methodLines) {
+    JavaFileObject fooFile =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "interface Foo {}");
+    JavaFileObject fooImplFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooImpl",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+    JavaFileObject barFile =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "final class Bar {}");
+    JavaFileObject bazFile =
+        JavaFileObjects.forSourceLines(
+            "test.Baz",
+            "package test;",
+            "",
+            "final class Baz {}");
+
+    ImmutableList<String> moduleLines =
+        new ImmutableList.Builder<String>()
+            .add(
+                "package test;",
+                "",
+                "import dagger.Bind;",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module abstract class TestModule {")
+            .add(methodLines)
+            .add("}")
+            .build();
+
+    JavaFileObject bindMethodAndInstanceProvidesMethodModuleFile =
+        JavaFileObjects.forSourceLines("test.TestModule", moduleLines);
+    return assertThat(
+            fooFile, fooImplFile, barFile, bazFile, bindMethodAndInstanceProvidesMethodModuleFile)
+        .processedWith(new ComponentProcessor());
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index f9ea63cfb..e5da7cce1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -27,6 +27,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
@@ -37,7 +38,6 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -685,6 +685,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
 }
diff --git a/core/src/main/java/dagger/Bind.java b/core/src/main/java/dagger/Bind.java
new file mode 100644
index 000000000..09a5e7560
--- /dev/null
+++ b/core/src/main/java/dagger/Bind.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates <em>abstract</em> methods of a {@link Module} that delegate bindings. For example, to
+ * bind {@link java.util.Random} to {@link java.security.SecureRandom} a module could declare the
+ * following: {@code @Bind abstract Random bindRandom(SecureRandom secureRandom);}
+ *
+ * <p>{@code @Bind} methods are a drop-in replacement for {@link Provides} methods that simply
+ * return an injected parameter.  Prefer {@code @Bind} because the generated implementation is
+ * likely to be more efficient.
+ *
+ * <p>A {@code @Bind} method:
+ * <ul>
+ * <li>Must be {@code abstract}.
+ * <li>Must have a single parameter whose type is assignable to the return type.  The return type is
+ * the bound type and the parameter is the type to which it is bound.
+ * <li>May be {@linkplain javax.inject.Scope scoped}.
+ * <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ * </ul>
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(METHOD)
+public @interface Bind {}
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 6498eae31..513722929 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -53,9 +53,15 @@ public T get() {
     return (T) result;
   }
 
-  /** Returns a new provider that caches the value from the given factory. */
-  public static <T> Provider<T> provider(Factory<T> factory) {
-    return new DoubleCheck<T>(checkNotNull(factory));
+  /** Returns a {@link Provider} that caches the value from the given delegate provider. */
+  public static <T> Provider<T> provider(Provider<T> delegate) {
+    checkNotNull(delegate);
+    if (delegate instanceof DoubleCheck) {
+      /* This should be a rare case, but if we have a scoped @Bind that delegates to a scoped
+       * binding, we shouldn't cache the value again. */
+      return delegate;
+    }
+    return new DoubleCheck<T>(delegate);
   }
 
   /** Returns a {@link Lazy} that caches the value from the given provider. */
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index 400d26825..ca57f71bd 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -21,8 +21,8 @@
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
  * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider(Factory)} is
- * valid and may be desired for testing or contractual guarantees.
+ * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index af110f49b..280dccf25 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -28,11 +28,11 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
 
@@ -56,7 +56,29 @@ public void lazy_nullPointerException() {
     }
   }
 
-  @Test public void get() throws Exception {
+  private static final Provider<Object> DOUBLE_CHECK_OBJECT_PROVIDER =
+      DoubleCheck.provider(
+          new Provider<Object>() {
+            @Override
+            public Object get() {
+              return new Object();
+            }
+          });
+
+  @Test
+  public void doubleWrapping_provider() {
+    assertThat(DoubleCheck.provider(DOUBLE_CHECK_OBJECT_PROVIDER))
+        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);
+  }
+
+  @Test
+  public void doubleWrapping_lazy() {
+    assertThat(DoubleCheck.lazy(DOUBLE_CHECK_OBJECT_PROVIDER))
+        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);
+  }
+
+  @Test
+  public void get() throws Exception {
     int numThreads = 10;
     ExecutorService executor = Executors.newFixedThreadPool(numThreads);
 
@@ -66,12 +88,14 @@ public void lazy_nullPointerException() {
 
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
-      tasks.add(new Callable<Object>() {
-        @Override public Object call() throws Exception {
-          latch.countDown();
-          return lazy.get();
-        }
-      });
+      tasks.add(
+          new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+              latch.countDown();
+              return lazy.get();
+            }
+          });
     }
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
