diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index a8d5588fc..88c6b8b0b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,27 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.type.TypeKind.VOID;
-
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -54,20 +33,17 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javawriter.JavaWriter;
-
 import dagger.Component;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
-
 import java.io.IOException;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
@@ -77,10 +53,32 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -90,11 +88,13 @@
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
   private final Elements elements;
   private final Types types;
+  private final Key.Factory keyFactory;
 
-  ComponentGenerator(Filer filer, Elements elements, Types types) {
+  ComponentGenerator(Filer filer, Elements elements, Types types, Key.Factory keyFactory) {
     super(filer);
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
+    this.keyFactory = keyFactory;
   }
 
   @Override
@@ -282,7 +282,7 @@ public String apply(TypeElement input) {
     writer.endConstructor().emitEmptyLine();
   }
 
-  private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
+  private String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
       ImmutableBiMap<TypeElement, String> moduleNames,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
@@ -296,7 +296,7 @@ private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBi
       }
       if (binding.requiresMemberInjection()) {
         String membersInjectorName =
-            membersInjectorNames.get(Key.create(binding.providedKey().type()));
+            membersInjectorNames.get(keyFactory.forType(binding.providedKey().type()));
         if (membersInjectorName != null) {
           parameters.add(membersInjectorName);
         } else {
@@ -364,9 +364,7 @@ private void writeInterfaceMethods(JavaWriter writer,
 
   private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement methodElement)
       throws IOException {
-    String returnTypeString = methodElement.getReturnType().getKind().equals(VOID)
-        ? "void"
-        : writer.compressType(Util.typeToString(methodElement.getReturnType()));
+    String returnTypeString = writer.compressType(returnTypeString(methodElement.getReturnType()));
     String methodName = methodElement.getSimpleName().toString();
     Set<Modifier> modifiers = Sets.difference(methodElement.getModifiers(), EnumSet.of(ABSTRACT));
     ImmutableList.Builder<String> parametersBuilder = ImmutableList.builder();
@@ -387,6 +385,18 @@ private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement meth
             thrownTypesBuilder.build());
   }
 
+  private String returnTypeString(TypeMirror returnType) {
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      return "void";
+    } else if (returnTypeKind.isPrimitive()) {
+      // TypeMirrors don't have names but PrimitiveType#toString() reflects the simple type name.
+      return returnType.toString();
+    }
+    // Util.typeToString() does boxing, so cannot be used for primitive types.
+    return Util.typeToString(returnType);
+  }
+
   private String providerTypeString(Key key) {
     return Util.typeToString(types.getDeclaredType(
         elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index bb280b488..82a9f343a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,18 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import static javax.lang.model.SourceVersion.RELEASE_6;
-
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -38,6 +33,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static javax.lang.model.SourceVersion.RELEASE_6;
+
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -76,11 +73,12 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
 
-    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
-
     Key.Factory keyFactory = new Key.Factory(types, elements);
+
+    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(keyFactory);
+
     DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types);
+        new DependencyRequest.Factory(elements, types, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     InjectionSite.Factory injectionSiteFactory =
@@ -92,7 +90,8 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, types);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, elements, types, keyFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new InjectProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 35d0d44ff..e960aa07c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,22 +15,16 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
-
 import java.util.List;
-
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -42,6 +36,9 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -71,10 +68,12 @@
   static final class Factory {
     private final Elements elements;
     private final Types types;
+    private final Key.Factory keyFactory;
 
-    Factory(Elements elements, Types types) {
+    Factory(Elements elements, Types types, Key.Factory keyFactory) {
       this.elements = elements;
       this.types = types;
+      this.keyFactory = keyFactory;
     }
 
     ImmutableList<DependencyRequest> forRequiredVariables(
@@ -108,13 +107,13 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          Key.create(qualifier,
+          keyFactory.forQualifiedType(qualifier,
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod);
     }
 
     DependencyRequest forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR, Key.create(type),
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR, keyFactory.forType(type),
           types.asElement(type));
     }
 
@@ -124,23 +123,27 @@ private DependencyRequest newDependencyRequest(Element requestElement, TypeMirro
           .equals(types.asElement(type))) {
         DeclaredType providerType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.PROVIDER,
-            Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(providerType.getTypeArguments())),
             requestElement);
       } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType lazyType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.LAZY,
-            Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(lazyType.getTypeArguments())),
             requestElement);
       } else if (elements.getTypeElement(MembersInjector.class.getCanonicalName())
           .equals(types.asElement(type))) {
         checkArgument(!qualifier.isPresent());
         DeclaredType membersInjectorType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-            Key.create(qualifier, Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
             requestElement);
       } else {
-        return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
+        return new AutoValue_DependencyRequest(Kind.INSTANCE,
+            keyFactory.forQualifiedType(qualifier, type),
             requestElement);
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 7cd6c8421..e4fb2586e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -15,16 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-
 import com.google.common.base.Optional;
 import com.google.common.collect.Maps;
-
 import java.util.Map;
-
 import javax.inject.Inject;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
@@ -34,10 +32,12 @@
 final class InjectBindingRegistry {
   private final Map<Key, ProvisionBinding> provisionBindingsByKey;
   private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
+  private final Key.Factory keyFactory;
 
-  InjectBindingRegistry() {
+  InjectBindingRegistry(Key.Factory keyFactory) {
     this.provisionBindingsByKey = Maps.newLinkedHashMap();
     this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
+    this.keyFactory = keyFactory;
   }
 
   void registerProvisionBinding(ProvisionBinding binding) {
@@ -47,7 +47,7 @@ void registerProvisionBinding(ProvisionBinding binding) {
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        Key.create(binding.injectedType().asType()), binding);
+        keyFactory.forType(binding.injectedType().asType()), binding);
     checkState(previousValue == null);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f7ab2aa23..216fcb2fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,32 +15,30 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.type.TypeKind.DECLARED;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-
 import dagger.Provides;
-
 import java.util.Set;
-
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
+
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
  * {@linkplain Qualifier qualifier} to which binding can occur.
@@ -49,11 +47,17 @@
  */
 @AutoValue
 abstract class Key {
+  /**
+   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
+   * for the type of this key.
+   */
   abstract Optional<AnnotationMirror> qualifier();
 
   /**
+   * The type represented by this key.
+   *
    * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
-   * logical equality, so we use {@link MoreTypes#equivalence()} for this object.
+   * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
@@ -70,15 +74,6 @@ public String toString() {
         .toString();
   }
 
-  static Key create(TypeMirror type) {
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
-        MoreTypes.equivalence().wrap(type));
-  }
-
-  static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(type));
-  }
-
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -90,7 +85,7 @@ static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
 
     private TypeMirror normalize(TypeMirror type) {
       TypeKind kind = type.getKind();
-      return kind.isPrimitive() ? types.getPrimitiveType(kind) : type;
+      return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
     }
 
     private TypeElement getSetElement() {
@@ -129,5 +124,14 @@ Key forInjectConstructor(ExecutableElement e) {
       return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
           MoreTypes.equivalence().wrap(type));
     }
+
+    Key forType(TypeMirror type) {
+      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+          MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+      return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(normalize(type)));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index f017d866c..c3276c1f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,28 +15,15 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-
 import dagger.Component;
 import dagger.Provides;
-
 import java.util.Iterator;
-
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -46,6 +33,16 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
  * should be created using an instance of the {@link Factory}.
@@ -175,7 +172,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           ImmutableList.<DependencyRequest>of(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Key.create(componentDefinitionType.asType()),
+          keyFactory.forType(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
           false);
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index f903d3050..fc7a911f6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,18 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static org.truth0.Truth.ASSERT;
-
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
-
 import dagger.Module;
 import dagger.Provides;
-
+import java.util.List;
 import java.util.Set;
-
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.lang.model.element.ExecutableElement;
@@ -36,13 +30,16 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static org.truth0.Truth.ASSERT;
+
 /**
  * Tests {@link Key}.
  */
@@ -50,10 +47,14 @@
 public class KeyTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
+  private Elements elements;
+  private Types types;
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
-    this.keyFactory = new Key.Factory(compilationRule.getTypes(), compilationRule.getElements());
+    this.elements = compilationRule.getElements();
+    this.types = compilationRule.getTypes();
+    this.keyFactory = new Key.Factory(types, elements);
   }
 
   @Test public void forInjectConstructor() {
@@ -62,7 +63,7 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     ASSERT.that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(Key.create(typeElement.asType()));
+        .isEqualTo(keyFactory.forType(typeElement.asType()));
   }
 
   static final class InjectedClass {
@@ -71,13 +72,13 @@
   }
 
   @Test public void forProvidesMethod() {
-    Elements elements = compilationRule.getElements();
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement moduleElement =
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    ASSERT.that(keyFactory.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
+    ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
+        .isEqualTo(keyFactory.forType(stringType));
   }
 
   @Module(library = true)
@@ -88,7 +89,6 @@
   }
 
   @Test public void forProvidesMethod_qualified() {
-    Elements elements = compilationRule.getElements();
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement qualifierElement =
         elements.getTypeElement(TestQualifier.class.getCanonicalName());
@@ -113,8 +113,6 @@
   @interface TestQualifier {}
 
   @Test public void forProvidesMethod_sets() {
-    Elements elements = compilationRule.getElements();
-    Types types = compilationRule.getTypes();
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
@@ -123,7 +121,7 @@
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
       ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(Key.create(setOfStringsType));
+          .isEqualTo(keyFactory.forType(setOfStringsType));
     }
   }
 
@@ -137,4 +135,25 @@
       return null;
     }
   }
+
+  interface PrimitiveTypes {
+    int foo();
+    Integer bar();
+  }
+
+  @Test public void primitiveKeysMatchBoxedKeys() {
+    TypeElement holder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
+    List<ExecutableElement> methods = (List<ExecutableElement>) holder.getEnclosedElements();
+
+    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
+    TypeMirror intType = methods.get(0).getReturnType();
+    ASSERT.that(intType.getKind().isPrimitive()).isTrue();
+    TypeMirror integerType = methods.get(1).getReturnType();
+    ASSERT.that(integerType.getKind().isPrimitive()).isFalse();
+    ASSERT.that(types.isSameType(intType, integerType)).named("type equality").isFalse();
+
+    Key intKey = keyFactory.forType(intType);
+    Key integerKey = keyFactory.forType(integerType);
+    ASSERT.that(intKey).isEqualTo(integerKey);
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 6b6bbf81c..9f83b1c1a 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -16,49 +16,92 @@
  */
 package dagger.tests.integration.operation;
 
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
-  static class ArrayInjectable {
-    @Inject byte[] byteArray;
-    @Inject int[] integerArray;
-    @Inject boolean[] booleanArray;
-    @Inject char[] charArray;
-    @Inject long[] longArray;
-    @Inject float[] floatArray;
-    @Inject double[] doubleArray;
-  }
 
-  @Module(injects = ArrayInjectable.class)
-  static class PrimitiveArrayModule {
-    @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
-    @Provides int[] intArray() { return new int[] { Integer.MAX_VALUE }; }
-    @Provides boolean[] booleanArray() { return new boolean[] { true }; }
-    @Provides long[] longArray() { return new long[] { Long.MAX_VALUE }; }
-    @Provides char[] charArray() { return new char[] { Character.MAX_VALUE }; }
-    @Provides float[] floatArray() { return new float[] { Float.MAX_VALUE }; }
-    @Provides double[] doubleArray() { return new double[] { Double.MAX_VALUE }; }
-  }
+  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
+  /*
+  JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
+      "package test;",
+      "import javax.inject.Qualifier;",
+      "@Qualifier",
+      "public @interface ForTest {",
+      "}");
+  */
+
+  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
+  JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
+      "package test;",
+      "import javax.inject.Inject;",
+      "class PrimitiveInjectable {",
+      "  @Inject PrimitiveInjectable(int ignored) {}",
+      "}");
+
+  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
+      "package test;",
+      "import dagger.Module;",
+      "import dagger.Provides;",
+      "@Module",
+      "class PrimitiveModule {",
+      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
+      "}");
+
+  JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
+      "package test;",
+      "import dagger.Component;",
+      "import dagger.Provides;",
+      "@Component(modules = PrimitiveModule.class)",
+      "interface PrimitiveComponent {",
+      "  int primitiveInt();",
+      "  PrimitiveInjectable primitiveInjectable();",
+      "}");
+
+  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
+      "test.Dagger_PrimitiveComponent",
+      "package test;",
+      "import javax.annotation.Generated;",
+      "import javax.inject.Provider;",
+      "",
+      "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+      "public final class Dagger_PrimitiveComponent implements PrimitiveComponent {",
+      "  private final PrimitiveModule primitiveModule;",
+      "  private final Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+      "  private final Provider<Integer> primitiveIntProvider;",
+      "  public Dagger_PrimitiveComponent(PrimitiveModule primitiveModule) {",
+      "    if (primitiveModule == null) {",
+      "      throw new NullPointerException(\"primitiveModule\");",
+      "    }",
+      "    this.primitiveModule = primitiveModule;",
+      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
+      "    this.primitiveInjectableProvider = ",
+      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "  }",
+      "  @Override",
+      "  public int primitiveInt() {",
+      "    return primitiveIntProvider.get();",
+      "  }",
+      "  @Override",
+      "  public PrimitiveInjectable primitiveInjectable() {",
+      "    return primitiveInjectableProvider.get();",
+      "  }",
+      "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
-    ArrayInjectable result = ObjectGraph.create(PrimitiveArrayModule.class)
-        .get(ArrayInjectable.class);
-    assertThat(result).isNotNull();
-    assertThat(result.byteArray).isEqualTo(new byte[] { Byte.MAX_VALUE });
-    assertThat(result.integerArray).isEqualTo(new int[] { Integer.MAX_VALUE });
-    assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
-    assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
-    assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
-    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
-    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
+    ASSERT.about(javaSources())
+        .that(asList(component, primitiveInjectable, primitiveModule))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedComponent);
   }
 }
