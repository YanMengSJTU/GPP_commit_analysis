diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 26c26d8a5..609ae1654 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -82,6 +82,7 @@ java_library(
         "CompilerOptions.java",
         "ContributionType.java",
         "DaggerElements.java",
+        "DaggerGraphs.java",
         "DaggerTypes.java",
         "DiagnosticFormatting.java",
         "Expression.java",
@@ -220,6 +221,7 @@ java_library(
         "DependencyMethodProducerCreationExpression.java",
         "DependencyMethodProviderCreationExpression.java",
         "DerivedFromProviderBindingExpression.java",
+        "DoubleCheckedMethodImplementation.java",
         "FactoryGenerator.java",
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
@@ -251,14 +253,15 @@ java_library(
         "ReferenceReleasingManagerFields.java",
         "ReleasableReferenceManagerProviderCreationExpression.java",
         "ReleasableReferenceManagerSetProviderCreationExpression.java",
-        "ScopedInstanceMethodImplementation.java",
         "SetBindingExpression.java",
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
         "SimpleMethodBindingExpression.java",
+        "SingleCheckedMethodImplementation.java",
         "SubcomponentBuilderBindingExpression.java",
         "SubcomponentBuilderProviderCreationExpression.java",
         "SubcomponentNames.java",
+        "SwitchingProviders.java",
         "UnwrappedMapKeyGenerator.java",
     ],
     plugins = CODEGEN_PLUGINS,
diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/BindingDeclaration.java
index 31655ad93..ef19c6090 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/BindingDeclaration.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.DaggerElements.ENCLOSING_TYPE_ELEMENT;
-
 import dagger.model.Key;
 import java.util.Optional;
 import javax.lang.model.element.Element;
@@ -40,7 +38,7 @@
    * #bindingElement()} is empty.
    */
   Optional<TypeElement> bindingTypeElement() {
-    return bindingElement().map(element -> element.accept(ENCLOSING_TYPE_ELEMENT, null));
+    return bindingElement().map(DaggerElements::closestEnclosingTypeElement);
   }
   
   /**
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index e8fb60eeb..b2310e392 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -68,6 +68,8 @@ boolean doCheckForNulls() {
 
   abstract boolean headerCompilation();
 
+  abstract boolean aheadOfTimeComponents();
+
   static Builder builder() {
     return new AutoValue_CompilerOptions.Builder().headerCompilation(false);
   }
@@ -92,6 +94,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElement
         .warnIfInjectionFactoryNotGeneratedUpstream(
             warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(processingEnv)
                 .equals(FeatureStatus.ENABLED))
+        .aheadOfTimeComponents(
+            aheadOfTimeComponentsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .build();
   }
 
@@ -119,6 +123,8 @@ Builder ignorePrivateAndStaticInjectionForComponent(
     Builder warnIfInjectionFactoryNotGeneratedUpstream(
         boolean warnIfInjectionFactoryNotGeneratedUpstream);
 
+    Builder aheadOfTimeComponents(boolean aheadOfTimeComponents);
+
     CompilerOptions build();
   }
 
@@ -150,6 +156,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
   static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
       "dagger.ignorePrivateAndStaticInjectionForComponent";
 
+  static final String AHEAD_OF_TIME_COMPONENTS_KEY = "dagger.experimentalAheadOfTimeComponents";
+
   static final ImmutableSet<String> SUPPORTED_OPTIONS =
       ImmutableSet.of(
           EXPERIMENTAL_ANDROID_MODE,
@@ -160,7 +168,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
           PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
           STATIC_MEMBER_VALIDATION_TYPE_KEY,
           WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-          IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
+          IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
+          AHEAD_OF_TIME_COMPONENTS_KEY);
 
   private static FeatureStatus experimentalAndroidModeFeatureStatus(
       ProcessingEnvironment processingEnv) {
@@ -230,6 +239,15 @@ private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstreamFeatureSt
         EnumSet.allOf(FeatureStatus.class));
   }
 
+  private static FeatureStatus aheadOfTimeComponentsFeatureStatus(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        AHEAD_OF_TIME_COMPONENTS_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 234b8c412..a9587470c 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -67,6 +67,7 @@
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
   private final MembersInjectionMethods membersInjectionMethods;
+  private final SwitchingProviders switchingProviders;
   private final Table<Key, RequestKind, BindingExpression> expressions = HashBasedTable.create();
 
   ComponentBindingExpressions(
@@ -114,6 +115,7 @@ private ComponentBindingExpressions(
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
         new MembersInjectionMethods(generatedComponentModel, this, graph, elements, types);
+    this.switchingProviders = new SwitchingProviders(generatedComponentModel, this, graph, types);
   }
 
   /**
@@ -583,20 +585,20 @@ private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings
    *
    * <p>In Android mode, if {@linkplain #instanceBindingExpression(ResolvedBindings) instance
    * binding expressions} don't call {@code Provider.get()} on the provider binding expression, and
-   * there's no {@linkplain #isFactorySimple(ResolvedBindings) simple factory}, then return an
-   * {@link AnonymousProviderBindingExpression} wrapped in a method.
+   * there's no simple factory, then return a {@link SwitchingProviders} binding expression wrapped
+   * in a method.
    *
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
   private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
     if (compilerOptions.experimentalAndroidMode()) {
-      if (!isFactorySimple(resolvedBindings)
+      if (!frameworkInstanceCreationExpression(resolvedBindings).isSimpleFactory()
           && !(instanceBindingExpression(resolvedBindings)
               instanceof DerivedFromProviderBindingExpression)) {
         return wrapInMethod(
             resolvedBindings,
             RequestKind.PROVIDER,
-            new AnonymousProviderBindingExpression(resolvedBindings, this, types));
+            switchingProviders.newBindingExpression(resolvedBindings.key()));
       }
     } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
         && !needsCaching(resolvedBindings)) {
@@ -606,17 +608,6 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
     return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
   }
 
-  /**
-   * Returns {@code true} if the factory created for a binding is not worth inlining because it's a
-   * singleton or an {@link dagger.internal.InstanceFactory} or a nested {@code Provider} for a
-   * component dependency provision method.
-   */
-  // TODO(dpb): Lazily create the component dependency provision method provider.
-  private boolean isFactorySimple(ResolvedBindings resolvedBindings) {
-    return staticFactoryCreation(resolvedBindings).isPresent()
-        || frameworkInstanceCreationExpression(resolvedBindings).isSimpleFactory();
-  }
-
   /**
    * Returns a binding expression that uses a given one as the body of a method that users call. If
    * a component provision method matches it, it will be the method implemented. If not, a new
@@ -665,17 +656,21 @@ private BindingMethodImplementation methodImplementation(
       ResolvedBindings resolvedBindings,
       RequestKind requestKind,
       BindingExpression bindingExpression) {
-    return compilerOptions.experimentalAndroidMode()
-            && requestKind.equals(RequestKind.INSTANCE)
-            && needsCaching(resolvedBindings)
-        ? new ScopedInstanceMethodImplementation(
-            resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel)
-        : new BindingMethodImplementation(
-            resolvedBindings,
-            requestKind,
-            bindingExpression,
-            generatedComponentModel.name(),
-            types);
+    if (compilerOptions.experimentalAndroidMode()) {
+      if (requestKind.equals(RequestKind.PROVIDER)) {
+        return new SingleCheckedMethodImplementation(
+            resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel);
+      } else if (requestKind.equals(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
+        return resolvedBindings.scope().get().isReusable()
+            ? new SingleCheckedMethodImplementation(
+                resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel)
+            : new DoubleCheckedMethodImplementation(
+                resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel);
+      }
+    }
+
+    return new BindingMethodImplementation(
+        resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 4f98d4abe..0e9d330ef 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -48,7 +48,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleElementVisitor8;
 import javax.lang.model.util.Types;
 
 /** Extension of {@link Elements} that adds Dagger-specific methods. */
@@ -83,23 +83,24 @@ public TypeElement getTypeElement(CharSequence name) {
     return elements.getTypeElement(name);
   }
 
-  /**
-   * A visitor that returns the input or the closest enclosing element that is a
-   * {@link TypeElement}.
-   */
-  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
+  /** Returns the argument or the closest enclosing element that is a {@link TypeElement}. */
+  static TypeElement closestEnclosingTypeElement(Element element) {
+    return element.accept(CLOSEST_ENCLOSING_TYPE_ELEMENT, null);
+  }
+
+  private static final ElementVisitor<TypeElement, Void> CLOSEST_ENCLOSING_TYPE_ELEMENT =
+      new SimpleElementVisitor8<TypeElement, Void>() {
         @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
+        protected TypeElement defaultAction(Element element, Void p) {
+          return element.getEnclosingElement().accept(this, null);
         }
-  
+
         @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
+        public TypeElement visitType(TypeElement type, Void p) {
+          return type;
         }
       };
-      
+
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
diff --git a/java/dagger/internal/codegen/DaggerGraphs.java b/java/dagger/internal/codegen/DaggerGraphs.java
new file mode 100644
index 000000000..066668fc8
--- /dev/null
+++ b/java/dagger/internal/codegen/DaggerGraphs.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.SuccessorsFunction;
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+
+/** Utility methods for {@link com.google.common.graph} types. */
+final class DaggerGraphs {
+  /**
+   * Returns a shortest path from {@code nodeU} to {@code nodeV} in {@code graph} as a list of the
+   * nodes visited in sequence, including both {@code nodeU} and {@code nodeV}. (Note that there may
+   * be many possible shortest paths.)
+   *
+   * <p>If {@code nodeV} is not {@link
+   * com.google.common.graph.Graphs#reachableNodes(com.google.common.graph.Graph, Object) reachable}
+   * from {@code nodeU}, the list returned is empty.
+   *
+   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not present in {@code
+   *     graph}
+   */
+  static <N> ImmutableList<N> shortestPath(SuccessorsFunction<N> graph, N nodeU, N nodeV) {
+    if (nodeU.equals(nodeV)) {
+      return ImmutableList.of(nodeU);
+    }
+    Set<N> successors = ImmutableSet.copyOf(graph.successors(nodeU));
+    if (successors.contains(nodeV)) {
+      return ImmutableList.of(nodeU, nodeV);
+    }
+
+    Map<N, N> visitedNodeToPathPredecessor = new HashMap<>(); // encodes shortest path tree
+    Queue<N> currentNodes = new ArrayDeque<N>();
+    Queue<N> nextNodes = new ArrayDeque<N>();
+    for (N node : successors) {
+      visitedNodeToPathPredecessor.put(node, nodeU);
+    }
+    currentNodes.addAll(successors);
+
+    // Perform a breadth-first traversal starting with the successors of nodeU.
+    while (!currentNodes.isEmpty()) {
+      while (!currentNodes.isEmpty()) {
+        N currentNode = currentNodes.remove();
+        for (N nextNode : graph.successors(currentNode)) {
+          if (visitedNodeToPathPredecessor.containsKey(nextNode)) {
+            continue; // we already have a shortest path to nextNode
+          }
+          visitedNodeToPathPredecessor.put(nextNode, currentNode);
+          if (nextNode.equals(nodeV)) {
+            ImmutableList.Builder<N> builder = ImmutableList.builder();
+            N node = nodeV;
+            builder.add(node);
+            while (!node.equals(nodeU)) {
+              node = visitedNodeToPathPredecessor.get(node);
+              builder.add(node);
+            }
+            return builder.build().reverse();
+          }
+          nextNodes.add(nextNode);
+        }
+      }
+      Queue<N> emptyQueue = currentNodes;
+      currentNodes = nextNodes;
+      nextNodes = emptyQueue; // reusing empty queue faster than allocating new one
+    }
+
+    return ImmutableList.of();
+  }
+
+  private DaggerGraphs() {}
+}
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index eedd909f1..ef8407041 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -20,6 +20,7 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.PARAM;
@@ -109,7 +110,7 @@ public Void visitClassDef(JCClassDecl tree, Void p) {
     bindingGraphFactory.create(type).ifPresent(this::addNodesForGraph);
 
     if (getModuleAnnotation(type).isPresent()) {
-      subcomponentDeclarationFactory.forModule(type).forEach(this::addBindingDeclarationEdge);
+      subcomponentDeclarationFactory.forModule(type).forEach(this::addSubcomponentDeclarationNode);
     }
 
     Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
@@ -212,7 +213,7 @@ private Span bindingElementSpan(Element bindingElement) {
         bindingElement.getKind().equals(ElementKind.CONSTRUCTOR)
             ? bindingElement.getEnclosingElement().getSimpleName()
             : bindingElement.getSimpleName();
-    return span(name, trees.getTree(bindingElement));
+    return span(name, getTree(bindingElement));
   }
 
   /**
@@ -230,7 +231,16 @@ private void addDependencyEdge(DependencyRequest dependencyRequest) {
 
   private Span dependencyRequestSpan(DependencyRequest dependency) {
     Element requestElement = dependency.requestElement().get();
-    return span(requestElement.getSimpleName(), trees.getTree(requestElement));
+    return span(requestElement.getSimpleName(), getTree(requestElement));
+  }
+
+  private void addSubcomponentDeclarationNode(SubcomponentDeclaration declaration) {
+    TypeElement module = declaration.contributingModule().get();
+    // getTree(bindingElement) doesn't seem to work as expected, and instead searches for the
+    // subcomponents() attribute's Tree in dagger/Module.java
+    JCTree tree = trees.getTree(module, declaration.moduleAnnotation());
+    EntrySet bindingAnchor = anchor(span(declaration.bindingElement().get().getSimpleName(), tree));
+    entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(declaration.key()));
   }
 
   /**
@@ -329,6 +339,22 @@ private Element getElement(Tree tree) {
     return trees.getElement(trees.getPath(compilationUnit, tree));
   }
 
+  /**
+   * A wrapper for {@link JavacTrees#getTree(Element)} that checks for {@code null} and reports
+   * debug information in the exception.
+   *
+   * <p>This should only be necessary in cases where there's a bug in the plugin, but it makes
+   * fixing the bug significantly easier.
+   */
+  private JCTree getTree(Element element) {
+    return checkNotNull(
+        trees.getTree(element),
+        "No Tree available for %s. This likely means that the element is being accessed from a "
+            + "different compilation. The current file being scanned is: %s.",
+        element,
+        fileVName.getPath());
+  }
+
   private void emitDaggerJoinsEdge(EntrySet source, EntrySet target) {
     new EntrySet.Builder(source.getVName(), "/dagger/joins", target.getVName())
         .build()
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index af8381590..e76400ae9 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -108,11 +108,6 @@ public CodeBlock creationExpression() {
             dependency(), generatedComponentModel.name()));
   }
 
-  @Override
-  public boolean isSimpleFactory() {
-    return true;
-  }
-
   private ClassName factoryClassName() {
     String factoryName =
         ClassName.get(dependency().typeElement()).toString().replace('.', '_')
diff --git a/java/dagger/internal/codegen/DependencyRequestFactory.java b/java/dagger/internal/codegen/DependencyRequestFactory.java
index b3de27440..95ac61824 100644
--- a/java/dagger/internal/codegen/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/DependencyRequestFactory.java
@@ -31,7 +31,6 @@
 import static dagger.model.RequestKind.PRODUCER;
 import static dagger.model.RequestKind.PROVIDER;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Lazy;
@@ -187,11 +186,9 @@ DependencyRequest forComponentMembersInjectionMethod(
   }
 
   DependencyRequest forProductionImplementationExecutor() {
-    Key key = keyFactory.forProductionImplementationExecutor();
     return DependencyRequest.builder()
         .kind(PROVIDER)
-        .key(key)
-        .requestElement(MoreTypes.asElement(key.type()))
+        .key(keyFactory.forProductionImplementationExecutor())
         .build();
   }
 
diff --git a/java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
similarity index 77%
rename from java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java
rename to java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
index 02a872231..e8a2a09d7 100644
--- a/java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java
+++ b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
@@ -29,14 +28,17 @@
 import dagger.internal.MemoizedSentinel;
 import dagger.model.RequestKind;
 
-/** Defines a scoping method body and return type for a given instance {@link BindingExpression}. */
-final class ScopedInstanceMethodImplementation extends BindingMethodImplementation {
+/**
+ * Defines a method body and return type for double checked locking of the given {@link
+ * BindingExpression}.
+ */
+final class DoubleCheckedMethodImplementation extends BindingMethodImplementation {
 
   private final GeneratedComponentModel generatedComponentModel;
   private final ContributionBinding binding;
   private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
 
-  ScopedInstanceMethodImplementation(
+  DoubleCheckedMethodImplementation(
       ResolvedBindings resolvedBindings,
       RequestKind requestKind,
       BindingExpression bindingExpression,
@@ -45,24 +47,10 @@
     super(resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
     this.generatedComponentModel = generatedComponentModel;
     this.binding = resolvedBindings.contributionBinding();
-    checkArgument(binding.scope().isPresent(), "expected binding to be scoped: %s", binding);
   }
 
   @Override
   CodeBlock body() {
-    return binding.scope().get().isReusable() ? singleCheck() : doubleCheck();
-  }
-
-  private CodeBlock singleCheck() {
-    return CodeBlock.builder()
-        .beginControlFlow("if ($N instanceof $T)", fieldName.get(), MemoizedSentinel.class)
-        .addStatement("$N = $L", fieldName.get(), simpleBindingExpression())
-        .endControlFlow()
-        .addStatement("return ($T) $N", returnType(), fieldName.get())
-        .build();
-  }
-
-  private CodeBlock doubleCheck() {
     String fieldExpression =
         fieldName.get().equals("local") ? "this." + fieldName.get() : fieldName.get();
     return CodeBlock.builder()
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 1dc019e73..8a2d206b9 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -84,7 +84,7 @@
   static final String INJECT_ON_PRIVATE_CONSTRUCTOR =
       "Dagger does not support injection into private constructors";
   static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
-      "@Inject constructors are invalid on inner classes";
+      "@Inject constructors are invalid on inner classes. Did you mean to make the class static?";
   static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
       "@Inject is nonsense on the constructor of an abstract class";
   static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 32ad46ef3..2ad4bd98f 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,12 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
@@ -33,6 +35,7 @@
 import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Optional;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
@@ -44,6 +47,7 @@
   // TODO(user, dpb): Move component requirements and reference managers to top? The order should
   // be component requirements, referencemanagers, framework fields, private method fields, ... etc
   static enum FieldSpecKind {
+
     /**
      * A field for the lock and cached value for {@linkplain PrivateMethodBindingExpression
      * private-method scoped bindings}.
@@ -116,6 +120,7 @@
       MultimapBuilder.enumKeys(MethodSpecKind.class).arrayListValues().build();
   private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
+  private Optional<Supplier<TypeSpec>> switchingProviderSupplier = Optional.empty();
 
   private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
     this.name = name;
@@ -177,6 +182,12 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
+  /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
+  void addSwitchingProvider(Supplier<TypeSpec> typeSpecSupplier) {
+    checkState(!switchingProviderSupplier.isPresent());
+    switchingProviderSupplier = Optional.of(typeSpecSupplier);
+  }
+
   /** Adds the given code block to the initialize methods of the component. */
   void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
@@ -207,6 +218,7 @@ void claimMethodName(Name name) {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
     methodSpecsMap.asMap().values().forEach(component::addMethods);
     typeSpecsMap.asMap().values().forEach(component::addTypes);
+    switchingProviderSupplier.map(Supplier::get).ifPresent(component::addType);
     return component;
   }
 }
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 25189bd1b..4b6d1aad1 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -103,6 +103,7 @@ private static BindingGraphFactory createBindingGraphFactory(
             .scopeCycleValidationType(ValidationType.NONE)
             .warnIfInjectionFactoryNotGeneratedUpstream(false)
             .experimentalAndroidMode(false)
+            .aheadOfTimeComponents(false)
             .build();
 
     BindingFactory bindingFactory =
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
new file mode 100644
index 000000000..6fd39f6a5
--- /dev/null
+++ b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static dagger.model.RequestKind.INSTANCE;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.VOLATILE;
+
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.MemoizedSentinel;
+import dagger.model.RequestKind;
+import java.util.Optional;
+
+/**
+ * Defines a method body and return type for single checked caching of the given {@link
+ * BindingExpression}.
+ */
+final class SingleCheckedMethodImplementation extends BindingMethodImplementation {
+
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ResolvedBindings resolvedBindings;
+  private final ContributionBinding binding;
+  private final RequestKind requestKind;
+  private final Supplier<FieldSpec> field = Suppliers.memoize(this::createField);
+
+  SingleCheckedMethodImplementation(
+      ResolvedBindings resolvedBindings,
+      RequestKind requestKind,
+      BindingExpression bindingExpression,
+      DaggerTypes types,
+      GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
+    this.generatedComponentModel = generatedComponentModel;
+    this.resolvedBindings = resolvedBindings;
+    this.binding = resolvedBindings.contributionBinding();
+    this.requestKind = requestKind;
+  }
+
+  @Override
+  CodeBlock body() {
+    CodeBlock.Builder builder = CodeBlock.builder();
+    if (isNullable()) {
+      builder.beginControlFlow("if ($N instanceof $T)", field.get(), MemoizedSentinel.class);
+    } else {
+      builder.beginControlFlow("if ($N == null)", field.get());
+    }
+
+    builder
+        .addStatement("$N = $L", field.get(), simpleBindingExpression())
+        .endControlFlow();
+
+    if (isNullable()) {
+      builder.addStatement("return ($T) $N", returnType(), field.get());
+    } else {
+      builder.addStatement("return $N", field.get());
+    }
+    return builder.build();
+  }
+
+  private FieldSpec createField() {
+    String name =
+        generatedComponentModel.getUniqueFieldName(
+            requestKind.equals(INSTANCE)
+                ? BindingVariableNamer.name(binding)
+                : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
+
+    FieldSpec field =
+        // Nullable instances use `MemoizedSentinel` instead of `null` as the initialization value.
+        isNullable()
+            ? FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
+                .initializer("new $T()", MemoizedSentinel.class)
+                .build()
+            : FieldSpec.builder(TypeName.get(returnType()), name, PRIVATE, VOLATILE).build();
+
+    generatedComponentModel.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
+    return field;
+  }
+
+  private boolean isNullable() {
+    return requestKind.equals(INSTANCE) && binding.isNullable();
+  }
+}
diff --git a/java/dagger/internal/codegen/SpiDiagnosticReporter.java b/java/dagger/internal/codegen/SpiDiagnosticReporter.java
index 32133da74..6d4aaae50 100644
--- a/java/dagger/internal/codegen/SpiDiagnosticReporter.java
+++ b/java/dagger/internal/codegen/SpiDiagnosticReporter.java
@@ -17,13 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerGraphs.shortestPath;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
-import com.google.common.graph.SuccessorsFunction;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
@@ -31,12 +30,8 @@
 import dagger.model.BindingGraph.Node;
 import dagger.model.DependencyRequest;
 import dagger.spi.ValidationItem;
-import java.util.ArrayDeque;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Optional;
-import java.util.Queue;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
@@ -202,65 +197,4 @@ private StringBuilder messageBuilder() {
   private static boolean isInstance(Optional<?> optional, Class<?> clazz) {
     return optional.filter(clazz::isInstance).isPresent();
   }
-
-  /**
-   * Returns a shortest path from {@code nodeU} to {@code nodeV} in {@code graph} as a list of the
-   * nodes visited in sequence, including both {@code nodeU} and {@code nodeV}. (Note that there may
-   * be many possible shortest paths.)
-   *
-   * <p>If {@code nodeV} is not {@link
-   * com.google.common.graph.Graphs#reachableNodes(com.google.common.graph.Graph, Object) reachable}
-   * from {@code nodeU}, the list returned is empty.
-   *
-   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not present in {@code
-   *     graph}
-   */
-  // This is copied from common.graph since it is not yet open-sourced.
-  // TODO(ronshapiro): When the API is released and becomes stable, remove this copy.
-  private static <N> ImmutableList<N> shortestPath(SuccessorsFunction<N> graph, N nodeU, N nodeV) {
-    if (nodeU.equals(nodeV)) {
-      return ImmutableList.of(nodeU);
-    }
-    Set<N> successors = ImmutableSet.copyOf(graph.successors(nodeU));
-    if (successors.contains(nodeV)) {
-      return ImmutableList.of(nodeU, nodeV);
-    }
-
-    Map<N, N> visitedNodeToPathPredecessor = new HashMap<>(); // encodes shortest path tree
-    Queue<N> currentNodes = new ArrayDeque<N>();
-    Queue<N> nextNodes = new ArrayDeque<N>();
-    for (N node : successors) {
-      visitedNodeToPathPredecessor.put(node, nodeU);
-    }
-    currentNodes.addAll(successors);
-
-    // Perform a breadth-first traversal starting with the successors of nodeU.
-    while (!currentNodes.isEmpty()) {
-      while (!currentNodes.isEmpty()) {
-        N currentNode = currentNodes.remove();
-        for (N nextNode : graph.successors(currentNode)) {
-          if (visitedNodeToPathPredecessor.containsKey(nextNode)) {
-            continue; // we already have a shortest path to nextNode
-          }
-          visitedNodeToPathPredecessor.put(nextNode, currentNode);
-          if (nextNode.equals(nodeV)) {
-            ImmutableList.Builder<N> builder = ImmutableList.builder();
-            N node = nodeV;
-            builder.add(node);
-            while (!node.equals(nodeU)) {
-              node = visitedNodeToPathPredecessor.get(node);
-              builder.add(node);
-            }
-            return builder.build().reverse();
-          }
-          nextNodes.add(nextNode);
-        }
-      }
-      Queue<N> emptyQueue = currentNodes;
-      currentNodes = nextNodes;
-      nextNodes = emptyQueue; // reusing empty queue faster than allocating new one
-    }
-
-    return ImmutableList.of();
-  }
 }
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
new file mode 100644
index 000000000..f2a6a0049
--- /dev/null
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
+import static dagger.internal.codegen.CodeBlocks.toConcatenatedCodeBlock;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.model.RequestKind.INSTANCE;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import dagger.model.Key;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeMap;
+import javax.inject.Provider;
+
+/**
+ * Keeps track of all provider expression requests for a component.
+ *
+ * <p>The provider expression request will be satisfied by a single generated {@code Provider} inner
+ * class that can provide instances for all types by switching on an id.
+ */
+final class SwitchingProviders {
+  private static final TypeVariableName T = TypeVariableName.get("T");
+
+  // Keep the switch cases ordered by switch id.
+  private final Map<Integer, CodeBlock> switchCases = new TreeMap<>();
+  private final Map<Key, Integer> switchIds = new HashMap<>();
+
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final BindingGraph graph;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ClassName owningComponent;
+  private final ClassName switchingProviderType;
+  private final DaggerTypes types;
+
+  SwitchingProviders(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      BindingGraph graph,
+      DaggerTypes types) {
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.graph = checkNotNull(graph);
+    this.types = checkNotNull(types);
+    this.owningComponent = checkNotNull(generatedComponentModel).name();
+    this.switchingProviderType = owningComponent.nestedClass("SwitchingProvider");
+  }
+
+  /**
+   * Returns the binding expression for a binding that satisfies its {link Provider} requests with
+   * the generated {@code SwitchingProvider}.
+   */
+  BindingExpression newBindingExpression(Key key) {
+    return new BindingExpression() {
+      @Override
+      Expression getDependencyExpression(ClassName requestingClass) {
+        if (!switchIds.containsKey(key)) {
+          // Register the SwitchingProvider creation method the first time it's requested.
+          if (switchIds.isEmpty()) {
+            generatedComponentModel.addSwitchingProvider(
+                SwitchingProviders.this::createSwitchingProviderType);
+          }
+
+          int switchId = switchIds.size();
+          switchIds.put(key, switchId);
+          switchCases.put(switchId, createSwitchCaseCodeBlock(key));
+        }
+
+        return Expression.create(
+            types.wrapType(key.type(), Provider.class),
+            CodeBlock.of("new $T<>($L)", switchingProviderType, switchIds.get(key)));
+      }
+    };
+  }
+
+  private CodeBlock createSwitchCaseCodeBlock(Key key) {
+    Expression instanceExpression =
+        componentBindingExpressions.getDependencyExpression(key, INSTANCE, owningComponent);
+
+    CodeBlock instanceCodeBlock = instanceExpression.codeBlock();
+
+    // Primitives cannot be cast directly to the method's parameterized type, T. We have to first
+    // cast them to their boxed type.
+    if (binding(key).contributedPrimitiveType().isPresent()) {
+      TypeName boxedType = TypeName.get(binding(key).contributedType()).box();
+      instanceCodeBlock = CodeBlock.of("($T) $L", boxedType, instanceCodeBlock);
+    }
+
+    return CodeBlock.builder()
+        // TODO(user): Is there something else more useful than the key?
+        .add("case $L: // $L \n", switchIds.get(key), key)
+        .addStatement("return ($T) $L", T, instanceCodeBlock)
+        .build();
+  }
+
+  private TypeSpec createSwitchingProviderType() {
+    return classBuilder(switchingProviderType)
+        .addModifiers(PRIVATE, FINAL)
+        .addTypeVariable(T)
+        .addSuperinterface(providerOf(T))
+        .addField(TypeName.INT, "id", PRIVATE, FINAL)
+        .addMethod(
+            constructorBuilder()
+                .addParameter(TypeName.INT, "id")
+                .addStatement("this.id = id")
+                .build())
+        .addMethod(
+            methodBuilder("get")
+                .addModifiers(PUBLIC)
+                .addAnnotation(suppressWarnings(UNCHECKED))
+                .addAnnotation(Override.class)
+                .returns(T)
+                .beginControlFlow("switch (id)")
+                .addCode(switchCases.values().stream().collect(toConcatenatedCodeBlock()))
+                .addStatement("default: throw new $T(id)", AssertionError.class)
+                .endControlFlow()
+                .build())
+        .build();
+  }
+
+  private ContributionBinding binding(Key key) {
+    return graph.contributionBindings().get(key).contributionBinding();
+  }
+}
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
index 75bfad460..37e5e90fc 100644
--- a/javatests/dagger/functional/cycle/LongCycleTest.java
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -44,6 +44,9 @@ public void longCycle() {
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
     assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
+    assume()
+        .that(System.getProperty("dagger.mode"))
+        .isNotEqualTo("ExperimentalAndroidModeAndAheadOfTimeComponents");
     DaggerLongCycle_LongCycleComponent.class
         .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
diff --git a/javatests/dagger/functional/nullables/NullComponent.java b/javatests/dagger/functional/nullables/NullComponent.java
index 8d8d757b3..39f0d349d 100644
--- a/javatests/dagger/functional/nullables/NullComponent.java
+++ b/javatests/dagger/functional/nullables/NullComponent.java
@@ -26,4 +26,5 @@
   Provider<String> stringProvider();
   Number number();
   Provider<Number> numberProvider();
+  @Nullable Integer integer();
 }
diff --git a/javatests/dagger/functional/nullables/NullModule.java b/javatests/dagger/functional/nullables/NullModule.java
index 00f35fd43..02191657d 100644
--- a/javatests/dagger/functional/nullables/NullModule.java
+++ b/javatests/dagger/functional/nullables/NullModule.java
@@ -18,10 +18,12 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.Reusable;
 
 @Module
 class NullModule {
   Number numberValue = null;
+  Integer integerCallCount = 0;
 
   @Nullable
   @Provides
@@ -33,4 +35,12 @@ String provideNullableString() {
   Number provideNumber() {
     return numberValue;
   }
+
+  @Nullable
+  @Provides
+  @Reusable
+  Integer provideNullReusableInteger() {
+    integerCallCount++;
+    return null;
+  }
 }
diff --git a/javatests/dagger/functional/nullables/NullabilityTest.java b/javatests/dagger/functional/nullables/NullabilityTest.java
index e232d8534..8db577bb8 100644
--- a/javatests/dagger/functional/nullables/NullabilityTest.java
+++ b/javatests/dagger/functional/nullables/NullabilityTest.java
@@ -50,9 +50,21 @@
     validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
         nullFoo.fieldInjectedNumberProvider);
   }
-  
+
+  @Test public void testNullability_reusuable() {
+    NullModule module = new NullModule();
+    NullComponent component = DaggerNullComponent.builder().nullModule(module).build();
+
+    // Test that the @Nullable @Reusuable binding is cached properly even when the value is null.
+    assertThat(module.integerCallCount).isEqualTo(0);
+    assertThat(component.integer()).isNull();
+    assertThat(module.integerCallCount).isEqualTo(1);
+    assertThat(component.integer()).isNull();
+    assertThat(module.integerCallCount).isEqualTo(1);
+  }
+
   @Test public void testNullability_components() {
-    NullComponent nullComponent = new NullComponent() {      
+    NullComponent nullComponent = new NullComponent() {
       @Override public Provider<String> stringProvider() {
         return new Provider<String>() {
           @Override public String get() {
@@ -60,11 +72,11 @@
           }
         };
       }
-      
+
       @Override public String string() {
         return null;
       }
-      
+
       @Override public Provider<Number> numberProvider() {
         return new Provider<Number>() {
           @Override public Number get() {
@@ -72,19 +84,23 @@
           }
         };
       }
-      
+
       @Override public Number number() {
         return null;
       }
-      
+
       @Override public NullFoo nullFoo() {
         return null;
       }
+
+      @Override public Integer integer() {
+        return null;
+      }
     };
     NullComponentWithDependency component =
         DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();
     validate(false, component.string(), component.stringProvider(), component.numberProvider());
-    
+
     // Also validate that the component's number() method fails
     try {
       component.number();
@@ -103,7 +119,7 @@ private void validate(boolean fromProvides,
     try {
       numberProvider.get();
       fail();
-    } catch(NullPointerException npe) {
+    } catch (NullPointerException npe) {
       assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
           + (fromProvides ? "@Provides" : "component") + " method");
     }
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentTest.java b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
index 84c11f896..73562b8d4 100644
--- a/javatests/dagger/functional/subcomponent/SubcomponentTest.java
+++ b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
@@ -87,6 +87,9 @@ public void multibindingContributions() {
   @Test
   public void unscopedProviders() {
     assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
+    assume()
+        .that(System.getProperty("dagger.mode"))
+        .isNotEqualTo("ExperimentalAndroidModeAndAheadOfTimeComponents");
     assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent.getUnscopedTypeProvider());
     assertThat(parentGetters.getUnscopedTypeProvider())
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index fdb8b44c8..0d858ed01 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -289,7 +289,11 @@ public void componentWithInvalidModule() {
                 "import javax.inject.Provider;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "public final class DaggerSimpleComponent implements SimpleComponent {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private volatile Provider<SomeInjectableType> someInjectableTypeProvider;")
+            .addLines(
                 "  private DaggerSimpleComponent(Builder builder) {}",
                 "",
                 "  public static Builder builder() {",
@@ -306,13 +310,28 @@ public void componentWithInvalidModule() {
                 "  }",
                 "",
                 "  @Override",
-                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {")
+            .addLinesIn(
+                DEFAULT_MODE, //
+                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    return DoubleCheck.lazy(someInjectableTypeProvider());")
+            .addLines(
                 "  }",
                 "",
                 "  @Override",
-                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-                "    return SomeInjectableType_Factory.create();",
+                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {")
+            .addLinesIn(
+                DEFAULT_MODE, //
+                "    return SomeInjectableType_Factory.create();")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE, //
+                "    if (someInjectableTypeProvider == null) {",
+                "      someInjectableTypeProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return someInjectableTypeProvider;")
+            .addLines(
                 "  }",
                 "",
                 "  public static final class Builder {",
@@ -321,8 +340,25 @@ public void componentWithInvalidModule() {
                 "    public SimpleComponent build() {",
                 "      return new DaggerSimpleComponent(this);",
                 "    }",
-                "  }",
-                "}")
+                "  }")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) new SomeInjectableType();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }")
             .build();
 
     Compilation compilation =
@@ -371,7 +407,8 @@ public void componentWithInvalidModule() {
                 "public final class DaggerSimpleComponent implements SimpleComponent {")
             .addLinesIn(
                 EXPERIMENTAL_ANDROID_MODE,
-                "  private volatile Object someInjectableType = new MemoizedSentinel();")
+                "  private volatile Object someInjectableType = new MemoizedSentinel();",
+                "  private volatile Provider<SomeInjectableType> someInjectableTypeProvider;")
             .addLinesIn(
                 DEFAULT_MODE,
                 "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
@@ -416,20 +453,32 @@ public void componentWithInvalidModule() {
                 "",
                 "  @Override",
                 "  public Provider<SomeInjectableType> someInjectableTypeProvider() {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE, //
+                "    if (someInjectableTypeProvider == null) {",
+                "      someInjectableTypeProvider = new SwitchingProvider<>(0);",
+                "    }")
+            .addLines(
+                "    return someInjectableTypeProvider;",
+                "  }")
             .addLinesIn(
                 EXPERIMENTAL_ANDROID_MODE,
-                "    return new Provider<SomeInjectableType>() {",
-                "      @Override",
-                "      public SomeInjectableType get() {",
-                "        return someInjectableType();",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) someInjectableType();",
+                "        default: throw new AssertionError(id);",
                 "      }",
-                "    };")
-            .addLinesIn(
-                DEFAULT_MODE, //
-                "    return someInjectableTypeProvider;")
-            .addLines(
-                "  }", //
-                "}")
+                "    }",
+                "  }")
             .build();
     Compilation compilation =
         daggerCompiler()
@@ -1238,55 +1287,99 @@ public void testDefaultPackage() {
         "  B b();",
         "}");
     JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerBComponent",
-            "package test;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerBComponent implements BComponent {",
-            "  private test_AComponent_a aProvider;",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new test_AComponent_a(builder.aComponent);",
-            "  }",
-            "",
-            "  @Override",
-            "  public B b() {",
-            "    return new B(aProvider);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private AComponent aComponent;",
-            "",
-            "    public BComponent build() {",
-            "      if (aComponent == null) {",
-            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
-            "      return new DaggerBComponent(this);",
-            "    }",
-            "",
-            "    public Builder aComponent(AComponent aComponent) {",
-            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private static class test_AComponent_a implements Provider<A> {",
-            "    private final AComponent aComponent;",
-            "    ",
-            "    test_AComponent_a(AComponent aComponent) {",
-            "        this.aComponent = aComponent;",
-            "    }",
-            "    ",
-            "    @Override()",
-            "    public A get() {",
-            "      return Preconditions.checkNotNull(",
-            "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
-            "    }",
-            "  }",
-            "}");
+        compilerMode
+            .javaFileBuilder("test.DaggerBComponent")
+            .addLines(
+                "package test;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "  private test_AComponent_a aProvider;")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private volatile Provider<A> aProvider;",
+                "  private AComponent aComponent;",
+                "",
+                "  private Provider<A> getAProvider() {",
+                "    if (aProvider == null) {",
+                "      aProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return aProvider;",
+                "  }")
+            .addLines(
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    this.aComponent = builder.aComponent;")
+            .addLines(
+                "  }",
+                "",
+                "  @Override",
+                "  public B b() {")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "    return new B(aProvider);")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    return new B(getAProvider());")
+            .addLines(
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+                "            + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "  private static class test_AComponent_a implements Provider<A> {",
+                "    private final AComponent aComponent;",
+                "    ",
+                "    test_AComponent_a(AComponent aComponent) {",
+                "        this.aComponent = aComponent;",
+                "    }",
+                "    ",
+                "    @Override()",
+                "    public A get() {",
+                "      return Preconditions.checkNotNull(",
+                "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "}")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T)",
+                "              Preconditions.checkNotNull(",
+                "                  aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }")
+            .build();
     Compilation compilation =
         daggerCompiler()
             .withOptions(compilerMode.javacopts())
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index cdd0cfbdf..921365fda 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -21,7 +21,6 @@
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.CompilationSubject;
@@ -179,6 +178,9 @@ public void toDoubleCheck() {
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object regularScoped = new MemoizedSentinel();",
+                    "  private volatile ReusableScoped reusableScoped;",
+                    "",
                     "  private RegularScoped getRegularScoped() {",
                     "    Object local = regularScoped;",
                     "    if (local instanceof MemoizedSentinel) {",
@@ -193,10 +195,10 @@ public void toDoubleCheck() {
                     "  }",
                     "",
                     "  private ReusableScoped getReusableScoped() {",
-                    "    if (reusableScoped instanceof MemoizedSentinel) {",
+                    "    if (reusableScoped == null) {",
                     "      reusableScoped = new ReusableScoped();",
                     "    }",
-                    "    return (ReusableScoped) reusableScoped;",
+                    "    return reusableScoped;",
                     "  }",
                     "")
                 .addLines(
@@ -271,6 +273,9 @@ public void toSingleCheck() {
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object regularScoped = new MemoizedSentinel();",
+                    "  private volatile ReusableScoped reusableScoped;",
+                    "",
                     "  private RegularScoped getRegularScoped() {",
                     "    Object local = regularScoped;",
                     "    if (local instanceof MemoizedSentinel) {",
@@ -285,10 +290,10 @@ public void toSingleCheck() {
                     "  }",
                     "",
                     "  private ReusableScoped getReusableScoped() {",
-                    "    if (reusableScoped instanceof MemoizedSentinel) {",
+                    "    if (reusableScoped == null) {",
                     "      reusableScoped = new ReusableScoped();",
                     "    }",
-                    "    return (ReusableScoped) reusableScoped;",
+                    "    return reusableScoped;",
                     "  }",
                     "")
                 .addLines(
@@ -360,6 +365,10 @@ public void toReleasableCheck() {
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object regularScoped = new MemoizedSentinel();",
+                    "  private volatile ReusableScoped reusableScoped;",
+                    "  private volatile Provider<Unscoped> unscopedProvider;",
+                    "",
                     "  private RegularScoped getRegularScoped() {",
                     "    Object local = regularScoped;",
                     "    if (local instanceof MemoizedSentinel) {",
@@ -374,10 +383,17 @@ public void toReleasableCheck() {
                     "  }",
                     "",
                     "  private ReusableScoped getReusableScoped() {",
-                    "    if (reusableScoped instanceof MemoizedSentinel) {",
+                    "    if (reusableScoped == null) {",
                     "      reusableScoped = new ReusableScoped();",
                     "    }",
-                    "    return (ReusableScoped) reusableScoped;",
+                    "    return reusableScoped;",
+                    "  }",
+                    "",
+                    "  private Provider<Unscoped> getUnscopedProvider() {",
+                    "    if (unscopedProvider == null) {",
+                    "      unscopedProvider = new SwitchingProvider<>(0);",
+                    "    }",
+                    "    return unscopedProvider;",
                     "  }",
                     "")
                 .addLines(
@@ -392,10 +408,18 @@ public void toReleasableCheck() {
                 .addLines(
                     "    this.releasableScopedProvider = ",
                     "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);",
+                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
+                .addLinesIn(
+                    DEFAULT_MODE,
                     "    this.unscopedProvider =",
                     "        ReferenceReleasingProvider.create(",
-                    "            (Provider) Unscoped_Factory.create(), customScopeReferences);",
+                    "            (Provider) Unscoped_Factory.create(), customScopeReferences);")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "    this.unscopedProvider2 =",
+                    "        ReferenceReleasingProvider.create(",
+                    "            (Provider) getUnscopedProvider(), customScopeReferences);")
+                .addLines(
                     "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
                     "        new Provider<ReleasableReferenceManager>() {",
                     "          @Override",
@@ -403,8 +427,20 @@ public void toReleasableCheck() {
                     "            return customScopeReferences;",
                     "          }",
                     "        };",
-                    "  }",
-                    "}")
+                    "  }")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private final class SwitchingProvider<T> implements Provider<T> {",
+                    "    @SuppressWarnings(\"unchecked\")",
+                    "    @Override",
+                    "    public T get() {",
+                    "      switch (id) {",
+                    "        case 0: return (T) new Unscoped();",
+                    "        default: throw new AssertionError(id);",
+                    "      }",
+                    "    }",
+                    "  }")
+                .addLines("}")
                 .build());
   }
 
@@ -445,6 +481,9 @@ public void toUnscoped() {
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object regularScoped = new MemoizedSentinel();",
+                    "  private volatile ReusableScoped reusableScoped;",
+                    "",
                     "  private RegularScoped getRegularScoped() {",
                     "    Object local = regularScoped;",
                     "    if (local instanceof MemoizedSentinel) {",
@@ -459,10 +498,10 @@ public void toUnscoped() {
                     "  }",
                     "",
                     "  private ReusableScoped getReusableScoped() {",
-                    "    if (reusableScoped instanceof MemoizedSentinel) {",
+                    "    if (reusableScoped == null) {",
                     "      reusableScoped = new ReusableScoped();",
                     "    }",
-                    "    return (ReusableScoped) reusableScoped;",
+                    "    return reusableScoped;",
                     "  }",
                     "")
                 .addLines(
@@ -537,36 +576,56 @@ public void castNeeded_rawTypes_Provider_get() {
             "  other.Supertype supertype();",
             "}");
     Compilation compilation =
-        daggerCompiler().compile(accessibleSupertype, inaccessibleSubtype, module, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(accessibleSupertype, inaccessibleSubtype, module, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(
-            JavaFileObjects.forSourceLines(
-                "test.DaggerTestComponent",
-                "package test;",
-                "",
-                "import dagger.internal.DoubleCheck;",
-                IMPORT_GENERATED_ANNOTATION,
-                "import javax.inject.Provider;",
-                "import other.Subtype_Factory;",
-                "import other.Supertype;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {",
-                "  @SuppressWarnings(\"rawtypes\")",
-                "  private Provider subtypeProvider;",
-                "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.subtypeProvider = DoubleCheck.provider(Subtype_Factory.create());",
-                "  }",
-                "",
-                "  @Override",
-                "  public Supertype supertype() {",
-                "    return (Supertype) subtypeProvider.get();",
-                "  }",
-                "}"));
+            compilerMode
+                .javaFileBuilder("test.DaggerTestComponent")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerTestComponent implements TestComponent {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  @SuppressWarnings(\"rawtypes\")",
+                    "  private Provider subtypeProvider;",
+                    "",
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
+                    "    this.subtypeProvider = DoubleCheck.provider(Subtype_Factory.create());",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Supertype supertype() {",
+                    "    return (Supertype) subtypeProvider.get();",
+                    "  }")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object subtype = new MemoizedSentinel();",
+                    "",
+                    "  private Object getSubtype() {",
+                    "    Object local = subtype;",
+                    "    if (local instanceof MemoizedSentinel) {",
+                    "      synchronized (local) {",
+                    "        if (local == subtype) {",
+                    "          subtype = Subtype_Factory.newSubtype();",
+                    "        }",
+                    "        local = subtype;",
+                    "      }",
+                    "    }",
+                    "    return (Object) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Supertype supertype() {",
+                    "    return (Supertype) getSubtype();",
+                    "  }")
+                .build());
   }
 
   @Test
@@ -625,30 +684,53 @@ public void noCast_rawTypes_Provider_get_toInaccessibleType() {
             "  other.UsesSupertype usesSupertype();",
             "}");
     Compilation compilation =
-        daggerCompiler().compile(supertype, subtype, usesSupertype, module, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(supertype, subtype, usesSupertype, module, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(
-            JavaFileObjects.forSourceLines(
-                "test.DaggerTestComponent",
-                "package test;",
-                "",
-                "import other.Subtype_Factory;",
-                "import other.UsesSupertype;",
-                "import other.UsesSupertype_Factory;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {",
-                "  @SuppressWarnings(\"rawtypes\")",
-                "  private Provider subtypeProvider;",
-                "",
-                "  @Override",
-                "  public UsesSupertype usesSupertype() {",
-                //   can't cast the provider.get() to a type that's not accessible
-                "    return UsesSupertype_Factory.newUsesSupertype(subtypeProvider.get());",
-                "  }",
-                "}"));
+            compilerMode
+                .javaFileBuilder("test.DaggerTestComponent")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerTestComponent implements TestComponent {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  @SuppressWarnings(\"rawtypes\")",
+                    "  private Provider subtypeProvider;",
+                    "",
+                    "  @Override",
+                    "  public UsesSupertype usesSupertype() {",
+                    //   can't cast the provider.get() to a type that's not accessible
+                    "    return UsesSupertype_Factory.newUsesSupertype(subtypeProvider.get());",
+                    "  }",
+                    "}")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object subtype = new MemoizedSentinel();",
+                    "",
+                    "  private Object getSubtype() {",
+                    "    Object local = subtype;",
+                    "    if (local instanceof MemoizedSentinel) {",
+                    "      synchronized (local) {",
+                    "        if (local == subtype) {",
+                    "          subtype = Subtype_Factory.newSubtype();",
+                    "        }",
+                    "        local = subtype;",
+                    "      }",
+                    "    }",
+                    "    return (Object) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public UsesSupertype usesSupertype() {",
+                    "    return UsesSupertype_Factory.newUsesSupertype(getSubtype());",
+                    "  }")
+                .build());
   }
 
   @Test
@@ -691,28 +773,70 @@ public void castedToRawType() {
             "  @Named(\"named\") Provider<String> namedString();",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(module, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(
-            JavaFileObjects.forSourceLines(
-                "test.DaggerTestComponent",
-                "",
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {",
-                "  @Override",
-                "  public Provider<CharSequence> charSequence() {",
-                "    return (Provider) TestModule_ProvideStringFactory.create();",
-                "  }",
-                "",
-                "  @Override",
-                "  public Provider<String> namedString() {",
-                "    return TestModule_ProvideStringFactory.create();",
-                "  }",
-                "}"));
+            compilerMode
+                .javaFileBuilder("test.DaggerTestComponent")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerTestComponent implements TestComponent {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) TestModule_ProvideStringFactory.create();",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<String> namedString() {",
+                    "    return TestModule_ProvideStringFactory.create();",
+                    "  }",
+                    "}")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Provider<CharSequence> charSequenceProvider;",
+                    "  private volatile Provider<String> namedStringProvider;",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    if (charSequenceProvider == null) {",
+                    "      charSequenceProvider = new SwitchingProvider<>(0);",
+                    "    }",
+                    "    return charSequenceProvider;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<String> namedString() {",
+                    "    if (namedStringProvider == null) {",
+                    "      namedStringProvider = new SwitchingProvider<>(1);",
+                    "    }",
+                    "    return namedStringProvider;",
+                    "  }",
+                    "",
+                    "  private final class SwitchingProvider<T> implements Provider<T> {",
+                    "    @SuppressWarnings(\"unchecked\")",
+                    "    @Override",
+                    "    public T get() {",
+                    "      switch (id) {",
+                    // TODO(cl/189031410): Dedupe identical cases in SwitchingProviders.
+                    "        case 0:",
+                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
+                    "        case 1:",
+                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
+                    "        default:",
+                    "            throw new AssertionError(id);",
+                    "      }",
+                    "    }",
+                    "  }")
+                .build());
   }
 
   @Test
@@ -752,27 +876,68 @@ public void doubleBinds() {
             "  Provider<Object> object();",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(module, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
         .containsElementsIn(
-            JavaFileObjects.forSourceLines(
-                "test.DaggerTestComponent",
-                "",
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {",
-                "  @Override",
-                "  public Provider<CharSequence> charSequence() {",
-                "    return (Provider) TestModule_ProvideStringFactory.create();",
-                "  }",
-                "  @Override",
-                "  public Provider<Object> object() {",
-                "    return (Provider) TestModule_ProvideStringFactory.create();",
-                "  }",
-                "}"));
+            compilerMode
+                .javaFileBuilder("test.DaggerTestComponent")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerTestComponent implements TestComponent {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    return (Provider) TestModule_ProvideStringFactory.create();",
+                    "  }",
+                    "  @Override",
+                    "  public Provider<Object> object() {",
+                    "    return (Provider) TestModule_ProvideStringFactory.create();",
+                    "  }",
+                    "}")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Provider<CharSequence> charSequenceProvider;",
+                    "  private volatile Provider<Object> objectProvider;",
+                    "",
+                    "  @Override",
+                    "  public Provider<CharSequence> charSequence() {",
+                    "    if (charSequenceProvider == null) {",
+                    "      charSequenceProvider = new SwitchingProvider<>(0);",
+                    "    }",
+                    "    return charSequenceProvider;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<Object> object() {",
+                    "    if (objectProvider == null) {",
+                    "      objectProvider = new SwitchingProvider<>(1);",
+                    "    }",
+                    "    return objectProvider;",
+                    "  }",
+                    "",
+                    "  private final class SwitchingProvider<T> implements Provider<T> {",
+                    "    @SuppressWarnings(\"unchecked\")",
+                    "    @Override",
+                    "    public T get() {",
+                    "      switch (id) {",
+                    "        case 0:",
+                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
+                    "        case 1:",
+                    "            return (T) TestModule_ProvideStringFactory.proxyProvideString();",
+                    "        default:",
+                    "            throw new AssertionError(id);",
+                    "      }",
+                    "    }",
+                    "  }")
+                .build());
   }
 
   @Test
@@ -818,26 +983,51 @@ public void inlineFactoryOfInacessibleType() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(supertype, injectableSubtype, module, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(supertype, injectableSubtype, module, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerRequestsSubtypeAsProvider")
         .containsElementsIn(
-            JavaFileObjects.forSourceLines(
-                "test.DaggerRequestsSubtypeAsProvider",
-                "package test;",
-                "",
-                "import other.Subtype_Factory;",
-                "import other.Supertype;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerRequestsSubtypeAsProvider ",
-                "    implements RequestsSubtypeAsProvider {",
-                "  @Override",
-                "  public Provider<Supertype> supertypeProvider() {",
-                "    return (Provider) Subtype_Factory.create();",
-                "  }",
-                "}"));
+            compilerMode
+                .javaFileBuilder("test.DaggerRequestsSubtypeAsProvider")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerRequestsSubtypeAsProvider",
+                    "    implements RequestsSubtypeAsProvider {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  @Override",
+                    "  public Provider<Supertype> supertypeProvider() {",
+                    "    return (Provider) Subtype_Factory.create();",
+                    "  }",
+                    "}")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Provider<Supertype> toProvider;",
+                    "",
+                    "  @Override",
+                    "  public Provider<Supertype> supertypeProvider() {",
+                    "    if (toProvider == null) {",
+                    "      toProvider = new SwitchingProvider<>(0);",
+                    "    }",
+                    "    return toProvider;",
+                    "  }",
+                    "",
+                    "  private final class SwitchingProvider<T> implements Provider<T> {",
+                    "    @SuppressWarnings(\"unchecked\")",
+                    "    @Override",
+                    "    public T get() {",
+                    "      switch (id) {",
+                    "        case 0: return (T) Subtype_Factory.newSubtype();",
+                    "        default: throw new AssertionError(id);",
+                    "      }",
+                    "    }",
+                    "  }")
+                .build());
   }
 
   @Test
@@ -914,14 +1104,15 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "}")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Provider<Object> bindStringProvider;",
                     "  private volatile Object object = new MemoizedSentinel();",
-                    "  private volatile Object string = new MemoizedSentinel();",
+                    "  private volatile String string;",
                     "",
                     "  private String getString() {",
-                    "    if (string instanceof MemoizedSentinel) {",
+                    "    if (string == null) {",
                     "      string = TestModule_ProvideStringFactory.proxyProvideString();",
                     "    }",
-                    "    return (String) string;",
+                    "    return string;",
                     "  }",
                     "",
                     "  private Object getObject2() {",
@@ -939,12 +1130,21 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "",
                     "  @Override",
                     "  public Provider<Object> getObject() {",
-                    "    return new Provider<Object>() {",
-                    "      @Override",
-                    "      public Object get() {",
-                    "        return getObject2();",
+                    "    if (bindStringProvider == null) {",
+                    "      bindStringProvider = new SwitchingProvider<>(0);",
+                    "    }",
+                    "    return bindStringProvider;",
+                    "  }",
+                    "",
+                    "  private final class SwitchingProvider<T> implements Provider<T> {",
+                    "    @SuppressWarnings(\"unchecked\")",
+                    "    @Override",
+                    "    public T get() {",
+                    "      switch (id) {",
+                    "        case 0: return (T) getObject2();",
+                    "        default: throw new AssertionError(id);",
                     "      }",
-                    "    };",
+                    "    }",
                     "  }")
                 .build());
   }
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index 93752837a..ae8729300 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -186,6 +186,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "  private volatile Object scopedType = new MemoizedSentinel();",
                 "",
                 "  private DaggerSimpleComponent(Builder builder) {}",
@@ -216,12 +217,10 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "  }",
                 "",
                 "  private Provider<DependsOnScoped> getDependsOnScopedProvider() {",
-                "    return new Provider<DependsOnScoped>() {",
-                "      @Override",
-                "      public DependsOnScoped get() {",
-                "        return getDependsOnScoped();",
-                "      }",
-                "    };",
+                "    if (dependsOnScopedProvider == null) {",
+                "      dependsOnScopedProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return dependsOnScopedProvider;",
                 "  }",
                 "",
                 "  @Override",
@@ -236,6 +235,22 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "      return new DaggerSimpleComponent(this);",
                 "    }",
                 "  }",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) getDependsOnScoped();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
                 "}");
         break;
       default:
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index d6968b427..a186b6d71 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -133,27 +133,25 @@ public void mapBindingsWithEnumKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<Map<PathEnum, Provider<Handler>>>",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
+                "  private volatile Provider<Handler> provideAdminHandlerProvider;",
+                "  private volatile Provider<Handler> provideLoginHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
                 "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleOne_ProvideAdminHandlerFactory.proxyProvideAdminHandler(",
-                "            mapModuleOne));",
-                "      }",
-                "    };",
+                "    if (provideAdminHandlerProvider == null) {",
+                "      provideAdminHandlerProvider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideAdminHandlerProvider;",
                 "  }",
                 "",
                 "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider2() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleTwo_ProvideLoginHandlerFactory.proxyProvideLoginHandler(",
-                "            mapModuleTwo);",
-                "      }",
-                "    };",
+                "    if (provideLoginHandlerProvider == null) {",
+                "      provideLoginHandlerProvider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLoginHandlerProvider;",
                 "  }",
                 "",
                 "  private Map<PathEnum, Provider<Handler>>",
@@ -165,12 +163,34 @@ public void mapBindingsWithEnumKey() {
                 "",
                 "  @Override",
                 "  public Provider<Map<PathEnum, Provider<Handler>>> dispatcher() {",
-                "    return new Provider<Map<PathEnum, Provider<Handler>>>() {",
-                "      @Override",
-                "      public Map<PathEnum, Provider<Handler>> get() {",
-                "        return getMapOfPathEnumAndProviderOfHandler();",
+                "    if (mapOfPathEnumAndProviderOfHandlerProvider == null) {",
+                "      mapOfPathEnumAndProviderOfHandlerProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return mapOfPathEnumAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "            return (T) getMapOfPathEnumAndProviderOfHandler();",
+                "        case 1:",
+                "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
+                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "        case 2:",
+                "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
+                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "        default: throw new AssertionError(id);",
                 "      }",
-                "    };",
+                "    }",
                 "  }",
                 "}");
         break;
@@ -511,27 +531,25 @@ public void mapBindingsWithStringKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<Map<String, Provider<Handler>>>",
+                "      mapOfStringAndProviderOfHandlerProvider;",
+                "  private volatile Provider<Handler> provideAdminHandlerProvider;",
+                "  private volatile Provider<Handler> provideLoginHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
                 "  private Provider<Handler> getMapOfStringAndProviderOfHandlerProvider() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleOne_ProvideAdminHandlerFactory.proxyProvideAdminHandler(",
-                "            mapModuleOne);",
-                "      }",
-                "    };",
+                "    if (provideAdminHandlerProvider == null) {",
+                "      provideAdminHandlerProvider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideAdminHandlerProvider;",
                 "  }",
                 "",
                 "  private Provider<Handler> getMapOfStringAndProviderOfHandlerProvider2() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleTwo_ProvideLoginHandlerFactory.proxyProvideLoginHandler(",
-                "            mapModuleTwo);",
-                "      }",
-                "    };",
+                "    if (provideLoginHandlerProvider == null) {",
+                "      provideLoginHandlerProvider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLoginHandlerProvider;",
                 "  }",
                 "",
                 "  private Map<String, Provider<Handler>>",
@@ -543,12 +561,34 @@ public void mapBindingsWithStringKey() {
                 "",
                 "  @Override",
                 "  public Provider<Map<String, Provider<Handler>>> dispatcher() {",
-                "    return new Provider<Map<String, Provider<Handler>>>() {",
-                "      @Override",
-                "      public Map<String, Provider<Handler>> get() {",
-                "        return getMapOfStringAndProviderOfHandler();",
+                "    if (mapOfStringAndProviderOfHandlerProvider == null) {",
+                "      mapOfStringAndProviderOfHandlerProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return mapOfStringAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "            return (T) getMapOfStringAndProviderOfHandler();",
+                "        case 1:",
+                "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
+                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "        case 2:",
+                "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
+                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "        default: throw new AssertionError(id);",
                 "      }",
-                "    };",
+                "    }",
                 "  }",
                 "}");
         break;
@@ -682,29 +722,27 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<Map<WrappedClassKey, Provider<Handler>>>",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "  private volatile Provider<Handler> provideAdminHandlerProvider;",
+                "  private volatile Provider<Handler> provideLoginHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
                 "  private Provider<Handler>",
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleOne_ProvideAdminHandlerFactory.proxyProvideAdminHandler(",
-                "            mapModuleOne);",
-                "      }",
-                "    };",
+                "    if (provideAdminHandlerProvider == null) {",
+                "      provideAdminHandlerProvider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideAdminHandlerProvider;",
                 "  }",
                 "",
                 "  private Provider<Handler>",
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider2() {",
-                "    return new Provider<Handler>() {",
-                "      @Override",
-                "      public Handler get() {",
-                "        return MapModuleTwo_ProvideLoginHandlerFactory.proxyProvideLoginHandler(",
-                "            mapModuleTwo);",
-                "      }",
-                "    };",
+                "    if (provideLoginHandlerProvider == null) {",
+                "      provideLoginHandlerProvider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLoginHandlerProvider;",
                 "  }",
                 "",
                 "  private Map<WrappedClassKey, Provider<Handler>>",
@@ -724,12 +762,35 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "  @Override",
                 "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
-                "    return new Provider<Map<WrappedClassKey, Provider<Handler>>>() {",
-                "      @Override",
-                "      public Map<WrappedClassKey, Provider<Handler>> get() {",
-                "        return getMapOfWrappedClassKeyAndProviderOfHandler();",
+                "    if (mapOfWrappedClassKeyAndProviderOfHandlerProvider == null) {",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+                "          new SwitchingProvider<>(0);",
+                "    }",
+                "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "            return (T) getMapOfWrappedClassKeyAndProviderOfHandler();",
+                "        case 1:",
+                "            return (T) MapModuleOne_ProvideAdminHandlerFactory",
+                "                .proxyProvideAdminHandler(mapModuleOne);",
+                "        case 2:",
+                "            return (T) MapModuleTwo_ProvideLoginHandlerFactory",
+                "                .proxyProvideLoginHandler(mapModuleTwo);",
+                "        default: throw new AssertionError(id);",
                 "      }",
-                "    };",
+                "    }",
                 "  }",
                 "}");
         break;
@@ -867,6 +928,8 @@ public void mapBindingsWithNonProviderValue() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
+                "  private volatile Provider<Map<PathEnum, Handler>>",
+                "      mapOfPathEnumAndHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
@@ -882,12 +945,27 @@ public void mapBindingsWithNonProviderValue() {
                 "",
                 "  @Override",
                 "  public Provider<Map<PathEnum, Handler>> dispatcher() {",
-                "    return new Provider<Map<PathEnum, Handler>>() {",
-                "      @Override",
-                "      public Map<PathEnum, Handler> get() {",
-                "        return getMapOfPathEnumAndHandler();",
+                "    if (mapOfPathEnumAndHandlerProvider == null) {",
+                "      mapOfPathEnumAndHandlerProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return mapOfPathEnumAndHandlerProvider;",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) getMapOfPathEnumAndHandler();",
+                "        default: throw new AssertionError(id);",
                 "      }",
-                "    };",
+                "    }",
                 "  }",
                 "}");
         break;
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
index 8bf02a9c2..ea4321a91 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
@@ -87,53 +89,124 @@ public void mapBindings() {
         "  Map<Long, Provider<Long>> providerLongs();",
         "}");
     JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapBuilder;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @Override",
-            "  public Map<String, String> strings() {",
-            "    return Collections.<String, String>emptyMap();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, Provider<String>> providerStrings() {",
-            "    return Collections.<String, Provider<String>>emptyMap();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Integer> ints() {",
-            "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Provider<Integer>> providerInts() {",
-            "    return Collections.<Integer, Provider<Integer>>singletonMap(",
-            "        0, MapModule_ProvideIntFactory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Long> longs() {",
-            "    return MapBuilder.<Long, Long>newMapBuilder(3)",
-            "        .put(0L, MapModule.provideLong0())",
-            "        .put(1L, MapModule.provideLong1())",
-            "        .put(2L, MapModule.provideLong2())",
-            "        .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Provider<Long>> providerLongs() {",
-            "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
-            "        .put(0L, MapModule_ProvideLong0Factory.create())",
-            "        .put(1L, MapModule_ProvideLong1Factory.create())",
-            "        .put(2L, MapModule_ProvideLong2Factory.create())",
-            "        .build();",
-            "  }",
-            "}");
+        compilerMode
+            .javaFileBuilder("test.DaggerTestComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.internal.MapBuilder;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private volatile Provider<Integer> provideIntProvider;",
+                "  private volatile Provider<Long> provideLong0Provider;",
+                "  private volatile Provider<Long> provideLong1Provider;",
+                "  private volatile Provider<Long> provideLong2Provider;",
+                "",
+                "  private Provider<Integer> getMapOfIntegerAndProviderOfIntegerProvider() {",
+                "    if (provideIntProvider == null) {",
+                "      provideIntProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return provideIntProvider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "    if (provideLong0Provider == null) {",
+                "      provideLong0Provider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideLong0Provider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "    if (provideLong1Provider == null) {",
+                "      provideLong1Provider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLong1Provider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "    if (provideLong2Provider == null) {",
+                "      provideLong2Provider = new SwitchingProvider<>(3);",
+                "    }",
+                "    return provideLong2Provider;",
+                "  }")
+            .addLines(
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return Collections.<String, String>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return Collections.<String, Provider<String>>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return Collections.<Integer, Provider<Integer>>singletonMap(")
+            .addLinesIn(
+                DEFAULT_MODE, //
+                "        0, MapModule_ProvideIntFactory.create());")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "        0, getMapOfIntegerAndProviderOfIntegerProvider());")
+            .addLines(
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+                "        .put(0L, MapModule.provideLong0())",
+                "        .put(1L, MapModule.provideLong1())",
+                "        .put(2L, MapModule.provideLong2())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "        .put(0L, MapModule_ProvideLong0Factory.create())",
+                "        .put(1L, MapModule_ProvideLong1Factory.create())",
+                "        .put(2L, MapModule_ProvideLong2Factory.create())")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "        .put(0L, getMapOfLongAndProviderOfLongProvider())",
+                "        .put(1L, getMapOfLongAndProviderOfLongProvider2())",
+                "        .put(2L, getMapOfLongAndProviderOfLongProvider3())")
+            .addLines( //
+                "        .build();", "  }")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) (Integer) MapModule.provideInt();",
+                "        case 1: return (T) (Long) MapModule.provideLong0();",
+                "        case 2: return (T) (Long) MapModule.provideLong1();",
+                "        case 3: return (T) (Long) MapModule.provideLong2();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}")
+            .build();
     Compilation compilation = daggerCompilerWithoutGuava().compile(mapModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index b17472914..b66dae78e 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -120,12 +122,48 @@ public void mapBindings() {
             "  Map<Long, Provider<Long>> providerLongs();",
             "}");
     JavaFileObject generatedComponent =
-            JavaFileObjects.forSourceLines(
-                "test.DaggerTestComponent",
+        compilerMode
+            .javaFileBuilder("test.DaggerTestComponent")
+            .addLines(
                 "package test;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {",
+                "public final class DaggerTestComponent implements TestComponent {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private volatile Provider<Integer> provideIntProvider;",
+                "  private volatile Provider<Long> provideLong0Provider;",
+                "  private volatile Provider<Long> provideLong1Provider;",
+                "  private volatile Provider<Long> provideLong2Provider;",
+                "",
+                "  private Provider<Integer> getMapOfIntegerAndProviderOfIntegerProvider() {",
+                "    if (provideIntProvider == null) {",
+                "      provideIntProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return provideIntProvider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "    if (provideLong0Provider == null) {",
+                "      provideLong0Provider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideLong0Provider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "    if (provideLong1Provider == null) {",
+                "      provideLong1Provider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLong1Provider;",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "    if (provideLong2Provider == null) {",
+                "      provideLong2Provider = new SwitchingProvider<>(3);",
+                "    }",
+                "    return provideLong2Provider;",
+                "  }")
+            .addLines(
                 "  @Override",
                 "  public Map<String, String> strings() {",
                 "    return ImmutableMap.<String, String>of();",
@@ -143,8 +181,14 @@ public void mapBindings() {
                 "",
                 "  @Override",
                 "  public Map<Integer, Provider<Integer>> providerInts() {",
-                "    return ImmutableMap.<Integer, Provider<Integer>>of(",
-                "        0, MapModule_ProvideIntFactory.create());",
+                "    return ImmutableMap.<Integer, Provider<Integer>>of(")
+            .addLinesIn(
+                DEFAULT_MODE, //
+                "        0, MapModule_ProvideIntFactory.create());")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "        0, getMapOfIntegerAndProviderOfIntegerProvider());")
+            .addLines(
                 "  }",
                 "",
                 "  @Override",
@@ -157,10 +201,18 @@ public void mapBindings() {
                 "",
                 "  @Override",
                 "  public Map<Long, Provider<Long>> providerLongs() {",
-                "    return ImmutableMap.<Long, Provider<Long>>of(",
+                "    return ImmutableMap.<Long, Provider<Long>>of(")
+            .addLinesIn(
+                DEFAULT_MODE,
                 "      0L, MapModule_ProvideLong0Factory.create(),",
                 "      1L, MapModule_ProvideLong1Factory.create(),",
-                "      2L, MapModule_ProvideLong2Factory.create());",
+                "      2L, MapModule_ProvideLong2Factory.create());")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "      0L, getMapOfLongAndProviderOfLongProvider(),",
+                "      1L, getMapOfLongAndProviderOfLongProvider2(),",
+                "      2L, getMapOfLongAndProviderOfLongProvider3());")
+            .addLines(
                 "  }",
                 "",
                 "  @Override",
@@ -168,9 +220,35 @@ public void mapBindings() {
                 "    return new SubImpl();",
                 "  }",
                 "",
-                "  private final class SubImpl implements Sub {",
+                "  private final class SubImpl implements Sub {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    private volatile Provider<Long> provideLong3Provider;",
+                "    private volatile Provider<Long> provideLong4Provider;",
+                "    private volatile Provider<Long> provideLong5Provider;",
                 "    private SubImpl() {}",
                 "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "    if (provideLong3Provider == null) {",
+                "      provideLong3Provider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return provideLong3Provider;",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "    if (provideLong4Provider == null) {",
+                "      provideLong4Provider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return provideLong4Provider;",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "    if (provideLong5Provider == null) {",
+                "      provideLong5Provider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return provideLong5Provider;",
+                "    }")
+            .addLines(
                 "    @Override",
                 "    public Map<Long, Long> longs() {",
                 "      return ImmutableMap.<Long, Long>builderWithExpectedSize(6)",
@@ -185,17 +263,71 @@ public void mapBindings() {
                 "",
                 "    @Override",
                 "    public Map<Long, Provider<Long>> providerLongs() {",
-                "      return ImmutableMap.<Long, Provider<Long>>builderWithExpectedSize(6)",
+                "      return ImmutableMap.<Long, Provider<Long>>builderWithExpectedSize(6)")
+            .addLinesIn(
+                DEFAULT_MODE,
                 "          .put(0L, MapModule_ProvideLong0Factory.create())",
                 "          .put(1L, MapModule_ProvideLong1Factory.create())",
                 "          .put(2L, MapModule_ProvideLong2Factory.create())",
                 "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
                 "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
-                "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
-                "          .build();",
+                "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "          .put(0L, DaggerTestComponent.this",
+                "              .getMapOfLongAndProviderOfLongProvider())",
+                "          .put(1L, DaggerTestComponent.this",
+                "              .getMapOfLongAndProviderOfLongProvider2())",
+                "          .put(2L, DaggerTestComponent.this",
+                "              .getMapOfLongAndProviderOfLongProvider3())",
+                "          .put(3L, getMapOfLongAndProviderOfLongProvider())",
+                "          .put(4L, getMapOfLongAndProviderOfLongProvider2())",
+                "          .put(5L, getMapOfLongAndProviderOfLongProvider3())")
+            .addLines( //
+                "          .build();", "    }")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    private final class SwitchingProvider<T> implements Provider<T> {",
+                "      private final int id;",
+                "",
+                "      SwitchingProvider(int id) {",
+                "        this.id = id;",
+                "      }",
+                "",
+                "      @SuppressWarnings(\"unchecked\")",
+                "      @Override",
+                "      public T get() {",
+                "        switch (id) {",
+                "          case 0: return (T) (Long) SubcomponentMapModule.provideLong3();",
+                "          case 1: return (T) (Long) SubcomponentMapModule.provideLong4();",
+                "          case 2: return (T) (Long) SubcomponentMapModule.provideLong5();",
+                "          default: throw new AssertionError(id);",
+                "        }",
+                "      }",
+                "    }",
+                "  }",
+                "",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) (Integer) MapModule.provideInt();",
+                "        case 1: return (T) (Long) MapModule.provideLong0();",
+                "        case 2: return (T) (Long) MapModule.provideLong1();",
+                "        case 3: return (T) (Long) MapModule.provideLong2();",
+                "        default: throw new AssertionError(id);",
+                "      }",
                 "    }",
                 "  }",
-                "}");
+                "}")
+            .build();
     Compilation compilation =
         daggerCompiler()
             .withOptions(compilerMode.javacopts())
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 1d5f0f6e4..c1f70fe1f 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -103,37 +105,78 @@ public void inlinedOptionalBindings() {
             "  Optional<DefinitelyNot> definitelyNot();",
             "  Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot();",
             "}");
+
     JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @Override",
-            "  public Optional<Maybe> maybe() {",
-            "    return Optional.of(Maybe_MaybeModule_ProvideMaybeFactory.proxyProvideMaybe());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
-            "    return Optional.of(",
-            "        ProviderOfLazy.create(Maybe_MaybeModule_ProvideMaybeFactory.create()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<DefinitelyNot> definitelyNot() {",
-            "    return Optional.<DefinitelyNot>absent();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<Provider<Lazy<DefinitelyNot>>>",
-            "      providerOfLazyOfDefinitelyNot() {",
-            "    return Optional.<Provider<Lazy<DefinitelyNot>>>absent();",
-            "  }",
-            "}");
+        compilerMode
+            .javaFileBuilder("test.DaggerTestComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private volatile Provider<Maybe> provideMaybeProvider;",
+                "",
+                "  private Provider<Maybe> getMaybeProvider() {",
+                "    if (provideMaybeProvider == null) {",
+                "      provideMaybeProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return provideMaybeProvider;",
+                "  }")
+            .addLines(
+                "  @Override",
+                "  public Optional<Maybe> maybe() {",
+                "    return Optional.of(",
+                "        Maybe_MaybeModule_ProvideMaybeFactory.proxyProvideMaybe());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+                "    return Optional.of(ProviderOfLazy.create(")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "        Maybe_MaybeModule_ProvideMaybeFactory.create()));")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "        getMaybeProvider()));")
+            .addLines(
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<DefinitelyNot> definitelyNot() {",
+                "    return Optional.<DefinitelyNot>absent();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<DefinitelyNot>>>",
+                "      providerOfLazyOfDefinitelyNot() {",
+                "    return Optional.<Provider<Lazy<DefinitelyNot>>>absent();",
+                "  }")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0:",
+                "          return (T) Maybe_MaybeModule_ProvideMaybeFactory.proxyProvideMaybe();",
+                "        default:",
+                "          throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
+                "}")
+            .build();
     Compilation compilation =
         daggerCompiler()
             .withOptions(compilerMode.javacopts())
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ed8101f03..ab260fbde 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -226,14 +226,15 @@ public void simpleComponent() {
                 "test.DaggerTestClass_SimpleComponent",
                 "package test;",
                 "",
+                "import com.google.common.collect.ImmutableSet;",
                 "import com.google.common.util.concurrent.ListenableFuture;",
                 "import dagger.internal.InstanceFactory;",
                 "import dagger.internal.MemoizedSentinel;",
                 "import dagger.internal.Preconditions;",
-                "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
+                "import java.util.Set;",
                 "import java.util.concurrent.Executor;",
                 IMPORT_GENERATED_ANNOTATION,
                 "import javax.inject.Provider;",
@@ -241,9 +242,14 @@ public void simpleComponent() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
                 "    implements TestClass.SimpleComponent {",
+                "  private volatile Provider<Executor> executorProvider;",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
+                "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
+                "  private volatile Provider<Set<ProductionComponentMonitor.Factory>>",
+                "      setOfFactoryProvider;",
+                "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Producer<TestClass.B> bProducer;",
@@ -278,12 +284,18 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  private Provider<Executor> getProductionImplementationExecutorProvider() {",
-                "    return new Provider<Executor>() {",
-                "      @Override",
-                "      public Executor get() {",
-                "        return getProductionImplementationExecutor();",
-                "      }",
-                "    };",
+                "    if (executorProvider == null) {",
+                "      executorProvider = new SwitchingProvider<>(0);",
+                "    }",
+                "    return executorProvider;",
+                "  }",
+                "",
+                "  private Provider<Set<ProductionComponentMonitor.Factory>>",
+                "      getSetOfFactoryProvider() {",
+                "    if (setOfFactoryProvider == null) {",
+                "      setOfFactoryProvider = new SwitchingProvider<>(2);",
+                "    }",
+                "    return setOfFactoryProvider;",
                 "  }",
                 "",
                 "  private ProductionComponentMonitor getProductionComponentMonitor() {",
@@ -295,7 +307,7 @@ public void simpleComponent() {
                 "              TestClass_SimpleComponent_MonitoringModule_MonitorFactory",
                 "                  .proxyMonitor(",
                 "                      simpleComponentProvider,",
-                "                      SetFactory.<ProductionComponentMonitor.Factory>empty());",
+                "                      getSetOfFactoryProvider());",
                 "        }",
                 "        local = productionComponentMonitor;",
                 "      }",
@@ -305,12 +317,10 @@ public void simpleComponent() {
                 "",
                 "  private Provider<ProductionComponentMonitor>",
                 "      getProductionComponentMonitorProvider() {",
-                "    return new Provider<ProductionComponentMonitor>() {",
-                "      @Override",
-                "      public ProductionComponentMonitor get() {",
-                "        return getProductionComponentMonitor();",
-                "      }",
-                "    };",
+                "    if (monitorProvider == null) {",
+                "      monitorProvider = new SwitchingProvider<>(1);",
+                "    }",
+                "    return monitorProvider;",
                 "  }",
                 "",
                 "  private TestClass.B getB() {",
@@ -318,12 +328,10 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  private Provider<TestClass.B> getBProvider() {",
-                "    return new Provider<TestClass.B>() {",
-                "      @Override",
-                "      public TestClass.B get() {",
-                "        return getB();",
-                "      }",
-                "    };",
+                "    if (bProvider == null) {",
+                "      bProvider = new SwitchingProvider<>(3);",
+                "    }",
+                "    return bProvider;",
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
@@ -381,6 +389,25 @@ public void simpleComponent() {
                 "      return this;",
                 "    }",
                 "  }",
+                "  private final class SwitchingProvider<T> implements Provider<T> {",
+                "    private final int id;",
+                "",
+                "    SwitchingProvider(int id) {",
+                "      this.id = id;",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    @Override",
+                "    public T get() {",
+                "      switch (id) {",
+                "        case 0: return (T) getProductionImplementationExecutor();",
+                "        case 1: return (T) getProductionComponentMonitor();",
+                "        case 2: return (T) ImmutableSet.<ProductionComponentMonitor.Factory>of();",
+                "        case 3: return (T) getB();",
+                "        default: throw new AssertionError(id);",
+                "      }",
+                "    }",
+                "  }",
                 "}");
         break;
       default:
diff --git a/test_defs.bzl b/test_defs.bzl
index cee81b3d9..2f96caf15 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -16,6 +16,9 @@
 # The key will be appended to the generated test names to ensure uniqueness.
 BUILD_VARIANTS = {
     "ExperimentalAndroidMode": ["-Adagger.experimentalAndroidMode=enabled"],
+    "ExperimentalAheadOfTimeComponents": ["-Adagger.experimentalAheadOfTimeComponents=enabled"],
+    "ExperimentalAndroidModeAndAheadOfTimeComponents": ["-Adagger.experimentalAndroidMode=enabled",
+                                                        "-Adagger.experimentalAheadOfTimeComponents=enabled"],
 }
 
 # TODO(user): split into two functions for functional vs non-functional tests?
@@ -37,9 +40,9 @@ def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_dep
 
   if functional:
     for (variant_name, extra_lib_javacopts) in BUILD_VARIANTS.items():
-      lib_javacopts = (lib_javacopts or []) + extra_lib_javacopts
+      variant_lib_javacopts = (lib_javacopts or []) + extra_lib_javacopts
       _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
-                 plugins, javacopts, lib_javacopts, test_javacopts, variant_name)
+                 plugins, javacopts, variant_lib_javacopts, test_javacopts, variant_name)
 
 def _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
                plugins, javacopts, lib_javacopts, test_javacopts, variant_name=None):
@@ -82,9 +85,10 @@ def _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_de
   for test_file in test_files:
     test_name = test_file.replace(".java", "")
     prefix_path = "src/test/java/"
-    if PACKAGE_NAME.find("javatests/") != -1:
+    package_name = native.package_name()
+    if package_name.find("javatests/") != -1:
       prefix_path = "javatests/"
-    test_class = (PACKAGE_NAME + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
+    test_class = (package_name + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
     test_rule_type(
         name = test_name + suffix,
         deps = test_deps,
