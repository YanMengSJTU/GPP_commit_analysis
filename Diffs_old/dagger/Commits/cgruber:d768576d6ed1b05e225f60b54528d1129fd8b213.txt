diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1b0e7b111..a804cff1d 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -237,6 +237,7 @@ java_library(
         "MembersInjectionMethods.java",
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
+        "MethodBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index e09b11ca2..2d036839f 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -638,7 +638,7 @@ private BindingExpression wrapInMethod(
         .<BindingExpression>map(
             componentMethod ->
                 new ComponentMethodBindingExpression(
-                    methodImplementation, generatedComponentModel, componentMethod, this))
+                    methodImplementation, generatedComponentModel, componentMethod))
         .orElseGet(
             () ->
                 new PrivateMethodBindingExpression(
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index cdd92c918..18eac4ada 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -20,7 +20,6 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 
 /**
@@ -28,21 +27,19 @@
  *
  * <p>Dependents of this binding expression will just call the component method.
  */
-final class ComponentMethodBindingExpression extends BindingExpression {
+final class ComponentMethodBindingExpression extends MethodBindingExpression {
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentMethodDescriptor componentMethod;
-  private final ComponentBindingExpressions componentBindingExpressions;
 
   ComponentMethodBindingExpression(
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel,
-      ComponentMethodDescriptor componentMethod,
-      ComponentBindingExpressions componentBindingExpressions) {
+      ComponentMethodDescriptor componentMethod) {
+    super(methodImplementation, generatedComponentModel);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentMethod = checkNotNull(componentMethod);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
   @Override
@@ -64,12 +61,10 @@ protected CodeBlock getComponentMethodImplementation(
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
-    MethodSpec implementedMethod = componentBindingExpressions.getComponentMethod(componentMethod);
-    return Expression.create(
-        methodImplementation.returnType(),
-        requestingClass.equals(generatedComponentModel.name())
-            ? CodeBlock.of("$N()", implementedMethod)
-            : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), implementedMethod));
+  protected void addMethod() {}
+
+  @Override
+  protected String methodName() {
+    return componentMethod.methodElement().getSimpleName().toString();
   }
 }
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
new file mode 100644
index 000000000..c9e53907b
--- /dev/null
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/** A binding expression that wraps another in a nullary method on the component. */
+abstract class MethodBindingExpression extends BindingExpression {
+
+  private final BindingMethodImplementation methodImplementation;
+  private final GeneratedComponentModel generatedComponentModel;
+
+  protected MethodBindingExpression(
+      BindingMethodImplementation methodImplementation,
+      GeneratedComponentModel generatedComponentModel) {
+    this.methodImplementation = checkNotNull(methodImplementation);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    addMethod();
+    return Expression.create(
+        methodImplementation.returnType(),
+        requestingClass.equals(generatedComponentModel.name())
+            ? CodeBlock.of("$N()", methodName())
+            : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), methodName()));
+  }
+
+  /** Adds the method to the component (if necessary) the first time it's called. */
+  protected abstract void addMethod();
+
+  /** Returns the name of the method to call. */
+  protected abstract String methodName();
+}
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 88aee7ac7..e19f9b853 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -20,12 +20,11 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.PRIVATE_METHOD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.model.RequestKind;
 
@@ -34,7 +33,7 @@
  *
  * <p>Dependents of this binding expression will just call the no-arg private method.
  */
-final class PrivateMethodBindingExpression extends BindingExpression {
+final class PrivateMethodBindingExpression extends MethodBindingExpression {
   private final ContributionBinding binding;
   private final RequestKind requestKind;
   private final BindingMethodImplementation methodImplementation;
@@ -46,6 +45,7 @@
       RequestKind requestKind,
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel) {
+    super(methodImplementation, generatedComponentModel);
     this.binding = resolvedBindings.contributionBinding();
     this.requestKind = checkNotNull(requestKind);
     this.methodImplementation = checkNotNull(methodImplementation);
@@ -53,52 +53,43 @@
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
+  protected void addMethod() {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
-      methodName = generatedComponentModel.getUniqueMethodName(methodName());
-      createMethod(methodName);
+      methodName = chooseMethodName();
+      // TODO(user): Fix the order that these generated methods are written to the component.
+      generatedComponentModel.addMethod(
+          PRIVATE_METHOD,
+          methodBuilder(methodName)
+              .addModifiers(PRIVATE)
+              .returns(TypeName.get(methodImplementation.returnType()))
+              .addCode(methodImplementation.body())
+              .build());
     }
-
-    // TODO(user): This logic is repeated in multiple places. Can we extract it somewhere?
-    ClassName componentName = generatedComponentModel.name();
-    CodeBlock invocation =
-        componentName.equals(requestingClass)
-            ? CodeBlock.of("$N()", methodName)
-            : CodeBlock.of("$T.this.$N()", componentName, methodName);
-    return Expression.create(methodImplementation.returnType(), invocation);
   }
 
-  /** Creates the no-arg method used for dependency expressions. */
-  private void createMethod(String name) {
-    // TODO(user): Consider when we can make this method static.
-    // TODO(user): Fix the order that these generated methods are written to the component.
-    generatedComponentModel.addMethod(
-        PRIVATE_METHOD,
-        methodBuilder(name)
-            .addModifiers(PRIVATE)
-            .returns(TypeName.get(methodImplementation.returnType()))
-            .addCode(methodImplementation.body())
-            .build());
+  @Override
+  protected String methodName() {
+    checkState(methodName != null, "addMethod() must be called before methodName()");
+    return methodName;
   }
 
-  /** Returns the canonical name for a no-arg dependency expression method. */
-  private String methodName() {
+  private String chooseMethodName() {
     // TODO(user): Use a better name for @MapKey binding instances.
     // TODO(user): Include the binding method as part of the method name.
-    if (requestKind.equals(RequestKind.INSTANCE)) {
-      return "get" + bindingName();
-    }
-    return "get" + bindingName() + dependencyKindName(requestKind);
+    return generatedComponentModel.getUniqueMethodName(
+        "get" + bindingName() + dependencyKindName());
   }
 
-  /** Returns the canonical name for the {@link Binding}. */
+  /** Returns the canonical method name suffix for the binding. */
   private String bindingName() {
     return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
   }
 
-  /** Returns a canonical name for the {@link RequestKind}. */
-  private static String dependencyKindName(RequestKind kind) {
-    return UPPER_UNDERSCORE.to(UPPER_CAMEL, kind.name());
+  /** Returns a canonical method name suffix for the request kind. */
+  private String dependencyKindName() {
+    return requestKind.equals(RequestKind.INSTANCE)
+        ? ""
+        : UPPER_UNDERSCORE.to(UPPER_CAMEL, requestKind.name());
   }
 }
