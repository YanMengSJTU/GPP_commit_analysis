diff --git a/compiler/pom.xml b/compiler/pom.xml
index 783c84e50..d8a74e902 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -70,7 +70,7 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.0</version>
+      <version>1.1</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index aa92fa5c5..88a806109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -15,7 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableSet;
 import dagger.producers.Produces;
 import java.util.EnumSet;
 import java.util.Map;
@@ -25,54 +27,45 @@
 import javax.tools.Diagnostic;
 
 /** A collection of options that dictate how the compiler will run. */
-final class CompilerOptions {
-  private final boolean usesProducers;
-  private final Diagnostic.Kind nullableValidationKind;
-  private final Diagnostic.Kind privateMemberValidationKind;
-  private final Diagnostic.Kind staticMemberValidationKind;
-  private final ValidationType scopeCycleValidationType;
-
-  CompilerOptions(ProcessingEnvironment processingEnv, Elements elements) {
-    this(
-        elements.getTypeElement(Produces.class.getCanonicalName()) != null,
-        nullableValidationType(processingEnv).diagnosticKind().get(),
-        privateMemberValidationType(processingEnv).diagnosticKind().get(),
-        staticMemberValidationType(processingEnv).diagnosticKind().get(),
-        scopeValidationType(processingEnv));
+@AutoValue
+abstract class CompilerOptions {
+  abstract boolean usesProducers();
+  abstract boolean writeProducerNameInToken();
+  abstract Diagnostic.Kind nullableValidationKind();
+  abstract Diagnostic.Kind privateMemberValidationKind();
+  abstract Diagnostic.Kind staticMemberValidationKind();
+  abstract ValidationType scopeCycleValidationType();
+
+  static Builder builder() {
+    return new AutoValue_CompilerOptions.Builder();
   }
 
-  CompilerOptions(
-      boolean usesProducers,
-      Diagnostic.Kind nullableValidationKind,
-      Diagnostic.Kind privateMemberValidationKind,
-      Diagnostic.Kind staticMemberValidationKind,
-      ValidationType scopeCycleValidationType) {
-    this.usesProducers = usesProducers;
-    this.nullableValidationKind = nullableValidationKind;
-    this.privateMemberValidationKind = privateMemberValidationKind;
-    this.staticMemberValidationKind = staticMemberValidationKind;
-    this.scopeCycleValidationType = scopeCycleValidationType;
+  static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elements) {
+    return builder()
+        .usesProducers(elements.getTypeElement(Produces.class.getCanonicalName()) != null)
+        .writeProducerNameInToken(
+            writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))
+        .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
+        .privateMemberValidationKind(
+            privateMemberValidationType(processingEnv).diagnosticKind().get())
+        .staticMemberValidationKind(
+            staticMemberValidationType(processingEnv).diagnosticKind().get())
+        .scopeCycleValidationType(scopeValidationType(processingEnv))
+        .build();
   }
 
-  boolean usesProducers() {
-    return usesProducers;
+  @AutoValue.Builder
+  interface Builder {
+    Builder usesProducers(boolean usesProduces);
+    Builder writeProducerNameInToken(boolean writeProducerNameInToken);
+    Builder nullableValidationKind(Diagnostic.Kind kind);
+    Builder privateMemberValidationKind(Diagnostic.Kind kind);
+    Builder staticMemberValidationKind(Diagnostic.Kind kind);
+    Builder scopeCycleValidationType(ValidationType type);
+    CompilerOptions build();
   }
 
-  Diagnostic.Kind nullableValidationKind() {
-    return nullableValidationKind;
-  }
-
-  Diagnostic.Kind privateMemberValidationKind() {
-    return privateMemberValidationKind;
-  }
-
-  Diagnostic.Kind staticMemberValidationKind() {
-    return staticMemberValidationKind;
-  }
-
-  ValidationType scopeCycleValidationType() {
-    return scopeCycleValidationType;
-  }
+  static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY = "dagger.writeProducerNameInToken";
 
   static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
       "dagger.disableInterComponentScopeValidation";
@@ -83,6 +76,21 @@ ValidationType scopeCycleValidationType() {
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  static final ImmutableSet<String> SUPPORTED_OPTIONS = ImmutableSet.of(
+        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        NULLABLE_VALIDATION_KEY,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY);
+
+  private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 90126f9db..3d439dd47 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -49,11 +48,7 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(
-        CompilerOptions.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        CompilerOptions.NULLABLE_VALIDATION_KEY,
-        CompilerOptions.PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        CompilerOptions.STATIC_MEMBER_VALIDATION_TYPE_KEY);
+    return CompilerOptions.SUPPORTED_OPTIONS;
   }
 
   @Override
@@ -63,7 +58,7 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
-    CompilerOptions compilerOptions = new CompilerOptions(processingEnv, elements);
+    CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
@@ -99,7 +94,7 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements);
+        new ProducerFactoryGenerator(filer, elements, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
     ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
new file mode 100644
index 000000000..792d67e53
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/** Allows options to control how features in component processing are enabled. */
+enum FeatureStatus {
+  ENABLED,
+  DISABLED;
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index d7bbdbd27..d1e5d3a8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -70,9 +70,11 @@
  * @since 2.0
  */
 final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+  private final CompilerOptions compilerOptions;
 
-  ProducerFactoryGenerator(Filer filer, Elements elements) {
+  ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
     super(filer, elements);
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -106,15 +108,13 @@ ClassName nameGeneratedType(ProductionBinding binding) {
         constructorBuilder()
             .addModifiers(PUBLIC)
             .addStatement(
-                "super($L, $T.create($T.class))",
+                "super($L, $L)",
                 fields.get(binding.monitorRequest().get().bindingKey()).name(),
-                PRODUCER_TOKEN,
-                generatedTypeName);
+                producerTokenConstruction(generatedTypeName, binding));
 
     if (!binding.bindingElement().getModifiers().contains(STATIC)) {
       TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
-      addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, "module", moduleType);
+      addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
     for (FrameworkField bindingField : fields.values()) {
@@ -214,6 +214,20 @@ public boolean apply(DependencyRequest dependency) {
         .toList();
   }
 
+  private CodeBlock producerTokenConstruction(
+      ClassName generatedTypeName, ProductionBinding binding) {
+    CodeBlock producerTokenArgs =
+        compilerOptions.writeProducerNameInToken()
+            ? CodeBlocks.format(
+                "$S",
+                String.format(
+                    "%s#%s",
+                    ClassName.get(binding.bindingTypeElement()),
+                    binding.bindingElement().getSimpleName()))
+            : CodeBlocks.format("$T.class", generatedTypeName);
+    return CodeBlocks.format("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
+  }
+
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
     return dependency.requestElement().getSimpleName() + "Future";
@@ -420,16 +434,15 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
-        codeBlocks.add(CodeBlocks.format(
-            "($T) $L.get($L)",
-            asyncDependencyType(dependency),
-            listArgName,
-            argIndex));
+        codeBlocks.add(
+            CodeBlocks.format(
+                "($T) $L.get($L)", asyncDependencyType(dependency), listArgName, argIndex));
         argIndex++;
       } else {
-        codeBlocks.add(frameworkTypeUsageStatement(
-            CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
-            dependency.kind()));
+        codeBlocks.add(
+            frameworkTypeUsageStatement(
+                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                dependency.kind()));
       }
     }
     return codeBlocks.build();
@@ -448,12 +461,14 @@ private CodeBlock getInvocationCodeBlock(
       ProductionBinding binding,
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
-    CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
-        binding.bindingElement().getModifiers().contains(STATIC)
-            ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-            : CodeBlocks.format("$T.this.module", generatedTypeName),
-        binding.bindingElement().getSimpleName(),
-        makeParametersCodeBlock(parameterCodeBlocks));
+    CodeBlock moduleCodeBlock =
+        CodeBlocks.format(
+            "$L.$L($L)",
+            binding.bindingElement().getModifiers().contains(STATIC)
+                ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
+                : CodeBlocks.format("$T.this.module", generatedTypeName),
+            binding.bindingElement().getSimpleName(),
+            makeParametersCodeBlock(parameterCodeBlocks));
 
     // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
@@ -467,8 +482,7 @@ private CodeBlock getInvocationCodeBlock(
         valueCodeBlock =
             CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueCodeBlock =
-            CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
+        valueCodeBlock = CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
       valueCodeBlock = moduleCodeBlock;
@@ -477,10 +491,7 @@ private CodeBlock getInvocationCodeBlock(
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
             ? valueCodeBlock
             : CodeBlocks.format(
-                "$T.<$T>immediateFuture($L)",
-                FUTURES,
-                providedTypeName,
-                valueCodeBlock);
+                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
     return CodeBlocks.format(
         Joiner.on('\n')
             .join(
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 4ef4f8100..f9ea63cfb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -574,6 +574,86 @@ public void publicModuleNonPublicIncludes() {
         .generatesSources(factoryFile);
   }
 
+  @Test
+  public void singleProducesMethodNoArgsFutureWithProducerName() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces ListenableFuture<String> produceString() {",
+            "    return Futures.immediateFuture(\"\");",
+            "  }",
+            "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerMonitor;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "  private final TestModule module;",
+            "  private final Provider<Executor> executorProvider;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(\"test.TestModule#produceString\"));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute(",
+            "      final ProducerMonitor monitor) {",
+            "    return Futures.transformAsync(",
+            "      Futures.<Void>immediateFuture(null),",
+            "      new AsyncFunction<Void, String>() {",
+            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "          monitor.methodStarting();",
+            "          try {",
+            "            return TestModule_ProduceStringFactory.this.module.produceString();",
+            "          } finally {",
+            "            monitor.methodFinished();",
+            "          }",
+            "        }",
+            "      }, executorProvider.get());",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .withCompilerOptions("-Adagger.writeProducerNameInToken=ENABLED")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(factoryFile);
+  }
+
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
           "package test;",
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
index eee6d077f..311d951a9 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -16,15 +16,19 @@
 package dagger.producers.monitoring;
 
 import dagger.producers.Produces;
+import java.util.Objects;
+import javax.annotation.Nullable;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /** A token that represents an individual {@linkplain Produces producer method}. */
 public final class ProducerToken {
-  private final Class<?> classToken;
+  @Nullable private final Class<?> classToken;
+  @Nullable private final String methodName;
 
-  private ProducerToken(Class<?> classToken) {
+  private ProducerToken(@Nullable Class<?> classToken, @Nullable String methodName) {
     this.classToken = classToken;
+    this.methodName = methodName;
   }
 
   /**
@@ -34,7 +38,17 @@ private ProducerToken(Class<?> classToken) {
    * signature may change at any time.
    */
   public static ProducerToken create(Class<?> classToken) {
-    return new ProducerToken(checkNotNull(classToken));
+    return new ProducerToken(checkNotNull(classToken), null);
+  }
+
+  /**
+   * Creates a token for a producer method.
+   *
+   * <p><b>Do not use this!</b> This is intended to be called by generated code only, and its
+   * signature may change at any time.
+   */
+  public static ProducerToken create(String methodName) {
+    return new ProducerToken(null, checkNotNull(methodName));
   }
 
   /** Two tokens are equal if they represent the same method. */
@@ -44,7 +58,8 @@ public boolean equals(Object o) {
       return true;
     } else if (o instanceof ProducerToken) {
       ProducerToken that = (ProducerToken) o;
-      return this.classToken.equals(that.classToken);
+      return Objects.equals(this.classToken, that.classToken)
+          && Objects.equals(this.methodName, that.methodName);
     } else {
       return false;
     }
@@ -53,12 +68,23 @@ public boolean equals(Object o) {
   /** Returns an appropriate hash code to match {@link #equals(Object)}. */
   @Override
   public int hashCode() {
-    return classToken.hashCode();
+    int h = 1;
+    h *= 1000003;
+    h ^= Objects.hashCode(this.classToken);
+    h *= 1000003;
+    h ^= Objects.hashCode(this.methodName);
+    return h;
   }
 
   /** Returns a representation of the method. */
   @Override
   public String toString() {
-    return classToken.toString();
+    if (methodName != null) {
+      return methodName;
+    } else if (classToken != null) {
+      return classToken.toString();
+    } else {
+      throw new IllegalStateException();
+    }
   }
 }
