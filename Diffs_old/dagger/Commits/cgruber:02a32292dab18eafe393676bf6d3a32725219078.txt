diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index bd9865fd2..f7b67d6fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index b985f7fb1..b551c51be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index cd7c5247f..3fbea2496 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 09c07a393..8aafacd97 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4148cb0b5..e52e337e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
deleted file mode 100644
index 396be1849..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import java.util.Iterator;
-import java.util.List;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleElementVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.EXECUTABLE;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-import static javax.lang.model.type.TypeKind.WILDCARD;
-
-/**
- * Utilities related to {@link TypeMirror} instances.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class MoreTypes {
-  private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
-    @Override
-    protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
-      return MoreTypes.equal(a, b);
-    }
-
-    @Override
-    protected int doHash(TypeMirror t) {
-      return MoreTypes.hash(t);
-    }
-  };
-
-  static Equivalence<TypeMirror> equivalence() {
-    return TYPE_EQUIVALENCE;
-  }
-
-  private static final TypeVisitor<Boolean, TypeMirror> EQUAL_VISITOR =
-      new SimpleTypeVisitor6<Boolean, TypeMirror>() {
-        @Override
-        protected Boolean defaultAction(TypeMirror a, TypeMirror b) {
-          return a.getKind().equals(b.getKind());
-        }
-
-        @Override
-        public Boolean visitArray(ArrayType a, TypeMirror m) {
-          if (m.getKind().equals(ARRAY)) {
-            ArrayType b = (ArrayType) m;
-            return equal(a.getComponentType(), b.getComponentType());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType a, TypeMirror m) {
-          if (m.getKind().equals(DECLARED)) {
-            DeclaredType b = (DeclaredType) m;
-            return a.asElement().equals(b.asElement())
-                && equal(a.getEnclosingType(), a.getEnclosingType())
-                && equalLists(a.getTypeArguments(), b.getTypeArguments());
-
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitError(ErrorType a, TypeMirror m) {
-          return a.equals(m);
-        }
-
-        @Override
-        public Boolean visitExecutable(ExecutableType a, TypeMirror m) {
-          if (m.getKind().equals(EXECUTABLE)) {
-            ExecutableType b = (ExecutableType) m;
-            return equalLists(a.getParameterTypes(), b.getParameterTypes())
-                && equal(a.getReturnType(), b.getReturnType())
-                && equalLists(a.getThrownTypes(), b.getThrownTypes())
-                && equalLists(a.getTypeVariables(), b.getTypeVariables());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitTypeVariable(TypeVariable a, TypeMirror m) {
-          if (m.getKind().equals(TYPEVAR)) {
-            TypeVariable b = (TypeVariable) m;
-            return equal(a.getUpperBound(), b.getUpperBound())
-                && equal(a.getLowerBound(), b.getLowerBound());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitWildcard(WildcardType a, TypeMirror m) {
-          if (m.getKind().equals(WILDCARD)) {
-            WildcardType b = (WildcardType) m;
-            return equal(a.getExtendsBound(), b.getExtendsBound())
-                && equal(a.getSuperBound(), b.getSuperBound());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitUnknown(TypeMirror a, TypeMirror p) {
-          throw new UnsupportedOperationException();
-        }
-      };
-
-  static boolean equal(TypeMirror a, TypeMirror b) {
-    return (a == b) || (a != null && b != null && a.accept(EQUAL_VISITOR, b));
-  }
-
-  private static boolean equalLists(List<? extends TypeMirror> a, List<? extends TypeMirror> b) {
-    int size = a.size();
-    if (size != b.size()) {
-      return false;
-    }
-    // Use iterators in case the Lists aren't RandomAccess
-    Iterator<? extends TypeMirror> aIterator = a.iterator();
-    Iterator<? extends TypeMirror> bIterator = b.iterator();
-    while (aIterator.hasNext()) {
-      if (!bIterator.hasNext()) {
-        return false;
-      }
-      TypeMirror nextMirrorA = aIterator.next();
-      TypeMirror nextMirrorB = bIterator.next();
-      if (!equal(nextMirrorA, nextMirrorB)) {
-        return false;
-      }
-    }
-    return !aIterator.hasNext();
-  }
-
-  private static final int HASH_SEED = 17;
-  private static final int HASH_MULTIPLIER = 31;
-
-  private static final TypeVisitor<Integer, Void> HASH_VISITOR =
-      new SimpleTypeVisitor6<Integer, Void>() {
-          int hashKind(int seed, TypeMirror t) {
-            int result = seed * HASH_MULTIPLIER;
-            result += t.getKind().hashCode();
-            return result;
-          }
-
-          @Override
-          protected Integer defaultAction(TypeMirror e, Void p) {
-            return hashKind(HASH_SEED, e);
-          }
-
-          @Override
-          public Integer visitArray(ArrayType t, Void v) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.getComponentType().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitDeclared(DeclaredType t, Void v) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.asElement().hashCode();
-            result *= HASH_MULTIPLIER;
-            result += t.getEnclosingType().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getTypeArguments());
-            return result;
-          }
-
-          @Override
-          public Integer visitExecutable(ExecutableType t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getParameterTypes());
-            result *= HASH_MULTIPLIER;
-            result += t.getReturnType().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getThrownTypes());
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getTypeVariables());
-            return result;
-          }
-
-          @Override
-          public Integer visitTypeVariable(TypeVariable t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.getLowerBound().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += t.getUpperBound().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitWildcard(WildcardType t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += (t.getExtendsBound() == null) ? 0 : t.getExtendsBound().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += (t.getSuperBound() == null) ? 0 : t.getSuperBound().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitUnknown(TypeMirror t, Void p) {
-            throw new UnsupportedOperationException();
-          }
-      };
-
-  static int hashList(List<? extends TypeMirror> mirrors) {
-    int result = HASH_SEED;
-    for (TypeMirror mirror : mirrors) {
-      result *= HASH_MULTIPLIER;
-      result += hash(mirror);
-    }
-    return result;
-  }
-
-  static int hash(TypeMirror mirror) {
-    return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
-  }
-
-  /**
-   * Returns the set of {@linkplain TypeElement types} that are referenced by the given
-   * {@link TypeMirror}.
-   */
-  static ImmutableSet<TypeElement> referencedTypes(TypeMirror type) {
-    checkNotNull(type);
-    ImmutableSet.Builder<TypeElement> elements = ImmutableSet.builder();
-    type.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<TypeElement>>() {
-      @Override
-      public Void visitArray(ArrayType t, Builder<TypeElement> p) {
-        t.getComponentType().accept(this, p);
-        return null;
-      }
-
-      @Override
-      public Void visitDeclared(DeclaredType t, Builder<TypeElement> p) {
-        p.add(MoreElements.asType(t.asElement()));
-        for (TypeMirror typeArgument : t.getTypeArguments()) {
-          typeArgument.accept(this, p);
-        }
-        return null;
-      }
-
-      @Override
-      public Void visitTypeVariable(TypeVariable t, Builder<TypeElement> p) {
-        t.getLowerBound().accept(this, p);
-        t.getUpperBound().accept(this, p);
-        return null;
-      }
-
-      @Override
-      public Void visitWildcard(WildcardType t, Builder<TypeElement> p) {
-        TypeMirror extendsBound = t.getExtendsBound();
-        if (extendsBound != null) {
-          extendsBound.accept(this, p);
-        }
-        TypeMirror superBound = t.getSuperBound();
-        if (superBound != null) {
-          superBound.accept(this, p);
-        }
-        return null;
-      }
-    }, elements);
-    return elements.build();
-  }
-
-  static TypeElement asTypeElement(Types types, TypeMirror mirror) {
-    checkNotNull(types);
-    checkNotNull(mirror);
-    Element element = types.asElement(mirror);
-    checkArgument(element != null);
-    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override
-      protected TypeElement defaultAction(Element e, Void p) {
-        throw new IllegalArgumentException();
-      }
-
-      @Override public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-    }, null);
-  }
-
-  static ImmutableSet<TypeElement> asTypeElements(Types types,
-      Iterable<? extends TypeMirror> mirrors) {
-    checkNotNull(types);
-    checkNotNull(mirrors);
-    ImmutableSet.Builder<TypeElement> builder = ImmutableSet.builder();
-    for (TypeMirror mirror : mirrors) {
-      builder.add(asTypeElement(types, mirror));
-    }
-    return builder.build();
-  }
-
-  private MoreTypes() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index e91408159..1863d7b57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 2bd53bbd2..9a69fb51c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
diff --git a/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
deleted file mode 100644
index 9eeeac329..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.testing.EquivalenceTester;
-import com.google.testing.compile.CompilationRule;
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static javax.lang.model.type.TypeKind.NONE;
-import static javax.lang.model.type.TypeKind.VOID;
-import static org.truth0.Truth.ASSERT;
-
-@RunWith(JUnit4.class)
-public class MoreTypesTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  @Test
-  public void equivalence() {
-    Types types = compilationRule.getTypes();
-    Elements elements = compilationRule.getElements();
-    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement mapElement = elements.getTypeElement(Map.class.getCanonicalName());
-    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
-    DeclaredType mapOfObjectToObjectType =
-        types.getDeclaredType(mapElement, objectType, objectType);
-    TypeMirror mapType = mapElement.asType();
-    WildcardType wildcard = types.getWildcardType(null, null);
-    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(MoreTypes.equivalence())
-        .addEquivalenceGroup(types.getNullType())
-        .addEquivalenceGroup(types.getNoType(NONE))
-        .addEquivalenceGroup(types.getNoType(VOID))
-        .addEquivalenceGroup(objectType)
-        .addEquivalenceGroup(stringType)
-        // Map<K, V>
-        .addEquivalenceGroup(mapType)
-        .addEquivalenceGroup(mapOfObjectToObjectType)
-        // Map<?, ?>
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, wildcard, wildcard))
-        // Map
-        .addEquivalenceGroup(types.erasure(mapType), types.erasure(mapOfObjectToObjectType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, objectType, stringType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, objectType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, stringType))
-        .addEquivalenceGroup(wildcard)
-        // ? extends Object
-        .addEquivalenceGroup(types.getWildcardType(objectType, null))
-        // ? extends String
-        .addEquivalenceGroup(types.getWildcardType(stringType, null))
-        // ? super String
-        .addEquivalenceGroup(types.getWildcardType(null, stringType))
-        // Map<String, Map<String, Set<Object>>>
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType,
-            types.getDeclaredType(mapElement, stringType,
-                types.getDeclaredType(setElement, objectType))))
-        .addEquivalenceGroup(FAKE_ERROR_TYPE)
-        ;
-
-    for (TypeKind kind : TypeKind.values()) {
-      if (kind.isPrimitive()) {
-        PrimitiveType primitiveType = types.getPrimitiveType(kind);
-        TypeMirror boxedPrimitiveType = types.boxedClass(primitiveType).asType();
-        tester.addEquivalenceGroup(primitiveType, types.unboxedType(boxedPrimitiveType));
-        tester.addEquivalenceGroup(boxedPrimitiveType);
-        tester.addEquivalenceGroup(types.getArrayType(primitiveType));
-        tester.addEquivalenceGroup(types.getArrayType(boxedPrimitiveType));
-      }
-    }
-
-    ImmutableSet<Class<?>> testClasses = ImmutableSet.of(
-        ExecutableElementsGroupA.class,
-        ExecutableElementsGroupB.class,
-        ExecutableElementsGroupC.class,
-        ExecutableElementsGroupD.class,
-        ExecutableElementsGroupE.class);
-    for (Class<?> testClass : testClasses) {
-      ImmutableList<TypeMirror> equivalenceGroup = FluentIterable.from(
-          elements.getTypeElement(testClass.getCanonicalName()).getEnclosedElements())
-              .transform(new Function<Element, TypeMirror>() {
-                @Override public TypeMirror apply(Element input) {
-                  return input.asType();
-                }
-              })
-              .toList();
-      tester.addEquivalenceGroup(equivalenceGroup);
-    }
-
-    tester.test();
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupA {
-    ExecutableElementsGroupA() {}
-    void a() {}
-    public static void b() {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupB {
-    ExecutableElementsGroupB(String s) {}
-    void a(String s) {}
-    public static void b(String s) {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupC {
-    ExecutableElementsGroupC() throws Exception {}
-    void a() throws Exception {}
-    public static void b() throws Exception {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupD {
-    ExecutableElementsGroupD() throws RuntimeException {}
-    void a() throws RuntimeException {}
-    public static void b() throws RuntimeException {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupE {
-    <T> ExecutableElementsGroupE() {}
-    <T> void a() {}
-    public static <T> void b() {}
-  }
-
-  @Test public void testReferencedTypes() {
-    Elements elements = compilationRule.getElements();
-    TypeElement testDataElement = elements
-        .getTypeElement(ReferencedTypesTestData.class.getCanonicalName());
-    ImmutableMap<String, VariableElement> fieldIndex =
-        FluentIterable.from(ElementFilter.fieldsIn(testDataElement.getEnclosedElements()))
-            .uniqueIndex(new Function<VariableElement, String>() {
-              @Override public String apply(VariableElement input) {
-                return input.getSimpleName().toString();
-              }
-            });
-
-    TypeElement objectElement =
-        elements.getTypeElement(Object.class.getCanonicalName());
-    TypeElement stringElement =
-        elements.getTypeElement(String.class.getCanonicalName());
-    TypeElement integerElement =
-        elements.getTypeElement(Integer.class.getCanonicalName());
-    TypeElement setElement =
-        elements.getTypeElement(Set.class.getCanonicalName());
-    TypeElement mapElement =
-        elements.getTypeElement(Map.class.getCanonicalName());
-    TypeElement charSequenceElement =
-        elements.getTypeElement(CharSequence.class.getCanonicalName());
-
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f1").asType()))
-        .has().exactly(objectElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f2").asType()))
-        .has().exactly(setElement, stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f3").asType()))
-        .has().exactly(mapElement, stringElement, objectElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f4").asType()))
-        .has().exactly(integerElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f5").asType()))
-        .has().exactly(setElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f6").asType()))
-        .has().exactly(setElement, charSequenceElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f7").asType()))
-        .has().exactly(mapElement, stringElement, setElement, charSequenceElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f8").asType()))
-        .has().exactly(stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f9").asType()))
-        .has().exactly(stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f12").asType()))
-        .has().exactly(setElement, stringElement);
-  }
-
-  @SuppressWarnings("unused") // types used in compiler tests
-  private static final class ReferencedTypesTestData {
-    Object f1;
-    Set<String> f2;
-    Map<String, Object> f3;
-    Integer f4;
-    Set<?> f5;
-    Set<? extends CharSequence> f6;
-    Map<String, Set<? extends CharSequence>> f7;
-    String[] f8;
-    String[][] f9;
-    int f10;
-    int[] f11;
-    Set<? super String> f12;
-  }
-
-
-  private static final ErrorType FAKE_ERROR_TYPE = new ErrorType() {
-    @Override
-    public TypeKind getKind() {
-      return TypeKind.ERROR;
-    }
-
-    @Override
-    public <R, P> R accept(TypeVisitor<R, P> v, P p) {
-      return v.visitError(this, p);
-    }
-
-    @Override
-    public List<? extends TypeMirror> getTypeArguments() {
-      return ImmutableList.of();
-    }
-
-    @Override
-    public TypeMirror getEnclosingType() {
-      return null;
-    }
-
-    @Override
-    public Element asElement() {
-      return null;
-    }
-
-    // JDK8 Compatibility:
-
-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
-      return null;
-    }
-
-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
-      return null;
-    }
-
-    public List<? extends AnnotationMirror> getAnnotationMirrors() {
-      return null;
-    }
-  };
-}
