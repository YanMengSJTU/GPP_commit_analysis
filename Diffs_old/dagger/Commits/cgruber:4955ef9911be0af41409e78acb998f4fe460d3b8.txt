diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index ebca7072f..0476c78a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -984,7 +984,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
           if (binding.bindingKind().equals(PROVISION)
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
-            arguments.add(getComponentContributionExpression(binding.contributedBy().get()));
+            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1073,7 +1073,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
       case INJECT_MEMBERS:
         return CodeBlock.of(
             "$T.create($L)",
-            membersInjectorNameForType(binding.bindingElement()),
+            membersInjectorNameForType(binding.membersInjectedType()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
       default:
         throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 71e1361ea..e3e6e49be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -21,8 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import dagger.internal.codegen.BindingType.HasBindingType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -48,7 +46,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class Binding implements HasBindingType, HasKey, HasSourceElement {
+abstract class Binding extends BindingDeclaration implements HasBindingType {
 
   /**
    * Returns the framework class associated with this binding.
@@ -61,16 +59,6 @@
   @Override
   public abstract Key key();
 
-  /** Returns the {@link Element} instance that is responsible for declaring the binding. */
-  Element bindingElement() {
-    return sourceElement().element();
-  }
-
-  /** The type enclosing the binding {@link #bindingElement()}. */
-  TypeElement bindingTypeElement() {
-    return sourceElement().enclosingTypeElement();
-  }
-
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
new file mode 100644
index 000000000..6a2a513f4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import dagger.internal.codegen.Key.HasKey;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
+import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
+
+/** An object that declares or specifies a binding. */
+abstract class BindingDeclaration implements HasKey {
+
+  /** The {@link Element} that declares the binding. */
+  abstract Element bindingElement();
+
+  /**
+   * The {@link ExecutableElement} that declares the binding. Equivalent to
+   * {@code MoreElements.asExecutable(bindingElement())}.
+   *
+   * @throws IllegalStateException if {@link #bindingElement()} is not an executable element
+   */
+  ExecutableElement bindingElementAsExecutable() {
+    try {
+      return MoreElements.asExecutable(bindingElement());
+    } catch (IllegalArgumentException e) {
+      throw new IllegalStateException(e);
+    }
+  }
+
+  /** The type enclosing the {@link #bindingElement()}. */
+  TypeElement bindingTypeElement() {
+    return ENCLOSING_TYPE_ELEMENT.visit(bindingElement());
+  }
+
+  /**
+   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass
+   * of the class that contains {@link #bindingElement()}.
+   */
+  abstract Optional<TypeElement> contributingModule();
+
+  /**
+   * The type of {@link #contributingModule()}.
+   */
+  Optional<DeclaredType> contributingModuleType() {
+    return contributingModule().transform(AS_DECLARED_TYPE);
+  }
+
+  /**
+   * The type of {@link #bindingElement()}, considered as a member of {@link #contributingModule()}
+   * if it is present.
+   */
+  TypeMirror declaredType(Types types) {
+    return contributingModuleType().isPresent()
+        ? types.asMemberOf(contributingModuleType().get(), bindingElement())
+        : bindingElement().asType();
+  }
+
+  static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
+      new Function<BindingDeclaration, Set<TypeElement>>() {
+        @Override
+        public Set<TypeElement> apply(BindingDeclaration bindingDeclaration) {
+          return bindingDeclaration.contributingModule().asSet();
+        }
+      };
+
+  static Predicate<BindingDeclaration> bindingElementHasModifier(final Modifier modifier) {
+    return new Predicate<BindingDeclaration>() {
+      @Override
+      public boolean apply(BindingDeclaration bindingDeclaration) {
+        return bindingDeclaration.bindingElement().getModifiers().contains(modifier);
+      }
+    };
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
new file mode 100644
index 000000000..ba6f1fde7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+
+/**
+ * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
+ */
+final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String format(BindingDeclaration bindingDeclaration) {
+    switch (bindingDeclaration.bindingElement().asType().getKind()) {
+      case EXECUTABLE:
+        return methodSignatureFormatter.format(
+            bindingDeclaration.bindingElementAsExecutable(),
+            bindingDeclaration.contributingModuleType());
+      case DECLARED:
+        return stripCommonTypePrefixes(bindingDeclaration.bindingElement().asType().toString());
+      default:
+        throw new IllegalArgumentException(
+            "Formatting unsupported for element: " + bindingDeclaration.bindingElement());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index cc49cd2cd..8d91101d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -36,7 +36,6 @@
 import dagger.Subcomponent;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -124,10 +123,9 @@
         .preOrderTraversal(this)
         .transformAndConcat(RESOLVED_BINDINGS)
         .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .transform(HasSourceElement.SOURCE_ELEMENT)
-        .filter(not(SourceElement.hasModifier(STATIC)))
-        .filter(not(SourceElement.hasModifier(ABSTRACT)))
-        .transformAndConcat(SourceElement.CONTRIBUTING_CLASS)
+        .filter(not(BindingDeclaration.bindingElementHasModifier(STATIC)))
+        .filter(not(BindingDeclaration.bindingElementHasModifier(ABSTRACT)))
+        .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .toSet();
@@ -315,8 +313,9 @@ private BindingGraph create(
         ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
             ImmutableSetMultimap.builder();
         for (ContributionBinding binding : explicitBindingsSet) {
-          if (binding.key().bindingMethod().isPresent()) {
-            explicitMultibindingsBuilder.put(binding.key().withoutBindingMethod(), binding);
+          if (binding.key().bindingMethodIdentifier().isPresent()) {
+            explicitMultibindingsBuilder.put(
+                binding.key().withoutBindingMethodIdentifier(), binding);
           }
         }
         this.explicitMultibindings = explicitMultibindingsBuilder.build();
@@ -585,8 +584,9 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit multibindings whose key (minus its {@link Key#bindingMethod()})
-       * matches the {@code requestKey} from this and all ancestor resolvers.
+       * Returns the explicit multibindings whose key (minus its
+       * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
+       * ancestor resolvers.
        */
       private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 17ed72d44..4d2a74298 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -43,7 +43,6 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -111,7 +110,7 @@
   private final Types types;
   private final CompilerOptions compilerOptions;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final HasSourceElementFormatter hasSourceElementFormatter;
+  private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
@@ -122,7 +121,7 @@
       Types types,
       CompilerOptions compilerOptions,
       InjectBindingRegistry injectBindingRegistry,
-      HasSourceElementFormatter hasSourceElementFormatter,
+      BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter,
@@ -131,7 +130,7 @@
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.hasSourceElementFormatter = hasSourceElementFormatter;
+    this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
@@ -491,10 +490,10 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
           multibindingDeclarations.build());
     }
 
-    private ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType(
+    private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
         ResolvedBindings resolvedBinding) {
       ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
-      return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+      return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
           .putAll(indexByContributionType(inlined.contributionBindings()))
           .putAll(indexByContributionType(inlined.multibindingDeclarations()))
           .build();
@@ -516,7 +515,7 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
-              nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
+              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
               compilerOptions.nullableValidationKind(),
@@ -882,10 +881,9 @@ void validateComponentScope() {
             switch (contributionBinding.bindingKind()) {
               case SYNTHETIC_DELEGATE_BINDING:
               case PROVISION:
-                ExecutableElement provisionMethod =
-                    MoreElements.asExecutable(contributionBinding.bindingElement());
                 incompatiblyScopedMethodsBuilder.add(
-                    methodSignatureFormatter.format(provisionMethod));
+                    methodSignatureFormatter.format(
+                        contributionBinding.bindingElementAsExecutable()));
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
@@ -1010,7 +1008,7 @@ private void reportDuplicateBindings(DependencyPath path) {
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
           inlineSyntheticContributions(resolvedBinding).contributionBindings();
-      hasSourceElementFormatter.formatIndentedList(
+      bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
     }
@@ -1057,7 +1055,7 @@ private void reportMultipleBindingTypes(DependencyPath path) {
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ResolvedBindings resolvedBinding = path.currentBinding();
-      ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
+      ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
           declarationsByType(resolvedBinding);
       verify(
           declarationsByType.keySet().size() > 1,
@@ -1069,7 +1067,7 @@ private void reportMultipleBindingTypes(DependencyPath path) {
         builder.append(INDENT);
         builder.append(formatContributionType(type));
         builder.append(" bindings and declarations:");
-        hasSourceElementFormatter.formatIndentedList(
+        bindingDeclarationFormatter.formatIndentedList(
             builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
@@ -1080,7 +1078,7 @@ private void reportDuplicateMapKeys(
         DependencyPath path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
-      hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
@@ -1101,7 +1099,7 @@ private void reportInconsistentMapKeyAnnotations(
             .append(annotationType)
             .append(':');
 
-        hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
       reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e21aa8e53..219c68865 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -61,8 +61,8 @@ public SourceVersion getSupportedSourceVersion() {
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    HasSourceElementFormatter hasSourceElementFormatter =
-        new HasSourceElementFormatter(methodSignatureFormatter);
+    BindingDeclarationFormatter bindingDeclarationFormatter =
+        new BindingDeclarationFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
@@ -150,7 +150,7 @@ public SourceVersion getSupportedSourceVersion() {
             types,
             compilerOptions,
             injectBindingRegistry,
-            hasSourceElementFormatter,
+            bindingDeclarationFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
             keyFormatter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 2d9298e14..5ebf68472 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -36,7 +36,6 @@
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
@@ -68,16 +67,6 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  /**
-   * If this is a provision request from an {@code @Provides} or {@code @Produces} method, this will
-   * be the element that contributed it. In the case of subclassed modules, this may differ than the
-   * binding's enclosed element, as this will return the subclass whereas the enclosed element will
-   * be the superclass.
-   */
-  Optional<TypeElement> contributedBy() {
-    return sourceElement().contributedBy();
-  }
-
   /**
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index 73ec39e9d..b7dc1076e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -18,11 +18,10 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
@@ -35,7 +34,7 @@
  * The declaration for a delegate binding established by a {@link Bind} method.
  */
 @AutoValue
-abstract class DelegateDeclaration implements HasKey, HasSourceElement, HasContributionType {
+abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
   @Override
@@ -58,15 +57,18 @@ public ContributionType contributionType() {
     DelegateDeclaration create(
         ExecutableElement bindsMethod, TypeElement contributingElement) {
       checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));
-      SourceElement sourceElement = SourceElement.forElement(bindsMethod, contributingElement);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributingElement.asType()), bindsMethod));
       DependencyRequest delegateRequest =
           dependencyRequestFactory.forRequiredResolvedVariable(
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
-          keyFactory.forBindsMethod(sourceElement), sourceElement, delegateRequest);
+          keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
+          bindsMethod,
+          Optional.of(contributingElement),
+          delegateRequest);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 33890d012..3dff2bf99 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -225,7 +225,7 @@ DependencyRequest forImplicitMapBinding(
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingMethod().isPresent(),
+          multibindingContribution.key().bindingMethodIdentifier().isPresent(),
           "multibindingContribution's key must have a binding method identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
deleted file mode 100644
index 9441f7172..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-
-/**
- * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
- */
-final class HasSourceElementFormatter extends Formatter<HasSourceElement> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-
-  HasSourceElementFormatter(MethodSignatureFormatter methodSignatureFormatter) {
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override
-  public String format(HasSourceElement hasElement) {
-    SourceElement sourceElement = hasElement.sourceElement();
-    switch (sourceElement.element().asType().getKind()) {
-      case EXECUTABLE:
-        Optional<TypeElement> contributedBy = sourceElement.contributedBy();
-        return methodSignatureFormatter.format(
-            MoreElements.asExecutable(sourceElement.element()),
-            contributedBy.isPresent()
-                ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
-                : Optional.<DeclaredType>absent());
-      case DECLARED:
-        return stripCommonTypePrefixes(sourceElement.element().asType().toString());
-      default:
-        throw new IllegalArgumentException(
-            "Formatting unsupported for element: " + sourceElement.element());
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 013c7af18..45cb39d6a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -203,7 +203,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
      */
     warnIfNotAlreadyGenerated =
         warnIfNotAlreadyGenerated
-            && (!injectedConstructors(binding.bindingElement()).isEmpty()
+            && (!injectedConstructors(binding.membersInjectedType()).isEmpty()
                 ? !binding.injectionSites().isEmpty()
                 : binding.hasLocalInjectionSites());
     membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a27593174..f955b31ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -44,7 +44,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -97,15 +96,32 @@
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
   /**
-   * For multibinding contributions, this is the binding method element. Each multibound map and set
-   * is represented by a
+   * Absent except for multibinding contributions. Each multibound map and set is represented by a
    * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
    * synthetic binding} that depends on the specific contributions to that map or set. Each such
    * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound.
+   * the qualified type that is bound. For those bindings, this is the binding method element.
    */
-  abstract Optional<SourceElement> bindingMethod();
+  abstract Optional<BindingMethodIdentifier> bindingMethodIdentifier();
 
+  /** An object that uniquely identifies a multibinding contribution binding. */
+  @AutoValue
+  abstract static class BindingMethodIdentifier {
+    /**
+     * The {@link dagger.Provides} or {@link dagger.producers.Produces} method that contributes to
+     * the multibinding.
+     */
+    abstract ExecutableElement bindingMethod();
+
+    /** The installed module that contains or inherits the {@link #bindingMethod()}. */
+    abstract TypeElement contributingModule();
+
+    static BindingMethodIdentifier create(
+        ExecutableElement bindingMethod, TypeElement contributingModule) {
+      return new AutoValue_Key_BindingMethodIdentifier(bindingMethod, contributingModule);
+    }
+  }
+  
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -127,30 +143,32 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingMethod()} are equivalent to this one's, but
-   * with {@code newType} (normalized) as its {@link #type()}.
+   * A key whose {@link #qualifier()} and {@link #bindingMethodIdentifier()} are equivalent to this
+   * one's, but with {@code newType} (normalized) as its {@link #type()}.
    */
   private Key withType(Types types, TypeMirror newType) {
     return new AutoValue_Key(
         wrappedQualifier(),
         MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingMethod());
+        bindingMethodIdentifier());
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but
-   * with {@code bindingMethod} as its {@link #bindingMethod()}.
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
+   * {@code bindingDeclaration} as its {@link #bindingMethodIdentifier()}.
    */
-  private Key withBindingMethod(SourceElement bindingMethod) {
-    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(bindingMethod));
+  private Key withBindingMethodIdentifier(BindingMethodIdentifier bindingMethodIdentifier) {
+    return new AutoValue_Key(
+        wrappedQualifier(), wrappedType(), Optional.of(bindingMethodIdentifier));
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingMethod()}.
+   * absent {@link #bindingMethodIdentifier()}.
    */
-  Key withoutBindingMethod() {
-    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.<SourceElement>absent());
+  Key withoutBindingMethodIdentifier() {
+    return new AutoValue_Key(
+        wrappedQualifier(), wrappedType(), Optional.<BindingMethodIdentifier>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -205,7 +223,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
-        .add("bindingMethod", bindingMethod().orNull())
+        .add("bindingMethodIdentifier", bindingMethodIdentifier().orNull())
         .toString();
   }
 
@@ -302,20 +320,20 @@ Key forSubcomponentBuilderMethod(
       return forMethod(subcomponentBuilderMethod, returnType);
     }
 
-    Key forProvidesMethod(SourceElement sourceElement) {
-      return forProvidesOrProducesMethod(sourceElement, getProviderElement());
+    Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
+      return forProvidesOrProducesMethod(method, contributingModule, getProviderElement());
     }
 
-    Key forProducesMethod(SourceElement sourceElement) {
-      return forProvidesOrProducesMethod(sourceElement, getProducerElement());
+    Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
+      return forProvidesOrProducesMethod(method, contributingModule, getProducerElement());
     }
 
     private Key forProvidesOrProducesMethod(
-        SourceElement sourceElement, TypeElement frameworkType) {
-      checkArgument(sourceElement.element().getKind().equals(METHOD));
-      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+        ExecutableElement method, TypeElement contributingModule, TypeElement frameworkType) {
+      checkArgument(method.getKind().equals(METHOD));
       ExecutableType methodType =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
       if (frameworkType.equals(getProducerElement())
@@ -327,7 +345,8 @@ private Key forProvidesOrProducesMethod(
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethod(sourceElement);
+          : key.withBindingMethodIdentifier(
+              BindingMethodIdentifier.create(method, contributingModule));
     }
 
     /**
@@ -353,24 +372,9 @@ Key forMultibindingsMethod(
     }
 
     /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(SourceElement bindsMethodElement) {
-      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
-      checkArgument(isAnnotationPresent(method, Binds.class));
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      return forMethod(method, returnType);
-    }
-
-    /** Returns the key for the single parameter of a {@link Binds} method. */
-    Key forBindParameter(SourceElement bindsMethodElement) {
-      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
-      VariableElement parameterElement = Iterables.getOnlyElement(method.getParameters());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
+    Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
       checkArgument(isAnnotationPresent(method, Binds.class));
-      TypeMirror parameterType = Iterables.getOnlyElement(methodType.getParameterTypes());
-      return forQualifiedType(getQualifier(parameterElement), parameterType);
+      return forMethod(method, normalize(types, methodType.getReturnType()));
     }
 
     private TypeMirror providesOrProducesKeyType(
@@ -414,35 +418,35 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forProductionExecutor() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index a670c1bae..d329627a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -15,10 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-
 /**
  * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
  *
@@ -27,26 +23,24 @@
  */
 final class KeyFormatter extends Formatter<Key> {
   
-  private final MethodSignatureFormatter methodSignatureFormatter;
+  final MethodSignatureFormatter methodSignatureFormatter;
 
   KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override public String format(Key request) {
-    if (request.bindingMethod().isPresent()) {
+  @Override
+  public String format(Key key) {
+    if (key.bindingMethodIdentifier().isPresent()) {
       // If there's a binding method, its signature is enough.
-      SourceElement bindingMethod = request.bindingMethod().get();
-      return methodSignatureFormatter.format(
-          MoreElements.asExecutable(bindingMethod.element()),
-          Optional.of(MoreTypes.asDeclared(bindingMethod.contributedBy().get().asType())));
+      return methodSignatureFormatter.format(key.bindingMethodIdentifier().get());
     }
     StringBuilder builder = new StringBuilder();
-    if (request.qualifier().isPresent()) {
-      builder.append(request.qualifier().get());
+    if (key.qualifier().isPresent()) {
+      builder.append(key.qualifier().get());
       builder.append(' ');
     }
-    builder.append(request.type());
+    builder.append(key.type());
     return builder.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 0a8b80b84..3ca4f0cde 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -64,9 +64,8 @@
   @Override
   abstract Optional<MembersInjectionBinding> unresolved();
 
-  @Override
-  TypeElement bindingElement() {
-    return MoreElements.asType(super.bindingElement());
+  TypeElement membersInjectedType() {
+    return MoreElements.asType(bindingElement());
   }
 
   @Override
@@ -106,7 +105,7 @@ boolean hasLocalInjectionSites() {
             new Predicate<InjectionSite>() {
               @Override
               public boolean apply(InjectionSite injectionSite) {
-                return injectionSite.element().getEnclosingElement().equals(bindingElement());
+                return injectionSite.element().getEnclosingElement().equals(membersInjectedType());
               }
             });
   }
@@ -221,7 +220,8 @@ public Key apply(DeclaredType superclass) {
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
-          SourceElement.forElement(typeElement),
+          typeElement,
+          Optional.<TypeElement>absent(),
           key,
           dependencies,
           findBindingPackage(key),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1e70eeddb..1310365c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -81,12 +81,12 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return membersInjectorNameForType(binding.bindingElement());
+    return membersInjectorNameForType(binding.membersInjectedType());
   }
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return Optional.of(binding.membersInjectedType());
   }
 
   @Override
@@ -193,7 +193,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
               ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
               : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
-          && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
+          && injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())
           && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
         injectMethodsForSubclasses.add(
             injectorMethodForSubclasses(
@@ -224,7 +224,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   // enclosed in a package-private element?
   private static boolean visibleToMembersInjector(
       MembersInjectionBinding binding, Element element) {
-    return getPackage(element).equals(getPackage(binding.bindingElement()))
+    return getPackage(element).equals(getPackage(binding.membersInjectedType()))
         || element.getModifiers().contains(PUBLIC);
   }
 
@@ -238,7 +238,7 @@ private CodeBlock directInjectMemberCodeBlock(
     return CodeBlock.of(
         injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
         getInstanceCodeBlockWithPotentialCast(
-            injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+            injectionSite.element().getEnclosingElement(), binding.membersInjectedType()),
         injectionSite.element().getSimpleName(),
         makeParametersCodeBlock(
             parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 896458650..fa2e55555 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -17,8 +17,8 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import java.util.Iterator;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
@@ -94,18 +94,10 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
-  public String format(SourceElement sourceElement) {
+  String format(BindingMethodIdentifier bindingMethodIdentifier) {
     return format(
-        MoreElements.asExecutable(sourceElement.element()),
-        sourceElement
-            .contributedBy()
-            .transform(
-                new Function<TypeElement, DeclaredType>() {
-                  @Override
-                  public DeclaredType apply(TypeElement contributingModule) {
-                    return MoreTypes.asDeclared(contributingModule.asType());
-                  }
-                }));
+        MoreElements.asExecutable(bindingMethodIdentifier.bindingMethod()),
+        Optional.of(MoreTypes.asDeclared(bindingMethodIdentifier.contributingModule().asType())));
   }
 
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index e708e35e9..c682d6497 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -17,13 +17,12 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
@@ -48,15 +47,8 @@
  * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
  */
 @AutoValue
-abstract class MultibindingDeclaration
-    implements HasBindingType, HasKey, HasSourceElement, HasContributionType {
-
-  /**
-   * The method in a {@link Multibindings @Multibindings} interface that declares that this map or
-   * set is available to be injected.
-   */
-  @Override
-  public abstract SourceElement sourceElement();
+abstract class MultibindingDeclaration extends BindingDeclaration
+    implements HasBindingType, HasContributionType {
 
   /**
    * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
@@ -141,7 +133,8 @@ private MultibindingDeclaration forDeclaredMethod(
           "%s must return a set or map",
           method);
       return new AutoValue_MultibindingDeclaration(
-          SourceElement.forElement(method, interfaceElement),
+          method,
+          Optional.of(interfaceElement),
           keyFactory.forMultibindingsMethod(bindingType, methodType, method),
           contributionType(returnType),
           bindingType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index c79f9c641..268bfafab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -90,10 +90,10 @@ public BindingType bindingType() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
-      Key key = keyFactory.forProducesMethod(sourceElement);
+      Key key = keyFactory.forProducesMethod(producesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), producesMethod));
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
               producesMethod.getParameters(),
@@ -107,7 +107,8 @@ ProductionBinding forProducesMethod(
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
           ContributionType.fromBindingMethod(producesMethod),
-          sourceElement,
+          producesMethod,
+          Optional.of(contributedBy),
           key,
           dependencies,
           findBindingPackage(key),
@@ -137,7 +138,8 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(requestForMapOfProducers.requestElement()),
+          requestForMapOfProducers.requestElement(),
+          Optional.<TypeElement>absent(),
           requestForMapOfValuesOrProduced.key(),
           ImmutableSet.of(requestForMapOfProducers),
           findBindingPackage(requestForMapOfValuesOrProduced.key()),
@@ -159,7 +161,8 @@ ProductionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(request.requestElement()),
+          request.requestElement(),
+          Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
           findBindingPackage(request.key()),
@@ -178,7 +181,8 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentMethod),
+          componentMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -194,7 +198,8 @@ ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return new AutoValue_ProductionBinding(
           delegateBinding.contributionType(),
-          delegateDeclaration.sourceElement(),
+          delegateDeclaration.bindingElement(),
+          delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           findBindingPackage(delegateDeclaration.key()),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index dc0bd8417..13e8ba9ab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -117,7 +117,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
 
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(constructorElement),
+          constructorElement,
+          Optional.<TypeElement>absent(),
           key,
           dependencies,
           findBindingPackage(key),
@@ -151,10 +152,10 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Key key = keyFactory.forProvidesMethod(sourceElement);
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
+      Key key = keyFactory.forProvidesMethod(providesMethod, contributedBy);
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
               providesMethod.getParameters(),
@@ -162,7 +163,8 @@ ProvisionBinding forProvidesMethod(
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           ContributionType.fromBindingMethod(providesMethod),
-          sourceElement,
+          providesMethod,
+          Optional.of(contributedBy),
           key,
           dependencies,
           findBindingPackage(key),
@@ -189,7 +191,8 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
               requestForMapOfValues, mapOfProvidersKey.get());
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(requestForMapOfProviders.requestElement()),
+          requestForMapOfProviders.requestElement(),
+          Optional.<TypeElement>absent(),
           requestForMapOfValues.key(),
           ImmutableSet.of(requestForMapOfProviders),
           findBindingPackage(requestForMapOfValues.key()),
@@ -210,7 +213,8 @@ ProvisionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(request.requestElement()),
+          request.requestElement(),
+          Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
           findBindingPackage(request.key()),
@@ -225,7 +229,8 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentDefinitionType),
+          componentDefinitionType,
+          Optional.<TypeElement>absent(),
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -243,7 +248,8 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentMethod),
+          componentMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -262,7 +268,8 @@ ProvisionBinding forSubcomponentBuilderMethod(
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
+          subcomponentBuilderMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -277,7 +284,8 @@ ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
           delegate.contributionType(),
-          delegateDeclaration.sourceElement(),
+          delegateDeclaration.bindingElement(),
+          delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           findBindingPackage(delegateDeclaration.key()),
@@ -285,7 +293,7 @@ ProvisionBinding delegate(
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.sourceElement().element()));
+          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 14949b47d..f0e0d4155 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -28,7 +28,6 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkArgument;
@@ -298,9 +297,9 @@ public ContributionType contributionType() {
    * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
    * {@link ContributionType}.
    */
-  ImmutableListMultimap<ContributionType, HasSourceElement>
+  ImmutableListMultimap<ContributionType, BindingDeclaration>
       bindingsAndDeclarationsByContributionType() {
-    return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+    return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
         .putAll(indexByContributionType(contributionBindings()))
         .putAll(indexByContributionType(multibindingDeclarations()))
         .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
deleted file mode 100644
index b03072a08..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import java.util.Set;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleElementVisitor6;
-import javax.lang.model.util.Types;
-
-/**
- * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
- */
-@AutoValue
-abstract class SourceElement {
-
-  /** An object that has a {@link SourceElement}. */
-  interface HasSourceElement {
-    /** The source element associated with this object. */
-    SourceElement sourceElement();
-
-    Function<SourceElement.HasSourceElement, SourceElement> SOURCE_ELEMENT =
-        new Function<SourceElement.HasSourceElement, SourceElement>() {
-          @Override
-          public SourceElement apply(SourceElement.HasSourceElement hasSourceElement) {
-            return hasSourceElement.sourceElement();
-          }
-        };
-  }
-
-  /** The {@link Element} instance.. */
-  abstract Element element();
-
-  /**
-   * The concrete class that contributed the {@link #element()}, if different from
-   * {@link #enclosingTypeElement()}.
-   */
-  abstract Optional<TypeElement> contributedBy();
-
-  /** The type enclosing the {@link #element()}. */
-  TypeElement enclosingTypeElement() {
-    return BINDING_TYPE_ELEMENT.visit(element());
-  }
-
-  /**
-   * The type of {@link #element()}, considered as a member of {@link #contributedBy()} if it is
-   * present.
-   */
-  TypeMirror asMemberOfContributingType(Types types) {
-    return contributedBy().isPresent()
-        ? types.asMemberOf(MoreTypes.asDeclared(contributedBy().get().asType()), element())
-        : element().asType();
-  }
-
-  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
-  static SourceElement forElement(Element element) {
-    return new AutoValue_SourceElement(element, Optional.<TypeElement>absent());
-  }
-
-  static SourceElement forElement(Element element, TypeElement contributedBy) {
-    return new AutoValue_SourceElement(element, Optional.of(contributedBy));
-  }
-
-  static final Function<SourceElement, Set<TypeElement>> CONTRIBUTING_CLASS =
-      new Function<SourceElement, Set<TypeElement>>() {
-        @Override
-        public Set<TypeElement> apply(SourceElement sourceElement) {
-          return sourceElement.contributedBy().asSet();
-        }
-      };
-      
-  static Predicate<SourceElement> hasModifier(final Modifier modifier) {
-    return new Predicate<SourceElement>() {
-      @Override
-      public boolean apply(SourceElement sourceElement) {
-        return sourceElement.element().getModifiers().contains(modifier);
-      }
-    };
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 2d9e2fb8c..c31376055 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -29,7 +29,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Iterator;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
@@ -168,7 +167,8 @@ static ClassName generatedClassNameForBinding(Binding binding) {
         }
 
       case MEMBERS_INJECTION:
-        return membersInjectorNameForType(binding.bindingTypeElement());
+        return membersInjectorNameForType(
+            ((MembersInjectionBinding) binding).membersInjectedType());
 
       default:
         throw new AssertionError();
@@ -267,7 +267,7 @@ private static String factoryPrefix(ContributionBinding binding) {
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+            UPPER_CAMEL, binding.bindingElement().getSimpleName().toString());
 
       default:
         throw new IllegalArgumentException();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index e23c4eb25..606a088c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -18,6 +18,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -27,9 +28,12 @@
 import java.lang.annotation.Annotation;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
@@ -140,5 +144,31 @@ public boolean apply(AnnotationMirror input) {
     };
   }
 
+  /** A function that returns the input as a {@link DeclaredType}. */
+  static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
+      new Function<TypeElement, DeclaredType>() {
+        @Override
+        public DeclaredType apply(TypeElement typeElement) {
+          return MoreTypes.asDeclared(typeElement.asType());
+        }
+      };
+
+  /**
+   * A visitor that returns the input or the closest enclosing element that is a
+   * {@link TypeElement}.
+   */
+  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 8635fc713..3592fbb17 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,8 +23,9 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.multibindings.IntoSet;
+import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
@@ -75,7 +76,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<SourceElement>absent()));
+                Optional.<BindingMethodIdentifier>absent()));
   }
 
   static final class InjectedClass {
@@ -89,13 +90,12 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(
-            keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement)))
+    assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
         .isEqualTo(
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(stringType),
-                Optional.<SourceElement>absent()));
+                Optional.<BindingMethodIdentifier>absent()));
   }
 
   @Module
@@ -113,7 +113,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
+    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -124,8 +124,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key provisionKey =
-        keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
+    Key provisionKey = keyFactory.forProvidesMethod(providesMethod, moduleElement);
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -166,13 +165,12 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      SourceElement sourceElement = SourceElement.forElement(providesMethod, moduleElement);
-      assertThat(keyFactory.forProvidesMethod(sourceElement))
+      assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(sourceElement)));
+                  Optional.of(BindingMethodIdentifier.create(providesMethod, moduleElement))));
     }
   }
 
@@ -216,10 +214,8 @@ String provideQualifiedString() {
     TypeMirror integerType = integerMethod.getReturnType();
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
-
-    Key intKey = keyFactory.forProvidesMethod(SourceElement.forElement(intMethod, primitiveHolder));
-    Key integerKey =
-        keyFactory.forProvidesMethod(SourceElement.forElement(integerMethod, boxedPrimitiveHolder));
+    Key intKey = keyFactory.forProvidesMethod(intMethod, primitiveHolder);
+    Key integerKey = keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);
     assertThat(intKey).isEqualTo(integerKey);
   }
 
@@ -229,13 +225,12 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(
-              keyFactory.forProducesMethod(SourceElement.forElement(producesMethod, moduleElement)))
+      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType),
-                  Optional.<SourceElement>absent()));
+                  Optional.<BindingMethodIdentifier>absent()));
     }
   }
 
@@ -258,13 +253,12 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      SourceElement sourceElement = SourceElement.forElement(producesMethod, moduleElement);
-      assertThat(keyFactory.forProducesMethod(sourceElement))
+      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(sourceElement)));
+                  Optional.of(BindingMethodIdentifier.create(producesMethod, moduleElement))));
     }
   }
 
