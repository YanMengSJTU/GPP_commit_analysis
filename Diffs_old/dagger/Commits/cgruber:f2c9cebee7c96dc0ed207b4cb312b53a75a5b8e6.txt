diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 34184725a..899e9af82 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -94,6 +94,7 @@ java_library(
         "Keys.java",
         "MapKeyAccessibility.java",
         "MapType.java",
+        "ModuleAnnotation.java",
         "MoreAnnotationMirrors.java",
         "MoreAnnotationValues.java",
         "MultibindingAnnotations.java",
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 72ece3ca1..1560fcad4 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -17,9 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
@@ -27,11 +25,10 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
@@ -94,13 +91,9 @@ public String format(BindingDeclaration bindingDeclaration) {
   }
 
   private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponentDeclaration) {
-    ImmutableList<TypeMirror> moduleSubcomponents =
-        getModuleSubcomponents(subcomponentDeclaration.moduleAnnotation());
-    int index =
-        Iterables.indexOf(
-            moduleSubcomponents,
-            MoreTypes.equivalence()
-                .equivalentTo(subcomponentDeclaration.subcomponentType().asType()));
+    ImmutableList<TypeElement> moduleSubcomponents =
+        subcomponentDeclaration.moduleAnnotation().subcomponents();
+    int index = moduleSubcomponents.indexOf(subcomponentDeclaration.subcomponentType());
     StringBuilder annotationValue = new StringBuilder();
     if (moduleSubcomponents.size() != 1) {
       annotationValue.append("{");
@@ -116,7 +109,7 @@ private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponen
 
     return String.format(
         "@%s(subcomponents = %s) for %s",
-        simpleName(subcomponentDeclaration.moduleAnnotation()),
+        subcomponentDeclaration.moduleAnnotation().annotationClass().getSimpleName(),
         annotationValue,
         subcomponentDeclaration.contributingModule().get());
   }
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index c9d3cca50..8d6fed0a2 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -18,9 +18,9 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static java.util.Arrays.stream;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -49,9 +49,6 @@
           .map(ComponentKind::annotation)
           .collect(toImmutableSet());
 
-  private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
-      stream(ModuleKind.values()).map(ModuleKind::annotation).collect(toImmutableSet());
-
   private final Messager messager;
 
   @Inject
@@ -68,35 +65,37 @@
   @Override
   protected void process(
       ExecutableElement method, ImmutableSet<Class<? extends Annotation>> annotations) {
-      ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
-      if (!method.getModifiers().contains(ABSTRACT)) {
-        report.addError("@BindsInstance methods must be abstract");
-      }
-      if (method.getParameters().size() != 1) {
-        report.addError(
-            "@BindsInstance methods should have exactly one parameter for the bound type");
-      } else {
-        VariableElement parameter = getOnlyElement(method.getParameters());
-        if (FrameworkTypes.isFrameworkType(parameter.asType())) {
-          report.addError("@BindsInstance parameters may not be framework types", parameter);
-        }
-      }
-      TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
-      if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
-        report.addError(
-            String.format(
-                "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
-                simpleName(getModuleAnnotation(enclosingType).get())));
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+    if (!method.getModifiers().contains(ABSTRACT)) {
+      report.addError("@BindsInstance methods must be abstract");
+    }
+    if (method.getParameters().size() != 1) {
+      report.addError(
+          "@BindsInstance methods should have exactly one parameter for the bound type");
+    } else {
+      VariableElement parameter = getOnlyElement(method.getParameters());
+      if (FrameworkTypes.isFrameworkType(parameter.asType())) {
+        report.addError("@BindsInstance parameters may not be framework types", parameter);
       }
-      if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
-        AnnotationMirror componentAnnotation =
-            getComponentOrSubcomponentAnnotation(enclosingType).get();
-        report.addError(
-            String.format(
-                "@BindsInstance methods should not be included in @%1$ss. "
-                    + "Did you mean to put it in a @%1$s.Builder?",
-                simpleName(componentAnnotation)));
-      }
-      report.build().printMessagesTo(messager);
+    }
+    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    moduleAnnotation(enclosingType)
+        .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
+    if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
+      AnnotationMirror componentAnnotation =
+          getComponentOrSubcomponentAnnotation(enclosingType).get();
+      report.addError(
+          String.format(
+              "@BindsInstance methods should not be included in @%1$ss. "
+                  + "Did you mean to put it in a @%1$s.Builder?",
+              simpleName(componentAnnotation)));
+    }
+    report.build().printMessagesTo(messager);
+  }
+
+  private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
+    return String.format(
+        "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
+        moduleAnnotation.annotationClass().getSimpleName());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
index 8846faaaf..37d6b8e4a 100644
--- a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -21,6 +21,7 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -122,7 +123,7 @@ private static ComponentRequirement requirement(
           request.key(), request.isNullable(), method.getSimpleName().toString());
     }
 
-    return ConfigurationAnnotations.getModuleAnnotation(asTypeElement(type)).isPresent()
+    return moduleAnnotation(asTypeElement(type)).isPresent()
         ? ComponentRequirement.forModule(type)
         : ComponentRequirement.forDependency(type);
   }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 7e2b1c20c..c13eb21e1 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -26,12 +26,12 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static java.util.Comparator.comparing;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -456,7 +456,7 @@ private void validateSubcomponentCreatorMethod(
       ValidationReport.Builder<T> report, Iterable<TypeMirror> types) {
     validateTypesAreDeclared(report, types, "component dependency");
     for (TypeMirror type : types) {
-      if (getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()) {
+      if (moduleAnnotation(MoreTypes.asTypeElement(type)).isPresent()) {
         report.addError(
             String.format("%s is a module, which cannot be a component dependency", type));
       }
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index a7af3a7e3..cc25a41d3 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -19,11 +19,14 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.consumingIterable;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
 import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.ModuleAnnotation.isModuleAnnotation;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
 import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
 import static javax.lang.model.util.ElementFilter.typesIn;
@@ -37,7 +40,6 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
-import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
@@ -108,8 +110,8 @@ static boolean isSubcomponentCreator(Element element) {
         .isPresent()) {
       return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
     }
-    if (ModuleKind.forAnnotatedElement(annotatedType).isPresent()) {
-      return asAnnotationValues(getAnnotationValue(annotation, INCLUDES_ATTRIBUTE));
+    if (isModuleAnnotation(annotation)) {
+      return moduleAnnotation(annotation).includesAsAnnotationValues();
     }
     throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
   }
@@ -128,29 +130,10 @@ static boolean isSubcomponentCreator(Element element) {
     return getTypeListValue(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
-  static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
-    return getAnyAnnotation(moduleElement, Module.class, ProducerModule.class);
-  }
-
-  private static final String INCLUDES_ATTRIBUTE = "includes";
-
-  static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
-    checkNotNull(moduleAnnotation);
-    return getTypeListValue(moduleAnnotation, INCLUDES_ATTRIBUTE);
-  }
-
-  private static final String SUBCOMPONENTS_ATTRIBUTE = "subcomponents";
-
-  static ImmutableList<TypeMirror> getModuleSubcomponents(AnnotationMirror moduleAnnotation) {
-    checkNotNull(moduleAnnotation);
-    return getTypeListValue(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);
-  }
-
-  private static final String INJECTS_ATTRIBUTE = "injects";
-
+  // Dagger 1 support.
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getTypeListValue(moduleAnnotation, INJECTS_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, "injects");
   }
 
   /** Returns the first type that specifies this' nullability, or empty if none. */
@@ -178,26 +161,26 @@ static boolean isSubcomponentCreator(Element element) {
     Queue<TypeElement> moduleQueue = new ArrayDeque<>();
     Iterables.addAll(moduleQueue, seedModules);
     Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
-    for (TypeElement moduleElement = moduleQueue.poll();
-        moduleElement != null;
-        moduleElement = moduleQueue.poll()) {
-      Optional<AnnotationMirror> moduleMirror = getModuleAnnotation(moduleElement);
-      if (moduleMirror.isPresent()) {
-        ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
-        moduleDependenciesBuilder.addAll(
-            MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
-        // (note: we don't recurse on the parent class because we don't want the parent class as a
-        // root that the component depends on, and also because we want the dependencies rooted
-        // against this element, not the parent.)
-        addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
-        ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
-        moduleElements.add(moduleElement);
-        for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
-            moduleQueue.add(dependencyType);
-          }
-        }
-      }
+    for (TypeElement moduleElement : consumingIterable(moduleQueue)) {
+      moduleAnnotation(moduleElement)
+          .ifPresent(
+              moduleAnnotation -> {
+                ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder =
+                    ImmutableSet.builder();
+                moduleDependenciesBuilder.addAll(moduleAnnotation.includes());
+                // We don't recur on the parent class because we don't want the parent class as a
+                // root that the component depends on, and also because we want the dependencies
+                // rooted against this element, not the parent.
+                addIncludesFromSuperclasses(
+                    types, moduleElement, moduleDependenciesBuilder, objectType);
+                ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
+                moduleElements.add(moduleElement);
+                for (TypeElement dependencyType : moduleDependencies) {
+                  if (!moduleElements.contains(dependencyType)) {
+                    moduleQueue.add(dependencyType);
+                  }
+                }
+              });
     }
     return ImmutableSet.copyOf(moduleElements);
   }
@@ -225,11 +208,8 @@ private static void addIncludesFromSuperclasses(
     while (!types.isSameType(objectType, superclass)
         && superclass.getKind().equals(TypeKind.DECLARED)) {
       element = MoreElements.asType(types.asElement(superclass));
-      getModuleAnnotation(element)
-          .ifPresent(
-              moduleMirror -> {
-                builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror)));
-              });
+      moduleAnnotation(element)
+          .ifPresent(moduleAnnotation -> builder.addAll(moduleAnnotation.includes()));
       superclass = element.getSuperclass();
     }
   }
diff --git a/java/dagger/internal/codegen/ModuleAnnotation.java b/java/dagger/internal/codegen/ModuleAnnotation.java
new file mode 100644
index 000000000..866c66a35
--- /dev/null
+++ b/java/dagger/internal/codegen/ModuleAnnotation.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Optional;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.TypeElement;
+
+/** A {@code @Module} or {@code @ProducerModule} annotation. */
+@AutoValue
+abstract class ModuleAnnotation {
+  /** The annotation itself. */
+  // This does not use AnnotationMirrors.equivalence() because we want the actual annotation
+  // instance.
+  abstract AnnotationMirror annotation();
+
+  /** The type of the annotation. */
+  @Memoized
+  Class<?> annotationClass() {
+    try {
+      return Class.forName(
+          asTypeElement(annotation().getAnnotationType()).getQualifiedName().toString());
+    } catch (ClassNotFoundException e) {
+      AssertionError assertionError = new AssertionError();
+      assertionError.initCause(e);
+      throw assertionError;
+    }
+  }
+
+  /**
+   * The types specified in the {@code includes} attribute.
+   *
+   * @throws IllegalArgumentException if any of the values are error types
+   */
+  @Memoized
+  ImmutableList<TypeElement> includes() {
+    return includesAsAnnotationValues().stream()
+        .map(MoreAnnotationValues::asType)
+        .map(MoreTypes::asTypeElement)
+        .collect(toImmutableList());
+  }
+
+  /** The values specified in the {@code includes} attribute. */
+  @Memoized
+  ImmutableList<AnnotationValue> includesAsAnnotationValues() {
+    return asAnnotationValues(getAnnotationValue(annotation(), "includes"));
+  }
+
+  /**
+   * The types specified in the {@code subcomponents} attribute.
+   *
+   * @throws IllegalArgumentException if any of the values are error types
+   */
+  @Memoized
+  ImmutableList<TypeElement> subcomponents() {
+    return subcomponentsAsAnnotationValues().stream()
+        .map(MoreAnnotationValues::asType)
+        .map(MoreTypes::asTypeElement)
+        .collect(toImmutableList());
+  }
+
+  /** The values specified in the {@code subcomponents} attribute. */
+  @Memoized
+  ImmutableList<AnnotationValue> subcomponentsAsAnnotationValues() {
+    return asAnnotationValues(getAnnotationValue(annotation(), "subcomponents"));
+  }
+
+  /** Returns {@code true} if the argument is a {@code @Module} or {@code @ProducerModule}. */
+  static boolean isModuleAnnotation(AnnotationMirror annotation) {
+    return MODULE_ANNOTATIONS.stream()
+        .map(Class::getCanonicalName)
+        .anyMatch(asTypeElement(annotation.getAnnotationType()).getQualifiedName()::contentEquals);
+  }
+
+  private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
+      ImmutableSet.of(Module.class, ProducerModule.class);
+
+  /**
+   * Creates an object that represents a {@code @Module} or {@code @ProducerModule}.
+   *
+   * @throws IllegalArgumentException if {@link #isModuleAnnotation(AnnotationMirror)} returns
+   *     {@code false}
+   */
+  static ModuleAnnotation moduleAnnotation(AnnotationMirror annotation) {
+    checkArgument(
+        isModuleAnnotation(annotation),
+        "%s is not a Module or ProducerModule annotation",
+        annotation);
+    return new AutoValue_ModuleAnnotation(annotation);
+  }
+
+  /**
+   * Returns an object representing the {@code @Module} or {@code @ProducerModule} annotation if one
+   * annotates {@code typeElement}.
+   */
+  static Optional<ModuleAnnotation> moduleAnnotation(TypeElement typeElement) {
+    return getAnyAnnotation(typeElement, Module.class, ProducerModule.class)
+        .map(ModuleAnnotation::moduleAnnotation);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index cf59a154d..d352f863a 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -22,10 +22,9 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.transform;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
@@ -47,10 +46,8 @@
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produces;
 import java.util.LinkedHashSet;
-import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -181,11 +178,12 @@ ModuleDescriptor create(TypeElement moduleElement) {
           collectIncludedModules(includedModules, superclassElement);
         }
       }
-      Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
-      if (moduleAnnotation.isPresent()) {
-        includedModules.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleAnnotation.get())));
-        includedModules.addAll(implicitlyIncludedModules(moduleElement));
-      }
+      moduleAnnotation(moduleElement)
+          .ifPresent(
+              moduleAnnotation -> {
+                includedModules.addAll(moduleAnnotation.includes());
+                includedModules.addAll(implicitlyIncludedModules(moduleElement));
+              });
       return includedModules;
     }
 
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 1dca8596e..506d5d8ec 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -17,20 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
@@ -45,7 +42,6 @@
 import com.google.auto.common.Visibility;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
@@ -74,13 +70,11 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor8;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
@@ -245,35 +239,43 @@ private void validateReferencedSubcomponents(
       final TypeElement subject,
       ModuleKind moduleKind,
       final ValidationReport.Builder<TypeElement> builder) {
-    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotation(subject);
     // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
-    for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
-      subcomponentAttribute.accept(
-          new SimpleTypeVisitor6<Void, Void>() {
-            @Override
-            protected Void defaultAction(TypeMirror e, Void aVoid) {
-              builder.addError(e + " is not a valid subcomponent type", subject, moduleAnnotation);
-              return null;
-            }
+    ModuleAnnotation moduleAnnotation = moduleAnnotation(moduleKind.getModuleAnnotation(subject));
+    for (AnnotationValue subcomponentAttribute :
+        moduleAnnotation.subcomponentsAsAnnotationValues()) {
+      asType(subcomponentAttribute)
+          .accept(
+              new SimpleTypeVisitor8<Void, Void>() {
+                @Override
+                protected Void defaultAction(TypeMirror e, Void aVoid) {
+                  builder.addError(
+                      e + " is not a valid subcomponent type",
+                      subject,
+                      moduleAnnotation.annotation(),
+                      subcomponentAttribute);
+                  return null;
+                }
 
-            @Override
-            public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
-              TypeElement attributeType = MoreTypes.asTypeElement(declaredType);
-              if (isAnyAnnotationPresent(attributeType, SUBCOMPONENT_TYPES)) {
-                validateSubcomponentHasBuilder(attributeType, moduleAnnotation, builder);
-              } else {
-                builder.addError(
-                    isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)
-                        ? moduleSubcomponentsIncludesBuilder(attributeType)
-                        : moduleSubcomponentsIncludesNonSubcomponent(attributeType),
-                    subject,
-                    moduleAnnotation);
-              }
-
-              return null;
-            }
-          },
-          null);
+                @Override
+                public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
+                  TypeElement attributeType = MoreTypes.asTypeElement(declaredType);
+                  if (isAnyAnnotationPresent(attributeType, SUBCOMPONENT_TYPES)) {
+                    validateSubcomponentHasBuilder(
+                        attributeType, moduleAnnotation.annotation(), builder);
+                  } else {
+                    builder.addError(
+                        isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)
+                            ? moduleSubcomponentsIncludesBuilder(attributeType)
+                            : moduleSubcomponentsIncludesNonSubcomponent(attributeType),
+                        subject,
+                        moduleAnnotation.annotation(),
+                        subcomponentAttribute);
+                  }
+
+                  return null;
+                }
+              },
+              null);
     }
   }
 
@@ -507,6 +509,8 @@ private void validateModuleVisibility(
       final TypeElement moduleElement,
       ModuleKind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
+    ModuleAnnotation moduleAnnotation =
+        moduleAnnotation(getAnnotationMirror(moduleElement, moduleKind.annotation()).get());
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
       reportBuilder.addError("Modules cannot be private.", moduleElement);
@@ -523,12 +527,9 @@ private void validateModuleVisibility(
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
           ImmutableSet<Element> nonPublicModules =
-              FluentIterable.from(
-                      getModuleIncludes(
-                          getAnnotationMirror(moduleElement, moduleKind.annotation()).get()))
-                  .transform(types::asElement)
+              moduleAnnotation.includes().stream()
                   .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
-                  .toSet();
+                  .collect(toImmutableSet());
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
                 String.format(
@@ -559,31 +560,27 @@ private void validateNoScopeAnnotationsOnModuleElement(
 
   private void validateSelfCycles(
       TypeElement module, ValidationReport.Builder<TypeElement> builder) {
-    AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
-    getAnnotationValue(moduleAnnotation, "includes")
-        .accept(
-            new SimpleAnnotationValueVisitor8<Void, AnnotationValue>() {
-              @Override
-              public Void visitType(TypeMirror includedModule, AnnotationValue value) {
-                if (MoreTypes.equivalence().equivalent(module.asType(), includedModule)) {
-                  Name moduleKind =
-                      moduleAnnotation.getAnnotationType().asElement().getSimpleName();
-                  builder.addError(
-                      String.format("@%s cannot include themselves.", moduleKind),
-                      module,
-                      moduleAnnotation,
-                      value);
-                }
-                return null;
-              }
-
-              @Override
-              public Void visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-                values.stream().forEach(value -> value.accept(this, value));
-                return null;
-              }
-            },
-            null);
+    ModuleAnnotation moduleAnnotation = moduleAnnotation(module).get();
+    moduleAnnotation
+        .includesAsAnnotationValues()
+        .forEach(
+            value ->
+                value.accept(
+                    new SimpleAnnotationValueVisitor8<Void, Void>() {
+                      @Override
+                      public Void visitType(TypeMirror includedModule, Void aVoid) {
+                        if (MoreTypes.equivalence().equivalent(module.asType(), includedModule)) {
+                          String moduleKind = moduleAnnotation.annotationClass().getSimpleName();
+                          builder.addError(
+                              String.format("@%s cannot include themselves.", moduleKind),
+                              module,
+                              moduleAnnotation.annotation(),
+                              value);
+                        }
+                        return null;
+                      }
+                    },
+                    null));
   }
 
   private void validateModuleBindings(
diff --git a/java/dagger/internal/codegen/SubcomponentDeclaration.java b/java/dagger/internal/codegen/SubcomponentDeclaration.java
index ed741b063..477a8f8a2 100644
--- a/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -17,17 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
 import dagger.model.Key;
 import java.util.Optional;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -50,7 +46,8 @@
    */
   abstract TypeElement subcomponentType();
 
-  abstract AnnotationMirror moduleAnnotation();
+  /** The module annotation. */
+  abstract ModuleAnnotation moduleAnnotation();
 
   static class Factory {
     private final KeyFactory keyFactory;
@@ -62,11 +59,10 @@
 
     ImmutableSet<SubcomponentDeclaration> forModule(TypeElement module) {
       ImmutableSet.Builder<SubcomponentDeclaration> declarations = ImmutableSet.builder();
-      AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
+      ModuleAnnotation moduleAnnotation = ModuleAnnotation.moduleAnnotation(module).get();
       Element subcomponentAttribute =
-          getAnnotationElementAndValue(moduleAnnotation, "subcomponents").getKey();
-      for (TypeElement subcomponent :
-          MoreTypes.asTypeElements(getModuleSubcomponents(moduleAnnotation))) {
+          getAnnotationElementAndValue(moduleAnnotation.annotation(), "subcomponents").getKey();
+      for (TypeElement subcomponent : moduleAnnotation.subcomponents()) {
         declarations.add(
             new AutoValue_SubcomponentDeclaration(
                 Optional.of(subcomponentAttribute),
