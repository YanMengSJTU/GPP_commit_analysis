diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index f18318572..169e1f903 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -15,11 +15,13 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
 import dagger.Provides;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * The collection of error messages to be reported back to users.
@@ -217,6 +219,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT =
       "%s cannot be provided without an @Provides- or @Produces-annotated method.";
 
+  private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT =
+      "%s may only be injected in @Produces methods.";
+
+  static String provisionMayNotDependOnProducerType(TypeMirror type) {
+    return String.format(
+        PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT,
+        MoreTypes.asTypeElement(type).getSimpleName());
+  }
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
new file mode 100644
index 000000000..e565da792
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A collection of utility methods for dealing with Dagger framework types. A framework type is any
+ * type that the framework itself defines.
+ */
+final class FrameworkTypes {
+  // NOTE(beder): ListenableFuture is not considered a producer framework type because it is not
+  // defined by the framework, so we can't treat it specially in ordinary Dagger.
+  private static final ImmutableSet<Class<?>> PRODUCER_TYPES =
+      ImmutableSet.of(Produced.class, Producer.class);
+
+  /** Returns true if the type represents a producer-related framework type. */
+  static boolean isProducerType(TypeMirror type) {
+    if (!MoreTypes.isType(type)) {
+      return false;
+    }
+    for (Class<?> clazz : PRODUCER_TYPES) {
+      if (MoreTypes.isTypeOf(clazz, type)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private FrameworkTypes() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index 11cd066fc..23b2edcab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -68,6 +69,9 @@
           builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
         }
       }
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
     }
 
     TypeElement enclosingElement =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index e30678af7..96822b190 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -70,6 +71,10 @@ public InjectFieldValidator(
       }
     }
 
+    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
+      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
+    }
+
     return builder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index a716b7d81..b151ee4fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -29,6 +29,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -76,6 +77,9 @@ public InjectMethodValidator(
           builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
         }
       }
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
     }
 
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 094511611..c558ef545 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -25,6 +25,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
@@ -46,6 +47,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -118,6 +120,12 @@ private TypeElement getSetElement() {
       }
     }
 
+    for (VariableElement parameter : providesMethodElement.getParameters()) {
+      if (FrameworkTypes.isProducerType(parameter.asType())) {
+        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
+      }
+    }
+
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 3e8fde831..6f95e93aa 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -704,6 +704,102 @@
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
 
+  @Test public void injectConstructorDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(Produced<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectConstructorDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(Producer<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void injectFieldDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject Produced<String> str;",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectFieldDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject Producer<String> str;",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void injectMethodDependsOnProduced() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject void inject(Produced<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
+
+  @Test public void injectMethodDependsOnProducer() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import dagger.producers.Producer;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject void inject(Producer<String> str) {}",
+        "}");
+    assertAbout(javaSource()).that(aFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
   @Test public void injectConstructor() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 8cd99733a..ebef1ff89 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1102,4 +1102,44 @@ public void genericSubclassedModule() {
         .failsToCompile()
         .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
   }
+
+  @Test public void providerDependsOnProduced() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Producer;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(Producer<Integer> producer) {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Producer may only be injected in @Produces methods");
+  }
+
+  @Test public void providerDependsOnProducer() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Produced;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(Produced<Integer> produced) {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Produced may only be injected in @Produces methods");
+  }
 }
