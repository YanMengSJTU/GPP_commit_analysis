diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index d1edfebc0..814314114 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -76,5 +76,35 @@
   static final String INJECT_INTO_PRIVATE_CLASS =
       "Dagger does not support injection into private classes";
 
+  /*
+   * Configuration errors
+   *
+   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
+   * etc.)
+   */
+  static final String PROVIDES_METHOD_RETURN_TYPE =
+      "@Provides methods must either return a primitive, an array or a declared type.";
+
+  static final String PROVIDES_METHOD_SET_VALUES_RAW_SET =
+      "@Provides methods of type set values cannot return a raw Set";
+
+  static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
+      "@Provides methods of type set values must return a Set";
+
+  static final String PROVIDES_METHOD_MUST_RETURN_A_VALUE =
+      "@Provides methods must return a value (not void).";
+
+  static final String PROVIDES_METHOD_ABSTRACT = "@Provides methods cannot be abstract";
+
+  static final String PROVIDES_METHOD_STATIC = "@Provides methods cannot be static";
+
+  static final String PROVIDES_METHOD_PRIVATE = "@Provides methods cannot be private";
+
+  static final String PROVIDES_METHOD_TYPE_PARAMETER =
+      "@Provides methods may not have type parameters.";
+
+  static final String PROVIDES_METHOD_NOT_IN_MODULE =
+      "@Provides methods can only be present within a @Module";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
new file mode 100644
index 000000000..c2ea00fa3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+
+/**
+ * A {@link Validator} for {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectConstructorValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(constructorElement);
+    if (constructorElement.getModifiers().contains(PRIVATE)) {
+      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+    }
+
+    for (VariableElement parameter : constructorElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+        }
+      }
+    }
+
+    TypeElement enclosingElement =
+        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
+
+    if (typeModifiers.contains(PRIVATE)) {
+      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    }
+
+    if (typeModifiers.contains(ABSTRACT)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+    }
+
+    if (!enclosingElement.getTypeParameters().isEmpty()) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
+    }
+
+    if (enclosingElement.getNestingKind().isNested()
+        && !typeModifiers.contains(STATIC)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+    }
+
+    // This is computationally expensive, but probably preferable to a giant index
+    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
+        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override public boolean apply(ExecutableElement input) {
+                return input.getAnnotation(Inject.class) != null;
+              }
+            });
+
+    if (injectConstructors.size() > 1) {
+      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
+    if (scopes.size() > 1) {
+      for (AnnotationMirror scope : scopes) {
+        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
new file mode 100644
index 000000000..a2cc10f30
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A {@link Validator} for {@link Inject} fields.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectFieldValidator implements Validator<VariableElement> {
+  @Override
+  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder =
+        ValidationReport.Builder.about(fieldElement);
+    Set<Modifier> modifiers = fieldElement.getModifiers();
+    if (modifiers.contains(FINAL)) {
+      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
new file mode 100644
index 000000000..2fc0dbd18
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A {@link Validator} for {@link Inject} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectMethodValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(methodElement);
+    Set<Modifier> modifiers = methodElement.getModifiers();
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+    }
+
+    if (!methodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+    }
+
+    for (VariableElement parameter : methodElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        }
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 4edbc6c2b..0813b2d77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,35 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static javax.lang.model.SourceVersion.RELEASE_6;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.base.Function;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 
-import java.lang.annotation.Annotation;
 import java.util.Collection;
-import java.util.List;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -53,15 +32,10 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
-import javax.inject.Qualifier;
-import javax.inject.Scope;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -76,6 +50,9 @@
 @SupportedSourceVersion(RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private Messager messager;
+  private InjectConstructorValidator constructorValidator;
+  private InjectFieldValidator fieldValidator;
+  private InjectMethodValidator methodValidator;
   private ProvisionBinding.Factory provisionBindingFactory;
   private InjectConstructorFactoryGenerator factoryWriter;
   private MembersInjectionBinding.Factory membersInjectionBindingFactory;
@@ -85,6 +62,9 @@
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     this.messager = processingEnv.getMessager();
+    this.constructorValidator = new InjectConstructorValidator();
+    this.fieldValidator = new InjectFieldValidator();
+    this.methodValidator = new InjectMethodValidator();
     Filer filer = processingEnv.getFiler();
     Elements elements = processingEnv.getElementUtils();
     Types types = processingEnv.getTypeUtils();
@@ -115,7 +95,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             @Override
             public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
               ValidationReport<ExecutableElement> report =
-                  validateInjectConstructor(constructorElement);
+                  constructorValidator.validate(constructorElement);
 
               report.printMessagesTo(messager);
 
@@ -128,7 +108,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructorElement, V
 
             @Override
             public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              ValidationReport<VariableElement> report = validateInjectField(fieldElement);
+              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
               report.printMessagesTo(messager);
 
@@ -142,7 +122,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
 
             @Override
             public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report = validateInjectMethod(methodElement);
+              ValidationReport<ExecutableElement> report = methodValidator.validate(methodElement);
 
               report.printMessagesTo(messager);
 
@@ -182,136 +162,4 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
     return false;
   }
-
-  private ValidationReport<ExecutableElement> validateInjectConstructor(
-      ExecutableElement constructorElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(constructorElement);
-    if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
-    }
-
-    for (VariableElement parameter : constructorElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
-        }
-      }
-    }
-
-    TypeElement enclosingElement =
-        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
-    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
-
-    if (typeModifiers.contains(PRIVATE)) {
-      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
-    }
-
-    if (typeModifiers.contains(ABSTRACT)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
-    }
-
-    if (!enclosingElement.getTypeParameters().isEmpty()) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
-    }
-
-    if (enclosingElement.getNestingKind().isNested()
-        && !typeModifiers.contains(STATIC)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
-    }
-
-    // This is computationally expensive, but probably preferable to a giant index
-    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
-        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
-            .filter(new Predicate<ExecutableElement>() {
-              @Override public boolean apply(ExecutableElement input) {
-                return input.getAnnotation(Inject.class) != null;
-              }
-            });
-
-    if (injectConstructors.size() > 1) {
-      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
-    }
-
-    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
-    if (scopes.size() > 1) {
-      for (AnnotationMirror scope : scopes) {
-        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ValidationReport<ExecutableElement> validateInjectMethod(
-      ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(methodElement);
-    Set<Modifier> modifiers = methodElement.getModifiers();
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
-    }
-
-    if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
-    }
-
-    for (VariableElement parameter : methodElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
-        }
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ValidationReport<VariableElement> validateInjectField(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder =
-        ValidationReport.Builder.about(fieldElement);
-    Set<Modifier> modifiers = fieldElement.getModifiers();
-    if (modifiers.contains(FINAL)) {
-      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
-    }
-
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
-    return getAnnotatedAnnotations(element, Qualifier.class);
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
-    return getAnnotatedAnnotations(element, Scope.class);
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
-          }
-        })
-        .toSet();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index e0184bf7b..0237f7142 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -16,14 +16,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
 
 import java.lang.annotation.Annotation;
-import java.util.Iterator;
 import java.util.List;
 
 import javax.inject.Qualifier;
@@ -40,33 +39,50 @@
 final class InjectionAnnotations {
   static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
     checkNotNull(e);
-    return getAnnotatedAnnotation(e, Scope.class);
+    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(e);
+    switch (scopeAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(scopeAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Scope annotation");
+    }
   }
 
   static Optional<AnnotationMirror> getQualifier(Element e) {
     checkNotNull(e);
-    return getAnnotatedAnnotation(e, Qualifier.class);
+    ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
+    switch (qualifierAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Scope annotation");
+    }
+  }
+
+  static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
+    return getAnnotatedAnnotations(element, Qualifier.class);
   }
 
-  private static Optional<AnnotationMirror> getAnnotatedAnnotation(Element e,
+  static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
+    return getAnnotatedAnnotations(element, Scope.class);
+  }
+
+  private static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
       final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
-    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
+    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
+    return FluentIterable.from(annotations)
         .filter(new Predicate<AnnotationMirror>() {
-          @Override
-          public boolean apply(AnnotationMirror input) {
+          @Override public boolean apply(AnnotationMirror input) {
             return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
           }
         })
-        .iterator();
-    if (qualifiers.hasNext()) {
-      AnnotationMirror qualifier = qualifiers.next();
-      checkState(!qualifiers.hasNext(),
-          "More than one " + annotationType.getName() + " was present.");
-      return Optional.of(qualifier);
-    } else {
-      return Optional.absent();
-    }
+        .toSet();
   }
 
   private InjectionAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
new file mode 100644
index 000000000..ce03114cb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.Iterables;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A {@link Validator} for {@link Provides} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProvidesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(providesMethodElement);
+
+    Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
+    checkArgument(providesAnnotation != null);
+
+    Element enclosingElement = providesMethodElement.getEnclosingElement();
+    if (enclosingElement.getAnnotation(Module.class) == null) {
+      builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
+          providesMethodElement);
+    }
+
+    if (!providesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
+    }
+
+    Set<Modifier> modifiers = providesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PROVIDES_METHOD_PRIVATE, providesMethodElement);
+    }
+    if (modifiers.contains(STATIC)) {
+      // TODO(gak): why not?
+      builder.addItem(PROVIDES_METHOD_STATIC, providesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(PROVIDES_METHOD_ABSTRACT, providesMethodElement);
+    }
+
+    TypeMirror returnType = providesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
+    }
+
+    switch (providesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateKeyType(builder, returnType);
+        break;
+      case SET_VALUES:
+        if (!returnTypeKind.equals(DECLARED)) {
+          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+        } else {
+          DeclaredType declaredReturnType = (DeclaredType) returnType;
+          // TODO(gak): should we allow "covariant return" for set values?
+          if (!declaredReturnType.asElement().equals(getSetElement())) {
+            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
+            builder.addItem(PROVIDES_METHOD_SET_VALUES_RAW_SET, providesMethodElement);
+          } else {
+            validateKeyType(builder,
+                Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index a337fc83c..7f0d5e795 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -77,6 +77,10 @@ private Builder(T subject) {
       this.subject = subject;
     }
 
+    T getSubject() {
+      return subject;
+    }
+
     Builder<T> addItem(String message, Element element) {
       items.add(new AutoValue_ValidationReport_Item(message, element,
           Optional.<AnnotationMirror>absent()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
new file mode 100644
index 000000000..615f863c0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validator.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Validates a given subject and produces a {@link ValidationReport} containing the result.
+ *
+ * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
+ */
+interface Validator<T> {
+  ValidationReport<T> validate(T subject);
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
new file mode 100644
index 000000000..fda6afd03
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ProvidesMethodValidatorTest {
+  @Test public void validate_notInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
+  }
+
+  @Test public void validate_abstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "abstract class TestModule {",
+        "  @Provides abstract String provideString();",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
+  }
+
+  @Test public void validate_private() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides private String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
+  }
+
+  @Test public void validate_static() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides static String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_STATIC);
+  }
+
+  @Test public void validate_void() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides void provideNothing() {}",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
+  }
+
+  @Test public void validate_typeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides <T> String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
+  }
+
+  @Test public void validate_setValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void validate_setValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
+  }
+
+  @Test public void validate_setValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  private Processor validationProcessor() {
+    return new AbstractProcessor() {
+      ProvidesMethodValidator validator;
+
+      @Override
+      public synchronized void init(ProcessingEnvironment processingEnv) {
+        super.init(processingEnv);
+        this.validator = new ProvidesMethodValidator(processingEnv.getElementUtils());
+      }
+
+      @Override public Set<String> getSupportedAnnotationTypes() {
+        return ImmutableSet.of(Provides.class.getName());
+      }
+
+      @Override
+      public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        for (ExecutableElement element
+            : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(Provides.class))) {
+          validator.validate(element).printMessagesTo(processingEnv.getMessager());
+        }
+        return false;
+      }
+    };
+  }
+}
