diff --git a/java/dagger/android/AndroidInjection.java b/java/dagger/android/AndroidInjection.java
index 2a6554565..990bd9208 100644
--- a/java/dagger/android/AndroidInjection.java
+++ b/java/dagger/android/AndroidInjection.java
@@ -21,6 +21,9 @@
 import android.app.Activity;
 import android.app.Application;
 import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
 import android.util.Log;
 import dagger.internal.Beta;
 
@@ -34,8 +37,8 @@
    * found, otherwise throws an {@link IllegalArgumentException}.
    *
    * @throws RuntimeException if the {@link Application} doesn't implement {@link
-   *     HasDispatchingActivityInjector}, or if no {@code AndroidInjector.Factory<Activity, ?>} is
-   *     bound for {@code activity}.
+   *     HasDispatchingActivityInjector}, or if no {@code AndroidInjector.Factory<? extends
+   *     Activity>} is bound for {@code activity}.
    */
   public static void inject(Activity activity) {
     checkNotNull(activity, "activity");
@@ -77,8 +80,8 @@ public static void inject(Activity activity) {
    * If none of them implement {@link HasDispatchingFragmentInjector}, a {@link
    * IllegalArgumentException} is thrown.
    *
-   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
-   *     for {@code fragment}.
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<? extends Fragment>} is
+   *     bound for {@code fragment}.
    */
   public static void inject(Fragment fragment) {
     checkNotNull(fragment, "fragment");
@@ -119,5 +122,65 @@ private static HasDispatchingFragmentInjector findHasFragmentInjector(Fragment f
         String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
   }
 
+  /**
+   * Injects {@code service} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasDispatchingServiceInjector}, or if no {@code AndroidInjector.Factory<? extends Service>}
+   *     is bound for {@code service}.
+   */
+  public static void inject(Service service) {
+    checkNotNull(service, "service");
+    Application application = service.getApplication();
+    if (!(application instanceof HasDispatchingServiceInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingServiceInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<Service> serviceInjector =
+        ((HasDispatchingServiceInjector) application).serviceInjector();
+    checkNotNull(
+        serviceInjector,
+        "%s.serviceInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    serviceInjector.inject(service);
+  }
+
+  /**
+   * Injects {@code broadcastReceiver} if an associated {@link AndroidInjector.Factory}
+   * implementation can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} from {@link
+   *     Context#getApplicationContext()} doesn't implement {@link
+   *     HasDispatchingBroadcastReceiverInjector}, or if no {@code AndroidInjector.Factory<? extends
+   *     BroadcastReceiver>} is bound for {@code broadcastReceiver}.
+   */
+  public static void inject(BroadcastReceiver broadcastReceiver, Context context) {
+    checkNotNull(broadcastReceiver, "broadcastReceiver");
+    checkNotNull(context, "context");
+    Application application = (Application) context.getApplicationContext();
+    if (!(application instanceof HasDispatchingBroadcastReceiverInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingBroadcastReceiverInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector =
+        ((HasDispatchingBroadcastReceiverInjector) application).broadcastReceiverInjector();
+    checkNotNull(
+        broadcastReceiverInjector,
+        "%s.broadcastReceiverInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    broadcastReceiverInjector.inject(broadcastReceiver);
+  }
+
   private AndroidInjection() {}
 }
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 3910a0421..9fc359a6e 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -18,6 +18,8 @@
 
 import android.app.Activity;
 import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
 import dagger.Module;
 import dagger.internal.Beta;
 import dagger.multibindings.Multibinds;
@@ -39,5 +41,14 @@
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       fragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactories();
+
+  @Multibinds
+  abstract Map<
+          Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactories();
+
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BroadcastReceiverKey.java b/java/dagger/android/BroadcastReceiverKey.java
new file mode 100644
index 000000000..942577ac1
--- /dev/null
+++ b/java/dagger/android/BroadcastReceiverKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.content.BroadcastReceiver;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface BroadcastReceiverKey {
+  Class<? extends BroadcastReceiver> value();
+}
diff --git a/java/dagger/android/DaggerBroadcastReceiver.java b/java/dagger/android/DaggerBroadcastReceiver.java
new file mode 100644
index 000000000..601c5a31e
--- /dev/null
+++ b/java/dagger/android/DaggerBroadcastReceiver.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.CallSuper;
+
+/**
+ * A {@link BroadcastReceiver} that injects its members in the first call to {@link
+ * #onReceive(Context, Intent)}.
+ *
+ * <p>This class should only be used for {@link BroadcastReceiver}s that are declared in an {@code
+ * AndroidManifest.xml}. If, instead, the {@link BroadcastReceiver} is created in code, prefer
+ * constructor injection.
+ *
+ * <p>Note: this class is <em>not thread safe</em> and should not be used with multiple {@link
+ * android.os.Handler}s in calls to {@link Context#registerReceiver(BroadcastReceiver,
+ * android.content.IntentFilter, String, android.os.Handler)}. Injection is performed on each
+ * invocation to {@link #onReceive(Context, Intent)} which could result in inconsistent views of
+ * injected dependencies across threads.
+ *
+ * <p>Subclasses should override {@link #onReceive(Context, Intent)} and call {@code
+ * super.onReceive(context, intent)} immediately to ensure injection is performed immediately.
+ */
+public abstract class DaggerBroadcastReceiver extends BroadcastReceiver {
+  @CallSuper
+  @Override
+  public void onReceive(Context context, Intent intent) {
+    AndroidInjection.inject(this, context);
+  }
+}
diff --git a/java/dagger/android/DaggerIntentService.java b/java/dagger/android/DaggerIntentService.java
new file mode 100644
index 000000000..865d18948
--- /dev/null
+++ b/java/dagger/android/DaggerIntentService.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.IntentService;
+
+/** An {@link IntentService} that injects its members in {@link #onCreate()}. */
+public abstract class DaggerIntentService extends IntentService {
+  public DaggerIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/java/dagger/android/DaggerService.java b/java/dagger/android/DaggerService.java
new file mode 100644
index 000000000..8b37c1b76
--- /dev/null
+++ b/java/dagger/android/DaggerService.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+
+/** A {@link Service} that injects its members in {@link #onCreate()}. */
+public abstract class DaggerService extends Service {
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java b/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java
new file mode 100644
index 000000000..aa21d3e10
--- /dev/null
+++ b/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link BroadcastReceiver}s. */
+@Beta
+public interface HasDispatchingBroadcastReceiverInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link BroadcastReceiver}s. */
+  DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector();
+}
diff --git a/java/dagger/android/HasDispatchingServiceInjector.java b/java/dagger/android/HasDispatchingServiceInjector.java
new file mode 100644
index 000000000..b25dd77bf
--- /dev/null
+++ b/java/dagger/android/HasDispatchingServiceInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Service}s. */
+@Beta
+public interface HasDispatchingServiceInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Service}s. */
+  DispatchingAndroidInjector<Service> serviceInjector();
+}
diff --git a/java/dagger/android/ServiceKey.java b/java/dagger/android/ServiceKey.java
new file mode 100644
index 000000000..1461a98e5
--- /dev/null
+++ b/java/dagger/android/ServiceKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Service;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Service}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ServiceKey {
+  Class<? extends Service> value();
+}
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 2813ccce5..f595e3a74 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -18,6 +18,8 @@
 
 import android.app.Activity;
 import android.app.Application;
+import android.app.Service;
+import android.content.BroadcastReceiver;
 import android.support.v4.app.Fragment;
 import dagger.Binds;
 import dagger.Component;
@@ -26,17 +28,28 @@
 import dagger.Subcomponent;
 import dagger.android.ActivityKey;
 import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
 import dagger.android.DispatchingAndroidInjector;
 import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.HasDispatchingBroadcastReceiverInjector;
+import dagger.android.HasDispatchingServiceInjector;
+import dagger.android.ServiceKey;
 import dagger.android.support.AndroidSupportInjectionModule;
 import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import javax.inject.Inject;
 
 public final class AllControllersAreDirectChildrenOfApplication extends Application
-    implements HasDispatchingActivityInjector {
+    implements HasDispatchingActivityInjector,
+        HasDispatchingServiceInjector,
+        HasDispatchingBroadcastReceiverInjector {
   @Inject DispatchingAndroidInjector<Activity> activityInjector;
+  @Inject DispatchingAndroidInjector<Service> serviceInjector;
+  @Inject DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector;
 
   @Override
   public void onCreate() {
@@ -49,6 +62,16 @@ public void onCreate() {
     return activityInjector;
   }
 
+  @Override
+  public DispatchingAndroidInjector<Service> serviceInjector() {
+    return serviceInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector() {
+    return broadcastReceiverInjector;
+  }
+
   @Component(
     modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
   )
@@ -59,7 +82,10 @@ public void onCreate() {
       subcomponents = {
         ActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
-        ChildFragmentSubcomponent.class
+        ChildFragmentSubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
       }
     )
     abstract class ApplicationModule {
@@ -86,6 +112,24 @@ public void onCreate() {
       @FragmentKey(TestChildFragment.class)
       abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
           ChildFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder b);
     }
 
     @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
@@ -132,5 +176,50 @@ public void onCreate() {
       @Subcomponent.Builder
       abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
     }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
   }
 }
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 6b7c44bd4..705b9b3a6 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -18,6 +18,8 @@
 
 import android.app.Activity;
 import android.app.Application;
+import android.app.Service;
+import android.content.BroadcastReceiver;
 import android.support.v4.app.Fragment;
 import dagger.Binds;
 import dagger.Component;
@@ -26,17 +28,28 @@
 import dagger.Subcomponent;
 import dagger.android.ActivityKey;
 import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
 import dagger.android.DispatchingAndroidInjector;
 import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.HasDispatchingBroadcastReceiverInjector;
+import dagger.android.HasDispatchingServiceInjector;
+import dagger.android.ServiceKey;
 import dagger.android.support.AndroidSupportInjectionModule;
 import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import javax.inject.Inject;
 
 public final class ComponentStructureFollowsControllerStructureApplication extends Application
-    implements HasDispatchingActivityInjector {
+    implements HasDispatchingActivityInjector,
+        HasDispatchingServiceInjector,
+        HasDispatchingBroadcastReceiverInjector {
   @Inject DispatchingAndroidInjector<Activity> activityInjector;
+  @Inject DispatchingAndroidInjector<Service> serviceInjector;
+  @Inject DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector;
 
   @Override
   public void onCreate() {
@@ -50,13 +63,30 @@ public void onCreate() {
     return activityInjector;
   }
 
+  @Override
+  public DispatchingAndroidInjector<Service> serviceInjector() {
+    return serviceInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector() {
+    return broadcastReceiverInjector;
+  }
+
   @Component(
-      modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
   )
   interface ApplicationComponent {
     void inject(ComponentStructureFollowsControllerStructureApplication application);
 
-    @Module(subcomponents = ActivitySubcomponent.class)
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
+      }
+    )
     abstract class ApplicationModule {
       @Provides
       @IntoSet
@@ -69,6 +99,24 @@ public void onCreate() {
       @ActivityKey(TestActivity.class)
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder b);
     }
 
     @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
@@ -127,5 +175,50 @@ public void onCreate() {
         }
       }
     }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
   }
 }
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index cc1b0b4a7..bf3a85b73 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -18,12 +18,14 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.content.Intent;
 import android.content.res.Configuration;
 import org.robolectric.RobolectricTestRunner;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
@@ -37,6 +39,9 @@
   private TestActivity activity;
   private TestParentFragment parentFragment;
   private TestChildFragment childFragment;
+  private TestService service;
+  private TestIntentService intentService;
+  private TestBroadcastReceiver broadcastReceiver;
 
   @Before
   public void setUp() {
@@ -48,6 +53,12 @@ public void setUp() {
     childFragment =
         (TestChildFragment)
             parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+
+    service = Robolectric.buildService(TestService.class).create().get();
+    intentService = Robolectric.buildIntentService(TestIntentService.class).create().get();
+
+    broadcastReceiver = new TestBroadcastReceiver();
+    broadcastReceiver.onReceive(RuntimeEnvironment.application, new Intent());
   }
 
   @Test
@@ -78,6 +89,23 @@ public void componentStructureFollowsControllerStructure() {
             ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
                 .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
 
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
     changeConfiguration();
   }
 
@@ -100,6 +128,23 @@ public void AllControllersAreDirectChildrenOfApplication() {
             AllControllersAreDirectChildrenOfApplication.ApplicationComponent
                 .ChildFragmentSubcomponent.class);
 
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
     changeConfiguration();
   }
 
diff --git a/javatests/dagger/android/support/functional/TestBroadcastReceiver.java b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
new file mode 100644
index 000000000..edf93fef1
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.DaggerBroadcastReceiver;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestBroadcastReceiver extends DaggerBroadcastReceiver {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestIntentService.java b/javatests/dagger/android/support/functional/TestIntentService.java
new file mode 100644
index 000000000..dc301d493
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestIntentService.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import dagger.android.DaggerIntentService;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestIntentService extends DaggerIntentService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  public TestIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  protected void onHandleIntent(Intent intent) {}
+}
diff --git a/javatests/dagger/android/support/functional/TestService.java b/javatests/dagger/android/support/functional/TestService.java
new file mode 100644
index 000000000..d3c6dc1cc
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestService.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Parcel;
+import android.os.RemoteException;
+import dagger.android.DaggerService;
+import java.io.FileDescriptor;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestService extends DaggerService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public IBinder onBind(Intent intent) {
+    return new MockBinder();
+  }
+
+  private static class MockBinder implements IBinder {
+    @Override
+    public String getInterfaceDescriptor() throws RemoteException {
+      return null;
+    }
+
+    @Override
+    public boolean pingBinder() {
+      return false;
+    }
+
+    @Override
+    public boolean isBinderAlive() {
+      return false;
+    }
+
+    @Override
+    public IInterface queryLocalInterface(String descriptor) {
+      return null;
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
+      return false;
+    }
+
+    @Override
+    public void linkToDeath(DeathRecipient recipient, int flags) throws RemoteException {}
+
+    @Override
+    public boolean unlinkToDeath(DeathRecipient recipient, int flags) {
+      return false;
+    }
+  }
+}
