diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
index c57b0cab3..fcebac6fb 100644
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -32,8 +32,9 @@
 import javax.inject.Qualifier;
 
 /**
- * Classes to support {@link OptionalBindingComponentsTest} and
- * {@link test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
+ * Classes to support {@link OptionalBindingComponentsPresentTest}, {@link
+ * OptionalBindingComponentsAbsentTest} and {@link
+ * test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
  */
 public final class OptionalBindingComponents {
 
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..cd74d09e7
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() {
+    assertThat(absent.optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(absent.optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(absent.optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(absent.optionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..c10853120
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static test.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import test.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+        });
+  }
+
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedOptionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
deleted file mode 100644
index ef437cf84..000000000
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
-import static test.optional.OptionalBindingComponents.Value.VALUE;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
-import test.optional.OptionalBindingComponents.PresentOptionalBindingComponent;
-import test.optional.OptionalBindingComponents.PresentOptionalBindingSubcomponent;
-
-/** Tests for optional bindings. */
-@RunWith(JUnit4.class)
-public final class OptionalBindingComponentsTest {
-  private AbsentOptionalBindingComponent absent;
-  private PresentOptionalBindingComponent present;
-  private PresentOptionalBindingSubcomponent presentChild;
-
-  @Before
-  public void setUp() {
-    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
-    present = DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create();
-    presentChild = absent.presentChild();
-  }
-
-  @Test
-  public void absentOptional() {
-    assertThat(absent.optionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalProvider() {
-    assertThat(absent.optionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalLazy() {
-    assertThat(absent.optionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalLazyProvider() {
-    assertThat(absent.optionalLazyProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptional() {
-    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalProvider() {
-    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalLazy() {
-    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalLazyProvider() {
-    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
-  }
-
-  @Test
-  public void presentOptional() {
-    assertThat(present.optionalInstance()).hasValue(VALUE);
-  }
-
-  @Test
-  public void presentOptionalProvider() {
-    assertThat(present.optionalProvider().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentOptionalLazy() {
-    assertThat(present.optionalLazy().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentOptionalLazyProvider() {
-    assertThat(present.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptional() {
-    assertThat(present.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalProvider() {
-    assertThat(present.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalLazy() {
-    assertThat(present.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalLazyProvider() {
-    assertThat(present.qualifiedOptionalLazyProvider().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildOptional() {
-    assertThat(presentChild.optionalInstance()).hasValue(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalProvider() {
-    assertThat(presentChild.optionalProvider().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalLazy() {
-    assertThat(presentChild.optionalLazy().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalLazyProvider() {
-    assertThat(presentChild.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptional() {
-    assertThat(presentChild.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalProvider() {
-    assertThat(presentChild.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalLazy() {
-    assertThat(presentChild.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalLazyProvider() {
-    assertThat(presentChild.qualifiedOptionalLazyProvider().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index bcf80437f..a36759e8d 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -48,7 +48,12 @@ limitations under the License.
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
-
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <version>${auto.value.version}</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..60d31bb20
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Retention;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import javax.inject.Qualifier;
+
+/**
+ * Classes to support {@link OptionalBindingComponentsAbsentTest} and {@link
+ * OptionalBindingComponentsPresentTest}.
+ */
+final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Producer<Value>> optionalProducer();
+
+    abstract Optional<Produced<Value>> optionalProduced();
+  }
+
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  @Module
+  static final class ExecutorModule {
+    @Provides
+    @Production
+    static Executor executor() {
+      return Executors.newSingleThreadExecutor();
+    }
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @ProducerModule
+  abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier
+    abstract Value qualifiedValue();
+
+    @Produces
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+
+    @Produces
+    @SomeQualifier
+    static Values qualifiedValues(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+  }
+
+  /** Binds {@link Value} using {@link Producer}s. */
+  @ProducerModule
+  abstract static class ConcreteBindingProducerModule {
+    @Produces
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Produces
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Binds {@link Value} using {@link Provider}s. */
+  @Module
+  abstract static class ConcreteBindingModule {
+    @Provides
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  interface OptionalBindingComponent {
+    ListenableFuture<Values> values();
+
+    ListenableFuture<Optional<Value>> optionalInstance();
+
+    ListenableFuture<Optional<Producer<Value>>> optionalProducer();
+
+    ListenableFuture<Optional<Produced<Value>>> optionalProduced();
+
+    @SomeQualifier
+    ListenableFuture<Values> qualifiedValues();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Value>> qualifiedOptionalInstance();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Producer<Value>>> qualifiedOptionalProducer();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @ProductionComponent(
+    modules = {
+      ExecutorModule.class,
+      OptionalBindingModule.class,
+      ConcreteBindingProducerModule.class
+    }
+  )
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @ProductionSubcomponent(modules = ConcreteBindingProducerModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+
+  @ProductionComponent(
+    modules = {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}
+  )
+  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..c2d5ce530
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(absent.optionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(absent.optionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(absent.optionalProduced().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..8788e5236
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static producerstest.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static producerstest.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import producerstest.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
+        });
+  }
+  
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(component.optionalInstance().get()).hasValue(VALUE);
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(component.qualifiedOptionalProducer().get().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index e21e39325..aa0b91f63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1294,22 +1294,20 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
     return CodeBlock.of("($T) $L", classToCast, notCasted);
   }
 
-  /** Returns an expression that initializes a {@link Provider} for an optional binding. */
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
   private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.bindingType().equals(BindingType.PRODUCTION)) {
-      throw new UnsupportedOperationException("optional producers are not supported yet");
-    }
-
     if (binding.dependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
       return optionalFactories.absentOptionalProvider();
     } else {
-      TypeMirror valueType = OptionalType.from(binding.key()).valueType();
-      DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
-      FrameworkDependency frameworkDependency =
-          getOnlyElement(frameworkDependenciesForBinding(binding));
-      CodeBlock dependencyArgument =
-          getDependencyArgument(frameworkDependency).getExpressionFor(name);
-      return optionalFactories.presentOptionalProvider(valueKind, dependencyArgument);
+      return optionalFactories.presentOptionalFactory(
+          binding, getOnlyElement(getDependencyArguments(binding)));
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9b5810e39..196486780 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -23,8 +23,8 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.isEmpty;
+import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
@@ -589,20 +589,26 @@ private boolean multibindingsRequireProduction(
       /**
        * Returns a synthetic binding for {@code @Qualifier Optional<Type>} if there are any {@code
        * optionalBindingDeclarations}.
+       *
+       * <p>If there are no bindings for the underlying key (the key for dependency requests for
+       * {@code Type}), returns a provision binding that always returns {@link Optional#absent()}.
+       *
+       * <p>If there are any production bindings for the underlying key, returns a production
+       * binding. Otherwise returns a provision binding.
        */
       private Optional<? extends ContributionBinding> syntheticOptionalBinding(
           Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
         if (optionalBindingDeclarations.isEmpty()) {
           return Optional.absent();
         }
-        ContributionBinding syntheticPresentBinding =
-            provisionBindingFactory.syntheticPresentBinding(key);
-        ResolvedBindings bindings =
-            lookUpBindings(getOnlyElement(syntheticPresentBinding.dependencies()).bindingKey());
-        if (bindings.isEmpty()) {
+        ResolvedBindings underlyingKeyBindings =
+            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+        if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
-        } else { // TODO(dpb): Support producers.
-          return Optional.of(syntheticPresentBinding);
+        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
+          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));
+        } else {
+          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));
         }
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d44498a05..cf744ecff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -41,7 +41,6 @@
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -981,29 +980,12 @@ private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       } else {
         FluentIterable<ContributionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
-        if (dependentProvisions
-            .transform(ContributionBinding.KIND)
-            .contains(SYNTHETIC_OPTIONAL_BINDING)) {
-          // TODO(dpb): Implement @BindsOptionalOf for producers.
-          errorMessage
-              .append("Using optional bindings with @Produces bindings is not yet supported.\n")
-              .append(INDENT)
-              .append(formatCurrentDependencyRequestKey(path))
-              .append(" is produced at\n")
-              .append(DOUBLE_INDENT)
-              .append(
-                  bindingDeclarationFormatter.format(
-                      path.currentResolvedBindings().contributionBinding()))
-              .append('\n')
-              .append(dependencyRequestFormatter.toDependencyTrace(path));
-        } else {
-          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
-          // do that, should we display all productions that depend on them also?
-          new Formatter(errorMessage)
-              .format(
-                  PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                  dependentProvisions.iterator().next().key());
-        }
+        // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+        // do that, should we display all productions that depend on them also?
+        new Formatter(errorMessage)
+            .format(
+                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                dependentProvisions.iterator().next().key());
       }
       reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
index 50220094d..06baa23b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -21,6 +21,9 @@
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.producers.Producer;
 import javax.inject.Provider;
@@ -59,13 +62,18 @@
     return frameworkClass;
   }
 
+  /** Returns the {@link #frameworkClass()} parameterized with a type. */
+  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
+  }
+
   /** A predicate that passes for {@link HasBindingType}s with a given type. */
   static Predicate<HasBindingType> isOfType(BindingType type) {
     return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
   }
 
   /** A function that returns {@link HasBindingType#bindingType()}. */
-  static Function<HasBindingType, BindingType> BINDING_TYPE =
+  static final Function<HasBindingType, BindingType> BINDING_TYPE =
       new Function<HasBindingType, BindingType>() {
         @Override
         public BindingType apply(HasBindingType hasBindingType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index acc607f48..fea0f29cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -24,6 +24,11 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producedOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -33,6 +38,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -128,6 +134,35 @@
     KindAndType ofType(TypeMirror type) {
       return new AutoValue_DependencyRequest_KindAndType(this, type);
     }
+
+    /** Returns the type of a request of this kind for a key with a given type. */
+    TypeName typeName(TypeName keyType) {
+      switch (this) {
+        case INSTANCE:
+          return keyType;
+
+        case PROVIDER:
+          return providerOf(keyType);
+
+        case LAZY:
+          return lazyOf(keyType);
+
+        case PROVIDER_OF_LAZY:
+          return providerOf(lazyOf(keyType));
+
+        case PRODUCER:
+          return producerOf(keyType);
+
+        case PRODUCED:
+          return producedOf(keyType);
+
+        case FUTURE:
+          return listenableFutureOf(keyType);
+
+        default:
+          throw new AssertionError(this);
+      }
+    }
   }
 
   abstract Kind kind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index d9a03cbc2..fea103f09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -20,11 +20,12 @@
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
-import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.optionalOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -32,7 +33,13 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Table;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
@@ -43,13 +50,12 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.InstanceFactory;
 import dagger.internal.Preconditions;
-import java.util.EnumMap;
-import java.util.Map;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
 import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
 
-/**
- * The nested class and static methods required by the component to implement optional bindings.
- */
+/** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name classes correctly if a component uses both Guava and JDK Optional.
 final class OptionalFactories {
 
@@ -87,11 +93,15 @@
           .build();
 
   /**
-   * The factory classes that implement present optional bindings for a given kind of dependency
-   * request within the component.
+   * The factory classes that implement {@code Provider<Optional<T>>} or {@code
+   * Producer<Optional<T>>} for present optional bindings for a given kind of dependency request
+   * within the component.
+   *
+   * <p>The row key specifies whether the class implements {@link Provider} or {@link Producer}, and
+   * the column key specifies the kind of dependency request represented by {@code T}.
    */
-  private final Map<DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
-      new EnumMap<>(DependencyRequest.Kind.class);
+  private final Table<BindingType, DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
+      HashBasedTable.create();
 
   /**
    * If the component contains any absent optional bindings, this will be the member select for a
@@ -111,34 +121,42 @@ CodeBlock absentOptionalProvider() {
     }
     return absentOptionalProviderMethod.get();
   }
-
+  
   /**
    * Returns an expression for an instance of a nested class that implements {@code
-   * Provider<Optional<T>>} for a present optional binding, where {@code T} represents dependency
-   * requests of that kind.
+   * Provider<Optional<T>>} or {@code Producer<Optional<T>>} for a present optional binding, where
+   * {@code T} represents dependency requests of that kind.
    *
    * <ul>
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#INSTANCE}, the class
-   *     implements {@code Provider<Optional<T>>}.
+   *     implements {@code ProviderOrProducer<Optional<T>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER}, the class
    *     implements {@code Provider<Optional<Provider<T>>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#LAZY}, the class implements
    *     {@code Provider<Optional<Lazy<T>>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER_OF_LAZY}, the
    *     class implements {@code Provider<Optional<Provider<Lazy<T>>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCER}, the class
+   *     implements {@code Producer<Optional<Producer<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCED}, the class
+   *     implements {@code Producer<Optional<Produced<T>>>}.
    * </ul>
    *
-   * <p>Production requests are not yet supported.
-   *
-   * @param delegateProvider an expression for a {@link Provider} of the underlying type
+   * @param delegateFactory an expression for a {@link Provider} or {@link Producer} of the
+   *     underlying type
    */
-  CodeBlock presentOptionalProvider(DependencyRequest.Kind valueKind, CodeBlock delegateProvider) {
-    if (!presentFactoryClasses.containsKey(valueKind)) {
-      presentFactoryClasses.put(valueKind, createPresentFactoryClass(valueKind));
+  CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {
+    TypeMirror valueType = OptionalType.from(binding.key()).valueType();
+    DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
+    if (!presentFactoryClasses.contains(binding.bindingType(), valueKind)) {
+      presentFactoryClasses.put(
+          binding.bindingType(),
+          valueKind,
+          createPresentFactoryClass(binding.bindingType(), valueKind));
     }
-    return CodeBlock.of("$N.of($L)", presentFactoryClasses.get(valueKind), delegateProvider);
+    return CodeBlock.of(
+        "$N.of($L)", presentFactoryClasses.get(binding.bindingType(), valueKind), delegateFactory);
   }
-  
   /**
    * Adds classes and methods required by previous calls to {@link #absentOptionalProvider()} and
    * {@link #presentOptionalProvider(DependencyRequest.Kind, CodeBlock)} to the top-level {@code
@@ -153,77 +171,126 @@ void addMembers(TypeSpec.Builder component) {
     }
   }
 
-  private TypeSpec createPresentFactoryClass(DependencyRequest.Kind valueKind) {
-    String factoryClassName =
-        String.format(
-            "PresentOptional%sFactory", UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()));
-
+  private TypeSpec createPresentFactoryClass(
+      BindingType bindingType, DependencyRequest.Kind valueKind) {
     TypeVariableName typeVariable = TypeVariableName.get("T");
+    TypeName valueType = valueKind.typeName(typeVariable);
+    ParameterizedTypeName factoryType = bindingType.frameworkClassOf(optionalOf(valueType));
 
-    FieldSpec providerField =
-        FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build();
+    FieldSpec delegateField =
+        FieldSpec.builder(bindingType.frameworkClassOf(typeVariable), "delegate", PRIVATE, FINAL)
+            .build();
+    ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
 
-    ParameterSpec providerParameter =
-        ParameterSpec.builder(providerOf(typeVariable), "provider").build();
+    MethodSpec.Builder getMethodBuilder =
+        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+    switch (bindingType) {
+      case PROVISION:
+        getMethodBuilder
+            .returns(optionalOf(valueType))
+            .addCode(
+                "return $T.of($L);",
+                Optional.class,
+                FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", delegateField)));
+        break;
+
+      case PRODUCTION:
+        getMethodBuilder.returns(listenableFutureOf(optionalOf(valueType)));
+
+        switch (valueKind) {
+          case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
+          case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
+            getMethodBuilder.addCode(
+                "return $T.immediateFuture($T.of($L));",
+                Futures.class,
+                Optional.class,
+                FrameworkType.PRODUCER.to(valueKind, CodeBlock.of("$N", delegateField)));
+            break;
+
+          case INSTANCE: // return a ListenableFuture<Optional<T>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(typeVariable, CodeBlock.of("$N.get()", delegateField)));
+            break;
+
+          case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(
+                    valueType,
+                    CodeBlock.of(
+                        "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
+            break;
+
+          default:
+            throw new UnsupportedOperationException(factoryType + " objects are not supported");
+        }
+        break;
+
+      default:
+        throw new AssertionError(bindingType);
+    }
+    MethodSpec getMethod = getMethodBuilder.build();
+
+    String factoryClassName =
+        String.format(
+            "PresentOptional%s%s",
+            UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()),
+            bindingType.frameworkClass().getSimpleName());
 
-    ParameterizedTypeName optionalType = optionalType(valueKind, typeVariable);
     return classBuilder(factoryClassName)
         .addTypeVariable(typeVariable)
         .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(providerOf(optionalType))
+        .addSuperinterface(factoryType)
         .addJavadoc(
-            "A {@link $T} that returns an {@code $T} using a {@code Provider<T>}.",
-            Provider.class,
-            optionalType)
-        .addField(providerField)
+            "A {@link $T} that uses a delegate {@code $T}.", factoryType, delegateField.type)
+        .addField(delegateField)
         .addMethod(
             constructorBuilder()
                 .addModifiers(PRIVATE)
-                .addParameter(providerParameter)
+                .addParameter(delegateParameter)
                 .addCode(
                     "this.$N = $T.checkNotNull($N);",
-                    FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build(),
+                    delegateField,
                     Preconditions.class,
-                    providerParameter)
-                .build())
-        .addMethod(
-            methodBuilder("get")
-                .addAnnotation(Override.class)
-                .addModifiers(PUBLIC)
-                .returns(optionalType)
-                .addCode(
-                    "return $T.of($L);",
-                    Optional.class,
-                    FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", providerField)))
+                    delegateParameter)
                 .build())
+        .addMethod(getMethod)
         .addMethod(
             methodBuilder("of")
                 .addModifiers(PRIVATE, STATIC)
                 .addTypeVariable(typeVariable)
-                .returns(providerOf(optionalType))
-                .addParameter(providerParameter)
-                .addCode("return new $L<T>($N);", factoryClassName, providerParameter)
+                .returns(factoryType)
+                .addParameter(delegateParameter)
+                .addCode(
+                    "return new $L<$T>($N);", factoryClassName, typeVariable, delegateParameter)
                 .build())
         .build();
   }
 
-  private ParameterizedTypeName optionalType(
-      DependencyRequest.Kind optionalValueKind, TypeName valueType) {
-    switch (optionalValueKind) {
-      case INSTANCE:
-        return optionalOf(valueType);
-
-      case LAZY:
-        return optionalOf(lazyOf(valueType));
-
-      case PROVIDER:
-        return optionalOf(providerOf(valueType));
-
-      case PROVIDER_OF_LAZY:
-        return optionalOf(providerOf(lazyOf(valueType)));
-
-      default:
-        throw new AssertionError(optionalValueKind);
-    }
+  /**
+   * An expression that uses {@link Futures#transform(ListenableFuture, Function)} to transform a
+   * {@code ListenableFuture<inputType>} into a {@code ListenableFuture<Optional<inputType>>}.
+   *
+   * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
+   */
+  private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock inputFuture) {
+    return CodeBlock.of(
+        "$T.transform($L, $L)",
+        Futures.class,
+        inputFuture,
+        anonymousClassBuilder("")
+            .addSuperinterface(
+                ParameterizedTypeName.get(
+                    ClassName.get(Function.class), inputType, optionalOf(inputType)))
+            .addMethod(
+                methodBuilder("apply")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(optionalOf(inputType))
+                    .addParameter(inputType, "input")
+                    .addCode("return $T.of(input);", Optional.class)
+                    .build())
+            .build());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 22efe9bbc..ed3dcba16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -213,5 +213,20 @@ ProductionBinding delegate(
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .build();
     }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with a binding for the underlying key.
+     */
+    ProductionBinding syntheticPresentBinding(Key key) {
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+          .dependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                  key, DependencyRequest.Kind.PRODUCER))
+          .build();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index d146fe5d9..f372858a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -302,12 +302,16 @@ public BindingType bindingType() {
       // Only multibinding declarations, so assume provision.
       return BindingType.PROVISION;
     }
-    ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    ImmutableSet<BindingType> bindingTypes = bindingTypes();
     checkState(bindingTypes.size() == 1, "conflicting binding types: %s", bindings());
     return getOnlyElement(bindingTypes);
   }
 
+  /** The binding types for {@link #bindings()}. */
+  ImmutableSet<BindingType> bindingTypes() {
+    return FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+  }
+
   /**
    * The contribution type for these bindings.
    *
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
index 481453615..a104cb916 100644
--- a/core/src/main/java/dagger/BindsOptionalOf.java
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -22,7 +22,6 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.inject.Qualifier;
 
 /**
@@ -60,9 +59,16 @@
  * <li>{@code Optional<Provider<Lazy<Foo>>>}
  * </ul>
  *
- * or a {@link Provider}, {@link Lazy}, or {@link Provider} of {@link Lazy} of any of the above.
- *
  * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
+ *
+ * <p>If the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}
+ * binding can depend on any of:
+ *
+ * <ul>
+ * <li>{@code Optional<Foo>}
+ * <li>{@code Optional<Producer<Foo>>}
+ * <li>{@code Optional<Produced<Foo>>}
+ * </ul>
  */
 @Documented
 @Beta
