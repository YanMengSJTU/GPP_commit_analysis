diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 1560fcad4..1ba5d9696 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -17,7 +17,9 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
+import static javax.lang.model.element.ElementKind.PARAMETER;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
@@ -54,9 +56,11 @@ boolean canFormat(BindingDeclaration bindingDeclaration) {
       return true;
     }
     if (bindingDeclaration.bindingElement().isPresent()) {
-      return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
-          bindingDeclaration.bindingElement().get().asType().getKind());
+      Element bindingElement = bindingDeclaration.bindingElement().get();
+      return bindingElement.getKind().equals(PARAMETER)
+          || FORMATTABLE_ELEMENT_TYPE_KINDS.contains(bindingElement.asType().getKind());
     }
+    // TODO(dpb): validate whether what this is doing is correct
     return false;
   }
 
@@ -68,6 +72,10 @@ public String format(BindingDeclaration bindingDeclaration) {
 
     if (bindingDeclaration.bindingElement().isPresent()) {
       Element bindingElement = bindingDeclaration.bindingElement().get();
+      if (bindingElement.getKind().equals(PARAMETER)) {
+        return elementToString(bindingElement);
+      }
+
       switch (bindingElement.asType().getKind()) {
         case EXECUTABLE:
           return methodSignatureFormatter.format(
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 3fa0b5dcc..96cb85df0 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -340,7 +340,8 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case SUBCOMPONENT_CREATOR:
         return new SubcomponentCreatorProviderCreationExpression(
-            binding.key().type(), componentImplementation.getSubcomponentName(binding.key()));
+            binding.key().type(),
+            componentImplementation.getSubcomponentCreatorSimpleName(binding.key()));
 
       case INJECTION:
       case PROVISION:
@@ -543,7 +544,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
         return Optional.of(
             new SubcomponentCreatorBindingExpression(
                 resolvedBindings,
-                componentImplementation.getSubcomponentName(resolvedBindings.key())));
+                componentImplementation.getSubcomponentCreatorSimpleName(resolvedBindings.key())));
 
       case MULTIBOUND_SET:
         return Optional.of(
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index fa8256a37..17ed528d7 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -24,7 +24,6 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -105,16 +104,14 @@ private static boolean hasNoSetterMethods(
   /** Base class for building a creator implementation. */
   private abstract class Builder {
     final ComponentImplementation componentImplementation;
-    final ComponentCreatorKind creatorKind;
     final ClassName className;
     final TypeSpec.Builder classBuilder;
 
     private ImmutableMap<ComponentRequirement, FieldSpec> fields;
 
-    Builder(ComponentImplementation componentImplementation, ComponentCreatorKind creatorKind) {
+    Builder(ComponentImplementation componentImplementation) {
       this.componentImplementation = componentImplementation;
-      this.creatorKind = creatorKind;
-      this.className = componentImplementation.getCreatorName(creatorKind);
+      this.className = componentImplementation.getCreatorName();
       this.classBuilder = classBuilder(className);
     }
 
@@ -368,7 +365,7 @@ private CodeBlock newModuleInstance(ComponentRequirement requirement) {
     BuilderForCreatorDescriptor(
         ComponentImplementation componentImplementation,
         ComponentCreatorDescriptor creatorDescriptor) {
-      super(componentImplementation, creatorDescriptor.kind());
+      super(componentImplementation);
       this.creatorDescriptor = creatorDescriptor;
     }
 
@@ -485,7 +482,7 @@ private boolean hasBaseCreatorImplementation() {
    */
   private final class BuilderForGeneratedRootComponentBuilder extends Builder {
     BuilderForGeneratedRootComponentBuilder(ComponentImplementation componentImplementation) {
-      super(componentImplementation, BUILDER);
+      super(componentImplementation);
     }
 
     @Override
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 4b4157c3b..1fa96a834 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -24,6 +24,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.value.AutoValue;
@@ -360,14 +361,27 @@ void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorIm
     return baseImplementation().flatMap(baseImpl -> baseImpl.creatorImplementation());
   }
 
+  /**
+   * Returns the kind of this component's creator.
+   *
+   * @throws IllegalStateException if the component has no creator
+   */
+  private ComponentCreatorKind creatorKind() {
+    checkState(componentDescriptor().hasCreator());
+    return componentDescriptor()
+        .creatorDescriptor()
+        .map(ComponentCreatorDescriptor::kind)
+        .orElse(BUILDER);
+  }
+
   /**
    * Returns the name of the creator class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
    */
-  ClassName getCreatorName(ComponentCreatorKind kind) {
+  ClassName getCreatorName() {
     return isNested()
-        ? name.peerClass(subcomponentNames.get(componentDescriptor()) + kind.typeName())
-        : name.nestedClass(kind.typeName());
+        ? name.peerClass(subcomponentNames.getCreatorName(componentDescriptor()))
+        : name.nestedClass(creatorKind().typeName());
   }
 
   /** Returns the name of the nested implementation class for a child component. */
@@ -380,9 +394,12 @@ ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
     return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
   }
 
-  /** Returns the simple subcomponent name for the given subcomponent builder {@link Key}. */
-  String getSubcomponentName(Key key) {
-    return subcomponentNames.get(key);
+  /**
+   * Returns the simple name of the creator implementation class for the given subcomponent creator
+   * {@link Key}.
+   */
+  String getSubcomponentCreatorSimpleName(Key key) {
+    return subcomponentNames.getCreatorName(key);
   }
 
   /** Returns the child implementation. */
diff --git a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
index 552d39fe5..510e8c424 100644
--- a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
@@ -17,21 +17,22 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
+import javax.lang.model.type.TypeMirror;
 
 /** A binding expression for a subcomponent creator that just invokes the constructor. */
 final class SubcomponentCreatorBindingExpression extends SimpleInvocationBindingExpression {
-  private final String subcomponentBuilderName;
-  private final ContributionBinding binding;
+  private final TypeMirror creatorType;
+  private final String creatorImplementationName;
 
   SubcomponentCreatorBindingExpression(
-      ResolvedBindings resolvedBindings, String subcomponentBuilderName) {
+      ResolvedBindings resolvedBindings, String creatorImplementationName) {
     super(resolvedBindings);
-    this.subcomponentBuilderName = subcomponentBuilderName;
-    this.binding = resolvedBindings.contributionBinding();
+    this.creatorType = resolvedBindings.key().type();
+    this.creatorImplementationName = creatorImplementationName;
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    return Expression.create(binding.key().type(), "new $LBuilder()", subcomponentBuilderName);
+    return Expression.create(creatorType, "new $L()", creatorImplementationName);
   }
 }
diff --git a/java/dagger/internal/codegen/SubcomponentCreatorProviderCreationExpression.java b/java/dagger/internal/codegen/SubcomponentCreatorProviderCreationExpression.java
index be7005c9a..06d491d81 100644
--- a/java/dagger/internal/codegen/SubcomponentCreatorProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentCreatorProviderCreationExpression.java
@@ -26,19 +26,18 @@
 /** A {@link javax.inject.Provider} creation expression for a subcomponent creator. */
 final class SubcomponentCreatorProviderCreationExpression
     implements FrameworkInstanceCreationExpression {
-  private final String subcomponentName;
-  private final TypeMirror subcomponentBuilderType;
+  private final TypeMirror creatorType;
+  private final String creatorImplementationName;
 
   SubcomponentCreatorProviderCreationExpression(
-      TypeMirror subcomponentBuilderType, String subcomponentName) {
-    this.subcomponentName = subcomponentName;
-    this.subcomponentBuilderType = subcomponentBuilderType;
+      TypeMirror creatorType, String creatorImplementationName) {
+    this.creatorType = creatorType;
+    this.creatorImplementationName = creatorImplementationName;
   }
 
   @Override
   public CodeBlock creationExpression() {
     return anonymousProvider(
-        TypeName.get(subcomponentBuilderType),
-        CodeBlock.of("return new $LBuilder();", subcomponentName));
+        TypeName.get(creatorType), CodeBlock.of("return new $L();", creatorImplementationName));
   }
 }
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index 494a9686e..f2ffd8374 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
 import static java.lang.Character.isUpperCase;
 import static java.lang.String.format;
 
@@ -24,6 +26,7 @@
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import dagger.model.Key;
 import java.util.Collection;
@@ -32,7 +35,6 @@
 import java.util.Map;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 /**
  * Holds the unique simple names for all subcomponents, keyed by their {@link ComponentDescriptor}
@@ -40,12 +42,13 @@
  */
 final class SubcomponentNames {
   private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
+
   private final ImmutableMap<ComponentDescriptor, String> namesByDescriptor;
-  private final ImmutableMap<Key, String> namesByKey;
+  private final ImmutableMap<Key, ComponentDescriptor> descriptorsByCreatorKey;
 
   SubcomponentNames(BindingGraph graph, KeyFactory keyFactory) {
     this.namesByDescriptor = namesByDescriptor(graph);
-    this.namesByKey = namesByKey(keyFactory, namesByDescriptor);
+    this.descriptorsByCreatorKey = descriptorsByCreatorKey(keyFactory, namesByDescriptor.keySet());
   }
 
   /** Returns the simple component name for the given {@link ComponentDescriptor}. */
@@ -53,9 +56,21 @@ String get(ComponentDescriptor componentDescriptor) {
     return namesByDescriptor.get(componentDescriptor);
   }
 
-  /** Returns the simple component name for the given subcomponent builder {@link Key}. */
-  String get(Key key) {
-    return namesByKey.get(key);
+  /**
+   * Returns the simple name for the subcomponent creator implementation with the given {@link Key}.
+   */
+  String getCreatorName(Key key) {
+    return getCreatorName(descriptorsByCreatorKey.get(key));
+  }
+
+  /**
+   * Returns the simple name for the subcomponent creator implementation for the given {@link
+   * ComponentDescriptor}.
+   */
+  String getCreatorName(ComponentDescriptor componentDescriptor) {
+    checkArgument(componentDescriptor.creatorDescriptor().isPresent());
+    ComponentCreatorDescriptor creatorDescriptor = componentDescriptor.creatorDescriptor().get();
+    return get(componentDescriptor) + creatorDescriptor.kind().typeName();
   }
 
   private static ImmutableMap<ComponentDescriptor, String> namesByDescriptor(BindingGraph graph) {
@@ -77,19 +92,16 @@ String get(Key key) {
     return ImmutableMap.copyOf(subcomponentImplSimpleNames);
   }
 
-  private static ImmutableMap<Key, String> namesByKey(
-      KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
-    ImmutableMap.Builder<Key, String> builder = ImmutableMap.builder();
-    subcomponentNames.forEach(
-        (component, name) ->
-            component
-                .creatorDescriptor()
-                .ifPresent(
-                    creatorDescriptor -> {
-                      TypeMirror creatorType = creatorDescriptor.typeElement().asType();
-                      builder.put(keyFactory.forSubcomponentCreator(creatorType), name);
-                    }));
-    return builder.build();
+  private static ImmutableMap<Key, ComponentDescriptor> descriptorsByCreatorKey(
+      KeyFactory keyFactory, ImmutableSet<ComponentDescriptor> subcomponents) {
+    return subcomponents.stream()
+        .filter(subcomponent -> subcomponent.creatorDescriptor().isPresent())
+        .collect(
+            toImmutableMap(
+                subcomponent ->
+                    keyFactory.forSubcomponentCreator(
+                        subcomponent.creatorDescriptor().get().typeElement().asType()),
+                subcomponent -> subcomponent));
   }
 
   private static ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index b2d42fcc8..fb27679d5 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -79,7 +79,7 @@
  *
  * <p>There is a <b>subcomponent edge</b> for each parent-child component relationship in the graph.
  * The target node is the component node for the child component. For subcomponents defined by a
- * {@linkplain SubcomponentCreatorBindingEdge subcomponent builder binding} (either a method on the
+ * {@linkplain SubcomponentCreatorBindingEdge subcomponent creator binding} (either a method on the
  * component or a set of {@code @Module.subcomponents} annotation values), the source node is the
  * binding for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
  * ChildFactoryMethodEdge subcomponent factory methods}, the source node is the component node for
diff --git a/java/dagger/model/BindingKind.java b/java/dagger/model/BindingKind.java
index 3b749b62b..7704989c8 100644
--- a/java/dagger/model/BindingKind.java
+++ b/java/dagger/model/BindingKind.java
@@ -45,7 +45,10 @@
   /** A binding for a {@link dagger.MembersInjector} of a type. */
   MEMBERS_INJECTOR,
 
-  /** A binding for a subcomponent creator. */
+  /**
+   * A binding for a subcomponent creator (a {@linkplain dagger.Subcomponent.Builder builder} or
+   * {@linkplain dagger.Subcomponent.Factory factory}).
+   */
   SUBCOMPONENT_CREATOR,
 
   /** A binding for a {@link dagger.BindsInstance}-annotated builder method. */
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTest.java b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
index aa0f2696c..9d716370d 100644
--- a/javatests/dagger/internal/codegen/ComponentCreatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
@@ -24,22 +24,18 @@
 import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
 import static dagger.internal.codegen.ComponentKind.COMPONENT;
 import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
-import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
-import static java.util.stream.Collectors.joining;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Stream;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,7 +44,7 @@
 
 /** Tests for properties of component creators shared by both builders and factories. */
 @RunWith(Parameterized.class)
-public class ComponentCreatorTest {
+public class ComponentCreatorTest extends ComponentCreatorTestHelper {
   @Parameters(name = "compilerMode={0}, creatorKind={1}")
   public static Collection<Object[]> parameters() {
     Set<List<Object>> params =
@@ -58,43 +54,8 @@
     return ImmutableList.copyOf(Iterables.transform(params, Collection::toArray));
   }
 
-  private final CompilerMode compilerMode;
-  private final ComponentCreatorKind creatorKind;
-
-  private final ErrorMessages.ComponentCreatorMessages messages;
-
   public ComponentCreatorTest(CompilerMode compilerMode, ComponentCreatorKind creatorKind) {
-    this.compilerMode = compilerMode;
-    this.creatorKind = creatorKind;
-    this.messages = creatorMessagesFor(COMPONENT, creatorKind);
-  }
-
-  // For tests where code for both builders and factories can be largely equivalent, i.e. when there
-  // is nothing to set, just preprocess the lines to change code written for a builder to code for a
-  // factory.
-  // For more complicated code, use a JavaFileBuilder to add different code depending on the creator
-  // kind.
-
-  private String process(String... lines) {
-    Stream<String> stream = Arrays.stream(lines);
-    if (creatorKind.equals(FACTORY)) {
-      stream =
-          stream.map(
-              line ->
-                  line.replace("Builder", "Factory")
-                      .replace("builder", "factory")
-                      .replace("build", "create"));
-    }
-    return stream.collect(joining("\n"));
-  }
-
-  private JavaFileObject preprocessedJavaFile(String fullyQualifiedName, String... lines) {
-    return JavaFileObjects.forSourceString(fullyQualifiedName, process(lines));
-  }
-
-  /** Returns a file builder for the current creator kind. */
-  private JavaFileBuilder javaFileBuilder(String qualifiedName) {
-    return new JavaFileBuilder(qualifiedName).withSettings(compilerMode, creatorKind);
+    super(compilerMode, COMPONENT, creatorKind);
   }
 
   @Test
@@ -140,10 +101,7 @@ public void testEmptyCreator() {
             "    }",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(injectableTypeFile, componentFile);
+    Compilation compilation = compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -216,8 +174,7 @@ public void testCanInstantiateModulesUserCannotSet() {
             "    }",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, componentFile);
+    Compilation compilation = compile(module, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -246,8 +203,7 @@ public void testMoreThanOneCreatorOfSameTypeFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -279,8 +235,7 @@ public void testBothBuilderAndFactoryFails() {
             "     SimpleComponent create();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -307,8 +262,7 @@ public void testGenericCreatorTypeFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(messages.generics()).inFile(componentFile);
   }
@@ -324,8 +278,7 @@ public void testCreatorNotInComponentFails() {
             "",
             "@Component.Builder",
             "interface Builder {}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(builder);
+    Compilation compilation = compile(builder);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(messages.mustBeInComponent()).inFile(builder);
   }
@@ -345,8 +298,7 @@ public void testCreatorMissingFactoryMethodFails() {
             "  @Component.Builder",
             "  interface Builder {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.missingFactoryMethod())
@@ -446,8 +398,7 @@ public void testCreatorWithBindsInstanceNoStaticCreateGenerated() {
             .addLines("}")
             .build();
 
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -537,8 +488,7 @@ public void testCreatorWithPrimitiveBindsInstance() {
                 "}")
             .build();
 
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -560,8 +510,7 @@ public void testPrivateCreatorFails() {
             "  @Component.Builder",
             "  private interface Builder {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(messages.isPrivate()).inFile(componentFile);
   }
@@ -581,8 +530,7 @@ public void testNonStaticCreatorFails() {
             "  @Component.Builder",
             "  abstract class Builder {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(messages.mustBeStatic()).inFile(componentFile);
   }
@@ -602,8 +550,7 @@ public void testNonAbstractCreatorFails() {
             "  @Component.Builder",
             "  static class Builder {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(messages.mustBeAbstract()).inFile(componentFile);
   }
@@ -625,8 +572,7 @@ public void testCreatorOneConstructorWithArgsFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.invalidConstructor())
@@ -651,8 +597,7 @@ public void testCreatorMoreThanOneConstructorFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.invalidConstructor())
@@ -674,8 +619,7 @@ public void testCreatorEnumFails() {
             "  @Component.Builder",
             "  enum Builder {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.mustBeClassOrInterface())
@@ -699,8 +643,7 @@ public void testCreatorFactoryMethodReturnsWrongTypeFails() {
             "    String build();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.factoryMethodMustReturnComponentType())
@@ -737,8 +680,7 @@ public void testCreatorSetterForNonBindsInstancePrimitiveFails() {
             .addLines( //
                 "}")
             .build();
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    Compilation compilation = compile(component);
     assertThat(compilation).failed();
 
     assertThat(compilation)
@@ -766,8 +708,7 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -795,8 +736,7 @@ public void testTwoFactoryMethodsFails() {
             "    SimpleComponent newSimpleComponent();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(String.format(messages.twoFactoryMethods(), process("build")))
@@ -805,7 +745,7 @@ public void testTwoFactoryMethodsFails() {
   }
 
   @Test
-  public void testInheritedTwoBuildMethodsFails() {
+  public void testInheritedTwoFactoryMethodsFails() {
     JavaFileObject componentFile =
         preprocessedJavaFile(
             "test.SimpleComponent",
@@ -824,8 +764,7 @@ public void testInheritedTwoBuildMethodsFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -878,8 +817,7 @@ public void testMultipleSettersPerTypeFails() {
             .addLines( //
                 "}")
             .build();
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    Compilation compilation = compile(moduleFile, componentFile);
     assertThat(compilation).failed();
     String elements =
         creatorKind.equals(BUILDER)
@@ -942,8 +880,7 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
             .addLines( //
                 "}")
             .build();
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    Compilation compilation = compile(moduleFile, componentFile);
     assertThat(compilation).failed();
     String elements =
         creatorKind.equals(BUILDER)
@@ -995,10 +932,7 @@ public void testExtraSettersFails() {
             "",
             "@Module",
             "abstract class AbstractModule {}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(componentFile, abstractModule);
+    Compilation compilation = compile(componentFile, abstractModule);
     assertThat(compilation).failed();
     String elements =
         creatorKind.equals(BUILDER)
@@ -1129,8 +1063,7 @@ public void covariantFactoryMethodReturnType() {
             "  }",
             "}");
 
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(foo, supertype, component);
+    Compilation compilation = compile(foo, supertype, component);
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -1182,10 +1115,7 @@ public void covariantFactoryMethodReturnType_hasNewMethod() {
             "  }",
             "}");
 
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(foo, bar, supertype, component);
+    Compilation compilation = compile(foo, bar, supertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
@@ -1253,10 +1183,7 @@ public void covariantFactoryMethodReturnType_hasNewMethod_factoryMethodInherited
             "  interface Builder extends CreatorSupertype {}",
             "}");
 
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(foo, bar, supertype, creatorSupertype, component);
+    Compilation compilation = compile(foo, bar, supertype, creatorSupertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
@@ -1284,8 +1211,7 @@ public void testGenericsOnFactoryMethodFails() {
             "    <T> SimpleComponent build();",
             "  }",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(messages.methodsMayNotHaveTypeParameters())
@@ -1312,8 +1238,7 @@ public void testGenericsOnInheritedFactoryMethodFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    Compilation compilation = compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java b/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java
new file mode 100644
index 000000000..13d3b39de
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
+import static java.util.stream.Collectors.joining;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import java.util.stream.Stream;
+import javax.tools.JavaFileObject;
+
+/**
+ * Base class for component creator codegen tests that are written in terms of builders and
+ * transformed, either by automatic string processing or using a {@code JavaFileBuilder}, to test
+ * factories as well.
+ */
+abstract class ComponentCreatorTestHelper {
+
+  private final CompilerMode compilerMode;
+
+  protected final ComponentCreatorKind creatorKind;
+  protected final ErrorMessages.ComponentCreatorMessages messages;
+
+  ComponentCreatorTestHelper(
+      CompilerMode compilerMode, ComponentKind componentKind, ComponentCreatorKind creatorKind) {
+    this.compilerMode = compilerMode;
+    this.creatorKind = creatorKind;
+    this.messages = creatorMessagesFor(componentKind, creatorKind);
+  }
+
+  // For tests where code for both builders and factories can be largely equivalent, i.e. when there
+  // is nothing to set, just preprocess the lines to change code written for a builder to code for a
+  // factory.
+  // For more complicated code, use a JavaFileBuilder to add different code depending on the creator
+  // kind.
+
+  /**
+   * Processes the given lines, replacing builder-related names with factory-related names if the
+   * creator kind is {@code FACTORY}.
+   */
+  String process(String... lines) {
+    Stream<String> stream = Arrays.stream(lines);
+    if (creatorKind.equals(FACTORY)) {
+      stream =
+          stream.map(
+              line ->
+                  line.replace("Builder", "Factory")
+                      .replace("builder", "factory")
+                      .replace("build", "create"));
+    }
+    return stream.collect(joining("\n"));
+  }
+
+  /**
+   * Returns a Java file with the {@linkplain #process(String...)} processed} versions of the given
+   * lines.
+   */
+  JavaFileObject preprocessedJavaFile(String fullyQualifiedName, String... lines) {
+    return JavaFileObjects.forSourceString(fullyQualifiedName, process(lines));
+  }
+
+  /** Returns a file builder for the current creator kind. */
+  JavaFileBuilder javaFileBuilder(String qualifiedName) {
+    return new JavaFileBuilder(qualifiedName).withSettings(compilerMode, creatorKind);
+  }
+
+  /** Compiles the given files with the set compiler mode's javacopts. */
+  Compilation compile(JavaFileObject... files) {
+    return daggerCompiler().withOptions(compilerMode.javacopts()).compile(files);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 0e10dfb13..3df8a7e71 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -20,10 +20,7 @@
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
-import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
-import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
 import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
-import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -39,393 +36,6 @@
   private static final ErrorMessages.ComponentCreatorMessages MSGS =
       creatorMessagesFor(SUBCOMPONENT, BUILDER);
 
-  @Test
-  public void testRefSubcomponentAndSubBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent child();",
-        "  ChildComponent.Builder builder();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                moreThanOneRefToSubcomponent(), "test.ChildComponent", "[child(), builder()]"))
-        .inFile(componentFile);
-  }
-
-  @Test
-  public void testRefSubBuilderTwiceFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder builder1();",
-        "  ChildComponent.Builder builder2();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                moreThanOneRefToSubcomponent(), "test.ChildComponent", "[builder1(), builder2()]"))
-        .inFile(componentFile);
-  }
-
-  @Test
-  public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder1 {",
-        "    ChildComponent build();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  static interface Builder2 {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                componentMessagesFor(SUBCOMPONENT).moreThanOne(),
-                "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
-        .inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder<T> {",
-        "     ChildComponent build();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent.Builder",
-        "interface Builder {}");
-    Compilation compilation = daggerCompiler().compile(builder);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
-  }
-
-  @Test
-  public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.missingFactoryMethod())
-        .inFile(childComponentFile);
-  }
-
-  @Test
-  public void testPrivateBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  private interface Builder {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(childComponentFile);
-  }
-
-  @Test
-  public void testNonStaticBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  abstract class Builder {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(childComponentFile);
-  }
-
-  @Test
-  public void testNonAbstractBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static class Builder {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.invalidConstructor())
-        .inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.invalidConstructor())
-        .inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderEnumFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  enum Builder {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.mustBeClassOrInterface())
-        .inFile(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(MSGS.factoryMethodMustReturnComponentType())
-        .inFile(childComponentFile)
-        .onLine(9);
-  }
-
-  @Test
-  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(MSGS.inheritedFactoryMethodMustReturnComponentType(), "build"))
-        .inFile(childComponentFile)
-        .onLine(12);
-  }
-
-  @Test
-  public void testTwoBuildMethodsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    ChildComponent create();",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.twoFactoryMethods(), "build()"))
-        .inFile(childComponentFile)
-        .onLine(10);
-  }
-
-  @Test
-  public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    ChildComponent build();",
-        "    ChildComponent create();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    Compilation compilation = daggerCompiler().compile(childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(String.format(MSGS.inheritedTwoFactoryMethods(), "build()", "create()"))
-        .inFile(childComponentFile)
-        .onLine(13);
-  }
-
   @Test
   public void testMoreThanOneArgFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -580,443 +190,4 @@ public void testGenericsOnInheritedSetterMethodFails() {
         .inFile(childComponentFile)
         .onLine(13);
   }
-
-  @Test
-  public void testMultipleSettersPerTypeFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "abstract class ChildComponent {",
-            "  abstract String s();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    ChildComponent build();",
-            "    void set1(TestModule s);",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.multipleSettersForModuleOrDependencyType(),
-                "test.TestModule",
-                "[void test.ChildComponent.Builder.set1(test.TestModule), "
-                    + "void test.ChildComponent.Builder.set2(test.TestModule)]"))
-        .inFile(childComponentFile)
-        .onLine(10);
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "abstract class ChildComponent {",
-            "  abstract String s();",
-            "",
-            "  interface Parent<T> {",
-            "    void set1(T t);",
-            "  }",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder extends Parent<TestModule> {",
-            "    ChildComponent build();",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.multipleSettersForModuleOrDependencyType(),
-                "test.TestModule",
-                "[void test.ChildComponent.Builder.set1(test.TestModule), "
-                    + "void test.ChildComponent.Builder.set2(test.TestModule)]"))
-        .inFile(childComponentFile)
-        .onLine(14);
-  }
-
-  @Test
-  public void testMultipleSettersPerBoundInstanceTypeFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface ChildComponent {",
-            "  String s();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    ChildComponent build();",
-            "    @BindsInstance void set1(String s);",
-            "    @BindsInstance void set2(String s);",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "java.lang.String is bound multiple times:",
-                "    @BindsInstance void test.ChildComponent.Builder.set1(String)",
-                "    @BindsInstance void test.ChildComponent.Builder.set2(String)",
-                "    java.lang.String is provided at",
-                "        test.ChildComponent.s() [test.ParentComponent → test.ChildComponent]"))
-        .inFile(componentFile)
-        .onLineContaining("interface ParentComponent {");
-  }
-
-  @Test
-  public void testExtraSettersFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    void set1(String s);",
-        "    void set2(Integer s);",
-        "  }",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                MSGS.extraSetters(),
-                "[void test.ChildComponent.Builder.set1(String),"
-                    + " void test.ChildComponent.Builder.set2(Integer)]"))
-        .inFile(childComponentFile)
-        .onLine(8);
-  }
-
-  @Test
-  public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
-        "interface ChildComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent create();",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(moduleFile, module2File, module3File, componentFile, childComponentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            // Ignores Test2Module because we can construct it ourselves.
-            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
-        .inFile(childComponentFile)
-        .onLine(11);
-  }
-
-  @Test
-  public void covariantBuildMethodReturnType() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface HasSupertype extends Supertype {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Supertype build();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(foo, supertype, subcomponent);
-    assertThat(compilation).succeededWithoutWarnings();
-  }
-
-  @Test
-  public void covariantBuildMethodReturnType_hasNewMethod() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Bar {",
-            "  @Inject Bar() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface HasSupertype extends Supertype {",
-            "  Bar bar();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Supertype build();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, subcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .hadWarningContaining(
-            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
-                + "declares additional component method(s): bar(). In order to provide type-safe "
-                + "access to these methods, override build() to return test.HasSupertype")
-        .inFile(subcomponent)
-        .onLine(11);
-  }
-
-  @Test
-  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Bar {",
-            "  @Inject Bar() {}",
-            "}");
-    JavaFileObject supertype =
-        JavaFileObjects.forSourceLines(
-            "test.Supertype",
-            "package test;",
-            "",
-            "interface Supertype {",
-            "  Foo foo();",
-            "}");
-
-    JavaFileObject builderSupertype =
-        JavaFileObjects.forSourceLines(
-            "test.BuilderSupertype",
-            "package test;",
-            "",
-            "interface BuilderSupertype {",
-            "  Supertype build();",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.HasSupertype",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface HasSupertype extends Supertype {",
-            "  Bar bar();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder extends BuilderSupertype {}",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(foo, bar, supertype, builderSupertype, subcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .hadWarningContaining(
-            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
-                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
-                + "bar(). In order to provide type-safe access to these methods, override build() "
-                + "to return test.HasSupertype");
-  }
 }
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
similarity index 70%
rename from javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
rename to javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
index 27a6844fb..16ecdefd0 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
@@ -17,13 +17,20 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
+import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,22 +38,25 @@
 import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
-public class SubcomponentBuilderRequestFulfillmentTest {
-  @Parameters(name = "{0}")
+public class SubcomponentCreatorRequestFulfillmentTest extends ComponentCreatorTestHelper {
+  @Parameters(name = "compilerMode={0}, creatorKind={1}")
   public static Collection<Object[]> parameters() {
-    return CompilerMode.TEST_PARAMETERS;
+    Set<List<Object>> params =
+        Sets.<Object>cartesianProduct(
+            Sets.immutableEnumSet(DEFAULT_MODE, FAST_INIT_MODE),
+            EnumSet.allOf(ComponentCreatorKind.class));
+    return ImmutableList.copyOf(Iterables.transform(params, Collection::toArray));
   }
 
-  private final CompilerMode compilerMode;
-
-  public SubcomponentBuilderRequestFulfillmentTest(CompilerMode compilerMode) {
-    this.compilerMode = compilerMode;
+  public SubcomponentCreatorRequestFulfillmentTest(
+      CompilerMode compilerMode, ComponentCreatorKind creatorKind) {
+    super(compilerMode, SUBCOMPONENT, creatorKind);
   }
 
   @Test
-  public void testInlinedSubcomponentBuilders_componentMethod() {
+  public void testInlinedSubcomponentCreators_componentMethod() {
     JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
+        preprocessedJavaFile(
             "test.Sub",
             "package test;",
             "",
@@ -60,7 +70,7 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "  }",
             "}");
     JavaFileObject usesSubcomponent =
-        JavaFileObjects.forSourceLines(
+        preprocessedJavaFile(
             "test.UsesSubcomponent",
             "package test;",
             "",
@@ -70,7 +80,7 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "  @Inject UsesSubcomponent(Sub.Builder subBuilder) {}",
             "}");
     JavaFileObject component =
-        JavaFileObjects.forSourceLines(
+        preprocessedJavaFile(
             "test.C",
             "package test;",
             "",
@@ -83,7 +93,7 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "}");
 
     JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
+        preprocessedJavaFile(
             "test.DaggerC",
             "package test;",
             "",
@@ -91,16 +101,6 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
-            "  private DaggerC() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static C create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
             "  @Override",
             "  public Sub.Builder sBuilder() {",
             "    return new SubBuilder();",
@@ -111,14 +111,6 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "    return new UsesSubcomponent(new SubBuilder());",
             "  }",
             "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public C build() {",
-            "      return new DaggerC();",
-            "    }",
-            "  }",
-            "",
             "  private final class SubBuilder implements Sub.Builder {",
             "    @Override",
             "    public Sub build() {",
@@ -131,13 +123,10 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "  }",
             "}");
 
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(subcomponent, usesSubcomponent, component);
+    Compilation compilation = compile(subcomponent, usesSubcomponent, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerC")
-        .hasSourceEquivalentTo(generatedComponent);
+        .containsElementsIn(generatedComponent);
   }
 }
diff --git a/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java
new file mode 100644
index 000000000..6246a473e
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java
@@ -0,0 +1,985 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
+import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
+import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
+import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for {@link dagger.Subcomponent.Builder} validation. */
+@RunWith(Parameterized.class)
+public class SubcomponentCreatorValidationTest extends ComponentCreatorTestHelper {
+  @Parameters(name = "creatorKind={0}")
+  public static Collection<Object[]> parameters() {
+    return ImmutableList.copyOf(new Object[][] {{BUILDER}, {FACTORY}});
+  }
+
+  public SubcomponentCreatorValidationTest(ComponentCreatorKind creatorKind) {
+    super(DEFAULT_MODE, SUBCOMPONENT, creatorKind);
+  }
+
+  @Test
+  public void testRefSubcomponentAndSubCreatorFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent child();",
+        "  ChildComponent.Builder builder();",
+        "}");
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                moreThanOneRefToSubcomponent(),
+                "test.ChildComponent",
+                process("[child(), builder()]")))
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testRefSubCreatorTwiceFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder1();",
+        "  ChildComponent.Builder builder2();",
+        "}");
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                moreThanOneRefToSubcomponent(),
+                "test.ChildComponent", process("[builder1(), builder2()]")))
+        .inFile(componentFile);
+  }
+
+  @Test
+  public void testMoreThanOneCreatorFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",
+        "}");
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder1 {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  static interface Builder2 {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                componentMessagesFor(SUBCOMPONENT).moreThanOne(),
+                process("[test.ChildComponent.Builder1, test.ChildComponent.Builder2]")))
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testMoreThanOneCreatorFails_differentTypes() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Factory",
+        "  static interface Factory {",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                componentMessagesFor(SUBCOMPONENT).moreThanOne(),
+                "[test.ChildComponent.Builder, test.ChildComponent.Factory]"))
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorGenericsFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder<T> {",
+        "     ChildComponent build();",
+        "  }",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.generics()).inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorNotInComponentFails() {
+    JavaFileObject builder = preprocessedJavaFile("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent.Builder",
+        "interface Builder {}");
+    Compilation compilation = compile(builder);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.mustBeInComponent()).inFile(builder);
+  }
+
+  @Test
+  public void testCreatorMissingFactoryMethodFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder();",
+        "}");
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {}",
+        "}");
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.missingFactoryMethod())
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testPrivateCreatorFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  private interface Builder {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.isPrivate()).inFile(childComponentFile);
+  }
+
+  @Test
+  public void testNonStaticCreatorFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  abstract class Builder {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(messages.mustBeStatic()).inFile(childComponentFile);
+  }
+
+  @Test
+  public void testNonAbstractCreatorFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static class Builder {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.mustBeAbstract())
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorOneConstructorWithArgsFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.invalidConstructor())
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorMoreThanOneConstructorFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.invalidConstructor())
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorEnumFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  enum Builder {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.mustBeClassOrInterface())
+        .inFile(childComponentFile);
+  }
+
+  @Test
+  public void testCreatorFactoryMethodReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(messages.factoryMethodMustReturnComponentType())
+        .inFile(childComponentFile)
+        .onLine(9);
+  }
+
+  @Test
+  public void testInheritedCreatorFactoryMethodReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.inheritedFactoryMethodMustReturnComponentType(), process("build")))
+        .inFile(childComponentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void testTwoFactoryMethodsFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    ChildComponent build1();",
+        "  }",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(messages.twoFactoryMethods(), process("build()")))
+        .inFile(childComponentFile)
+        .onLine(10);
+  }
+
+  @Test
+  public void testInheritedTwoFactoryMethodsFails() {
+    JavaFileObject childComponentFile = preprocessedJavaFile("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    ChildComponent build1();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    Compilation compilation = compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.inheritedTwoFactoryMethods(), process("build()"), process("build1()")))
+        .inFile(childComponentFile)
+        .onLine(13);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        javaFileBuilder("test.ChildComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Subcomponent;",
+                "import javax.inject.Provider;",
+                "",
+                "@Subcomponent(modules = TestModule.class)",
+                "abstract class ChildComponent {",
+                "  abstract String s();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Subcomponent.Builder",
+                "  interface Builder {",
+                "    ChildComponent build();",
+                "    void set1(TestModule s);",
+                "    void set2(TestModule s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Subcomponent.Factory",
+                "  interface Factory {",
+                "    ChildComponent create(TestModule m1, TestModule m2);",
+                "  }")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation = compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(BUILDER)
+            ? "[void test.ChildComponent.Builder.set1(test.TestModule), "
+                + "void test.ChildComponent.Builder.set2(test.TestModule)]"
+            : "[test.TestModule m1, test.TestModule m2]";
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.multipleSettersForModuleOrDependencyType(), "test.TestModule", elements))
+        .inFile(childComponentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        javaFileBuilder("test.ChildComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Subcomponent;",
+                "import javax.inject.Provider;",
+                "",
+                "@Subcomponent(modules = TestModule.class)",
+                "abstract class ChildComponent {",
+                "  abstract String s();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  interface Parent<T> {",
+                "    void set1(T t);",
+                "  }",
+                "",
+                "  @Subcomponent.Builder",
+                "  interface Builder extends Parent<TestModule> {",
+                "    ChildComponent build();",
+                "    void set2(TestModule s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  interface Parent<C, T> {",
+                "    C create(TestModule m1, T t);",
+                "  }",
+                "",
+                "  @Subcomponent.Factory",
+                "  interface Factory extends Parent<ChildComponent, TestModule> {}")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation = compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(BUILDER)
+            ? "[void test.ChildComponent.Builder.set1(test.TestModule), "
+                + "void test.ChildComponent.Builder.set2(test.TestModule)]"
+            : "[test.TestModule m1, test.TestModule t]";
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.multipleSettersForModuleOrDependencyType(), "test.TestModule", elements))
+        .inFile(childComponentFile)
+        .onLine(15);
+  }
+
+  @Test
+  public void testMultipleSettersPerBoundInstanceTypeFails() {
+    JavaFileObject componentFile =
+        preprocessedJavaFile(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        javaFileBuilder("test.ChildComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.BindsInstance;",
+                "import dagger.Subcomponent;",
+                "",
+                "@Subcomponent",
+                "abstract class ChildComponent {",
+                "  abstract String s();",
+                "")
+            .addLinesIf(
+                BUILDER,
+                "  @Subcomponent.Builder",
+                "  interface Builder {",
+                "    ChildComponent build();",
+                "    @BindsInstance void set1(String s);",
+                "    @BindsInstance void set2(String s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Subcomponent.Factory",
+                "  interface Factory {",
+                "    ChildComponent create(",
+                "        @BindsInstance String s1, @BindsInstance String s2);",
+                "  }")
+            .addLines( //
+                "}")
+            .build();
+
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    String firstBinding = creatorKind.equals(FACTORY)
+        ? "test.ChildComponent.Factory.create(s1, …)"
+        : "@BindsInstance void test.ChildComponent.Builder.set1(String)";
+    String secondBinding = creatorKind.equals(FACTORY)
+        ? "test.ChildComponent.Factory.create(…, s2)"
+        : "@BindsInstance void test.ChildComponent.Builder.set2(String)";
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.String is bound multiple times:",
+                "    " + firstBinding,
+                "    " + secondBinding,
+                "    java.lang.String is provided at",
+                "        test.ChildComponent.s() [test.ParentComponent → test.ChildComponent]"))
+        .inFile(componentFile)
+        .onLineContaining("interface ParentComponent {");
+  }
+
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile =
+        javaFileBuilder("test.ChildComponent")
+            .addLines(
+                "package test;",
+                "",
+                "import dagger.Subcomponent;",
+                "import javax.inject.Provider;",
+                "",
+                "@Subcomponent",
+                "abstract class ChildComponent {")
+            .addLinesIf(
+                BUILDER,
+                "  @Subcomponent.Builder",
+                "  interface Builder {",
+                "    ChildComponent build();",
+                "    void set1(String s);",
+                "    void set2(Integer s);",
+                "  }")
+            .addLinesIf(
+                FACTORY,
+                "  @Subcomponent.Factory",
+                "  interface Factory {",
+                "    ChildComponent create(String s, Integer i);",
+                "  }")
+            .addLines( //
+                "}")
+            .build();
+    Compilation compilation = compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    String elements =
+        creatorKind.equals(FACTORY)
+            ? "[String s, Integer i]"
+            : "[void test.ChildComponent.Builder.set1(String),"
+                + " void test.ChildComponent.Builder.set2(Integer)]";
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                messages.extraSetters(),
+                elements))
+        .inFile(childComponentFile)
+        .onLine(9);
+  }
+
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = preprocessedJavaFile("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile =
+        preprocessedJavaFile(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
+            "interface ChildComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        compile(moduleFile, module2File, module3File, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(messages.missingSetters(), "[test.TestModule, test.Test3Module]"))
+        .inFile(childComponentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(foo, supertype, subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(foo, bar, supertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            process(
+                "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                    + "declares additional component method(s): bar(). In order to provide "
+                    + "type-safe access to these methods, override build() to return "
+                    + "test.HasSupertype"))
+        .inFile(subcomponent)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantFactoryMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject creatorSupertype =
+        preprocessedJavaFile(
+            "test.CreatorSupertype",
+            "package test;",
+            "",
+            "interface CreatorSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject subcomponent =
+        preprocessedJavaFile(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends CreatorSupertype {}",
+            "}");
+
+    Compilation compilation = compile(foo, bar, supertype, creatorSupertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            process(
+                "[test.CreatorSupertype.build()] test.HasSupertype.Builder.build() returns "
+                    + "test.Supertype, but test.HasSupertype declares additional component "
+                    + "method(s): bar(). In order to provide type-safe access to these methods, "
+                    + "override build() to return test.HasSupertype"));
+  }
+}
