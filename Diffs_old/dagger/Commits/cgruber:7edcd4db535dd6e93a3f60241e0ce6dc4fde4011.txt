diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 703ebb384..0513c7528 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -261,7 +261,7 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     component = createComponentClass();
     addBuilder();
     addFactoryMethods();
-    addFields();
+    addFrameworkFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
@@ -461,7 +461,7 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
-  private void addFields() {
+  private void addFrameworkFields() {
     for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
       addField(resolvedBindings);
     }
@@ -1066,10 +1066,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
   }
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
-    return CodeBlock.of(
-        "$T.provider($L)",
-        scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
-        factoryCreate);
+      return CodeBlock.of(
+          "$T.provider($L)",
+          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
+          factoryCreate);
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index cddc1aea7..3571b8b58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -448,7 +448,7 @@ private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey)
         }
 
         for (ContributionBinding delegateMultibinding : getDelegateMultibindings(key)) {
-          if (delegateMultibinding.key().withoutBindingMethodIdentifier().equals(key)) {
+          if (delegateMultibinding.key().withoutBindingIdentifier().equals(key)) {
             return true;
           }
         }
@@ -587,7 +587,7 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
 
       /**
        * Returns the explicit multibindings whose key (minus its
-       * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
+       * {@link Key#bindingIdentifier()}) matches the {@code requestKey} from this and all
        * ancestor resolvers.
        */
       private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
@@ -831,16 +831,17 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
     }
 
     /**
-     * Selects each item in {@code haveKeys} that has a {@link Key#bindingMethodIdentifier()} and
-     * indexes them by its {@link HasKey#key()}, where each key has its {@link
-     * dagger.internal.codegen.Key.BindingMethodIdentifier} removed.
+     * Selects each item in {@code haveKeys} that has a {@link Key#bindingIdentifier()} and
+     * indexes them by its {@link HasKey#key()}, where each key has its
+     * {@link Key.BindingIdentifier} removed.
      */
-    static <T extends HasKey> ImmutableSetMultimap<Key, T>
-        multibindingsKeyedWithoutBindingIdentifiers(Iterable<T> haveKeys) {
+    static <T extends HasKey>
+        ImmutableSetMultimap<Key, T> multibindingsKeyedWithoutBindingIdentifiers(
+            Iterable<T> haveKeys) {
       ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
       for (T hasKey : haveKeys) {
-        if (hasKey.key().bindingMethodIdentifier().isPresent()) {
-          builder.put(hasKey.key().withoutBindingMethodIdentifier(), hasKey);
+        if (hasKey.key().bindingIdentifier().isPresent()) {
+          builder.put(hasKey.key().withoutBindingIdentifier(), hasKey);
         }
       }
       return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fa3e8e30e..e33d0cd74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -285,7 +285,7 @@ boolean isProducer() {
   abstract Optional<BuilderSpec> builderSpec();
 
   @AutoValue
-  static abstract class ComponentMethodDescriptor {
+  abstract static class ComponentMethodDescriptor {
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
@@ -356,7 +356,7 @@ Kind componentKind() {
   }
 
   @AutoValue
-  static abstract class BuilderSpec {
+  abstract static class BuilderSpec {
     abstract TypeElement builderDefinitionType();
     abstract Map<TypeElement, ExecutableElement> methodMap();
     abstract ExecutableElement buildMethod();
@@ -465,7 +465,6 @@ private ComponentDescriptor create(
             break;
           default: // nothing special to do for other methods.
         }
-
       }
 
       ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 7b32c9da0..41f685cba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -90,7 +90,7 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsMethodValidator multibindingsMethodValidator =
         new MultibindingsMethodValidator(elements, types);
 
-    Key.Factory keyFactory = new Key.Factory(types, elements);
+    Key.Factory keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
 
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 76e8c0d64..23f396377 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -130,6 +130,14 @@ public TypeMirror apply(AnnotationValue typeValue) {
           throw new IllegalArgumentException(elementName + " is not an array: " + o);
         }
       };
+      
+  /**
+   * Returns the value named {@code elementName} from {@code annotation}, which must be a member
+   * that contains a single type.
+   */
+  static TypeMirror typeValue(AnnotationMirror annotation, String elementName) {
+    return TO_TYPE.visit(getAnnotationValue(annotation, elementName));
+  }
 
   private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
       new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index fe22d2b11..51c797c72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -40,7 +40,11 @@
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
+import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -213,26 +217,30 @@ static Kind forMultibindingRequest(DependencyRequest request) {
   }
 
   /**
-   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
-   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
-   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   * Returns the {@link FactoryCreationStrategy} appropriate for a binding.
+   *
+   * <p>Delegate bindings
+   * use the {@link FactoryCreationStrategy#DELEGATE} strategy.
+   *
+   * <p>Bindings without dependencies that don't require a module instance use the
+   * {@link FactoryCreationStrategy#ENUM_INSTANCE} strategy.
+   *
+   * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
   FactoryCreationStrategy factoryCreationStrategy() {
     switch (bindingKind()) {
       case SYNTHETIC_DELEGATE_BINDING:
-        return FactoryCreationStrategy.DELEGATE;
+        return DELEGATE;
       case PROVISION:
         return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+            ? ENUM_INSTANCE
+            : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return implicitDependencies().isEmpty()
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return implicitDependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
       default:
-        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return CLASS_CONSTRUCTOR;
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index e2bf84705..cfabcae1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -66,7 +66,7 @@ DelegateDeclaration create(
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
-          keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
+          keyFactory.forBindsMethod(bindsMethod, contributingElement),
           bindsMethod,
           Optional.of(contributingElement),
           delegateRequest,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 84434fcdd..19c5c0959 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -110,7 +110,7 @@
     Kind() {
       this.frameworkClass = Optional.absent();
     }
-    
+
     /**
      * If {@code type}'s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with
      * this kind that represents the dependency request.
@@ -131,7 +131,7 @@ KindAndType ofType(TypeMirror type) {
 
   abstract Kind kind();
   abstract Key key();
-  
+
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -159,7 +159,7 @@ BindingKey bindingKey() {
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
-  
+
   /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
   abstract boolean isSynthetic();
 
@@ -200,7 +200,7 @@ public boolean apply(DependencyRequest request) {
     /**
      * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
      * to satisfy the {@code mapOfValueRequest}.
-     * 
+     *
      * @param mapOfValueRequest a request for {@code Map<K, V>}
      * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
      *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
@@ -224,8 +224,8 @@ DependencyRequest forImplicitMapBinding(
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingMethodIdentifier().isPresent(),
-          "multibindingContribution's key must have a binding method identifier: %s",
+          multibindingContribution.key().bindingIdentifier().isPresent(),
+          "multibindingContribution's key must have a binding identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
           multibindingContributionRequestKind(multibindingContribution),
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 9ca9ef07f..724b7f766 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -102,28 +102,28 @@
    * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
    * synthetic binding} that depends on the specific contributions to that map or set. Each such
    * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound. For those bindings, this is the binding method element.
+   * the qualified type that is bound.
+   *
+   * <p>For nonsynthetic multibinding contributions, this should be a human-readable string that
+   * identifies the method and contributing module.
    */
-  abstract Optional<BindingMethodIdentifier> bindingMethodIdentifier();
+  abstract Optional<BindingIdentifier> bindingIdentifier();
 
   /** An object that uniquely identifies a multibinding contribution binding. */
   @AutoValue
-  abstract static class BindingMethodIdentifier {
-    /**
-     * The {@link dagger.Provides} or {@link dagger.producers.Produces} method that contributes to
-     * the multibinding.
-     */
-    abstract ExecutableElement bindingMethod();
+  abstract static class BindingIdentifier {
+    abstract String string();
 
-    /** The installed module that contains or inherits the {@link #bindingMethod()}. */
-    abstract TypeElement contributingModule();
+    @Override
+    public final String toString() {
+      return string();
+    }
 
-    static BindingMethodIdentifier create(
-        ExecutableElement bindingMethod, TypeElement contributingModule) {
-      return new AutoValue_Key_BindingMethodIdentifier(bindingMethod, contributingModule);
+    static BindingIdentifier create(String string) {
+      return new AutoValue_Key_BindingIdentifier(string);
     }
   }
-  
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -145,32 +145,34 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingMethodIdentifier()} are equivalent to this
+   * A key whose {@link #qualifier()} and {@link #bindingIdentifier()} are equivalent to this
    * one's, but with {@code newType} (normalized) as its {@link #type()}.
    */
   private Key withType(Types types, TypeMirror newType) {
     return new AutoValue_Key(
         wrappedQualifier(),
         MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingMethodIdentifier());
+        bindingIdentifier());
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
-   * {@code bindingDeclaration} as its {@link #bindingMethodIdentifier()}.
+   * {@code bindingIdentifier} as its {@link #bindingIdentifier()}.
    */
-  private Key withBindingMethodIdentifier(BindingMethodIdentifier bindingMethodIdentifier) {
+  private Key withBindingIdentifier(String bindingIdentifier) {
     return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.of(bindingMethodIdentifier));
+        wrappedQualifier(),
+        wrappedType(),
+        Optional.of(BindingIdentifier.create(bindingIdentifier)));
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingMethodIdentifier()}.
+   * absent {@link #bindingIdentifier()}.
    */
-  Key withoutBindingMethodIdentifier() {
+  Key withoutBindingIdentifier() {
     return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.<BindingMethodIdentifier>absent());
+        wrappedQualifier(), wrappedType(), Optional.<BindingIdentifier>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -225,7 +227,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
-        .add("bindingMethodIdentifier", bindingMethodIdentifier().orNull())
+        .add("bindingIdentifier", bindingIdentifier().orNull())
         .toString();
   }
 
@@ -247,18 +249,22 @@ public Key apply(HasKey hasKey) {
   static final class Factory {
     private final Types types;
     private final Elements elements;
+    private final MethodSignatureFormatter methodSignatureFormatter;
 
-    Factory(Types types, Elements elements) {
+    Factory(Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
+      this.methodSignatureFormatter = checkNotNull(methodSignatureFormatter);
     }
 
-    private TypeElement getSetElement() {
-      return elements.getTypeElement(Set.class.getCanonicalName());
+    private DeclaredType setOf(TypeMirror elementType) {
+      return types.getDeclaredType(
+          elements.getTypeElement(Set.class.getCanonicalName()), elementType);
     }
 
-    private TypeElement getMapElement() {
-      return elements.getTypeElement(Map.class.getCanonicalName());
+    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
     }
 
     private TypeElement getProviderElement() {
@@ -326,8 +332,7 @@ private Key forProvidesOrProducesMethod(
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(method, contributingModule));
+          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
     }
 
     /**
@@ -354,19 +359,27 @@ Key forMultibindsMethod(
     }
 
     /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
+    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
       checkArgument(isAnnotationPresent(method, Binds.class));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      TypeMirror returnType =
+          normalize(
+              types,
+              MoreTypes.asExecutable(
+                      types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method))
+                  .getReturnType());
       TypeMirror keyType =
           bindingMethodKeyType(
               returnType, method, contributionType, Optional.<TypeElement>absent());
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(
-                  method, MoreElements.asType(method.getEnclosingElement())));
+          : key.withBindingIdentifier(bindingIdentifier(method, contributingModule));
+    }
+
+    private String bindingIdentifier(ExecutableElement method, TypeElement contributingModule) {
+      return methodSignatureFormatter.format(
+          method, Optional.of(MoreTypes.asDeclared(contributingModule.asType())));
     }
 
     private TypeMirror bindingMethodKeyType(
@@ -378,12 +391,12 @@ private TypeMirror bindingMethodKeyType(
         case UNIQUE:
           return returnType;
         case SET:
-          return types.getDeclaredType(getSetElement(), returnType);
+          return setOf(returnType);
         case MAP:
           if (frameworkType.isPresent()) {
             return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
           } else {
-            return types.getDeclaredType(getMapElement(), mapKeyType(method), returnType);
+            return mapOf(mapKeyType(method), returnType);
           }
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
@@ -413,8 +426,7 @@ Key forDelegateBinding(
      */
     private TypeMirror mapOfFrameworkType(
         TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
+      return mapOf(keyType, types.getDeclaredType(frameworkType, valueType));
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
@@ -428,35 +440,35 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+          Optional.<BindingIdentifier>absent());
     }
 
     Key forProductionExecutor() {
@@ -512,8 +524,7 @@ Key convertToDelegateKey(Key possibleMapKey) {
       } else {
         return possibleMapKey;
       }
-      return possibleMapKey.withType(
-          types, types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType));
+      return possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType));
     }
 
     /**
@@ -545,9 +556,8 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           DeclaredType wrappedValueType =
               types.getDeclaredType(
                   wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
         }
       }
       return Optional.absent();
@@ -569,9 +579,8 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(wrappingElement, mapType.valueType());
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
         }
       }
       return Optional.absent();
@@ -588,8 +597,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
             MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
         if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
           TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
-          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
-          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
+          return Optional.of(possibleSetOfProducedKey.withType(types, setOf(producedArgType)));
         }
       }
       return Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index d329627a0..3be455fdd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -31,9 +31,9 @@
 
   @Override
   public String format(Key key) {
-    if (key.bindingMethodIdentifier().isPresent()) {
-      // If there's a binding method, its signature is enough.
-      return methodSignatureFormatter.format(key.bindingMethodIdentifier().get());
+    if (key.bindingIdentifier().isPresent()) {
+      // If there's a binding identifier, use that.
+      return key.bindingIdentifier().get().toString();
     }
     StringBuilder builder = new StringBuilder();
     if (key.qualifier().isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index fa2e55555..20c056a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import java.util.Iterator;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
@@ -94,12 +93,6 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
-  String format(BindingMethodIdentifier bindingMethodIdentifier) {
-    return format(
-        MoreElements.asExecutable(bindingMethodIdentifier.bindingMethod()),
-        Optional.of(MoreTypes.asDeclared(bindingMethodIdentifier.contributingModule().asType())));
-  }
-
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 8a8ac1cfd..6b8fcac9e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -211,7 +211,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 49d465cb3..7e07427b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -349,6 +349,15 @@ public ContributionType contributionType() {
     return bindingType().frameworkClass();
   }
 
+  /**
+   * The scope associated with the single binding.
+   *
+   * @throws IllegalStateException if {@link #bindings()} does not have exactly one element
+   */
+  Optional<Scope> scope() {
+    return getOnlyElement(bindings()).scope();
+  }
+
   static final Function<ResolvedBindings, Set<ContributionBinding>> CONTRIBUTION_BINDINGS =
       new Function<ResolvedBindings, Set<ContributionBinding>>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 0c136b3d7..f807a4fb2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -19,7 +19,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -105,8 +104,8 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
    *
-   * This does not return any annotation values as according to {@link javax.inject.Scope} scope
-   * annotations are not supposed to use them.
+   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope}
+   * annotations are not supposed to have any.
    */
   public String getReadableSource() {
     return stripCommonTypePrefixes("@" + getQualifiedName());
@@ -116,10 +115,14 @@ public String getReadableSource() {
    * Returns the fully qualified name of the annotation type.
    */
   public String getQualifiedName() {
-    Preconditions.checkState(annotationMirror != null,
-        "Cannot create a stripped source representation of no annotation");
-    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
-    return typeElement.getQualifiedName().toString();
+    return scopeAnnotationElement().getQualifiedName().toString();
+  }
+
+  /**
+   * The scope annotation element.
+   */
+  public TypeElement scopeAnnotationElement() {
+    return MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
index c94eafea6..8ba3704dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -16,7 +16,11 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -26,33 +30,77 @@
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
-/** A representation of an annotation with no fields. */
+/** A representation of an annotation. */
 final class SimpleAnnotationMirror implements AnnotationMirror {
-  private final DeclaredType type;
+  private final TypeElement annotationType;
+  private final ImmutableMap<String, ? extends AnnotationValue> namedValues;
+  private final ImmutableMap<ExecutableElement, ? extends AnnotationValue> elementValues;
 
-  private SimpleAnnotationMirror(DeclaredType type) {
-    this.type = type;
+  private SimpleAnnotationMirror(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    checkArgument(
+        annotationType.getKind().equals(ElementKind.ANNOTATION_TYPE),
+        "annotationType must be an annotation: %s",
+        annotationType);
+    checkArgument(
+        FluentIterable.from(methodsIn(annotationType.getEnclosedElements()))
+            .transform(ELEMENT_SIMPLE_NAME)
+            .toSet()
+            .equals(namedValues.keySet()),
+        "namedValues must have values for exactly the members in %s: %s",
+        annotationType,
+        namedValues);
+    this.annotationType = annotationType;
+    this.namedValues = ImmutableMap.copyOf(namedValues);
+    this.elementValues =
+        Maps.toMap(
+            methodsIn(annotationType.getEnclosedElements()),
+            Functions.compose(Functions.forMap(namedValues), ELEMENT_SIMPLE_NAME));
   }
 
   @Override
   public DeclaredType getAnnotationType() {
-    return type;
+    return MoreTypes.asDeclared(annotationType.asType());
   }
 
   @Override
-  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues() {
-    return ImmutableMap.of();
+  public Map<ExecutableElement, ? extends AnnotationValue> getElementValues() {
+    return elementValues;
   }
 
   @Override
   public String toString() {
-    return "@" + type;
+    StringBuilder builder = new StringBuilder("@").append(annotationType.getQualifiedName());
+    if (!namedValues.isEmpty()) {
+      builder
+          .append('(')
+          .append(Joiner.on(", ").withKeyValueSeparator(" = ").join(namedValues))
+          .append(')');
+    }
+    return builder.toString();
   }
 
-  static AnnotationMirror of(TypeElement element) {
-    checkArgument(element.getKind().equals(ElementKind.ANNOTATION_TYPE));
-    checkArgument(element.getEnclosedElements().isEmpty());
-    return new SimpleAnnotationMirror(MoreTypes.asDeclared(element.asType()));
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type with no members
+   */
+  static AnnotationMirror of(TypeElement annotationType) {
+    return of(annotationType, ImmutableMap.<String, AnnotationValue>of());
+  }
+
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type
+   * @param namedValues a value for every annotation member, including those with defaults, indexed
+   *     by simple name
+   */
+  static AnnotationMirror of(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    return new SimpleAnnotationMirror(annotationType, namedValues);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
new file mode 100644
index 000000000..fee479074
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.type.TypeMirror;
+
+/** An {@link AnnotationValue} that contains a {@link TypeMirror}. */
+final class SimpleTypeAnnotationValue implements AnnotationValue {
+  private final TypeMirror value;
+
+  SimpleTypeAnnotationValue(TypeMirror value) {
+    this.value = value;
+  }
+
+  @Override
+  public TypeMirror getValue() {
+    return value;
+  }
+
+  @Override
+  public String toString() {
+    return value + ".class";
+  }
+
+  @Override
+  public <R, P> R accept(AnnotationValueVisitor<R, P> visitor, P parameter) {
+    return visitor.visitType(getValue(), parameter);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index d93fae3d9..6775ee13a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -170,7 +170,6 @@ public TypeElement visitType(TypeElement e, Void p) {
         }
       };
 
-      
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
@@ -203,5 +202,14 @@ public boolean apply(Element element) {
             });
   }
 
+  /** A function that returns the simple name of an element. */
+  static final Function<Element, String> ELEMENT_SIMPLE_NAME =
+      new Function<Element, String>() {
+        @Override
+        public String apply(Element element) {
+          return element.getSimpleName().toString();
+        }
+      };
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 2bc5fc017..0bd1ec551 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -56,7 +56,7 @@
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
+    this.keyFactory = new Key.Factory(types, elements, new MethodSignatureFormatter(types));
     this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3592fbb17..865097ba7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,7 +23,7 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
+import dagger.internal.codegen.Key.BindingIdentifier;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
@@ -56,12 +56,14 @@
 
   private Elements elements;
   private Types types;
+  private MethodSignatureFormatter methodSignatureFormatter;
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
+    this.methodSignatureFormatter = new MethodSignatureFormatter(types);
+    this.keyFactory = new Key.Factory(types, elements, methodSignatureFormatter);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
@@ -76,7 +78,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<BindingMethodIdentifier>absent()));
+                Optional.<BindingIdentifier>absent()));
   }
 
   static final class InjectedClass {
@@ -95,7 +97,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(stringType),
-                Optional.<BindingMethodIdentifier>absent()));
+                Optional.<BindingIdentifier>absent()));
   }
 
   @Module
@@ -170,7 +172,11 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(providesMethod, moduleElement))));
+                  Optional.of(
+                      BindingIdentifier.create(
+                          methodSignatureFormatter.format(
+                              providesMethod,
+                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
     }
   }
 
@@ -230,7 +236,7 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType),
-                  Optional.<BindingMethodIdentifier>absent()));
+                  Optional.<BindingIdentifier>absent()));
     }
   }
 
@@ -258,7 +264,11 @@ String provideQualifiedString() {
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(producesMethod, moduleElement))));
+                  Optional.of(
+                      BindingIdentifier.create(
+                          methodSignatureFormatter.format(
+                              producesMethod,
+                              Optional.of(MoreTypes.asDeclared(moduleElement.asType())))))));
     }
   }
 
diff --git a/core/src/main/java/dagger/internal/GwtIncompatible.java b/core/src/main/java/dagger/internal/GwtIncompatible.java
new file mode 100644
index 000000000..8d60e3325
--- /dev/null
+++ b/core/src/main/java/dagger/internal/GwtIncompatible.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/** Marks an element incompatible with GWT. */
+public @interface GwtIncompatible {}
diff --git a/core/src/main/java/dagger/releaseablereferences/package-info.java b/core/src/main/java/dagger/releaseablereferences/package-info.java
new file mode 100644
index 000000000..d53cccb88
--- /dev/null
+++ b/core/src/main/java/dagger/releaseablereferences/package-info.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the API by which Dagger allows you
+ * <a href="http://google.github.io/dagger/users-guide.html#releasable-references">release
+ * references</a> held within some scopes.
+ * 
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.NEXT
+ */
+package dagger.releaseablereferences;
diff --git a/pom.xml b/pom.xml
index b81f8c8b6..ba52868c2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -205,6 +205,7 @@
         <configuration>
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
+          <docfilessubdirs>true</docfilessubdirs>
         </configuration>
       </plugin>
 
