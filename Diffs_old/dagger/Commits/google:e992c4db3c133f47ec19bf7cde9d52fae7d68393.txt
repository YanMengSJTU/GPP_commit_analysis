diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 4723d2497..3a0530f81 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -39,6 +39,13 @@ limitations under the License.
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <!-- For map-bindings -->
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <version>${auto.value.version}</version>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -59,9 +66,6 @@ limitations under the License.
         <configuration>
           <source>1.7</source>
           <target>1.7</target>
-          <annotationProcessors>
-            <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
-          </annotationProcessors>
         </configuration>
       </plugin>
       <plugin>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 731df3f57..7fd73c139 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -20,12 +20,20 @@
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
+import test.sub.ContributionsModule;
 
-@Component(modules = MultibindingModule.class)
+@Component(
+  modules = {
+    MultibindingModule.class,
+    ContributionsModule.class
+  },
+  dependencies = MultibindingDependency.class
+)
 interface MultibindingComponent {
   Map<String, String> map();
   Map<String, Provider<String>> mapOfProviders();
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
+  Map<TestKey.NestedWrappedKey, String> nestedKeyMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
new file mode 100644
index 000000000..a92e029e2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+interface MultibindingDependency {
+  double doubleDependency();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 2b9b441ac..311ac1bd6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -27,7 +27,7 @@
 
 @Module
 class MultibindingModule {
-  @Provides(type = MAP) @TestKey("foo") String provideFooKey() {
+  @Provides(type = MAP) @TestKey("foo") String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
@@ -50,4 +50,12 @@
   @Provides Collection<String> provideMapValues(Map<String, String> map) {
     return map.values();
   }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Integer.class) String valueForInteger() {
+    return "integer";
+  }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Long.class) String valueForLong() {
+    return "long";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
index 3f1b80069..43a088cdc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
@@ -17,14 +17,19 @@
 
 import dagger.Component;
 import javax.inject.Inject;
+import test.sub.OtherThing;
 
 @Component(dependencies = {NonComponentDependencyComponent.ThingComponent.class})
 interface NonComponentDependencyComponent {
   ThingTwo thingTwo();
 
   static class ThingTwo {
+    @SuppressWarnings("unused")
     @Inject
-    ThingTwo(@SuppressWarnings("unused") Thing thing) {}
+    ThingTwo(
+        Thing thing,
+        NonComponentDependencyComponent nonComponentDependencyComponent,
+        NonComponentDependencyComponent.ThingComponent thingComponent) {}
   }
 
   // A non-component interface which this interface depends upon.
@@ -36,7 +41,7 @@
   static class ThingComponentImpl implements ThingComponent {
     @Override
     public Thing thing() {
-      return new Thing();
+      return new Thing(new OtherThing(1));
     }
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
new file mode 100644
index 000000000..c7fabdb2b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+final class OuterClassBar {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    InjectedThing injectedThing();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
new file mode 100644
index 000000000..86f963f5c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+final class OuterClassFoo {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    Thing thing();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
index 549eb3fa7..645af788a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
@@ -20,4 +20,9 @@
 @MapKey(unwrapValue = true)
 @interface TestKey {
   String value();
+
+  @MapKey(unwrapValue = false)
+  @interface NestedWrappedKey {
+    Class<?> value();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Thing.java b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
index 127ad07e2..46cbdc999 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/Thing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
@@ -16,7 +16,8 @@
 package test;
 
 import javax.inject.Inject;
+import test.sub.OtherThing;
 
 final class Thing {
-  @Inject Thing() {}
+  @Inject Thing(@SuppressWarnings("unused") OtherThing unused) {}
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
new file mode 100644
index 000000000..b10ac4533
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.sub;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
+@Module
+public final class ContributionsModule {
+  @Provides(type = SET) int contributeAnInt(double doubleDependency) {
+    return 1742;
+  }
+
+  @Provides(type = SET) int contributeAnotherInt() {
+    return 832;
+  }
+
+  @Provides(type = SET_VALUES) Set<Integer> contributeSomeInts() {
+    return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
new file mode 100644
index 000000000..94935171f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.sub;
+
+import javax.inject.Inject;
+
+public final class OtherThing {
+  @Inject public OtherThing(int i) {}
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 04235b68b..8172ced27 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -1,22 +1,23 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
 package test;
 
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.collect.ImmutableMap;
 import java.util.Map;
 import javax.inject.Provider;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -25,18 +26,50 @@
 
 @RunWith(JUnit4.class)
 public class MultibindingTest {
-  @Test public void testMultibindings() {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+  private MultibindingComponent multibindingComponent;
+
+  @Before public void setUp() {
+    multibindingComponent = DaggerMultibindingComponent.builder()
+        .multibindingDependency(new MultibindingDependency() {
+          @Override public double doubleDependency() {
+            return 0.0;
+          }
+        })
+        .build();
+  }
+
+  @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
+  }
+
+  @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
     assertThat(mapOfProviders).hasSize(2);
     assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
     assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+  }
+
+  @Test public void mapKeysAndValues() {
     assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
     assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
-    assertThat(multibindingComponent.set()).containsExactly(5, 6);
+  }
+
+  @Test public void nestedKeyMap() {
+    assertThat(multibindingComponent.nestedKeyMap()).isEqualTo(
+        ImmutableMap.of(
+            nestedWrappedKey(Integer.class), "integer",
+            nestedWrappedKey(Long.class), "long"));
+  }
+
+  @Test public void setBindings() {
+    assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
+  }
+
+  @AutoAnnotation
+  static TestKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
new file mode 100644
index 000000000..14c3e5385
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class NestedTest {
+  @Test public void nestedFoo() {
+    OuterClassFoo.NestedComponent nestedFoo = DaggerOuterClassFoo_NestedComponent.create();
+    assertThat(nestedFoo.thing()).isNotNull();
+  }
+
+  @Test public void nestedBar() {
+    OuterClassBar.NestedComponent nestedBar = DaggerOuterClassBar_NestedComponent.create();
+    assertThat(nestedBar.injectedThing()).isNotNull();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index a903b98a4..206a7e2d8 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -68,9 +68,6 @@ limitations under the License.
         <configuration>
           <source>1.6</source>
           <target>1.6</target>
-          <annotationProcessors>
-            <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
-          </annotationProcessors>
         </configuration>
       </plugin>
       <plugin>
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
index 75c07c7a3..15aa48165 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
@@ -15,6 +15,8 @@
 */
 package test;
 
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -24,7 +26,7 @@
 
 @RunWith(JUnit4.class)
 public class DependentTest {
-  @Test public void testDependentComponent() throws Exception {
+  @Test public void dependentComponent() throws Exception {
     DependentComponent dependentComponent = DaggerDependentComponent
         .builder()
         .dependedProductionComponent(DaggerDependedProductionComponent.builder()
@@ -37,4 +39,36 @@
     assertThat(dependentComponent.greetings().get()).containsExactly(
         "2", "Hello world!", "HELLO WORLD!");
   }
+
+  @Test public void reuseBuilderWithDependentComponent() throws Exception {
+    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent
+        .builder()
+        .executor(MoreExecutors.directExecutor());
+
+    DependentComponent componentUsingComponents = dependentComponentBuilder
+        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .build())
+        .dependedComponent(DaggerDependedComponent.create())
+        .build();
+
+    DependentComponent componentUsingJavaImpls = dependentComponentBuilder
+        .dependedProductionComponent(new DependedProductionComponent() {
+          @Override public ListenableFuture<Integer> numGreetings() {
+            return Futures.immediateFuture(3);
+          }
+        })
+        .dependedComponent(new DependedComponent() {
+          @Override public String getGreeting() {
+            return "Goodbye world!";
+          }
+        })
+        .build();
+
+    assertThat(componentUsingJavaImpls.greetings().get()).containsExactly(
+        "3", "Goodbye world!", "GOODBYE WORLD!");
+    assertThat(componentUsingComponents.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 4b05e88aa..edb8ad6b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -91,9 +91,9 @@ public TypeElement visitType(TypeElement e, Void p) {
 
   /**
    * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
-   * superset of {@link #dependencies()}.
+   * superset of {@link #dependencies()}.  This returns an unmodifiable set.
    */
-  abstract ImmutableSet<DependencyRequest> implicitDependencies();
+  abstract Set<DependencyRequest> implicitDependencies();
 
   /**
    * Returns the name of the package in which this binding must be managed. E.g.: a binding
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 77115015e..80e6c1187 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -32,11 +32,11 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
+
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -46,7 +46,6 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
@@ -75,53 +74,6 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
-  @AutoValue
-  abstract static class ResolvedBindings {
-    abstract BindingKey bindingKey();
-    abstract ImmutableSet<? extends Binding> ownedBindings();
-    abstract ImmutableSet<? extends Binding> inheritedBindings();
-
-    ImmutableSet<? extends Binding> bindings() {
-      return new ImmutableSet.Builder<Binding>()
-          .addAll(inheritedBindings())
-          .addAll(ownedBindings())
-          .build();
-    }
-
-    static ResolvedBindings create(
-        BindingKey bindingKey,
-        Set<? extends Binding> ownedBindings,
-        Set<? extends Binding> inheritedBindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(
-          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.copyOf(inheritedBindings));
-    }
-
-    static ResolvedBindings create(
-        BindingKey bindingKey,
-        Binding... ownedBindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(
-          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.<Binding>of());
-    }
-
-    @SuppressWarnings("unchecked")  // checked by validator
-    ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
-      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-      return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
-    }
-
-    @SuppressWarnings("unchecked")  // checked by validator
-    ImmutableSet<? extends ContributionBinding> contributionBindings() {
-      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-      return (ImmutableSet<? extends ContributionBinding>) bindings();
-    }
-
-    @SuppressWarnings("unchecked")  // checked by validator
-    ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
-      checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-      return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
-    }
-  }
-
   static final class Factory {
     private final Elements elements;
     private final Types types;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1b10497bc..74080ff8e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,7 +35,6 @@
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -63,6 +62,7 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -127,39 +127,47 @@
         subject.componentDescriptor().componentMethods()) {
       Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
       if (entryPoint.isPresent()) {
-        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(), subject,
-            reportBuilder);
+        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
+            Sets.<BindingKey>newHashSet(), subject, reportBuilder,
+            Sets.<DependencyRequest>newHashSet());
       }
     }
 
     validateSubcomponents(subject, reportBuilder);
-
     return reportBuilder.build();
   }
 
   private void traverseRequest(
       DependencyRequest request,
       Deque<ResolvedRequest> bindingPath,
+      Set<BindingKey> keysInPath,
       BindingGraph graph,
-      ValidationReport.Builder<BindingGraph> reportBuilder) {
+      ValidationReport.Builder<BindingGraph> reportBuilder,
+      Set<DependencyRequest> resolvedRequests) {
+    verify(bindingPath.size() == keysInPath.size(),
+        "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
     BindingKey requestKey = request.bindingKey();
-    for (ResolvedRequest pathElement : bindingPath) {
-      if (pathElement.request().bindingKey().equals(requestKey)) {
-        reportCycle(request, bindingPath, reportBuilder);
-        return;
-      }
+    if (keysInPath.contains(requestKey)) {
+      reportCycle(request, bindingPath, reportBuilder);
+      return;
     }
 
-    ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
-    bindingPath.push(resolvedRequest);
-    validateResolvedBinding(bindingPath, resolvedRequest.binding(), reportBuilder);
-
-    for (Binding binding : resolvedRequest.binding().bindings()) {
-      for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-        traverseRequest(nextRequest, bindingPath, graph, reportBuilder);
+     // If request has already been resolved, avoid re-traversing the binding path.
+    if (resolvedRequests.add(request)) {
+      ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
+      bindingPath.push(resolvedRequest);
+      keysInPath.add(requestKey);
+      validateResolvedBinding(bindingPath, resolvedRequest.binding(), reportBuilder);
+
+      for (Binding binding : resolvedRequest.binding().bindings()) {
+        for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+          traverseRequest(nextRequest, bindingPath, keysInPath, graph, reportBuilder,
+              resolvedRequests);
+        }
       }
+      bindingPath.poll();
+      keysInPath.remove(requestKey);
     }
-    bindingPath.poll();
   }
 
   private void validateSubcomponents(BindingGraph graph,
@@ -258,8 +266,8 @@ private boolean validateResolvedBinding(
   private boolean validateNullability(DependencyRequest request,
       Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
     boolean valid = true;
-    String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
     if (!request.isNullable()) {
+      String typeName = null;
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           String methodSignature;
@@ -275,6 +283,9 @@ private boolean validateNullability(DependencyRequest request,
           // (Maybe this happens if the code was already compiled before this point?)
           // ... we manually print ouf the request in that case, otherwise the error
           // message is kind of useless.
+          if (typeName == null) {
+            typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+          }
           reportBuilder.addItem(
               String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
               + "\n at: " + dependencyRequestFormatter.format(request),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 82903739a..3886ba1d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -46,7 +46,6 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -1162,9 +1161,13 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     switch(binding.bindingKind()) {
       case COMPONENT:
-        return Snippet.format("%s.<%s>create(this)",
+        MemberSelect componentContributionSelect =
+            contributionFields.get(MoreTypes.asTypeElement(binding.key().type()));
+        return Snippet.format("%s.<%s>create(%s)",
             ClassName.fromClass(InstanceFactory.class),
-            TypeNames.forTypeMirror(binding.key().type()));
+            TypeNames.forTypeMirror(binding.key().type()),
+            componentContributionSelect != null
+                ? componentContributionSelect.getSnippetFor(componentName) : "this");
       case COMPONENT_PROVISION:
         TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
         String sourceFieldName =
@@ -1249,18 +1252,23 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     switch (binding.bindingKind()) {
       case COMPONENT_PRODUCTION:
+        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
+        String sourceFieldName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
         return Snippet.format(Joiner.on('\n').join(
             "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %4$s;",
             "  @Override public %3$s<%2$s> get() {",
-            "    return %4$s.%5$s();",
+            "    return %7$s.%5$s();",
             "  }",
             "}"),
             ClassName.fromClass(Producer.class),
             TypeNames.forTypeMirror(binding.key().type()),
             ClassName.fromClass(ListenableFuture.class),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
-                .getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString());
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
+            binding.bindingElement().getSimpleName().toString(),
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         List<Snippet> parameters =
@@ -1421,8 +1429,9 @@ public Snippet apply(AnnotationValue value) {
       for (Snippet snippet : annotationValueNames) {
         snippets.add(snippet);
       }
-      argsBuilder.add(Snippet.format("%sCreator.create(%s)",
-          TypeNames.forTypeMirror(mapKeyAnnotationMirror.getAnnotationType()),
+      argsBuilder.add(Snippet.format("%s.create(%s)",
+          Util.getMapKeyCreatorClassName(
+              MoreTypes.asTypeElement(mapKeyAnnotationMirror.getAnnotationType())),
           Snippet.makeParametersSnippet(snippets.build())));
       argsBuilder.add(factory);
     } else { // unwrapped key case
@@ -1464,7 +1473,7 @@ public Snippet visitAnnotation(AnnotationMirror a, Void p) {
 
           @Override
           public Snippet visitType(TypeMirror t, Void p) {
-            return Snippet.format("%s", TypeNames.forTypeMirror(t));
+            return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
           }
 
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 75ff023e8..c7eb6326f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -237,8 +237,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           parametersSnippet);
 
       if (binding.provisionType().equals(SET)) {
-        getMethodWriter.body().addSnippet("return %s.singleton(%s);",
-            ClassName.fromClass(Collections.class), providesMethodInvocation);
+        TypeName paramTypeName = TypeNames.forTypeMirror(
+            MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
+        // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
+        getMethodWriter.body().addSnippet("return %s.<%s>singleton(%s);",
+            ClassName.fromClass(Collections.class), paramTypeName, providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
           || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index b11eeec9a..e0be1493a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -38,7 +38,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates implementations to create{@link MapKey} instances
+ * Generates implementations to create {@link MapKey} instances
  *
  * @author Chenying Hou
  * @since 2.0
@@ -50,9 +50,7 @@
 
   @Override
   ClassName nameGeneratedType(Element e) {
-    ClassName enclosingClassName = ClassName.fromTypeElement((TypeElement)e);
-    return enclosingClassName.topLevelClassName().peerNamed(
-        enclosingClassName.classFileName() + "Creator");
+    return Util.getMapKeyCreatorClassName((TypeElement) e);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 89383a292..aec51f038 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -63,11 +64,14 @@
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return new ImmutableSet.Builder<DependencyRequest>()
-        .addAll(memberInjectionRequest().asSet())
-        .addAll(dependencies())
-        .build();
+  Set<DependencyRequest> implicitDependencies() {
+    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
+    if (!memberInjectionRequest().isPresent()) {
+      return dependencies();
+    } else {
+      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
+      return Sets.union(memberInjectionRequest().asSet(), dependencies());
+    }
   }
 
   enum Kind {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
new file mode 100644
index 000000000..e44ba4ca7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * The collection of bindings that have been resolved for a binding key.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class ResolvedBindings {
+  abstract BindingKey bindingKey();
+  abstract ImmutableSet<? extends Binding> ownedBindings();
+  abstract ImmutableSet<? extends Binding> bindings();
+
+  static ResolvedBindings create(
+      BindingKey bindingKey,
+      Set<? extends Binding> ownedBindings,
+      Set<? extends Binding> inheritedBindings) {
+    ImmutableSet<Binding> immutableOwnedBindings = ImmutableSet.copyOf(ownedBindings);
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        immutableOwnedBindings,
+        ImmutableSet.<Binding>builder()
+        .addAll(inheritedBindings)
+        .addAll(immutableOwnedBindings)
+        .build());
+  }
+
+  static ResolvedBindings create(
+      BindingKey bindingKey,
+      Binding... ownedBindings) {
+    ImmutableSet<Binding> bindings = ImmutableSet.copyOf(ownedBindings);
+    return new AutoValue_ResolvedBindings(bindingKey, bindings, bindings);
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends ContributionBinding> contributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return (ImmutableSet<? extends ContributionBinding>) bindings();
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 7acb9d759..3adf6f6bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableSet.Builder;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.ClassName;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -111,6 +112,16 @@ protected TypeElement defaultAction(Object o, Void v) {
     return keyTypeElement;
   }
 
+  /**
+   * Returns the name of the generated class that contains the static {@code create} method for a
+   * {@code @MapKey} annotation type.
+   */
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
+    return enclosingClassName.topLevelClassName().peerNamed(
+        enclosingClassName.classFileName() + "Creator");
+  }
+
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 0c10d1984..74f33aeaa 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -369,6 +370,171 @@ public void mapBindingsWithStringKey() {
         .generatesSources(generatedComponent);
   }
 
+  @Test
+  public void mapBindingsWithWrappedKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @ClassKey(Integer.class) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @ClassKey(Long.class) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject classKeyFile = JavaFileObjects.forSourceLines("test.ClassKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface ClassKey {",
+        "  Class<?> value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<ClassKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<ClassKey, Provider<Handler>>>",
+        "      mapOfClassKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfClassKeyAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfClassKeyAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<ClassKey, Handler>builder(2)",
+        "            .put(ClassKeyCreator.create(Integer.class), mapOfClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(ClassKeyCreator.create(Long.class), mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<ClassKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfClassKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            classKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
   @Test
   public void mapBindingsWithNonProviderValue() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 6025b738b..b003a4fef 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -71,6 +71,53 @@ public void mapKeyCreatorFile() {
     .generatesSources(generatedKeyCreator);
   }
 
+  @Test
+  public void nestedMapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.Container",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "public interface Container {",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Container.PathKey",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public class Container$PathKeyCreator {",
+            "  @com.google.auto.value.AutoAnnotation",
+            "  public static PathKey create(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container$PathKeyCreator_create(value, relativePath);",
+            "  }",
+            "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
   @Test
   public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 2642497f2..0ec5f8083 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -622,7 +622,7 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return Collections.singleton(module.provideString());",
+        "    return Collections.<String>singleton(module.provideString());",
         "  }",
         "",
         "  public static Factory<Set<String>> create(TestModule module) {",
@@ -635,6 +635,58 @@ private String formatModuleErrorMessage(String msg) {
         .and().generatesSources(factoryFile);
   }
 
+  @Test public void providesSetElementWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import java.util.logging.Logger;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.ArrayList;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET) List<List<?>> provideWildcardList() {",
+        "    return new ArrayList<>();",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines(
+        "TestModule_ProvideWildcardListFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.Collections;",
+        "import java.util.List;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideWildcardListFactory implements "
+            + "Factory<Set<List<List<?>>>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<List<List<?>>> get() {",
+        "    return Collections.<List<List<?>>>singleton(module.provideWildcardList());",
+        "  }",
+        "",
+        "  public static Factory<Set<List<List<?>>>> create(TestModule module) {",
+        "    return new TestModule_ProvideWildcardListFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
   @Test public void providesSetValues() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
