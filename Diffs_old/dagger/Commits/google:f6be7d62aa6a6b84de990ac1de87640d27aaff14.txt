diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 261e1b270..3b9235915 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -58,7 +58,6 @@
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -88,6 +87,7 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MemberSelect.emptyMapProviderFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
@@ -97,7 +97,6 @@
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
@@ -984,8 +983,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
           }
-          parameters.addAll(
-              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER));
+          parameters.addAll(getDependencyParameterSnippets(binding));
 
           Snippet factorySnippet =
               Snippet.format(
@@ -1031,8 +1029,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           parameters.add(
               getComponentContributionSnippet(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(
-              getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PRODUCER));
+          parameters.addAll(getDependencyParameterSnippets(binding));
 
           return Snippet.format(
               "new %s(%s)",
@@ -1082,12 +1079,10 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
       case INJECT_MEMBERS:
-        List<Snippet> parameters =
-            getDependencyParameterSnippets(binding, DependencyRequestMapper.FOR_PROVIDER);
         return Snippet.format(
             "%s.create(%s)",
             membersInjectorNameForType(binding.bindingElement()),
-            Snippet.makeParametersSnippet(parameters));
+            makeParametersSnippet(getDependencyParameterSnippets(binding)));
       default:
         throw new AssertionError();
     }
@@ -1096,22 +1091,14 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
   /**
    * The snippets that represent factory arguments for the dependencies of a binding.
    */
-  private List<Snippet> getDependencyParameterSnippets(
-      Binding binding, DependencyRequestMapper dependencyRequestMapper) {
+  private ImmutableList<Snippet> getDependencyParameterSnippets(Binding binding) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> dependencyRequestsForUnresolvedKey :
-        indexDependenciesByUnresolvedKey(binding).asMap().values()) {
-      BindingKey requestedKey =
-          Iterables.getOnlyElement(
-              FluentIterable.from(dependencyRequestsForUnresolvedKey)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                  .toSet());
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      BindingKey requestedKey = frameworkDependency.bindingKey();
       Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetFor(name);
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
       if (resolvedBindings.frameworkClass().equals(Provider.class)
-          && dependencyRequestMapper
-              .getFrameworkClass(dependencyRequestsForUnresolvedKey)
-              .equals(Producer.class)) {
+          && frameworkDependency.frameworkClass().equals(Producer.class)) {
         parameters.add(
             Snippet.format(
                 "%s.producerFromProvider(%s)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index d67214d68..2906292b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -107,15 +107,12 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
 
-    this.factoryGenerator =
-        new FactoryGenerator(
-            filer, elements, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
-    this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, DependencyRequestMapper.FOR_PROVIDER);
+    this.factoryGenerator = new FactoryGenerator(filer, elements, nullableDiagnosticType);
+    this.membersInjectorGenerator = new MembersInjectorGenerator(filer, elements);
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements, DependencyRequestMapper.FOR_PRODUCER);
+        new ProducerFactoryGenerator(filer, elements);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index 1dc48fc8b..9ca294206 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -94,4 +94,8 @@
   }
 
   static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
+
+  static DependencyRequestMapper forBindingType(BindingType bindingType) {
+    return bindingType.equals(BindingType.PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 8b548c0db..993946571 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,7 +30,6 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
-import dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -49,10 +48,9 @@
 import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.TypeNames.factoryOf;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
@@ -60,6 +58,7 @@
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.TypeNames.factoryOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,16 +73,13 @@
  */
 final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
 
-  private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
   FactoryGenerator(
       Filer filer,
       Elements elements,
-      DependencyRequestMapper dependencyRequestMapper,
       Diagnostic.Kind nullableValidationType) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -112,8 +108,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     TypeSpec.Builder factoryBuilder;
     Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
     boolean useRawType =
         binding.factoryCreationStrategy() == ENUM_INSTANCE
             && binding.bindingKind() == INJECTION
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
new file mode 100644
index 000000000..57851cbf0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Maps;
+import java.util.Collection;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+/**
+ * The framework class and binding key for a resolved dependency of a binding. If a binding has
+ * several dependencies for a key, then only one instance of this class will represent them all.
+ *
+ * <p>In the following example, the binding {@code provideFoo()} has two dependency requests:
+ *
+ * <ol>
+ * <li>{@code Bar bar}
+ * <li>{@code Provider<Bar> barProvider}
+ * </ol>
+ *
+ * But they both can be satisfied with the same instance of {@code Provider<Bar>}. So one instance
+ * of {@code FrameworkDependency} will be used for both. Its {@link #bindingKey()} will be for
+ * {@code Bar}, and its {@link #frameworkClass()} will be {@link Provider}.
+ *
+ * <pre><code>
+ *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider<Bar>} barProvider) {
+ *     return new Foo(…);
+ *   }
+ * </code></pre>
+ */
+@AutoValue
+abstract class FrameworkDependency {
+
+  /**
+   * The fully-resolved binding key shared by all the dependency requests.
+   */
+  abstract BindingKey bindingKey();
+
+  /**
+   * The framework class to use for these requests.
+   */
+  abstract Class<?> frameworkClass();
+
+  /**
+   * The dependency requests that are all satisfied by one framework instance.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencyRequests();
+
+  /**
+   * The framework dependencies of {@code binding}. There will be one element for each
+   * different binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of
+   * {@code binding}.
+   *
+   * <p>For example, given the following modules:
+   * <pre><code>
+   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
+   *     {@literal @Provides} Foo provideFoo(T t, String string) {
+   *       return …;
+   *     }
+   *   }
+   *
+   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
+   * </code></pre>
+   *
+   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:
+   * {@code String}. But there are still two dependencies, because in the unresolved binding they
+   * have different binding keys:
+   *
+   * <dl>
+   * <dt>{@code T} <dd>{@code String t}
+   * <dt>{@code String} <dd>{@code String string}
+   * </dl>
+   * 
+   * <p>Note that the sets returned by this method when called on the same binding will be equal,
+   * and their elements will be in the same order.
+   */
+  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
+   * instances of Binding, because it really depends on the order of the binding's dependencies,
+   * and two equal instances of Binding may have the same dependencies in a different order. */
+  static ImmutableSet<FrameworkDependency> frameworkDependenciesForBinding(Binding binding) {
+    DependencyRequestMapper dependencyRequestMapper =
+        DependencyRequestMapper.forBindingType(binding.bindingType());
+    ImmutableSet.Builder<FrameworkDependency> frameworkDependencies = ImmutableSet.builder();
+    for (Collection<DependencyRequest> requests : groupByUnresolvedKey(binding)) {
+      frameworkDependencies.add(
+          new AutoValue_FrameworkDependency(
+              getOnlyElement(
+                  FluentIterable.from(requests)
+                      .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                      .toSet()),
+              dependencyRequestMapper.getFrameworkClass(requests),
+              ImmutableSet.copyOf(requests)));
+    }
+    return frameworkDependencies.build();
+  }
+
+  /**
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   */
+  private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
+      Binding binding) {
+    // If the binding has no unresolved version, just group the dependencies by binding key.
+    if (!binding.unresolved().isPresent()) {
+      return groupByKey(binding, Functions.<DependencyRequest>identity());
+    }
+
+    // Group the unresolved dependencies, replacing each one with its resolved version by looking it
+    // up by request element.
+    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
+        Maps.uniqueIndex(
+            binding.implicitDependencies(),
+            new Function<DependencyRequest, Element>() {
+              @Override
+              public Element apply(DependencyRequest dependencyRequest) {
+                return dependencyRequest.requestElement();
+              }
+            });
+    return groupByKey(
+        binding.unresolved().get(),
+        new Function<DependencyRequest, DependencyRequest>() {
+          @Override
+          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
+            return resolvedDependencies.get(unresolvedRequest.requestElement());
+          }
+        });
+  }
+
+  /**
+   * Groups a binding's dependency requests by their binding key.
+   *
+   * @param transformer applied to each dependency before inserting into the group
+   */
+  private static ImmutableList<Collection<DependencyRequest>> groupByKey(
+      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : binding.implicitDependencies()) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
+    }
+    return ImmutableList.copyOf(
+        dependenciesByKeyBuilder
+            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+            .build()
+            .asMap()
+            .values());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index d4539a8f6..c672a9521 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -56,12 +56,12 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
-import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,12 +74,9 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
-  private final DependencyRequestMapper dependencyRequestMapper;
 
-  MembersInjectorGenerator(
-      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+  MembersInjectorGenerator(Filer filer, Elements elements) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -125,7 +122,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
             .addCode("}");
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+        SourceFiles.generateBindingFieldsForDependencies(binding);
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 4741ef5b0..ea8e3d308 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -46,16 +46,16 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
-import static dagger.internal.codegen.TypeNames.abstractProducerOf;
-import static dagger.internal.codegen.TypeNames.listOf;
-import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
-import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
+import static dagger.internal.codegen.TypeNames.listOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -71,12 +71,8 @@
  */
 final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
 
-  private final DependencyRequestMapper dependencyRequestMapper;
-
-  ProducerFactoryGenerator(
-      Filer filer, Elements elements, DependencyRequestMapper dependencyRequestMapper) {
+  ProducerFactoryGenerator(Filer filer, Elements elements) {
     super(filer, elements);
-    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -104,7 +100,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .superclass(abstractProducerOf(providedTypeName));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
+        SourceFiles.generateBindingFieldsForDependencies(binding);
 
     MethodSpec.Builder constructorBuilder =
         constructorBuilder()
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index f7b2f8ee9..4731ea641 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,19 +14,14 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Splitter;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeVariableName;
@@ -35,14 +30,7 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -50,6 +38,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
 
 /**
@@ -80,62 +69,6 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   *
-   * <p>Consider a generic type {@code Foo<T>} with a constructor {@code Foo(T t, T t1, A a, A a1)}.
-   * Its factory's {@code create} method should take only two parameters:
-   * {@code create(Provider<T> tProvider, Provider<A> aProvider)}. However, if the component
-   * initializes a factory for {@code Foo<A>}, it really has only one dependency:
-   * both arguments should be the same {@code Provider<A>}. In order to get the right number of
-   * arguments, we have to index resolved binding's dependencies by their keys in the unresolved
-   * version of the binding.
-   */
-  // TODO(dpb): Move this to DependencyRequest.
-  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Binding binding) {
-    // If the binding is already fully resolved, just index the dependencies by binding key.
-    if (!binding.unresolved().isPresent()) {
-      return indexDependenciesByKey(binding, Functions.<DependencyRequest>identity());
-    }
-    
-    // Index the unresolved dependencies, replacing each one with its resolved version by looking it
-    // up by request element.
-    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
-        Maps.uniqueIndex(
-            binding.implicitDependencies(),
-            new Function<DependencyRequest, Element>() {
-              @Override
-              public Element apply(DependencyRequest dependencyRequest) {
-                return dependencyRequest.requestElement();
-              }
-            });
-    return indexDependenciesByKey(
-        binding.unresolved().get(),
-        new Function<DependencyRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
-            return resolvedDependencies.get(unresolvedRequest.requestElement());
-          }
-        });
-  }
-
-  /**
-   * Groups a binding's dependency requests by their binding key.
-   *
-   * @param transformer applied to each dependency before inserting into the multimap
-   */
-  private static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
-      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : binding.implicitDependencies()) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
-    }
-    return dependenciesByKeyBuilder.orderValuesBy(DEPENDENCY_ORDERING).build();
-  }
-
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
    * all of the dependencies of {@code binding}. It is responsible for choosing a name that
@@ -145,51 +78,50 @@ public DependencyRequest apply(DependencyRequest unresolvedRequest) {
    * <li>is <i>probably</i> associated with the type being bound
    * <li>is unique within the class
    * </ul>
-   *
+   * 
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
-      DependencyRequestMapper dependencyRequestMapper, Binding binding) {
-    ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByUnresolvedKey(binding);
-    Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
-        dependenciesByKey.asMap();
+      Binding binding) {
+    checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
+
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (Entry<BindingKey, Collection<DependencyRequest>> entry
-        : dependenciesByKeyMap.entrySet()) {
-      BindingKey bindingKey = entry.getKey();
-      Collection<DependencyRequest> requests = entry.getValue();
-      Class<?> frameworkClass =
-          dependencyRequestMapper.getFrameworkClass(requests.iterator().next());
-      // collect together all of the names that we would want to call the provider
-      ImmutableSet<String> dependencyNames =
-          FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
-    
-      if (dependencyNames.size() == 1) {
-        // if there's only one name, great! use it!
-        String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(
-            bindingKey,
-            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey.key(), name));
-      } else {
-        // in the event that a field is being used for a bunch of deps with different names,
-        // add all the names together with "And"s in the middle. E.g.: stringAndS
-        Iterator<String> namesIterator = dependencyNames.iterator();
-        String first = namesIterator.next();
-        StringBuilder compositeNameBuilder = new StringBuilder(first);
-        while (namesIterator.hasNext()) {
-          compositeNameBuilder.append("And").append(
-              CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
-        }
-        bindingFields.put(
-            bindingKey,
-            FrameworkField.createWithTypeFromKey(
-                frameworkClass, bindingKey.key(), compositeNameBuilder.toString()));
-      }
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      bindingFields.put(
+          frameworkDependency.bindingKey(),
+          FrameworkField.createWithTypeFromKey(
+              frameworkDependency.frameworkClass(),
+              frameworkDependency.bindingKey().key(),
+              fieldNameForDependency(frameworkDependency)));
     }
     return bindingFields.build();
   }
 
+  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {
+    // collect together all of the names that we would want to call the provider
+    ImmutableSet<String> dependencyNames =
+        FluentIterable.from(frameworkDependency.dependencyRequests())
+            .transform(new DependencyVariableNamer())
+            .toSet();
+
+    if (dependencyNames.size() == 1) {
+      // if there's only one name, great! use it!
+      return Iterables.getOnlyElement(dependencyNames);
+    } else {
+      // in the event that a field is being used for a bunch of deps with different names,
+      // add all the names together with "And"s in the middle. E.g.: stringAndS
+      Iterator<String> namesIterator = dependencyNames.iterator();
+      String first = namesIterator.next();
+      StringBuilder compositeNameBuilder = new StringBuilder(first);
+      while (namesIterator.hasNext()) {
+        compositeNameBuilder
+            .append("And")
+            .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+      }
+      return compositeNameBuilder.toString();
+    }
+  }
+
   static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
