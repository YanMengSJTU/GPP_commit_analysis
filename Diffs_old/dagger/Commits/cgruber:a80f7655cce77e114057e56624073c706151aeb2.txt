diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 6e24cf46c..11e586cf5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -45,6 +45,7 @@
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.VoidName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.VoidName;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -69,6 +70,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -105,12 +107,23 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
 
   @Override
   JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
-    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
+    ClassName componentDefinitionTypeName =
+        ClassName.fromTypeElement(input.componentDefinitionType());
 
+    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
-    componentWriter.addImplementedType(input.componentDefinitionType());
+    componentWriter.addImplementedType(componentDefinitionTypeName);
+
+    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
+    builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
+
+    builderWriter.addConstructor().addModifiers(PRIVATE);
+
+    MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
+    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
     ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
         input.resolvedProvisionBindings();
@@ -132,18 +145,56 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
             })));
 
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+
+    MethodWriter buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+    buildMethod.addModifiers(PUBLIC);
+
+    boolean requiresBuilder = false;
+
     for (Entry<TypeElement, String> entry : moduleNames.entrySet()) {
-      componentWriter.addField(entry.getKey(), entry.getValue())
+      TypeElement moduleElement = entry.getKey();
+      String moduleName = entry.getValue();
+      componentWriter.addField(moduleElement, moduleName)
           .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(entry.getKey(), entry.getValue());
+      builderWriter.addField(moduleElement, moduleName)
+          .addModifiers(PRIVATE);
       constructorWriter.body()
-          .addSnippet("if (%s == null) {", entry.getValue())
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(entry.getValue()))
+          .addSnippet("this.%1$s = builder.%1$s;", moduleName);
+      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, moduleName);
+      builderMethod.addModifiers(PUBLIC);
+      builderMethod.addParameter(moduleElement, moduleName);
+      builderMethod.body()
+          .addSnippet("if (%s == null) {", moduleName)
+          .addSnippet("  throw new NullPointerException(%s);", StringLiteral.forValue(moduleName))
           .addSnippet("}")
-          .addSnippet("this.%1$s = %1$s;", entry.getValue());
+          .addSnippet("this.%1$s = %1$s;", moduleName)
+          .addSnippet("return this;");
+      if (Util.getNoArgsConstructor(moduleElement) == null) {
+        requiresBuilder = true;
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", moduleName)
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");", moduleName)
+            .addSnippet("}");
+      } else {
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", moduleName)
+            .addSnippet("  this.%s = new %s();",
+                moduleName, ClassName.fromTypeElement(moduleElement))
+            .addSnippet("}");
+      }
+    }
+
+    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
 
+    // this will eventually need to be modules & components
+    if (!requiresBuilder) {
+      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod.body().addSnippet("return builder().build();");
     }
 
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 4fffc757c..922eadfe8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -100,6 +100,13 @@ public MethodWriter addMethod(Class<?> returnType, String name) {
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
@@ -120,22 +127,25 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
         implementedTypesIterator.next().write(appendable, context);
       }
     }
-    appendable.append(" {\n");
+    appendable.append(" {");
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
     for (VariableWriter fieldWriter : fieldWriters) {
       fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
     }
-    appendable.append('\n');
     for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
       if (!isDefaultConstructor(constructorWriter)) {
         constructorWriter.write(new IndentingAppendable(appendable), context);
       }
     }
-    appendable.append('\n');
     for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
       methodWriter.write(new IndentingAppendable(appendable), context);
     }
-    appendable.append('\n');
     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
       nestedTypeWriter.write(new IndentingAppendable(appendable), context);
     }
     appendable.append("}\n");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
index 9d93b50c7..4477f92d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
@@ -20,6 +20,10 @@ public void setInitializer(Snippet initializer) {
     this.initializer = Optional.of(initializer);
   }
 
+  public void setInitializer(String initializer, Object... args) {
+    this.initializer = Optional.of(Snippet.format(initializer, args));
+  }
+
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     super.write(appendable, context);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
new file mode 100644
index 000000000..30a76fc44
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
@@ -0,0 +1,5 @@
+package dagger.internal.codegen.writer;
+
+interface HasTypeName {
+  TypeName name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 7750f7e53..696d33df2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -10,7 +10,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
 import com.google.common.io.Closer;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.util.List;
 import java.util.Set;
@@ -110,11 +112,19 @@ public Appendable write(Appendable appendable) throws IOException {
         .addAll(explicitImports)
         .addAll(classNames)
         .build();
+    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet();
     for (ClassName className : importCandidates) {
       if (!(className.packageName().equals(packageName)
               && !className.enclosingClassName().isPresent())
           && !(className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty())) {
+              && className.enclosingSimpleNames().isEmpty())
+          && !typeNames.contains(className.topLevelClassName())) {
         Optional<ClassName> importCandidate = Optional.of(className);
         while (importCandidate.isPresent()
             && importedClassIndex.containsKey(importCandidate.get().simpleName())) {
@@ -130,11 +140,11 @@ public Appendable write(Appendable appendable) throws IOException {
     appendable.append('\n');
 
     CompilationUnitContext context =
-        new CompilationUnitContext(ImmutableSet.copyOf(importedClassIndex.values()));
+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));
 
     // write types
     for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.write(appendable, context).append('\n');
+      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\n');
     }
     return appendable;
   }
@@ -169,13 +179,19 @@ public String toString() {
   }
 
 
+  static final class CompilationUnitContext implements Writable.Context {
+    private final String packageName;
+    private final ImmutableSortedSet<ClassName> visibleClasses;
 
-  final class CompilationUnitContext implements Writable.Context {
-    private final ImmutableSortedSet<ClassName> importedClasses;
+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {
+      this.packageName = packageName;
+      this.visibleClasses =
+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);
+    }
 
-    CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {
-      this.importedClasses =
-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));
     }
 
     @Override
@@ -197,7 +213,7 @@ public String sourceReferenceForClassName(ClassName className) {
     private boolean isImported(ClassName className) {
       return (packageName.equals(className.packageName())
               && !className.enclosingClassName().isPresent()) // need to account for scope & hiding
-          || importedClasses.contains(className)
+          || visibleClasses.contains(className)
           || (className.packageName().equals("java.lang")
               && className.enclosingSimpleNames().isEmpty());
     }
@@ -207,9 +223,8 @@ private boolean isImported(ClassName className) {
 
     @Override
     public String compressTypesWithin(String snippet) {
-
       // TODO(gak): deal with string literals
-      for (ClassName importedClass : importedClasses) {
+      for (ClassName importedClass : visibleClasses) {
         snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());
       }
       Pattern samePackagePattern = Pattern.compile(
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 3f6154360..d8d71c8e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -10,6 +10,7 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+import javax.lang.model.element.TypeElement;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -31,6 +32,10 @@ public VariableWriter addParameter(Class<?> type, String name) {
     return addParameter(ClassName.fromClass(type), name);
   }
 
+  public VariableWriter addParameter(TypeElement type, String name) {
+    return addParameter(ClassName.fromTypeElement(type), name);
+  }
+
   public VariableWriter addParameter(TypeWriter type, String name) {
     return addParameter(type.name, name);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index db7780077..cbd0af712 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -57,6 +57,9 @@ public static Snippet format(String format, Object... args) {
       if (arg instanceof TypeName) {
         types.add((TypeName) arg);
       }
+      if (arg instanceof HasTypeName) {
+        types.add(((HasTypeName) arg).name());
+      }
     }
     return new Snippet(value, types.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index a49e765cc..a18c68cb0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -9,7 +9,7 @@
  * Only named types. Doesn't cover anonymous inner classes.
  */
 public abstract class TypeWriter /* ha ha */ extends Modifiable
-    implements Writable, TypeName {
+    implements Writable, HasTypeName, HasClassReferences {
   final ClassName name;
   Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
@@ -19,4 +19,9 @@
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
   }
+
+  @Override
+  public TypeName name() {
+    return name;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
index 65e5c124b..2ef319744 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -1,11 +1,13 @@
 package dagger.internal.codegen.writer;
 
 import java.io.IOException;
+import java.util.Set;
 
 interface Writable {
   interface Context {
     String sourceReferenceForClassName(ClassName className);
     String compressTypesWithin(String snippet);
+    Context createSubcontext(Set<ClassName> newTypes);
   }
 
   Appendable write(Appendable appendable, Context context) throws IOException;
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index ac0f41d87..8db7a2f6c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -2,6 +2,7 @@
 
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Set;
 
 final class Writables {
   static Writable toStringWritable(final Object object) {
@@ -23,6 +24,11 @@ public String sourceReferenceForClassName(ClassName className) {
     public String compressTypesWithin(String snippet) {
       return snippet;
     }
+
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      throw new UnsupportedOperationException();
+    }
   };
 
   static String writeToString(Writable writable) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a8a67c51d..8aec49fdd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -122,21 +122,42 @@
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
         "",
-        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
         "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
         "  }",
         "",
-        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
         "    return someInjectableTypeProvider;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -184,22 +205,43 @@
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider =",
         "        ScopedProvider.create(new SomeInjectableType$$Factory());",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
         "",
-        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
         "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
         "  }",
         "",
-        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
         "    return someInjectableTypeProvider;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -284,17 +326,38 @@
         "  private final Provider<A> aProvider;",
         "  private final MembersInjector<B> bMembersInjector;",
         "",
-        "  public Dagger_OuterType$SimpleComponent() {",
+        "  private Dagger_OuterType$SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.aProvider = new OuterType$A$$Factory();",
         "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
         "  }",
         "",
-        "  @Override public A a() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
-        "  @Override public void inject(B b) {",
+        "",
+        "  @Override",
+        "  public void inject(B b) {",
         "    bMembersInjector.injectMembers(b);",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_OuterType$SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
      ASSERT.about(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
@@ -360,19 +423,46 @@
         "  private final Provider<B> bProvider;",
         "  private final Provider<C> cProvider;",
         "",
-        "  public Dagger_TestComponent(TestModule testModule) {",
-        "    if (testModule == null) {",
-        "      throw new NullPointerException(\"testModule\");",
-        "    }",
-        "    this.testModule = testModule;",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.testModule = builder.testModule;",
         "    this.cProvider = new C$$Factory();",
         "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
         "    this.aProvider = new A$$Factory(bProvider);",
         "  }",
         "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
         "  @Override public A a() {",
         "    return aProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
@@ -435,23 +525,60 @@
         "  private final SetModule setModule;",
         "  private final Provider<Set<String>> setOfStringProvider;",
         "",
-        "  public Dagger_TestComponent(EmptySetModule emptySetModule, SetModule setModule) {",
-        "    if (emptySetModule == null) {",
-        "      throw new NullPointerException(\"emptySetModule\");",
-        "    }",
-        "    this.emptySetModule = emptySetModule;",
-        "    if (setModule == null) {",
-        "      throw new NullPointerException(\"setModule\");",
-        "    }",
-        "    this.setModule = setModule;",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.emptySetModule = builder.emptySetModule;",
+        "    this.setModule = builder.setModule;",
         "    this.setOfStringProvider = SetFactory.create(",
-        "        new EmptySetModule$$EmptySetFactory(emptySetModule),",
-        "        new SetModule$$StringFactory(setModule));",
+        "    new EmptySetModule$$EmptySetFactory(emptySetModule), new SetModule$$StringFactory(setModule));",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
         "  }",
         "",
-        "  @Override public Set<String> strings() {",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Set<String> strings() {",
         "    return setOfStringProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private EmptySetModule emptySetModule;",
+        "    private SetModule setModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (emptySetModule == null) {",
+        "        this.emptySetModule = new EmptySetModule();",
+        "      }",
+        "      if (setModule == null) {",
+        "        this.setModule = new SetModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+        "      if (emptySetModule == null) {",
+        "        throw new NullPointerException(\"emptySetModule\");",
+        "      }",
+        "      this.emptySetModule = emptySetModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder setModule(SetModule setModule) {",
+        "      if (setModule == null) {",
+        "        throw new NullPointerException(\"setModule\");",
+        "      }",
+        "      this.setModule = setModule;",
+        "      return this;",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
@@ -504,12 +631,21 @@
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector = ",
+        "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
         "  }",
         "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
         "  @Override public void inject(SomeInjectedType instance) {",
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "  }",
@@ -518,6 +654,14 @@
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
@@ -560,15 +704,34 @@
         "  private final Provider<SimpleComponent> simpleComponentProvider;",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
         "        new SomeInjectableType$$Factory(simpleComponentProvider);",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -617,17 +780,36 @@
         "  private final Provider<SomeInjectedType> someInjectedTypeProvider;",
         "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector = ",
+        "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
-        "    this.someInjectedTypeProvider = ",
+        "    this.someInjectedTypeProvider =",
         "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
         "  }",
         "",
-        "  @Override public SomeInjectedType createAndInject() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType createAndInject() {",
         "    return someInjectedTypeProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
     ASSERT.about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 9f83b1c1a..8d18c50f1 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -70,6 +70,7 @@
   JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
       "test.Dagger_PrimitiveComponent",
       "package test;",
+      "",
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
@@ -78,23 +79,54 @@
       "  private final PrimitiveModule primitiveModule;",
       "  private final Provider<PrimitiveInjectable> primitiveInjectableProvider;",
       "  private final Provider<Integer> primitiveIntProvider;",
-      "  public Dagger_PrimitiveComponent(PrimitiveModule primitiveModule) {",
-      "    if (primitiveModule == null) {",
-      "      throw new NullPointerException(\"primitiveModule\");",
-      "    }",
-      "    this.primitiveModule = primitiveModule;",
+      "",
+      "  private Dagger_PrimitiveComponent(Builder builder) {",
+      "    assert builder != null;",
+      "    this.primitiveModule = builder.primitiveModule;",
       "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
-      "    this.primitiveInjectableProvider = ",
+      "    this.primitiveInjectableProvider =",
       "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
       "  }",
+      "",
+      "  public static Builder builder() {",
+      "    return new Builder();",
+      "  }",
+      "",
+      "  public static PrimitiveComponent create() {",
+      "    return builder().build();",
+      "  }",
+      "",
       "  @Override",
       "  public int primitiveInt() {",
       "    return primitiveIntProvider.get();",
       "  }",
+      "",
       "  @Override",
       "  public PrimitiveInjectable primitiveInjectable() {",
       "    return primitiveInjectableProvider.get();",
       "  }",
+      "",
+      "  public static final class Builder {",
+      "    private PrimitiveModule primitiveModule;",
+      "",
+      "    private Builder() {",
+      "    }",
+      "",
+      "    public PrimitiveComponent build() {",
+      "      if (primitiveModule == null) {",
+      "        this.primitiveModule = new PrimitiveModule();",
+      "      }",
+      "      return new Dagger_PrimitiveComponent(this);",
+      "    }",
+      "",
+      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+      "      if (primitiveModule == null) {",
+      "        throw new NullPointerException(\"primitiveModule\");",
+      "      }",
+      "      this.primitiveModule = primitiveModule;",
+      "      return this;",
+      "    }",
+      "  }",
       "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
