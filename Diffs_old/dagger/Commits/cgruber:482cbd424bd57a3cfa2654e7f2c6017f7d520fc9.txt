diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
index a0e89ed71..9cdd5965a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
@@ -18,7 +18,7 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestStringKey {
+public @interface TestStringKey {
   String value();
 
   @MapKey(unwrapValue = false)
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
index 8a8bfa7d0..4b61cf072 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
@@ -17,7 +17,9 @@
 
 import dagger.Module;
 import dagger.Provides;
+import test.TestStringKey;
 
+import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
 
 @Module
@@ -27,4 +29,10 @@
   Object childObject() {
     return "object provided by child";
   }
+
+  @Provides(type = MAP)
+  @TestStringKey("child key")
+  Object childKeyObject() {
+    return "object in child";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
index 578de707e..61bad5ea3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
@@ -17,7 +17,9 @@
 
 import dagger.Module;
 import dagger.Provides;
+import test.TestStringKey;
 
+import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
 
 @Module
@@ -34,7 +36,20 @@ String provideString() {
   }
 
   @Provides(type = SET)
-  RequiresSetOfObjects requiresSetOfObjects(RequiresSetOfObjects requiresSetOfObjects) {
-    return requiresSetOfObjects;
+  RequiresMultiboundObjects requiresMultiboundObjects(
+      RequiresMultiboundObjects requiresMultiboundObjects) {
+    return requiresMultiboundObjects;
+  }
+
+  @Provides(type = MAP)
+  @TestStringKey("parent key")
+  String parentKeyString() {
+    return "string in parent";
+  }
+
+  @Provides(type = MAP)
+  @TestStringKey("parent key")
+  Object parentKeyObject() {
+    return "object in parent";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
index e324fdf10..4ec0469de 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
@@ -22,9 +22,9 @@
 
   @Inject
   RequiresMultibindingsInChild(
-      RequiresSetOfObjects requiresSetOfObjects,
-      RequiresSetOfStrings requiresSetOfStrings,
-      Set<RequiresSetOfObjects> setOfRequiresSetOfObjects) {
-    super(requiresSetOfObjects, requiresSetOfStrings, setOfRequiresSetOfObjects);
+      RequiresMultiboundObjects requiresMultiboundObjects,
+      RequiresMultiboundStrings requiresMultiboundStrings,
+      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
+    super(requiresMultiboundObjects, requiresMultiboundStrings, setOfRequiresMultiboundObjects);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
index 73a56d955..a48d38bfa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
@@ -19,29 +19,29 @@
 import javax.inject.Inject;
 
 class RequiresMultibindingsInParent {
-  private final RequiresSetOfObjects requiresSetOfObjects;
-  private final RequiresSetOfStrings requiresSetOfStrings;
-  private final Set<RequiresSetOfObjects> setOfRequiresSetOfObjects;
+  private final RequiresMultiboundObjects requiresMultiboundObjects;
+  private final RequiresMultiboundStrings requiresMultiboundStrings;
+  private final Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects;
 
   @Inject
   RequiresMultibindingsInParent(
-      RequiresSetOfObjects requiresSetOfObjects,
-      RequiresSetOfStrings requiresSetOfStrings,
-      Set<RequiresSetOfObjects> setOfRequiresSetOfObjects) {
-    this.requiresSetOfObjects = requiresSetOfObjects;
-    this.requiresSetOfStrings = requiresSetOfStrings;
-    this.setOfRequiresSetOfObjects = setOfRequiresSetOfObjects;
+      RequiresMultiboundObjects requiresMultiboundObjects,
+      RequiresMultiboundStrings requiresMultiboundStrings,
+      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
+    this.requiresMultiboundObjects = requiresMultiboundObjects;
+    this.requiresMultiboundStrings = requiresMultiboundStrings;
+    this.setOfRequiresMultiboundObjects = setOfRequiresMultiboundObjects;
   }
 
-  RequiresSetOfObjects requiresSetOfObjects() {
-    return requiresSetOfObjects;
+  RequiresMultiboundObjects requiresMultiboundObjects() {
+    return requiresMultiboundObjects;
   }
 
-  RequiresSetOfStrings requiresSetOfStrings() {
-    return requiresSetOfStrings;
+  RequiresMultiboundStrings requiresMultiboundStrings() {
+    return requiresMultiboundStrings;
   }
 
-  Set<RequiresSetOfObjects> setOfRequiresSetOfObjects() {
-    return setOfRequiresSetOfObjects;
+  Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects() {
+    return setOfRequiresMultiboundObjects;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
similarity index 69%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
index 447ac61dc..d787153e3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
@@ -15,18 +15,25 @@
  */
 package test.subcomponent;
 
+import java.util.Map;
 import java.util.Set;
 import javax.inject.Inject;
 
-class RequiresSetOfObjects {
-  private Set<Object> setOfObjects;
+class RequiresMultiboundObjects {
+  private final Set<Object> setOfObjects;
+  private final Map<String, Object> mapOfObjects;
 
   @Inject
-  RequiresSetOfObjects(Set<Object> setOfObjects) {
+  RequiresMultiboundObjects(Set<Object> setOfObjects, Map<String, Object> mapOfObjects) {
     this.setOfObjects = setOfObjects;
+    this.mapOfObjects = mapOfObjects;
   }
 
   Set<Object> setOfObjects() {
     return setOfObjects;
   }
+
+  Map<String, Object> mapOfObjects() {
+    return mapOfObjects;
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
similarity index 69%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
index 37eaea95d..410bdf2c0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
@@ -15,18 +15,25 @@
  */
 package test.subcomponent;
 
+import java.util.Map;
 import java.util.Set;
 import javax.inject.Inject;
 
-class RequiresSetOfStrings {
-  private Set<String> setOfStrings;
+class RequiresMultiboundStrings {
+  private final Set<String> setOfStrings;
+  private final Map<String, String> mapOfStrings;
 
   @Inject
-  RequiresSetOfStrings(Set<String> setOfStrings) {
+  RequiresMultiboundStrings(Set<String> setOfStrings, Map<String, String> mapOfStrings) {
     this.setOfStrings = setOfStrings;
+    this.mapOfStrings = mapOfStrings;
   }
 
   Set<String> setOfStrings() {
     return setOfStrings;
   }
+
+  Map<String, String> mapOfStrings() {
+    return mapOfStrings;
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index f4ae9ef2a..f57a77831 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -16,6 +16,7 @@
 package test.subcomponent;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,13 +47,22 @@ public void testMultibindingsInSubcomponents() {
     RequiresMultibindingsInChild requiresMultibindingsInChild =
         parent.childComponent().requiresMultibindingsInChild();
 
-    assertWithMessage("requiresSetOfObjects")
-        .that(requiresMultibindingsInChild.requiresSetOfObjects().setOfObjects())
+    assertWithMessage("requiresMultiboundObjects.setOfObjects")
+        .that(requiresMultibindingsInChild.requiresMultiboundObjects().setOfObjects())
         .containsExactly("object provided by parent", "object provided by child");
 
-    assertWithMessage("requiresSetOfStrings")
-        .that(requiresMultibindingsInChild.requiresSetOfStrings().setOfStrings())
+    assertWithMessage("requiresMultiboundObjects.mapOfObjects")
+        .that(requiresMultibindingsInChild.requiresMultiboundObjects().mapOfObjects())
+        .isEqualTo(
+            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
+
+    assertWithMessage("requiresMultiboundStrings")
+        .that(requiresMultibindingsInChild.requiresMultiboundStrings().setOfStrings())
         .containsExactly("string provided by parent");
+
+    assertWithMessage("requiresMultiboundStrings.mapOfStrings")
+        .that(requiresMultibindingsInChild.requiresMultiboundStrings().mapOfStrings())
+        .isEqualTo(ImmutableMap.of("parent key", "string in parent"));
   }
 
   @Test
@@ -60,15 +70,20 @@ public void testOverriddenMultibindingsInSubcomponents() {
     RequiresMultibindingsInChild requiresMultibindingsInChild =
         parent.childComponent().requiresMultibindingsInChild();
 
-    assertWithMessage("setOfRequiresSetOfObjects")
-        .that(requiresMultibindingsInChild.setOfRequiresSetOfObjects())
+    assertWithMessage("setOfRequiresMultiboundObjects")
+        .that(requiresMultibindingsInChild.setOfRequiresMultiboundObjects())
         .hasSize(1);
 
-    RequiresSetOfObjects onlyElementInSetOfRequiresSetOfObjects =
-        getOnlyElement(requiresMultibindingsInChild.setOfRequiresSetOfObjects());
+    RequiresMultiboundObjects onlyElementInMultiboundRequiresMultiboundObjects =
+        getOnlyElement(requiresMultibindingsInChild.setOfRequiresMultiboundObjects());
 
-    assertWithMessage("setOfRequiresSetOfObjects[only].setOfObjects")
-        .that(onlyElementInSetOfRequiresSetOfObjects.setOfObjects())
+    assertWithMessage("setOfRequiresMultiboundObjects[only].setOfObjects")
+        .that(onlyElementInMultiboundRequiresMultiboundObjects.setOfObjects())
         .containsExactly("object provided by parent", "object provided by child");
+
+    assertWithMessage("setOfRequiresMultiboundObjects[only].mapOfObjects")
+        .that(onlyElementInMultiboundRequiresMultiboundObjects.mapOfObjects())
+        .isEqualTo(
+            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 604c59f5d..567ef472f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -66,6 +66,7 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
@@ -73,6 +74,7 @@
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 
@@ -230,18 +232,25 @@ private boolean validateResolvedBinding(
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if ((provisionBindings.size() + productionBindings.size()) <= 1) {
+          if (combined.size() <= 1) {
             return true;
           }
           ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-              ContributionBinding.bindingTypesFor(
-                  Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
+              ContributionBinding.bindingTypesFor(combined);
           if (bindingsByType.keySet().size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
-          } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-            reportDuplicateBindings(path);
-            return false;
+          }
+          switch (getOnlyElement(bindingsByType.keySet())) {
+            case UNIQUE:
+              reportDuplicateBindings(path);
+              return false;
+            case MAP:
+              return !hasDuplicateMapKeys(path, combined);
+            case SET:
+              break;
+            default:
+              throw new AssertionError();
           }
           break;
         case MEMBERS_INJECTION:
@@ -302,6 +311,23 @@ private boolean validateNullability(
       return valid;
     }
 
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
+     * for the same map key.
+     */
+    private boolean hasDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Set<? extends ContributionBinding> mapBindings) {
+      boolean hasDuplicateMapKeys = false;
+      for (Collection<ContributionBinding> mapBindingsForMapKey :
+          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
+        if (mapBindingsForMapKey.size() > 1) {
+          hasDuplicateMapKeys = true;
+          reportDuplicateMapKeys(path, mapBindingsForMapKey);
+        }
+      }
+      return hasDuplicateMapKeys;
+    }
+
     /**
      * Validates a members injection binding, returning false (and reporting the error) if it wasn't
      * valid.
@@ -688,13 +714,7 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
           keyFormatter.format(path.peek().request().key()));
       for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT);
-        // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
-        if (binding instanceof ProvisionBinding) {
-          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-        } else if (binding instanceof ProductionBinding) {
-          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-        }
+        builder.append('\n').append(INDENT).append(formatBinding(binding));
       }
       int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
       if (numberOfOtherBindings > 0) {
@@ -733,6 +753,28 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
+    private void reportDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Collection<? extends ContributionBinding> mapBindings) {
+      StringBuilder builder = new StringBuilder();
+      builder.append(duplicateMapKeysError(keyFormatter.format(path.peek().request().key())));
+      for (Binding binding : Iterables.limit(mapBindings, DUPLICATE_SIZE_LIMIT)) {
+        builder.append('\n').append(INDENT).append(formatBinding(binding));
+      }
+      int numberOfOtherBindings = mapBindings.size() - DUPLICATE_SIZE_LIMIT;
+      if (numberOfOtherBindings > 0) {
+        builder
+            .append('\n')
+            .append(INDENT)
+            .append("and ")
+            .append(numberOfOtherBindings)
+            .append(" other");
+      }
+      if (numberOfOtherBindings > 1) {
+        builder.append('s');
+      }
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
     private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> bindingPath) {
       ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
           .add(request)
@@ -874,6 +916,18 @@ private String formatBindingType(BindingType type) {
     }
   }
 
+  private String formatBinding(Binding binding) {
+    // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
+    if (binding instanceof ProvisionBinding) {
+      return provisionBindingFormatter.format((ProvisionBinding) binding);
+    } else if (binding instanceof ProductionBinding) {
+      return productionBindingFormatter.format((ProductionBinding) binding);
+    } else {
+      throw new IllegalArgumentException(
+          "Expected either a ProvisionBinding or a ProductionBinding, not " + binding);
+    }
+  }
+
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
@@ -896,8 +950,4 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
           return resolvedRequest.request();
         }
       };
-
-  abstract static class Traverser {
-    abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 0630dfc7d..6700741e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -17,16 +17,21 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
+import dagger.MapKey;
 import java.util.EnumSet;
 import java.util.Set;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -109,4 +114,25 @@ static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindin
     }
     return Iterables.getOnlyElement(types);
   }
+
+  /**
+   * Indexes map-multibindings by map key (the result of calling
+   * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
+   * itself, depending on {@link MapKey#unwrapValue()}).
+   */
+  static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
+      Set<? extends ContributionBinding> mapBindings) {
+    ImmutableSetMultimap.Builder<Object, ContributionBinding> mapBindingsByMapKey =
+        ImmutableSetMultimap.builder();
+    for (ContributionBinding mapBinding : mapBindings) {
+      AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+      Optional<? extends AnnotationValue> unwrappedValue = MapKeys.unwrapValue(mapKey);
+      if (unwrappedValue.isPresent()) {
+        mapBindingsByMapKey.put(unwrappedValue.get().getValue(), mapBinding);
+      } else {
+        mapBindingsByMapKey.put(mapKey, mapBinding);
+      }
+    }
+    return mapBindingsByMapKey.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 12da8deae..4bee50f57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -94,6 +94,10 @@
   static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
       "%s is bound multiple times:";
 
+  static String duplicateMapKeysError(String key) {
+    return "The same map key is bound more than once for " + key;
+  }
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index cd7579659..c14cc22c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -24,7 +24,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.MapKey;
 import dagger.Provides;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
@@ -273,8 +272,7 @@ private TypeMirror mapOfFactoryType(
 
     private TypeMirror mapKeyType(ExecutableElement method) {
       AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
-      MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-      return mapKey.unwrapValue()
+      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
           ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
           : mapKeyAnnotation.getAnnotationType();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index f378bbb26..4d79a28c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,6 +20,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.MapKey;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.Snippet;
@@ -76,6 +77,22 @@
     return getAnnotatedAnnotations(bindingElement, MapKey.class);
   }
 
+  /**
+   * Returns the annotation value if {@code mapKey}'s type is annotated with
+   * {@link MapKey @MapKey(unwrapValue = true)}.
+   *
+   * @throws IllegalArgumentException if {@code mapKey}'s type is not annotated with
+   *     {@link MapKey @MapKey} at all.
+   */
+  static Optional<? extends AnnotationValue> unwrapValue(AnnotationMirror mapKey) {
+    MapKey mapKeyAnnotation = mapKey.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    checkArgument(
+        mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
+    return mapKeyAnnotation.unwrapValue()
+        ? Optional.of(getOnlyElement(mapKey.getElementValues().values()))
+        : Optional.<AnnotationValue>absent();
+  }
+
   /**
    * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
    * type is primitive, returns the boxed type.
@@ -121,10 +138,8 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * {@link MapKey} annotation type.
    */
   public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
-    return enclosingClassName
-        .topLevelClassName()
-        .peerNamed(enclosingClassName.classFileName() + "Creator");
+    ClassName mapKeyTypeName = ClassName.fromTypeElement(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerNamed(mapKeyTypeName.classFileName() + "Creator");
   }
 
   /**
@@ -138,11 +153,12 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    */
   static Snippet getMapKeySnippet(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
-    TypeElement mapKeyAnnotationType = MoreTypes.asTypeElement(mapKey.getAnnotationType());
-    ClassName mapKeyCreator = MapKeys.getMapKeyCreatorClassName(mapKeyAnnotationType);
-    if (mapKeyAnnotationType.getAnnotation(MapKey.class).unwrapValue()) {
-      AnnotationValue memberToUnwrap = getOnlyElement(mapKey.getElementValues().values());
-      return new MapKeySnippetExceptArrays(mapKeyCreator).visit(memberToUnwrap, memberToUnwrap);
+    ClassName mapKeyCreator =
+        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
+    Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+    if (unwrappedValue.isPresent()) {
+      return new MapKeySnippetExceptArrays(mapKeyCreator)
+          .visit(unwrappedValue.get(), unwrappedValue.get());
     } else {
       return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index cf5a94a2f..24bd793cf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -23,7 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
@@ -190,7 +190,7 @@ public void mapBindingsWithEnumKey() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -356,7 +356,7 @@ public void mapBindingsWithStringKey() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             stringKeyFile,
@@ -523,7 +523,7 @@ public void mapBindingsWithWrappedKey() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             classKeyFile,
@@ -697,7 +697,7 @@ public void mapBindingsWithNonProviderValue() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -716,7 +716,6 @@ public void injectMapWithoutMapBinding() {
     JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
         "package test;",
         "",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import java.util.HashMap;",
@@ -735,7 +734,6 @@ public void injectMapWithoutMapBinding() {
         "",
         "import dagger.Component;",
         "import java.util.Map;",
-        "import javax.inject.Provider;",
         "",
         "@Component(modules = {MapModule.class})",
         "interface TestComponent {",
@@ -796,8 +794,71 @@ public void injectMapWithoutMapBinding() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
         .processedWith(new ComponentProcessor()).compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test
+  public void mapBindingsWithDuplicateKeys() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "    return \"one again\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKey",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "import java.lang.annotation.Retention;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "@MapKey(unwrapValue = true)",
+            "@Retention(RUNTIME)",
+            "public @interface StringKey {",
+            "  String value();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, stringKeyFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("The same map key is bound more than once")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForAKeyAgain()")
+        .and()
+        .withErrorCount(1);
+  }
 }
