diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
new file mode 100644
index 000000000..da1c7b257
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProductionScope;
+
+@Module
+final class ScopedModule {
+  @Provides
+  @ProductionScope
+  static Object newScopedObject() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
new file mode 100644
index 000000000..646eda45e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.producers.ProductionScope;
+import javax.inject.Inject;
+
+@ProductionScope
+final class ScopedObject {
+  @Inject
+  ScopedObject() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
new file mode 100644
index 000000000..c7801c06a
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = {ScopedModule.class, SetProducerModule.class})
+interface SetComponent {
+  ScopedObject scopedObject();
+
+  ListenableFuture<Set<Object>> set();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
new file mode 100644
index 000000000..a5fc81e16
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import static dagger.producers.Produces.Type.SET;
+
+/**
+ * A module that provides two entries into a set; but since the inputs are scoped, the set should
+ * only have one value.
+ */
+@ProducerModule
+final class SetProducerModule {
+  @Produces(type = SET)
+  static Object setValue1(Object value) {
+    return value;
+  }
+
+  @Produces(type = SET)
+  static Object setValue2(Object value) {
+    return value;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
new file mode 100644
index 000000000..36ce255e5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.scope;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void scope() throws Exception {
+    SetComponent component =
+        DaggerSetComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(component.set().get()).hasSize(1);
+    assertThat(component.scopedObject()).isSameAs(component.scopedObject());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 8552fe7e8..fe41e7ed5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -172,6 +172,19 @@ boolean isTopLevel() {
       return isTopLevel;
     }
 
+    boolean isProducer() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return false;
+        case PRODUCTION_COMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
+          return true;
+        default:
+          throw new AssertionError();
+      }
+    }
+
     private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
         new Function<Kind, Class<? extends Annotation>>() {
           @Override
@@ -408,7 +421,7 @@ private ComponentDescriptor create(
       }
 
       Optional<TypeElement> executorDependency =
-          kind.equals(Kind.PRODUCTION_COMPONENT) || kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
+          kind.isProducer()
               ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
               : Optional.<TypeElement>absent();
 
@@ -470,6 +483,11 @@ private ComponentDescriptor create(
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
       Scope scope = Scope.scopeOf(componentDefinitionType);
+      if (kind.isProducer() && !scope.isPresent()) {
+        // TODO(beder): Override scope for production components when clients don't use them.
+        scope = Scope.productionScope(elements);
+      }
+
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 0be4686a9..15b900677 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -19,6 +19,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -28,6 +29,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionScope;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -229,6 +231,23 @@ public ComponentValidationReport validate(final TypeElement subject,
       }
     }
 
+    if (componentKind.isProducer()) {
+      ImmutableSet<? extends AnnotationMirror> nonProductionScopes =
+          FluentIterable.from(InjectionAnnotations.getScopes(subject))
+              .filter(
+                  new Predicate<AnnotationMirror>() {
+                    @Override
+                    public boolean apply(AnnotationMirror scope) {
+                      return !MoreTypes.isTypeOf(ProductionScope.class, scope.getAnnotationType());
+                    }
+                  })
+              .toSet();
+      if (!nonProductionScopes.isEmpty()) {
+        // TODO(beder): Make this an error after all clients are updated.
+        builder.addWarning(ErrorMessages.PRODUCTION_COMPONENT_SCOPE, subject);
+      }
+    }
+
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2077864d7..e9d110a06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -226,6 +226,10 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
+  static final String PRODUCTION_COMPONENT_SCOPE =
+      "Production components may not declare any @Scope other than @ProductionScope; they are "
+          + "automatically scoped with @ProductionScope if no scope is applied.";
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index bcb009d1e..c64ff64c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -19,11 +19,13 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
+import dagger.producers.ProductionScope;
 import javax.annotation.Nullable;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
@@ -70,6 +72,15 @@ static Scope scopeOf(Element element) {
     return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
   }
 
+  /**
+   * Returns a representation for producer scope;
+   */
+  static Scope productionScope(Elements elements) {
+    return new Scope(
+        SimpleAnnotationMirror.of(
+            elements.getTypeElement(ProductionScope.class.getCanonicalName())));
+  }
+
   /**
    * Returns true if the scope is present, i.e. it's not unscoped binding.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
new file mode 100644
index 000000000..c94eafea6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/** A representation of an annotation with no fields. */
+final class SimpleAnnotationMirror implements AnnotationMirror {
+  private final DeclaredType type;
+
+  private SimpleAnnotationMirror(DeclaredType type) {
+    this.type = type;
+  }
+
+  @Override
+  public DeclaredType getAnnotationType() {
+    return type;
+  }
+
+  @Override
+  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues() {
+    return ImmutableMap.of();
+  }
+
+  @Override
+  public String toString() {
+    return "@" + type;
+  }
+
+  static AnnotationMirror of(TypeElement element) {
+    checkArgument(element.getKind().equals(ElementKind.ANNOTATION_TYPE));
+    checkArgument(element.getEnclosedElements().isEmpty());
+    return new SimpleAnnotationMirror(MoreTypes.asDeclared(element.asType()));
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index c645056a5..8d8da6783 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -86,6 +86,24 @@
         .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
+  // TODO(beder): Expose this when CompileTester is updated externally.
+
+  @Test public void productionScopedProductionComponent() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ScopedComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "import dagger.producers.ProductionScope;",
+        "",
+        "@ProductionScope",
+        "@ProductionComponent",
+        "interface ScopedComponent {}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
diff --git a/producers/src/main/java/dagger/producers/ProductionScope.java b/producers/src/main/java/dagger/producers/ProductionScope.java
new file mode 100644
index 000000000..8e3a405d8
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionScope.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scope annotation for provision bindings that are tied to the lifetime of a
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
+ */
+@Documented
+@Retention(RUNTIME)
+@Scope
+public @interface ProductionScope {}
