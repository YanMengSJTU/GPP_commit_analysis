diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
index 95f373f9d..0ef22ae6b 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -15,41 +15,38 @@
 */
 package producerstest;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
-
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
-
+import java.util.concurrent.ExecutionException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.mockito.InOrder;
 import org.mockito.Mock;
+import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 
-import java.util.concurrent.ExecutionException;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
 
 @RunWith(JUnit4.class)
 public class ProducerFactoryTest {
   @Mock private ProductionComponentMonitor componentMonitor;
-  @Mock private ProducerMonitor monitor;
+  private ProducerMonitor monitor;
 
   @Before
   public void setUpMocks() {
     MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
     when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
   }
 
@@ -164,25 +161,9 @@ public void failureMonitorDueToThrowingProducer() throws Exception {
     order.verifyNoMoreInteractions();
   }
 
-  @Test
+  @Test(expected = NullPointerException.class)
   public void nullComponentMonitor() throws Exception {
-    Producer<String> producer =
-        new SimpleProducerModule_StrFactory(null, MoreExecutors.directExecutor());
-    assertThat(producer.get().get()).isEqualTo("str");
-    verifyZeroInteractions(componentMonitor, monitor);
-  }
-
-  @Test
-  public void nullMonitor() throws Exception {
-    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(null);
-
-    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
-    Producer<String> producer =
-        new SimpleProducerModule_StrFactory(
-            componentMonitor, MoreExecutors.directExecutor());
-    assertThat(producer.get().get()).isEqualTo("str");
-    verify(componentMonitor).producerMonitorFor(token);
-    verifyZeroInteractions(monitor);
+    new SimpleProducerModule_StrFactory(null, MoreExecutors.directExecutor());
   }
 
   private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index a84f871a5..759711a3b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -58,6 +58,7 @@
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
+import dagger.producers.monitoring.internal.Monitors;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.HashMap;
@@ -1024,7 +1025,9 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           List<Snippet> parameters =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 3);
           // TODO(beder): Pass the actual ProductionComponentMonitor.
-          parameters.add(Snippet.format("null"));
+          parameters.add(
+              Snippet.format(
+                  "%s.noOpProductionComponentMonitor()", ClassName.fromClass(Monitors.class)));
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 0e1e5316a..a7da5a4eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -49,7 +49,6 @@
 import java.util.List;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
-import javax.annotation.Nullable;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -106,14 +105,11 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ConstructorWriter constructorWriter = factoryWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
 
-    constructorWriter
-        .addParameter(ProductionComponentMonitor.class, "componentMonitor")
-        .annotate(Nullable.class);
+    constructorWriter.addParameter(ProductionComponentMonitor.class, "componentMonitor");
     constructorWriter
         .body()
         .addSnippet(
-            "super(%s.producerMonitorFor(componentMonitor, %s.create(%s.class)));",
-            ClassName.fromClass(Producers.class),
+            "super(componentMonitor.producerMonitorFor(%s.create(%s.class)));",
             ClassName.fromClass(ProducerToken.class),
             factoryWriter.name());
 
@@ -457,7 +453,7 @@ private Snippet getInvocationSnippet(
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
     // factories.
     ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-    snippets.add(Snippet.format("if (monitor != null) { monitor.methodStarting(); }"));
+    snippets.add(Snippet.format("monitor.methodStarting();"));
 
     final Snippet valueSnippet;
     if (binding.productionType().equals(Produces.Type.SET)) {
@@ -485,11 +481,11 @@ private Snippet getInvocationSnippet(
     return Snippet.format(
         Joiner.on('\n')
             .join(
-                "if (monitor != null) { monitor.methodStarting(); }",
+                "monitor.methodStarting();",
                 "try {",
                 "  return %s;",
                 "} finally {",
-                "  if (monitor != null) { monitor.methodFinished(); }",
+                "  monitor.methodFinished();",
                 "}"),
         returnSnippet);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index c27423028..2c017c923 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -475,12 +475,10 @@ public void publicModuleNonPublicIncludes() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.internal.Producers;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
-            "import javax.annotation.Nullable;",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
@@ -488,12 +486,11 @@ public void publicModuleNonPublicIncludes() {
             "  private final Executor executor;",
             "",
             "  public TestModule_ProduceStringFactory(",
-            "      @Nullable ProductionComponentMonitor componentMonitor,",
+            "      ProductionComponentMonitor componentMonitor,",
             "      TestModule module,",
             "      Executor executor) {",
             "    super(",
-            "        Producers.producerMonitorFor(",
-            "            componentMonitor,",
+            "        componentMonitor.producerMonitorFor(",
             "            ProducerToken.create(TestModule_ProduceStringFactory.class)));",
             "    assert module != null;",
             "    this.module = module;",
@@ -506,15 +503,11 @@ public void publicModuleNonPublicIncludes() {
             "      Futures.<Void>immediateFuture(null),",
             "      new AsyncFunction<Void, String>() {",
             "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "          if (monitor != null) {",
-            "            monitor.methodStarting();",
-            "          }",
+            "          monitor.methodStarting();",
             "          try {",
             "            return module.produceString();",
             "          } finally {",
-            "            if (monitor != null) {",
-            "              monitor.methodFinished();",
-            "            }",
+            "            monitor.methodFinished();",
             "          }",
             "        }",
             "      }, executor);",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 92bbb752c..fd9f875c6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -123,98 +123,100 @@
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestClass_SimpleComponent",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.TestClass.A;",
-        "import test.TestClass.AModule;",
-        "import test.TestClass.B;",
-        "import test.TestClass.BModule;",
-        "import test.TestClass.SimpleComponent;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Producer<A> aProducer;",
-        "",
-        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestClass$BModule_BFactory.create(",
-        "        builder.bModule, TestClass$C_Factory.create());",
-        "    this.aProducer = new TestClass$AModule_AFactory(",
-		"        null,",
-		"        builder.aModule,",
-		"        builder.executor,",
-		"        Producers.producerFromProvider(bProvider));",
-		"  }",
-        "",
-        "  @Override",
-        "  public ListenableFuture<A> a() {",
-        "    return aProducer.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private BModule bModule;",
-        "    private AModule aModule;",
-        "    private Executor executor;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      if (bModule == null) {",
-        "        this.bModule = new BModule();",
-        "      }",
-        "      if (aModule == null) {",
-        "        this.aModule = new AModule();",
-        "      }",
-        "      if (executor == null) {",
-        "        throw new IllegalStateException(Executor.class.getCanonicalName()",
-        "            + \" must be set\");",
-        "      }",
-        "      return new DaggerTestClass_SimpleComponent(this);",
-        "    }",
-        "",
-        "    public Builder aModule(AModule aModule) {",
-        "      if (aModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.aModule = aModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder bModule(BModule bModule) {",
-        "      if (bModule == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.bModule = bModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder executor(Executor executor) {",
-        "      if (executor == null) {",
-        "        throw new NullPointerException();",
-        "      }",
-        "      this.executor = executor;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestClass_SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.internal.Monitors;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.TestClass.A;",
+            "import test.TestClass.AModule;",
+            "import test.TestClass.B;",
+            "import test.TestClass.BModule;",
+            "import test.TestClass.SimpleComponent;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Producer<A> aProducer;",
+            "",
+            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestClass$BModule_BFactory.create(",
+            "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.aProducer = new TestClass$AModule_AFactory(",
+            "        Monitors.noOpProductionComponentMonitor(),",
+            "        builder.aModule,",
+            "        builder.executor,",
+            "        Producers.producerFromProvider(bProvider));",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<A> a() {",
+            "    return aProducer.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private BModule bModule;",
+            "    private AModule aModule;",
+            "    private Executor executor;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      if (bModule == null) {",
+            "        this.bModule = new BModule();",
+            "      }",
+            "      if (aModule == null) {",
+            "        this.aModule = new AModule();",
+            "      }",
+            "      if (executor == null) {",
+            "        throw new IllegalStateException(Executor.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerTestClass_SimpleComponent(this);",
+            "    }",
+            "",
+            "    public Builder aModule(AModule aModule) {",
+            "      if (aModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.aModule = aModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder bModule(BModule bModule) {",
+            "      if (bModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.bModule = bModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder executor(Executor executor) {",
+            "      if (executor == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.executor = executor;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 7843b2094..0fca60f0f 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -15,12 +15,12 @@
  */
 package dagger.producers.internal;
 
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
-import javax.annotation.Nullable;
+import dagger.producers.monitoring.internal.Monitors;
+
+import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * An abstract {@link Producer} implementation that memoizes the result of its compute method.
@@ -29,15 +29,15 @@
  * @since 2.0
  */
 public abstract class AbstractProducer<T> implements Producer<T> {
-  @Nullable protected final ProducerMonitor monitor;
+  protected final ProducerMonitor monitor;
   private volatile ListenableFuture<T> instance = null;
 
   protected AbstractProducer() {
-    this(null);
+    this(Monitors.noOpProducerMonitor());
   }
 
-  protected AbstractProducer(@Nullable ProducerMonitor monitor) {
-    this.monitor = monitor;
+  protected AbstractProducer(ProducerMonitor monitor) {
+    this.monitor = checkNotNull(monitor);
   }
 
   /** Computes this producer's future, which is then cached in {@link #get}. */
@@ -55,21 +55,7 @@ protected AbstractProducer(@Nullable ProducerMonitor monitor) {
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
-          if (monitor != null) {
-            Futures.addCallback(
-                result,
-                new FutureCallback<T>() {
-                  @Override
-                  public void onSuccess(T value) {
-                    monitor.succeeded(value);
-                  }
-
-                  @Override
-                  public void onFailure(Throwable t) {
-                    monitor.failed(t);
-                  }
-                });
-          }
+          monitor.addCallbackTo(result);
         }
       }
     }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 65269b54e..f90315053 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -22,11 +22,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.Set;
-import javax.annotation.Nullable;
 import javax.inject.Provider;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -104,16 +100,6 @@
     };
   }
 
-  /** Lifts {@link ProductionComponentMonitor#producerMonitorFor} to nullable types. */
-  @Nullable
-  public static ProducerMonitor producerMonitorFor(
-      @Nullable ProductionComponentMonitor componentMonitor, ProducerToken token) {
-    if (componentMonitor != null) {
-      return componentMonitor.producerMonitorFor(token);
-    }
-    return null;
-  }
-
   /** Returns a producer that succeeds with the given value. */
   public static <T> Producer<T> immediateProducer(final T value) {
     return new Producer<T>() {
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 74c1a8f6e..63cb454a0 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -15,6 +15,9 @@
  */
 package dagger.producers.monitoring;
 
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produces;
 
 /**
@@ -76,4 +79,24 @@ public void succeeded(Object o) {}
    * calls to {@link #methodStarting()}.
    */
   public void failed(Throwable t) {}
+
+  /**
+   * Adds this monitor's completion methods as a callback to the future. This is only intended to be
+   * overridden in the framework!
+   */
+  public <T> void addCallbackTo(ListenableFuture<T> future) {
+    Futures.addCallback(
+        future,
+        new FutureCallback<T>() {
+          @Override
+          public void onSuccess(T value) {
+            succeeded(value);
+          }
+
+          @Override
+          public void onFailure(Throwable t) {
+            failed(t);
+          }
+        });
+  }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index 111089066..6d7949021 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -17,13 +17,13 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.Collection;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import javax.annotation.Nullable;
 
 /**
  * Utility methods relating to monitoring, for use in generated producers code.
@@ -35,17 +35,17 @@
 
   /**
    * Returns a monitor factory that delegates to the given factories, and ensures that any method
-   * called on this object, even transitively, does not throw a {@link RuntimeException}.
+   * called on this object, even transitively, does not throw a {@link RuntimeException} or return
+   * null.
    *
    * <p>If the delegate monitors throw an {@link Error}, then that will escape this monitor
    * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
    * component's execution to fail.
    */
-  @Nullable
   public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(
       Collection<? extends ProductionComponentMonitor.Factory> factories) {
     if (factories.isEmpty()) {
-      return null;
+      return noOpProductionComponentMonitorFactory();
     } else if (factories.size() == 1) {
       return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));
     } else {
@@ -69,14 +69,10 @@
     public ProducerMonitor producerMonitorFor(ProducerToken token) {
       try {
         ProducerMonitor monitor = delegate.producerMonitorFor(token);
-        if (monitor == null) {
-          return null;
-        } else {
-          return new NonThrowingProducerMonitor(monitor);
-        }
+        return monitor == null ? noOpProducerMonitor() : new NonThrowingProducerMonitor(monitor);
       } catch (RuntimeException e) {
         logProducerMonitorForException(e, delegate, token);
-        return null;
+        return noOpProducerMonitor();
       }
     }
 
@@ -91,14 +87,12 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       public ProductionComponentMonitor create(Object component) {
         try {
           ProductionComponentMonitor monitor = delegate.create(component);
-          if (monitor == null) {
-            return null;
-          } else {
-            return new NonThrowingProductionComponentMonitor(monitor);
-          }
+          return monitor == null
+              ? noOpProductionComponentMonitor()
+              : new NonThrowingProductionComponentMonitor(monitor);
         } catch (RuntimeException e) {
           logCreateException(e, delegate, component);
-          return null;
+          return noOpProductionComponentMonitor();
         }
       }
     }
@@ -179,7 +173,7 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       }
       ImmutableList<ProducerMonitor> monitors = monitorsBuilder.build();
       if (monitors.isEmpty()) {
-        return null;
+        return noOpProducerMonitor();
       } else if (monitors.size() == 1) {
         return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));
       } else {
@@ -209,7 +203,7 @@ public ProductionComponentMonitor create(Object component) {
         }
         ImmutableList<ProductionComponentMonitor> monitors = monitorsBuilder.build();
         if (monitors.isEmpty()) {
-          return null;
+          return noOpProductionComponentMonitor();
         } else if (monitors.size() == 1) {
           return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));
         } else {
@@ -275,6 +269,46 @@ public void failed(Throwable t) {
     }
   }
 
+  /** Returns a monitor factory that returns no-op component monitors. */
+  public static ProductionComponentMonitor.Factory noOpProductionComponentMonitorFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY;
+  }
+
+  /** Returns a component monitor that returns no-op producer monitors. */
+  public static ProductionComponentMonitor noOpProductionComponentMonitor() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR;
+  }
+
+  /** Returns a producer monitor that does nothing. */
+  public static ProducerMonitor noOpProducerMonitor() {
+    return NO_OP_PRODUCER_MONITOR;
+  }
+
+  private static final ProductionComponentMonitor.Factory
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY =
+          new ProductionComponentMonitor.Factory() {
+            @Override
+            public ProductionComponentMonitor create(Object component) {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
+  private static final ProductionComponentMonitor NO_OP_PRODUCTION_COMPONENT_MONITOR =
+      new ProductionComponentMonitor() {
+        @Override
+        public ProducerMonitor producerMonitorFor(ProducerToken token) {
+          return noOpProducerMonitor();
+        }
+      };
+
+  private static final ProducerMonitor NO_OP_PRODUCER_MONITOR =
+      new ProducerMonitor() {
+        @Override
+        public <T> void addCallbackTo(ListenableFuture<T> future) {
+          // overridden to avoid adding a do-nothing callback
+        }
+      };
+
   private static void logCreateException(
       RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {
     logger.log(
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 15a64bd1f..33eb17082 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -25,25 +25,24 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
+import org.mockito.Mockito;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
-  @Mock private ProducerMonitor monitor;
+  private ProducerMonitor monitor;
 
   @Before
   public void initMocks() {
-    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
   }
 
   @Test
@@ -78,7 +77,7 @@ public void monitor_success() throws Exception {
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
-    verifyZeroInteractions(monitor);
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
     delegateFuture.set(-42);
     assertThat(future.get()).isEqualTo(-42);
     verify(monitor).succeeded(-42);
@@ -92,7 +91,7 @@ public void monitor_failure() throws Exception {
 
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
-    verifyZeroInteractions(monitor);
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
     Throwable t = new RuntimeException("monkey");
     delegateFuture.setException(t);
     try {
@@ -105,10 +104,9 @@ public void monitor_failure() throws Exception {
     verifyNoMoreInteractions(monitor);
   }
 
-  @Test
+  @Test(expected = NullPointerException.class)
   public void monitor_null() throws Exception {
-    Producer<Integer> producer = new DelegateProducer<>(null, Futures.immediateFuture(42));
-    assertThat(producer.get().get()).isEqualTo(42);
+    new DelegateProducer<>(null, Futures.immediateFuture(42));
   }
 
   static final class DelegateProducer<T> extends AbstractProducer<T> {
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
index ff63dc2bd..e7f42746b 100644
--- a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -55,11 +55,11 @@ public void initMocks() {
   }
 
   @Test
-  public void zeroMonitorsReturnsNull() {
+  public void zeroMonitorsReturnsNoOp() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.<ProductionComponentMonitor.Factory>of());
-    assertThat(factory).isNull();
+    assertThat(factory).isSameAs(Monitors.noOpProductionComponentMonitorFactory());
   }
 
   @Test
@@ -68,7 +68,7 @@ public void singleMonitor_nullProductionComponentMonitor() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
-    assertThat(factory.create(new Object())).isNull();
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
   }
 
   @Test
@@ -79,7 +79,7 @@ public void singleMonitor_throwingProductionComponentMonitorFactory() {
     ProductionComponentMonitor.Factory factory =
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
-    assertThat(factory.create(new Object())).isNull();
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
   }
 
   @Test
@@ -92,7 +92,8 @@ public void singleMonitor_nullProducerMonitor() {
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
     ProductionComponentMonitor monitor = factory.create(new Object());
-    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class))).isNull();
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
   }
 
   @Test
@@ -106,7 +107,8 @@ public void singleMonitor_throwingProductionComponentMonitor() {
         Monitors.delegatingProductionComponentMonitorFactory(
             ImmutableList.of(mockProductionComponentMonitorFactory));
     ProductionComponentMonitor monitor = factory.create(new Object());
-    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class))).isNull();
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
   }
 
   @Test
@@ -210,7 +212,7 @@ public void multipleMonitors_nullProductionComponentMonitors() {
                 mockProductionComponentMonitorFactoryA,
                 mockProductionComponentMonitorFactoryB,
                 mockProductionComponentMonitorFactoryC));
-    assertThat(factory.create(new Object())).isNull();
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
   }
 
   @Test
@@ -230,7 +232,7 @@ public void multipleMonitors_throwingProductionComponentMonitorFactories() {
                 mockProductionComponentMonitorFactoryA,
                 mockProductionComponentMonitorFactoryB,
                 mockProductionComponentMonitorFactoryC));
-    assertThat(factory.create(new Object())).isNull();
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
   }
 
   @Test
