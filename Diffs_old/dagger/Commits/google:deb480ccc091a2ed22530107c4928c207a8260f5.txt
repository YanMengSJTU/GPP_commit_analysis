diff --git a/CHANGELOG.md b/CHANGELOG.md
index b2168197e..42bd6272f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,17 @@ Change Log
 Dagger 2 (Components)
 ---------------------
 
+### Version 2.5 *(2016-06-14)*
+  * Enables `@Binds` usage with multibinding annotations (`@IntoSet`, `@ElementsIntoSet`, and `@IntoMap`)
+  * Adds [`@Multibinds`](http://google.github.io/dagger/api/latest/dagger/multibindings/Multibinds.html) API to replace `@Multibindings` interfaces
+  * `@Component.Builder` methods for abstract modules are no longer allowed
+  * Performance improvements for `@IntoSet` usage. Provided objects are no longer wrapped in a wasteful `Collections.singleton()`
+  * Compilation speed improvements for large graphs
+  * `@Scope`s are no longer allowed on `@Produces` methods
+  * Adds state checking to scoped providers to make sure a circular dependency does not create multiple instances
+  * Producers optimizations: Each `@Produces` method now generates 1 class instead of 2
+  * Fix: Requests for Map<K, V> now include both `@Provides @IntoMap` and `@Produces @IntoMap` values
+
 ### Version 2.4 *(2016-04-21)*
   * Adds [`@Binds`](http://google.github.io/dagger/api/latest/dagger/Binds.html) API for delegating
     one binding to another
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
similarity index 97%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
index b0b126a0c..86122f9b4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 /**
  * This is the type that will be bound.  We throw in generics just to complicate the test.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
similarity index 97%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
index 14b98c944..730e70211 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.bind;
+package test.binds;
 
 import javax.inject.Inject;
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
similarity index 97%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
index 2bf81689a..c5a23f92f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import javax.inject.Inject;
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
similarity index 97%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
index 48e705cd5..84814a6f6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import dagger.Binds;
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
similarity index 99%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
index cc174aba7..b760eca58 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import dagger.Binds;
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
similarity index 98%
rename from compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
rename to compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
index 25befc452..08866ed22 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import dagger.Component;
 import java.util.Map;
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
similarity index 99%
rename from compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java
rename to compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
index 4440f4ac0..3e0c47fe7 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/bind/BindsCollectionsWithoutMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import com.google.common.collect.ImmutableMap;
 import dagger.Binds;
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
rename to compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
index 636ff62f8..c06512124 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.bind;
+package test.binds;
 
 import com.google.common.collect.ImmutableMap;
 import org.junit.Before;
@@ -23,9 +23,8 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-// TODO(ronshapiro): rename to BindsTest
 @RunWith(JUnit4.class)
-public class BindTest {
+public class BindsTest {
 
   private TestComponent component;
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
similarity index 96%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
index 5b0908832..147284caa 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest.bind;
+package producerstest.binds;
 
 /**
  * This is the type that will be bound.  We throw in generics just to complicate the test.
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
index 66f93406d..256041290 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest.bind;
+package producerstest.binds;
 
 /**
  * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
similarity index 99%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
index 770950413..5538ce60b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest.bind;
+package producerstest.binds;
 
 import com.google.common.util.concurrent.MoreExecutors;
 import dagger.Binds;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
similarity index 94%
rename from compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
index b843b3401..2c8c8130d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest.bind;
+package producerstest.binds;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
@@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Singleton;
-import producerstest.bind.SimpleBindingModule.SomeQualifier;
+import producerstest.binds.SimpleBindingModule.SomeQualifier;
 
 @Singleton
 @ProductionComponent(modules = SimpleBindingModule.class)
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
similarity index 99%
rename from compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
index 7c6cf8087..1c6b0faf4 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package producerstest.bind;
+package producerstest.binds;
 
 import com.google.common.collect.ImmutableMap;
 import dagger.producers.Produced;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index afd8f0e2b..233ab5511 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -63,12 +63,12 @@
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
@@ -322,15 +322,22 @@ private BindingGraph create(
        *
        * <p>For {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:
        * <ul>
-       * <li>All explicit bindings for the requested key.
-       * <li>All explicit bindings for {@code Set<T>} if the requested key's type is
-       *     {@code Set<Produced<T>>}.
+       * <li>All explicit bindings for:
+       *     <ul>
+       *     <li>the requested key
+       *     <li>{@code Set<T>} if the requested key's type is {@code Set<Produced<T>>}
+       *     <li>{@code Map<K, Provider<V>>} if the requested key's type is
+       *         {@code Map<K, Producer<V>>}.
+       *     </ul>
+       *
        * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
        *     type is {@code Map<K, V>} and there are some explicit bindings for
        *     {@code Map<K, Producer<V>>}.
+       *
        * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
        *     type is {@code Map<K, V>} and there are some explicit bindings for
        *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
+       *
        * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
        *     there are no explicit bindings or synthetic bindings.
        * </ul>
@@ -340,38 +347,33 @@ private BindingGraph create(
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
-        Key key = bindingKey.key();
+        Key requestKey = bindingKey.key();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
-            Set<ContributionBinding> multibindings = new LinkedHashSet<>();
+            ImmutableSet.Builder<ContributionBinding> multibindingsBuilder = ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
-            for (Key keyOrImplicitKey : explicitAndImplicitKeys(key)) {
-              contributionBindings.addAll(getExplicitBindings(keyOrImplicitKey));
-              contributionBindings.addAll(
-                  delegateBindings(getDelegateDeclarations(keyOrImplicitKey)));
+            for (Key key : keysMatchingRequest(requestKey)) {
+              contributionBindings.addAll(getExplicitBindings(key));
+              contributionBindings.addAll(getDelegateBindings(key));
 
-              multibindings.addAll(getExplicitMultibindings(keyOrImplicitKey));
-              multibindings.addAll(
-                  delegateBindings(getDelegateMultibindingDeclarations(keyOrImplicitKey)));
+              multibindingsBuilder.addAll(getExplicitMultibindings(key));
+              multibindingsBuilder.addAll(getDelegateMultibindings(key));
 
-              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(keyOrImplicitKey));
+              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
             }
 
-            // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
-            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
-            // declarations.
             if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProducerKeyFrom(key))) {
+                keyFactory.implicitMapProducerKeyFrom(requestKey))) {
               /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
                * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
                * binding that depends on Map<K, Producer<V>>. */
               contributionBindings.add(
                   productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
             } else if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProviderKeyFrom(key))) {
+                keyFactory.implicitMapProviderKeyFrom(requestKey))) {
               /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
                * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
                * or multibinding declarations, then add the synthetic binding that depends on
@@ -380,6 +382,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.syntheticMapOfValuesBinding(request));
             }
 
+            ImmutableSet<ContributionBinding> multibindings = multibindingsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
 
@@ -387,25 +390,23 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 Iterables.concat(multibindings, multibindingDeclarations);
             if (Iterables.any(
                 multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
-            /* If there are production multibindings, add a synthetic binding that depends on each
-             * individual multibinding. */
+              /* If there are production multibindings, add a synthetic binding that depends on each
+               * individual multibinding. */
               contributionBindings.add(
                   productionBindingFactory.syntheticMultibinding(request, multibindings));
             } else if (Iterables.any(
                 multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
-            /* If there are provision multibindings but not production ones, add a synthetic
-             * binding that depends on each individual multibinding. */
+              /* If there are provision multibindings but not production ones, add a synthetic
+               * binding that depends on each individual multibinding. */
               contributionBindings.add(
                   provisionBindingFactory.syntheticMultibinding(request, multibindings));
             }
 
-            /* If there are no explicit or synthetic bindings, multibinding declarations or delegate
-             * declarations, use an implicit @Inject- constructed binding if there is one. */
-            if (contributionBindings.isEmpty()
-                && multibindings.isEmpty()
-                && multibindingDeclarations.isEmpty()) {
+            /* If there are still no bindings, look for an implicit @Inject- constructed binding if
+             * there is one. */
+            if (contributionBindings.isEmpty()) {
               contributionBindings.addAll(
-                  injectBindingRegistry.getOrFindProvisionBinding(key).asSet());
+                  injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());
             }
 
             return ResolvedBindings.forContributionBindings(
@@ -417,7 +418,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             Optional<MembersInjectionBinding> binding =
-                injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+                injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
             return binding.isPresent()
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
@@ -427,11 +428,11 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
-      private Iterable<Key> explicitAndImplicitKeys(Key key) {
+      private Iterable<Key> keysMatchingRequest(Key requestKey) {
         return ImmutableSet.<Key>builder()
-            .add(key)
-            .addAll(keyFactory.implicitSetKeyFromProduced(key).asSet())
-            .addAll(keyFactory.implicitProviderMapKeyFromProducer(key).asSet())
+            .add(requestKey)
+            .addAll(keyFactory.implicitSetKeyFromProduced(requestKey).asSet())
+            .addAll(keyFactory.implicitProviderMapKeyFromProducer(requestKey).asSet())
             .build();
       }
 
@@ -446,17 +447,15 @@ private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey)
           return true;
         }
 
-        ImmutableSet<ContributionBinding> delegateBindings =
-            delegateBindings(getDelegateMultibindingDeclarations(key));
-        for (ContributionBinding delegateBinding : delegateBindings) {
-          if (delegateBinding.key().withoutBindingMethodIdentifier().equals(key)) {
+        for (ContributionBinding delegateMultibinding : getDelegateMultibindings(key)) {
+          if (delegateMultibinding.key().withoutBindingMethodIdentifier().equals(key)) {
             return true;
           }
         }
         return false;
       }
 
-      private ImmutableSet<ContributionBinding> delegateBindings(
+      private ImmutableSet<ContributionBinding> createDelegateBindings(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
         for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
@@ -613,31 +612,30 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return multibindingDeclarations.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key requestKey) {
-        Key key = keyFactory.convertToDelegateKey(requestKey);
-        ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
-            ImmutableSet.builder();
+      private ImmutableSet<ContributionBinding> getDelegateBindings(Key requestKey) {
+        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
+        ImmutableSet.Builder<ContributionBinding> delegateBindings = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          delegateDeclarations.addAll(resolver.delegateDeclarations.get(key));
+          delegateBindings.addAll(
+              createDelegateBindings(resolver.delegateDeclarations.get(delegateDeclarationKey)));
         }
-        return delegateDeclarations.build();
+        return delegateBindings.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateMultibindingDeclarations(
-          Key requestKey) {
+      private ImmutableSet<ContributionBinding> getDelegateMultibindings(Key requestKey) {
         if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
           // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All @IntoMap
           // requests must be for Map<K, Framework<V>>.
           return ImmutableSet.of();
         }
-        Key key = keyFactory.convertToDelegateKey(requestKey);
-        ImmutableSet.Builder<DelegateDeclaration> delegateMultibindingDeclarations =
-            ImmutableSet.builder();
+        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
+        ImmutableSet.Builder<ContributionBinding> delegateMultibindings = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          delegateMultibindingDeclarations.addAll(
-              resolver.delegateMultibindingDeclarations.get(key));
+          delegateMultibindings.addAll(
+              createDelegateBindings(
+                  resolver.delegateMultibindingDeclarations.get(delegateDeclarationKey)));
         }
-        return delegateMultibindingDeclarations.build();
+        return delegateMultibindings.build();
       }
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
diff --git a/pom.xml b/pom.xml
index a3df564cd..b81f8c8b6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -205,7 +205,6 @@
         <configuration>
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
-          <excludePackageNames>*.internal</excludePackageNames>
         </configuration>
       </plugin>
 
diff --git a/util/generate-latest-docs.sh b/util/generate-latest-docs.sh
index b68df0c4a..573576999 100755
--- a/util/generate-latest-docs.sh
+++ b/util/generate-latest-docs.sh
@@ -5,7 +5,7 @@ if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing javadoc...\n"
-  mvn javadoc:aggregate -P!examples
+  mvn javadoc:aggregate -P!examples -DexcludePackageNames=*.internal
   TARGET="$(pwd)/target"
 
   cd $HOME
