diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index e626e13a5..db0609b8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -123,6 +123,7 @@ static ResolvedBindings createForMembersInjectionBindings(
     private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
+    private final DependencyRequestMapper dependencyRequestMapper;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
 
@@ -130,12 +131,14 @@ static ResolvedBindings createForMembersInjectionBindings(
         Types types,
         InjectBindingRegistry injectBindingRegistry,
         dagger.internal.codegen.Key.Factory keyFactory,
+        dagger.internal.codegen.DependencyRequestMapper dependencyRequestMapper,
         dagger.internal.codegen.DependencyRequest.Factory dependencyRequestFactory,
         dagger.internal.codegen.ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
+      this.dependencyRequestMapper = dependencyRequestMapper;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
     }
@@ -249,7 +252,7 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
       State resolve(DependencyRequest request) {
         Key requestKey = request.key();
-        FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
+        FrameworkKey frameworkKey = dependencyRequestMapper.getFrameworkKey(request);
 
         ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(frameworkKey);
         if (previouslyResolvedBinding != null) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1d71e9a75..628855278 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -53,12 +53,17 @@
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ScopeCycleValidation disableInterComponentScopeCycles;
+  private final DependencyRequestMapper dependencyRequestMapper;
 
-  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry,
-      ScopeCycleValidation disableInterComponentScopeCycles) {
+  BindingGraphValidator(
+      Types types,
+      InjectBindingRegistry injectBindingRegistry,
+      ScopeCycleValidation disableInterComponentScopeCycles,
+      DependencyRequestMapper dependencyRequestMapper) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -72,7 +77,7 @@
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
       ResolvedBindings resolvedBinding = resolvedBindings.get(
-          FrameworkKey.forDependencyRequest(entryPoint));
+          dependencyRequestMapper.getFrameworkKey(entryPoint));
       if (!resolvedBinding.state().equals(State.COMPLETE)) {
         LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
         requestPath.push(entryPoint);
@@ -439,7 +444,7 @@ boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindi
   private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
       Traverser traverser) {
     ResolvedBindings resolvedBinding = graph.resolvedBindings().get(
-        FrameworkKey.forDependencyRequest(requestPath.peek()));
+        dependencyRequestMapper.getFrameworkKey(requestPath.peek()));
     ImmutableSet<DependencyRequest> allDeps =
         FluentIterable.from(resolvedBinding.bindings())
             .transformAndConcat(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 02783dde4..c7fede923 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -105,8 +105,11 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  ComponentGenerator(Filer filer) {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  ComponentGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -392,7 +395,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                 input.resolvedBindings().get(frameworkKey).membersInjectionBindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
-                initializeMembersInjectorForBinding(binding, memberSelectSnippets));
+                initializeMembersInjectorForBinding(
+                    dependencyRequestMapper, binding, memberSelectSnippets));
             break;
           default:
             throw new AssertionError();
@@ -414,7 +418,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                     requestElement.getSimpleName().toString());
             interfaceMethod.annotate(Override.class);
             interfaceMethod.addModifiers(PUBLIC);
-            FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(interfaceRequest);
+            FrameworkKey frameworkKey = dependencyRequestMapper.getFrameworkKey(interfaceRequest);
             if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
               Snippet membersInjectorName = memberSelectSnippets.get(frameworkKey);
               VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
@@ -528,10 +532,11 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
         parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        parameters.add(memberSelectSnippets.get(FrameworkKey.forDependencyRequest(
+        parameters.add(memberSelectSnippets.get(dependencyRequestMapper.getFrameworkKey(
             binding.memberInjectionRequest().get())));
       }
-      parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
+      parameters.addAll(getDependencyParameters(
+          dependencyRequestMapper, binding.dependencies(), memberSelectSnippets));
 
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
@@ -545,6 +550,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
   }
 
   private static Snippet initializeMembersInjectorForBinding(
+      DependencyRequestMapper dependencyRequestMapper,
       MembersInjectionBinding binding,
       ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
     if (binding.injectionSites().isEmpty()) {
@@ -553,13 +559,14 @@ private static Snippet initializeMembersInjectorForBinding(
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
             memberSelectSnippets.get(
-                FrameworkKey.forDependencyRequest(parentInjectorRequest)));
+                dependencyRequestMapper.getFrameworkKey(parentInjectorRequest)));
       } else {
         return Snippet.format("%s.noOp()",
             ClassName.fromClass(MembersInjectors.class));
       }
     } else {
       List<Snippet> parameters = getDependencyParameters(
+          dependencyRequestMapper,
           Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
           memberSelectSnippets);
       return Snippet.format("new %s(%s)",
@@ -568,10 +575,13 @@ private static Snippet initializeMembersInjectorForBinding(
     }
   }
 
-  private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
+  private static List<Snippet> getDependencyParameters(
+      DependencyRequestMapper dependencyRequestMapper,
+      Iterable<DependencyRequest> dependencies,
       ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (FrameworkKey dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
+    for (FrameworkKey dependencyKey :
+         SourceFiles.indexDependenciesByKey(dependencyRequestMapper, dependencies).keySet()) {
       parameters.add(memberSelectSnippets.get(dependencyKey));
     }
     return parameters.build();
@@ -588,7 +598,7 @@ private Snippet initializeMapBinding(
     if (isNonProviderMap(firstBinding)) {
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(FrameworkKey.forDependencyRequest(
+          memberSelectSnippets.get(dependencyRequestMapper.getFrameworkKey(
               Iterables.getOnlyElement(firstBinding.dependencies()))));
     } else {
       DeclaredType mapType = asDeclared(firstBinding.key().type());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 7299098ba..ffacaea74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -78,11 +78,14 @@ public SourceVersion getSupportedSourceVersion() {
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
+    FactoryGenerator factoryGenerator =
+        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
-    ProducerFactoryGenerator producerFactoryGenerator = new ProducerFactoryGenerator(filer);
+        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+    ProducerFactoryGenerator producerFactoryGenerator =
+        new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(types, keyFactory);
@@ -102,12 +105,15 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentDescriptor.Factory(elements, types);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements, types, injectBindingRegistry, keyFactory, dependencyRequestFactory,
-        provisionBindingFactory);
+        elements, types, injectBindingRegistry, keyFactory, DependencyRequestMapper.FOR_PROVIDER,
+        dependencyRequestFactory, provisionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
-        injectBindingRegistry, disableInterComponentScopeValidation(processingEnv));
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
+        types,
+        injectBindingRegistry,
+        disableInterComponentScopeValidation(processingEnv),
+        DependencyRequestMapper.FOR_PROVIDER);
 
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
new file mode 100644
index 000000000..6657af157
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import dagger.MembersInjector;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * A mapper for associated a {@link DependencyRequest} to a {@link FrameworkKey}, dependent on the
+ * type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ *
+ *  @author Jesse Beder
+ *  @since 2.0
+ */
+abstract class DependencyRequestMapper {
+  abstract FrameworkKey getFrameworkKey(DependencyRequest request);
+
+  private static final class MapperForProvider extends DependencyRequestMapper {
+    @Override public FrameworkKey getFrameworkKey(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PROVIDER:
+        case LAZY:
+          return FrameworkKey.create(FrameworkKey.Kind.PROVIDER, request.key());
+        case MEMBERS_INJECTOR:
+          return FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, request.key());
+        case PRODUCED:
+        case PRODUCER:
+          throw new IllegalArgumentException();
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PROVIDER = new MapperForProvider();
+
+  private static final class MapperForProducer extends DependencyRequestMapper {
+    @Override public FrameworkKey getFrameworkKey(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PRODUCED:
+        case PRODUCER:
+          return FrameworkKey.create(FrameworkKey.Kind.PRODUCER, request.key());
+        case PROVIDER:
+        case LAZY:
+          return FrameworkKey.create(FrameworkKey.Kind.PROVIDER, request.key());
+        case MEMBERS_INJECTOR:
+          return FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, request.key());
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index aab819c32..1643adbc4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -49,6 +49,14 @@ public String apply(DependencyRequest dependency) {
         return variableName.endsWith("MembersInjector") && !variableName.equals("MembersInjector")
             ? variableName.substring(0, variableName.length() - 15)
             : variableName;
+      case PRODUCED:
+        return variableName.startsWith("produced") && !variableName.equals("produced")
+            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            : variableName;
+      case PRODUCER:
+        return variableName.endsWith("Producer") && !variableName.equals("Producer")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 976ca1956..d6e5038e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -61,8 +61,11 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-  FactoryGenerator(Filer filer) {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -137,7 +140,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
 
     ImmutableMap<FrameworkKey, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
+        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+            dependencyRequestMapper, binding.dependencies());
 
     for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
       ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
@@ -152,7 +156,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(names.get(FrameworkKey.forDependencyRequest(dependency))),
+          Snippet.format(names.get(dependencyRequestMapper.getFrameworkKey(dependency))),
           dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
index aab67f59e..3c61e27d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -20,6 +20,7 @@
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.Producer;
 import javax.inject.Provider;
 
 /**
@@ -38,6 +39,7 @@
   enum Kind {
     PROVIDER(Provider.class),
     MEMBERS_INJECTOR(MembersInjector.class),
+    PRODUCER(Producer.class),
     ;
 
     private final Class<?> frameworkClass;
@@ -51,19 +53,8 @@
     }
   }
 
-  // TODO(user): Pass instructions for how to handle requests for instances, since producers will
-  // handle them differently.
-  static FrameworkKey forDependencyRequest(DependencyRequest request) {
-    switch (request.kind()) {
-      case INSTANCE:
-      case PROVIDER:
-      case LAZY:
-        return new AutoValue_FrameworkKey(Kind.PROVIDER, request.key());
-      case MEMBERS_INJECTOR:
-        return new AutoValue_FrameworkKey(Kind.MEMBERS_INJECTOR, request.key());
-      default:
-        throw new AssertionError();
-    }
+  static FrameworkKey create(Kind kind, Key key) {
+    return new AutoValue_FrameworkKey(kind, key);
   }
 
   ParameterizedTypeName frameworkType() {
@@ -73,4 +64,17 @@ ParameterizedTypeName frameworkType() {
 
   abstract Kind kind();
   abstract Key key();
+
+  String defaultSuffix() {
+    switch (kind()) {
+      case PROVIDER:
+        return "Provider";
+      case MEMBERS_INJECTOR:
+        return "MembersInjector";
+      case PRODUCER:
+        return "Producer";
+      default:
+        throw new AssertionError();
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 206d483e4..3d3f700f4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -59,11 +59,17 @@
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
   private final Elements elements;
   private final Types types;
+  private final DependencyRequestMapper dependencyRequestMapper;
 
-  MembersInjectorGenerator(Filer filer, Elements elements, Types types) {
+  MembersInjectorGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -128,7 +134,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableMap<FrameworkKey, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(
-            ImmutableSet.copyOf(binding.dependencies()));
+            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
 
     ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
@@ -149,7 +155,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
           FieldWriter singleField = depedencyFields.get(
-              FrameworkKey.forDependencyRequest(fieldDependency));
+              dependencyRequestMapper.getFrameworkKey(fieldDependency));
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
               frameworkTypeUsageStatement(Snippet.format(singleField.name()),
@@ -159,7 +165,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
             FieldWriter field = depedencyFields.get(
-                FrameworkKey.forDependencyRequest(methodDependency));
+                dependencyRequestMapper.getFrameworkKey(methodDependency));
             parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
                 methodDependency.kind()));
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index f8784d6be..0844b2f50 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -17,18 +17,21 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Provides.Type;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.producers.Producer;
+import java.util.Map.Entry;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
@@ -47,8 +50,11 @@
  * @since 2.0
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
-  ProducerFactoryGenerator(Filer filer) {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  ProducerFactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -100,12 +106,24 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryWriter.addImplementedType(
         ParameterizedTypeName.create(Producer.class, providedTypeName));
 
-    // TODO(user): Add dependencies.
-
     MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
+    ImmutableMap<FrameworkKey, String> names =
+        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+            dependencyRequestMapper, binding.dependencies());
+
+    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, nameEntry.getValue());
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body()
+          .addSnippet("assert %s != null;", field.name())
+          .addSnippet("this.%1$s = %1$s;", field.name());
+    }
+
     // TODO(user): Implement this method.
     getMethodWriter.body().addSnippet("return null;");
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 176a5e06b..848772bd1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -60,12 +60,14 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   };
 
   static ImmutableSetMultimap<FrameworkKey, DependencyRequest> indexDependenciesByKey(
+      DependencyRequestMapper dependencyRequestMapper,
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
         new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>().orderValuesBy(
             DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(FrameworkKey.forDependencyRequest(dependency), dependency);
+      dependenciesByKeyBuilder.put(
+          dependencyRequestMapper.getFrameworkKey(dependency), dependency);
     }
     return dependenciesByKeyBuilder.build();
   }
@@ -84,14 +86,17 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    *         provider.
    */
   static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
+      DependencyRequestMapper dependencyRequestMapper,
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
-        indexDependenciesByKey(dependencies);
+        indexDependenciesByKey(dependencyRequestMapper, dependencies);
     Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
     ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
     for (Entry<FrameworkKey, Collection<DependencyRequest>> entry
         : dependenciesByKeyMap.entrySet()) {
+      FrameworkKey frameworkKey = entry.getKey();
+      String suffix = frameworkKey.defaultSuffix();
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
           FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
@@ -99,7 +104,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        providerNames.put(entry.getKey(), name.endsWith("Provider") ? name : name + "Provider");
+        providerNames.put(frameworkKey, name.endsWith(suffix) ? name : name + suffix);
       } else {
         // in the event that a provider is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
@@ -110,7 +115,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           compositeNameBuilder.append("And").append(
               CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        providerNames.put(entry.getKey(), compositeNameBuilder.append("Provider").toString());
+        providerNames.put(frameworkKey, compositeNameBuilder.append(suffix).toString());
       }
     }
     return providerNames.build();
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
new file mode 100644
index 000000000..f839ceaf7
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.List;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link DependencyRequestMapper}.
+ */
+@RunWith(JUnit4.class)
+public class DependencyRequestMapperTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+  private DependencyRequest.Factory dependencyRequestFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(types, keyFactory);
+  }
+
+  private List<? extends VariableElement> sampleProviderParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return providesMethod.getParameters();
+  }
+
+  private List<? extends VariableElement> sampleProducerParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodModule.class.getCanonicalName());
+    ExecutableElement producesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return producesMethod.getParameters();
+  }
+
+  private DependencyRequest dependencyRequestForInstance() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForLazy() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
+  }
+
+  private DependencyRequest dependencyRequestForProvider() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
+  }
+
+  private DependencyRequest dependencyRequestForMembersInjector() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
+  }
+
+  private DependencyRequest dependencyRequestForProducer() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForProduced() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(1));
+  }
+
+  @Test public void forProvider() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PROVIDER;
+    assertThat(mapper.getFrameworkKey(dependencyRequestForInstance()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForLazy()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForProvider()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForMembersInjector()).kind())
+        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
+  }
+
+  @Test public void forProducer() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PRODUCER;
+    assertThat(mapper.getFrameworkKey(dependencyRequestForInstance()).kind())
+        .isEqualTo(FrameworkKey.Kind.PRODUCER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForLazy()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForProvider()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForMembersInjector()).kind())
+        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForProducer()).kind())
+        .isEqualTo(FrameworkKey.Kind.PRODUCER);
+    assertThat(mapper.getFrameworkKey(dependencyRequestForProduced()).kind())
+        .isEqualTo(FrameworkKey.Kind.PRODUCER);
+  }
+
+  @Module(library = true)
+  static final class ProvidesMethodModule {
+    @Provides String provideString(
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+      return null;
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodModule {
+    @Produces String produceString(Producer<Integer> a, Produced<Integer> b) {
+      return null;
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
index c8fefcbb6..ead0488d2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
@@ -17,18 +17,15 @@
 
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
-import dagger.Lazy;
 import dagger.MembersInjector;
-import dagger.Module;
-import dagger.Provides;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
-import java.util.List;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -50,65 +47,31 @@
   private Elements elements;
   private Types types;
   private Key.Factory keyFactory;
-  private DependencyRequest.Factory dependencyRequestFactory;
 
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(types, keyFactory);
   }
 
-  private List<? extends VariableElement> sampleProviderParameters() {
-    TypeElement moduleElement =
-        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
-    ExecutableElement providesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    return providesMethod.getParameters();
-  }
-
-  private DependencyRequest dependencyRequestForInstance() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
-  }
-
-  private DependencyRequest dependencyRequestForLazy() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
-  }
-
-  private DependencyRequest dependencyRequestForProvider() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
-  }
-
-  private DependencyRequest dependencyRequestForMembersInjector() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
-  }
-
-  @Test public void forDependencyRequest() {
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForInstance()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForLazy()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForProvider()).kind())
-        .isEqualTo(FrameworkKey.Kind.PROVIDER);
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForMembersInjector()).kind())
-        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
+  private ExecutableElement getXConstructor() {
+    TypeElement classElement = elements.getTypeElement(X.class.getCanonicalName());
+    return Iterables.getOnlyElement(
+        ElementFilter.constructorsIn(classElement.getEnclosedElements()));
   }
 
   @Test public void frameworkType() {
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForInstance()).frameworkType())
+    Key key = keyFactory.forInjectConstructor(getXConstructor());
+    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    assertThat(FrameworkKey.create(FrameworkKey.Kind.PROVIDER, key).frameworkType())
         .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class), ClassName.fromClass(Integer.class)));
-    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForMembersInjector())
-        .frameworkType())
+            ClassName.fromClass(Provider.class), xClass));
+    assertThat(FrameworkKey.create(FrameworkKey.Kind.MEMBERS_INJECTOR, key).frameworkType())
         .isEqualTo(ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class), ClassName.fromClass(Integer.class)));
+            ClassName.fromClass(MembersInjector.class), xClass));
   }
 
-  @Module(library = true)
-  static final class ProvidesMethodModule {
-    @Provides String provideString(
-        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
-      return null;
-    }
+  static final class X {
+    @Inject X() {}
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 783f2f045..a19b6e31e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -280,9 +280,18 @@ private String formatModuleErrorMessage(String msg) {
           "@Qualifier @interface QualifierB {}");
 
   @Test public void multipleProvidesMethods() {
+    JavaFileObject classXFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class X {",
+        "  @Inject public String s;",
+        "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.MembersInjector;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "",
@@ -291,7 +300,8 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides List<Object> provideObjects(@QualifierA Object a, @QualifierB Object b) {",
+        "  @Provides List<Object> provideObjects(",
+        "      @QualifierA Object a, @QualifierB Object b, MembersInjector<X> x) {",
         "    return Arrays.asList(a, b);",
         "  }",
         "",
@@ -308,6 +318,7 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.Factory;",
+        "import dagger.MembersInjector;",
         "import java.util.List;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -317,22 +328,29 @@ private String formatModuleErrorMessage(String msg) {
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
         "  private final Provider<Object> bProvider;",
+        "  private final MembersInjector<X> xMembersInjector;",
         "",
-        "  public TestModule$$ProvideObjectsFactory(TestModule module,",
-        "       Provider<Object> aProvider, Provider<Object> bProvider) {",
+        "  public TestModule$$ProvideObjectsFactory(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
         "    assert module != null;",
         "    this.module = module;",
         "    assert aProvider != null;",
         "    this.aProvider = aProvider;",
         "    assert bProvider != null;",
         "    this.bProvider = bProvider;",
+        "    assert xMembersInjector != null;",
+        "    this.xMembersInjector = xMembersInjector;",
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "    return module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+    assert_().about(javaSources()).that(
+            ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 048403ed9..522636afe 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -531,4 +531,137 @@ public void publicModuleNonPublicIncludes() {
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
+
+  @Test public void singleProducesMethodArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override public ListenableFuture<String> get() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodArgsNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override public ListenableFuture<String> get() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
 }
