diff --git a/.travis.yml b/.travis.yml
index 8560e1661..49ca80a24 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -42,7 +42,7 @@ install:
   - mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
 script:
-  - bazel test //...
+  - bazel test --test_output errors //...
   - mvn -B -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
 
 env:
diff --git a/WORKSPACE b/WORKSPACE
index d8860f003..de425d11f 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -65,10 +65,16 @@ maven_jar(
     sha1 = "13f0f0dce4e710bb0bb791bd07f6e9858670a865",
 )
 
+maven_jar(
+    name = "com_google_errorprone_javac",
+    artifact = "com.google.errorprone:javac:9-dev-r3297-1-shaded",
+    sha1 = "0f6d4998965282068a3feecddc21578d23f17275",
+)
+
 maven_jar(
     name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:jar:all-deps:1.1",
-    sha1 = "cf47e1c32fa8ccc75fa3f1e2331317a866c8bd0a",
+    artifact = "com.google.googlejavaformat:google-java-format:1.2",
+    sha1 = "c897dff7c217667d797bc9bf9d54416e776e9917",
 )
 
 maven_jar(
diff --git a/android/pom.xml b/android/pom.xml
index 03ab262a9..3bd1e34f3 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2016 Google, Inc.
+ Copyright (C) 2016 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/android/src/it/functional-tests/src/test/java/test/android/BUILD b/android/src/it/functional-tests/src/test/java/test/android/BUILD
index 0b40b2636..13beefb8d 100644
--- a/android/src/it/functional-tests/src/test/java/test/android/BUILD
+++ b/android/src/it/functional-tests/src/test/java/test/android/BUILD
@@ -29,11 +29,11 @@ GenRobolectricTests(
     srcs = glob(["*.java"]),
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
     deps = [
+        "//android/src/it/functional-tests/src/main/java/test/android",
         "//third_party:guava",
         "//third_party:guava_testlib",
         "//third_party:junit",
         "//third_party:truth",
-        "//android/src/it/functional-tests/src/main/java/test/android",
     ],
 )
 
diff --git a/android/src/main/AndroidManifest.xml b/android/src/main/AndroidManifest.xml
index 5101105d1..8acac7a8f 100644
--- a/android/src/main/AndroidManifest.xml
+++ b/android/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <!--
- Copyright (C) 2016 Google, Inc.
+ Copyright (C) 2016 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/android/src/main/java/dagger/android/BUILD b/android/src/main/java/dagger/android/BUILD
index a156ed133..70060f8d4 100644
--- a/android/src/main/java/dagger/android/BUILD
+++ b/android/src/main/java/dagger/android/BUILD
@@ -30,8 +30,8 @@ android_library(
     srcs = glob(["*.java"]),
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
-        "@androidsdk//com.android.support:support-annotations-24.2.0",
-        "//third_party:auto_value",
         "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "@androidsdk//com.android.support:support-annotations-24.2.0",
     ],
 )
diff --git a/compiler/BUILD b/compiler/BUILD
index a9fc844d7..08c111641 100644
--- a/compiler/BUILD
+++ b/compiler/BUILD
@@ -47,11 +47,10 @@ java_library(
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     plugins = COMPILER_PLUGINS,
     deps = COMPILER_SHARED_DEPS + [
-        "//third_party:guava"
+        "//third_party:guava",
     ],
 )
 
-
 java_plugin(
     name = "component-codegen",
     generates_api = 1,
@@ -68,17 +67,17 @@ GenJavaTests(
     plugins = [":component-codegen"],
     deps = [
         ":compiler",
+        "//core",
+        "//producers",
         "//third_party:auto_common",
         "//third_party:auto_value",
         "//third_party:compile_testing",
+        "//third_party:guava",
         "//third_party:javapoet",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:mockito",
         "//third_party:truth",
-        "//core",
-        "//producers",
-        "//third_party:guava",
     ],
 )
 
diff --git a/compiler/pom.xml b/compiler/pom.xml
index c420563aa..1a7ab7df3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
+ Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -208,6 +207,13 @@
                     <exclude>META-INF/*.RSA</exclude>
                   </excludes>
                 </filter>
+                <!-- https://github.com/google/google-java-format/issues/114 -->
+                <filter>
+                  <artifact>com.google.errorprone:javac</artifact>
+                  <includes>
+                    <include>**</include>
+                  </includes>
+                </filter>
               </filters>
             </configuration>
           </execution>
diff --git a/compiler/src/it/functional-tests/BUILD b/compiler/src/it/functional-tests/BUILD
index 8e334ac42..1e705697e 100644
--- a/compiler/src/it/functional-tests/BUILD
+++ b/compiler/src/it/functional-tests/BUILD
@@ -35,15 +35,14 @@ java_library(
     # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
     # used without a Guava and jsr305 deps.
     deps = [
+        "//:dagger_with_compiler",
         "//third_party:auto_factory",
         "//third_party:auto_value",
-        "//:dagger_with_compiler",
         "//third_party:jsr330_inject",
         "//third_party:junit",
     ],
 )
 
-
 load("//:test_defs.bzl", "GenJavaTests")
 
 GenJavaTests(
@@ -54,15 +53,14 @@ GenJavaTests(
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         ":code_under_test",
-        "//third_party:guava_testlib",
-        "//third_party:guava",
-        "//third_party:auto_value",
         "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:truth",
     ],
 )
 
-
 test_suite(name = "AllTests")
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 6845c5951..9bf20565a 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 6f8be978f..8bb18db55 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -43,13 +43,6 @@ static String provideFooKey(@SuppressWarnings("unused") double doubleDependency)
     return "foo value";
   }
 
-  @Provides
-  @IntoMap
-  @StringKey("foo @Provides(type)")
-  static String provideFooProvidesTypeKey(@SuppressWarnings("unused") double doubleDependency) {
-    return "foo @Provides(type) value";
-  }
-
   @Provides
   @IntoMap
   @StringKey("bar")
@@ -83,15 +76,9 @@ static int provideSixToSet() {
     return 6;
   }
 
-  @Provides
-  @IntoSet
-  static int provideIntoSetWithProvidesType() {
-    return -100;
-  }
-
   @Provides
   @ElementsIntoSet
-  static Set<Integer> provideElementsIntoSetWithProvidesType() {
+  static Set<Integer> provideElementsIntoSet() {
     Set<Integer> set = new HashSet<>();
     set.add(-101);
     set.add(-102);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
new file mode 100644
index 000000000..c965bc224
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import dagger.BindsInstance;
+import javax.inject.Named;
+
+interface BuilderSupertype {
+  @BindsInstance
+  void boundInSubtype(@Named("subtype") int subtype);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
index 2fefb3f86..75d470b9a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
@@ -36,8 +36,11 @@
 
   List<String> listOfString();
 
+  @Named("subtype")
+  int boundInSubtype();
+
   @Component.Builder
-  interface Builder {
+  interface Builder extends BuilderSupertype {
     @BindsInstance
     Builder count(int count);
 
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 0cb664293..89b75cb13 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -65,10 +65,9 @@ public MultibindingTest(MultibindingComponent multibindingComponent) {
 
   @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
-    assertThat(map).hasSize(3);
+    assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
-    assertThat(map).containsEntry("foo @Provides(type)", "foo @Provides(type) value");
   }
 
   @Test public void mapOfArrays() {
@@ -82,18 +81,16 @@ public MultibindingTest(MultibindingComponent multibindingComponent) {
 
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
-    assertThat(mapOfProviders).hasSize(3);
+    assertThat(mapOfProviders).hasSize(2);
     assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
     assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
-    assertThat(mapOfProviders.get("foo @Provides(type)").get())
-        .isEqualTo("foo @Provides(type) value");
   }
 
   @Test public void mapKeysAndValues() {
     assertThat(multibindingComponent.mapKeys())
-        .containsExactly("foo", "bar", "foo @Provides(type)");
+        .containsExactly("foo", "bar");
     assertThat(multibindingComponent.mapValues())
-        .containsExactly("foo value", "bar value", "foo @Provides(type) value");
+        .containsExactly("foo value", "bar value");
   }
 
   @Test public void nestedKeyMap() {
@@ -164,7 +161,7 @@ public void shortKeyMap() {
 
   @Test public void setBindings() {
     assertThat(multibindingComponent.set())
-        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -100, -101, -102);
+        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -101, -102);
   }
 
   @Test
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
index 377369d41..01c73842e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
@@ -24,20 +24,22 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import test.builderbinds.TestComponent.Builder;
 
 @RunWith(JUnit4.class)
 public final class BuilderBindsTest {
 
   @Test
   public void builderBinds() {
-    TestComponent component =
+    TestComponent.Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
             .nullableInput("bar")
-            .listOfString(Arrays.asList("x", "y", "z"))
-            .build();
+            .listOfString(Arrays.asList("x", "y", "z"));
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isEqualTo("bar");
@@ -46,14 +48,16 @@ public void builderBinds() {
 
   @Test
   public void builderBindsNullableWithNull() {
-    TestComponent component =
+    Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
             .nullableInput(null)
-            .listOfString(Collections.<String>emptyList())
-            .build();
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isNull();
@@ -72,12 +76,14 @@ public void builderBindsNonNullableWithNull() {
   @Test
   public void builderBindsPrimitiveNotSet() {
     try {
-      DaggerTestComponent.builder()
-          .l(10L)
-          .input("foo")
-          .nullableInput("bar")
-          .listOfString(Collections.<String>emptyList())
-          .build();
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .l(10L)
+              .input("foo")
+              .nullableInput("bar")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
       fail("expected IllegalStateException");
     } catch (IllegalStateException expected) {
     }
@@ -86,12 +92,14 @@ public void builderBindsPrimitiveNotSet() {
   @Test
   public void builderBindsNonNullableNotSet() {
     try {
-      DaggerTestComponent.builder()
-          .count(5)
-          .l(10L)
-          .nullableInput("foo")
-          .listOfString(Collections.<String>emptyList())
-          .build();
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .count(5)
+              .l(10L)
+              .nullableInput("foo")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
       fail("expected IllegalStateException");
     } catch (IllegalStateException expected) {
     }
@@ -99,13 +107,14 @@ public void builderBindsNonNullableNotSet() {
 
   @Test
   public void builderBindsNullableNotSet() {
-    TestComponent component =
+    Builder builder =
         DaggerTestComponent.builder()
             .count(5)
             .l(10L)
             .input("foo")
-            .listOfString(Collections.<String>emptyList())
-            .build();
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
     assertThat(component.count()).isEqualTo(5);
     assertThat(component.input()).isEqualTo("foo");
     assertThat(component.nullableInput()).isNull();
diff --git a/compiler/src/it/guava-functional-tests/BUILD b/compiler/src/it/guava-functional-tests/BUILD
index 24c8eb6a9..a94af72b1 100644
--- a/compiler/src/it/guava-functional-tests/BUILD
+++ b/compiler/src/it/guava-functional-tests/BUILD
@@ -25,9 +25,9 @@ java_library(
     srcs = glob(["src/main/java/**/*.java"]),
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
     deps = [
-        "//third_party:guava",
-        "//third_party:auto_value",
         "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
         "//third_party:jsr330_inject",
         "//third_party:junit",
     ],
@@ -41,9 +41,9 @@ GenJavaTests(
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
     deps = [
         ":code_under_test",
-        "//third_party:guava",
-        "//third_party:auto_value",
         "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:truth",
diff --git a/compiler/src/it/guava-functional-tests/pom.xml b/compiler/src/it/guava-functional-tests/pom.xml
index d8f1a65f2..6bf0fc074 100644
--- a/compiler/src/it/guava-functional-tests/pom.xml
+++ b/compiler/src/it/guava-functional-tests/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2016 Google, Inc.
+Copyright (C) 2016 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/producers-functional-tests/BUILD b/compiler/src/it/producers-functional-tests/BUILD
index b9154cbda..79e137ce1 100644
--- a/compiler/src/it/producers-functional-tests/BUILD
+++ b/compiler/src/it/producers-functional-tests/BUILD
@@ -31,9 +31,9 @@ java_library(
     srcs = glob(["src/main/java/**/*.java"]),
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
     deps = [
-        "//third_party:guava",
-        "//third_party:auto_value",
         "//:producers_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
         "//third_party:jsr330_inject",
     ],
 )
@@ -46,8 +46,8 @@ GenJavaTests(
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         ":code_under_test",
-        "//third_party:guava",
         "//:producers_with_compiler",
+        "//third_party:guava",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:mockito",
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index 3006318b2..0bf75f6a7 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index fb8979013..0bc1b455f 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index ab90e093c..8165da85e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -16,11 +16,19 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_NOT_IN_BUILDER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_INVALID_COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_ONE_PARAMETER;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.BindsInstance;
@@ -28,8 +36,11 @@
 import java.util.Set;
 import java.util.stream.Stream;
 import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.tools.Diagnostic.Kind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 
 /**
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
@@ -37,9 +48,13 @@
  */
 final class BindsInstanceProcessingStep implements ProcessingStep {
 
-  private static final ImmutableSet<Class<? extends Annotation>> VALID_CONTAINING_ANNOTATIONS =
+  private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
       Stream.of(ComponentDescriptor.Kind.values())
-          .map(ComponentDescriptor.Kind::builderAnnotationType)
+          .map(ComponentDescriptor.Kind::annotationType)
+          .collect(toImmutableSet());
+  private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
+      Stream.of(ModuleDescriptor.Kind.values())
+          .map(ModuleDescriptor.Kind::moduleAnnotation)
           .collect(toImmutableSet());
 
   private final Messager messager;
@@ -57,9 +72,32 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
-      if (!isAnyAnnotationPresent(element.getEnclosingElement(), VALID_CONTAINING_ANNOTATIONS)) {
-        messager.printMessage(Kind.ERROR, BINDS_INSTANCE_NOT_IN_BUILDER, element);
+      ExecutableElement method = MoreElements.asExecutable(element);
+      ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        report.addError("@BindsInstance methods must be abstract");
+      }
+      if (method.getParameters().size() != 1) {
+        report.addError(BINDS_INSTANCE_ONE_PARAMETER);
+      } else {
+        VariableElement parameter = getOnlyElement(method.getParameters());
+        if (FrameworkTypes.isFrameworkType(parameter.asType())) {
+          report.addError("@BindsInstance parameters may not be framework types", parameter);
+        }
+      }
+      TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+      if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
+        report.addError(
+            String.format(
+                BINDS_INSTANCE_IN_MODULE, simpleName(getModuleAnnotation(enclosingType).get())));
+      }
+      if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
+        AnnotationMirror componentAnnotation =
+            getComponentOrSubcomponentAnnotation(enclosingType).get();
+        report.addError(
+            String.format(BINDS_INSTANCE_IN_INVALID_COMPONENT, simpleName(componentAnnotation)));
       }
+      report.build().printMessagesTo(messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index f7e9b2132..b979128ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -37,6 +37,7 @@
   abstract Diagnostic.Kind staticMemberValidationKind();
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
   abstract ValidationType scopeCycleValidationType();
+  abstract boolean warnIfInjectionFactoryNotGeneratedUpstream();
 
   static Builder builder() {
     return new AutoValue_CompilerOptions.Builder();
@@ -56,6 +57,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
             ignorePrivateAndStaticInjectionForComponent(processingEnv)
                 .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
+        .warnIfInjectionFactoryNotGeneratedUpstream(
+            warnIfInjectionFactoryNotGeneratedUpstream(processingEnv).equals(FeatureStatus.ENABLED))
         .build();
   }
 
@@ -69,6 +72,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
     Builder ignorePrivateAndStaticInjectionForComponent(
         boolean ignorePrivateAndStaticInjectionForComponent);
     Builder scopeCycleValidationType(ValidationType type);
+    Builder warnIfInjectionFactoryNotGeneratedUpstream(
+        boolean warnIfInjectionFactoryNotGeneratedUpstream);
     CompilerOptions build();
   }
 
@@ -83,6 +88,9 @@ Builder ignorePrivateAndStaticInjectionForComponent(
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  static final String WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY =
+      "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
+
   /**
    * If true, Dagger will generate factories and components even if some members-injected types
    * have private or static {@code @Inject}-annotated members.
@@ -99,6 +107,7 @@ Builder ignorePrivateAndStaticInjectionForComponent(
         NULLABLE_VALIDATION_KEY,
         PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
         STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
         IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
   private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
@@ -150,6 +159,15 @@ private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
         EnumSet.allOf(FeatureStatus.class));
   }
 
+  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstream(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 931664330..b47fbf983 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -156,7 +156,8 @@ public SourceVersion getSupportedSourceVersion() {
             injectValidator,
             keyFactory,
             provisionBindingFactory,
-            membersInjectionBindingFactory);
+            membersInjectionBindingFactory,
+            compilerOptions);
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
         new ModuleDescriptor.Factory(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index fe5bd95d5..d5e7c9b5a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -70,6 +70,14 @@
     return getAnyAnnotation(subcomponent, Subcomponent.class, ProductionSubcomponent.class);
   }
 
+  static Optional<AnnotationMirror> getComponentOrSubcomponentAnnotation(TypeElement type) {
+    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
+    if (componentAnnotation.isPresent()) {
+      return componentAnnotation;
+    }
+    return getSubcomponentAnnotation(type);
+  }
+
   static boolean isSubcomponent(Element element) {
     return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index 72ba2862d..e3f8e37a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -24,9 +24,7 @@
 import dagger.multibindings.IntoSet;
 import javax.lang.model.element.ExecutableElement;
 
-/**
- * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
- */
+/** Whether a binding or declaration is for a unique contribution or a map or set multibinding. */
 enum ContributionType {
   /** Represents map bindings. */
   MAP,
@@ -38,41 +36,21 @@
   UNIQUE,
   ;
 
-  /**
-   * An object that is associated with a {@link ContributionType}.
-   */
+  /** An object that is associated with a {@link ContributionType}. */
   interface HasContributionType {
 
     /** The contribution type of this object. */
     ContributionType contributionType();
   }
 
-  /**
-   * {@code true} if this is for a multibinding.
-   */
+  /** {@code true} if this is for a multibinding. */
   boolean isMultibinding() {
     return !this.equals(UNIQUE);
   }
 
-  /** The contribution type for a given provision type. */
-  private static ContributionType forProvisionType(Provides.Type provisionType) {
-    switch (provisionType) {
-      case SET:
-        return SET;
-      case SET_VALUES:
-        return SET_VALUES;
-      case MAP:
-        return MAP;
-      case UNIQUE:
-        return UNIQUE;
-      default:
-        throw new AssertionError("Unknown provision type: " + provisionType);
-    }
-  }
-
   /**
    * The contribution type from a binding method annotations. Presumes a well-formed binding method
-   * (only one of @IntoSet, @IntoMap, @ElementsIntoSet, @Provides.type or @Produces.type. {@link
+   * (at most one of @IntoSet, @IntoMap, @ElementsIntoSet and @Provides.type). {@link
    * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
    */
   static ContributionType fromBindingMethod(ExecutableElement method) {
@@ -83,11 +61,6 @@ static ContributionType fromBindingMethod(ExecutableElement method) {
     } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {
       return ContributionType.SET_VALUES;
     }
-
-    if (isAnnotationPresent(method, Provides.class)) {
-      return forProvisionType(method.getAnnotation(Provides.class).type());
-    } else {
-      return ContributionType.UNIQUE;
-    }
+    return ContributionType.UNIQUE;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
index fe0fa02b2..f88dcdecc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -161,4 +161,12 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
         annotationClassNames.contains(
             MoreTypes.asTypeElement(annotation.getAnnotationType()).getQualifiedName().toString());
   }
+
+  static ImmutableSet<String> suppressedWarnings(Element element) {
+    SuppressWarnings suppressedWarnings = element.getAnnotation(SuppressWarnings.class);
+    if (suppressedWarnings == null) {
+      return ImmutableSet.of();
+    }
+    return ImmutableSet.copyOf(suppressedWarnings.value());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index ae15635e3..9e398c4a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -24,7 +24,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
-import dagger.Provides;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -322,8 +321,15 @@ static String nullableToNonNullable(String typeName, String bindingString) {
       "@%s.type cannot be used with multibinding annotations";
 
   /* BindsInstance messages. */
-  static final String BINDS_INSTANCE_NOT_IN_BUILDER =
-      "@BindsInstance must annotate a method in a component builder";
+  static final String BINDS_INSTANCE_IN_MODULE =
+      "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?";
+
+  static final String BINDS_INSTANCE_IN_INVALID_COMPONENT =
+      "@BindsInstance methods should not be included in @%1$ss. "
+          + "Did you mean to put it in a @%1$s.Builder?";
+
+  static final String BINDS_INSTANCE_ONE_PARAMETER =
+      "@BindsInstance methods should have exactly one parameter for the bound type";
 
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
@@ -648,9 +654,6 @@ static String moduleSubcomponentsDoesntHaveBuilder(
    *     through this method.
    */
   static String stripCommonTypePrefixes(String type) {
-    // Special case this enum's constants since they will be incredibly common.
-    type = type.replace(Provides.Type.class.getCanonicalName() + ".", "");
-
     // Do regex magic to remove common packages we care to shorten.
     Matcher matcher = COMMON_PACKAGE_PATTERN.matcher(type);
     StringBuilder result = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 5b87629e8..2169c4ba5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -63,6 +63,7 @@
   private final Key.Factory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final CompilerOptions compilerOptions;
 
   final class BindingsCollection<B extends Binding> {
     private final BindingType bindingType;
@@ -105,7 +106,8 @@ void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {
     void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
       if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
         bindingsRequiringGeneration.offer(binding);
-        if (warnIfNotAlreadyGenerated) {
+        if (compilerOptions.warnIfInjectionFactoryNotGeneratedUpstream()
+            && warnIfNotAlreadyGenerated) {
           messager.printMessage(
               Kind.NOTE,
               String.format(
@@ -152,7 +154,8 @@ private void tryToCacheBinding(B binding) {
       InjectValidator injectValidator,
       Key.Factory keyFactory,
       ProvisionBinding.Factory provisionBindingFactory,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory) {
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      CompilerOptions compilerOptions) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
@@ -160,6 +163,7 @@ private void tryToCacheBinding(B binding) {
     this.keyFactory = keyFactory;
     this.provisionBindingFactory = provisionBindingFactory;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 3dd9e7ce2..bc71b08f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -45,8 +45,6 @@
  * @author Jesse Beder
  * @since 2.0
  */
-// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
-// Produces.Type are reconciled.
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   ProducesMethodValidator(Elements elements, Types types) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index cacd83332..b095819e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1183,8 +1183,6 @@ public void testDefaultPackage() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.multibindings.ElementsIntoSet;",
@@ -2356,7 +2354,9 @@ public void genericTestToLetMeDebugInEclipse() {
   public void unprocessedMembersInjectorNotes() {
     Compilation compilation =
         javac()
-            .withOptions("-Xlint:-processing")
+            .withOptions(
+                "-Xlint:-processing",
+                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
             .withProcessors(
                 new ElementFilteringComponentProcessor(
                     Predicates.not(
@@ -2613,6 +2613,9 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
         .hasSourceEquivalentTo(generated);
   }
 
+  // TODO(b/34107586): Fix and enable test.
+  @Test
+  @Ignore
   public void invalidComponentDependencies() {
     JavaFileObject testComponent =
         JavaFileObjects.forSourceLines(
@@ -2682,16 +2685,16 @@ public void bindsInstanceInModule() {
             "",
             "import dagger.BindsInstance;",
             "import dagger.Module;",
-            "import dagger.Provides;",
             "",
             "@Module",
-            "final class TestModule {",
-            "  @BindsInstance String s() { return null; }",
+            "abstract class TestModule {",
+            "  @BindsInstance abstract void str(String string);",
             "}");
     Compilation compilation = daggerCompiler().compile(testModule);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
   }
 
   @Test
@@ -2706,12 +2709,105 @@ public void bindsInstanceInComponent() {
             "",
             "@Component",
             "interface TestComponent {",
-            "  @BindsInstance String s();",
+            "  @BindsInstance String s(String s);",
             "}");
     Compilation compilation = daggerCompiler().compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Components. "
+                + "Did you mean to put it in a @Component.Builder?");
+  }
+
+  @Test
+  public void bindsInstanceNotAbstract() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNotAbstract",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "class BindsInstanceNotAbstract {",
+            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance methods must be abstract")
+        .inFile(notAbstract)
+        .onLine(7);
+  }
+
+  @Test
+  public void bindsInstanceNoParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameters",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceNoParameters {",
+            "  @BindsInstance void noParams();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceManyParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameter",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceManyParameters {",
+            "  @BindsInstance void manyParams(int i, long l);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceFrameworkType() {
+    JavaFileObject bindsFrameworkType =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceFrameworkType",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Producer;",
+            "import javax.inject.Provider;",
+            "",
+            "interface BindsInstanceFrameworkType {",
+            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
+            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(8);
+
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(9);
   }
 
   private static Compiler daggerCompiler(Processor... extraProcessors) {
@@ -2748,6 +2844,11 @@ public SourceVersion getSupportedSourceVersion() {
       return componentProcessor.getSupportedSourceVersion();
     }
 
+    @Override
+    public Set<String> getSupportedOptions() {
+      return componentProcessor.getSupportedOptions();
+    }
+
     @Override
     public boolean process(
         Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 0cea3c2ab..a271187ef 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -148,8 +148,6 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.multibindings.IntoMap;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
index 2ba66056b..dce0b65d2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 
 import com.google.testing.compile.JavaFileObjects;
@@ -26,41 +27,6 @@
 
 @RunWith(JUnit4.class)
 public class MultibindingTest {
-  @Test
-  public void providesTypeAndAnnotationOnSameMethod_failsToCompile() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingModule",
-            "package test;",
-            "",
-            "import static dagger.Provides.Type.SET;",
-            "import static dagger.Provides.Type.UNIQUE;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class MultibindingModule {",
-            "  @Provides(type = SET) @IntoSet Integer provideInt() { ",
-            "    return 1;",
-            "  }",
-            "  @Provides(type = UNIQUE) @IntoSet Integer provideConflictingMultibindingTypes() { ",
-            "    return 2;",
-            "  }",
-            "}");
-
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
-        .in(module)
-        .onLine(12)
-        .and()
-        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
-        .in(module)
-        .onLine(15);
-  }
 
   @Test
   public void providesWithTwoMultibindingAnnotations_failsToCompile() {
diff --git a/core/pom.xml b/core/pom.xml
index 96967f7c8..4641a5f5c 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 7e7baf78b..de204557b 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -19,7 +19,6 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -46,52 +45,4 @@
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
 public @interface Provides {
-  /** The type of binding into which the return type of the annotated method contributes. */
-  @Deprecated
-  enum Type {
-    /**
-     * The method is the only one which can produce the value for the specified return type. This
-     * is the default behavior.
-     */
-    UNIQUE,
-
-    /**
-     * The method's return type forms the generic type argument of a {@code Set<T>}, and the
-     * returned value is contributed to the set. The object graph will pass dependencies to the
-     * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
-     * immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET,
-
-    /**
-     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
-     * contributed to the set. An example use is to provide a default empty set binding, which is
-     * otherwise not possible using {@link #SET}.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET_VALUES,
-
-    /**
-     * The method's return type forms the type argument for the value of a
-     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
-     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
-     * the accumulation of values will be immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
-     *      multibinding</a>
-     */
-    @Beta
-    MAP;
-  }
-
-  /**
-   * @deprecated Use the multibinding annotations in {@link dagger.multibindings}.
-   */
-  @Deprecated
-  Type type() default Type.UNIQUE;
 }
diff --git a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
index 95bfa222f..829fd4c41 100644
--- a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
+++ b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -38,14 +38,14 @@
  * be in any one of four states at a time:
  *
  * <ul>
- * <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link WeakReference}
- *     are both {@code null}.
- * <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
- *     WeakReference}'s value is {@code null}.
- * <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached value,
- *     and its {@link WeakReference} is {@code null}.
- * <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
- *     {@link WeakReference}'s value is not {@code null}.
+ *   <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link
+ *       WeakReference} are both {@code null}.
+ *   <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
+ *       WeakReference}'s value is {@code null}.
+ *   <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached
+ *       value, and its {@link WeakReference} is {@code null}.
+ *   <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
+ *       {@link WeakReference}'s value is not {@code null}.
  * </ul>
  *
  * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
@@ -56,14 +56,15 @@
  * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
  * in <b>strong-reference</b> state to <b>weak-reference</b> state.
  *
- * <p>{@link #restoreStrongReference()} transitions all providers within {@link #scope()} that are
+ * <p>{@link #restoreStrongReferences()} transitions all providers within {@link #scope()} that are
  * in <b>weak-reference</b> state to <b>strong-reference</b> state.
  *
  * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
  * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
  * state.
  *
- * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png">
+ * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png"
+ * alt="ReleasableReferenceManager state machine">
  *
  * <p>This interface is implemented by Dagger.
  *
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 1843eacb3..83247d6e5 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index d0dee3b15..75183cdef 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/examples/pom.xml b/examples/pom.xml
index 95406ea8f..bbf1becec 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Google, Inc.
- Copyright (C) 2013 Square, Inc.
+  Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index c261d4df1..145c5e22b 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+  Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 1f1f0e04f..a182efe64 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2015 Google, Inc.
+ Copyright (C) 2015 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -40,39 +40,10 @@
       <classifier>sources</classifier>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject</artifactId>
+      <classifier>sources</classifier>
+    </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <!--
-        Include JSR 330 sources in dagger-gwt to avoid implicit
-        compilation warnings in downstream projects.
-      -->
-      <plugin>
-        <artifactId>maven-dependency-plugin</artifactId>
-        <version>2.10</version>
-        <executions>
-          <execution>
-            <id>unpack-jsr330-sources</id>
-            <goals>
-              <goal>unpack</goal>
-            </goals>
-            <configuration>
-              <artifactItems>
-                <artifactItem>
-                  <groupId>javax.inject</groupId>
-                  <artifactId>javax.inject</artifactId>
-                  <version>${javax.inject.version}</version>
-                  <type>java-source</type>
-                  <overWrite>true</overWrite>
-                  <outputDirectory>${project.build.outputDirectory}/dagger/super/</outputDirectory>
-                </artifactItem>
-              </artifactItems>
-            </configuration>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-
 </project>
diff --git a/gwt/src/main/resources/dagger/Dagger.gwt.xml b/gwt/src/main/resources/dagger/Dagger.gwt.xml
index f81c5c00c..ad106fd22 100644
--- a/gwt/src/main/resources/dagger/Dagger.gwt.xml
+++ b/gwt/src/main/resources/dagger/Dagger.gwt.xml
@@ -1,5 +1,5 @@
 <!--
- Copyright (C) 2015 Google, Inc.
+  Copyright (C) 2015 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -14,6 +14,7 @@
   limitations under the License.
 -->
 <module>
+  <inherits name="javax.inject.Inject" />
+
   <source path=""/>
-  <super-source path="super"/>
 </module>
diff --git a/gwt/src/main/resources/javax/inject/Inject.gwt.xml b/gwt/src/main/resources/javax/inject/Inject.gwt.xml
new file mode 100644
index 000000000..b6349264f
--- /dev/null
+++ b/gwt/src/main/resources/javax/inject/Inject.gwt.xml
@@ -0,0 +1,18 @@
+<!--
+ Copyright (C) 2017 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<module>
+  <source path=""/>
+</module>
diff --git a/pom.xml b/pom.xml
index b55344445..b8db19aec 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-  Copyright (C) 2012 Google, Inc.
-  Copyright (C) 2012 Square, Inc.
+  Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -78,6 +77,12 @@
         <artifactId>javax.inject</artifactId>
         <version>1</version>
       </dependency>
+      <dependency>
+        <groupId>javax.inject</groupId>
+        <artifactId>javax.inject</artifactId>
+        <classifier>sources</classifier>
+        <version>1</version>
+      </dependency>
       <dependency>
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject-tck</artifactId>
@@ -101,7 +106,7 @@
       <dependency>
         <groupId>com.google.googlejavaformat</groupId>
         <artifactId>google-java-format</artifactId>
-        <version>1.1</version>
+        <version>1.2</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
diff --git a/producers/BUILD b/producers/BUILD
index 66f9c10b3..df23036ab 100644
--- a/producers/BUILD
+++ b/producers/BUILD
@@ -39,14 +39,13 @@ java_library(
         "//third_party:jsr330_inject",
     ],
     deps = [
+        "//core",
         "//third_party:guava",
         "//third_party:jsr305_annotations",
         "//third_party:jsr330_inject",
-        "//core",
     ],
 )
 
-
 load("//:test_defs.bzl", "GenJavaTests")
 
 GenJavaTests(
@@ -56,9 +55,9 @@ GenJavaTests(
     deps = [
         ":producers",
         "//third_party:guava",
+        "//third_party:guava_testlib",
         "//third_party:junit",
         "//third_party:mockito",
         "//third_party:truth",
-        "//third_party:guava_testlib",
     ],
 )
diff --git a/producers/pom.xml b/producers/pom.xml
index 820c45aa5..67aafefd6 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2014 Google, Inc.
+ Copyright (C) 2014 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index d982132fc..f86408393 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,6 +16,9 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -69,7 +72,7 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           @Override
           public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(
                         map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
@@ -78,7 +81,8 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
                   public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
         });
   }
@@ -93,14 +97,15 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
             @Override
             public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   Producers.createFutureProduced(entry.getValue().get()),
                   new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
                     @Override
                     public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index b5104f01d..d02c9ca90 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -16,6 +16,9 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -65,7 +68,7 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
           @Override
           public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
                 new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
@@ -73,7 +76,8 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
                   public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
         });
   }
@@ -86,14 +90,15 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
             @Override
             public ListenableFuture<Map.Entry<Object, Object>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   entry.getValue().get(),
                   new Function<Object, Map.Entry<Object, Object>>() {
                     @Override
                     public Map.Entry<Object, Object> apply(Object value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 4d9d17c4c..029bcb51a 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -17,6 +17,9 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.catchingAsync;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
@@ -49,17 +52,19 @@
   // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
-    return Futures.catchingAsync(
-        Futures.transform(
+    return catchingAsync(
+        transform(
             future,
             new Function<T, Produced<T>>() {
               @Override
               public Produced<T> apply(final T value) {
                 return Produced.successful(value);
               }
-            }),
+            },
+            directExecutor()),
         Throwable.class,
-        Producers.<T>futureFallbackForProduced());
+        Producers.<T>futureFallbackForProduced(),
+        directExecutor());
 
   }
 
@@ -82,11 +87,15 @@
    * future.
    */
   public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
-    return Futures.transform(future, new Function<T, Set<T>>() {
-      @Override public Set<T> apply(T value) {
-        return ImmutableSet.of(value);
-      }
-    });
+    return transform(
+        future,
+        new Function<T, Set<T>>() {
+          @Override
+          public Set<T> apply(T value) {
+            return ImmutableSet.of(value);
+          }
+        },
+        directExecutor());
   }
 
   /**
@@ -97,14 +106,15 @@
    */
   public static <T> ListenableFuture<Set<T>> allAsSet(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
-    return Futures.transform(
+    return transform(
         Futures.allAsList(futures),
         new Function<List<T>, Set<T>>() {
           @Override
           public Set<T> apply(List<T> values) {
             return ImmutableSet.copyOf(values);
           }
-        });
+        },
+        directExecutor());
   }
 
   /**
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index c8d75b3e6..ff25ad709 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -17,6 +17,8 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static dagger.internal.DaggerCollections.hasDuplicates;
 import static dagger.internal.DaggerCollections.presizedList;
 
@@ -137,7 +139,7 @@ private SetProducer(
     for (Producer<Collection<T>> producer : collectionProducers) {
       futureCollections.add(checkNotNull(producer.get()));
     }
-    return Futures.transform(
+    return transform(
         Futures.allAsList(futureCollections),
         new Function<List<Collection<T>>, Set<T>>() {
           @Override
@@ -148,6 +150,7 @@ private SetProducer(
             }
             return builder.build();
           }
-        });
+        },
+        directExecutor());
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 6a3ad1148..a7ead827d 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -16,8 +16,10 @@
 
 package dagger.producers.monitoring;
 
+import static com.google.common.util.concurrent.Futures.addCallback;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
@@ -160,7 +162,7 @@ public void failed(@SuppressWarnings("unused") Throwable t) {}
    * overridden in the framework!
    */
   public <T> void addCallbackTo(ListenableFuture<T> future) {
-    Futures.addCallback(
+    addCallback(
         future,
         new FutureCallback<T>() {
           @Override
@@ -172,7 +174,8 @@ public void onSuccess(T value) {
           public void onFailure(Throwable t) {
             failed(t);
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final ProducerMonitor NO_OP =
diff --git a/third_party/BUILD b/third_party/BUILD
index e8e6cad4f..7aa46968c 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -142,7 +142,13 @@ java_library(
 
 java_library(
     name = "google_java_format",
-    exports = ["@com_google_googlejavaformat_google_java_format//jar"],
+    exports = [
+        "@com_google_googlejavaformat_google_java_format//jar",
+    ],
+    runtime_deps = [
+        ":guava",
+        "@com_google_errorprone_javac//jar",
+    ],
 )
 
 java_library(
diff --git a/util/maven/xml_formatting.py b/util/maven/xml_formatting.py
index 54ee89a0f..71db83b8b 100644
--- a/util/maven/xml_formatting.py
+++ b/util/maven/xml_formatting.py
@@ -21,8 +21,7 @@
 """.strip()
 
 def maven_dependency_xml(artifact_string):
-  group, artifact = artifact_string.split(':')[0:2]
-  version = artifact_string.split(':')[-1]
+  group, artifact, version = artifact_string.split(':')
   formatted = DEP_BLOCK % (group, artifact, version)
   return '\n'.join(['    %s' %x for x in formatted.split('\n')])
 
@@ -51,7 +50,7 @@ def maven_dependency_xml(artifact_string):
     <version>7</version>
   </parent>
 
-  <groupId>com.google.dagger</groupId>
+  <groupId>{group}</groupId>
   <artifactId>{artifact}</artifactId>
   <name>{name}</name>
   <version>{version}</version>
@@ -90,13 +89,12 @@ def maven_dependency_xml(artifact_string):
 """
 
 def generate_pom(artifact_string, metadata, deps, version):
-  artifact = artifact_string.split(':')[1]
-  # accounts for classifiers in artifact string
-  version = artifact_string.split(':')[-1]
+  group, artifact, version = artifact_string.split(':')
 
   return POM_OUTLINE.format(
-      artifact = artifact,
-      name = metadata['name'],
-      version = version,
-      packaging = metadata.get('packaging', 'jar'),
-      deps = '\n'.join(map(maven_dependency_xml, deps)))
+      group=group,
+      artifact=artifact,
+      name=metadata['name'],
+      version=version,
+      packaging=metadata.get('packaging', 'jar'),
+      deps='\n'.join(map(maven_dependency_xml, deps)))
