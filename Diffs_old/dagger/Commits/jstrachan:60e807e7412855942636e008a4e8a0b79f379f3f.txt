diff --git a/compiler/pom.xml b/compiler/pom.xml
index 72252f1dd..a49cfae99 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -31,6 +31,11 @@
   </description>
 
   <dependencies>
+    <dependency>
+      <groupId>javax.enterprise</groupId>
+      <artifactId>cdi-api</artifactId>
+      <version>1.2</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
@@ -70,6 +75,7 @@
       <version>1.0</version>
     </dependency>
 
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index c35058ba3..f99916ab1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -99,7 +99,8 @@ public SourceVersion getSupportedSourceVersion() {
             methodSignatureFormatter,
             Module.class,
             ImmutableList.<Class<? extends Annotation>>of(Module.class),
-            Provides.class);
+            Provides.class,
+            javax.enterprise.inject.Produces.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     BuilderValidator componentBuilderValidator =
         new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f0bd3a04f..dee2e598c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -216,13 +216,18 @@ Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
       checkArgument(method.getKind().equals(METHOD));
       Provides providesAnnotation = method.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
+      javax.enterprise.inject.Produces producesAnnotation = null;
+      if (providesAnnotation == null) {
+        producesAnnotation = method.getAnnotation(javax.enterprise.inject.Produces.class);
+      }
+      checkArgument(providesAnnotation != null || producesAnnotation != null);
+      Provides.Type providesType = providesAnnotation != null ? providesAnnotation.type() : Provides.Type.UNIQUE;
       TypeMirror returnType = normalize(types, executableType.getReturnType());
       TypeMirror keyType =
           providesOrProducesKeyType(
               returnType,
               method,
-              Optional.of(providesAnnotation.type()),
+              Optional.of(providesType),
               Optional.<Produces.Type>absent());
       return forMethod(method, keyType);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c938af2c3..903b5fb3e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -70,7 +70,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
-        if (isAnnotationPresent(moduleMethod, Provides.class)) {
+        if (isAnnotationPresent(moduleMethod, Provides.class) || isAnnotationPresent(moduleMethod, javax.enterprise.inject.Produces.class)) {
           bindings.add(
               provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement.asType()));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 1afda7d90..f90c4a7dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -66,7 +66,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Module.class, Provides.class);
+    return ImmutableSet.of(Module.class, Provides.class, javax.enterprise.inject.Produces.class);
   }
 
   @Override
@@ -85,6 +85,17 @@
         }
       }
     }
+    for (Element providesElement : elementsByAnnotation.get(javax.enterprise.inject.Produces.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
     ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
 
     // process each module
@@ -103,6 +114,9 @@
           if (isAnnotationPresent(methodElement, Provides.class)) {
             moduleProvidesMethodsBuilder.add(methodElement);
           }
+          if (isAnnotationPresent(methodElement, javax.enterprise.inject.Produces.class)) {
+            moduleProvidesMethodsBuilder.add(methodElement);
+          }
         }
         ImmutableSet<ExecutableElement> moduleProvidesMethods =
             moduleProvidesMethodsBuilder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 8b0c9a217..dd25349bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -72,7 +72,7 @@
   private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
   private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
-  private final Class<? extends Annotation> methodClass;
+  private final Class<? extends Annotation>[] methodClasses;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
@@ -81,12 +81,12 @@
       MethodSignatureFormatter methodSignatureFormatter,
       Class<? extends Annotation> moduleClass,
       ImmutableList<Class<? extends Annotation>> includedModuleClasses,
-      Class<? extends Annotation> methodClass) {
+      Class<? extends Annotation>... methodClasses) {
     this.types = types;
     this.elements = elements;
     this.moduleClass = moduleClass;
     this.includedModuleClasses = includedModuleClasses;
-    this.methodClass = methodClass;
+    this.methodClasses = methodClasses;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
@@ -97,8 +97,11 @@
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, methodClass)) {
-        bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+      for (Class<? extends Annotation> methodClass : methodClasses) {
+        if (isAnnotationPresent(moduleMethod, methodClass)) {
+          bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+          break;
+        }
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
@@ -132,7 +135,7 @@ private void validateMethodsWithSameName(
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
-              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClasses[0].getSimpleName()),
               offendingMethod);
         }
       }
@@ -241,6 +244,7 @@ private void validateProvidesOverrides(
       currentClass = MoreElements.asType(types.asElement(currentClass.getSuperclass()));
       List<ExecutableElement> superclassMethods =
           ElementFilter.methodsIn(currentClass.getEnclosedElements());
+      String methodClassName = methodClasses[0].getSimpleName();
       for (ExecutableElement superclassMethod : superclassMethods) {
         String name = superclassMethod.getSimpleName().toString();
         // For each method in the superclass, confirm our @Provides methods don't override it
@@ -251,26 +255,28 @@ private void validateProvidesOverrides(
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                    methodClass.getSimpleName(),
+                        methodClassName,
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, methodClass)) {
-          for (ExecutableElement method : allMethodsByName.get(name)) {
-            if (!failedMethods.contains(method)
-                && elements.overrides(method, superclassMethod, subject)) {
-              failedMethods.add(method);
-              builder.addError(
-                  String.format(
-                      METHOD_OVERRIDES_PROVIDES_METHOD,
-                      methodClass.getSimpleName(),
-                      methodSignatureFormatter.format(superclassMethod)),
-                  method);
+        for (Class<? extends Annotation> methodClass : methodClasses) {
+          if (isAnnotationPresent(superclassMethod, methodClass)) {
+            for (ExecutableElement method : allMethodsByName.get(name)) {
+              if (!failedMethods.contains(method)
+                  && elements.overrides(method, superclassMethod, subject)) {
+                failedMethods.add(method);
+                builder.addError(
+                    String.format(
+                        METHOD_OVERRIDES_PROVIDES_METHOD,
+                            methodClassName,
+                        methodSignatureFormatter.format(superclassMethod)),
+                    method);
+              }
             }
           }
-        }
+          }
         allMethodsByName.put(superclassMethod.getSimpleName().toString(), superclassMethod);
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index e9c8b1629..c3e7e5205 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -75,7 +75,15 @@ private TypeElement getSetElement() {
         ValidationReport.about(providesMethodElement);
 
     Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
-    checkArgument(providesAnnotation != null);
+    Provides.Type type;
+    javax.enterprise.inject.Produces producesAnnotation = null;
+    if (providesAnnotation == null) {
+      producesAnnotation = providesMethodElement.getAnnotation(javax.enterprise.inject.Produces.class);
+      type = Provides.Type.UNIQUE;
+    } else {
+      type = providesAnnotation.type();
+    }
+    checkArgument(providesAnnotation != null || producesAnnotation != null);
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
@@ -103,7 +111,7 @@ private TypeElement getSetElement() {
     }
 
     // check mapkey is right
-    if (!providesAnnotation.type().equals(Provides.Type.MAP)
+    if (!type.equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
       builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
@@ -111,7 +119,7 @@ private TypeElement getSetElement() {
 
     validateMethodQualifiers(builder, providesMethodElement);
 
-    switch (providesAnnotation.type()) {
+    switch (type) {
       case UNIQUE: // fall through
       case SET:
         validateKeyType(builder, returnType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b2ac74fb3..03e50ddb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -160,7 +160,15 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
       checkArgument(providesMethod.getKind().equals(METHOD));
       checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
+      Provides.Type provisionType;
+      javax.enterprise.inject.Produces producesAnnotation = null;
+      if (providesAnnotation == null) {
+        producesAnnotation = providesMethod.getAnnotation(javax.enterprise.inject.Produces.class);
+        provisionType = Provides.Type.UNIQUE;
+      } else {
+        provisionType = providesAnnotation.type();
+      }
+      checkArgument(providesAnnotation != null || producesAnnotation != null);
       DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
@@ -181,7 +189,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
-          providesAnnotation.type(),
+          provisionType,
           scope);
     }
 
diff --git a/examples/pom.xml b/examples/pom.xml
index eb4685aa0..89392d68a 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -31,6 +31,7 @@
 
   <modules>
     <module>simple</module>
+    <module>simple-cdi</module>
     <module>android-simple</module>
     <module>android-activity-graphs</module>
   </modules>
diff --git a/examples/simple-cdi/ReadMe.md b/examples/simple-cdi/ReadMe.md
new file mode 100644
index 000000000..85c03221d
--- /dev/null
+++ b/examples/simple-cdi/ReadMe.md
@@ -0,0 +1,12 @@
+## Simple CDI Demo
+
+This demo shows how to use Dagger 2 using @Inject and CDI's `@Produces` annotation.
+
+### Running the demo
+
+Type the following to try it out
+
+    mvn install exec:java
+    
+You should then see the awesome CoffeeApp make some coffee!
+    
\ No newline at end of file
diff --git a/examples/simple-cdi/pom.xml b/examples/simple-cdi/pom.xml
new file mode 100644
index 000000000..d0d7fdb14
--- /dev/null
+++ b/examples/simple-cdi/pom.xml
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.google.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>simple-cdi</artifactId>
+  <name>Examples: Simple CDI</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>javax.enterprise</groupId>
+      <artifactId>cdi-api</artifactId>
+      <version>1.2</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <version>1.4.0</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>java</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <mainClass>coffee.CoffeeApp</mainClass>
+          <classpathScope>compile</classpathScope>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/examples/simple-cdi/src/main/java/coffee/CoffeeApp.java b/examples/simple-cdi/src/main/java/coffee/CoffeeApp.java
new file mode 100644
index 000000000..b0a93ec3c
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/CoffeeApp.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+public class CoffeeApp {
+  @Singleton
+  @Component(modules = { DripCoffeeModule.class })
+  public interface Coffee {
+    CoffeeMaker maker();
+  }
+
+  public static void main(String[] args) {
+    Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();
+    coffee.maker().brew();
+  }
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/CoffeeMaker.java b/examples/simple-cdi/src/main/java/coffee/CoffeeMaker.java
new file mode 100644
index 000000000..6410336d0
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/CoffeeMaker.java
@@ -0,0 +1,21 @@
+package coffee;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+
+class CoffeeMaker {
+  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
+  private final Pump pump;
+
+  @Inject CoffeeMaker(Lazy<Heater> heater, Pump pump) {
+    this.heater = heater;
+    this.pump = pump;
+  }
+
+  public void brew() {
+    heater.get().on();
+    pump.pump();
+    System.out.println(" [_]P coffee! [_]P ");
+    heater.get().off();
+  }
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/DripCoffeeModule.java b/examples/simple-cdi/src/main/java/coffee/DripCoffeeModule.java
new file mode 100644
index 000000000..b3b724b87
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/DripCoffeeModule.java
@@ -0,0 +1,15 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+import javax.enterprise.inject.Produces;
+import javax.inject.Singleton;
+
+@Module(includes = PumpModule.class)
+class DripCoffeeModule {
+  @Produces
+  @Singleton Heater provideHeater() {
+    return new ElectricHeater();
+  }
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/ElectricHeater.java b/examples/simple-cdi/src/main/java/coffee/ElectricHeater.java
new file mode 100644
index 000000000..fbab399f2
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/ElectricHeater.java
@@ -0,0 +1,18 @@
+package coffee;
+
+class ElectricHeater implements Heater {
+  boolean heating;
+
+  @Override public void on() {
+    System.out.println("~ ~ ~ heating ~ ~ ~");
+    this.heating = true;
+  }
+
+  @Override public void off() {
+    this.heating = false;
+  }
+
+  @Override public boolean isHot() {
+    return heating;
+  }
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/Heater.java b/examples/simple-cdi/src/main/java/coffee/Heater.java
new file mode 100644
index 000000000..b5ddb6b88
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/Heater.java
@@ -0,0 +1,7 @@
+package coffee;
+
+interface Heater {
+  void on();
+  void off();
+  boolean isHot();
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/Pump.java b/examples/simple-cdi/src/main/java/coffee/Pump.java
new file mode 100644
index 000000000..e39434913
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/Pump.java
@@ -0,0 +1,5 @@
+package coffee;
+
+interface Pump {
+  void pump();
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/PumpModule.java b/examples/simple-cdi/src/main/java/coffee/PumpModule.java
new file mode 100644
index 000000000..c12da05da
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/PumpModule.java
@@ -0,0 +1,14 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+import javax.enterprise.inject.Produces;
+
+@Module
+class PumpModule {
+  @Produces
+  Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
diff --git a/examples/simple-cdi/src/main/java/coffee/Thermosiphon.java b/examples/simple-cdi/src/main/java/coffee/Thermosiphon.java
new file mode 100644
index 000000000..c9f9828b0
--- /dev/null
+++ b/examples/simple-cdi/src/main/java/coffee/Thermosiphon.java
@@ -0,0 +1,18 @@
+package coffee;
+
+import javax.inject.Inject;
+
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  @Override public void pump() {
+    if (heater.isHot()) {
+      System.out.println("=> => pumping => =>");
+    }
+  }
+}
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 0be10b86d..f7aad7cdf 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -27,6 +27,11 @@
   <name>Examples: Simple</name>
 
   <dependencies>
+    <dependency>
+      <groupId>javax.enterprise</groupId>
+      <artifactId>cdi-api</artifactId>
+      <version>1.2</version>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index e50d249e1..b3b724b87 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -2,11 +2,14 @@
 
 import dagger.Module;
 import dagger.Provides;
+
+import javax.enterprise.inject.Produces;
 import javax.inject.Singleton;
 
 @Module(includes = PumpModule.class)
 class DripCoffeeModule {
-  @Provides @Singleton Heater provideHeater() {
+  @Produces
+  @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index 338ad33c2..c12da05da 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -3,9 +3,12 @@
 import dagger.Module;
 import dagger.Provides;
 
+import javax.enterprise.inject.Produces;
+
 @Module
 class PumpModule {
-  @Provides Pump providePump(Thermosiphon pump) {
+  @Produces
+  Pump providePump(Thermosiphon pump) {
     return pump;
   }
 }
