diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index d9cd68f1b..67dbe1304 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -390,19 +390,19 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
 
             if (!explicitProducerMapBindings.isEmpty()
                 || !explicitProducerMultibindingDeclarations.isEmpty()) {
-              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
-               * bindings or multibinding declarations, then add the synthetic binding that depends
-               * on Map<K, Producer<V>>. */
+              /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
+               * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
+               * binding that depends on Map<K, Producer<V>>. */
               contributionBindings.add(
-                  productionBindingFactory.implicitMapOfProducerBinding(request));
+                  productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
             } else if (!explicitProviderMapBindings.isEmpty()
                 || !explicitProviderMultibindingDeclarations.isEmpty()) {
-              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
+              /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
                * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
                * or multibinding declarations, then add the synthetic binding that depends on
                * Map<K, Provider<V>>. */
               contributionBindings.add(
-                  provisionBindingFactory.implicitMapOfProviderBinding(request));
+                  provisionBindingFactory.syntheticMapOfValuesBinding(request));
             }
 
             Iterable<? extends HasBindingType> multibindingsAndDeclarations =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index c21aec6db..9aa840e50 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -132,20 +132,27 @@ ProductionBinding forProducesMethod(
           Optional.of(monitorRequest));
     }
 
-    ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
-      checkNotNull(mapOfValueRequest);
-      Optional<Key> implicitMapOfProducerKey =
-          keyFactory.implicitMapProducerKeyFrom(mapOfValueRequest.key());
+    /**
+     * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
+     * {@code Map<K, Producer<V>>}.
+     */
+    ProductionBinding syntheticMapOfValuesOrProducedBinding(
+        DependencyRequest requestForMapOfValuesOrProduced) {
+      checkNotNull(requestForMapOfValuesOrProduced);
+      Optional<Key> mapOfProducersKey =
+          keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
       checkArgument(
-          implicitMapOfProducerKey.isPresent(), "%s is not for a Map<K, V>", mapOfValueRequest);
-      DependencyRequest implicitMapOfProducerRequest =
+          mapOfProducersKey.isPresent(),
+          "%s is not for a Map<K, V>",
+          requestForMapOfValuesOrProduced);
+      DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(
-              mapOfValueRequest, implicitMapOfProducerKey.get());
+              requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return new AutoValue_ProductionBinding(
-          SourceElement.forElement(implicitMapOfProducerRequest.requestElement()),
-          mapOfValueRequest.key(),
-          ImmutableSet.of(implicitMapOfProducerRequest),
-          findBindingPackage(mapOfValueRequest.key()),
+          SourceElement.forElement(requestForMapOfProducers.requestElement()),
+          requestForMapOfValuesOrProduced.key(),
+          ImmutableSet.of(requestForMapOfProducers),
+          findBindingPackage(requestForMapOfValuesOrProduced.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
@@ -156,8 +163,10 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
     }
 
     /**
-     * A binding that depends explicitly on a set of individual provision or production multibinding
-     * contribution methods.
+     * A synthetic binding that depends explicitly on a set of individual provision or production
+     * multibinding contribution methods.
+     * 
+     * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index aa08f5c2e..2fb6c2bfe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -179,33 +179,38 @@ ProvisionBinding forProvidesMethod(
           scope);
     }
     
-    ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
-      checkNotNull(mapOfValueRequest);
-      Optional<Key> implicitMapOfProviderKey =
-          keyFactory.implicitMapProviderKeyFrom(mapOfValueRequest.key());
+    /**
+     * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
+     */
+    ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfValues) {
+      checkNotNull(requestForMapOfValues);
+      Optional<Key> mapOfProvidersKey =
+          keyFactory.implicitMapProviderKeyFrom(requestForMapOfValues.key());
       checkArgument(
-          implicitMapOfProviderKey.isPresent(),
+          mapOfProvidersKey.isPresent(),
           "%s is not a request for Map<K, V>",
-          mapOfValueRequest);
-      DependencyRequest implicitMapOfProviderRequest =
+          requestForMapOfValues);
+      DependencyRequest requestForMapOfProviders =
           dependencyRequestFactory.forImplicitMapBinding(
-              mapOfValueRequest, implicitMapOfProviderKey.get());
+              requestForMapOfValues, mapOfProvidersKey.get());
       return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(implicitMapOfProviderRequest.requestElement()),
-          mapOfValueRequest.key(),
-          ImmutableSet.of(implicitMapOfProviderRequest),
-          findBindingPackage(mapOfValueRequest.key()),
+          SourceElement.forElement(requestForMapOfProviders.requestElement()),
+          requestForMapOfValues.key(),
+          ImmutableSet.of(requestForMapOfProviders),
+          findBindingPackage(requestForMapOfValues.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(implicitMapOfProviderRequest.requestElement()));
+          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
     }
 
     /**
-     * A binding that depends explicitly on a set of individual provision multibinding contribution
-     * methods.
+     * A synthetic binding that depends explicitly on a set of individual provision multibinding
+     * contribution methods.
+     * 
+     * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
