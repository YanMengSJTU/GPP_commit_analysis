diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
new file mode 100644
index 000000000..4fb0f7832
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+abstract class AbstractMembersInjectingBaseClass {
+  @Inject Thing thing;
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
new file mode 100644
index 000000000..89e94bd2f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
new file mode 100644
index 000000000..cd9dbdbf1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -0,0 +1,53 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+@Component(modules = PrimitivesModule.class)
+interface BasicComponent {
+  byte getByte();
+  char getChar();
+  short getShort();
+  int getInt();
+  long getLong();
+  boolean getBoolean();
+  float getFloat();
+  double getDouble();
+
+  Byte getBoxedByte();
+  Character getBoxedChar();
+  Short getBoxedShort();
+  Integer getBoxedInt();
+  Long getBoxedLong();
+  Boolean getBoxedBoolean();
+  Float getBoxedFloat();
+  Double getBoxedDouble();
+
+  byte[] getByteArray();
+  char[] getCharArray();
+  short[] getShortArray();
+  int[] getIntArray();
+  long[] getLongArray();
+  boolean[] getBooleanArray();
+  float[] getFloatArray();
+  double[] getDoubleArray();
+
+  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
+
+  Thing thing();
+  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 3b76fc642..731df3f57 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,9 +16,16 @@
 package test;
 
 import dagger.Component;
+import java.util.Collection;
 import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
 
 @Component(modules = MultibindingModule.class)
 interface MultibindingComponent {
   Map<String, String> map();
+  Map<String, Provider<String>> mapOfProviders();
+  Set<String> mapKeys();
+  Collection<String> mapValues();
+  Set<Integer> set();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 0e83ed519..2b9b441ac 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -17,8 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
 
 @Module
 class MultibindingModule {
@@ -29,4 +34,20 @@
   @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
     return "bar value";
   }
+
+  @Provides(type = SET) int provideFiveToSet() {
+    return 5;
+  }
+
+  @Provides(type = SET) int provideSixToSet() {
+    return 6;
+  }
+
+  @Provides Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+    return map.keySet();
+  }
+
+  @Provides Collection<String> provideMapValues(Map<String, String> map) {
+    return map.values();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
new file mode 100644
index 000000000..907287dd3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
@@ -0,0 +1,93 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class PrimitivesModule {
+  static final byte BOUND_BYTE = -41;
+  static final char BOUND_CHAR = 'g';
+  static final short BOUND_SHORT = 21840;
+  static final int BOUND_INT = 1894833693;
+  static final long BOUND_LONG = -4369839828653523584L;
+  static final boolean BOUND_BOOLEAN = true;
+  static final float BOUND_FLOAT = (float) 0.9964542;
+  static final double BOUND_DOUBLE = 0.12681322049667765;
+
+  /*
+   * While we can't ensure that these constants stay constant, this is a test so we're just going to
+   * keep our fingers crossed that we're not going to be jerks.
+   */
+  static final byte[] BOUND_BYTE_ARRAY =  {1, 2, 3};
+  static final char[] BOUND_CHAR_ARRAY = {'g', 'a', 'k'};
+  static final short[] BOUND_SHORT_ARRAY = {2, 4};
+  static final int[] BOUND_INT_ARRAY = {3, 1, 2};
+  static final long[] BOUND_LONG_ARRAY = {1, 1, 2, 3, 5};
+  static final boolean[] BOUND_BOOLEAN_ARRAY = {false, true, false, false};
+  static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
+  static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
+
+  @Provides byte provideByte() {
+    return BOUND_BYTE;
+  }
+
+  @Provides char provideChar() {
+    return BOUND_CHAR;
+  }
+
+  @Provides short provideShort() {
+    return BOUND_SHORT;
+  }
+
+  @Provides int provideInt() {
+    return BOUND_INT;
+  }
+
+  @Provides long provideLong() {
+    return BOUND_LONG;
+  }
+
+  @Provides boolean provideBoolean() {
+    return BOUND_BOOLEAN;
+  }
+
+  @Provides float provideFloat() {
+    return BOUND_FLOAT;
+  }
+
+  @Provides double boundDouble() {
+    return BOUND_DOUBLE;
+  }
+
+  @Provides byte[] provideByteArray() {
+    return BOUND_BYTE_ARRAY;
+  }
+
+  @Provides char[] provideCharArray() {
+    return BOUND_CHAR_ARRAY;
+  }
+
+  @Provides short[] provideShortArray() {
+    return BOUND_SHORT_ARRAY;
+  }
+
+  @Provides int[] provideIntArray() {
+    return BOUND_INT_ARRAY;
+  }
+
+  @Provides long[] provideLongArray() {
+    return BOUND_LONG_ARRAY;
+  }
+
+  @Provides boolean[] provideBooleanArray() {
+    return BOUND_BOOLEAN_ARRAY;
+  }
+
+  @Provides float[] provideFloatArray() {
+    return BOUND_FLOAT_ARRAY;
+  }
+
+  @Provides double[] boundDoubleArray() {
+    return BOUND_DOUBLE_ARRAY;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
deleted file mode 100644
index bf33761ac..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2014 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.Component;
-
-@Component
-interface ThingComponent {
-  Thing thing();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
new file mode 100644
index 000000000..587baade1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {
+  @Inject TypeWithInheritedMembersInjection() {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index e5247c4a1..96e4bcb1f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -17,9 +17,12 @@
 
 import dagger.Subcomponent;
 import java.util.Set;
+import javax.inject.Provider;
 
 @Subcomponent(modules = ChildModule.class)
 interface ChildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
   RequiresSingleton requiresSingleton();
 
   Set<Object> objectSet();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
index d1332a27c..388d66960 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -17,9 +17,13 @@
 
 import dagger.Subcomponent;
 import java.util.Set;
+import javax.inject.Provider;
 
 @Subcomponent(modules = GrandchildModule.class)
 interface GrandchildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
   RequiresSingleton requiresSingleton();
+
   Set<Object> objectSet();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index 6bf9bd15a..ec9a79941 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -17,11 +17,14 @@
 
 import dagger.Component;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 
 @Component(modules = ParentModule.class)
 @Singleton
 interface ParentComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
   SingletonType getSingletonType();
 
   Set<Object> objectSet();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
new file mode 100644
index 000000000..89c00855f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+final class UnscopedType {
+  @Inject UnscopedType(@SuppressWarnings("unused") SingletonType singletonType) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
new file mode 100644
index 000000000..b95502cf8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = test.subcomponent.hiding.b.CommonModuleName.class)
+interface ChildComponent {
+  //ensure that t.s.h.a.CommonName gets bound in this component
+  test.subcomponent.hiding.a.CommonName aCommonName();
+  //ensure that t.s.h.b.CommonName gets bound in this component
+  test.subcomponent.hiding.b.CommonName bCommonName();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
new file mode 100644
index 000000000..d7c66a679
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = test.subcomponent.hiding.a.CommonModuleName.class)
+@Singleton
+interface ParentComponent {
+  // ensure that t.s.h.a.CommonName gets bound in this component
+  test.subcomponent.hiding.a.CommonName aCommonName();
+
+  ChildComponent newChildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
new file mode 100644
index 000000000..ad692896f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.a;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides String provideString() {
+    return "a";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
new file mode 100644
index 000000000..b2aefda06
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.a;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final String s;
+
+  @Inject CommonName(String s) {
+    this.s = s;
+  }
+
+  @Override
+  public String toString() {
+    return s;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
new file mode 100644
index 000000000..66deab5aa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.b;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides int provideString() {
+    return 1;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
new file mode 100644
index 000000000..023cbdbf2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.b;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final int i;
+
+  @Inject CommonName(int i) {
+    this.i = i;
+  }
+
+  @Override
+  public String toString() {
+    return Integer.toString(i);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
new file mode 100644
index 000000000..45dd924ae
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -0,0 +1,93 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.PrimitivesModule.BOUND_BOOLEAN;
+import static test.PrimitivesModule.BOUND_BOOLEAN_ARRAY;
+import static test.PrimitivesModule.BOUND_BYTE;
+import static test.PrimitivesModule.BOUND_BYTE_ARRAY;
+import static test.PrimitivesModule.BOUND_CHAR;
+import static test.PrimitivesModule.BOUND_CHAR_ARRAY;
+import static test.PrimitivesModule.BOUND_DOUBLE;
+import static test.PrimitivesModule.BOUND_DOUBLE_ARRAY;
+import static test.PrimitivesModule.BOUND_FLOAT;
+import static test.PrimitivesModule.BOUND_FLOAT_ARRAY;
+import static test.PrimitivesModule.BOUND_INT;
+import static test.PrimitivesModule.BOUND_INT_ARRAY;
+import static test.PrimitivesModule.BOUND_LONG;
+import static test.PrimitivesModule.BOUND_LONG_ARRAY;
+import static test.PrimitivesModule.BOUND_SHORT;
+import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
+
+@RunWith(JUnit4.class)
+public class BasicTest {
+  @Test public void primitives() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
+    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
+    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
+    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
+    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
+    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
+    assertThat(basicComponent.getFloat()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
+  }
+
+  @Test public void boxedPrimitives() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getBoxedFloat()).isEqualTo(new Float(BOUND_FLOAT));
+    assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
+  }
+
+  @Test public void primitiveArrays() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Test public void noOpMembersInjection() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    Object object = new Object();
+    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
+  }
+
+  @Test public void basicObject_noDeps() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.thing()).isNotNull();
+  }
+
+  @Test public void inheritedMembersInjection() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index dfcf34189..23fb61bb7 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -16,6 +16,7 @@
 package test;
 
 import java.util.Map;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,5 +31,12 @@
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
+    Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
+    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
+    assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+    assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
+    assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
+    assertThat(multibindingComponent.set()).containsExactly(5, 6);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
index 3d6079b22..3f75547ce 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
@@ -26,7 +26,7 @@
 @RunWith(JUnit4.class)
 public class SubcomponentScopeTest {
   @Test
-  public void testSingletonPropagatesUpward() {
+  public void singletonPropagatesUpward() {
     ParentComponent parentComponent = Dagger_ParentComponent.create();
     SingletonType singletonType = parentComponent.getSingletonType();
     assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
@@ -38,7 +38,7 @@ public void testSingletonPropagatesUpward() {
   }
 
   @Test
-  public void testMultibindingContributions() {
+  public void multibindingContributions() {
     ParentComponent parentComponent = Dagger_ParentComponent.create();
     Set<Object> parentObjectSet = parentComponent.objectSet();
     assertThat(parentObjectSet).hasSize(2);
@@ -51,4 +51,15 @@ public void testMultibindingContributions() {
     assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
     assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
   }
+
+  @Test
+  public void unscopedProviders() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    assertThat(parentComponent.getUnscopedTypeProvider())
+        .isSameAs(parentComponent.newChildComponent().getUnscopedTypeProvider());
+    assertThat(parentComponent.getUnscopedTypeProvider())
+        .isSameAs(parentComponent.newChildComponent()
+            .newGrandchildComponent()
+            .getUnscopedTypeProvider());
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
new file mode 100644
index 000000000..76e916d3e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SubcomponentHidingTest {
+  @Test public void moduleNameHiding() {
+    ParentComponent parent = Dagger_ParentComponent.create();
+    assertThat(parent.aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo("1");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
new file mode 100644
index 000000000..561ad4a89
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = MultibindingProducerModule.class)
+interface MultibindingComponent {
+  ListenableFuture<Set<String>> strs();
+  ListenableFuture<Integer> strCount();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
new file mode 100644
index 000000000..3531201c1
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
@@ -0,0 +1,49 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+@ProducerModule
+final class MultibindingProducerModule {
+  @Produces(type = SET) ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("foo");
+  }
+
+  @Produces(type = SET) String str() {
+    return "bar";
+  }
+
+  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
+    return Futures.immediateFuture((Set<String>) ImmutableSet.of("foo1", "foo2"));
+  }
+
+  @Produces(type = SET_VALUES) Set<String> strs() {
+    return ImmutableSet.of("bar1", "bar2");
+  }
+
+  @Produces int strCount(Set<String> strs) {
+    return strs.size();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
similarity index 58%
rename from compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
index 82094e610..d20de2384 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2014 Google, Inc.
+* Copyright (C) 2015 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
 */
 package test;
 
+import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -22,10 +23,13 @@
 import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
-public class SimpleTest {
-  @Test public void testAThing() {
-    ThingComponent thingComponent = Dagger_ThingComponent.create();
-    assertThat(thingComponent).isNotNull();
-    assertThat(thingComponent.thing()).isNotNull();
+public class MultibindingTest {
+  @Test public void multibinding() throws Exception {
+    MultibindingComponent multibindingComponent = Dagger_MultibindingComponent.builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 362a21dfc..94f72ec1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -45,12 +45,14 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -190,8 +192,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       ImmutableSet<DependencyRequest> componentMethodRequests =
           componentMethodRequests(componentMethods);
-      for (DependencyRequest componentMethodRequest :
-          componentMethodRequests) {
+      for (DependencyRequest componentMethodRequest : componentMethodRequests) {
         requestResolver.resolve(componentMethodRequest);
       }
 
@@ -336,14 +337,27 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            MembersInjectionBinding membersInjectionBinding =
-                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
-            return Optional.of(ImmutableSet.of(membersInjectionBinding));
+            return Optional.of(ImmutableSet.of(rollUpMembersInjectionBindings(bindingKey.key())));
           default:
             throw new AssertionError();
         }
       }
 
+      private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
+        MembersInjectionBinding membersInjectionBinding =
+            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+
+        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
+          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
+              membersInjectionBinding.parentInjectorRequest().get().key());
+          if (parentBinding.injectionStrategy().equals(NO_OP)) {
+            return membersInjectionBinding.withoutParentInjectorRequest();
+          }
+        }
+
+        return membersInjectionBinding;
+      }
+
       private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
         Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
             provisionBinding.wrappedScope();
@@ -383,11 +397,28 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
         return explicitBindingsForKey.build();
       }
 
+      private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
+          final BindingKey bindingKey) {
+        Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
+        if (result.isPresent()) {
+          return result;
+        } else if (parentResolver.isPresent()) {
+          return parentResolver.get().getPreviouslyResolvedBindings(bindingKey);
+        } else {
+          return Optional.absent();
+        }
+      }
+
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
-        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(bindingKey);
-        if (previouslyResolvedBinding != null) {
+        Optional<ResolvedBindings> previouslyResolvedBinding =
+            getPreviouslyResolvedBindings(bindingKey);
+        if (previouslyResolvedBinding.isPresent()
+            && !(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+                && !previouslyResolvedBinding.get().contributionBindings().isEmpty()
+                && ContributionBinding.bindingTypeFor(
+                    previouslyResolvedBinding.get().contributionBindings()).isMultibinding())) {
           return;
         }
 
@@ -402,7 +433,9 @@ void resolve(DependencyRequest request) {
           Optional<? extends ImmutableSet<? extends Binding>> bindings = lookUpBindings(request);
           if (bindings.isPresent()) {
             for (Binding binding : bindings.get()) {
-              resolveDependencies(binding.implicitDependencies());
+              for (DependencyRequest dependency : binding.implicitDependencies()) {
+                resolve(dependency);
+              }
             }
             resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings.get()));
           }
@@ -410,12 +443,6 @@ void resolve(DependencyRequest request) {
           cycleStack.pop();
         }
       }
-
-      private void resolveDependencies(Iterable<DependencyRequest> dependencies) {
-        for (DependencyRequest dependency : dependencies) {
-          resolve(dependency);
-        }
-      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index d1d1633e7..187b71e7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -61,6 +61,7 @@
 import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
@@ -90,15 +91,10 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.ProductionBinding.Kind.COMPONENT_PRODUCTION;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -155,6 +151,52 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     }
   }
 
+  @AutoValue static abstract class MemberSelect {
+    static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, false, snippet);
+    }
+
+    static MemberSelect staticSelect(ClassName owningClass, Snippet snippet) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, true, snippet);
+    }
+
+    static MemberSelect staticMethodInvocationWithCast(
+        ClassName owningClass, Snippet snippet, TypeName castType) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.of(castType), owningClass, true, snippet);
+    }
+
+    /**
+     * This exists only to facilitate edge cases in which we need to select a member, but that
+     * member uses a type parameter that can't be inferred.
+     */
+    abstract Optional<TypeName> selectedCast();
+    abstract ClassName owningClass();
+    abstract boolean staticMember();
+    abstract Snippet snippet();
+
+    private Snippet qualifiedSelectSnippet() {
+      return Snippet.format(
+          "%s" + (staticMember() ? "" : ".this") + ".%s",
+          owningClass(), snippet());
+    }
+
+    Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
+      Snippet snippet = getSnippetFor(usingClass);
+      return selectedCast().isPresent()
+          ? Snippet.format("(%s) %s", selectedCast().get(), snippet)
+          : snippet;
+    }
+
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? snippet()
+          : qualifiedSelectSnippet();
+    }
+  }
+
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     ClassName componentDefinitionTypeName =
@@ -174,7 +216,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     return ImmutableSet.copyOf(javaWriters);
   }
 
-  private ImmutableMap<BindingKey, Snippet> writeComponent(
+  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
       BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters) {
     ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
@@ -211,7 +253,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
 
     boolean requiresBuilder = false;
 
-    Map<TypeElement, FieldWriter> componentContributionFields = Maps.newHashMap();
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
     for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
       TypeElement contributionElement = entry.getKey();
@@ -219,7 +261,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       FieldWriter contributionField =
           componentWriter.addField(contributionElement, contributionName);
       contributionField.addModifiers(PRIVATE, FINAL);
-      componentContributionFields.put(contributionElement, contributionField);
+      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
+          componentWriter.name(), Snippet.format(contributionField.name())));
       FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
       builderField.addModifiers(PRIVATE);
       constructorWriter.body()
@@ -257,7 +300,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
     ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
 
@@ -274,7 +317,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
 
     buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
 
-    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
         ImmutableMap.copyOf(memberSelectSnippetsBuilder);
     ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
@@ -303,8 +346,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
   private void writeSubcomponents(BindingGraph input,
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
-      Map<TypeElement, FieldWriter> componentContributionFields,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets) {
     for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
       TypeName componentType =
@@ -321,8 +364,8 @@ private void writeSubcomponents(BindingGraph input,
           subcomponentWriter,
           proxyWriters,
           ImmutableMap.copyOf(componentContributionFields),
-          ImmutableMap.copyOf(multibindingContributionSnippets),
-          memberSelectSnippets);
+          multibindingContributionSnippets,
+          parentMemberSelectSnippets);
 
       MethodWriter componentMethod = componentWriter.addMethod(componentType,
           subgraphEntry.getKey().getSimpleName().toString());
@@ -334,12 +377,12 @@ private void writeSubcomponents(BindingGraph input,
     }
   }
 
-  private ImmutableMap<BindingKey, Snippet> writeSubcomponent(
+  private ImmutableMap<BindingKey, MemberSelect> writeSubcomponent(
       BindingGraph input, ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
-      ImmutableMap<TypeElement, FieldWriter> parentContributionFields,
+      ImmutableMap<TypeElement, MemberSelect> parentContributionFields,
       ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ImmutableMap<BindingKey, Snippet> parentMemberSelectSnippets) {
+      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets) {
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
@@ -355,7 +398,7 @@ private void writeSubcomponents(BindingGraph input,
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
 
-    Map<TypeElement, FieldWriter> componentContributionFields =
+    Map<TypeElement, MemberSelect> componentContributionFields =
         Maps.newHashMap(parentContributionFields);
 
     for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
@@ -368,10 +411,11 @@ private void writeSubcomponents(BindingGraph input,
             ClassName.fromTypeElement(entry.getKey())));
       }
       contributionField.addModifiers(PRIVATE, FINAL);
-      componentContributionFields.put(contributionElement, contributionField);
+      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
+          componentWriter.name(), Snippet.format(contributionField.name())));
     }
 
-    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
     ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
@@ -387,13 +431,14 @@ private void writeSubcomponents(BindingGraph input,
         enumBindingKeysBuilder,
         packageProxies);
 
-    for (Entry<BindingKey, Snippet> parentBindingEntry : parentMemberSelectSnippets.entrySet()) {
+    for (Entry<BindingKey, MemberSelect> parentBindingEntry :
+        parentMemberSelectSnippets.entrySet()) {
       if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
         memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
       }
     }
 
-    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
         ImmutableMap.copyOf(memberSelectSnippetsBuilder);
     ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
@@ -425,7 +470,7 @@ private void writeSubcomponents(BindingGraph input,
   private void writeFields(BindingGraph input,
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
-      Map<BindingKey, Snippet> memberSelectSnippetsBuilder,
+      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
       Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
       Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
       ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
@@ -433,18 +478,35 @@ private void writeFields(BindingGraph input,
     for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
       BindingKey bindingKey = resolvedBindings.bindingKey();
 
-      if (resolvedBindings.bindings().size() == 1
-          && bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ContributionBinding contributionBinding =
-            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-        if (contributionBinding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-              && !provisionBinding.scope().isPresent()) {
+      if (resolvedBindings.bindings().size() == 1) {
+        if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+          ContributionBinding contributionBinding =
+              Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+          if (contributionBinding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+            if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                && !provisionBinding.scope().isPresent()) {
+              enumBindingKeysBuilder.add(bindingKey);
+              // skip keys whose factories are enum instances and aren't scoped
+              memberSelectSnippetsBuilder.put(bindingKey,
+                  MemberSelect.staticSelect(
+                      factoryNameForProvisionBinding(provisionBinding),
+                      Snippet.format("create()")));
+              continue;
+            }
+          }
+        } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
+          MembersInjectionBinding membersInjectionBinding =
+              Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
+          if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
+            // TODO(gak): refactor to use enumBindingKeys throughout the generator
             enumBindingKeysBuilder.add(bindingKey);
-            // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(bindingKey, Snippet.format("%s.create()",
-                    factoryNameForProvisionBinding(provisionBinding)));
+            // TODO(gak): suppress the warnings in a reasonable place
+            memberSelectSnippetsBuilder.put(bindingKey,
+                MemberSelect.staticMethodInvocationWithCast(
+                    ClassName.fromClass(MembersInjectors.class),
+                    Snippet.format("noOp()"),
+                    ClassName.fromClass(MembersInjector.class)));
             continue;
           }
         }
@@ -497,25 +559,25 @@ private void writeFields(BindingGraph input,
             resolvedBindings.contributionBindings();
         if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
           // note that here we rely on the order of the resolved bindings being from parent to child
-          // otherwise, the nubmering wouldn't work
+          // otherwise, the numbering wouldn't work
           int contributionNumber = 0;
           for (ContributionBinding contributionBinding : contributionBindings) {
-            if (isSytheticProvisionBinding(contributionBinding)) {
+            if (!contributionBinding.isSyntheticBinding()) {
               contributionNumber++;
               if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
                 FrameworkField contributionBindingField =
-                    frameworkFieldForSyntheticProvisionBinding(
+                    frameworkFieldForSyntheticContributionBinding(
                           bindingKey, contributionNumber, contributionBinding);
                 FieldWriter contributionField = classWithFields.addField(
                     contributionBindingField.frameworkType(), contributionBindingField.name());
                 contributionField.addModifiers(fieldModifiers);
 
-                ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
+                ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
                     .addAll(proxySelector.asSet())
                     .add(contributionField.name())
                     .build();
                 multibindingContributionSnippetsBuilder.put(contributionBinding,
-                    Snippet.memberSelectSnippet(contirubtionSelectTokens));
+                    Snippet.memberSelectSnippet(contributionSelectTokens));
               }
             }
           }
@@ -531,12 +593,14 @@ private void writeFields(BindingGraph input,
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(bindingKey, Snippet.memberSelectSnippet(memberSelectTokens));
+      memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
+          componentWriter.name(),
+          Snippet.memberSelectSnippet(memberSelectTokens)));
     }
   }
 
   private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
       ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
@@ -555,13 +619,17 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
         BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
         switch(interfaceRequest.kind()) {
           case MEMBERS_INJECTOR:
-            Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
+            MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
             VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
             Name parameterName = parameter.getSimpleName();
             interfaceMethod.addParameter(
                 TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
             interfaceMethod.body()
-                .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+                .addSnippet("%s.injectMembers(%s);",
+                    // in this case we know we won't need the cast because we're never going to pass
+                    // the reference to anything
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()),
+                    parameterName);
             if (!requestElement.getReturnType().getKind().equals(VOID)) {
               interfaceMethod.body().addSnippet("return %s;", parameterName);
             }
@@ -576,7 +644,7 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
               TypeName factoryType = ParameterizedTypeName.create(Provider.class,
                   TypeNames.forTypeMirror(requestElement.getReturnType()));
               interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                  memberSelectSnippets.get(bindingKey));
+                  memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
               interfaceMethod.body().addSnippet("return factory.get();");
               break;
             }
@@ -587,7 +655,8 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
           case PROVIDER:
           case FUTURE:
             interfaceMethod.body().addSnippet("return %s;",
-                frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
+                frameworkTypeUsageStatement(
+                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
                     interfaceRequest.kind()));
             break;
           default:
@@ -600,8 +669,8 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
   private void initializeFrameworkTypes(BindingGraph input,
       ClassWriter componentWriter,
       ConstructorWriter constructorWriter,
-      Map<TypeElement, FieldWriter> componentContributionFields,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
       ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
       throws AssertionError {
@@ -615,7 +684,8 @@ private void initializeFrameworkTypes(BindingGraph input,
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
       for (BindingKey bindingKey : partitions.get(i)) {
-        Snippet memberSelectSnippet = memberSelectSnippets.get(bindingKey);
+        Snippet memberSelectSnippet =
+            memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             ImmutableSet<? extends ContributionBinding> bindings =
@@ -623,39 +693,33 @@ private void initializeFrameworkTypes(BindingGraph input,
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
-                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
-                    .isEmpty()) {
-                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
-                  ImmutableSet<ProvisionBinding> provisionBindings =
-                      (ImmutableSet<ProvisionBinding>) bindings;
-                  ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                  for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (multibindingContributionSnippets.containsKey(provisionBinding)) {
-                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          snippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields,
-                              memberSelectSnippets));
-                      parameterSnippets.add(snippet);
-                    } else if (parentMultibindingContributionSnippets
-                        .containsKey(provisionBinding)) {
-                      parameterSnippets.add(
-                          parentMultibindingContributionSnippets.get(provisionBinding));
-                    } else {
-                      throw new IllegalStateException();
-                    }
+                boolean hasOnlyProvisions =
+                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
+                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+                for (ContributionBinding binding : bindings) {
+                  if (multibindingContributionSnippets.containsKey(binding)) {
+                    Snippet initializeSnippet = initializeFactoryForContributionBinding(
+                        binding,
+                        input,
+                        componentWriter.name(),
+                        componentContributionFields,
+                        memberSelectSnippets);
+                    Snippet snippet = multibindingContributionSnippets.get(binding);
+                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+                    parameterSnippets.add(snippet);
+                  } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
+                    parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
+                  } else {
+                    throw new IllegalStateException();
                   }
-                  Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                      ClassName.fromClass(SetFactory.class),
-                      Snippet.makeParametersSnippet(parameterSnippets.build()));
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet, initializeSetSnippet);
-                } else {
-                  // TODO(user): Implement producer set bindings.
-                  throw new IllegalStateException("producer set bindings not implemented yet");
                 }
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    hasOnlyProvisions
+                        ? ClassName.fromClass(SetFactory.class)
+                        : ClassName.fromClass(SetProducer.class),
+                    Snippet.makeParametersSnippet(parameterSnippets.build()));
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
                 if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
@@ -668,6 +732,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                       initializeMethod.body().addSnippet("this.%s = %s;",
                         multibindingContributionSnippets.get(provisionBinding),
                           initializeFactoryForProvisionBinding(provisionBinding,
+                              componentWriter.name(),
                               input.componentDescriptor().dependencyMethodIndex(),
                               componentContributionFields,
                               memberSelectSnippets));
@@ -675,7 +740,8 @@ private void initializeFrameworkTypes(BindingGraph input,
                   }
                   if (!provisionBindings.isEmpty()) {
                     Snippet initializeMapSnippet = initializeMapBinding(
-                        memberSelectSnippets, multibindingContributionSnippets, provisionBindings);
+                        componentWriter.name(), memberSelectSnippets,
+                        multibindingContributionSnippets, provisionBindings);
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet, initializeMapSnippet);
                   }
@@ -693,6 +759,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet,
                         initializeFactoryForProvisionBinding(provisionBinding,
+                            componentWriter.name(),
                             input.componentDescriptor().dependencyMethodIndex(),
                             componentContributionFields, memberSelectSnippets));
                   }
@@ -702,10 +769,11 @@ private void initializeFrameworkTypes(BindingGraph input,
                       memberSelectSnippet,
                       initializeFactoryForProductionBinding(productionBinding,
                           input,
+                          componentWriter.name(),
                           input.componentDescriptor().dependencyMethodIndex(),
                           componentContributionFields, memberSelectSnippets));
                 } else {
-                  throw new IllegalStateException();
+                  throw new AssertionError();
                 }
                 break;
               default:
@@ -715,9 +783,12 @@ private void initializeFrameworkTypes(BindingGraph input,
           case MEMBERS_INJECTION:
             MembersInjectionBinding binding = Iterables.getOnlyElement(
                 input.resolvedBindings().get(bindingKey).membersInjectionBindings());
-            initializeMethod.body().addSnippet("this.%s = %s;",
-                memberSelectSnippet,
-                initializeMembersInjectorForBinding(binding, memberSelectSnippets));
+            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+              initializeMethod.body().addSnippet("this.%s = %s;",
+                  memberSelectSnippet,
+                  initializeMembersInjectorForBinding(
+                      componentWriter.name(), binding, memberSelectSnippets));
+            }
             break;
           default:
             throw new AssertionError();
@@ -726,41 +797,30 @@ private void initializeFrameworkTypes(BindingGraph input,
     }
   }
 
-  private static FrameworkField frameworkFieldForSyntheticProvisionBinding(BindingKey bindingKey,
+  private static FrameworkField frameworkFieldForSyntheticContributionBinding(BindingKey bindingKey,
       int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
-    FrameworkField contributionBindingField;
     switch (contributionBinding.bindingType()) {
       case MAP:
-        contributionBindingField = FrameworkField.createForMapBindingContribution(
-            Provider.class,
+        return FrameworkField.createForMapBindingContribution(
+            contributionBinding.frameworkClass(),
             BindingKey.create(bindingKey.kind(), contributionBinding.key()),
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       case SET:
-        contributionBindingField = FrameworkField.createWithTypeFromKey(
-            Provider.class,
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       case UNIQUE:
-        contributionBindingField = FrameworkField.createWithTypeFromKey(
-            Provider.class,
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
             bindingKey,
             KeyVariableNamer.INSTANCE.apply(bindingKey.key())
                 + "Contribution" + contributionNumber);
-        break;
       default:
         throw new AssertionError();
     }
-    return contributionBindingField;
-  }
-
-  private static boolean isSytheticProvisionBinding(ContributionBinding contributionBinding) {
-    return !(contributionBinding instanceof ProvisionBinding
-        && ((ProvisionBinding) contributionBinding)
-            .bindingKind().equals(SYNTHETIC_PROVISON));
   }
 
   private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
@@ -830,10 +890,36 @@ public String visitType(TypeElement e, Void p) {
     }
   }
 
+  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding,
+      BindingGraph input,
+      ClassName componentName,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    if (binding instanceof ProvisionBinding) {
+      return initializeFactoryForProvisionBinding(
+          (ProvisionBinding) binding,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else if (binding instanceof ProductionBinding) {
+      return initializeFactoryForProductionBinding(
+          (ProductionBinding) binding,
+          input,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else {
+      throw new AssertionError();
+    }
+}
+
   private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
+      ClassName componentName,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+      Map<TypeElement, MemberSelect> contributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     switch(binding.bindingKind()) {
       case COMPONENT:
         return Snippet.format("%s.<%s>create(this)",
@@ -853,7 +939,8 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
             "}"),
             ClassName.fromClass(Factory.class),
             TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
+                .getSnippetFor(componentName),
             binding.bindingElement().getSimpleName().toString(),
             nullableSnippet);
         } else {
@@ -877,7 +964,8 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
             "}"),
             ClassName.fromClass(Factory.class),
             TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
+                .getSnippetFor(componentName),
             binding.bindingElement().getSimpleName().toString(),
             failMsg);
         }
@@ -886,23 +974,20 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
         List<Snippet> parameters =
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
         if (binding.bindingKind().equals(PROVISION)) {
-          parameters.add(
-              Snippet.format(contributionFields.get(binding.contributedBy().get()).name()));
-        }
-        if (binding.memberInjectionRequest().isPresent()) {
-          parameters.add(memberSelectSnippets.get(
-              BindingKey.forDependencyRequest(binding.memberInjectionRequest().get())));
+          parameters.add(contributionFields.get(binding.contributedBy().get())
+              .getSnippetFor(componentName));
         }
-        parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
+        parameters.addAll(getDependencyParameters(componentName, binding.implicitDependencies(),
+            memberSelectSnippets));
 
+        Snippet factorySnippet = Snippet.format("%s.create(%s)",
+            factoryNameForProvisionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
         return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s.create(%s))",
+            ? Snippet.format("%s.create(%s)",
                 ClassName.fromClass(ScopedProvider.class),
-                factoryNameForProvisionBinding(binding),
-                Snippet.makeParametersSnippet(parameters))
-            : Snippet.format("%s.create(%s)",
-                factoryNameForProvisionBinding(binding),
-                Snippet.makeParametersSnippet(parameters));
+                factorySnippet)
+            : factorySnippet;
       default:
         throw new AssertionError();
     }
@@ -910,9 +995,10 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
 
   private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
       BindingGraph bindingGraph,
+      ClassName componentName,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+      Map<TypeElement, MemberSelect> contributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     switch (binding.bindingKind()) {
       case COMPONENT_PRODUCTION:
         return Snippet.format(Joiner.on('\n').join(
@@ -924,17 +1010,20 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
             ClassName.fromClass(Producer.class),
             TypeNames.forTypeMirror(binding.key().type()),
             ClassName.fromClass(ListenableFuture.class),
-            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement()))
+                .getSnippetFor(componentName),
             binding.bindingElement().getSimpleName().toString());
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         List<Snippet> parameters =
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
-        parameters.add(Snippet.format(contributionFields.get(
-            bindingGraph.componentDescriptor().executorDependency().get()).name()));
+        parameters.add(contributionFields.get(binding.bindingTypeElement())
+            .getSnippetFor(componentName));
+        parameters.add(contributionFields.get(
+            bindingGraph.componentDescriptor().executorDependency().get())
+                .getSnippetFor(componentName));
         parameters.addAll(getProducerDependencyParameters(
-            bindingGraph, binding.dependencies(), memberSelectSnippets));
+            bindingGraph, componentName, binding.dependencies(), memberSelectSnippets));
 
         return Snippet.format("new %s(%s)",
             factoryNameForProductionBinding(binding),
@@ -945,31 +1034,36 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
   }
 
   private static Snippet initializeMembersInjectorForBinding(
+      ClassName componentName,
       MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
-    if (binding.injectionSites().isEmpty()) {
-      if (binding.parentInjectorRequest().isPresent()) {
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return Snippet.format("%s.noOp()",
+            ClassName.fromClass(MembersInjectors.class));
+      case DELEGATE:
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
-            memberSelectSnippets.get(BindingKey.forDependencyRequest(parentInjectorRequest)));
-      } else {
-        return Snippet.format("%s.noOp()",
-            ClassName.fromClass(MembersInjectors.class));
-      }
-    } else {
-      List<Snippet> parameters = getDependencyParameters(
-          Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
-          memberSelectSnippets);
-      return Snippet.format("%s.create(%s)",
-          membersInjectorNameForMembersInjectionBinding(binding),
-          Snippet.makeParametersSnippet(parameters));
+            memberSelectSnippets.get(BindingKey.forDependencyRequest(parentInjectorRequest))
+                .getSnippetFor(componentName));
+      case INJECT_MEMBERS:
+        List<Snippet> parameters = getDependencyParameters(
+            componentName,
+            binding.implicitDependencies(),
+            memberSelectSnippets);
+        return Snippet.format("%s.create(%s)",
+            membersInjectorNameForMembersInjectionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
     }
   }
 
   private static List<Snippet> getDependencyParameters(
+      ClassName componentName,
       Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
          SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
@@ -980,15 +1074,16 @@ private static Snippet initializeMembersInjectorForBinding(
             }
           })
           .toSet());
-      parameters.add(memberSelectSnippets.get(key));
+      parameters.add(memberSelectSnippets.get(key).getSnippetWithRawTypeCastFor(componentName));
     }
     return parameters.build();
   }
 
   private static List<Snippet> getProducerDependencyParameters(
       BindingGraph bindingGraph,
+      ClassName componentName,
       Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
          SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
@@ -1006,16 +1101,17 @@ private static Snippet initializeMembersInjectorForBinding(
         parameters.add(Snippet.format(
             "%s.producerFromProvider(%s)",
             ClassName.fromClass(Producers.class),
-            memberSelectSnippets.get(key)));
+            memberSelectSnippets.get(key).getSnippetFor(componentName)));
       } else {
-        parameters.add(memberSelectSnippets.get(key));
+        parameters.add(memberSelectSnippets.get(key).getSnippetFor(componentName));
       }
     }
     return parameters.build();
   }
 
   private Snippet initializeMapBinding(
-      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ClassName componentName,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
       Set<ProvisionBinding> bindings) {
     Iterator<ProvisionBinding> iterator = bindings.iterator();
@@ -1025,7 +1121,7 @@ private Snippet initializeMapBinding(
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
           memberSelectSnippets.get(BindingKey.forDependencyRequest(
-              Iterables.getOnlyElement(firstBinding.dependencies()))));
+              Iterables.getOnlyElement(firstBinding.dependencies()))).getSnippetFor(componentName));
     } else {
       DeclaredType mapType = asDeclared(firstBinding.key().type());
       TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 2a7c617d9..0630dfc7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.Ordering;
 import java.util.EnumSet;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
@@ -49,7 +50,7 @@ boolean isMultibinding() {
   }
 
   abstract BindingType bindingType();
-  
+
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -61,6 +62,20 @@ boolean isMultibinding() {
    */
   abstract Optional<TypeElement> contributedBy();
 
+  /**
+   * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
+   * implicitly by the framework.
+   */
+  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
+  // this field the source of truth for synthetic bindings.
+  abstract boolean isSyntheticBinding();
+
+  /**
+   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
+   * ProvisionBinding.
+   */
+  abstract Class<?> frameworkClass();
+
   /**
    * Returns the set of {@link BindingType} enum values implied by a given
    * {@link ContributionBinding} collection.
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index bce63acc0..c2c5c0178 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,8 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -124,7 +124,7 @@ DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key
       checkNotNull(delegatingRequest);
       return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
           delegatingRequest.requestElement(),
-          MoreTypes.asDeclared(delegatingRequest.requestElement().getEnclosingElement().asType()),
+          getEnclosingType(delegatingRequest.requestElement()),
           false /* doesn't allow null */);
     }
 
@@ -132,8 +132,8 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier, MoreTypes.asDeclared(
-          variableElement.getEnclosingElement().getEnclosingElement().asType()));
+      return newDependencyRequest(variableElement, type, qualifier,
+          getEnclosingType(variableElement));
     }
 
     DependencyRequest forRequiredResolvedVariable(DeclaredType container,
@@ -152,7 +152,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod)
       TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(provisionMethod, type, qualifier,
-          MoreTypes.asDeclared(provisionMethod.getEnclosingElement().asType()));
+          getEnclosingType(provisionMethod));
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod) {
@@ -161,8 +161,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
           "Component production methods must be empty: %s", productionMethod);
       TypeMirror type = productionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
-      DeclaredType container =
-          MoreTypes.asDeclared(productionMethod.getEnclosingElement().asType());
+      DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
       // special-case it here.
       if (isTypeOf(ListenableFuture.class, type)) {
@@ -187,7 +186,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod,
-          MoreTypes.asDeclared(membersInjectionMethod.getEnclosingElement().asType()),
+          getEnclosingType(membersInjectionMethod),
           false /* doesn't allow null */);
     }
 
@@ -252,5 +251,12 @@ static KindAndType extractKindAndType(TypeMirror type) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       }
     }
+
+    static DeclaredType getEnclosingType(Element element) {
+      while (!MoreElements.isType(element)) {
+        element = element.getEnclosingElement();
+      }
+      return MoreTypes.asDeclared(element.asType());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2518beddc..c0af683f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -158,6 +158,9 @@
   static final String METHOD_OVERRIDES_PROVIDES_METHOD =
       "@%s methods may not be overridden in modules. Overrides: %s";
 
+  static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
+      "Cannot use more than one @Qualifier on a @Provides or @Produces method";
+
   /*mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 9868c661d..4f48d8d59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -60,6 +60,34 @@
 
   abstract Optional<DependencyRequest> parentInjectorRequest();
 
+  enum Strategy {
+    NO_OP,
+    DELEGATE,
+    INJECT_MEMBERS,
+  }
+
+  Strategy injectionStrategy() {
+    if (injectionSites().isEmpty()) {
+      return parentInjectorRequest().isPresent()
+          ? Strategy.DELEGATE
+          : Strategy.NO_OP;
+    } else {
+      return Strategy.INJECT_MEMBERS;
+    }
+  }
+
+  MembersInjectionBinding withoutParentInjectorRequest() {
+    return new AutoValue_MembersInjectionBinding(
+          key(),
+          dependencies(),
+          implicitDependencies(),
+          bindingPackage(),
+          hasNonDefaultTypeParameters(),
+          bindingElement(),
+          injectionSites(),
+          Optional.<DependencyRequest>absent());
+  }
+
   private static final Ordering<InjectionSite> INJECTION_ORDERING =
       new Ordering<InjectionSite>() {
         @Override
@@ -206,8 +234,8 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
           key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(dependencies)
               .addAll(parentInjectorRequest.asSet())
+              .addAll(dependencies)
               .build(),
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 24cff39b5..d9cd793b4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -120,6 +120,8 @@ private TypeElement getSetElement() {
           producesMethodElement);
     }
 
+    ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
+
     switch (producesAnnotation.type()) {
       case UNIQUE: // fall through
       case SET:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index f92bf94c0..38d45e6a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
 import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -53,6 +54,11 @@
     IMMEDIATE,
     /** Represents a binding configured by {@link Produces} that returns a future. */
     FUTURE_PRODUCTION,
+    /**
+     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC_PRODUCTION,
     /**
      * Represents a binding from a production method on a component dependency that returns a
      * future. Methods that return immediate values are considered provision bindings.
@@ -87,6 +93,16 @@ BindingType bindingType() {
     }
   }
 
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Producer.class;
+  }
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -146,7 +162,7 @@ ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.FUTURE_PRODUCTION,
+          Kind.SYNTHETIC_PRODUCTION,
           Produces.Type.MAP,
           ImmutableList.<TypeMirror>of());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 1a4161410..32bf8d0a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -46,6 +46,8 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -117,6 +119,8 @@ private TypeElement getSetElement() {
           providesMethodElement);
     }
 
+    validateMethodQualifiers(builder, providesMethodElement);
+
     switch (providesAnnotation.type()) {
       case UNIQUE: // fall through
       case SET:
@@ -163,6 +167,17 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
+  /** Validates that a Provides or Produces method doesn't have multiple qualifiers. */
+  static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement methodElement) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+      }
+    }
+  }
+
   private String formatErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index f63eb1422..1d660a9e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -23,11 +23,9 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.Component;
 import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.producers.ProductionComponent;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -65,8 +63,8 @@
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
-        .addAll(dependencies())
         .addAll(memberInjectionRequest().asSet())
+        .addAll(dependencies())
         .build();
   }
 
@@ -125,6 +123,16 @@ BindingType bindingType() {
     }
   }
 
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Provider.class;
+  }
+
   enum FactoryCreationStrategy {
     ENUM_INSTANCE,
     CLASS_CONSTRUCTOR,
@@ -194,7 +202,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           membersInjectionRequest(enclosingCxtorType);
       Optional<AnnotationMirror> scope =
           getScopeAnnotation(constructorElement.getEnclosingElement());
-      
+
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index d9613ddb3..b2fae4a13 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -33,7 +33,7 @@
 public class ComponentProcessorTest {
   private static final StringLiteral NPE_LITERAL =
       StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-  
+
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
         "package test;",
@@ -1122,8 +1122,6 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<AbstractGenericType<String>> abstractGenericTypeMembersInjector;",
-        "  private MembersInjector<SomeInjectableType> someInjectableTypeMembersInjector;",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
@@ -1140,11 +1138,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.abstractGenericTypeMembersInjector = MembersInjectors.noOp();",
-        "    this.someInjectableTypeMembersInjector = MembersInjectors.delegatingTo(",
-        "        abstractGenericTypeMembersInjector);",
         "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType$$Factory.create(someInjectableTypeMembersInjector);",
+        "        SomeInjectableType$$Factory.create((MembersInjector) MembersInjectors.noOp());",
         "  }",
         "",
         "  @Override",
@@ -1742,7 +1737,7 @@
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
- 
+
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
   @SuppressWarnings("unused")
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 7a67567e9..19b9c9419 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -34,7 +34,7 @@
   private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
       "package test;",
       "public @interface Nullable {}");
-  
+
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -547,8 +547,8 @@
         + "          [parameter: test.TestClass.DImpl impl]\n"
         + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
         + "          [parameter: test.TestClass.C c]\n"
-        + "      test.TestClass.C.<init>(test.TestClass.B b)\n"
-        + "          [parameter: test.TestClass.B b]\n"
+        + "      test.TestClass.C.b\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
     String secondError = errorText
@@ -562,7 +562,7 @@
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
-  
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -601,18 +601,18 @@
         "}");
     String expectedMsg = Joiner.on("\n").join(
         "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
-        "      test.Generic.<init>(test.TestClass t)", 
-        "          [parameter: test.TestClass t]", 
-        "      test.TestClass.<init>(java.util.List list)", 
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
+        "      test.Generic.<init>(test.TestClass t)",
+        "          [parameter: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
         "          [parameter: java.util.List list]");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedMsg);
   }
-  
+
   @Test public void resolvedVariablesInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -652,18 +652,18 @@
         "}");
     String expectedMsg = Joiner.on("\n").join(
         "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
         "      test.Generic.t",
-        "          [injected field of type: test.TestClass t]", 
-        "      test.TestClass.<init>(java.util.List list)", 
+        "          [injected field of type: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
         "          [parameter: java.util.List list]");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedMsg);
   }
-  
+
   @Test public void nullCheckForConstructorParameters() {
     JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index fe330a201..19a2c29d0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -64,8 +64,6 @@ public void parentClass_noInjectedMembers() {
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
-        "  private MembersInjector<Parent> parentMembersInjector;",
-        "  private MembersInjector<Child> childMembersInjector;",
         "  private Provider<Child> childProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
@@ -82,9 +80,8 @@ public void parentClass_noInjectedMembers() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.parentMembersInjector = MembersInjectors.noOp();",
-        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = Child$$Factory.create(childMembersInjector);",
+        "    this.childProvider =",
+        "        Child$$Factory.create((MembersInjector) MembersInjectors.noOp());",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index fc716b4b8..18b16575a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -1010,4 +1011,26 @@ public void genericSubclassedModule() {
         .compilesWithoutError()
         .and().generatesSources(listBFactory, numberFactory, integerFactory);
   }
+
+  @Test public void providesMethodMultipleQualifiers() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import javax.annotation.Nullable;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides @QualifierA @QualifierB String provideString() {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 83c96aca1..5719bf3c5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -36,6 +36,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -1154,4 +1155,37 @@ public void publicModuleNonPublicIncludes() {
         .and().generatesSources(factoryFile);
   }
 
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test public void producesMethodMultipleQualifiers() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces @QualifierA @QualifierB abstract String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+  }
 }
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
index 684c2aff2..579e0405f 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -58,12 +58,12 @@
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
 
-    assert_().that(provider.provisions.get()).is(1);
+    assert_().that(provider.provisions.get()).isEqualTo(1);
     Set<Object> results = Sets.newIdentityHashSet();
     for (Future<Object> future : futures) {
       results.add(future.get());
     }
-    assert_().that(results.size()).is(1);
+    assert_().that(results.size()).isEqualTo(1);
   }
 
   // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
index 30cdd4121..46ec6a1bf 100644
--- a/core/src/test/java/dagger/internal/ScopedProviderTest.java
+++ b/core/src/test/java/dagger/internal/ScopedProviderTest.java
@@ -59,8 +59,8 @@
         return i++;
       }
     });
-    assert_().that(scopedProvider.get()).is(0);
-    assert_().that(scopedProvider.get()).is(0);
-    assert_().that(scopedProvider.get()).is(0);
+    assert_().that(scopedProvider.get()).isEqualTo(0);
+    assert_().that(scopedProvider.get()).isEqualTo(0);
+    assert_().that(scopedProvider.get()).isEqualTo(0);
   }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
new file mode 100644
index 000000000..234ff7ebd
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
+ * a future {@link Set} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetProducer<T> extends AbstractProducer<Set<T>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  public static <T> Producer<Set<T>> create(
+      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+    return new SetProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final Set<Producer<Set<T>>> contributingProducers;
+
+  private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
+   * producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then this future will fail
+   * with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * delegate futures fails or is canceled, this one is, too.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<T>> compute() {
+    List<ListenableFuture<Set<T>>> futureSets = new ArrayList<>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureSets.add(futureSet);
+    }
+    return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
+      @Override public Set<T> apply(List<Set<T>> sets) {
+        ImmutableSet.Builder<T> builder = new ImmutableSet.Builder<>();
+        for (Set<T> set : sets) {
+          builder.addAll(set);
+        }
+        return builder.build();
+      }
+    });
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index b7a17004a..e307166f5 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -51,8 +51,8 @@
         return Futures.immediateFuture(i++);
       }
     };
-    assertThat(producer.get().get()).is(0);
-    assertThat(producer.get().get()).is(0);
-    assertThat(producer.get().get()).is(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
   }
 }
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
new file mode 100644
index 000000000..0aafd77de
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link SetProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetProducerTest {
+  @Test public void success() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer((Set<Integer>) ImmutableSet.of(1, 2)),
+        immediateProducer((Set<Integer>) ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
+  }
+
+  @Test public void delegateSetNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer((Set<Integer>) ImmutableSet.of(1, 2)),
+        immediateProducer((Set<Integer>) null));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  @Test public void delegateElementNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        immediateProducer((Set<Integer>) ImmutableSet.of(1, 2)),
+        immediateProducer(Collections.singleton((Integer) null)));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  private static final class ImmediateProducer<T> implements Producer<T> {
+    private final T value;
+
+    ImmediateProducer(T value) {
+      this.value = value;
+    }
+
+    @Override public ListenableFuture<T> get() {
+      return Futures.immediateFuture(value);
+    }
+  }
+
+  private static <T> Producer<T> immediateProducer(T value) {
+    return new ImmediateProducer<T>(value);
+  }
+}
