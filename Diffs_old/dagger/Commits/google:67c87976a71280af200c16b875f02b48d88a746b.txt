diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index ec0fae769..7c9292ef2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -17,6 +17,7 @@
 
 import dagger.Component;
 import dagger.Lazy;
+import dagger.Subcomponent;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -96,6 +97,8 @@ private Cycles() {}
     A a();
 
     C c();
+
+    ChildCycleComponent child();
   }
 
   @SuppressWarnings("dependency-cycle")
@@ -103,4 +106,10 @@ private Cycles() {}
   interface SelfCycleComponent {
     S s();
   }
+
+  @Subcomponent
+  interface ChildCycleComponent {
+    @SuppressWarnings("dependency-cycle")
+    A a();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
index c3f20452a..b580dc524 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
@@ -20,6 +20,7 @@
 import org.junit.runners.JUnit4;
 import test.cycle.Cycles.A;
 import test.cycle.Cycles.C;
+import test.cycle.Cycles.ChildCycleComponent;
 import test.cycle.Cycles.CycleComponent;
 import test.cycle.Cycles.S;
 import test.cycle.Cycles.SelfCycleComponent;
@@ -61,4 +62,12 @@ public void lazyIndirectionCycle() {
     assertThat(a.b.c.aLazy.get()).isNotNull();
     assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
   }
+  
+  @Test
+  public void subcomponentIndirectionCycle() {
+    ChildCycleComponent childCycleComponent = DaggerCycles_CycleComponent.create().child();
+    A a = childCycleComponent.a();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c28a39274..2e5d869b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -36,9 +36,11 @@
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
@@ -469,8 +471,16 @@ void resolve(DependencyRequest request) {
        * <p>We don't care about scoped dependencies or production bindings because they will never
        * depend on multibindings with contributions from subcomponents.
        */
+      private boolean dependsOnLocalMultibindings(ResolvedBindings previouslyResolvedBindings) {
+        return dependsOnLocalMultibindings(previouslyResolvedBindings, new HashSet<BindingKey>());
+      }
+
       private boolean dependsOnLocalMultibindings(
-          final ResolvedBindings previouslyResolvedBindings) {
+          final ResolvedBindings previouslyResolvedBindings, final Set<BindingKey> cycleChecker) {
+        // Don't recur infinitely if there are valid cycles in the dependency graph.
+        if (!cycleChecker.add(previouslyResolvedBindings.bindingKey())) {
+          return false;
+        }
         try {
           return dependsOnLocalMultibindingsCache.get(
               previouslyResolvedBindings.bindingKey(),
@@ -486,7 +496,8 @@ public Boolean call() {
                     if (!isScoped(binding) && !(binding instanceof ProductionBinding)) {
                       for (DependencyRequest dependency : binding.implicitDependencies()) {
                         if (dependsOnLocalMultibindings(
-                            getPreviouslyResolvedBindings(dependency.bindingKey()).get())) {
+                            getPreviouslyResolvedBindings(dependency.bindingKey()).get(),
+                            cycleChecker)) {
                           return true;
                         }
                       }
