diff --git a/reflect/.gitignore b/reflect/.gitignore
new file mode 100644
index 000000000..08a55c09b
--- /dev/null
+++ b/reflect/.gitignore
@@ -0,0 +1 @@
+.gradle
diff --git a/reflect/build.gradle b/reflect/build.gradle
new file mode 100644
index 000000000..0147b07a9
--- /dev/null
+++ b/reflect/build.gradle
@@ -0,0 +1,21 @@
+buildscript {
+  ext.deps = [
+    'dagger': [
+      'runtime': 'com.google.dagger:dagger:2.17',
+      'compiler': 'com.google.dagger:dagger-compiler:2.17',
+    ],
+    'annotations': 'org.jetbrains:annotations:16.0.2',
+    'junit': 'junit:junit:4.12',
+    'truth': 'com.google.truth:truth:0.42',
+    'javaPoet': 'com.squareup:javapoet:1.11.1',
+    'autoService': 'com.google.auto.service:auto-service:1.0-rc4',
+    'compileTesting': 'com.google.testing.compile:compile-testing:0.15',
+  ]
+}
+
+allprojects {
+  repositories {
+    mavenCentral()
+    jcenter()
+  }
+}
diff --git a/reflect/codegen/build.gradle b/reflect/codegen/build.gradle
new file mode 100644
index 000000000..8ab4688a1
--- /dev/null
+++ b/reflect/codegen/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java-library'
+
+sourceCompatibility = JavaVersion.VERSION_1_6
+targetCompatibility = JavaVersion.VERSION_1_6
+
+dependencies {
+  api deps.dagger.runtime
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+  testAnnotationProcessor deps.dagger.compiler
+}
diff --git a/reflect/codegen/src/main/java/dagger/Dagger.java b/reflect/codegen/src/main/java/dagger/Dagger.java
new file mode 100644
index 000000000..6d0b74caa
--- /dev/null
+++ b/reflect/codegen/src/main/java/dagger/Dagger.java
@@ -0,0 +1,15 @@
+package dagger;
+
+import dagger.internal.DaggerCodegen;
+
+public final class Dagger {
+  public static <C> C create(Class<C> componentClass) {
+    return DaggerCodegen.create(componentClass);
+  }
+
+  public static <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+    return DaggerCodegen.builder(componentClass, builderClass);
+  }
+
+  private Dagger() {}
+}
diff --git a/reflect/codegen/src/main/java/dagger/internal/DaggerCodegen.java b/reflect/codegen/src/main/java/dagger/internal/DaggerCodegen.java
new file mode 100644
index 000000000..bf1b4da62
--- /dev/null
+++ b/reflect/codegen/src/main/java/dagger/internal/DaggerCodegen.java
@@ -0,0 +1,52 @@
+package dagger.internal;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+public final class DaggerCodegen {
+  public static <C> C create(Class<C> componentClass) {
+    return invokeStatic(findImplementationClass(componentClass), "create", componentClass);
+  }
+
+  public static <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+    return invokeStatic(findImplementationClass(componentClass), "builder", builderClass);
+  }
+
+  private static <C> Class<? extends C> findImplementationClass(Class<C> componentClass) {
+    String implementationName =
+        componentClass.getPackage().getName() + ".Dagger" + componentClass.getSimpleName();
+    try {
+      //noinspection unchecked Dagger compiler guarantees this cast to succeed.
+      return (Class<? extends C>) componentClass.getClassLoader().loadClass(implementationName);
+    } catch (ClassNotFoundException e) {
+      throw new IllegalStateException("Unable to find generated component implementation "
+          + implementationName
+          + " for component "
+          + componentClass.getName(), e);
+    }
+  }
+
+  private static <T> T invokeStatic(Class<?> target, String methodName, Class<T> returnType) {
+    Method method;
+    try {
+      method = target.getMethod(methodName);
+    } catch (NoSuchMethodException e) {
+      throw new IllegalStateException("Unable to find method '" + methodName + "' on " + target, e);
+    }
+    Object returnValue;
+    try {
+      returnValue = method.invoke(null);
+    } catch (IllegalAccessException e) {
+      throw new IllegalStateException("Unable to invoke method '" + methodName + "' on " + target,
+          e);
+    } catch (InvocationTargetException e) {
+      Throwable cause = e.getCause();
+      if (cause instanceof RuntimeException) throw (RuntimeException) cause;
+      if (cause instanceof Error) throw (Error) cause;
+      throw new RuntimeException("Exception while reflectively invoking method", e);
+    }
+    return returnType.cast(returnValue);
+  }
+
+  private DaggerCodegen() {}
+}
diff --git a/reflect/codegen/src/test/java/dagger/internal/BuilderComponent.java b/reflect/codegen/src/test/java/dagger/internal/BuilderComponent.java
new file mode 100644
index 000000000..2760ff1c5
--- /dev/null
+++ b/reflect/codegen/src/test/java/dagger/internal/BuilderComponent.java
@@ -0,0 +1,11 @@
+package dagger.internal;
+
+import dagger.Component;
+
+@Component
+interface BuilderComponent {
+  @Component.Builder
+  interface Builder {
+    BuilderComponent build();
+  }
+}
diff --git a/reflect/codegen/src/test/java/dagger/internal/DaggerCodegenTest.java b/reflect/codegen/src/test/java/dagger/internal/DaggerCodegenTest.java
new file mode 100644
index 000000000..d08788394
--- /dev/null
+++ b/reflect/codegen/src/test/java/dagger/internal/DaggerCodegenTest.java
@@ -0,0 +1,18 @@
+package dagger.internal;
+
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+
+public final class DaggerCodegenTest {
+  @Test public void create() {
+    NoBuilderComponent actual = DaggerCodegen.create(NoBuilderComponent.class);
+    assertThat(actual).isInstanceOf(DaggerNoBuilderComponent.class);
+  }
+
+  @Test public void builder() {
+    BuilderComponent.Builder actual =
+        DaggerCodegen.builder(BuilderComponent.class, BuilderComponent.Builder.class);
+    assertThat(actual).isInstanceOf(DaggerBuilderComponent.builder().getClass());
+  }
+}
diff --git a/reflect/codegen/src/test/java/dagger/internal/NoBuilderComponent.java b/reflect/codegen/src/test/java/dagger/internal/NoBuilderComponent.java
new file mode 100644
index 000000000..11a21efd0
--- /dev/null
+++ b/reflect/codegen/src/test/java/dagger/internal/NoBuilderComponent.java
@@ -0,0 +1,7 @@
+package dagger.internal;
+
+import dagger.Component;
+
+@Component
+interface NoBuilderComponent {
+}
diff --git a/reflect/gradle/wrapper/gradle-wrapper.jar b/reflect/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 000000000..0d4a95168
Binary files /dev/null and b/reflect/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/reflect/gradle/wrapper/gradle-wrapper.properties b/reflect/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 000000000..115e6ac0a
--- /dev/null
+++ b/reflect/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.10-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/reflect/gradlew b/reflect/gradlew
new file mode 100755
index 000000000..cccdd3d51
--- /dev/null
+++ b/reflect/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/reflect/reflect-compiler/build.gradle b/reflect/reflect-compiler/build.gradle
new file mode 100644
index 000000000..840f9b193
--- /dev/null
+++ b/reflect/reflect-compiler/build.gradle
@@ -0,0 +1,20 @@
+import org.gradle.internal.jvm.Jvm
+
+apply plugin: 'java-library'
+
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
+
+dependencies {
+  implementation project(':reflect')
+  implementation deps.javaPoet
+  implementation deps.annotations
+
+  compileOnly deps.autoService
+  annotationProcessor deps.autoService
+
+  testImplementation deps.junit
+  testImplementation deps.truth
+  testImplementation deps.compileTesting
+  testImplementation files(Jvm.current().getToolsJar())
+}
diff --git a/reflect/reflect-compiler/src/main/java/dagger/reflect/compiler/DaggerReflectCompiler.java b/reflect/reflect-compiler/src/main/java/dagger/reflect/compiler/DaggerReflectCompiler.java
new file mode 100644
index 000000000..b9ebfeb40
--- /dev/null
+++ b/reflect/reflect-compiler/src/main/java/dagger/reflect/compiler/DaggerReflectCompiler.java
@@ -0,0 +1,100 @@
+package dagger.reflect.compiler;
+
+import com.google.auto.service.AutoService;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Component;
+import dagger.reflect.DaggerReflect;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import org.jetbrains.annotations.Nullable;
+
+import static java.util.Collections.singleton;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+@AutoService(Processor.class)
+public final class DaggerReflectCompiler extends AbstractProcessor {
+  private static final ClassName DAGGER_REFLECT = ClassName.get(DaggerReflect.class);
+
+  private Filer filer;
+  private Messager messager;
+
+  @Override public synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+    filer = processingEnv.getFiler();
+    messager = processingEnv.getMessager();
+  }
+
+  @Override public Set<String> getSupportedAnnotationTypes() {
+    return singleton(Component.class.getCanonicalName());
+  }
+
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latest();
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    Set<? extends Element> candidates = roundEnv.getElementsAnnotatedWith(Component.class);
+    for (Element candidate : candidates) {
+      TypeElement component = (TypeElement) candidate;
+      ClassName componentName = ClassName.get(component);
+      TypeElement builder = findBuilder(component);
+      ClassName builderName = builder != null ? ClassName.get(builder) : null;
+
+      TypeSpec type = createComponent(componentName, builderName)
+          .toBuilder()
+          .addOriginatingElement(component)
+          .build();
+      JavaFile file = JavaFile.builder(componentName.packageName(), type)
+              .addFileComment("Generated by Dagger's reflect-compiler. Do not modify!")
+              .build();
+      try {
+        file.writeTo(filer);
+      } catch (Exception e) {
+        messager.printMessage(ERROR, "Unable to write component implementation: " + e, component);
+      }
+    }
+    return false;
+  }
+
+  private static @Nullable TypeElement findBuilder(TypeElement component) {
+    for (Element enclosed : component.getEnclosedElements()) {
+      if (enclosed.getAnnotation(Component.Builder.class) != null) {
+        return (TypeElement) enclosed;
+      }
+    }
+    return null;
+  }
+
+  private static TypeSpec createComponent(ClassName component, @Nullable ClassName builder) {
+    TypeSpec.Builder type = TypeSpec.classBuilder("Dagger" + component.simpleName())
+        .addModifiers(FINAL)
+        .addMethod(MethodSpec.methodBuilder("create")
+            .addModifiers(PUBLIC, STATIC)
+            .returns(component)
+            .addStatement("return $T.create($T.class)", DAGGER_REFLECT, component)
+            .build());
+    if (builder != null) {
+      type.addMethod(MethodSpec.methodBuilder("builder")
+          .addModifiers(PUBLIC, STATIC)
+          .returns(builder)
+          .addStatement("return $T.builder($T.class, $T.class)", DAGGER_REFLECT, component, builder)
+          .build());
+    }
+    return type.build();
+  }
+}
diff --git a/reflect/reflect-compiler/src/test/java/dagger/reflect/compiler/DaggerReflectCompilerTest.java b/reflect/reflect-compiler/src/test/java/dagger/reflect/compiler/DaggerReflectCompilerTest.java
new file mode 100644
index 000000000..9de2465f7
--- /dev/null
+++ b/reflect/reflect-compiler/src/test/java/dagger/reflect/compiler/DaggerReflectCompilerTest.java
@@ -0,0 +1,79 @@
+package dagger.reflect.compiler;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+public final class DaggerReflectCompilerTest {
+  @Test public void simple() {
+    JavaFileObject component = JavaFileObjects.forSourceString("example.TestComponent", ""
+        + "package example;\n"
+        + "\n"
+        + "import dagger.Component;\n"
+        + "\n"
+        + "@Component\n"
+        + "interface TestComponent {\n"
+        + "}\n"
+    );
+
+    JavaFileObject expected = JavaFileObjects.forSourceString("example.DaggerTestComponent", ""
+        + "package example;\n"
+        + "\n"
+        + "import dagger.reflect.DaggerReflect\n"
+        + "\n"
+        + "final class DaggerTestComponent {\n"
+        + "  public static TestComponent create() {\n"
+        + "    return DaggerReflect.create(TestComponent.class);\n"
+        + "  }\n"
+        + "}\n"
+    );
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new DaggerReflectCompiler())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test public void builder() {
+    JavaFileObject component = JavaFileObjects.forSourceString("example.TestComponent", ""
+        + "package example;\n"
+        + "\n"
+        + "import dagger.Component;\n"
+        + "\n"
+        + "@Component\n"
+        + "interface TestComponent {\n"
+        + "  @Component.Builder\n"
+        + "  interface Builder {\n"
+        + "  }\n"
+        + "}\n"
+    );
+
+    JavaFileObject expected = JavaFileObjects.forSourceString("example.DaggerTestComponent", ""
+        + "package example;\n"
+        + "\n"
+        + "import dagger.reflect.DaggerReflect\n"
+        + "\n"
+        + "final class DaggerTestComponent {\n"
+        + "  public static TestComponent create() {\n"
+        + "    return DaggerReflect.create(TestComponent.class);\n"
+        + "  }\n"
+        + "\n"
+        + "  public static TestComponent.Builder builder() {\n"
+        + "    return DaggerReflect.builder(TestComponent.class, TestComponent.Builder.class);\n"
+        + "  }\n"
+        + "}\n"
+    );
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new DaggerReflectCompiler())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+}
diff --git a/reflect/reflect/build.gradle b/reflect/reflect/build.gradle
new file mode 100644
index 000000000..cd953e305
--- /dev/null
+++ b/reflect/reflect/build.gradle
@@ -0,0 +1,14 @@
+apply plugin: 'java-library'
+
+sourceCompatibility = JavaVersion.VERSION_1_6
+targetCompatibility = JavaVersion.VERSION_1_6
+
+dependencies {
+  api deps.dagger.runtime
+  implementation deps.annotations
+
+  testImplementation project(':codegen')
+  testImplementation deps.junit
+  testImplementation deps.truth
+  testAnnotationProcessor deps.dagger.compiler
+}
diff --git a/reflect/reflect/src/main/java/dagger/Dagger.java b/reflect/reflect/src/main/java/dagger/Dagger.java
new file mode 100644
index 000000000..82f264420
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/Dagger.java
@@ -0,0 +1,15 @@
+package dagger;
+
+import dagger.reflect.DaggerReflect;
+
+public final class Dagger {
+  public static <C> C create(Class<C> componentClass) {
+    return DaggerReflect.create(componentClass);
+  }
+
+  public static <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+    return DaggerReflect.builder(componentClass, builderClass);
+  }
+
+  private Dagger() {}
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/ComponentInvocationHandler.java b/reflect/reflect/src/main/java/dagger/reflect/ComponentInvocationHandler.java
new file mode 100644
index 000000000..c18b41341
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/ComponentInvocationHandler.java
@@ -0,0 +1,49 @@
+package dagger.reflect;
+
+import dagger.Subcomponent;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+
+import static dagger.reflect.DaggerReflect.notImplemented;
+import static dagger.reflect.Util.findQualifier;
+
+final class ComponentInvocationHandler implements InvocationHandler {
+  private final InstanceGraph instanceGraph;
+
+  ComponentInvocationHandler(InstanceGraph instanceGraph) {
+    this.instanceGraph = instanceGraph;
+  }
+
+  @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+    if (method.getDeclaringClass() == Object.class) {
+      return method.invoke(this, args);
+    }
+    if (method.isDefault()) {
+      throw notImplemented("Default methods");
+    }
+
+    Type returnType = method.getGenericReturnType();
+    Class<?>[] parameterTypes = method.getParameterTypes();
+
+    if (args != null
+        && args.length == 1
+        && (returnType == void.class || returnType.equals(parameterTypes[0]))) {
+      throw notImplemented("Members injection");
+    }
+
+    if (args == null || args.length == 0) {
+      Annotation[] annotations = method.getDeclaredAnnotations();
+      if (returnType instanceof Class<?>
+          && ((Class<?>) returnType).getAnnotation(Subcomponent.class) != null) {
+        throw notImplemented("Subcomponents");
+      }
+
+      Key key = new Key(findQualifier(annotations), returnType);
+      return instanceGraph.getInstance(key);
+    }
+
+    throw notImplemented("Method " + method);
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java b/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java
new file mode 100644
index 000000000..bab1cd2a2
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java
@@ -0,0 +1,144 @@
+package dagger.reflect;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.lang.reflect.Type;
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import javax.inject.Provider;
+
+import static dagger.reflect.Util.findQualifier;
+import static dagger.reflect.Util.findScope;
+import static dagger.reflect.Util.hasAnnotation;
+import static dagger.reflect.Util.tryInvoke;
+import static java.lang.reflect.Modifier.ABSTRACT;
+
+public final class DaggerReflect {
+  public static <C> C create(Class<C> componentClass) {
+    if (!componentClass.isInterface()) {
+      throw new IllegalArgumentException("Only interface components are supported");
+    }
+
+    Component component = componentClass.getAnnotation(Component.class);
+    if (component == null) {
+      throw new IllegalArgumentException(componentClass + " lacks @Component annotation");
+    }
+
+    Class<?>[] dependencies = component.dependencies();
+    if (dependencies.length > 0) {
+      throw notImplemented("Component dependencies");
+    }
+
+    Annotation scope = findScope(componentClass.getAnnotations());
+
+    final InstanceGraph instanceGraph = new InstanceGraph();
+    Deque<Class<?>> moduleQueue = new ArrayDeque<Class<?>>();
+    Set<Class<?>> seenModules = new LinkedHashSet<Class<?>>();
+    Collections.addAll(moduleQueue, component.modules());
+    while (!moduleQueue.isEmpty()) {
+      Class<?> moduleClass = moduleQueue.removeFirst();
+      if (!seenModules.add(moduleClass)) {
+        continue;
+      }
+      if (moduleClass.getSuperclass() != Object.class) {
+        throw notImplemented("Module inheritance");
+      }
+      Module module = moduleClass.getAnnotation(Module.class);
+      if (module == null) {
+        throw new IllegalStateException("Module " + moduleClass + " missing @Module");
+      }
+      Collections.addAll(moduleQueue, module.includes());
+      // TODO subcomponents
+
+      for (final Method method : moduleClass.getDeclaredMethods()) {
+        Type returnType = method.getGenericReturnType();
+        Annotation[] annotations = method.getDeclaredAnnotations();
+        Annotation qualifier = findQualifier(annotations);
+        int parameterCount = method.getParameterTypes().length;
+
+        if (hasAnnotation(annotations, Provides.class)) {
+          final Request[] requests = new Request[parameterCount];
+          for (int i = 0; i < parameterCount; i++) {
+            requests[i] = Request.fromMethodParameter(method, i);
+          }
+
+          // TODO check visibility
+          method.setAccessible(true);
+
+          Annotation methodScope = findScope(annotations);
+          if (!Util.equals(scope, methodScope)) {
+            // TODO real error message
+            throw new IllegalStateException("Cannot provide " + methodScope + " in " + scope);
+          }
+
+          instanceGraph.put(new Key(qualifier, returnType), new Provider<Object>() {
+            @Override public Object get() {
+              Object[] arguments = new Object[requests.length];
+              for (int i = 0; i < requests.length; i++) {
+                arguments[i] = requests[i].resolve(instanceGraph);
+              }
+              return tryInvoke(method, null, arguments);
+            }
+          });
+          continue;
+        }
+
+        if (hasAnnotation(annotations, Binds.class)) {
+          if (parameterCount != 1) {
+            throw new IllegalStateException("@Binds must have single parameter: "
+                + method.getDeclaringClass().getName()
+                + '.'
+                + method.getName());
+          }
+          if ((method.getModifiers() & ABSTRACT) == 0) {
+            throw new IllegalStateException("@Binds methods must be abstract: "
+                + method.getDeclaringClass()
+                + '.'
+                + method.getName());
+          }
+
+          // TODO check visibility
+          method.setAccessible(true);
+
+          Annotation methodScope = findScope(annotations);
+          if (!Util.equals(scope, methodScope)) {
+            // TODO real error message
+            throw new IllegalStateException("Cannot provide " + methodScope + " in " + scope);
+          }
+
+          final Key delegate = Key.fromMethodParameter(method, 0);
+          instanceGraph.put(new Key(qualifier, returnType), new Provider<Object>() {
+            @Override public Object get() {
+              return instanceGraph.getInstance(delegate);
+            }
+          });
+          continue;
+        }
+
+        throw notImplemented("Method " + method);
+      }
+    }
+
+    //noinspection unchecked Single interface proxy.
+    return (C) Proxy.newProxyInstance(componentClass.getClassLoader(),
+        new Class<?>[] { componentClass }, new ComponentInvocationHandler(instanceGraph));
+  }
+
+  public static <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+    throw notImplemented("Builders");
+  }
+
+  static RuntimeException notImplemented(String feature) {
+    return new UnsupportedOperationException(feature + " does not work yet, sorry!");
+  }
+
+  private DaggerReflect() {}
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java b/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java
new file mode 100644
index 000000000..923dc98aa
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java
@@ -0,0 +1,46 @@
+package dagger.reflect;
+
+import dagger.Lazy;
+import dagger.internal.DoubleCheck;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.inject.Provider;
+import org.jetbrains.annotations.Nullable;
+
+final class InstanceGraph {
+  private final @Nullable InstanceGraph parent;
+  private final ConcurrentHashMap<Key, Provider<?>> bindings =
+      new ConcurrentHashMap<Key, Provider<?>>();
+
+  InstanceGraph() {
+    this(null);
+  }
+
+  InstanceGraph(@Nullable InstanceGraph parent) {
+    this.parent = parent;
+  }
+
+  void put(Key key, Provider<?> provider) {
+    if (bindings.put(key, provider) != null) {
+      throw new IllegalStateException("Duplicate binding for " + key);
+    }
+  }
+
+  Object getInstance(Key key) {
+    return getProvider(key).get();
+  }
+
+  Provider<?> getProvider(Key key) {
+    Provider<?> provider = bindings.get(key);
+    if (provider == null && parent != null) {
+      provider = parent.getProvider(key);
+    }
+    if (provider == null) {
+      throw new IllegalStateException("No binding for " + key);
+    }
+    return provider;
+  }
+
+  Lazy<?> getLazy(Key key) {
+    return DoubleCheck.lazy(getProvider(key));
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/Key.java b/reflect/reflect/src/main/java/dagger/reflect/Key.java
new file mode 100644
index 000000000..a5dfcea4f
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/Key.java
@@ -0,0 +1,42 @@
+package dagger.reflect;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import org.jetbrains.annotations.Nullable;
+
+/** A type and optional qualifier. */
+final class Key {
+  static Key fromMethodParameter(Method method, int parameterIndex) {
+    Annotation qualifier = Util.findQualifier(method.getParameterAnnotations()[parameterIndex]);
+    Type type = method.getGenericParameterTypes()[parameterIndex];
+    return new Key(qualifier, type);
+  }
+
+  private final @Nullable Annotation qualifer;
+  private final Type type;
+
+  Key(@Nullable Annotation qualifer, Type type) {
+    this.qualifer = qualifer;
+    this.type = type;
+  }
+
+  @Override public String toString() {
+    if (qualifer != null) {
+      return "@" + qualifer + " " + type;
+    }
+    return type.toString();
+  }
+
+  @Override public boolean equals(Object obj) {
+    if (obj == this) return true;
+    if (!(obj instanceof Key)) return false;
+    Key other = (Key) obj;
+    return type.equals(other.type)
+        && Util.equals(qualifer, other.qualifer);
+  }
+
+  @Override public int hashCode() {
+    return 31 * type.hashCode() + (qualifer != null ? qualifer.hashCode() : 0);
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/Request.java b/reflect/reflect/src/main/java/dagger/reflect/Request.java
new file mode 100644
index 000000000..327b0417b
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/Request.java
@@ -0,0 +1,63 @@
+package dagger.reflect;
+
+import dagger.Lazy;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.inject.Provider;
+
+/** A key and its lookup type. */
+final class Request {
+  static Request fromMethodParameter(Method method, int parameterIndex) {
+    Annotation qualifier = Util.findQualifier(method.getParameterAnnotations()[parameterIndex]);
+
+    Type type = method.getGenericParameterTypes()[parameterIndex];
+    Lookup lookup = Lookup.INSTANCE;
+    if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      Type rawType = parameterizedType.getRawType();
+      if (rawType == Provider.class) {
+        type = parameterizedType.getActualTypeArguments()[0];
+        lookup = Lookup.PROVIDER;
+      } else if (rawType == Lazy.class) {
+        type = parameterizedType.getActualTypeArguments()[0];
+        lookup = Lookup.LAZY;
+      }
+    }
+
+    return new Request(new Key(qualifier, type), lookup);
+  }
+
+  private final Key key;
+  private final Lookup lookup;
+
+  Request(Key key, Lookup lookup) {
+    this.key = key;
+    this.lookup = lookup;
+  }
+
+  Object resolve(InstanceGraph instanceGraph) {
+    return lookup.lookup(instanceGraph, key);
+  }
+
+  enum Lookup {
+    INSTANCE {
+      @Override Object lookup(InstanceGraph instanceGraph, Key key) {
+        return instanceGraph.getInstance(key);
+      }
+    },
+    PROVIDER {
+      @Override Object lookup(InstanceGraph instanceGraph, Key key) {
+        return instanceGraph.getProvider(key);
+      }
+    },
+    LAZY {
+      @Override Object lookup(InstanceGraph instanceGraph, Key key) {
+        return instanceGraph.getLazy(key);
+      }
+    };
+
+    abstract Object lookup(InstanceGraph instanceGraph, Key key);
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/Util.java b/reflect/reflect/src/main/java/dagger/reflect/Util.java
new file mode 100644
index 000000000..dc4acf564
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/Util.java
@@ -0,0 +1,74 @@
+package dagger.reflect;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import org.jetbrains.annotations.Nullable;
+
+final class Util {
+  static boolean equals(@Nullable Object left, @Nullable Object right) {
+    return left == null ? right == null : left.equals(right);
+  }
+
+  static @Nullable Annotation findQualifier(Annotation[] annotations) {
+    Annotation qualifier = null;
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().getAnnotation(Qualifier.class) != null) {
+        if (qualifier != null) {
+          throw new IllegalStateException("Found multiple qualifier annotations: @"
+              + qualifier.annotationType().getName()
+              + " and @"
+              + annotation.annotationType().getName());
+        }
+        qualifier = annotation;
+      }
+    }
+    return qualifier;
+  }
+
+  static @Nullable Annotation findScope(Annotation[] annotations) {
+    Annotation scope = null;
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().getAnnotation(Scope.class) != null) {
+        if (scope != null) {
+          throw new IllegalStateException("Found multiple scope annotations: @"
+              + scope.annotationType().getName()
+              + " and @"
+              + annotation.annotationType().getName());
+        }
+        scope = annotation;
+      }
+    }
+    return scope;
+  }
+
+  static boolean hasAnnotation(Annotation[] annotations, Class<?> annotationClass) {
+    for (Annotation annotation : annotations) {
+      if (annotation.annotationType().equals(annotationClass)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static Object tryInvoke(Method method, Object target, Object... arguments) {
+    Throwable cause;
+    try {
+      return method.invoke(target, arguments);
+    } catch (IllegalAccessException e) {
+      cause = e;
+    } catch (InvocationTargetException e) {
+      cause = e.getCause();
+      if (cause instanceof RuntimeException) throw (RuntimeException) cause;
+      if (cause instanceof Error) throw (Error) cause;
+    }
+    throw new RuntimeException(
+        "Unable to invoke " + method + " on " + target + " with arguments "
+            + Arrays.toString(arguments), cause);
+  }
+
+  private Util() {}
+}
diff --git a/reflect/reflect/src/test/java/dagger/DaggerTest.java b/reflect/reflect/src/test/java/dagger/DaggerTest.java
new file mode 100644
index 000000000..2e065b433
--- /dev/null
+++ b/reflect/reflect/src/test/java/dagger/DaggerTest.java
@@ -0,0 +1,24 @@
+package dagger;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(Parameterized.class)
+public final class DaggerTest {
+  @Parameters(name = "{0}")
+  public static Object[] parameters() {
+    return Frontend.values();
+  }
+
+  @Parameter public Frontend frontend;
+
+  @Test public void hello() {
+    TestComponent component = frontend.create(TestComponent.class);
+    assertThat(component.hello()).isEqualTo("Hello, world!");
+  }
+}
diff --git a/reflect/reflect/src/test/java/dagger/Frontend.java b/reflect/reflect/src/test/java/dagger/Frontend.java
new file mode 100644
index 000000000..a2d695adb
--- /dev/null
+++ b/reflect/reflect/src/test/java/dagger/Frontend.java
@@ -0,0 +1,28 @@
+package dagger;
+
+import dagger.internal.DaggerCodegen;
+import dagger.reflect.DaggerReflect;
+
+enum Frontend {
+  REFLECT {
+    @Override <C> C create(Class<C> componentClass) {
+      return DaggerReflect.create(componentClass);
+    }
+
+    @Override <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+      return DaggerReflect.builder(componentClass, builderClass);
+    }
+  },
+  CODEGEN {
+    @Override <C> C create(Class<C> componentClass) {
+      return DaggerCodegen.create(componentClass);
+    }
+
+    @Override <C, B> B builder(Class<C> componentClass, Class<B> builderClass) {
+      return DaggerCodegen.builder(componentClass, builderClass);
+    }
+  };
+
+  abstract <C> C create(Class<C> componentClass);
+  abstract <C, B> B builder(Class<C> componentClass, Class<B> builderClass);
+}
diff --git a/reflect/reflect/src/test/java/dagger/TestComponent.java b/reflect/reflect/src/test/java/dagger/TestComponent.java
new file mode 100644
index 000000000..0bee03667
--- /dev/null
+++ b/reflect/reflect/src/test/java/dagger/TestComponent.java
@@ -0,0 +1,7 @@
+package dagger;
+
+@Component(modules = TestModule.class)
+interface TestComponent {
+  CharSequence hello();
+}
+
diff --git a/reflect/reflect/src/test/java/dagger/TestModule.java b/reflect/reflect/src/test/java/dagger/TestModule.java
new file mode 100644
index 000000000..09d88f387
--- /dev/null
+++ b/reflect/reflect/src/test/java/dagger/TestModule.java
@@ -0,0 +1,38 @@
+package dagger;
+
+import java.lang.annotation.Retention;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Module
+abstract class TestModule {
+  @Provides static @Hello String provideHelloString() {
+    return "Hello";
+  }
+
+  @Provides static @World String provideWorldString() {
+    return "world";
+  }
+
+  @Provides static @Exclamation String provideExclaimationString() {
+    return "!";
+  }
+
+  @Provides static String provideString(
+      @Hello String hello,
+      @World Provider<String> world,
+      @Exclamation Lazy<String> exclaimation) {
+    return hello + ", " + world.get() + exclaimation.get();
+  }
+
+  @Binds abstract CharSequence provideCharSequence(String hello);
+
+  @Retention(RUNTIME)
+  @Qualifier @interface Hello {}
+  @Retention(RUNTIME)
+  @Qualifier @interface World {}
+  @Retention(RUNTIME)
+  @Qualifier @interface Exclamation {}
+}
diff --git a/reflect/settings.gradle b/reflect/settings.gradle
new file mode 100644
index 000000000..b2c0e813b
--- /dev/null
+++ b/reflect/settings.gradle
@@ -0,0 +1,3 @@
+include ':codegen'
+include ':reflect'
+include ':reflect-compiler'
