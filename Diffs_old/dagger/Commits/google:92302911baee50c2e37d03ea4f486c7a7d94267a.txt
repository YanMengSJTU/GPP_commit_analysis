diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 3fbbee24c..7edfee314 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -15,8 +15,12 @@
  */
 package dagger.producers;
 
+import com.google.common.base.Objects;
 import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
+import javax.annotation.Nullable;
+
+import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
@@ -39,11 +43,91 @@
  * @author Jesse Beder
  */
 @Beta
-public interface Produced<T> {
+public abstract class Produced<T> {
   /**
    * Returns the result of a production.
    *
    * @throws ExecutionException if the production threw an exception
    */
-  T get() throws ExecutionException;
+  public abstract T get() throws ExecutionException;
+
+  /**
+   * Two {@code Produced} objects compare equal if both are successful with equal values, or both
+   * are failed with equal exceptions.
+   */
+  @Override
+  public abstract boolean equals(Object o);
+
+  /** Returns an appropriate hash code to match {@link #equals). */
+  @Override
+  public abstract int hashCode();
+
+  /** Returns a successful {@code Produced}, whose {@link #get} will return the given value. */
+  public static <T> Produced<T> successful(@Nullable T value) {
+    return new Successful(value);
+  }
+
+  /**
+   * Returns a failed {@code Produced}, whose {@link #get} will throw an
+   * {@code ExecutionException} with the given cause.
+   */
+  public static <T> Produced<T> failed(Throwable throwable) {
+    return new Failed(checkNotNull(throwable));
+  }
+
+  private static final class Successful<T> extends Produced<T> {
+    @Nullable private final T value;
+
+    private Successful(@Nullable T value) {
+      this.value = value;
+    }
+
+    @Override public T get() {
+      return value;
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Successful) {
+        Successful that = (Successful) o;
+        return Objects.equal(this.value, that.value);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return value == null ? 0 : value.hashCode();
+    }
+  }
+
+  private static final class Failed<T> extends Produced<T> {
+    private final Throwable throwable;
+
+    private Failed(Throwable throwable) {
+      this.throwable = checkNotNull(throwable);
+    }
+
+    @Override public T get() throws ExecutionException {
+      throw new ExecutionException(throwable);
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Failed) {
+        Failed that = (Failed) o;
+        return this.throwable.equals(that.throwable);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return throwable.hashCode();
+    }
+  }
+
+  private Produced() {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index c850caa33..983834249 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -25,7 +25,6 @@
 import dagger.producers.Producer;
 import java.util.Set;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import javax.inject.Provider;
@@ -55,11 +54,7 @@
     return Futures.withFallback(
         Futures.transform(future, new Function<T, Produced<T>>() {
           @Override public Produced<T> apply(final T value) {
-            return new Produced<T>() {
-              @Override public T get() {
-                return value;
-              }
-            };
+            return Produced.successful(value);
           }
         }), Producers.<T>futureFallbackForProduced());
 
@@ -68,11 +63,7 @@
   private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
       new FutureFallback<Produced<Object>>() {
     @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
-      Produced<Object> produced = new Produced<Object>() {
-        @Override public Object get() throws ExecutionException {
-          throw new ExecutionException(t);
-        }
-      };
+      Produced<Object> produced = Produced.failed(t);
       return Futures.immediateFuture(produced);
     }
   };
diff --git a/producers/src/test/java/dagger/producers/ProducedTest.java b/producers/src/test/java/dagger/producers/ProducedTest.java
new file mode 100644
index 000000000..165e7301c
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/ProducedTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.testing.EqualsTester;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Produced}.
+ */
+@RunWith(JUnit4.class)
+public class ProducedTest {
+  @Test public void successfulProduced() throws ExecutionException {
+    Object o = new Object();
+    assertThat(Produced.successful(5).get()).isEqualTo(5);
+    assertThat(Produced.successful("monkey").get()).isEqualTo("monkey");
+    assertThat(Produced.successful(o).get()).isSameAs(o);
+  }
+
+  @Test public void failedProduced() {
+    RuntimeException cause = new RuntimeException("monkey");
+    try {
+      Produced.failed(cause).get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+
+  @Test public void producedEquivalence() {
+    RuntimeException e1 = new RuntimeException("monkey");
+    RuntimeException e2 = new CancellationException();
+    new EqualsTester()
+        .addEqualityGroup(Produced.successful(132435), Produced.successful(132435))
+        .addEqualityGroup(Produced.successful("hi"), Produced.successful("hi"))
+        .addEqualityGroup(Produced.failed(e1), Produced.failed(e1))
+        .addEqualityGroup(Produced.failed(e2), Produced.failed(e2))
+        .testEquals();
+  }
+}
