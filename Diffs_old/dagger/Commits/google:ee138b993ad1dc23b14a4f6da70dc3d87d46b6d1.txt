diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 46ced416f..2bdea0086 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -372,7 +372,7 @@ private void addBuildMethod(
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {
+      } else if (requiresAPassedInstance(elements, types, builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
             builderField,
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index e70b5df8d..303d05f8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -22,6 +22,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -112,10 +113,10 @@
    * binding keys:
    *
    * <dl>
-   * <dt>{@code T}
-   * <dd>{@code String t}
-   * <dt>{@code String}
-   * <dd>{@code String string}
+   *   <dt>{@code T}
+   *   <dd>{@code String t}
+   *   <dt>{@code String}
+   *   <dd>{@code String string}
    * </dl>
    *
    * <p>Note that the sets returned by this method when called on the same binding will be equal,
@@ -124,6 +125,7 @@
   /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
    * instances of Binding, because it really depends on the order of the binding's dependencies,
    * and two equal instances of Binding may have the same dependencies in a different order. */
+  @Memoized
   ImmutableList<FrameworkDependency> frameworkDependencies() {
     return ImmutableList.copyOf(
         dependencyAssociations()
@@ -158,6 +160,7 @@ static DependencyAssociation create(
    * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
    * distinction is not important, the entries can be merged into a single mapping.
    */
+  @Memoized
   ImmutableList<DependencyAssociation> dependencyAssociations() {
     BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
     ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
@@ -179,6 +182,7 @@ static DependencyAssociation create(
    * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
    * FrameworkDependency}.
    */
+  @Memoized
   ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
     ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
         ImmutableMap.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index cdc8d8f09..7b2038e5d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,6 +19,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Util.getUnimplementedMethods;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -109,7 +110,7 @@
     ExecutableElement buildMethod = null;
     Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
         LinkedHashMultimap.create();
-    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 1d19ee815..970db28dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,12 +27,14 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.getUnimplementedMethods;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
@@ -301,17 +303,8 @@ private static void addTransitiveModules(
         .build();
   }
 
-  // TODO(ronshapiro): convert this to use @Memoized
-  private ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType;
-
+  @Memoized
   ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
-    if (subcomponentsByBuilderType == null) {
-      subcomponentsByBuilderType = computeSubcomponentsByBuilderType();
-    }
-    return subcomponentsByBuilderType;
-  }
-
-  private ImmutableBiMap<TypeElement, ComponentDescriptor> computeSubcomponentsByBuilderType() {
     ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
         ImmutableBiMap.builder();
     for (ComponentDescriptor subcomponent : subcomponents()) {
@@ -485,7 +478,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          Util.getUnimplementedMethods(elements, componentDefinitionType);
+          getUnimplementedMethods(elements, types, componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -631,7 +624,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.absent();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
       ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index eb4f9cdfd..2e70a9cef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -100,6 +100,7 @@ public SourceVersion getSupportedSourceVersion() {
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
             elements,
+            types,
             keyFactory,
             keyFormatter,
             methodSignatureFormatter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index bab73c9ea..bb90d0a46 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -190,6 +190,7 @@ protected void addFactoryMethods() {
   /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
-        graph.componentRequirements(), dependency -> requiresAPassedInstance(elements, dependency));
+        graph.componentRequirements(),
+        dependency -> requiresAPassedInstance(elements, types, dependency));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index c7b769f2b..279304d4f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -103,7 +103,8 @@
       DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
 
       ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
-      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+      for (ExecutableElement method :
+          getLocalAndInheritedMethods(interfaceElement, types, elements)) {
         if (!method.getEnclosingElement().equals(objectElement)) {
           ExecutableType methodType =
               MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index 74fe9a1fd..48c81f53a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -36,6 +36,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
@@ -43,6 +44,7 @@
  */
 final class MultibindingsValidator {
   private final Elements elements;
+  private final Types types;
   private final Key.Factory keyFactory;
   private final KeyFormatter keyFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -51,11 +53,13 @@
 
   MultibindingsValidator(
       Elements elements,
+      Types types,
       Key.Factory keyFactory,
       KeyFormatter keyFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       MultibindingsMethodValidator multibindingsMethodValidator) {
     this.elements = elements;
+    this.types = types;
     this.keyFactory = keyFactory;
     this.keyFormatter = keyFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -82,7 +86,8 @@
 
     ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
         ImmutableListMultimap.builder();
-    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+    for (ExecutableElement method :
+        getLocalAndInheritedMethods(multibindingsType, types, elements)) {
       // Skip methods in Object.
       if (method.getEnclosingElement().equals(objectElement)) {
         continue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 09c547d2c..c98e366d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -45,6 +45,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
@@ -54,9 +55,9 @@
    * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
    * within a component.
    */
-  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {
+  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
     ImmutableSet<ExecutableElement> methods =
-        MoreElements.getLocalAndInheritedMethods(typeElement, elements);
+        getLocalAndInheritedMethods(typeElement, types, elements);
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(ABSTRACT)
@@ -130,8 +131,8 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
   }
 
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, TypeElement type) {
-    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
+      Elements elements, Types types, TypeElement type) {
+    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
   }
diff --git a/pom.xml b/pom.xml
index 9da880a95..692b49b02 100644
--- a/pom.xml
+++ b/pom.xml
@@ -103,7 +103,7 @@
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
-        <version>0.7</version>
+        <version>0.8</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.factory</groupId>
@@ -118,7 +118,7 @@
       <dependency>
         <groupId>com.google.auto.value</groupId>
         <artifactId>auto-value</artifactId>
-        <version>1.3</version>
+        <version>1.4-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
