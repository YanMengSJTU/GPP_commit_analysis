diff --git a/compiler/pom.xml b/compiler/pom.xml
index 6b2990d91..0d8691a9d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -36,6 +36,10 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.auto</groupId>
+      <artifactId>auto-common</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
new file mode 100644
index 000000000..608b4c0a1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A utility class for working with {@link AnnotationMirror} instances.
+ *
+ * @author Gregory Kick
+ */
+final class AnnotationMirrors {
+  /**
+   * An alternative to {@link Element#getAnnotation} that returns an {@link AnnotationMirror} rather
+   * than the weird, half-implementation returned by that method.
+   */
+  static Optional<AnnotationMirror> getAnnotationMirror(Element element,
+      Class<? extends Annotation> annotationType) {
+    String annotationName = annotationType.getName();
+    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
+      if (MoreElements.asType(annotationMirror.getAnnotationType().asElement())
+          .getQualifiedName().contentEquals(annotationName)) {
+        return Optional.of(annotationMirror);
+      }
+    }
+    return Optional.absent();
+  }
+
+  /**
+   * Takes a {@link Map} like that returned from {@link Elements#getElementValuesWithDefaults} and
+   * key it by the member name rather than the {@link ExecutableElement}.
+   */
+  static ImmutableMap<String, AnnotationValue> simplifyAnnotationValueMap(
+      Map<? extends ExecutableElement, ? extends AnnotationValue> annotationValueMap) {
+    ImmutableMap.Builder<String, AnnotationValue> builder = ImmutableMap.builder();
+    for (Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
+        : annotationValueMap.entrySet()) {
+      builder.put(entry.getKey().getSimpleName().toString(), entry.getValue());
+    }
+    return builder.build();
+  }
+
+  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(Elements elements,
+      AnnotationMirror annotationMirror, String attributeName) {
+    checkNotNull(annotationMirror);
+    checkNotNull(attributeName);
+    ImmutableMap<String, AnnotationValue> valueMap =
+        simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
+    ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
+    @SuppressWarnings("unchecked")
+    List<? extends AnnotationValue> typeValues =
+        (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
+    for (AnnotationValue typeValue : typeValues) {
+      builder.add((TypeMirror) typeValue.getValue());
+    }
+    return builder.build();
+  }
+
+  private AnnotationMirrors() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 4481739ef..8296341ce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 
-import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -33,7 +32,7 @@
  * @since 2.0
  */
 abstract class Binding {
-  /** The field or method annotated with {@link Inject}. */
+  /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
   /** The type enclosing the binding {@link #bindingElement()}. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
new file mode 100644
index 000000000..3080bea69
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Deque;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Queue;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * The logical representation of a {@link Component} definition.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ComponentDescriptor {
+  ComponentDescriptor() {}
+
+  /**
+   * The type (interface or abstract class) that defines the component. This is the element to which
+   * the {@link Component} annotation was applied.
+   */
+  abstract TypeElement componentDefinitionType();
+
+  /**
+   * The set of {@linkplain DependencyRequest dependency requests} representing  the provision
+   * methods in the component definition.  To access the method element itself, use
+   * {@link DependencyRequest#requestElement()}.
+   */
+  abstract ImmutableSet<DependencyRequest> provisionRequests();
+
+  /**
+   * The set of {@linkplain DependencyRequest dependency requests} representing the members
+   * injection methods in the component definition.  To access the method element itself, use
+   * {@link DependencyRequest#requestElement()}.
+   */
+  abstract ImmutableSet<DependencyRequest> membersInjectionRequests();
+
+  /**
+   * The total set of modules (those declared in {@link Component#modules} and their transitive
+   * dependencies) required to construct the object graph declared by the component.
+   */
+  abstract ImmutableSet<TypeElement> moduleDependencies();
+
+  /**
+   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that represents the full
+   * adjacency matrix for the object graph.
+   */
+  abstract ImmutableMap<Key, ProvisionBinding> resolvedBindings();
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final InjectBindingRegistry injectBindingRegistry;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, InjectBindingRegistry injectBindingRegistry,
+        ProvisionBinding.Factory provisionBindingFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.injectBindingRegistry = injectBindingRegistry;
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
+      Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+      LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
+      for (TypeElement moduleElement = moduleQueue.poll();
+          moduleElement != null;
+          moduleElement = moduleQueue.poll()) {
+        moduleElements.add(moduleElement);
+        AnnotationMirror moduleMirror =
+            getAnnotationMirror(moduleElement, Module.class).get();
+        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
+            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror));
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+      return ImmutableSet.copyOf(moduleElements);
+    }
+
+    ComponentDescriptor create(TypeElement componentDefinitionType) {
+      AnnotationMirror componentMirror =
+          getAnnotationMirror(componentDefinitionType, Component.class).get();
+      ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentModules(elements, componentMirror));
+      ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
+
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> bindingIndexBuilder =
+          ImmutableSetMultimap.builder();
+
+      for (TypeElement module : transitiveModules) {
+        // traverse the modules, collect the bindings
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(module));
+        for (ExecutableElement moduleMethod : moduleMethods) {
+          if (moduleMethod.getAnnotation(Provides.class) != null) {
+            ProvisionBinding providesMethodBinding =
+                provisionBindingFactory.forProvidesMethod(moduleMethod);
+            bindingIndexBuilder.put(providesMethodBinding.providedKey(), providesMethodBinding);
+          }
+        }
+      }
+
+      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
+
+      // TODO(gak): coalesce contributing bindings
+
+      ImmutableSet.Builder<DependencyRequest> provisionRequestsBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<DependencyRequest> membersInjectionRequestsBuilder =
+          ImmutableSet.builder();
+
+      Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
+
+      for (ExecutableElement componentMethod
+          : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
+        if (componentMethod.getModifiers().contains(ABSTRACT)) {
+          List<? extends VariableElement> parameters = componentMethod.getParameters();
+          switch (parameters.size()) {
+            case 0:
+              // provision method
+              DependencyRequest provisionRequest =
+                  dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
+              provisionRequestsBuilder.add(provisionRequest);
+              requestsToResolve.addLast(provisionRequest);
+              break;
+            case 1:
+              // members injection method
+              membersInjectionRequestsBuilder.add(
+                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+              break;
+            default:
+              throw new IllegalStateException();
+          }
+        }
+      }
+
+      LinkedHashMap<Key, ProvisionBinding> resolvedBindings =
+          new LinkedHashMap<Key, ProvisionBinding>();
+
+      for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
+          requestToResolve != null;
+          requestToResolve = requestsToResolve.pollLast()) {
+        Key key = requestToResolve.key();
+        if (!resolvedBindings.containsKey(key)) {
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
+          if (explicitBindingsForKey.isEmpty()) {
+            Optional<ProvisionBinding> injectBinding =
+                injectBindingRegistry.getBindingForKey(key);
+            if (injectBinding.isPresent()) {
+              requestsToResolve.addAll(injectBinding.get().dependencies());
+              resolvedBindings.put(key, injectBinding.get());
+            } else {
+              // uh oh
+            }
+          } else {
+            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+              requestsToResolve.addAll(explicitBinding.dependencies());
+            }
+            resolvedBindings.put(key, Iterables.getOnlyElement(explicitBindingsForKey));
+          }
+        }
+      }
+
+      return new AutoValue_ComponentDescriptor(
+          componentDefinitionType,
+          provisionRequestsBuilder.build(),
+          membersInjectionRequestsBuilder.build(),
+          moduleTypes,
+          ImmutableMap.copyOf(resolvedBindings));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
new file mode 100644
index 000000000..9aa5220a6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static dagger.internal.codegen.ProvisionBinding.Type.PROVIDES;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.Collections2;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Component;
+
+import java.io.IOException;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates the implementation of the abstract types annotated with {@link Component}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  ComponentGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ComponentDescriptor input) {
+    ClassName componentDefinitionClassName =
+        ClassName.fromTypeElement(input.componentDefinitionType());
+    return componentDefinitionClassName.peerNamed(
+        "Dagger_" + componentDefinitionClassName.simpleName());
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ComponentDescriptor input) {
+    return ImmutableSet.of(input.componentDefinitionType());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ComponentDescriptor input) {
+    return Optional.of(input.componentDefinitionType());
+  }
+
+  @Override
+  void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input)
+      throws IOException {
+    writer.emitPackage(componentName.packageName());
+
+    writeImports(writer, componentName, input.provisionRequests(),
+        input.resolvedBindings().keySet());
+
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
+    writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
+        input.componentDefinitionType().getQualifiedName().toString());
+
+    ImmutableMap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
+
+    ImmutableBiMap<Key, String> providerNames = generateProviderNamesForBindings(resolvedBindings);
+
+    ImmutableBiMap<TypeElement, String> moduleNames =
+        ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
+            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
+            new Function<TypeElement, String>() {
+              @Override
+              public String apply(TypeElement input) {
+                return input.getSimpleName().toString();
+              }
+            })));
+
+    writeModuleFields(writer, moduleNames);
+    writeProviderFields(writer, providerNames);
+
+    writeConstructor(writer, resolvedBindings, providerNames, moduleNames);
+
+    writeProvisionMethods(writer, input.provisionRequests(), providerNames);
+
+    writer.endType();
+  }
+
+  private void writeImports(JavaWriter writer, ClassName factoryClassName,
+      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableSet<Key> requiredKeys) throws IOException {
+    ImmutableSortedSet.Builder<ClassName> importsBuilder =
+        ImmutableSortedSet.<ClassName>naturalOrder()
+            .addAll(collectImportsFromDependencies(factoryClassName, provisionRequests))
+            .add(ClassName.fromClass(Generated.class))
+            .add(ClassName.fromClass(Provider.class));
+    for (Key requiredKey : requiredKeys) {
+      for (TypeElement referencedType : MoreTypes.referencedTypes(requiredKey.type())) {
+        ClassName className = ClassName.fromTypeElement(referencedType);
+        if (!className.packageName().equals("java.lang")
+            && !className.packageName().equals(factoryClassName.packageName()))
+          importsBuilder.add(className);
+      }
+    }
+
+    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
+        .emitEmptyLine();
+  }
+
+  private void writeModuleFields(JavaWriter writer,
+      ImmutableBiMap<TypeElement, String> moduleDependencies) throws IOException {
+    for (Entry<TypeElement, String> entry : moduleDependencies.entrySet()) {
+      writer.emitField(entry.getKey().getQualifiedName().toString(), entry.getValue(),
+          EnumSet.of(PRIVATE, FINAL));
+    }
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(final JavaWriter writer,
+      Map<Key, ProvisionBinding> resolvedBindings,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<TypeElement, String> moduleNames)
+          throws IOException {
+    Map<String, String> variableMap =
+        Maps.transformValues(moduleNames.inverse(), new Function<TypeElement, String>() {
+      @Override
+      public String apply(TypeElement input) {
+        return writer.compressType(input.getQualifiedName().toString());
+      }
+    });
+
+    writer.beginConstructor(EnumSet.of(PUBLIC), flattenVariableMap(variableMap),
+        ImmutableList.<String>of());
+    for (String variableName : variableMap.keySet()) {
+      writer.beginControlFlow("if (%s == null)", variableName)
+          .emitStatement("throw new NullPointerException(\"%s\")", variableName)
+          .endControlFlow();
+      writer.emitStatement("this.%1$s = %1$s", variableName);
+    }
+
+    for (Entry<String, Key> providerFieldEntry
+        : Lists.reverse(providerNames.inverse().entrySet().asList())) {
+      ProvisionBinding binding = resolvedBindings.get(providerFieldEntry.getValue());
+      List<String> parameters =
+          Lists.newArrayListWithCapacity(binding.dependenciesByKey().size() + 1);
+      if (binding.type().equals(PROVIDES)) {
+        parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+      }
+      FluentIterable.from(binding.dependenciesByKey().keySet())
+          .transform(Functions.forMap(providerNames))
+          .copyInto(parameters);
+      writer.emitStatement("this.%s = new %s(%s)",
+          providerFieldEntry.getKey(),
+          writer.compressType(
+              factoryNameForProvisionBinding(binding)
+                  .toString()),
+          Joiner.on(", ").join(parameters));
+    }
+
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeProvisionMethods(JavaWriter writer,
+      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableBiMap<Key, String> providerNames) throws IOException {
+    for (DependencyRequest provisionRequest : provisionRequests) {
+      ExecutableElement requestElement = (ExecutableElement) provisionRequest.requestElement();
+      writer.emitAnnotation(Override.class)
+          .beginMethod(Util.typeToString(requestElement.getReturnType()),
+              requestElement.getSimpleName().toString(),
+              Sets.difference(requestElement.getModifiers(), EnumSet.of(ABSTRACT)));
+
+      String providerName = providerNames.get(provisionRequest.key());
+
+      // look up the provider in the Key->name map and invoke.  Done.
+      writer.emitStatement("return "
+          + providerUsageStatement(providerName, provisionRequest.kind()));
+      writer.endMethod();
+    }
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
new file mode 100644
index 000000000..11fd1a368
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.SourceVersion.RELEASE_6;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Inject;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * The annotation processor responsible for generating the classes that drive the Dagger 2.0
+ * implementation.
+ *
+ * TODO(gak): give this some better documentation
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@SupportedSourceVersion(RELEASE_6)
+public final class ComponentProcessor extends AbstractProcessor {
+  private ImmutableList<ProcessingStep> processingSteps;
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of(
+        Component.class.getName(),
+        Inject.class.getName(),
+        Module.class.getName(),
+        Provides.class.getName());
+  }
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+
+    Messager messager = processingEnv.getMessager();
+    Types types = processingEnv.getTypeUtils();
+    Elements elements = processingEnv.getElementUtils();
+    Filer filer = processingEnv.getFiler();
+
+    InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
+    ModuleValidator moduleValidator = new ModuleValidator();
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
+    ComponentValidator componentValidator = new ComponentValidator(elements);
+
+    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
+    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
+
+    Key.Factory keyFactory = new Key.Factory(types, elements);
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, types);
+    ProvisionBinding.Factory provisionBindingFactory =
+        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
+    MembersInjectionBinding.Factory methodInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    ComponentDescriptor.Factory componentDescriptorFactory =
+        new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
+            provisionBindingFactory, dependencyRequestFactory);
+
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, providerTypeRepository);
+    MembersInjectorGenerator membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, providerTypeRepository);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, providerTypeRepository);
+
+    this.processingSteps = ImmutableList.<ProcessingStep>of(
+        new InjectProcessingStep(
+            messager,
+            injectConstructorValidator,
+            injectFieldValidator,
+            injectMethodValidator,
+            provisionBindingFactory,
+            factoryGenerator,
+            methodInjectionBindingFactory,
+            membersInjectorGenerator,
+            injectBindingRegistry),
+        new ModuleProcesssingStep(
+            messager,
+            moduleValidator,
+            providesMethodValidator,
+            provisionBindingFactory,
+            factoryGenerator),
+        new ComponentProcesssingStep(
+            messager,
+            componentValidator,
+            componentDescriptorFactory,
+            componentGenerator));
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    for (ProcessingStep processingStep : processingSteps) {
+      processingStep.process(annotations, roundEnv);
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
new file mode 100644
index 000000000..9a2d4dfd5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+
+import dagger.Component;
+import dagger.internal.codegen.ComponentDescriptor.Factory;
+
+import java.util.Set;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * as part of the {@link ComponentProcessor}.
+ *
+ * @author Gregory Kick
+ */
+final class ComponentProcesssingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ComponentValidator componentValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final ComponentGenerator componentGenerator;
+
+  ComponentProcesssingStep(
+      Messager messager,
+      ComponentValidator componentValidator,
+      Factory componentDescriptorFactory,
+      ComponentGenerator componentGenerator) {
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    Set<? extends Element> componentElements = roundEnv.getElementsAnnotatedWith(Component.class);
+
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> report =
+          componentValidator.validate(componentTypeElement);
+      report.printMessagesTo(messager);
+
+      if (report.isClean()) {
+        try {
+          componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
+        } catch (SourceFileGenerationException e) {
+          e.printMessageTo(messager);
+        }
+      }
+    }
+
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
new file mode 100644
index 000000000..c28e21e02
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+
+import dagger.Component;
+import dagger.Module;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Performs superficial validation of the contract of the {@link Component} annotation.
+ *
+ * @author Gregory Kick
+ */
+// TODO(gak): this class does superficial component validation, but we need to do graph validation
+// as well
+final class ComponentValidator implements Validator<TypeElement> {
+  private final Elements elements;
+
+  ComponentValidator(Elements elements) {
+    this.elements = elements;
+  }
+
+  @Override
+  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addItem("@Component may only be applied to an interface or abstract class", subject);
+    }
+
+    AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
+    ImmutableList<TypeMirror> moduleTypes =
+        ConfigurationAnnotations.getComponentModules(elements, componentMirror);
+
+    // TODO(gak): make unused modules an error
+    for (TypeMirror moduleType: moduleTypes) {
+      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror e, Void p) {
+          builder.addItem(Util.typeToString(e) + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          checkState(t.getTypeArguments().isEmpty());
+          TypeElement moduleElement = MoreElements.asType(t.asElement());
+          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()) {
+            builder.addItem(moduleElement.getQualifiedName()
+                + " is listed as a module, but is not annotated with @Module", subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
new file mode 100644
index 000000000..150dce892
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
+
+import com.google.common.collect.ImmutableList;
+
+import dagger.Component;
+import dagger.Module;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
+ * and {@link Module}).
+ *
+ * @author Gregory Kick
+ */
+final class ConfigurationAnnotations {
+  private static final String MODULES_ATTRIBUTE = "modules";
+
+  static ImmutableList<TypeMirror> getComponentModules(Elements elements,
+      AnnotationMirror componentAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(componentAnnotation);
+    return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
+  }
+
+  private static final String INCLUDES_ATTRIBUTE = "includes";
+
+  static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
+      AnnotationMirror moduleAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(moduleAnnotation);
+    return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
+  }
+
+  private ConfigurationAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index e44e6b03f..0cb323c17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.auto.value.AutoValue;
@@ -25,6 +26,7 @@
 import com.google.common.collect.Iterables;
 
 import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.Provides;
 
 import java.util.List;
@@ -32,6 +34,8 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -60,7 +64,7 @@
 
   abstract Kind kind();
   abstract Key key();
-  abstract VariableElement requestElement();
+  abstract Element requestElement();
 
   static final class Factory {
     private final Elements elements;
@@ -71,35 +75,60 @@
       this.types = types;
     }
 
-    ImmutableSet<DependencyRequest> forVariables(List<? extends VariableElement> variables) {
+    ImmutableSet<DependencyRequest> forRequiredVariables(
+        List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
             @Override public DependencyRequest apply(VariableElement input) {
-              return forVariable(input);
+              return forRequiredVariable(input);
             }
           })
           .toSet();
     }
 
-    DependencyRequest forVariable(VariableElement variableElement) {
+    DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, type, qualifier);
+    }
+
+    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
+      checkNotNull(provisionMethod);
+      TypeMirror type = provisionMethod.getReturnType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
+      return newDependencyRequest(provisionMethod, type, qualifier);
+    }
+
+    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
+      checkNotNull(membersInjectionMethod);
+      DeclaredType membersInjectorType = types.getDeclaredType(
+          elements.getTypeElement(MembersInjector.class.getCanonicalName()),
+          Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType());
+      // this is where we need to wrap it in a MembersInjector
+      Optional<AnnotationMirror> qualifier =
+          InjectionAnnotations.getQualifier(membersInjectionMethod);
+      checkArgument(!qualifier.isPresent());
+      return newDependencyRequest(membersInjectionMethod, membersInjectorType, qualifier);
+    }
+
+    private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
+        Optional<AnnotationMirror> qualifier) {
       if (elements.getTypeElement(Provider.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType providerType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.PROVIDER,
             Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
-            variableElement);
+            requestElement);
       } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType lazyType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.LAZY,
             Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
-            variableElement);
+            requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
-            variableElement);
+            requestElement);
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 3b4cb81e9..c43b6bf64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,19 +15,18 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.ProvisionBinding.Type.PROVIDES;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
 import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
@@ -53,10 +52,8 @@
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor6;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -75,25 +72,7 @@
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    TypeElement enclosingTypeElement = binding.enclosingType();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    String factoryPrefix = binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-      @Override protected String defaultAction(Element e, Void p) {
-        throw new IllegalStateException();
-      }
-
-      @Override
-      public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-        return "";
-      }
-
-      @Override
-      public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, e.getSimpleName().toString());
-      }
-    }, null);
-    return enclosingClassName.peerNamed(
-        enclosingClassName.simpleName() + "$$" + factoryPrefix + "Factory");
+    return factoryNameForProvisionBinding(binding);
   }
 
   @Override
@@ -116,16 +95,16 @@ void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding bindi
 
     writeImports(writer, factoryClassName, binding, providedType);
 
-    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
         .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
             type(Factory.class, Util.typeToString(binding.providedKey().type())));
 
     final ImmutableBiMap<Key, String> providerNames =
-        generateProviderNames(ImmutableList.of(binding));
+        generateProviderNamesForDependencies(binding.dependencies());
 
     ImmutableMap.Builder<String, String> variableMapBuilder =
         new ImmutableMap.Builder<String, String>();
-    if (binding.bindingElement().getKind().equals(METHOD)) {
+    if (binding.type().equals(PROVIDES)) {
       variableMapBuilder.put("module", binding.enclosingType().getQualifiedName().toString());
     }
     if (binding.requiresMemberInjection()) {
@@ -138,7 +117,7 @@ void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding bindi
     if (binding.requiresMemberInjection()) {
       writeMembersInjectorField(writer, providedTypeString);
     }
-    if (binding.bindingElement().getKind().equals(METHOD)) {
+    if (binding.type().equals(PROVIDES)) {
       writeModuleField(writer, binding.enclosingType());
     }
     writeProviderFields(writer, providerNames);
@@ -162,7 +141,7 @@ private void writeImports(JavaWriter writer, ClassName factoryClassName, Provisi
     if (binding.requiresMemberInjection()) {
       importsBuilder.add(ClassName.fromClass(MembersInjector.class));
     }
-    for (TypeElement referencedProvidedType : Mirrors.referencedTypes(providedType)) {
+    for (TypeElement referencedProvidedType : MoreTypes.referencedTypes(providedType)) {
       ClassName className = ClassName.fromTypeElement(referencedProvidedType);
       if (!className.packageName().equals("java.lang")
           && !className.packageName().equals(factoryClassName.packageName()))
@@ -222,7 +201,7 @@ private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
                 return providerUsageStatement(providerNames.get(input.key()), input.kind());
               }
             }));
-    if (binding.bindingElement().getKind().equals(METHOD)) {
+    if (binding.type().equals(PROVIDES)) {
       writer.emitStatement("return module.%s(%s)",
           binding.bindingElement().getSimpleName(), parameterString);
     } else if (binding.requiresMemberInjection()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
new file mode 100644
index 000000000..58875c286
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.Maps;
+
+import java.util.Map;
+
+import javax.inject.Inject;
+
+/**
+ * Maintains the collection of provision bindings from {@link Inject} constructors known to the
+ * annotation processor.
+ *
+ * @author Gregory Kick
+ */
+final class InjectBindingRegistry {
+  private final Map<Key, ProvisionBinding> bindingsByKey;
+
+  InjectBindingRegistry() {
+    this.bindingsByKey = Maps.newLinkedHashMap();
+  }
+
+  boolean isRegistered(Key key) {
+    return bindingsByKey.containsKey(key);
+  }
+
+  void registerBinding(ProvisionBinding binding) {
+    ProvisionBinding previousValue = bindingsByKey.put(binding.providedKey(), binding);
+    checkState(previousValue == null);
+  }
+
+  Optional<ProvisionBinding> getBindingForKey(Key key) {
+    return Optional.fromNullable(bindingsByKey.get(checkNotNull(key)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
similarity index 68%
rename from compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 94b89a828..9b40fa9b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -25,10 +25,7 @@
 import java.util.Collection;
 import java.util.Set;
 
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
@@ -37,8 +34,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementKindVisitor6;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
@@ -48,41 +43,36 @@
  * @since 2.0
  */
 @SupportedSourceVersion(RELEASE_6)
-public final class InjectProcessor extends AbstractProcessor {
-  private Messager messager;
-  private InjectConstructorValidator constructorValidator;
-  private InjectFieldValidator fieldValidator;
-  private InjectMethodValidator methodValidator;
-  private ProvisionBinding.Factory provisionBindingFactory;
-  private FactoryGenerator factoryWriter;
-  private MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private MembersInjectorGenerator membersInjectorWriter;
-
-  @Override
-  public synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
-    this.messager = processingEnv.getMessager();
-    this.constructorValidator = new InjectConstructorValidator();
-    this.fieldValidator = new InjectFieldValidator();
-    this.methodValidator = new InjectMethodValidator();
-    Filer filer = processingEnv.getFiler();
-    Elements elements = processingEnv.getElementUtils();
-    Types types = processingEnv.getTypeUtils();
-    Key.Factory keyFactory = new Key.Factory(types, elements);
-    DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types);
-    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
-    this.provisionBindingFactory =
-        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
-    this.factoryWriter = new FactoryGenerator(filer, providerTypeRepository);
-    this.membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(dependencyRequestFactory);
-    this.membersInjectorWriter = new MembersInjectorGenerator(filer, providerTypeRepository);
-  }
-
-  @Override
-  public Set<String> getSupportedAnnotationTypes() {
-    return ImmutableSet.of(Inject.class.getName());
+public final class InjectProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final InjectConstructorValidator constructorValidator;
+  private final InjectFieldValidator fieldValidator;
+  private final InjectMethodValidator methodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final MembersInjectorGenerator membersInjectorWriter;
+  private final InjectBindingRegistry factoryRegistrar;
+
+
+  InjectProcessingStep(Messager messager,
+      InjectConstructorValidator constructorValidator,
+      InjectFieldValidator fieldValidator,
+      InjectMethodValidator methodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      MembersInjectorGenerator membersInjectorWriter,
+      InjectBindingRegistry factoryRegistrar) {
+    this.messager = messager;
+    this.constructorValidator = constructorValidator;
+    this.fieldValidator = fieldValidator;
+    this.methodValidator = methodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.membersInjectorWriter = membersInjectorWriter;
+    this.factoryRegistrar = factoryRegistrar;
   }
 
   @Override
@@ -156,7 +146,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
     for (ProvisionBinding binding : provisions.build()) {
       try {
-        factoryWriter.generate(binding);
+        factoryGenerator.generate(binding);
+        factoryRegistrar.registerBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 2e2ff9aa1..f7ab2aa23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -53,7 +53,7 @@
 
   /**
    * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
-   * logical equality, so we use {@link Mirrors#equivalence()} for this object.
+   * logical equality, so we use {@link MoreTypes#equivalence()} for this object.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
@@ -71,11 +71,12 @@ public String toString() {
   }
 
   static Key create(TypeMirror type) {
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+    return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+        MoreTypes.equivalence().wrap(type));
   }
 
   static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
+    return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(type));
   }
 
   static final class Factory {
@@ -105,28 +106,20 @@ Key forProvidesMethod(ExecutableElement e) {
       Optional<AnnotationMirror> qualifier = getQualifier(e);
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(setType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(setType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
         default:
           throw new AssertionError();
       }
     }
 
-    Key forComponentMethod(ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      checkArgument(e.getParameters().isEmpty());
-      return new AutoValue_Key(getQualifier(e),
-          Mirrors.equivalence().wrap(normalize(e.getReturnType())));
-    }
-
     Key forInjectConstructor(ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(CONSTRUCTOR));
@@ -134,8 +127,7 @@ Key forInjectConstructor(ExecutableElement e) {
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
       return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
-          Mirrors.equivalence().wrap(type));
+          MoreTypes.equivalence().wrap(type));
     }
   }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index c92a133cc..7008c91a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -81,7 +81,7 @@ MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
       checkArgument(methodElement.getKind().equals(METHOD));
       checkArgument(methodElement.getAnnotation(Inject.class) != null);
       return new AutoValue_MembersInjectionBinding(methodElement,
-          dependencyRequestFactory.forVariables(methodElement.getParameters()));
+          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
     }
 
     /** Returns the field injection binding for a field annotated with {@link Inject}. */
@@ -90,7 +90,7 @@ MembersInjectionBinding forInjectField(VariableElement fieldElement) {
       checkArgument(fieldElement.getKind().equals(FIELD));
       checkArgument(fieldElement.getAnnotation(Inject.class) != null);
       return new AutoValue_MembersInjectionBinding(fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forVariable(fieldElement)));
+          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index bd9238e98..a92a4adb2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,6 +15,17 @@
  */
 package dagger.internal.codegen;
 
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
@@ -43,17 +54,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.VariableElement;
 
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNames;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
  *
@@ -122,12 +122,13 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
     String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
     // @Generated("dagger.internal.codegen.InjectProcessor")
     // public final class Blah$$MembersInjector implements MembersInjector<Blah>
-    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
         .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
             membersInjectorType);
 
 
-    final ImmutableBiMap<Key, String> providerNames = generateProviderNames(descriptor.bindings());
+    final ImmutableBiMap<Key, String> providerNames =
+        generateProviderNamesForDependencies(dependencies);
 
     // Add the fields
     writeProviderFields(writer, providerNames);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
similarity index 73%
rename from compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
index 3e3272bfb..a4a8073a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
@@ -29,16 +29,12 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Module}
@@ -47,32 +43,24 @@
  * @author Gregory Kick
  * @since 2.0
  */
-// TODO(gak): fold this into the inject processor when we start writing components
-public final class ModuleProcessor extends AbstractProcessor {
-  private Messager messager;
-  private ModuleValidator moduleValidator;
-  private ProvidesMethodValidator providesMethodValidator;
-  private ProvisionBinding.Factory provisionBindingFactory;
-  private FactoryGenerator moduleFactoriesGenerator;
+public final class ModuleProcesssingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ModuleValidator moduleValidator;
+  private final ProvidesMethodValidator providesMethodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
 
-  @Override
-  public synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
-    this.messager = processingEnv.getMessager();
-    this.moduleValidator = new ModuleValidator();
-    Elements elements = processingEnv.getElementUtils();
-    this.providesMethodValidator = new ProvidesMethodValidator(elements);
-    Types types = processingEnv.getTypeUtils();
-    this.provisionBindingFactory = new ProvisionBinding.Factory(
-        new Key.Factory(types, elements),
-        new DependencyRequest.Factory(elements, types));
-    this.moduleFactoriesGenerator = new FactoryGenerator(processingEnv.getFiler(),
-        new ProviderTypeRepository(elements, types));
-  }
-
-  @Override
-  public Set<String> getSupportedAnnotationTypes() {
-    return ImmutableSet.of(Module.class.getName(), Provides.class.getName());
+  ModuleProcesssingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      ProvidesMethodValidator providesMethodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator) {
+    this.messager = messager;
+    this.moduleValidator = moduleValidator;
+    this.providesMethodValidator = providesMethodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
   }
 
   @Override
@@ -125,7 +113,7 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
 
           try {
             for (ProvisionBinding binding : bindings) {
-              moduleFactoriesGenerator.generate(binding);
+              factoryGenerator.generate(binding);
             }
           } catch (SourceFileGenerationException e) {
             e.printMessageTo(messager);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
similarity index 89%
rename from compiler/src/main/java/dagger/internal/codegen/Mirrors.java
rename to compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
index 5e1317552..916bed5bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -30,6 +31,7 @@
 import java.util.Iterator;
 import java.util.List;
 
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -39,7 +41,9 @@
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
 /**
  * Utilities related to {@link TypeMirror} instances.
@@ -47,16 +51,16 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class Mirrors {
+final class MoreTypes {
   private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
     @Override
     protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
-      return Mirrors.equal(a, b);
+      return MoreTypes.equal(a, b);
     }
 
     @Override
     protected int doHash(TypeMirror t) {
-      return Mirrors.hash(t);
+      return MoreTypes.hash(t);
     }
   };
 
@@ -295,5 +299,33 @@ public Void visitWildcard(WildcardType t, Builder<TypeElement> p) {
     return elements.build();
   }
 
-  private Mirrors() {}
+  static TypeElement asTypeElement(Types types, TypeMirror mirror) {
+    checkNotNull(types);
+    checkNotNull(mirror);
+    Element element = types.asElement(mirror);
+    checkArgument(element != null);
+    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override
+      protected TypeElement defaultAction(Element e, Void p) {
+        throw new IllegalArgumentException();
+      }
+
+      @Override public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+    }, null);
+  }
+
+  static ImmutableSet<TypeElement> asTypeElements(Types types,
+      Iterable<? extends TypeMirror> mirrors) {
+    checkNotNull(types);
+    checkNotNull(mirrors);
+    ImmutableSet.Builder<TypeElement> builder = ImmutableSet.builder();
+    for (TypeMirror mirror : mirrors) {
+      builder.add(asTypeElement(types, mirror));
+    }
+    return builder.build();
+  }
+
+  private MoreTypes() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
new file mode 100644
index 000000000..50d2bcf6c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.Set;
+
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * This represents work to be done in an annotation processor that must run with other steps due to
+ * shared state between them or a particular execution order.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+interface ProcessingStep {
+  boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 3d9c2b676..86d0ef356 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -47,6 +47,14 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends Binding {
+  enum Type {
+    INJECT,
+    PROVIDES
+  }
+
+  /** The type of binding ({@link Inject} or {@link Provides}). */
+  abstract Type type();
+
   /** The {@link Key} that is provided by this binding. */
   abstract Key providedKey();
 
@@ -77,8 +85,10 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkArgument(constructorElement.getAnnotation(Inject.class) != null);
       Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
-      return new AutoValue_ProvisionBinding(constructorElement,
-          keyRequestFactory.forVariables(constructorElement.getParameters()),
+      return new AutoValue_ProvisionBinding(
+          constructorElement,
+          keyRequestFactory.forRequiredVariables(constructorElement.getParameters()),
+          Type.INJECT,
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           requiresMemeberInjection(
@@ -104,8 +114,10 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkArgument(providesMethod.getKind().equals(METHOD));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      return new AutoValue_ProvisionBinding(providesMethod,
-          keyRequestFactory.forVariables(providesMethod.getParameters()),
+      return new AutoValue_ProvisionBinding(
+          providesMethod,
+          keyRequestFactory.forRequiredVariables(providesMethod.getParameters()),
+          Type.PROVIDES,
           keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
           false,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 164499fc8..4ce42b4ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -45,7 +45,7 @@
     this.filer = checkNotNull(filer);
   }
 
-  final void generate(T input) throws SourceFileGenerationException {
+  final ClassName generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
     JavaFileObject file = null;
@@ -58,6 +58,7 @@ final void generate(T input) throws SourceFileGenerationException {
       boolean thrownWriting = false;
       try {
         write(generatedTypeName, writer, input);
+        return generatedTypeName;
       } catch (Exception e) {
         thrownWriting = true;
         throw new SourceFileGenerationException(generatedTypeName, e,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 55d4ece15..798fe22e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -42,7 +42,10 @@
 import java.util.Map.Entry;
 
 import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementKindVisitor6;
 
 /**
  * Utilities for generating files.
@@ -74,7 +77,8 @@
     ImmutableSet<String> packagesToSkip  =
         ImmutableSet.of("java.lang", topLevelClassName.packageName());
     for (DependencyRequest dependency : dependencies) {
-      ImmutableSet<TypeElement> referencedTypes = Mirrors.referencedTypes(dependency.key().type());
+      ImmutableSet<TypeElement> referencedTypes =
+          MoreTypes.referencedTypes(dependency.key().type());
       switch (dependency.kind()) {
         case LAZY:
           builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
@@ -132,15 +136,13 @@
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    * provider.
    */
-  static ImmutableBiMap<Key, String> generateProviderNames(
-      Iterable<? extends Binding> bindings) {
+  static ImmutableBiMap<Key, String> generateProviderNamesForDependencies(
+      Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
         new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
             .orderValuesBy(DEPENDENCY_ORDERING);
-    for (Binding binding : bindings) {
-      for (DependencyRequest dependency : binding.dependencies()) {
-        dependenciesByKeyBuilder.put(dependency.key(), dependency);
-      }
+    for (DependencyRequest dependency : dependencies) {
+      dependenciesByKeyBuilder.put(dependency.key(), dependency);
     }
     ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
@@ -183,6 +185,31 @@
     return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
   }
 
+  // TODO(gak): this needs to suck less
+  static ImmutableBiMap<Key, String> generateProviderNamesForBindings(
+      Map<Key, ProvisionBinding> bindings) {
+    BiMap<Key, String> providerNames = HashBiMap.create(bindings.size());
+    for (Entry<Key, ProvisionBinding> entry : bindings.entrySet()) {
+      // collect together all of the names that we would want to call the provider
+      String bindingElementName = entry.getValue().bindingElement().accept(
+          new ElementKindVisitor6<String, Void>() {
+            @Override
+            public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+              return CaseFormat.UPPER_CAMEL
+                  .to(CaseFormat.LOWER_CAMEL, e.getEnclosingElement().getSimpleName().toString());
+            }
+
+            @Override
+            public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+              return e.getSimpleName().toString();
+            }
+          }, null) + "Provider";
+      providerNames.put(entry.getKey(), bindingElementName);
+    }
+    // return the map so that it is sorted by name
+    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+  }
+
   static String providerUsageStatement(String providerName,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
@@ -198,5 +225,27 @@ static String providerUsageStatement(String providerName,
     }
   }
 
+  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
+    TypeElement enclosingTypeElement = binding.enclosingType();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    String factoryPrefix = binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+      @Override protected String defaultAction(Element e, Void p) {
+        throw new IllegalStateException();
+      }
+
+      @Override
+      public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+        return "";
+      }
+
+      @Override
+      public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, e.getSimpleName().toString());
+      }
+    }, null);
+    return enclosingClassName.peerNamed(
+        enclosingClassName.simpleName() + "$$" + factoryPrefix + "Factory");
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
new file mode 100644
index 000000000..a0fe4b7f0
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ComponentProcessorTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "final class NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "@interface NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = Object.class)",
+        "interface NotAComponent {}");
+    ASSERT.about(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("module");
+  }
+
+  @Test public void simpleComponent() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
+        "  @Override public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "    return someInjectableTypeProvider;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentWithModule() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "interface B {}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides B b(C c) { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final TestModule testModule;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "",
+        "  public Dagger_TestComponent(TestModule testModule) {",
+        "    if (testModule == null) {",
+        "      throw new NullPointerException(\"testModule\");",
+        "    }",
+        "    this.testModule = testModule;",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "  }",
+        "",
+        "  @Override public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index d88c5512d..329e5dc48 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -81,7 +81,7 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
         .in(file).onLine(6);
   }
@@ -97,7 +97,7 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
   }
 
@@ -110,7 +110,7 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
         .in(file).onLine(6);
   }
@@ -124,7 +124,7 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS)
         .in(file).onLine(6);
   }
@@ -140,7 +140,7 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
         .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
   }
@@ -155,7 +155,7 @@
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the constructor
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
@@ -170,7 +170,7 @@
         "  @Inject MultipleScopeClass() {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
         .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
   }
@@ -184,7 +184,7 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -197,7 +197,7 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -211,7 +211,7 @@
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
         .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
   }
@@ -225,7 +225,7 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -238,7 +238,7 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -251,7 +251,7 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -265,7 +265,7 @@
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new InjectProcessor()).failsToCompile()
+        .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
@@ -292,7 +292,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class FieldInjection$$MembersInjector ",
         "    implements MembersInjector<FieldInjection> {",
         "",
@@ -312,7 +312,7 @@
         "    instance.stringProvider = stringProvider;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -341,7 +341,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class MethodInjection$$MembersInjector ",
         "    implements MembersInjector<MethodInjection> {",
         "",
@@ -362,7 +362,7 @@
         "        stringProvider);",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -389,7 +389,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class MixedMemberInjection$$MembersInjector ",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -414,7 +414,7 @@
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -436,7 +436,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class InjectConstructor$$Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -451,7 +451,7 @@
         "    return new InjectConstructor(sProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -476,7 +476,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class AllInjections$$Factory ",
         "    implements Factory<AllInjections> {",
         "",
@@ -505,7 +505,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "final class AllInjections$$MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -524,7 +524,7 @@
         "    instance.s(sProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedFactory, expectedMembersInjector);
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3b1d41ae6..f903d3050 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -97,9 +97,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod);
-    ASSERT.that(Mirrors.equivalence().wrap(key.qualifier().get().getAnnotationType()))
-        .isEqualTo(Mirrors.equivalence().wrap(qualifierElement.asType()));
-    ASSERT.that(key.wrappedType()).isEqualTo(Mirrors.equivalence().wrap(stringType));
+    ASSERT.that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+        .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
+    ASSERT.that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
   @Module(library = true)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index 7e7fa7503..bcc2b33fa 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -54,7 +54,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
   }
@@ -71,7 +71,7 @@
         "  @Provides abstract String provideString();",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
   }
@@ -90,7 +90,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_PRIVATE);
   }
@@ -109,7 +109,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_STATIC);
   }
@@ -126,7 +126,7 @@
         "  @Provides void provideNothing() {}",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
   }
@@ -145,7 +145,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
   }
@@ -168,7 +168,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
   }
@@ -191,7 +191,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
   }
@@ -214,7 +214,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
   }
@@ -238,7 +238,7 @@
         "import dagger.Factory;",
         "import javax.annotation.Generated;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -252,7 +252,7 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
@@ -305,7 +305,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -326,7 +326,7 @@
         "  }",
         "}");
     ASSERT.about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ModuleProcessor())
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
similarity index 90%
rename from compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
rename to compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
index bef6c228e..44757ec30 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
@@ -15,6 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.type.TypeKind.VOID;
+import static org.truth0.Truth.ASSERT;
+
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -22,10 +26,12 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.EquivalenceTester;
 import com.google.testing.compile.CompilationRule;
+
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -40,20 +46,14 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static javax.lang.model.type.TypeKind.NONE;
-import static javax.lang.model.type.TypeKind.VOID;
-import static org.truth0.Truth.ASSERT;
-
-/**
- * Tests {@link Mirrors}.
- */
 @RunWith(JUnit4.class)
-public class MirrorsTest {
+public class MoreTypesTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   @Test
@@ -68,7 +68,7 @@ public void equivalence() {
         types.getDeclaredType(mapElement, objectType, objectType);
     TypeMirror mapType = mapElement.asType();
     WildcardType wildcard = types.getWildcardType(null, null);
-    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(Mirrors.equivalence())
+    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(MoreTypes.equivalence())
         .addEquivalenceGroup(types.getNullType())
         .addEquivalenceGroup(types.getNoType(NONE))
         .addEquivalenceGroup(types.getNoType(VOID))
@@ -190,27 +190,27 @@ public static void b() throws RuntimeException {}
     TypeElement charSequenceElement =
         elements.getTypeElement(CharSequence.class.getCanonicalName());
 
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f1").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f1").asType()))
         .has().exactly(objectElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f2").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f2").asType()))
         .has().exactly(setElement, stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f3").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f3").asType()))
         .has().exactly(mapElement, stringElement, objectElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f4").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f4").asType()))
         .has().exactly(integerElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f5").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f5").asType()))
         .has().exactly(setElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f6").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f6").asType()))
         .has().exactly(setElement, charSequenceElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f7").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f7").asType()))
         .has().exactly(mapElement, stringElement, setElement, charSequenceElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f8").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f8").asType()))
         .has().exactly(stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f9").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f9").asType()))
         .has().exactly(stringElement);
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
-    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f12").asType()))
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
+    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f12").asType()))
         .has().exactly(setElement, stringElement);
   }
 
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index fc04dd606..dc4b62867 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -15,6 +15,11 @@
  */
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
@@ -51,6 +56,8 @@
  */
 // TODO(gak): add missing spec for @Scope
 // TODO(gak): add missing spec for component dependencies
+@Target(TYPE)
+@Documented
 public @interface Component {
   /**
    * A list of classes annotated with {@link Module} whose bindings are used to generate the
diff --git a/pom.xml b/pom.xml
index c08015be8..5bf001f76 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,8 +43,9 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.3.0</javawriter.version>
-    <guava.version>16.0.1</guava.version>
+    <javawriter.version>2.5.0</javawriter.version>
+    <auto.common.version>0.1</auto.common.version>
+    <guava.version>17.0</guava.version>
 
     <!-- Test Dependencies -->
     <compile-testing.version>0.5</compile-testing.version>
@@ -100,6 +101,11 @@
         <artifactId>guava-testlib</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.auto</groupId>
+        <artifactId>auto-common</artifactId>
+        <version>${auto.common.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
