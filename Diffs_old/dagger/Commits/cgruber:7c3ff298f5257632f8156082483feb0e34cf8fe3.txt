diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index e1636eabc..d000adebd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -469,7 +469,8 @@ private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
 
     // No field needed for unique contributions inherited from the parent.
-    if (resolvedBindings.isUniqueContribution() && resolvedBindings.ownedBindings().isEmpty()) {
+    if (resolvedBindings.isUniqueContribution()
+        && resolvedBindings.ownedContributionBindings().isEmpty()) {
       return;
     }
 
@@ -522,7 +523,7 @@ private void addField(ResolvedBindings resolvedBindings) {
     }
 
     if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-      ImmutableSet<? extends ContributionBinding> contributionBindings =
+      ImmutableSet<ContributionBinding> contributionBindings =
           resolvedBindings.contributionBindings();
       if (ContributionBinding.contributionTypeFor(contributionBindings).isMultibinding()) {
         // note that here we rely on the order of the resolved bindings being from parent to child
@@ -531,7 +532,7 @@ private void addField(ResolvedBindings resolvedBindings) {
         for (ContributionBinding contributionBinding : contributionBindings) {
           if (!contributionBinding.isSyntheticBinding()) {
             contributionNumber++;
-            if (resolvedBindings.ownedBindings().contains(contributionBinding)) {
+            if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
               FrameworkField contributionBindingField =
                   FrameworkField.createForSyntheticContributionBinding(
                       contributionNumber, contributionBinding);
@@ -576,11 +577,11 @@ private void addField(ResolvedBindings resolvedBindings) {
    * injector.
    */
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.bindings().size() != 1) {
-      return Optional.absent();
-    }
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
+        if (resolvedBindings.contributionBindings().size() != 1) {
+          return Optional.absent();
+        }
         ContributionBinding contributionBinding =
             getOnlyElement(resolvedBindings.contributionBindings());
         if (contributionBinding.contributionType().isMultibinding()
@@ -596,9 +597,10 @@ private void addField(ResolvedBindings resolvedBindings) {
         break;
 
       case MEMBERS_INJECTION:
-        if (getOnlyElement(resolvedBindings.membersInjectionBindings())
-            .injectionStrategy()
-            .equals(NO_OP)) {
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            resolvedBindings.membersInjectionBinding();
+        if (membersInjectionBinding.isPresent()
+            && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
           return Optional.of(
               staticMethodInvocationWithCast(
                   ClassName.fromClass(MembersInjectors.class),
@@ -850,7 +852,7 @@ private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBin
   private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    MembersInjectionBinding binding = getOnlyElement(resolvedBindings.membersInjectionBindings());
+    MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
     if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
       initializationSnippets.add(initializeDelegateFactories(binding));
       initializationSnippets.add(
@@ -1128,7 +1130,7 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
     return parameters.build();
   }
 
-  private Snippet initializeMapBinding(Set<? extends ContributionBinding> bindings) {
+  private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
     // Get type information from the first binding.
     ContributionBinding firstBinding = bindings.iterator().next();
     DeclaredType mapType = asDeclared(firstBinding.key().type());
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 525bfd28d..715b0e3c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -109,29 +109,33 @@
    * {@link ProductionComponent}.
    */
   ImmutableSet<TypeElement> componentRequirements() {
-    return SUBGRAPH_TRAVERSER.preOrderTraversal(this)
-        .transformAndConcat(new Function<BindingGraph, Iterable<ResolvedBindings>>() {
-          @Override
-          public Iterable<ResolvedBindings> apply(BindingGraph input) {
-            return input.resolvedBindings().values();
-          }
-        })
-        .transformAndConcat(new Function<ResolvedBindings, Set<? extends ContributionBinding>>() {
-          @Override
-          public Set<? extends ContributionBinding> apply(ResolvedBindings input) {
-            return (input.bindingKey().kind().equals(CONTRIBUTION))
-                ? input.contributionBindings()
-                : ImmutableSet.<ContributionBinding>of();
-          }
-        })
-        .transformAndConcat(new Function<ContributionBinding, Set<TypeElement>>() {
-          @Override
-          public Set<TypeElement> apply(ContributionBinding input) {
-            return input.bindingElement().getModifiers().contains(STATIC)
-                ? ImmutableSet.<TypeElement>of()
-                : input.contributedBy().asSet();
-          }
-        })
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transformAndConcat(
+            new Function<BindingGraph, Iterable<ResolvedBindings>>() {
+              @Override
+              public Iterable<ResolvedBindings> apply(BindingGraph input) {
+                return input.resolvedBindings().values();
+              }
+            })
+        .transformAndConcat(
+            new Function<ResolvedBindings, Set<ContributionBinding>>() {
+              @Override
+              public Set<ContributionBinding> apply(ResolvedBindings input) {
+                return (input.bindingKey().kind().equals(CONTRIBUTION))
+                    ? input.contributionBindings()
+                    : ImmutableSet.<ContributionBinding>of();
+              }
+            })
+        .transformAndConcat(
+            new Function<ContributionBinding, Set<TypeElement>>() {
+              @Override
+              public Set<TypeElement> apply(ContributionBinding input) {
+                return input.bindingElement().getModifiers().contains(STATIC)
+                    ? ImmutableSet.<TypeElement>of()
+                    : input.contributedBy().asSet();
+              }
+            })
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .append(componentDescriptor().executorDependency().asSet())
@@ -322,29 +326,24 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             if (!explicitBindingsForKey.isEmpty() || !explicitSetBindings.isEmpty()) {
               /* If there are any explicit bindings for this key, then combine those with any
                * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
-              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
-              ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding>
-                  inheritedBindings = ImmutableSetMultimap.builder();
+              ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> bindings =
+                  ImmutableSetMultimap.builder();
               for (ContributionBinding binding :
                   union(explicitBindingsForKey, union(explicitSetBindings, explicitMapBindings))) {
                 if (isResolvedInParent(request, binding)
                     && !shouldOwnParentBinding(request, binding)) {
-                  inheritedBindings.put(
-                      getOwningResolver(binding).get().componentDescriptor, binding);
+                  bindings.put(getOwningResolver(binding).get().componentDescriptor, binding);
                 } else {
-                  ownedBindings.add(binding);
+                  bindings.put(componentDescriptor, binding);
                 }
               }
-              return ResolvedBindings.create(
-                  bindingKey,
-                  componentDescriptor,
-                  ownedBindings.build(),
-                  inheritedBindings.build());
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey, componentDescriptor, bindings.build());
             } else if (any(explicitMapBindings, Binding.Type.PRODUCTION)) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Producer<V>>. */
-              return ResolvedBindings.create(
+              return ResolvedBindings.forContributionBindings(
                   bindingKey,
                   componentDescriptor,
                   productionBindingFactory.implicitMapOfProducerBinding(request));
@@ -352,7 +351,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Provider<V>>. */
-              return ResolvedBindings.create(
+              return ResolvedBindings.forContributionBindings(
                   bindingKey,
                   componentDescriptor,
                   provisionBindingFactory.implicitMapOfProviderBinding(request));
@@ -361,28 +360,23 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                * binding. */
               Optional<ProvisionBinding> provisionBinding =
                   injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-              if (provisionBinding.isPresent()
-                  && isResolvedInParent(request, provisionBinding.get())
-                  && !shouldOwnParentBinding(request, provisionBinding.get())) {
-                return ResolvedBindings.create(
-                    bindingKey,
-                    componentDescriptor,
-                    ImmutableSet.<Binding>of(),
-                    ImmutableSetMultimap.of(
-                        getOwningResolver(provisionBinding.get()).get().componentDescriptor,
-                        provisionBinding.get()));
-              } else {
-                return ResolvedBindings.create(
-                    bindingKey,
-                    componentDescriptor,
-                    provisionBinding.asSet(),
-                    ImmutableSetMultimap.<ComponentDescriptor, Binding>of());
-              }
+              ComponentDescriptor owningComponent =
+                  provisionBinding.isPresent()
+                          && isResolvedInParent(request, provisionBinding.get())
+                          && !shouldOwnParentBinding(request, provisionBinding.get())
+                      ? getOwningResolver(provisionBinding.get()).get().componentDescriptor
+                      : componentDescriptor;
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey,
+                  componentDescriptor,
+                  ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
+                      .putAll(owningComponent, provisionBinding.asSet())
+                      .build());
             }
 
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            return ResolvedBindings.create(
+            return ResolvedBindings.forMembersInjectionBinding(
                 bindingKey, componentDescriptor, rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 4c713bc60..5b61d06d2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -236,7 +236,7 @@ private boolean validateResolvedBinding(
 
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          ImmutableSet<? extends ContributionBinding> contributionBindings =
+          ImmutableSet<ContributionBinding> contributionBindings =
               resolvedBinding.contributionBindings();
           if (any(contributionBindings, Binding.Type.MEMBERS_INJECTION)) {
             throw new IllegalArgumentException(
@@ -253,8 +253,8 @@ private boolean validateResolvedBinding(
           if (contributionBindings.size() <= 1) {
             return true;
           }
-          ImmutableListMultimap<ContributionType, ? extends ContributionBinding>
-              contributionsByType = ContributionBinding.contributionTypesFor(contributionBindings);
+          ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
+              ContributionBinding.contributionTypesFor(contributionBindings);
           if (contributionsByType.keySet().size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
@@ -292,7 +292,7 @@ private boolean validateResolvedBinding(
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
-        DependencyRequest request, Set<? extends ContributionBinding> bindings) {
+        DependencyRequest request, Set<ContributionBinding> bindings) {
       if (request.isNullable()) {
         return true;
       }
@@ -324,9 +324,9 @@ private boolean validateNullability(
      * for the same map key.
      */
     private boolean hasDuplicateMapKeys(
-        Deque<ResolvedRequest> path, Set<? extends ContributionBinding> mapBindings) {
+        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
       boolean hasDuplicateMapKeys = false;
-      for (Collection<? extends ContributionBinding> mapBindingsForMapKey :
+      for (Collection<ContributionBinding> mapBindingsForMapKey :
           indexMapBindingsByMapKey(mapBindings).asMap().values()) {
         if (mapBindingsForMapKey.size() > 1) {
           hasDuplicateMapKeys = true;
@@ -341,8 +341,8 @@ private boolean hasDuplicateMapKeys(
      * {@link MapKey} annotation type.
      */
     private boolean hasInconsistentMapKeyAnnotationTypes(
-        Deque<ResolvedRequest> path, Set<? extends ContributionBinding> contributionBindings) {
-      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ? extends ContributionBinding>
+        Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
+      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
       if (mapBindingsByAnnotationType.keySet().size() > 1) {
         reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
@@ -782,7 +782,8 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
           Iterables.limit(resolvedBinding.contributionBindings(), DUPLICATE_SIZE_LIMIT)) {
         builder.append('\n').append(INDENT).append(contributionBindingFormatter.format(binding));
       }
-      int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
+      int numberOfOtherBindings =
+          resolvedBinding.contributionBindings().size() - DUPLICATE_SIZE_LIMIT;
       if (numberOfOtherBindings > 0) {
         builder.append('\n').append(INDENT)
             .append("and ").append(numberOfOtherBindings).append(" other");
@@ -799,7 +800,7 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ImmutableListMultimap<ContributionType, ? extends ContributionBinding> bindingsByType =
+      ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
           ContributionBinding.contributionTypesFor(resolvedBinding.contributionBindings());
       for (ContributionType type :
           Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
@@ -818,7 +819,7 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
     }
 
     private void reportDuplicateMapKeys(
-        Deque<ResolvedRequest> path, Collection<? extends ContributionBinding> mapBindings) {
+        Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
       appendBindings(builder, mapBindings, 1);
@@ -827,16 +828,14 @@ private void reportDuplicateMapKeys(
 
     private void reportInconsistentMapKeyAnnotations(
         Deque<ResolvedRequest> path,
-        Multimap<Equivalence.Wrapper<DeclaredType>, ? extends ContributionBinding>
+        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
             mapBindingsByAnnotationType) {
       StringBuilder builder =
           new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
-      for (Map.Entry<
-              Equivalence.Wrapper<DeclaredType>,
-              ? extends Collection<? extends ContributionBinding>>
-          entry : mapBindingsByAnnotationType.asMap().entrySet()) {
+      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+          mapBindingsByAnnotationType.asMap().entrySet()) {
         DeclaredType annotationType = entry.getKey().get();
-        Collection<? extends ContributionBinding> bindings = entry.getValue();
+        Collection<ContributionBinding> bindings = entry.getValue();
 
         builder
             .append('\n')
@@ -1068,7 +1067,7 @@ private String formatRootRequestKey(Deque<ResolvedRequest> path) {
   }
 
   private void appendBindings(
-      StringBuilder builder, Collection<? extends ContributionBinding> bindings, int indentLevel) {
+      StringBuilder builder, Collection<ContributionBinding> bindings, int indentLevel) {
     for (ContributionBinding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
       builder.append('\n');
       for (int i = 0; i < indentLevel; i++) {
@@ -1097,12 +1096,10 @@ private void appendBindings(
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
       BindingKey bindingKey = request.bindingKey();
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(
+          request,
           resolvedBindings == null
-              ? ResolvedBindings.create(bindingKey,
-                  graph.componentDescriptor(),
-                  ImmutableSet.<Binding>of(),
-                  ImmutableSetMultimap.<ComponentDescriptor, Binding>of())
+              ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
               : resolvedBindings);
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 01913e431..543064dff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -218,7 +218,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
    *
    * @throws IllegalArgumentException if the given bindings are not all of one type
    */
-  static ContributionType contributionTypeFor(Iterable<? extends ContributionBinding> bindings) {
+  static ContributionType contributionTypeFor(Iterable<ContributionBinding> bindings) {
     checkNotNull(bindings);
     checkArgument(!Iterables.isEmpty(bindings), "no bindings");
     Set<ContributionType> types = EnumSet.noneOf(ContributionType.class);
@@ -237,8 +237,8 @@ static ContributionType contributionTypeFor(Iterable<? extends ContributionBindi
    * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
    * itself, depending on {@link MapKey#unwrapValue()}).
    */
-  static ImmutableSetMultimap<Object, ? extends ContributionBinding> indexMapBindingsByMapKey(
-      Set<? extends ContributionBinding> mapBindings) {
+  static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
+      Set<ContributionBinding> mapBindings) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
@@ -255,8 +255,8 @@ public Object apply(ContributionBinding mapBinding) {
   /**
    * Indexes map-multibindings by map key annotation type.
    */
-  static ImmutableSetMultimap<Wrapper<DeclaredType>, ? extends ContributionBinding>
-      indexMapBindingsByAnnotationType(Set<? extends ContributionBinding> mapBindings) {
+  static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
+      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 85da4ad5b..38e8f026a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -19,7 +19,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import dagger.MembersInjector;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
@@ -31,6 +30,7 @@
 import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
@@ -91,7 +91,7 @@ static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBinding
     BindingKey bindingKey = resolvedBindings.bindingKey();
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
-        ImmutableSet<? extends ContributionBinding> contributionBindings =
+        ImmutableSet<ContributionBinding> contributionBindings =
             resolvedBindings.contributionBindings();
         switch (contributionTypeFor(contributionBindings)) {
           case SET:
@@ -101,7 +101,7 @@ static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBinding
                 bindingKey,
                 KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
           case UNIQUE:
-            ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
+            ContributionBinding binding = getOnlyElement(contributionBindings);
             return createWithTypeFromKey(
                 FrameworkField.frameworkClassForResolvedBindings(resolvedBindings),
                 bindingKey,
@@ -115,7 +115,9 @@ static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBinding
             bindingKey,
             CaseFormat.UPPER_CAMEL.to(
                 CaseFormat.LOWER_CAMEL,
-                Iterables.getOnlyElement(resolvedBindings.bindings())
+                resolvedBindings
+                    .membersInjectionBinding()
+                    .get()
                     .bindingElement()
                     .getSimpleName()
                     .toString()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index f5e33b59d..c938af2c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -42,7 +42,7 @@
 
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
-  abstract ImmutableSet<? extends ContributionBinding> bindings();
+  abstract ImmutableSet<ContributionBinding> bindings();
 
   enum DefaultCreationStrategy {
     PASSED,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index af9c59cfb..024097ef0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -16,11 +16,15 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
-import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
@@ -31,63 +35,168 @@
  */
 @AutoValue
 abstract class ResolvedBindings {
+  /**
+   * The binding key for which the {@link #bindings()} have been resolved.
+   */
   abstract BindingKey bindingKey();
+
+  /**
+   * The component in which the bindings in {@link #ownedBindings()},
+   * {@link #ownedContributionBindings()}, and {@link #ownedMembersInjectionBinding()} were
+   * resolved.
+   */
   abstract ComponentDescriptor owningComponent();
-  abstract ImmutableSet<? extends Binding> ownedBindings();
-  abstract ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> inheritedBindings();
 
-  static ResolvedBindings create(
-      BindingKey bindingKey,
-      ComponentDescriptor owningComponent,
-      Set<? extends Binding> ownedBindings,
-      Multimap<ComponentDescriptor, ? extends Binding> inheritedBindings) {
-    return new AutoValue_ResolvedBindings(
-            bindingKey,
-            owningComponent,
-            ImmutableSet.copyOf(ownedBindings),
-            ImmutableSetMultimap.copyOf(inheritedBindings));
+  /**
+   * The contribution bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
+
+  /**
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   */
+  abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
+
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
+   */
+  ImmutableSet<? extends Binding> ownedBindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return ownedContributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * All contribution bindings, regardless of owning component.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#CONTRIBUTION}.
+   */
+  ImmutableSet<ContributionBinding> contributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return ImmutableSet.copyOf(allContributionBindings().values());
+  }
+
+  /**
+   * The contribution bindings that were resolved in {@link #owningComponent()}.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#CONTRIBUTION}.
+   */
+  ImmutableSet<ContributionBinding> ownedContributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return allContributionBindings().get(owningComponent());
+  }
+
+  /**
+   * The members-injection binding, regardless of owning component.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   */
+  Optional<MembersInjectionBinding> membersInjectionBinding() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        FluentIterable.from(allMembersInjectionBindings().values()).toSet();
+    return membersInjectionBindings.isEmpty()
+        ? Optional.<MembersInjectionBinding>absent()
+        : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
+  }
+
+  /**
+   * The members-injection binding that was resolved in {@link #owningComponent()}.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   */
+  Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
-  static ResolvedBindings create(
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
       ComponentDescriptor owningComponent,
-      Binding... ownedBindings) {
+      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
-        ImmutableSet.copyOf(ownedBindings),
-        ImmutableSetMultimap.<ComponentDescriptor, Binding>of());
-  }
-
-  ImmutableSet<? extends Binding> bindings() {
-     return new ImmutableSet.Builder<Binding>()
-         .addAll(ownedBindings())
-         .addAll(inheritedBindings().values())
-         .build();
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
+      BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
+      ContributionBinding... ownedContributionBindings) {
+    return forContributionBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
+            .putAll(owningComponent, ownedContributionBindings)
+            .build());
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> contributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return new ImmutableSet.Builder<ContributionBinding>()
-        .addAll((Iterable<? extends ContributionBinding>) ownedBindings())
-        .addAll((Iterable<? extends ContributionBinding>) inheritedBindings().values())
-        .build();
+  /**
+   * Creates a {@link ResolvedBindings} for members injection bindings.
+   */
+  static ResolvedBindings forMembersInjectionBinding(
+      BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
+      MembersInjectionBinding ownedMembersInjectionBinding) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding));
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    return new ImmutableSet.Builder<MembersInjectionBinding>()
-        .addAll((Iterable<? extends MembersInjectionBinding>) ownedBindings())
-        .addAll((Iterable<? extends MembersInjectionBinding>) inheritedBindings().values())
-        .build();
+  /**
+   * Creates a {@link ResolvedBindings} appropriate for when there are no bindings for the key.
+   */
+  static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor owningComponent) {
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
   }
 
   /**
@@ -95,14 +204,8 @@ static ResolvedBindings create(
    * as this one, but no {@link #ownedBindings()}.
    */
   ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
-    return ResolvedBindings.create(
-            bindingKey(),
-            owningComponent,
-            ImmutableSet.<Binding>of(),
-            new ImmutableSetMultimap.Builder<ComponentDescriptor, Binding>()
-                .putAll(inheritedBindings())
-                .putAll(owningComponent, ownedBindings())
-                .build());
+    return new AutoValue_ResolvedBindings(
+        bindingKey(), owningComponent, allContributionBindings(), allMembersInjectionBindings());
   }
 
   /**
