diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3411d1fc0..5a982c35e 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -70,7 +70,6 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.1</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 51c797c72..1096ea3a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Provides;
@@ -36,6 +37,8 @@
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
@@ -299,4 +302,31 @@ public Object apply(ContributionBinding mapBinding) {
               }
             }));
   }
+
+  /**
+   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of
+   * {@link ContributionBinding}.
+   */
+  @CanIgnoreReturnValue
+  abstract static class Builder<B extends Builder<B>> {
+    abstract B contributionType(ContributionType contributionType);
+
+    abstract B bindingElement(Element bindingElement);
+
+    abstract B contributingModule(TypeElement contributingModule);
+
+    abstract B key(Key key);
+
+    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+
+    abstract B dependencies(DependencyRequest... dependencies);
+
+    abstract B nullableType(Optional<DeclaredType> nullableType);
+
+    abstract B membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+
+    abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
+
+    abstract B bindingKind(ContributionBinding.Kind kind);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2429870e6..91c88aaa0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -67,6 +67,11 @@
   TypeElement membersInjectedType() {
     return MoreElements.asType(bindingElement());
   }
+  
+  @Override
+  Optional<TypeElement> contributingModule() {
+    return Optional.absent();
+  }
 
   @Override
   Set<DependencyRequest> implicitDependencies() {
@@ -221,7 +226,6 @@ public Key apply(DeclaredType superclass) {
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
           typeElement,
-          Optional.<TypeElement>absent(),
           key,
           dependencies,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index b062789dc..9271e7c58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,18 +17,17 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
+import javax.annotation.CheckReturnValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -80,6 +79,26 @@ public BindingType bindingType() {
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
+  private static Builder builder() {
+    return new AutoValue_ProductionBinding.Builder()
+        .dependencies(ImmutableList.<DependencyRequest>of())
+        .thrownTypes(ImmutableList.<TypeMirror>of());
+  }
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+
+    abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
+
+    abstract Builder executorRequest(DependencyRequest executorRequest);
+
+    abstract Builder monitorRequest(DependencyRequest monitorRequest);
+
+    @CheckReturnValue
+    abstract ProductionBinding build();
+  }
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -110,19 +129,19 @@ ProductionBinding forProducesMethod(
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
-      return new AutoValue_ProductionBinding(
-          ContributionType.fromBindingMethod(producesMethod),
-          producesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(producesMethod)),
-          kind,
-          ImmutableList.copyOf(producesMethod.getThrownTypes()),
-          Optional.of(executorRequest),
-          Optional.of(monitorRequest));
+      // TODO(beder): Add nullability checking with Java 8.
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.fromBindingMethod(producesMethod))
+          .bindingElement(producesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .dependencies(dependencies)
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
+          .bindingKind(kind)
+          .thrownTypes(producesMethod.getThrownTypes())
+          .executorRequest(executorRequest)
+          .monitorRequest(monitorRequest)
+          .build();
     }
 
     /**
@@ -141,42 +160,32 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
       DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProducers.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValuesOrProduced.key(),
-          ImmutableSet.of(requestForMapOfProducers),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProducers.requestElement())
+          .key(requestForMapOfValuesOrProduced.key())
+          .dependencies(requestForMapOfProducers)
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .build();
     }
 
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
+          .key(request.key())
+          .dependencies(
+              dependencyRequestFactory.forMultibindingContributions(
+                  request, multibindingContributions))
+          .bindingKind(Kind.forMultibindingRequest(request))
+          .build();
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -184,37 +193,27 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forProductionComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PRODUCTION,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forProductionComponentMethod(componentMethod))
+          .bindingKind(Kind.COMPONENT_PRODUCTION)
+          .thrownTypes(componentMethod.getThrownTypes())
+          .build();
     }
 
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Producer.class);
-      return new AutoValue_ProductionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegateBinding.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
+          .dependencies(delegateDeclaration.delegateRequest())
+          .nullableType(delegateBinding.nullableType())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .build();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 6b8fcac9e..ee03fd326 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,13 +18,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -68,6 +68,23 @@ public BindingType bindingType() {
   @Override
   abstract Optional<Scope> scope();
 
+  private static Builder builder() {
+    return new AutoValue_ProvisionBinding.Builder()
+        .dependencies(ImmutableSet.<DependencyRequest>of());
+  }
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+
+    abstract Builder unresolved(ProvisionBinding unresolved);
+
+    abstract Builder scope(Optional<Scope> scope);
+
+    @CheckReturnValue
+    abstract ProvisionBinding build();
+  }
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -115,25 +132,23 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               constructorElement.getParameters(), cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
+
+      ProvisionBinding.Builder builder =
+          ProvisionBinding.builder()
+              .contributionType(ContributionType.UNIQUE)
+              .bindingElement(constructorElement)
+              .key(key)
+              .dependencies(dependencies)
+              .membersInjectionRequest(membersInjectionRequest)
+              .bindingKind(Kind.INJECTION)
+              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
-
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          constructorElement,
-          Optional.<TypeElement>absent(),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(),
-          membersInjectionRequest,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.INJECTION,
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
-              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
-              : Optional.<ProvisionBinding>absent(),
-          scope);
+      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
+        builder.unresolved(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()));
+      }
+      return builder.build();
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -165,19 +180,17 @@ ProvisionBinding forProvidesMethod(
           dependencyRequestFactory.forRequiredResolvedVariables(
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.fromBindingMethod(providesMethod),
-          providesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(providesMethod)),
-          Kind.PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.fromBindingMethod(providesMethod))
+          .bindingElement(providesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .dependencies(dependencies)
+          .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
+          .bindingKind(Kind.PROVISION)
+          .scope(Scope.uniqueScopeOf(providesMethod))
+          .build();
     }
 
     /**
@@ -194,18 +207,16 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
       DependencyRequest requestForMapOfProviders =
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValues, mapOfProvidersKey.get());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProviders.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValues.key(),
-          ImmutableSet.of(requestForMapOfProviders),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(requestForMapOfProviders.requestElement())
+          .key(requestForMapOfValues.key())
+          .dependencies(requestForMapOfProviders)
+          .wrappedMapKey(
+              wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())))
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .scope(Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()))
+          .build();
     }
 
     /**
@@ -216,53 +227,40 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
      */
     ProvisionBinding syntheticMultibinding(
         DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(request.requestElement()));
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(request.requestElement())
+          .key(request.key())
+          .dependencies(
+              dependencyRequestFactory.forMultibindingContributions(
+                  request, multibindingContributions))
+          .bindingKind(Kind.forMultibindingRequest(request))
+          .scope(Scope.uniqueScopeOf(request.requestElement()))
+          .build();
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentDefinitionType,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponent(componentDefinitionType.asType()),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentDefinitionType)
+          .key(keyFactory.forComponent(componentDefinitionType.asType()))
+          .bindingKind(Kind.COMPONENT)
+          .build();
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forComponentMethod(componentMethod))
+          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
+          .bindingKind(Kind.COMPONENT_PROVISION)
+          .scope(Scope.uniqueScopeOf(componentMethod))
+          .build();
     }
 
     ProvisionBinding forSubcomponentBuilderMethod(
@@ -271,35 +269,28 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          subcomponentBuilderMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.SUBCOMPONENT_BUILDER,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(subcomponentBuilderMethod)
+          .key(
+              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
+          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .build();
     }
 
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Provider.class);
-      return new AutoValue_ProvisionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegate.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
+      return ProvisionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
+          .dependencies(delegateDeclaration.delegateRequest())
+          .nullableType(delegate.nullableType())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement()))
+          .build();
     }
   }
 }
diff --git a/pom.xml b/pom.xml
index ba52868c2..118533d96 100644
--- a/pom.xml
+++ b/pom.xml
@@ -50,7 +50,7 @@
     <auto.common.version>0.6</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.2</auto.value.version>
+    <auto.value.version>1.3-rc2</auto.value.version>
     <errorprone.version>2.0.8</errorprone.version>
     <guava.version>19.0</guava.version>
     <google.java.format.version>1.0</google.java.format.version>
