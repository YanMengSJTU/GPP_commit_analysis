diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index f31431bd9..8467c30fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -87,8 +87,8 @@
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
@@ -531,7 +531,7 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
             default:
               return Optional.of(
                   staticMethod(
-                      javapoetGeneratedClassNameForBinding(contributionBinding),
+                      generatedClassNameForBinding(contributionBinding),
                       CodeBlocks.format("create()")));
           }
         }
@@ -922,7 +922,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           CodeBlock factoryCreate =
               CodeBlocks.format(
                   "$T.create($L)",
-                  javapoetGeneratedClassNameForBinding(binding),
+                  generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
           return binding.scope().isPresent()
               ? CodeBlocks.format("$T.create($L)", SCOPED_PROVIDER, factoryCreate)
@@ -966,7 +966,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
           return CodeBlocks.format(
               "new $T($L)",
-              javapoetGeneratedClassNameForBinding(binding),
+              generatedClassNameForBinding(binding),
               makeParametersCodeBlock(arguments));
         }
 
@@ -1000,7 +1000,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
       case INJECT_MEMBERS:
         return CodeBlocks.format(
             "$T.create($L)",
-            javapoetMembersInjectorNameForType(binding.bindingElement()),
+            membersInjectorNameForType(binding.bindingElement()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
       default:
         throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 872277fd8..15c540ede 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,13 +35,13 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.TypeName;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.SourceElement.HasSourceElement;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -409,7 +409,7 @@ private boolean validateNullability(
        * (Maybe this happens if the code was already compiled before this point?)
        * ... we manually print out the request in that case, otherwise the error
        * message is kind of useless. */
-      String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+      String typeName = TypeName.get(request.key().type()).toString();
 
       boolean valid = true;
       for (ContributionBinding binding : bindings) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index e08b12b96..626308d79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -65,6 +65,10 @@ static CodeBlock nullCheck(String thingToCheck) {
     return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
   }
 
+  static CodeBlock stringLiteral(String toWrap) {
+    return format("$S", toWrap);
+  }
+
   private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
       new Function<TypeMirror, CodeBlock>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index b38c66908..94ec0e5af 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -56,8 +56,8 @@
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.factoryOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -85,7 +85,7 @@
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return javapoetGeneratedClassNameForBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -191,7 +191,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           case CLASS_CONSTRUCTOR:
             createMethodBuilder.addStatement(
                 "return new $T($L)",
-                javapoetParameterizedGeneratedTypeNameForBinding(binding),
+                parameterizedGeneratedTypeNameForBinding(binding),
                 makeParametersCodeBlock(
                     Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
             break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index e7c273047..59726f214 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -24,9 +24,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Provides;
-import dagger.internal.codegen.writer.ClassName;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Map;
@@ -116,10 +116,9 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.unresolved().isPresent()
-          && elements.getTypeElement(factoryName.canonicalName()) == null
+          && elements.getTypeElement(factoryName.toString()) == null
           && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
-
     }
 
     /** Caches the binding for future lookups by key. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 423d62615..e831ef296 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -41,7 +41,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MapKeys.getJavapoetMapKeyCreatorClassName;
+import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -95,7 +95,7 @@ static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
 
   @Override
   ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return getJavapoetMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
+    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 875d4ef3d..5be196420 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -48,7 +48,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.SourceFiles.classFileName;
+import static dagger.internal.codegen.SourceFiles.canonicalName;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -136,11 +136,9 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * Returns the name of the generated class that contains the static {@code create} methods for a
    * {@link MapKey} annotation type.
    */
-  public static com.squareup.javapoet.ClassName getJavapoetMapKeyCreatorClassName(
-      TypeElement mapKeyType) {
-    com.squareup.javapoet.ClassName mapKeyTypeName =
-        com.squareup.javapoet.ClassName.get(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerClass(classFileName(mapKeyTypeName) + "Creator");
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName mapKeyTypeName = ClassName.get(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerClass(canonicalName(mapKeyTypeName) + "Creator");
   }
 
   /**
@@ -155,7 +153,7 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
   static CodeBlock getMapKeyExpression(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
     ClassName mapKeyCreator =
-        getJavapoetMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
+        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     if (unwrappedValue.isPresent()) {
       return new MapKeyExpressionExceptArrays(mapKeyCreator)
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 14988e1ea..293dc7466 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -59,8 +59,8 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.membersInjectorOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -81,7 +81,7 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return javapoetMembersInjectorNameForType(binding.bindingElement());
+    return membersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -138,7 +138,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
             .addTypeVariables(typeParameters);
 
     createMethodBuilder.addCode(
-        "return new $T(", javapoetParameterizedGeneratedTypeNameForBinding(binding));
+        "return new $T(", parameterizedGeneratedTypeNameForBinding(binding));
     ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
 
     boolean usesRawFrameworkTypes = false;
@@ -252,7 +252,7 @@ private CodeBlock delegateInjectMemberCodeBlock(
       ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
     return CodeBlocks.format(
         "$L.$L($L);",
-        javapoetMembersInjectorNameForType(
+        membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
         makeParametersCodeBlock(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 103e0858f..6dfa0952b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -46,7 +46,7 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
@@ -78,7 +78,7 @@
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return javapoetGeneratedClassNameForBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 05c4f3a6d..46a04d63c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -16,9 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
+import com.squareup.javapoet.ClassName;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 
@@ -37,52 +35,17 @@
  */
 final class SourceFileGenerationException extends Exception {
   // TODO(ronshapiro): remove these unused values
-  private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
-      Optional<? extends Element> associatedElement) {
-    super(createMessage(generatedClassNames, cause.getMessage()), cause);
-    this.generatedClassNames = ImmutableSet.copyOf(generatedClassNames);
-    this.associatedElement = checkNotNull(associatedElement);
-  }
-
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause) {
-    this(generatedClassNames, cause, Optional.<Element>absent());
-  }
-
-  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
-      Element associatedElement) {
-    this(generatedClassNames, cause, Optional.of(associatedElement));
-  }
-
   SourceFileGenerationException(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName,
+      Optional<ClassName> generatedClassName,
       Throwable cause,
       Optional<? extends Element> associatedElement) {
     super(createMessage(generatedClassName, cause.getMessage()), cause);
-    this.generatedClassNames = ImmutableSet.of();
     this.associatedElement = checkNotNull(associatedElement);
   }
 
-  public ImmutableSet<ClassName> generatedClassNames() {
-    return generatedClassNames;
-  }
-
-  public Optional<? extends Element> associatedElement() {
-    return associatedElement;
-  }
-
-  private static String createMessage(Iterable<ClassName> generatedClassNames, String message) {
-    return String.format("Could not generate %s: %s.",
-        Iterables.isEmpty(generatedClassNames)
-            ? "unknown files"
-            : Iterables.toString(generatedClassNames),
-        message);
-  }
-
-  private static String createMessage(
-      Optional<com.squareup.javapoet.ClassName> generatedClassName, String message) {
+  private static String createMessage(Optional<ClassName> generatedClassName, String message) {
     return String.format("Could not generate %s: %s.",
         generatedClassName.isPresent()
             ? generatedClassName.get()
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 4731ea641..0e3e6e6fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -23,13 +23,11 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
 import java.util.Iterator;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -49,7 +47,8 @@
  */
 class SourceFiles {
 
-  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('$');
+  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('_');
+  private static final Joiner CANONICAL_NAME_JOINER = Joiner.on('$');
 
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
@@ -122,24 +121,6 @@ private static String fieldNameForDependency(FrameworkDependency frameworkDepend
     }
   }
 
-  static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
-      DependencyRequest.Kind dependencyKind) {
-    switch (dependencyKind) {
-      case LAZY:
-        return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
-            frameworkTypeMemberSelect);
-      case INSTANCE:
-      case FUTURE:
-        return Snippet.format("%s.get()", frameworkTypeMemberSelect);
-      case PROVIDER:
-      case PRODUCER:
-      case MEMBERS_INJECTOR:
-        return Snippet.format("%s", frameworkTypeMemberSelect);
-      default:
-        throw new AssertionError();
-    }
-  }
-
   static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
@@ -167,51 +148,7 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
         checkArgument(!contribution.isSyntheticBinding());
-        ClassName enclosingClassName = ClassName.fromTypeElement(contribution.bindingTypeElement());
-        switch (contribution.bindingKind()) {
-          case INJECTION:
-          case PROVISION:
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
-            return enclosingClassName
-                .topLevelClassName()
-                .peerNamed(
-                    enclosingClassName.classFileName()
-                        + "_"
-                        + factoryPrefix(contribution)
-                        + "Factory");
-
-          default:
-            throw new AssertionError();
-        }
-
-      case MEMBERS_INJECTION:
-        return membersInjectorNameForType(binding.bindingTypeElement());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the generated factory or members injector name parameterized with the proper type
-   * parameters if necessary.
-   */
-  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
-    return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
-  }
-
-  /**
-   * Returns the generated factory or members injector name for a binding.
-   */
-  static com.squareup.javapoet.ClassName javapoetGeneratedClassNameForBinding(Binding binding) {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(!contribution.isSyntheticBinding());
-        com.squareup.javapoet.ClassName enclosingClassName =
-            com.squareup.javapoet.ClassName.get(contribution.bindingTypeElement());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement());
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
@@ -220,7 +157,7 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
             return enclosingClassName
                 .topLevelClassName()
                 .peerClass(
-                    classFileName(enclosingClassName)
+                    canonicalName(enclosingClassName)
                         + "_"
                         + factoryPrefix(contribution)
                         + "Factory");
@@ -230,24 +167,23 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
         }
 
       case MEMBERS_INJECTION:
-        return javapoetMembersInjectorNameForType(binding.bindingTypeElement());
+        return membersInjectorNameForType(binding.bindingTypeElement());
 
       default:
         throw new AssertionError();
     }
   }
 
-  static com.squareup.javapoet.TypeName javapoetParameterizedGeneratedTypeNameForBinding(
+  static TypeName parameterizedGeneratedTypeNameForBinding(
       Binding binding) {
-    com.squareup.javapoet.ClassName className = javapoetGeneratedClassNameForBinding(binding);
-    ImmutableList<com.squareup.javapoet.TypeName> typeParameters =
-        javapoetBindingTypeParameters(binding);
+    ClassName className = generatedClassNameForBinding(binding);
+    ImmutableList<TypeName> typeParameters = bindingTypeParameters(binding);
     if (typeParameters.isEmpty()) {
       return className;
     } else {
-      return com.squareup.javapoet.ParameterizedTypeName.get(
+      return ParameterizedTypeName.get(
           className,
-          FluentIterable.from(typeParameters).toArray(com.squareup.javapoet.TypeName.class));
+          FluentIterable.from(typeParameters).toArray(TypeName.class));
     }
   }
 
@@ -285,58 +221,45 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     }
   }
 
-  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding) {
+  static ImmutableList<TypeName> bindingTypeParameters(
+      Binding binding) {
     Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
     if (!typeMirror.isPresent()) {
       return ImmutableList.of();
     }
-    TypeName bindingTypeName = dagger.internal.codegen.writer.TypeNames.forTypeMirror(typeMirror.get());
+    TypeName bindingTypeName = TypeName.get(typeMirror.get());
     return bindingTypeName instanceof ParameterizedTypeName
-        ? ((ParameterizedTypeName) bindingTypeName).parameters()
+        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)
         : ImmutableList.<TypeName>of();
   }
 
-  static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    com.squareup.javapoet.TypeName bindingTypeName =
-        com.squareup.javapoet.TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof com.squareup.javapoet.ParameterizedTypeName
-        ? ImmutableList.copyOf(
-            ((com.squareup.javapoet.ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<com.squareup.javapoet.TypeName>of();
-  }
-  
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
-    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
+    return siblingClassName(typeElement,  "_MembersInjector");
   }
 
-  static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
-      TypeElement typeElement) {
-    return siblingClassName(typeElement,  "_MembersInjector");
+  /**
+   * @deprecated prefer {@link #classFileName(ClassName)} instead and avoid dollar signs in
+   * generated source.
+   */
+  @Deprecated
+  static String canonicalName(ClassName className) {
+    return CANONICAL_NAME_JOINER.join(className.simpleNames());
   }
 
-  static String classFileName(com.squareup.javapoet.ClassName className) {
+  static String classFileName(ClassName className) {
     return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
   }
 
-  static com.squareup.javapoet.ClassName generatedMonitoringModuleName(
+  static ClassName generatedMonitoringModuleName(
       TypeElement componentElement) {
     return siblingClassName(componentElement, "_MonitoringModule");
   }
 
-  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code which could
-  // use this.
-  private static com.squareup.javapoet.ClassName siblingClassName(
-      TypeElement typeElement, String suffix) {
-    com.squareup.javapoet.ClassName className = com.squareup.javapoet.ClassName.get(typeElement);
-    return className.topLevelClassName().peerClass(classFileName(className) + suffix);
+  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code
+  // which could use this.
+  private static ClassName siblingClassName(TypeElement typeElement, String suffix) {
+    ClassName className = ClassName.get(typeElement);
+    return className.topLevelClassName().peerClass(canonicalName(className) + suffix);
   }
 
   private static String factoryPrefix(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
deleted file mode 100644
index 9ffab1871..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.SortedMap;
-
-import static dagger.internal.codegen.writer.Writables.toStringWritable;
-
-public final class AnnotationWriter implements Writable, HasClassReferences {
-  private final ClassName annotationName;
-  private final Set<HasClassReferences> memberReferences = Sets.newLinkedHashSet();
-  private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
-
-  AnnotationWriter(ClassName annotationName) {
-    this.annotationName = annotationName;
-  }
-
-  public void setValue(String value) {
-    setMember("value", value);
-  }
-
-  public void setMember(String name, int value) {
-    memberMap.put(name, toStringWritable(value));
-  }
-
-  public void setMember(String name, String value) {
-    memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
-  }
-
-  public <T extends Enum<T>> void setMember(String name, T value) {
-    Snippet snippet = Snippet.format("%s.%s", ClassName.fromClass(value.getClass()), value);
-    memberMap.put(name, snippet);
-    memberReferences.add(snippet);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append('@');
-    annotationName.write(appendable, context);
-    if (!memberMap.isEmpty()) {
-      appendable.append('(');
-      boolean singleEntry = memberMap.size() == 1;
-      Iterator<Entry<String, Writable>> iterator = memberMap.entrySet().iterator();
-      while (iterator.hasNext()) {
-        Entry<String, Writable> member = iterator.next();
-        if (!singleEntry || !member.getKey().equals("value")) {
-          appendable.append(member.getKey()).append(" = ");
-        }
-        member.getValue().write(appendable, context);
-        if (iterator.hasNext()) {
-          appendable.append(",");
-        }
-      }
-      appendable.append(')');
-    }
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(memberReferences)
-        .append(annotationName)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
deleted file mode 100644
index e7960629e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.io.IOException;
-import java.util.Set;
-
-final class ArrayTypeName implements TypeName {
-  private final TypeName componentType;
-
-  ArrayTypeName(TypeName componentType) {
-    this.componentType = componentType;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return componentType.referencedClasses();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return componentType.write(appendable, context).append("[]");
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return (obj instanceof ArrayTypeName)
-        && this.componentType.equals(((ArrayTypeName) obj).componentType);
-  }
-
-  @Override
-  public int hashCode() {
-    return componentType.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
deleted file mode 100644
index c00dd5f07..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Lists;
-import java.io.IOException;
-import java.util.List;
-import java.util.Set;
-
-public final class BlockWriter implements Writable, HasClassReferences {
-  private final List<Snippet> snippets;
-
-  BlockWriter() {
-    this.snippets = Lists.newArrayList();
-  }
-
-  public BlockWriter addSnippet(String snippet, Object... args) {
-    snippets.add(Snippet.format(snippet, args));
-    return this;
-  }
-
-  public BlockWriter addSnippet(Snippet snippet) {
-    snippets.add(snippet);
-    return this;
-  }
-
-  boolean isEmpty() {
-    return snippets.isEmpty();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    for (Snippet snippet : snippets) {
-      appendable.append('\n');
-      snippet.write(appendable, context);
-    }
-    return appendable.append('\n');
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(snippets)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
deleted file mode 100644
index bd0791fc6..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Ascii;
-import com.google.common.base.Joiner;
-import com.google.common.base.Objects;
-import com.google.common.base.Optional;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.NestingKind;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.NestingKind.MEMBER;
-import static javax.lang.model.element.NestingKind.TOP_LEVEL;
-
-/**
- * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and
- * {@link NestingKind#MEMBER} classes.
- *
- * @since 2.0
- */
-public final class ClassName implements TypeName, Comparable<ClassName> {
-  private String fullyQualifiedName = null;
-  private final String packageName;
-  /* From top to bottom.  E.g.: this field will contain ["A", "B"] for pgk.A.B.C */
-  private final ImmutableList<String> enclosingSimpleNames;
-  private final String simpleName;
-
-  private ClassName(String packageName, ImmutableList<String> enclosingSimpleNames,
-      String simpleName) {
-    this.packageName = packageName;
-    this.enclosingSimpleNames = enclosingSimpleNames;
-    this.simpleName = simpleName;
-  }
-
-  public String packageName() {
-    return packageName;
-  }
-
-  public ImmutableList<String> enclosingSimpleNames() {
-    return enclosingSimpleNames;
-  }
-
-  public Optional<ClassName> enclosingClassName() {
-    return enclosingSimpleNames.isEmpty()
-        ? Optional.<ClassName>absent()
-        : Optional.of(new ClassName(packageName,
-            enclosingSimpleNames.subList(0, enclosingSimpleNames.size() - 1),
-            enclosingSimpleNames.get(enclosingSimpleNames.size() - 1)));
-  }
-
-  public String simpleName() {
-    return simpleName;
-  }
-
-  public String canonicalName() {
-    if (fullyQualifiedName == null) {
-      StringBuilder builder = new StringBuilder(packageName());
-      if (builder.length() > 0) {
-        builder.append('.');
-      }
-      for (String enclosingSimpleName : enclosingSimpleNames()) {
-        builder.append(enclosingSimpleName).append('.');
-      }
-      fullyQualifiedName = builder.append(simpleName()).toString();
-    }
-    return fullyQualifiedName;
-  }
-
-  /**
-   * Equivalent to {@link #classFileName(char) classFileName('$')}
-   */
-  public String classFileName() {
-    return classFileName('$');
-  }
-
-  /**
-   * Returns the class name (excluding package).
-   *
-   * <p>The returned value includes the names of its enclosing classes (if any) but not the package
-   * name. e.g. {@code fromClass(Map.Entry.class).classFileName('_')} will return {@code Map_Entry}.
-   */
-  public String classFileName(char separator) {
-    StringBuilder builder = new StringBuilder();
-    for (String enclosingSimpleName : enclosingSimpleNames) {
-      builder.append(enclosingSimpleName).append(separator);
-    }
-    return builder.append(simpleName()).toString();
-  }
-
-  public ClassName topLevelClassName() {
-    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
-    return enclosingIterator.hasNext()
-        ? new ClassName(packageName(), ImmutableList.<String>of(),
-            enclosingIterator.next())
-        : this;
-  }
-
-  public ClassName nestedClassNamed(String memberClassName) {
-    checkNotNull(memberClassName);
-    checkArgument(SourceVersion.isIdentifier(memberClassName));
-    return new ClassName(packageName(),
-        new ImmutableList.Builder<String>()
-            .addAll(enclosingSimpleNames())
-            .add(simpleName())
-            .build(),
-        memberClassName);
-  }
-
-  public ClassName peerNamed(String peerClassName) {
-    checkNotNull(peerClassName);
-    checkArgument(SourceVersion.isIdentifier(peerClassName));
-    return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
-  }
-
-  /**
-   * Returns a parameterized type name with this as its raw type if {@code parameters} is not empty.
-   * If {@code parameters} is empty, returns this object.
-   */
-  public TypeName withTypeParameters(List<? extends TypeName> parameters) {
-    return parameters.isEmpty() ? this : ParameterizedTypeName.create(this, parameters);
-  }
-
-  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
-      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
-
-  public static ClassName fromTypeElement(TypeElement element) {
-    checkNotNull(element);
-    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
-    String simpleName = element.getSimpleName().toString();
-    List<String> enclosingNames = new ArrayList<String>();
-    Element current = element.getEnclosingElement();
-    while (current.getKind().isClass() || current.getKind().isInterface()) {
-      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
-      enclosingNames.add(current.getSimpleName().toString());
-      current = current.getEnclosingElement();
-    }
-    PackageElement packageElement = getPackage(current);
-    Collections.reverse(enclosingNames);
-    return new ClassName(packageElement.getQualifiedName().toString(),
-        ImmutableList.copyOf(enclosingNames), simpleName);
-  }
-
-  public static ClassName fromClass(Class<?> clazz) {
-    checkNotNull(clazz);
-    List<String> enclosingNames = new ArrayList<String>();
-    Class<?> current = clazz.getEnclosingClass();
-    while (current != null) {
-      enclosingNames.add(current.getSimpleName());
-      current = current.getEnclosingClass();
-    }
-    Collections.reverse(enclosingNames);
-    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
-  }
-
-  private static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
-   * method assumes that the input is ASCII and follows typical Java style (lower-case package
-   * names, upper-camel-case class names) and may produce incorrect results or throw
-   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and
-   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
-   * instances without such restrictions.
-   */
-  public static ClassName bestGuessFromString(String classNameString) {
-    checkNotNull(classNameString);
-    List<String> parts = Splitter.on('.').splitToList(classNameString);
-    int firstClassPartIndex = -1;
-    for (int i = 0; i < parts.size(); i++) {
-      String part = parts.get(i);
-      checkArgument(SourceVersion.isIdentifier(part));
-      char firstChar = part.charAt(0);
-      if (Ascii.isLowerCase(firstChar)) {
-        // looks like a package part
-        if (firstClassPartIndex >= 0) {
-          throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
-        }
-      } else if (Ascii.isUpperCase(firstChar)) {
-        // looks like a class part
-        if (firstClassPartIndex < 0) {
-          firstClassPartIndex = i;
-        }
-      } else {
-        throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
-      }
-    }
-    int lastIndex = parts.size() - 1;
-    return new ClassName(
-        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
-        firstClassPartIndex == lastIndex
-            ? ImmutableList.<String>of()
-            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),
-        parts.get(lastIndex));
-  }
-
-  public static ClassName create(
-      String packageName, List<String> enclosingSimpleNames, String simpleName) {
-    return new ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
-        simpleName);
-  }
-
-  public static ClassName create(String packageName, String simpleName) {
-    return new ClassName(packageName, ImmutableList.<String>of(), simpleName);
-  }
-
-  @Override
-  public String toString() {
-    return canonicalName();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(context.sourceReferenceForClassName(this));
-    return appendable;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == this) {
-      return true;
-    } else if (obj instanceof ClassName) {
-      ClassName that = (ClassName) obj;
-      return this.packageName.equals(that.packageName)
-          && this.enclosingSimpleNames.equals(that.enclosingSimpleNames)
-          && this.simpleName.equals(that.simpleName);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);
-  }
-
-  @Override
-  public int compareTo(ClassName o) {
-    return canonicalName().compareTo(o.canonicalName());
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of(this);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
deleted file mode 100644
index edaba3a2d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-public final class ClassWriter extends TypeWriter {
-  private Optional<TypeName> superclass;
-  private final List<ConstructorWriter> constructorWriters;
-  private final List<TypeVariableName> typeParameters;
-
-  ClassWriter(ClassName className) {
-    super(className);
-    this.superclass = Optional.absent();
-    this.constructorWriters = Lists.newArrayList();
-    this.typeParameters = Lists.newArrayList();
-  }
-
-  public void setSuperclass(TypeName typeReference) {
-    checkState(!superclass.isPresent());
-    superclass = Optional.of(typeReference);
-  }
-
-  /**
-   * If {@code supertype} is a class, makes this class extend it; if it is an interface, makes this
-   * class implement it.
-   */
-  public void setSupertype(TypeElement supertype) {
-    switch (supertype.getKind()) {
-      case CLASS:
-        setSuperclass(ClassName.fromTypeElement(supertype));
-        break;
-      case INTERFACE:
-        addImplementedType(supertype);
-        break;
-      default:
-        throw new IllegalArgumentException(supertype + " must be a class or interface");
-    }
-  }
-
-  public ConstructorWriter addConstructor() {
-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
-    constructorWriters.add(constructorWriter);
-    return constructorWriter;
-  }
-
-  public void addTypeParameter(TypeVariableName typeVariableName) {
-    this.typeParameters.add(typeVariableName);
-  }
-
-  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
-    Iterables.addAll(typeParameters, typeVariableNames);
-  }
-
-  public List<TypeVariableName> typeParameters() {
-    return ImmutableList.copyOf(typeParameters);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("class ").append(name.simpleName());
-    Writables.join(", ", typeParameters, "<", ">", appendable, context);
-    if (superclass.isPresent()) {
-      appendable.append(" extends ");
-      superclass.get().write(appendable, context);
-    }
-    Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
-    appendable.append(" {");
-    if (!fieldWriters.isEmpty()) {
-      appendable.append('\n');
-    }
-    for (VariableWriter fieldWriter : fieldWriters.values()) {
-      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
-    }
-    for (ConstructorWriter constructorWriter : constructorWriters) {
-      appendable.append('\n');
-      if (!isDefaultConstructor(constructorWriter)) {
-        constructorWriter.write(new IndentingAppendable(appendable), context);
-      }
-    }
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  private static final Set<Modifier> VISIBILIY_MODIFIERS =
-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
-
-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
-        && constructorWriter.body().isEmpty();
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(fieldWriters.values())
-        .append(constructorWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(superclass.asSet())
-        .append(annotations)
-        .append(typeParameters)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
deleted file mode 100644
index 387c1ddf1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {
-  private final String name;
-  private final Map<String, VariableWriter> parameterWriters;
-  private final BlockWriter blockWriter;
-
-  ConstructorWriter(String name) {
-    this.name = name;
-    this.parameterWriters = Maps.newLinkedHashMap();
-    this.blockWriter = new BlockWriter();
-  }
-
-  public VariableWriter addParameter(Class<?> type, String name) {
-    return addParameter(ClassName.fromClass(type), name);
-  }
-
-  public VariableWriter addParameter(TypeElement type, String name) {
-    return addParameter(ClassName.fromTypeElement(type), name);
-  }
-
-  public VariableWriter addParameter(TypeWriter type, String name) {
-    return addParameter(type.name, name);
-  }
-
-  public VariableWriter addParameter(TypeName type, String name) {
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-  
-  public Map<String, TypeName> parameters() {
-    ImmutableMap.Builder<String, TypeName> params = ImmutableMap.builder();
-    for (Map.Entry<String, VariableWriter> entry : parameterWriters.entrySet()) {
-      params.put(entry.getKey(), entry.getValue().type());
-    }
-    return params.build();
-  }
-
-  public BlockWriter body() {
-    return blockWriter;
-  }
-
-  private VariableWriter addParameter(ClassName type, String name) {
-    checkArgument(!parameterWriters.containsKey(name));
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(parameterWriters.values())
-        .append(annotations)
-        .append(blockWriter)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append(name).append('(');
-    Writables.join(", ", parameterWriters.values(), appendable, context);
-    appendable.append(") {");
-    blockWriter.write(new IndentingAppendable(appendable), context);
-    return appendable.append("}\n");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
deleted file mode 100644
index 4ab017d79..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.Modifier;
-
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-public final class EnumWriter extends TypeWriter {
-  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();
-  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();
-
-  EnumWriter(ClassName name) {
-    super(name);
-  }
-
-  public ConstantWriter addConstant(String name) {
-    ConstantWriter constantWriter = new ConstantWriter(name);
-    constantWriters.put(name, constantWriter);
-    return constantWriter;
-  }
-
-  public ConstructorWriter addConstructor() {
-    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
-    constructorWriters.add(constructorWriter);
-    return constructorWriter;
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("enum ").append(name.simpleName());
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" implements ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
-    appendable.append(" {");
-
-    checkState(!constantWriters.isEmpty(), "Cannot write an enum with no constants.");
-    appendable.append('\n');
-    ImmutableList<ConstantWriter> constantWriterList =
-        ImmutableList.copyOf(constantWriters.values());
-    for (ConstantWriter constantWriter
-        : constantWriterList.subList(0, constantWriterList.size() - 1)) {
-      constantWriter.write(appendable, context);
-      appendable.append(",\n");
-    }
-    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);
-    appendable.append(";\n");
-
-    if (!fieldWriters.isEmpty()) {
-      appendable.append('\n');
-    }
-    for (VariableWriter fieldWriter : fieldWriters.values()) {
-      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
-    }
-    for (ConstructorWriter constructorWriter : constructorWriters) {
-      appendable.append('\n');
-      if (!isDefaultConstructor(constructorWriter)) {
-        constructorWriter.write(new IndentingAppendable(appendable), context);
-      }
-    }
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  private static final Set<Modifier> VISIBILIY_MODIFIERS =
-      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
-
-  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
-    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
-        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
-        && constructorWriter.body().isEmpty();
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(constantWriters.values())
-        .append(fieldWriters.values())
-        .append(constructorWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-
-  public static final class ConstantWriter implements Writable, HasClassReferences {
-    private final String name;
-    private final List<Snippet> constructorSnippets;
-
-    private ConstantWriter(String name) {
-      this.name = name;
-      this.constructorSnippets = Lists.newArrayList();
-    }
-
-    ConstantWriter addArgument(Snippet snippet) {
-      constructorSnippets.add(snippet);
-      return this;
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      appendable.append(name);
-      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();
-      if (snippetIterator.hasNext()) {
-        appendable.append('(');
-        snippetIterator.next().write(appendable, context);
-        while (snippetIterator.hasNext()) {
-          appendable.append(", ");
-          snippetIterator.next().write(appendable, context);
-        }
-        appendable.append(')');
-      }
-      return appendable;
-    }
-
-    @Override
-    public Set<ClassName> referencedClasses() {
-      return FluentIterable.from(constructorSnippets)
-          .transformAndConcat(HasClassReferences.COMBINER)
-          .toSet();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
deleted file mode 100644
index b45e5d9ae..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Set;
-
-public final class FieldWriter extends VariableWriter {
-  private Optional<Snippet> initializer;
-
-  FieldWriter(TypeName type, String name) {
-    super(type, name);
-    this.initializer = Optional.absent();
-  }
-
-  public void setInitializer(Snippet initializer) {
-    this.initializer = Optional.of(initializer);
-  }
-
-  public void setInitializer(String initializer, Object... args) {
-    this.initializer = Optional.of(Snippet.format(initializer, args));
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    super.write(appendable, context);
-    if (initializer.isPresent()) {
-      appendable.append(" = ");
-      initializer.get().write(appendable, context);
-    }
-    appendable.append(';');
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
deleted file mode 100644
index e463ea2cb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import java.util.Set;
-
-public interface HasClassReferences {
-  Set<ClassName> referencedClasses();
-
-  static final Function<HasClassReferences, Set<ClassName>> COMBINER =
-      new Function<HasClassReferences, Set<ClassName>>() {
-        @Override
-        public Set<ClassName> apply(HasClassReferences input) {
-          return input.referencedClasses();
-        }
-      };
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
deleted file mode 100644
index a6909ed10..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-interface HasTypeName {
-  TypeName name();
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
deleted file mode 100644
index d96f8a3a2..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.AbstractIterator;
-import java.io.IOException;
-import java.util.Iterator;
-
-final class IndentingAppendable implements Appendable {
-  private final String indentation;
-  private final Appendable delegate;
-  private boolean requiresIndent = true;
-
-  IndentingAppendable(Appendable delegate) {
-    this("  ", delegate);
-  }
-
-  IndentingAppendable(String indentation, Appendable delegate) {
-    this.indentation = indentation;
-    this.delegate = delegate;
-  }
-
-  @Override
-  public Appendable append(CharSequence csq) throws IOException {
-    return append(csq, 0, csq.length());
-  }
-
-  @Override
-  public Appendable append(CharSequence csq, int start, int end) throws IOException {
-    Iterator<CharSequence> lines = lines(csq, start, end);
-    while (lines.hasNext()) {
-      CharSequence line = lines.next();
-      maybeIndent();
-      delegate.append(line);
-      if (line.charAt(line.length() - 1) == '\n') {
-        requiresIndent = true;
-      }
-    }
-    return this;
-  }
-
-  @Override
-  public Appendable append(char c) throws IOException {
-    maybeIndent();
-    delegate.append(c);
-    if (c == '\n') {
-      requiresIndent = true;
-    }
-    return this;
-  }
-
-  void maybeIndent() throws IOException {
-    if (requiresIndent) {
-      delegate.append(indentation);
-    }
-    requiresIndent = false;
-  }
-
-  private static Iterator<CharSequence> lines(
-      final CharSequence csq, final int start, final int end) {
-    return new AbstractIterator<CharSequence>() {
-      int index = start;
-
-      @Override protected CharSequence computeNext() {
-        int nextStart = index;
-        while (index < end && csq.charAt(index) != '\n') {
-          index++;
-        }
-        if (index < end && csq.charAt(index) == '\n') {
-          index++;
-        }
-        int nextEnd = index;
-        return nextStart >= end
-            ? endOfData()
-            : csq.subSequence(nextStart, nextEnd);
-      }
-    };
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
deleted file mode 100644
index ffcfc7562..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-
-public final class InterfaceWriter extends TypeWriter {
-  private final List<TypeVariableName> typeVariables;
-  InterfaceWriter(ClassName name) {
-    super(name);
-    this.typeVariables = Lists.newArrayList();
-  }
-
-  public void addTypeVariable(TypeVariableName typeVariable) {
-    this.typeVariables.add(typeVariable);
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet());
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable).append("interface ").append(name.simpleName());
-    if (!typeVariables.isEmpty()) {
-      appendable.append('<');
-      Joiner.on(", ").appendTo(appendable, typeVariables);
-      appendable.append('>');
-    }
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" extends ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
-    appendable.append(" {");
-    for (MethodWriter methodWriter : methodWriters) {
-      appendable.append('\n');
-      methodWriter.write(new IndentingAppendable(appendable), context);
-    }
-    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
-      appendable.append('\n');
-      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
-    }
-    appendable.append("}\n");
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(nestedTypeWriters)
-        .append(methodWriters)
-        .append(implementedTypes)
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
deleted file mode 100644
index 674dd621e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.BiMap;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Sets;
-import com.google.common.io.CharSink;
-import com.google.common.io.CharSource;
-import com.google.googlejavaformat.java.Formatter;
-import com.google.googlejavaformat.java.FormatterException;
-import dagger.internal.codegen.ComponentProcessor;
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Generated;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.PackageElement;
-import javax.tools.JavaFileObject;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableList;
-
-/**
- * Writes a single compilation unit.
- */
-public final class JavaWriter {
-  public static JavaWriter inPackage(String packageName) {
-    return new JavaWriter(packageName);
-  }
-
-  public static JavaWriter inPackage(Package enclosingPackage) {
-    return new JavaWriter(enclosingPackage.getName());
-  }
-
-  public static JavaWriter inPackage(PackageElement packageElement) {
-    return new JavaWriter(packageElement.getQualifiedName().toString());
-  }
-
-  private final String packageName;
-  // TODO(gak): disallow multiple types in a file?
-  private final List<TypeWriter> typeWriters;
-  private final List<ClassName> explicitImports;
-
-  private JavaWriter(String packageName) {
-    this.packageName = packageName;
-    this.typeWriters = Lists.newArrayList();
-    this.explicitImports = Lists.newArrayList();
-  }
-
-  public List<TypeWriter> getTypeWriters() {
-    return unmodifiableList(typeWriters);
-  }
-
-  public JavaWriter addImport(Class<?> importedClass) {
-    explicitImports.add(ClassName.fromClass(importedClass));
-    return this;
-  }
-
-  public ClassWriter addClass(String simpleName) {
-    checkNotNull(simpleName);
-    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(classWriter);
-    return classWriter;
-  }
-
-  public EnumWriter addEnum(String simpleName) {
-    checkNotNull(simpleName);
-    EnumWriter writer = new EnumWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(writer);
-    return writer;
-  }
-
-  public InterfaceWriter addInterface(String simpleName) {
-    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
-    typeWriters.add(writer);
-    return writer;
-  }
-
-  public void markGenerated(boolean generatedAnnotationAvailable) {
-    for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.markGenerated(generatedAnnotationAvailable);
-    }
-  }
-
-  public <A extends Appendable> A write(A appendable) throws IOException {
-    if (!packageName.isEmpty()) {
-      appendable.append("package ").append(packageName).append(";\n\n");
-    }
-
-    // write imports
-    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-
-    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
-        .addAll(explicitImports)
-        .addAll(classNames)
-        .build();
-    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)
-        .transform(new Function<TypeWriter, ClassName>() {
-          @Override public ClassName apply(TypeWriter input) {
-            return input.name;
-          }
-        })
-        .toSet();
-
-    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
-    Deque<TypeWriter> declaredTypes = new ArrayDeque<>(typeWriters);
-    while (!declaredTypes.isEmpty()) {
-      TypeWriter currentType = declaredTypes.pop();
-      declaredSimpleNamesBuilder.add(currentType.name().simpleName());
-      declaredTypes.addAll(currentType.nestedTypeWriters);
-    }
-
-    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
-
-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
-    for (ClassName className : importCandidates) {
-      if (!(className.packageName().equals(packageName)
-              && !className.enclosingClassName().isPresent())
-          && !(className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty())
-          && !typeNames.contains(className.topLevelClassName())) {
-        Optional<ClassName> importCandidate = Optional.of(className);
-        while (importCandidate.isPresent()
-            && (importedClassIndex.containsKey(importCandidate.get().simpleName())
-                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {
-          importCandidate = importCandidate.get().enclosingClassName();
-        }
-        if (importCandidate.isPresent()) {
-          appendable.append("import ").append(importCandidate.get().canonicalName()).append(";\n");
-          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());
-        }
-      }
-    }
-
-    appendable.append('\n');
-
-    CompilationUnitContext context =
-        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));
-
-    // write types
-    for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\n');
-    }
-    return appendable;
-  }
-
-  public void file(Filer filer, Iterable<? extends Element> originatingElements)
-      throws IOException {
-    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);
-  }
-
-  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
-      throws IOException {
-    final JavaFileObject sourceFile = filer.createSourceFile(name,
-        Iterables.toArray(originatingElements, Element.class));
-    try {
-      new Formatter().formatSource(
-          CharSource.wrap(write(new StringBuilder())),
-          new CharSink() {
-            @Override public Writer openStream() throws IOException {
-              return sourceFile.openWriter();
-            }
-          });
-    } catch (FormatterException e) {
-      throw new IllegalStateException(
-          "The writer produced code that could not be parsed by the formatter", e);
-    }
-  }
-
-  @Override
-  public String toString() {
-    try {
-      return write(new StringBuilder()).toString();
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
-
-  static final class CompilationUnitContext implements Context {
-    private final String packageName;
-    private final ImmutableSortedSet<ClassName> visibleClasses;
-
-    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {
-      this.packageName = packageName;
-      this.visibleClasses =
-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);
-    }
-
-    @Override
-    public Context createSubcontext(Set<ClassName> newTypes) {
-      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));
-    }
-
-    @Override
-    public String sourceReferenceForClassName(ClassName className) {
-      if (isImported(className)) {
-        return className.simpleName();
-      }
-      Optional<ClassName> enclosingClassName = className.enclosingClassName();
-      while (enclosingClassName.isPresent()) {
-        if (isImported(enclosingClassName.get())) {
-          return enclosingClassName.get().simpleName()
-              + className.canonicalName()
-                  .substring(enclosingClassName.get().canonicalName().length());
-        }
-        enclosingClassName = enclosingClassName.get().enclosingClassName();
-      }
-      return className.canonicalName();
-    }
-
-    private boolean collidesWithVisibleClass(ClassName className) {
-      return collidesWithVisibleClass(className.simpleName());
-    }
-
-    private boolean collidesWithVisibleClass(String simpleName) {
-      return FluentIterable.from(visibleClasses)
-          .transform(new Function<ClassName, String>() {
-            @Override public String apply(ClassName input) {
-              return input.simpleName();
-            }
-          })
-          .contains(simpleName);
-    }
-
-    private boolean isImported(ClassName className) {
-      return (packageName.equals(className.packageName())
-              && !className.enclosingClassName().isPresent()
-              && !collidesWithVisibleClass(className)) // need to account for scope & hiding
-          || visibleClasses.contains(className)
-          || (className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty());
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
deleted file mode 100644
index eb4ff8d51..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {
-  private final TypeName returnType;
-  private final String name;
-  private final Map<String, VariableWriter> parameterWriters;
-  private final List<TypeVariableName> typeParameters;
-  private Optional<BlockWriter> body;
-
-  MethodWriter(TypeName returnType, String name) {
-    this.returnType = returnType;
-    this.name = name;
-    this.parameterWriters = Maps.newLinkedHashMap();
-    this.typeParameters = Lists.newArrayList();
-    this.body = Optional.absent();
-  }
-
-  public String name() {
-    return name;
-  }
-  
-  public TypeName returnType() {
-    return returnType;
-  }
-  
-  public void addTypeParameter(TypeVariableName typeVariableName) {
-    this.typeParameters.add(typeVariableName);
-  }
-  
-  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
-    Iterables.addAll(typeParameters, typeVariableNames);
-  }
-
-  public VariableWriter addParameter(Class<?> type, String name) {
-    return addParameter(ClassName.fromClass(type), name);
-  }
-
-  public VariableWriter addParameter(TypeElement type, String name) {
-    return addParameter(ClassName.fromTypeElement(type), name);
-  }
-
-  public VariableWriter addParameter(TypeWriter type, String name) {
-    return addParameter(type.name, name);
-  }
-
-  public VariableWriter addParameter(TypeName type, String name) {
-    checkArgument(!parameterWriters.containsKey(name));
-    VariableWriter parameterWriter = new VariableWriter(type, name);
-    parameterWriters.put(name, parameterWriter);
-    return parameterWriter;
-  }
-
-  public BlockWriter body() {
-    if (body.isPresent()) {
-      return body.get();
-    } else {
-      BlockWriter blockWriter = new BlockWriter();
-      body = Optional.of(blockWriter);
-      return blockWriter;
-    }
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable);
-    Writables.join(", ", typeParameters, "<", "> ", appendable, context);
-    returnType.write(appendable, context);
-    appendable.append(' ').append(name).append('(');
-    Writables.join(", ", parameterWriters.values(), appendable, context);
-    appendable.append(")");
-    if (body.isPresent()) {
-      appendable.append(" {");
-      body.get().write(new IndentingAppendable(appendable), context);
-      appendable.append("}\n");
-    } else {
-      appendable.append(";\n");
-    }
-    return appendable;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(parameterWriters.values())
-        .append(returnType)
-        .append(body.asSet())
-        .append(annotations)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
deleted file mode 100644
index 91072baf6..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import dagger.internal.codegen.ComponentProcessor;
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Generated;
-import javax.lang.model.element.Modifier;
-
-public abstract class Modifiable {
-
-  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
-
-  final Set<Modifier> modifiers;
-  final List<AnnotationWriter> annotations;
-  // This is not intended to be widely used; handling comments should be deferred to
-  // when Javapoet is adopted
-  private String generatedComment;
-
-  Modifiable() {
-    this.modifiers = EnumSet.noneOf(Modifier.class);
-    this.annotations = Lists.newArrayList();
-  }
-
-  public void addModifiers(Modifier first, Modifier... rest) {
-    addModifiers(Lists.asList(first, rest));
-  }
-
-  public void addModifiers(Iterable<Modifier> modifiers) {
-    Iterables.addAll(this.modifiers, modifiers);
-  }
-
-  public AnnotationWriter annotate(ClassName annotation) {
-    AnnotationWriter annotationWriter = new AnnotationWriter(annotation);
-    this.annotations.add(annotationWriter);
-    return annotationWriter;
-  }
-
-  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
-    return annotate(ClassName.fromClass(annotation));
-  }
-
-  public void markGenerated(boolean generatedAnnotationAvailable) {
-    if (generatedAnnotationAvailable) {
-      AnnotationWriter annotation = annotate(Generated.class);
-      annotation.setValue(ComponentProcessor.class.getName());
-      annotation.setMember("comments", GENERATED_COMMENTS);
-    } else {
-      generatedComment =
-          String.format(
-              "// Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
-    }
-  }
-
-  Appendable writeModifiers(Appendable appendable) throws IOException {
-    for (Modifier modifier : modifiers) {
-      appendable.append(modifier.toString()).append(' ');
-    }
-    return appendable;
-  }
-
-  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {
-    for (AnnotationWriter annotationWriter : annotations) {
-      annotationWriter.write(appendable, context).append('\n');
-    }
-    if (generatedComment != null) {
-      appendable.append(generatedComment).append('\n');
-    }
-    return appendable;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
deleted file mode 100644
index 0d3588b77..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-
-enum NullName implements TypeName {
-  NULL;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append("null");
-  }
-
-  @Override
-  public String toString() {
-    return "null";
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
deleted file mode 100644
index e46a96186..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Objects;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Verify.verify;
-
-public final class ParameterizedTypeName implements TypeName {
-  private final ClassName type;
-  private final ImmutableList<TypeName> parameters;
-
-  ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
-    this.type = type;
-    this.parameters = ImmutableList.<TypeName>copyOf(parameters);
-  }
-  
-  public ClassName type() {
-    return type;
-  }
-  
-  public ImmutableList<TypeName> parameters() {
-    return parameters;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>()
-        .add(type);
-    for (TypeName parameter : parameters) {
-      builder.addAll(parameter.referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(context.sourceReferenceForClassName(type));
-    Iterator<? extends TypeName> parameterIterator = parameters.iterator();
-    verify(parameterIterator.hasNext(), type.toString());
-    appendable.append('<');
-    parameterIterator.next().write(appendable, context);
-    while (parameterIterator.hasNext()) {
-      appendable.append(", ");
-      parameterIterator.next().write(appendable, context);
-    }
-    appendable.append('>');
-    return appendable;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof ParameterizedTypeName) {
-      ParameterizedTypeName that = (ParameterizedTypeName) obj;
-      return this.type.equals(that.type)
-          && this.parameters.equals(that.parameters);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(type, parameters);
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  public static ParameterizedTypeName create(ClassName className,
-      TypeName... parameters) {
-    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
-  }
-
-  public static ParameterizedTypeName create(ClassName className,
-      Iterable<? extends TypeName> parameters) {
-    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
-  }
-
-  public static ParameterizedTypeName create(Class<?> parameterizedClass,
-      TypeName... parameters) {
-    checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
-    return new ParameterizedTypeName(ClassName.fromClass(parameterizedClass),
-        ImmutableList.copyOf(parameters));
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
deleted file mode 100644
index 94961dd7a..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Ascii;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-import javax.lang.model.type.PrimitiveType;
-
-public enum PrimitiveName implements TypeName {
-  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public String toString() {
-    return Ascii.toLowerCase(name());
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append(toString());
-  }
-
-  static PrimitiveName forTypeMirror(PrimitiveType mirror) {
-    switch (mirror.getKind()) {
-      case BOOLEAN:
-        return BOOLEAN;
-      case BYTE:
-        return BYTE;
-      case SHORT:
-        return SHORT;
-      case INT:
-        return INT;
-      case LONG:
-        return LONG;
-      case CHAR:
-        return CHAR;
-      case FLOAT:
-        return FLOAT;
-      case DOUBLE:
-        return DOUBLE;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static PrimitiveName forClass(Class<?> primitiveClass) {
-    if (boolean.class.equals(primitiveClass)) {
-      return BOOLEAN;
-    }
-    if (byte.class.equals(primitiveClass)) {
-      return BYTE;
-    }
-    if (short.class.equals(primitiveClass)) {
-      return SHORT;
-    }
-    if (int.class.equals(primitiveClass)) {
-      return INT;
-    }
-    if (long.class.equals(primitiveClass)) {
-      return LONG;
-    }
-    if (char.class.equals(primitiveClass)) {
-      return CHAR;
-    }
-    if (float.class.equals(primitiveClass)) {
-      return FLOAT;
-    }
-    if (double.class.equals(primitiveClass)) {
-      return DOUBLE;
-    }
-    throw new IllegalArgumentException(primitiveClass + " is not a primitive type");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
deleted file mode 100644
index 80ab944f8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Formatter;
-import java.util.Iterator;
-import java.util.Set;
-
-public abstract class Snippet implements HasClassReferences, Writable {
-
-  abstract ImmutableSet<TypeName> types();
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  @Override
-  public final Set<ClassName> referencedClasses() {
-    return FluentIterable.from(types())
-        .transformAndConcat(
-            new Function<TypeName, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(TypeName input) {
-                return input.referencedClasses();
-              }
-            })
-        .toSet();
-  }
-
-  private static final class BasicSnippet extends Snippet {
-    final String format;
-    final ImmutableSet<TypeName> types;
-    final ImmutableList<Object> args;
-
-    BasicSnippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
-      this.format = format;
-      this.types = types;
-      this.args = args;
-    }
-
-    @Override
-    ImmutableSet<TypeName> types() {
-      return types;
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
-      for (Object arg : args) {
-        if (arg instanceof Writable) {
-          formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
-        } else {
-          formattedArgsBuilder.add(arg);
-        }
-      }
-
-      @SuppressWarnings("resource") // intentionally don't close the formatter
-      Formatter formatter = new Formatter(appendable);
-      formatter.format(format, Iterables.toArray(formattedArgsBuilder.build(), Object.class));
-
-      return appendable;
-    }
-  }
-
-  private static final class CompoundSnippet extends Snippet {
-    final String joinToken;
-    final ImmutableList<Snippet> snippets;
-
-    CompoundSnippet(String joinToken, ImmutableList<Snippet> snippets) {
-      this.joinToken = joinToken;
-      this.snippets = snippets;
-    }
-
-    @Override
-    ImmutableSet<TypeName> types() {
-      return FluentIterable.from(snippets)
-          .transformAndConcat(
-              new Function<Snippet, Iterable<TypeName>>() {
-                @Override
-                public Iterable<TypeName> apply(Snippet input) {
-                  return input.types();
-                }
-              })
-          .toSet();
-    }
-
-    @Override
-    public Appendable write(Appendable appendable, Context context) throws IOException {
-      Iterator<Snippet> snippetIterator = snippets.iterator();
-      if (snippetIterator.hasNext()) {
-        Snippet firstSnippet = snippetIterator.next();
-        firstSnippet.write(appendable, context);
-        while (snippetIterator.hasNext()) {
-          Snippet nextSnippet = snippetIterator.next();
-          appendable.append(joinToken);
-          nextSnippet.write(appendable, context);
-        }
-      }
-      return appendable;
-    }
-  }
-
-  public static Snippet format(String format, Object... args) {
-    ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
-    for (Object arg : args) {
-      if (arg instanceof Snippet) {
-        types.addAll(((Snippet) arg).types());
-      }
-      if (arg instanceof TypeName) {
-        types.add((TypeName) arg);
-      }
-      if (arg instanceof HasTypeName) {
-        types.add(((HasTypeName) arg).name());
-      }
-    }
-    return new BasicSnippet(format, types.build(), ImmutableList.copyOf(args));
-  }
-
-  public static Snippet format(String format, Iterable<? extends Object> args) {
-    return format(format, Iterables.toArray(args, Object.class));
-  }
-
-  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {
-    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), "%s")),
-        selectors);
-  }
-
-  public static Snippet nullCheck(Object thingToCheck) {
-    return format("if (%s == null) { throw new NullPointerException(); } ", thingToCheck);
-  }
-
-  public static Snippet nullCheck(Object thingToCheck, String message) {
-    return format("if (%s == null) { throw new NullPointerException(%s); } ",
-        thingToCheck,
-        StringLiteral.forValue(message));
-  }
-
-  public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
-    return join(", ", parameterSnippets);
-  }
-
-  /**
-   * A snippet that concatenates its arguments with each snippet separated by a new line.
-   */
-  public static Snippet concat(Iterable<Snippet> snippets) {
-    return join("\n", snippets);
-  }
-
-  /**
-   * A snippet that joins its arguments with {@code joiner}.
-   */
-  public static Snippet join(String joinToken, Iterable<Snippet> snippets) {
-    return new CompoundSnippet(joinToken, ImmutableList.copyOf(snippets));
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
deleted file mode 100644
index 2d059f9af..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.util.Formatter;
-
-/**
- * Represents a string literal as found in Java source code.
- */
-public final class StringLiteral {
-  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */
-  public static StringLiteral forValue(String value) {
-    return new StringLiteral(value, stringLiteral(value));
-  }
-
-  /** Returns the string literal representing {@code data}, including wrapping quotes. */
-  private static String stringLiteral(String value) {
-    StringBuilder result = new StringBuilder();
-    result.append('"');
-    for (int i = 0; i < value.length(); i++) {
-      char c = value.charAt(i);
-      switch (c) {
-        case '"':
-          result.append("\\\"");
-          break;
-        case '\\':
-          result.append("\\\\");
-          break;
-        case '\b':
-          result.append("\\b");
-          break;
-        case '\t':
-          result.append("\\t");
-          break;
-        case '\n':
-          result.append("\\n");
-          break;
-        case '\f':
-          result.append("\\f");
-          break;
-        case '\r':
-          result.append("\\r");
-          break;
-        default:
-          if (Character.isISOControl(c)) {
-            new Formatter(result).format("\\u%04x", (int) c);
-          } else {
-            result.append(c);
-          }
-      }
-    }
-    result.append('"');
-    return result.toString();
-  }
-
-  private final String value;
-  private final String literal;
-
-  private StringLiteral(String value, String literal) {
-    this.value = value;
-    this.literal = literal;
-  }
-
-  public String value() {
-    return value;
-  }
-
-  public String literal() {
-    return literal;
-  }
-
-  @Override
-  public String toString() {
-    return literal;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == this) {
-      return true;
-    } else if (obj instanceof StringLiteral) {
-      return this.value.equals(((StringLiteral) obj).value);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return value.hashCode();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
deleted file mode 100644
index e0daf5312..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-public interface TypeName extends HasClassReferences, Writable {
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
deleted file mode 100644
index 4bc234739..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.NoType;
-import javax.lang.model.type.NullType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-public final class TypeNames {
-  static final Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
-      new Function<TypeMirror, TypeName>() {
-        @Override public TypeName apply(TypeMirror input) {
-          return forTypeMirror(input);
-        }
-      };
-
-  public static TypeName forClass(Class<?> clazz) {
-    if (clazz.isPrimitive()) {
-      return PrimitiveName.forClass(clazz);
-    } else if (void.class.equals(clazz)) {
-      return VoidName.VOID;
-    } else if (clazz.isArray()) {
-      return new ArrayTypeName(forClass(clazz.getComponentType()));
-    } else {
-      return ClassName.fromClass(clazz);
-    }
-  }
-
-  public static TypeName forTypeMirror(TypeMirror mirror) {
-    return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
-      @Override
-      protected TypeName defaultAction(TypeMirror e, Void p) {
-        throw new IllegalArgumentException(e.toString());
-      }
-      
-      @Override
-      public TypeName visitTypeVariable(TypeVariable t, Void p) {
-        return TypeVariableName.fromTypeVariable(t);
-      }
-
-      @Override
-      public ArrayTypeName visitArray(ArrayType t, Void p) {
-        return new ArrayTypeName(t.getComponentType().accept(this, null));
-      }
-
-      @Override
-      public TypeName visitDeclared(DeclaredType t, Void p) {
-        return t.getTypeArguments().isEmpty()
-            ? ClassName.fromTypeElement((TypeElement) t.asElement())
-            : new ParameterizedTypeName(
-                ClassName.fromTypeElement((TypeElement) t.asElement()),
-                FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));
-      }
-
-      @Override
-      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {
-        return PrimitiveName.forTypeMirror(t);
-      }
-
-      @Override
-      public WildcardName visitWildcard(WildcardType t, Void p) {
-        return WildcardName.forTypeMirror(t);
-      }
-
-      @Override
-      public NullName visitNull(NullType t, Void p) {
-        return NullName.NULL;
-      }
-
-      @Override
-      public TypeName visitNoType(NoType t, Void p) {
-        switch (t.getKind()) {
-          case VOID:
-            return VoidName.VOID;
-          case PACKAGE:
-            throw new IllegalArgumentException();
-          default:
-            throw new IllegalStateException();
-        }
-      }
-    }, null);
-  }
-
-  private TypeNames() {
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
deleted file mode 100644
index c6ee533ca..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Objects;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-
-public final class TypeVariableName implements TypeName {
-  private final CharSequence name;
-  private final Iterable<? extends TypeName> extendsBounds;
-
-  TypeVariableName(CharSequence name, Iterable<? extends TypeName> extendsBounds) {
-    this.name = name;
-    this.extendsBounds = extendsBounds;
-  }
-
-  public CharSequence name() {
-    return name;
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    for (TypeName bound : extendsBounds) {
-      builder.addAll(bound.referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append(name);
-    if (!Iterables.isEmpty(extendsBounds)) {
-      appendable.append(" extends ");
-      Iterator<? extends TypeName> iter = extendsBounds.iterator();
-      iter.next().write(appendable, context);
-      while (iter.hasNext()) {
-        appendable.append(" & ");
-        iter.next().write(appendable, context);  
-      }
-    }
-    return appendable;
-  }
-
-  @Override
-  public String toString() {
-    return Writables.writeToString(this);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof TypeVariableName) {
-      TypeVariableName that = (TypeVariableName) obj;
-      return this.name.toString().equals(that.name.toString())
-          && this.extendsBounds.equals(that.extendsBounds);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return Objects.hashCode(name, extendsBounds);
-  }
-
-  static TypeVariableName named(CharSequence name) {
-    return new TypeVariableName(name, ImmutableList.<TypeName>of());
-  }
-  
-  public static TypeVariableName fromTypeVariable(TypeVariable variable) {
-    // Note: We don't have any use right now for the bounds because these are references
-    // to the type & not the specification of the type itself.  We never generate
-    // code with type variables that include upper or lower bounds.
-    return named(variable.asElement().getSimpleName());
-  }
-
-  // TODO(sameb): Consider making this a whole different thing: TypeParameterName since it
-  // has different semantics than a TypeVariable (parameters only have upper bounds).
-  public static TypeVariableName fromTypeParameterElement(TypeParameterElement element) {
-    // We filter out bounds of type Object because those would just clutter the generated code.
-    Iterable<? extends TypeName> bounds =
-        FluentIterable.from(element.getBounds())
-            .filter(new Predicate<TypeMirror>() {
-              @Override public boolean apply(TypeMirror input) {
-                return !MoreTypes.isType(input) || !MoreTypes.isTypeOf(Object.class, input);
-              }
-            })
-            .transform(TypeNames.FOR_TYPE_MIRROR);
-    return new TypeVariableName(element.getSimpleName(), bounds);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
deleted file mode 100644
index b13d0831e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.util.List;
-import java.util.Map;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Only named types. Doesn't cover anonymous inner classes.
- */
-public abstract class TypeWriter /* ha ha */ extends Modifiable
-    implements Writable, HasTypeName, HasClassReferences {
-  final ClassName name;
-  final List<TypeName> implementedTypes;
-  final List<MethodWriter> methodWriters;
-  final List<TypeWriter> nestedTypeWriters;
-  final Map<String, FieldWriter> fieldWriters;
-
-  TypeWriter(ClassName name) {
-    this.name = name;
-    this.implementedTypes = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
-    this.nestedTypeWriters = Lists.newArrayList();
-    this.fieldWriters = Maps.newLinkedHashMap();
-  }
-
-  @Override
-  public ClassName name() {
-    return name;
-  }
-
-  public MethodWriter addMethod(TypeWriter returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeMirror returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeName returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(Class<?> returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(ClassName.fromClass(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public ClassWriter addNestedClass(String name) {
-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
-    nestedTypeWriters.add(innerClassWriter);
-    return innerClassWriter;
-  }
-
-  public void addImplementedType(TypeName typeReference) {
-    implementedTypes.add(typeReference);
-  }
-
-  public void addImplementedType(TypeElement typeElement) {
-    implementedTypes.add(ClassName.fromTypeElement(typeElement));
-  }
-
-  public FieldWriter addField(Class<?> type, String name) {
-    return addField(ClassName.fromClass(type), name);
-  }
-
-  public FieldWriter addField(TypeElement type, String name) {
-    return addField(ClassName.fromTypeElement(type), name);
-  }
-
-  public FieldWriter addField(TypeName type, String name) {
-    String candidateName = name;
-    int differentiator = 1;
-    while (fieldWriters.containsKey(candidateName)) {
-      candidateName = name + differentiator;
-      differentiator++;
-    }
-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
-    fieldWriters.put(candidateName, fieldWriter);
-    return fieldWriter;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
deleted file mode 100644
index 58ee1e494..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import java.io.IOException;
-import java.util.Set;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
-  private final TypeName type;
-  private final String name;
-
-  VariableWriter(TypeName type, String name) {
-    this.type = checkNotNull(type);
-    this.name = checkNotNull(name);
-  }
-
-  public TypeName type() {
-    return type;
-  }
-
-  public String name() {
-    return name;
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    writeAnnotations(appendable, context);
-    writeModifiers(appendable);
-    type.write(appendable, context);
-    return appendable.append(' ').append(name);
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
-        .append(annotations)
-        .append(type)
-        .transformAndConcat(HasClassReferences.COMBINER)
-        .toSet();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
deleted file mode 100644
index f82a4cab4..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-
-public enum VoidName implements TypeName {
-  VOID;
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of();
-  }
-
-  @Override
-  public String toString() {
-    return "void";
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append("void");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
deleted file mode 100644
index 7756f9311..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
-import java.io.IOException;
-import java.util.Set;
-import javax.lang.model.type.WildcardType;
-
-import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;
-
-public final class WildcardName implements TypeName {
-  private final Optional<TypeName> extendsBound;
-  private final Optional<TypeName> superBound;
-
-  WildcardName(Optional<TypeName> extendsBound,
-      Optional<TypeName> superBound) {
-    this.extendsBound = extendsBound;
-    this.superBound = superBound;
-  }
-
-  static WildcardName forTypeMirror(WildcardType mirror) {
-    return new WildcardName(
-        Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),
-        Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));
-  }
-
-  @Override
-  public Set<ClassName> referencedClasses() {
-    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    if (extendsBound.isPresent()) {
-      builder.addAll(extendsBound.get().referencedClasses());
-    }
-    if (superBound.isPresent()) {
-      builder.addAll(superBound.get().referencedClasses());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    appendable.append('?');
-    if (extendsBound.isPresent()) {
-      appendable.append(" extends ");
-      extendsBound.get().write(appendable, context);
-    }
-    if (superBound.isPresent()) {
-      appendable.append(" super ");
-      superBound.get().write(appendable, context);
-    }
-    return appendable;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
deleted file mode 100644
index 9a88f433d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import java.io.IOException;
-import java.util.Set;
-
-interface Writable {
-  interface Context {
-    String sourceReferenceForClassName(ClassName className);
-    Context createSubcontext(Set<ClassName> newTypes);
-  }
-
-  Appendable write(Appendable appendable, Context context) throws IOException;
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
deleted file mode 100644
index 0186cbfcf..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import dagger.internal.codegen.writer.Writable.Context;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Set;
-
-final class Writables {
-
-  /**
-   * Joins the writables by the given delimiter, writing out the
-   * prefix & suffix if there's at least one element.
-   */
-  static void join(String delimiter, Iterable<? extends Writable> writables,
-      String prefix, String suffix,
-      Appendable appendable, Context context) throws IOException {
-    Iterator<? extends Writable> iter = writables.iterator();
-    if (iter.hasNext()) {
-      appendable.append(prefix);
-      iter.next().write(appendable, context);
-      while (iter.hasNext()) {
-        appendable.append(delimiter);
-        iter.next().write(appendable, context);
-      }
-      appendable.append(suffix);
-    }
-  }
-
-  /** Joins the writables by the given delimiter. */
-  static void join(String delimiter, Iterable<? extends Writable> writables,
-      Appendable appendable, Context context) throws IOException {
-    join(delimiter, writables, "", "", appendable, context);
-  }
-
-  static Writable toStringWritable(final Object object) {
-    return new Writable() {
-      @Override
-      public Appendable write(Appendable appendable, Context context) throws IOException {
-        return appendable.append(object.toString());
-      }
-    };
-  }
-
-  private static final Context DEFAULT_CONTEXT = new Context() {
-    @Override
-    public String sourceReferenceForClassName(ClassName className) {
-      return className.canonicalName();
-    }
-
-    @Override
-    public Context createSubcontext(Set<ClassName> newTypes) {
-      throw new UnsupportedOperationException();
-    }
-  };
-
-  static String writeToString(Writable writable) {
-    StringBuilder builder = new StringBuilder();
-    try {
-      writable.write(builder, DEFAULT_CONTEXT);
-    } catch (IOException e) {
-      throw new AssertionError("StringBuilder doesn't throw IOException" + e);
-    }
-    return builder.toString();
-  }
-
-  private Writables() {
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 164d21d9a..d389dfcb1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -23,8 +23,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
-import dagger.internal.codegen.writer.StringLiteral;
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
@@ -52,8 +52,8 @@
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
-  private static final StringLiteral NPE_LITERAL =
-      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  private static final CodeBlock NPE_LITERAL =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index f79cdbb8d..cda08be2d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,8 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import dagger.Provides;
-import dagger.internal.codegen.writer.StringLiteral;
+import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,8 +47,8 @@
       "package test;",
       "public @interface Nullable {}");
 
-  private static final StringLiteral NPE_LITERAL =
-      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+  private static final CodeBlock NPE_LITERAL =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
deleted file mode 100644
index eff01b849..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.CompilationRule;
-import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;
-import java.util.Map;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class ClassNameTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  @Test public void bestGuessForString_simpleClass() {
-    assertThat(ClassName.bestGuessFromString(String.class.getName()))
-        .isEqualTo(ClassName.create("java.lang", "String"));
-  }
-
-  static class OuterClass {
-    static class InnerClass {}
-  }
-
-  @Test public void bestGuessForString_nestedClass() {
-    assertThat(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
-        .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
-    assertThat(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
-        .isEqualTo(
-            ClassName.create("dagger.internal.codegen.writer",
-                ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
-  }
-
-  @Test public void bestGuessForString_defaultPackage() {
-    assertThat(ClassName.bestGuessFromString("SomeClass"))
-        .isEqualTo(ClassName.create("", "SomeClass"));
-    assertThat(ClassName.bestGuessFromString("SomeClass.Nested"))
-        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
-    assertThat(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
-        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
-  }
-
-  @Test public void bestGuessForString_confusingInput() {
-    try {
-      ClassName.bestGuessFromString("com.test.$");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-    try {
-      ClassName.bestGuessFromString("com.test.LooksLikeAClass.pkg");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-    try {
-      ClassName.bestGuessFromString("!@#$gibberish%^&*");
-      fail();
-    } catch (IllegalArgumentException expected) {}
-  }
-
-  @Test public void classNameFromTypeElement() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
-    assertThat(ClassName.fromTypeElement(element).canonicalName())
-        .isEqualTo("java.lang.Object");
-  }
-
-  @Test public void peerNamed_topLevelClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.Foo");
-  }
-
-  @Test public void peerNamed_nestedClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.Foo");
-  }
-
-  @Test public void peerNamed_deeplyNestedClass() {
-    Elements elements = compilationRule.getElements();
-    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
-    ClassName className = ClassName.fromTypeElement(element);
-    ClassName peerName = className.peerNamed("Foo");
-    assertThat(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo");
-  }
-
-  @Test public void fromClass_NonNestedClass() {
-    ClassName className = ClassName.fromClass(ClassNameTest.class);
-    assertThat(className.canonicalName()).isEqualTo(
-        "dagger.internal.codegen.writer.ClassNameTest");
-  }
-
-  @Test public void fromClass_NestedClass() {
-    ClassName className = ClassName.fromClass(InnerClass.class);
-    assertThat(className.canonicalName()).isEqualTo(
-        "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
-  }
-
-  @Test public void fromClass_classFileName() {
-    ClassName className = ClassName.fromClass(InnerClass.class);
-    assertThat(className.classFileName('_')).isEqualTo("ClassNameTest_OuterClass_InnerClass");
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
deleted file mode 100644
index e775f7487..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class JavaWriterTest {
-  @Test public void referencedAndDeclaredSimpleName() {
-    JavaWriter javaWriter = JavaWriter.inPackage("test");
-    ClassWriter topClass = javaWriter.addClass("Top");
-    topClass.addNestedClass("Middle").addNestedClass("Bottom");
-    topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
-    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
deleted file mode 100644
index ec82e9605..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.writer;
-
-import com.google.testing.compile.CompilationRule;
-import java.nio.charset.Charset;
-import java.util.Set;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class TypeNamesTest {
-  @Rule public final CompilationRule compilation = new CompilationRule();
-
-  private TypeElement getElement(Class<?> clazz) {
-    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
-  }
-
-  private TypeMirror getType(Class<?> clazz) {
-    return getElement(clazz).asType();
-  }
-
-  @Test
-  public void forTypeMirror_basicTypes() {
-    assertThat(TypeNames.forTypeMirror(getType(Object.class)))
-        .isEqualTo(ClassName.fromClass(Object.class));
-    assertThat(TypeNames.forTypeMirror(getType(Charset.class)))
-        .isEqualTo(ClassName.fromClass(Charset.class));
-    assertThat(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
-        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
-  }
-
-  @Test
-  public void forTypeMirror_parameterizedType() {
-    DeclaredType setType =
-        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
-    assertThat(TypeNames.forTypeMirror(setType))
-        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
-  }
-
-  @Test
-  public void forTypeMirror_typeVariables() {
-    TypeMirror setType = getType(Set.class);
-    assertThat(TypeNames.forTypeMirror(setType))
-        .isEqualTo(ParameterizedTypeName.create(Set.class, TypeVariableName.named("E")));
-  }
-
-  @Test
-  public void forTypeMirror_primitive() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
-        .isEqualTo(PrimitiveName.BOOLEAN);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
-        .isEqualTo(PrimitiveName.BYTE);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
-        .isEqualTo(PrimitiveName.SHORT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
-        .isEqualTo(PrimitiveName.INT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
-        .isEqualTo(PrimitiveName.LONG);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
-        .isEqualTo(PrimitiveName.CHAR);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
-        .isEqualTo(PrimitiveName.FLOAT);
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
-        .isEqualTo(PrimitiveName.DOUBLE);
-  }
-
-  @Test
-  public void forTypeMirror_arrays() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
-        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
-  }
-
-  @Test
-  public void forTypeMirror_void() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
-        .isEqualTo(VoidName.VOID);
-  }
-
-  @Test
-  public void forTypeMirror_null() {
-    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
-        .isEqualTo(NullName.NULL);
-  }
-}
