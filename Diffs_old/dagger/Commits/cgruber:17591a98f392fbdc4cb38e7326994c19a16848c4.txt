diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index f00d9f4b3..49ce70c5b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -51,11 +51,16 @@
     Elements elements = compilationRule.getElements();
     TypeElement inner = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
-    assertThat(MethodSignatureFormatter.instance().format(method))
-        .isEqualTo(
-            "@dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.Foo(bar=String.class)"
-            + " @Singleton String "
-            + "dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.InnerClass.foo"
-            + "(int, ImmutableList<Boolean>)");
+    String formatted = MethodSignatureFormatter.instance().format(method);
+    // This is gross, but it turns out that annotation order is not guaranteed when getting
+    // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
+    // less brittle.
+    assertThat(formatted).contains("@Singleton");
+    assertThat(formatted).doesNotContain("@javax.inject.Singleton"); // maybe more importantly
+    assertThat(formatted)
+        .contains("@dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.Foo"
+            + "(bar=String.class)");
+    assertThat(formatted).contains(" String "); // return type compressed
+    assertThat(formatted).contains("int, ImmutableList<Boolean>)"); // parameters compressed.
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
index 5da543e55..27e08263f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -48,7 +48,7 @@
         .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
     assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
         .isEqualTo(
-            ClassName.create("dagger.internal.codegen",
+            ClassName.create("dagger.internal.codegen.writer",
                 ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
   }
 
@@ -89,7 +89,7 @@
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
     assert_().that(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.Foo");
+        .isEqualTo("dagger.internal.codegen.writer.Foo");
   }
 
   @Test public void peerNamed_nestedClass() {
@@ -98,7 +98,7 @@
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
     assert_().that(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.ClassNameTest.Foo");
+        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.Foo");
   }
 
   @Test public void peerNamed_deeplyNestedClass() {
@@ -107,6 +107,6 @@
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
     assert_().that(peerName.canonicalName())
-        .isEqualTo("dagger.internal.codegen.ClassNameTest.OuterClass.Foo");
+        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo");
   }
 }
