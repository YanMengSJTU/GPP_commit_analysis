diff --git a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java b/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
index f2ecb5b56..bb2668b22 100644
--- a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
@@ -65,7 +65,7 @@
   }
 
   @Override
-  CodeBlock body(ClassName requestingClass) {
+  CodeBlock body() {
     // TODO(user): split this class into 1 class for each request?
     switch (requestKind()) {
       case PROVIDER:
@@ -85,7 +85,7 @@ CodeBlock body(ClassName requestingClass) {
       default:
         break;
     }
-    return super.body(requestingClass);
+    return super.body();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index eb90fc076..3a8b81326 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -60,13 +60,17 @@ final ResolvedBindings resolvedBindings() {
    */
   abstract Expression getDependencyExpression(ClassName requestingClass);
 
-  /** Returns an expression for the implementation of a component method with the given request. */
+  /**
+   * Returns an expression for the implementation of a component method with the given request.
+   *
+   * @param componentName the component that will contain the implemented method
+   */
   final CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName requestingClass) {
+      ComponentMethodDescriptor componentMethod, ClassName componentName) {
     DependencyRequest request = componentMethod.dependencyRequest().get();
     checkArgument(request.key().equals(key()));
     checkArgument(request.kind().equals(requestKind()));
-    return doGetComponentMethodImplementation(componentMethod, requestingClass);
+    return doGetComponentMethodImplementation(componentMethod, componentName);
   }
 
   /**
@@ -74,10 +78,12 @@ final CodeBlock getComponentMethodImplementation(
    *
    * <p>This method is called only if {@code componentMethod}'s request key and kind matches this
    * binding expression's.
+   *
+   * @param componentName the component that will contain the implemented method
    */
   protected CodeBlock doGetComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName requestingClass) {
+      ComponentMethodDescriptor componentMethod, ClassName componentName) {
     // By default, just delegate to #getDependencyExpression().
-    return CodeBlock.of("return $L;", getDependencyExpression(requestingClass).codeBlock());
+    return CodeBlock.of("return $L;", getDependencyExpression(componentName).codeBlock());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
index 43a5d9079..8ac498b34 100644
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/BindingMethodImplementation.java
@@ -56,9 +56,9 @@
    * <p>If the implementation has a non-void return type, the body will also include the {@code
    * return} statement.
    */
-  CodeBlock body(ClassName requestingClass) {
+  CodeBlock body() {
     return CodeBlock.of(
-        "return $L;", bindingExpression.getDependencyExpression(requestingClass).codeBlock());
+        "return $L;", bindingExpression.getDependencyExpression(componentName).codeBlock());
   }
 
   /** Returns the return type for the dependency request. */
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 8027d57bb..64d316e4f 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -494,7 +494,7 @@ private BindingExpression provisionBindingExpression(
             resolvedBindings,
             requestKind,
             methodImplementation(inlineBindingExpression),
-            generatedComponentModel.name(),
+            generatedComponentModel,
             componentMethod.get(),
             componentBindingExpressions);
       } else if (shouldUsePrivateMethod(resolvedBindings.contributionBinding(), requestKind)) {
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 9c734d28d..d4aeb8fc3 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -31,7 +31,7 @@
  */
 final class ComponentMethodBindingExpression extends BindingExpression {
   private final BindingMethodImplementation methodImplementation;
-  private final ClassName componentName;
+  private final GeneratedComponentModel generatedComponentModel;
   private final ComponentMethodDescriptor componentMethod;
   private final ComponentBindingExpressions componentBindingExpressions;
 
@@ -39,24 +39,32 @@
       ResolvedBindings resolvedBindings,
       RequestKind requestKind,
       BindingMethodImplementation methodImplementation,
-      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
       ComponentMethodDescriptor componentMethod,
       ComponentBindingExpressions componentBindingExpressions) {
     super(resolvedBindings, requestKind);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.componentName = checkNotNull(componentName);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentMethod = checkNotNull(componentMethod);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
   @Override
   protected CodeBlock doGetComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName requestingClass) {
-    // There could be multiple component methods with the same request key and kind. We designate
-    // the component method passed into the constructor to contain the implementation code.
-    return this.componentMethod.equals(componentMethod)
-        ? methodImplementation.body(requestingClass)
-        : super.doGetComponentMethodImplementation(componentMethod, requestingClass);
+      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+    // There could be several methods on the component for the same request key and kind.
+    // Only one should use the BindingMethodImplementation; the others can delegate that one. So
+    // use methodImplementation.body() only if componentMethod equals the method for this instance.
+    
+    // Separately, the method might be defined on a supertype that is also a supertype of some
+    // parent component. In that case, the same ComponentMethodDescriptor will be used to add a CMBE
+    // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
+    // the child's can delegate to the parent. So use methodImplementation.body() only if
+    // componentName equals the component for this instance.
+    return componentMethod.equals(this.componentMethod)
+            && componentName.equals(generatedComponentModel.name())
+        ? methodImplementation.body()
+        : super.doGetComponentMethodImplementation(componentMethod, componentName);
   }
 
   @Override
@@ -64,8 +72,8 @@ Expression getDependencyExpression(ClassName requestingClass) {
     MethodSpec implementedMethod = componentBindingExpressions.getComponentMethod(componentMethod);
     return Expression.create(
         methodImplementation.returnType(),
-        componentName.equals(requestingClass)
+        requestingClass.equals(generatedComponentModel.name())
             ? CodeBlock.of("$N()", implementedMethod)
-            : CodeBlock.of("$T.this.$N()", componentName, implementedMethod));
+            : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), implementedMethod));
   }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index 8b0bb3125..faa230d6d 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -51,7 +51,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock doGetComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName requestingClass) {
+      ComponentMethodDescriptor componentMethod, ClassName componentName) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 506fe5910..224c89289 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -54,7 +54,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
       methodName = generatedComponentModel.getUniqueMethodName(methodName());
-      createMethod(methodName, requestingClass);
+      createMethod(methodName);
     }
 
     // TODO(user): This logic is repeated in multiple places. Can we extract it somewhere?
@@ -67,7 +67,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   }
 
   /** Creates the no-arg method used for dependency expressions. */
-  private void createMethod(String name, ClassName requestingClass) {
+  private void createMethod(String name) {
     // TODO(user): Consider when we can make this method static.
     // TODO(user): Fix the order that these generated methods are written to the component.
     generatedComponentModel.addMethod(
@@ -75,7 +75,7 @@ private void createMethod(String name, ClassName requestingClass) {
         methodBuilder(name)
             .addModifiers(PRIVATE)
             .returns(TypeName.get(methodImplementation.returnType()))
-            .addCode(methodImplementation.body(requestingClass))
+            .addCode(methodImplementation.body())
             .build());
   }
 
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index fba229d1f..3f5674e89 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2589,6 +2589,143 @@ public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
         .containsElementsIn(generatedComponent);
   }
 
+  @Test
+  public void privateMethodUsedOnlyInChildDoesNotUseQualifiedThis() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules=TestModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @Singleton static Number number() {",
+            "    return 3;",
+            "  }",
+            "",
+            "  @Provides static String string(Number number) {",
+            "    return number.toString();",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject expectedPattern =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private String getString() {",
+            "    return TestModule_StringFactory.proxyString(numberProvider.get());",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, testModule, child);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(expectedPattern);
+  }
+
+  @Test
+  public void componentMethodInChildCallsComponentMethodInParent() {
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  String string();",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules=TestModule.class)",
+            "interface Parent extends Supertype {",
+            "  Child child();",
+            "}");
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @Singleton static Number number() {",
+            "    return 3;",
+            "  }",
+            "",
+            "  @Provides static String string(Number number) {",
+            "    return number.toString();",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child extends Supertype {}");
+
+    JavaFileObject expectedPattern =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private final class ChildImpl implements Child {",
+            "    @Override",
+            "    public String string() {",
+            "      return DaggerParent.this.string();",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(supertype, parent, testModule, child);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(expectedPattern);
+  }
+
   private static Compiler daggerCompiler(Processor... extraProcessors) {
     return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
   }
