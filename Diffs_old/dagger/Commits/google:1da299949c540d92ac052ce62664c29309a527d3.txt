diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index a9c9360bf..50a55f6f9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -22,7 +22,10 @@
 import java.util.Map;
 import java.util.Set;
 import producerstest.ExecutorModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
@@ -65,4 +68,13 @@
 
   @ObjCount
   ListenableFuture<Integer> objCount();
+
+  @EmptyButDeclaredInModuleAndProducerModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModuleAndProducerModule();
+
+  @EmptyButDeclaredInModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModule();
+
+  @OnlyProvisionMultibindings
+  ListenableFuture<Map<String, Object>> onlyProvisionMultibindings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
index 5c5834f54..98a6e36a8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
@@ -22,10 +22,16 @@
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.multibindings.StringKey;
+import java.util.Map;
 import java.util.Set;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 
 @Module
-final class MultibindingModule {
+abstract class MultibindingModule {
   @Provides
   @IntoSet
   static String providedStr() {
@@ -44,4 +50,20 @@ static String providedStr() {
   static String providedValueFor3() {
     return "provided three";
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
+
+  @Multibinds
+  @EmptyButDeclaredInModule
+  abstract Map<String, Object> emptyButDeclaredInModule();
+
+  @Provides
+  @IntoMap
+  @StringKey("a")
+  @OnlyProvisionMultibindings
+  static Object onlyProvisionMultibindings() {
+    return "only multibinding";
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 8532686f8..ee80ede02 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -18,7 +18,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
@@ -27,14 +26,13 @@
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-
+import java.util.Map;
+import java.util.Set;
 import producerstest.multibindings.Qualifiers.ObjCount;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-import java.util.Map;
-import java.util.Set;
-
 @ProducerModule
 abstract class MultibindingProducerModule {
   @Produces
@@ -128,4 +126,8 @@ static String throwingValueFor15() {
   static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
     return objs.size() + objMap.size();
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
index c638270ed..7d754622e 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -15,8 +15,8 @@
  */
 package producerstest.multibindings;
 
-import java.lang.annotation.Retention;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -37,5 +37,20 @@
   @Qualifier
   @interface ObjCount {}
 
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModuleAndProducerModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface OnlyProvisionMultibindings {}
+
   private Qualifiers() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 3571b8b58..60a2e874d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -19,6 +19,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
@@ -31,12 +32,14 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Reusable;
 import dagger.Subcomponent;
-import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.Key.HasKey;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -50,6 +53,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -62,7 +66,9 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -351,7 +357,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
-            ImmutableSet.Builder<ContributionBinding> multibindingsBuilder = ImmutableSet.builder();
+            ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
+                ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
@@ -359,51 +366,24 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               contributionBindings.addAll(getExplicitBindings(key));
               contributionBindings.addAll(getDelegateBindings(key));
 
-              multibindingsBuilder.addAll(getExplicitMultibindings(key));
-              multibindingsBuilder.addAll(getDelegateMultibindings(key));
+              multibindingContributionsBuilder.addAll(getExplicitMultibindingContributions(key));
+              multibindingContributionsBuilder.addAll(getDelegateMultibindingContributions(key));
 
               multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
             }
 
-            if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProducerKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
-               * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
-               * binding that depends on Map<K, Producer<V>>. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
-            } else if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProviderKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
-               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
-               * or multibinding declarations, then add the synthetic binding that depends on
-               * Map<K, Provider<V>>. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMapOfValuesBinding(request));
-            }
-
-            ImmutableSet<ContributionBinding> multibindings = multibindingsBuilder.build();
+            ImmutableSet<ContributionBinding> multibindingContributions =
+                multibindingContributionsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
 
-            Iterable<? extends HasBindingType> multibindingsAndDeclarations =
-                Iterables.concat(multibindings, multibindingDeclarations);
-            if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
-              /* If there are production multibindings, add a synthetic binding that depends on each
-               * individual multibinding. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMultibinding(request, multibindings));
-            } else if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
-              /* If there are provision multibindings but not production ones, add a synthetic
-               * binding that depends on each individual multibinding. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMultibinding(request, multibindings));
-            }
+            contributionBindings.addAll(syntheticMapOfValuesBinding(request).asSet());
+            contributionBindings.addAll(
+                syntheticMultibinding(request, multibindingContributions, multibindingDeclarations)
+                    .asSet());
 
-            /* If there are still no bindings, look for an implicit @Inject- constructed binding if
-             * there is one. */
+            /* If there are no bindings, add the implicit @Inject-constructed binding if there is
+             * one. */
             if (contributionBindings.isEmpty()) {
               contributionBindings.addAll(
                   injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());
@@ -423,6 +403,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
                 : ResolvedBindings.noBindings(bindingKey, componentDescriptor);
+
           default:
             throw new AssertionError();
         }
@@ -431,28 +412,148 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
       private Iterable<Key> keysMatchingRequest(Key requestKey) {
         return ImmutableSet.<Key>builder()
             .add(requestKey)
-            .addAll(keyFactory.implicitSetKeyFromProduced(requestKey).asSet())
-            .addAll(keyFactory.implicitProviderMapKeyFromProducer(requestKey).asSet())
+            .addAll(keyFactory.unwrapSetKey(requestKey, Produced.class).asSet())
+            .addAll(keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).asSet())
+            .addAll(keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).asSet())
             .build();
       }
 
-      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey) {
-        if (!maybeKey.isPresent()) {
-          return false;
-        }
+      /**
+       * If {@code request} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are
+       * any multibinding contributions or declarations that apply to that map, returns a synthetic
+       * binding for the {@code request} that depends on an {@linkplain
+       * #syntheticMultibinding(DependencyRequest, Iterable, Iterable) underlying synthetic
+       * multibinding}.
+       *
+       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
+       * multibinding.
+       */
+      private Optional<ContributionBinding> syntheticMapOfValuesBinding(
+          final DependencyRequest request) {
+        return syntheticMultibinding(
+                request,
+                multibindingContributionsForValueMap(request.key()),
+                multibindingDeclarationsForValueMap(request.key()))
+            .transform(
+                new Function<ContributionBinding, ContributionBinding>() {
+                  @Override
+                  public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
+                    switch (syntheticMultibinding.bindingType()) {
+                      case PROVISION:
+                        return provisionBindingFactory.syntheticMapOfValuesBinding(request);
 
-        Key key = maybeKey.get();
-        if (!getExplicitMultibindings(key).isEmpty()
-            || !getMultibindingDeclarations(key).isEmpty()) {
-          return true;
+                      case PRODUCTION:
+                        return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(
+                            request);
+
+                      default:
+                        throw new VerifyException(syntheticMultibinding.toString());
+                    }
+                  }
+                });
+      }
+
+      /**
+       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private FluentIterable<ContributionBinding> multibindingContributionsForValueMap(
+          Key requestKey) {
+        return keyFactory
+            .implicitFrameworkMapKeys(requestKey)
+            .transformAndConcat(
+                new Function<Key, Iterable<ContributionBinding>>() {
+                  @Override
+                  public Iterable<ContributionBinding> apply(Key key) {
+                    return Iterables.concat(
+                        getExplicitMultibindingContributions(key),
+                        getDelegateMultibindingContributions(key));
+                  }
+                });
+      }
+
+      /**
+       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private FluentIterable<MultibindingDeclaration> multibindingDeclarationsForValueMap(
+          Key requestKey) {
+        return keyFactory
+            .implicitFrameworkMapKeys(requestKey)
+            .transformAndConcat(
+                new Function<Key, Iterable<MultibindingDeclaration>>() {
+                  @Override
+                  public Iterable<MultibindingDeclaration> apply(Key key) {
+                    return getMultibindingDeclarations(key);
+                  }
+                });
+      }
+
+      /**
+       * Returns a synthetic binding that depends on individual multibinding contributions.
+       *
+       * <p>If there are no {@code multibindingContributions} or {@code multibindingDeclarations},
+       * returns {@link Optional#absent()}.
+       *
+       * <p>If there are production {@code multibindingContributions} or the request is for any of
+       * the following types, returns a {@link ProductionBinding}.
+       *
+       * <ul>
+       * <li>{@link Producer Producer<SetOrMap>}
+       * <li>{@link Produced Produced<SetOrMap>}
+       * <li>{@link ListenableFuture ListenableFuture<SetOrMap>}
+       * <li>{@code Set<Produced<T>>}
+       * <li>{@code Map<K, Producer<V>>}
+       * <li>{@code Map<K, Produced<V>>}
+       * </ul>
+       *
+       * Otherwise, returns a {@link ProvisionBinding}.
+       */
+      private Optional<? extends ContributionBinding> syntheticMultibinding(
+          DependencyRequest request,
+          Iterable<ContributionBinding> multibindingContributions,
+          Iterable<MultibindingDeclaration> multibindingDeclarations) {
+        if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
+          return Optional.absent();
+        } else if (multibindingsRequireProduction(multibindingContributions, request)) {
+          return Optional.of(
+              productionBindingFactory.syntheticMultibinding(request, multibindingContributions));
+        } else {
+          return Optional.of(
+              provisionBindingFactory.syntheticMultibinding(request, multibindingContributions));
         }
+      }
 
-        for (ContributionBinding delegateMultibinding : getDelegateMultibindings(key)) {
-          if (delegateMultibinding.key().withoutBindingIdentifier().equals(key)) {
+      private boolean multibindingsRequireProduction(
+          Iterable<ContributionBinding> multibindingContributions, DependencyRequest request) {
+        switch (request.kind()) {
+          case PRODUCER:
+          case PRODUCED:
+          case FUTURE:
             return true;
-          }
+
+          case INSTANCE:
+          case LAZY:
+          case PROVIDER:
+          case PROVIDER_OF_LAZY:
+            if (MapType.isMap(request.key())) {
+              MapType mapType = MapType.from(request.key());
+              if (mapType.valuesAreTypeOf(Producer.class)
+                  || mapType.valuesAreTypeOf(Produced.class)) {
+                return true;
+              }
+            } else if (SetType.isSet(request.key())
+                && SetType.from(request.key()).elementsAreTypeOf(Produced.class)) {
+              return true;
+            }
+            return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
+
+          case MEMBERS_INJECTOR:
+          default:
+            throw new AssertionError(request.kind());
         }
-        return false;
       }
 
       private ImmutableSet<ContributionBinding> createDelegateBindings(
@@ -586,11 +687,12 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit multibindings whose key (minus its
-       * {@link Key#bindingIdentifier()}) matches the {@code requestKey} from this and all
-       * ancestor resolvers.
+       * Returns the explicit multibinding contributions whose key (minus its
+       * {@link Key#bindingIdentifier()}) matches the {@code requestKey} from this and all ancestor
+       * resolvers.
        */
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getExplicitMultibindingContributions(
+          Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
             ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
@@ -622,7 +724,8 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateBindings.build();
       }
 
-      private ImmutableSet<ContributionBinding> getDelegateMultibindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getDelegateMultibindingContributions(
+          Key requestKey) {
         if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
           // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All @IntoMap
           // requests must be for Map<K, Framework<V>>.
@@ -831,9 +934,8 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
     }
 
     /**
-     * Selects each item in {@code haveKeys} that has a {@link Key#bindingIdentifier()} and
-     * indexes them by its {@link HasKey#key()}, where each key has its
-     * {@link Key.BindingIdentifier} removed.
+     * Selects each item in {@code haveKeys} that has a {@link Key#bindingIdentifier()} and indexes
+     * them by its {@link HasKey#key()}, where each key has its binding identifier removed.
      */
     static <T extends HasKey>
         ImmutableSetMultimap<Key, T> multibindingsKeyedWithoutBindingIdentifiers(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index df2510ab4..16092010f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -937,6 +937,7 @@ void validateComponentScope() {
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
+    // TODO(b/29509141): Clarify the error.
     private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 724b7f766..757833900 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -23,6 +23,8 @@
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
@@ -55,6 +57,7 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.common.base.Optional.presentInstances;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -483,13 +486,25 @@ Key forProductionImplementationExecutor() {
           getClassElement(Executor.class).asType());
     }
 
+    /**
+     * If {@code requestKey} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns keys
+     * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
+     * the classpath).
+     */
+    FluentIterable<Key> implicitFrameworkMapKeys(Key requestKey) {
+      return FluentIterable.from(
+          presentInstances(
+              ImmutableList.of(
+                  implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))));
+    }
+
     /**
      * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
      * valid key can be inferred from the given key.  Specifically, if the key represents a
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Provider.class);
+      return wrapMapKey(possibleMapKey, Provider.class);
     }
 
     /**
@@ -499,8 +514,8 @@ Key forProductionImplementationExecutor() {
      * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
-          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+      return rewrapMapKey(possibleMapKey, Produced.class, Producer.class)
+          .or(wrapMapKey(possibleMapKey, Producer.class));
     }
 
     /**
@@ -534,14 +549,20 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       checkArgument(
           FrameworkTypes.isFrameworkType(
               elements.getTypeElement(newWrappingClass.getName()).asType()));
-      return maybeWrapMapValue(key, newWrappingClass).get();
+      return wrapMapKey(key, newWrappingClass).get();
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
-     * {@code Map<K, CurrentWrappingClass<V>>}.
+     * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
+     * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
+     * Optional#absent()}.
+     *
+     * <p>Returns {@link Optional#absent()} if {@code newWrappingClass} is not in the classpath.
+     *
+     * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
+     *     currentWrappingClass}
      */
-    private Optional<Key> maybeRewrapMapValue(
+    Optional<Key> rewrapMapKey(
         Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
       if (MapType.isMap(possibleMapKey)) {
@@ -564,10 +585,13 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, WrappingClass<V>>} if the input key represents a
-     * {@code Map<K, V>}.
+     * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
+     * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
+     * Otherwise returns {@link Optional#absent()}.
+     *
+     * <p>Returns {@link Optional#absent()} if {@code WrappingClass} is not in the classpath.
      */
-    private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
+    private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
       if (MapType.isMap(possibleMapKey)) {
         MapType mapType = MapType.from(possibleMapKey);
         if (!mapType.valuesAreTypeOf(wrappingClass)) {
@@ -587,28 +611,18 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     }
 
     /**
-     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
-     * {@code Set<Produced<T>>}.
+     * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
+     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#absent()}.
      */
-    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
-      if (MoreTypes.isType(possibleSetOfProducedKey.type())
-          && MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
-        TypeMirror argType =
-            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
-        if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
-          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
-          return Optional.of(possibleSetOfProducedKey.withType(types, setOf(producedArgType)));
+    Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
+      if (SetType.isSet(key)) {
+        SetType setType = SetType.from(key);
+        if (setType.elementsAreTypeOf(wrappingClass)) {
+          return Optional.of(
+              key.withType(types, setOf(setType.unwrappedElementType(wrappingClass))));
         }
       }
       return Optional.absent();
     }
-
-    /**
-     * Optionally extract a {@link Key} for a {@code Map<K, Provider<V>>} if the given key is for
-     * {@code Map<K, Producer<V>>}.
-     */
-    Optional<Key> implicitProviderMapKeyFromProducer(Key possibleMapOfProducerKey) {
-      return maybeRewrapMapValue(possibleMapOfProducerKey, Producer.class, Provider.class);
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 70cc61fde..85ef2d199 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -100,7 +100,7 @@ TypeMirror unwrappedValueType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(valuesAreTypeOf(wrappingClass));
+    checkState(valuesAreTypeOf(wrappingClass), "expected values to be %s: %s", wrappingClass, this);
     return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 9271e7c58..8f91d14fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -155,7 +155,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
       checkArgument(
           mapOfProducersKey.isPresent(),
-          "%s is not for a Map<K, V>",
+          "%s is not for a Map<K, V> or Map<K, Produced<V>>",
           requestForMapOfValuesOrProduced);
       DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 7e07427b9..5a73f5367 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -34,7 +34,6 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 
@@ -268,18 +267,21 @@ ContributionBinding contributionBinding() {
   }
 
   /**
-   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
+   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} but no
+   * {@link #bindings()}, returns {@link BindingType#PROVISION}.
    *
    * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
   @Override
   public BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", bindingKey());
+    if (bindings().isEmpty() && !multibindingDeclarations().isEmpty()) {
+      // Only multibinding declarations, so assume provision.
+      return BindingType.PROVISION;
+    }
     ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
-            .transform(BindingType.BINDING_TYPE)
-            .toSet();
-    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", bindings());
     return getOnlyElement(bindingTypes);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 0206ec7fd..8317ad07a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -148,29 +148,31 @@
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  @ProducerModule",
-        "  final class AModule {",
-        "    @Produces ListenableFuture<A> a() {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
+            "  interface AComponent {",
+            "    A getA();",
+            "  }",
+            "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
@@ -179,6 +181,65 @@
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
 
+  @Test
+  public void providingMultibindingWithProductions() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "  interface B {}",
+            "",
+            "  @Module",
+            "  static final class AModule {",
+            "    @Provides static A a(Map<String, Provider<Object>> map) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Provides @IntoMap @StringKey(\"a\") static Object aEntry() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class BModule {",
+            "    @Produces static B b(A a) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces @IntoMap @StringKey(\"b\") static Object bEntry() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(",
+            "      modules = {ExecutorModule.class, AModule.class, BModule.class})",
+            "  interface AComponent {",
+            "    ListenableFuture<B> b();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(EXECUTOR_MODULE, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
+        .in(component)
+        .onLine(43);
+  }
+
   @Test
   public void monitoringDependsOnUnboundType() {
     JavaFileObject component =
