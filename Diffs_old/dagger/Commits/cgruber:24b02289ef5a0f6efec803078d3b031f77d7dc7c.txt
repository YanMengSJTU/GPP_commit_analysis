diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
index 857bf2147..48e705cd5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
@@ -15,10 +15,10 @@
  */
 package test.bind;
 
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 
 @Module
 interface InterfaceModule {
-  @Bind Foo<Object> bindFooOfObjects(FooOfObjects impl);
+  @Binds Foo<Object> bindFooOfObjects(FooOfObjects impl);
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
index ee33c8d86..f884c8b8c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -15,7 +15,7 @@
  */
 package test.bind;
 
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
@@ -23,16 +23,16 @@
 
 @Module(includes = InterfaceModule.class)
 abstract class SimpleBindingModule {
-  @Bind
+  @Binds
   abstract Object bindObject(FooOfStrings impl);
 
-  @Bind
+  @Binds
   abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
 
-  @Bind
+  @Binds
   abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
 
-  @Bind
+  @Binds
   @Singleton
   @SomeQualifier
   abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java
index 3d094417b..453d5b099 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindMethodValidator.java
@@ -19,7 +19,7 @@
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
 import com.google.common.collect.Iterables;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.util.List;
@@ -66,7 +66,7 @@
       ValidationReport.Builder<ExecutableElement> builder =
           ValidationReport.about(bindMethodElement);
 
-      checkArgument(isAnnotationPresent(bindMethodElement, Bind.class));
+      checkArgument(isAnnotationPresent(bindMethodElement, Binds.class));
 
       Element enclosingElement = bindMethodElement.getEnclosingElement();
       if (!isAnnotationPresent(enclosingElement, Module.class)
@@ -91,7 +91,7 @@
         builder.addError(formatErrorMessage(BIND_METHOD_NOT_ABSTRACT), bindMethodElement);
       }
       TypeMirror returnType = bindMethodElement.getReturnType();
-      validateReturnType(Bind.class, builder, returnType);
+      validateReturnType(Binds.class, builder, returnType);
 
       List<? extends VariableElement> parameters = bindMethodElement.getParameters();
       if (parameters.size() == 1) {
@@ -105,7 +105,7 @@
             formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindMethodElement);
       }
 
-      validateUncheckedThrows(elements, types, bindMethodElement, Bind.class, builder);
+      validateUncheckedThrows(elements, types, bindMethodElement, Binds.class, builder);
 
       validateMethodQualifiers(builder, bindMethodElement);
 
@@ -118,10 +118,10 @@
   }
 
   private String formatErrorMessage(String msg) {
-    return String.format(msg, Bind.class.getSimpleName());
+    return String.format(msg, Binds.class.getSimpleName());
   }
 
   private String formatErrorMessage(String msg, String parameter) {
-    return String.format(msg, Bind.class.getSimpleName(), parameter);
+    return String.format(msg, Binds.class.getSimpleName(), parameter);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index bd4f516fe..223688b44 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -19,7 +19,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.Iterables;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
 import dagger.internal.codegen.SourceElement.HasSourceElement;
@@ -57,7 +57,7 @@ public ContributionType contributionType() {
 
     DelegateDeclaration create(
         ExecutableElement bindMethod, TypeElement contributingElement) {
-      checkArgument(MoreElements.isAnnotationPresent(bindMethod, Bind.class));
+      checkArgument(MoreElements.isAnnotationPresent(bindMethod, Binds.class));
       SourceElement sourceElement = SourceElement.forElement(bindMethod, contributingElement);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 7640bb948..51f89f674 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -28,7 +28,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.Produced;
@@ -373,23 +373,23 @@ Key forMultibindingsMethod(
       return forMethod(method, keyType);
     }
 
-    /** Returns the key bound by a {@link Bind} method. */
+    /** Returns the key bound by a {@link Binds} method. */
     Key forBindMethod(SourceElement bindMethodElement) {
       ExecutableElement method = MoreElements.asExecutable(bindMethodElement.element());
       ExecutableType methodType =
           MoreTypes.asExecutable(bindMethodElement.asMemberOfContributingType(types));
-      checkArgument(isAnnotationPresent(method, Bind.class));
+      checkArgument(isAnnotationPresent(method, Binds.class));
       TypeMirror returnType = normalize(types, methodType.getReturnType());
       return forMethod(method, returnType);
     }
 
-    /** Returns the key for the single parameter of a {@link Bind} method. */
+    /** Returns the key for the single parameter of a {@link Binds} method. */
     Key forBindParameter(SourceElement bindMethodElement) {
       ExecutableElement method = MoreElements.asExecutable(bindMethodElement.element());
       VariableElement parameterElement = Iterables.getOnlyElement(method.getParameters());
       ExecutableType methodType =
           MoreTypes.asExecutable(bindMethodElement.asMemberOfContributingType(types));
-      checkArgument(isAnnotationPresent(method, Bind.class));
+      checkArgument(isAnnotationPresent(method, Binds.class));
       TypeMirror parameterType = Iterables.getOnlyElement(methodType.getParameterTypes());
       return forQualifiedType(getQualifier(parameterElement), parameterType);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 6197712bd..a4e645ec3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -23,7 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -75,7 +75,7 @@
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
   /**
-   * The {@link Bind} method declarations that define delegate bindings.
+   * The {@link Binds} method declarations that define delegate bindings.
    */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
@@ -175,7 +175,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
           bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
         }
-        if (isAnnotationPresent(moduleMethod, Bind.class)) {
+        if (isAnnotationPresent(moduleMethod, Binds.class)) {
           delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index f48be2ed5..642420591 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -22,7 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import java.lang.annotation.Annotation;
@@ -70,7 +70,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Module.class, Provides.class, Bind.class);
+    return ImmutableSet.of(Module.class, Provides.class, Binds.class);
   }
 
   @Override
@@ -101,7 +101,7 @@
           if (isAnnotationPresent(methodElement, Provides.class)) {
             moduleProvidesMethodsBuilder.add(methodElement);
           }
-          if (isAnnotationPresent(methodElement, Bind.class)) {
+          if (isAnnotationPresent(methodElement, Binds.class)) {
             moduleBindMethodsBuilder.add(methodElement);
           }
         }
@@ -147,7 +147,7 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
   private ImmutableSet<ExecutableElement> validateBindMethods(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     ImmutableSet.Builder<ExecutableElement> validBindMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Bind.class)) {
+    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
       if (bindElement.getKind().equals(METHOD)) {
         ExecutableElement bindMethodElement = (ExecutableElement) bindElement;
         ValidationReport<ExecutableElement> methodReport =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index ce2677547..5057dba7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -26,7 +26,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
@@ -98,7 +98,7 @@
             moduleMethod.getModifiers().contains(STATIC)
                 ? ModuleMethodKind.STATIC_BINDING
                 : ModuleMethodKind.INSTANCE_BINDING);
-      } else if (isAnnotationPresent(moduleMethod, Bind.class)) {
+      } else if (isAnnotationPresent(moduleMethod, Binds.class)) {
         methodKinds.add(ModuleMethodKind.ABSTRACT_DECLARATION);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 40b2dd1b3..3640468eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -23,7 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -104,7 +104,7 @@
             if (isAnnotationPresent(methodElement, Produces.class)) {
               moduleProducesMethodsBuilder.add(methodElement);
             }
-            if (isAnnotationPresent(methodElement, Bind.class)) {
+            if (isAnnotationPresent(methodElement, Binds.class)) {
               moduleBindMethodsBuilder.add(methodElement);
             }
           }
@@ -165,7 +165,7 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
   private ImmutableSet<ExecutableElement> validateBindMethods(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     ImmutableSet.Builder<ExecutableElement> validBindMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Bind.class)) {
+    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
       if (bindElement.getKind().equals(METHOD)) {
         ExecutableElement bindMethodElement = (ExecutableElement) bindElement;
         ValidationReport<ExecutableElement> methodReport =
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 6e57fc4bc..1bcda53ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -19,7 +19,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import dagger.Bind;
+import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
 import javax.lang.model.element.Element;
@@ -48,7 +48,7 @@ static boolean requiresAPassedInstance(Elements elements, TypeElement typeElemen
         MoreElements.getLocalAndInheritedMethods(typeElement, elements);
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Bind.class)) {
+      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
         /* We found an abstract method that isn't a @Bind method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
         return true;
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java
index 273b28a7e..7354b1eb1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindMethodValidatorTest.java
@@ -50,11 +50,11 @@ public void nonAbstract() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "",
             "@" + moduleAnnotation.getCanonicalName(),
             "abstract class TestModule {",
-            "  @Bind Object bindObject(String impl) { return null; }",
+            "  @Binds Object bindObject(String impl) { return null; }",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -72,11 +72,11 @@ public void notAssignable() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "",
             "@" + moduleAnnotation.getCanonicalName(),
             "abstract class TestModule {",
-            "  @Bind abstract String bindString(Object impl);",
+            "  @Binds abstract String bindString(Object impl);",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -94,11 +94,11 @@ public void moreThanOneParamter() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "",
             "@" + moduleAnnotation.getCanonicalName(),
             "abstract class TestModule {",
-            "  @Bind abstract Object bindObject(String s1, String s2);",
+            "  @Binds abstract Object bindObject(String s1, String s2);",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -116,11 +116,11 @@ public void typeParameters() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "",
             "@" + moduleAnnotation.getCanonicalName(),
             "abstract class TestModule {",
-            "  @Bind abstract <S, T extends S> S bindS(T t);",
+            "  @Binds abstract <S, T extends S> S bindS(T t);",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -138,10 +138,10 @@ public void notInModule() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "",
             "abstract class TestModule {",
-            "  @Bind abstract Object bindObject(String s);",
+            "  @Binds abstract Object bindObject(String s);",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -159,12 +159,12 @@ public void throwsException() {
             "test.TestModule",
             "package test;",
             "",
-            "import dagger.Bind;",
+            "import dagger.Binds;",
             "import java.io.IOException;",
             "",
             "@" + moduleAnnotation.getCanonicalName(),
             "abstract class TestModule {",
-            "  @Bind abstract Object bindObject(String s1) throws IOException;",
+            "  @Binds abstract Object bindObject(String s1) throws IOException;",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 04a5dccc0..f95e0a116 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1321,7 +1321,7 @@ public void genericSubclassedModule() {
         .withErrorContaining("Produced may only be injected in @Produces methods");
   }
 
-  private static final String BIND_METHOD = "@Bind abstract Foo bindFoo(FooImpl impl);";
+  private static final String BIND_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
   private static final String STATIC_PROVIDES_METHOD =
       "@Provides static Bar provideBar() { return new Bar(); }";
   private static final String INSTANCE_PROVIDES_METHOD =
@@ -1373,7 +1373,7 @@ private CompileTester assertThatMethodCombination(String... methodLines) {
             .add(
                 "package test;",
                 "",
-                "import dagger.Bind;",
+                "import dagger.Binds;",
                 "import dagger.Module;",
                 "import dagger.Provides;",
                 "",
diff --git a/core/src/main/java/dagger/Bind.java b/core/src/main/java/dagger/Binds.java
similarity index 98%
rename from core/src/main/java/dagger/Bind.java
rename to core/src/main/java/dagger/Binds.java
index 09a5e7560..78b9a7fec 100644
--- a/core/src/main/java/dagger/Bind.java
+++ b/core/src/main/java/dagger/Binds.java
@@ -43,4 +43,4 @@
 @Documented
 @Retention(RUNTIME)
 @Target(METHOD)
-public @interface Bind {}
+public @interface Binds {}
