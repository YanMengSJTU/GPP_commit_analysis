diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 27cda36ed..107062f22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -20,14 +20,12 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 public final class ClassWriter extends TypeWriter {
-  private final List<TypeWriter> nestedTypeWriters;
   private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
-    this.nestedTypeWriters = Lists.newArrayList();
     this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
@@ -67,12 +65,6 @@ public ConstructorWriter addConstructor() {
     return constructorWriter;
   }
 
-  public ClassWriter addNestedClass(String name) {
-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
-    nestedTypeWriters.add(innerClassWriter);
-    return innerClassWriter;
-  }
-
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index f777100c1..08182a41b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -12,12 +12,9 @@
 
 public class InterfaceWriter extends TypeWriter {
   private final List<TypeVariableName> typeVariables;
-  private final List<TypeWriter> nestedTypeWriters;
-
   InterfaceWriter(ClassName name) {
     super(name);
     this.typeVariables = Lists.newArrayList();
-    this.nestedTypeWriters = Lists.newArrayList();
   }
 
   public void addTypeVariable(TypeVariableName typeVariable) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index a02291580..60ac493d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -10,10 +10,12 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.io.Closer;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Deque;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -86,8 +88,6 @@ public Appendable write(Appendable appendable) throws IOException {
         })
         .toSet();
 
-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
-    // TODO(gak): check for collisions with types declared in this compilation unit too
     ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
         .addAll(explicitImports)
         .addAll(classNames)
@@ -99,6 +99,18 @@ public Appendable write(Appendable appendable) throws IOException {
           }
         })
         .toSet();
+
+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);
+    while (!declaredTypes.isEmpty()) {
+      TypeWriter currentType = declaredTypes.pop();
+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());
+      declaredTypes.addAll(currentType.nestedTypeWriters);
+    }
+
+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
+
+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
     for (ClassName className : importCandidates) {
       if (!(className.packageName().equals(packageName)
               && !className.enclosingClassName().isPresent())
@@ -107,7 +119,8 @@ public Appendable write(Appendable appendable) throws IOException {
           && !typeNames.contains(className.topLevelClassName())) {
         Optional<ClassName> importCandidate = Optional.of(className);
         while (importCandidate.isPresent()
-            && importedClassIndex.containsKey(importCandidate.get().simpleName())) {
+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())
+                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {
           importCandidate = importCandidate.get().enclosingClassName();
         }
         if (importCandidate.isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index 611a2aee3..aa7ba02e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -14,12 +14,14 @@
   Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
   final List<MethodWriter> methodWriters;
+  final List<TypeWriter> nestedTypeWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
     this.methodWriters = Lists.newArrayList();
+    nestedTypeWriters = Lists.newArrayList();
   }
 
   @Override
@@ -52,4 +54,10 @@ public MethodWriter addMethod(Class<?> returnType, String name) {
     methodWriters.add(methodWriter);
     return methodWriter;
   }
+
+  public ClassWriter addNestedClass(String name) {
+    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
+    nestedTypeWriters.add(innerClassWriter);
+    return innerClassWriter;
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
new file mode 100644
index 000000000..e775f7487
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class JavaWriterTest {
+  @Test public void referencedAndDeclaredSimpleName() {
+    JavaWriter javaWriter = JavaWriter.inPackage("test");
+    ClassWriter topClass = javaWriter.addClass("Top");
+    topClass.addNestedClass("Middle").addNestedClass("Bottom");
+    topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
+    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
+  }
+}
