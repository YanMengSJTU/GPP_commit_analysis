diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 692348912..2102909a6 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -141,6 +141,7 @@ private boolean modifiableBindingWillBeFinalized(
         // Once we modify any of the above a single time, then they are finalized.
         return modifyingBinding;
       case MULTIBINDING:
+      case MODULE_INSTANCE:
         return false;
       default:
         throw new IllegalStateException(
@@ -187,6 +188,7 @@ private BindingExpression createModifiableBindingExpression(
       case OPTIONAL:
       case MULTIBINDING:
       case INJECTION:
+      case MODULE_INSTANCE:
         return bindingExpressions.wrapInMethod(
             resolvedBindings,
             request,
@@ -238,6 +240,13 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
       if (binding.kind().equals(BindingKind.INJECTION)) {
         return ModifiableBindingType.INJECTION;
       }
+
+      // TODO(b/72748365): Check whether we need to modify a module instance binding if we are
+      // correctly installing the new module instance. In other words, if there is a subcomponent
+      // builder should we consider a module instance binding modifiable?
+      if (binding.requiresModuleInstance()) {
+        return ModifiableBindingType.MODULE_INSTANCE;
+      }
     } else if (!resolvableBinding(request)) {
       return ModifiableBindingType.MISSING;
     }
@@ -286,6 +295,12 @@ private boolean shouldModifyBinding(
             .containsAll(resolvedBindings.contributionBinding().dependencies());
       case INJECTION:
         return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
+      case MODULE_INSTANCE:
+        // At the moment we have no way of detecting whether a new module instance is installed and
+        // the implementation has changed, so we implement the binding once in the base
+        // implementation of the subcomponent. It will be re-implemented when generating the
+        // component.
+        return !generatedComponentModel.supermodel().isPresent();
       default:
         throw new IllegalStateException(
             String.format(
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
index 2bec3dc39..d015b3411 100644
--- a/java/dagger/internal/codegen/ModifiableBindingType.java
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -70,10 +70,21 @@
    * such bindings are modifiable across subcomponent implementations.
    */
   INJECTION,
+
+  /**
+   * If a binding requires an instance of a module then it is possible for that same module to be
+   * re-instantiated with different state by an ancestor component and thereby bind to a different
+   * instance of the same object. For this reason we reimplement the binding in the base
+   * implementation of the subcomponent, but then allow for all modifiations by re-implementing the
+   * binding when generating the root component. This allows for as much of the known binding graph
+   * to be implemented as early as possible, even if the binding requiring a module must be
+   * overridden later on.
+   */
+  MODULE_INSTANCE,
   ;
 
   private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
-      ImmutableSet.of(NONE, MULTIBINDING, OPTIONAL, INJECTION);
+      ImmutableSet.of(NONE, MULTIBINDING, OPTIONAL, INJECTION, MODULE_INSTANCE);
 
   boolean isModifiable() {
     return !equals(NONE);
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 0fee19f39..9f5b513f2 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -352,18 +352,18 @@ public void missingBindings_satisfiedInGreatAncestor() {
 
   @Test
   public void moduleInstanceDependency() {
-    JavaFileObject subcomponent =
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Sub",
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
             "@Subcomponent(modules = TestModule.class)",
-            "interface Sub {",
+            "interface Leaf {",
             "  String string();",
-            "}");
-    JavaFileObject module =
+            "}"),
         JavaFileObjects.forSourceLines(
             "test.TestModule",
             "package test;",
@@ -374,18 +374,18 @@ public void moduleInstanceDependency() {
             "@Module",
             "class TestModule {",
             "  @Provides String provideString() { return \"florp\"; }",
-            "}");
-    JavaFileObject generatedSubcomponent =
+            "}"));
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerSub",
+            "test.DaggerLeaf",
             "package test;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerSub implements Sub {",
+            "public abstract class DaggerLeaf implements Leaf {",
             "  private TestModule testModule;",
             "",
-            "  protected DaggerSub() {",
+            "  protected DaggerLeaf() {",
             "    initialize();",
             "  }",
             "",
@@ -399,11 +399,44 @@ public void moduleInstanceDependency() {
             "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
             "  }",
             "}");
-    Compilation compilation = compile(subcomponent, module);
+    Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerSub")
-        .hasSourceEquivalentTo(generatedSubcomponent);
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
   }
 
   @Test
@@ -2673,12 +2706,6 @@ private static Compilation compile(Iterable<JavaFileObject> files) {
         .compile(files);
   }
 
-  private static Compilation compile(JavaFileObject... files) {
-    return daggerCompiler()
-        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-        .compile(files);
-  }
-
   private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
     return daggerCompiler()
         .withOptions(
