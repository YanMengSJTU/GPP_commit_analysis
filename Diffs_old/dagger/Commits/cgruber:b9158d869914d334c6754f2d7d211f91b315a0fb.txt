diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 051abf2a7..4eebafe40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -189,7 +189,7 @@ protected final ClassName componentDefinitionTypeName() {
    */
   private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
     if (builderFields.containsKey(contributionType)) {
-      return CodeBlocks.format("builder.$N", builderFields.get(contributionType));
+      return CodeBlock.of("builder.$N", builderFields.get(contributionType));
     } else {
       Optional<CodeBlock> codeBlock =
           getOrCreateComponentContributionFieldExpression(contributionType);
@@ -546,7 +546,7 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
               return Optional.of(
                   staticMethod(
                       generatedClassNameForBinding(contributionBinding),
-                      CodeBlocks.format("create()")));
+                      CodeBlock.of("create()")));
           }
         }
         break;
@@ -774,7 +774,7 @@ private void initializeFrameworkTypes() {
     ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
-        CodeBlock delegatingCodeBlock = CodeBlocks.format(
+        CodeBlock delegatingCodeBlock = CodeBlock.of(
             "($T) $L",
             binding.frameworkClass(),
             getMemberSelect(
@@ -832,7 +832,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
         initializations.add(
-            CodeBlocks.format(
+            CodeBlock.of(
                 "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
         setInitializationState(dependencyKey, DELEGATED);
       }
@@ -848,14 +848,14 @@ private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializati
     CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
       initializations.add(
-          CodeBlocks.format(
+          CodeBlock.of(
               "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
     }
     initializations.add(
-        CodeBlocks.format("this.$L = $L;", memberSelect, initializationCodeBlock));
+        CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
       initializations.add(
-          CodeBlocks.format("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
+          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
     }
     setInitializationState(bindingKey, INITIALIZED);
 
@@ -863,15 +863,14 @@ private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializati
   }
 
   private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
-    return CodeBlocks.format(
-        "$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
+    return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
   }
 
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.<$T>create($L)",
             INSTANCE_FACTORY,
             bindingKeyTypeName,
@@ -886,7 +885,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
           String localFactoryVariable = simpleVariableName(bindingTypeElement);
           CodeBlock callFactoryMethod =
-              CodeBlocks.format(
+              CodeBlock.of(
                   "$L.$L()",
                   localFactoryVariable,
                   binding.bindingElement().getSimpleName().toString());
@@ -899,12 +898,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           CodeBlock getMethodBody =
               binding.nullableType().isPresent()
                       || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlocks.format("return $L;", callFactoryMethod)
-                  : CodeBlocks.format("return $T.checkNotNull($L, $S);",
+                  ? CodeBlock.of("return $L;", callFactoryMethod)
+                  : CodeBlock.of("return $T.checkNotNull($L, $S);",
                       Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          return CodeBlocks.format(
+          return CodeBlock.of(
               Joiner.on('\n')
                   .join(
                       "new $1T<$2T>() {",
@@ -923,7 +922,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         }
 
       case SUBCOMPONENT_BUILDER:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             Joiner.on('\n')
                 .join(
                     "new $1T<$2T>() {",
@@ -947,7 +946,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           arguments.addAll(getDependencyArguments(binding));
 
           CodeBlock factoryCreate =
-              CodeBlocks.format(
+              CodeBlock.of(
                   "$T.create($L)",
                   generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
@@ -960,7 +959,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          return CodeBlocks.format(
+          return CodeBlock.of(
               Joiner.on('\n')
                   .join(
                       "new $1T<$2T>() {",
@@ -988,14 +987,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           }
           arguments.addAll(getDependencyArguments(binding));
 
-          return CodeBlocks.format(
+          return CodeBlock.of(
               "new $T($L)",
               generatedClassNameForBinding(binding),
               makeParametersCodeBlock(arguments));
         }
 
       case SYNTHETIC_MAP:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.create($L)",
             mapFactoryClassName(binding),
             getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
@@ -1013,22 +1012,22 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
     return scope.equals(reusableScope(elements))
-        ? CodeBlocks.format("$T.create($L)", SIMPLE_LAZILY_INITIALIZED_PROVIDER, factoryCreate)
-        : CodeBlocks.format("$T.provider($L)", DOUBLE_CHECK, factoryCreate);
+        ? CodeBlock.of("$T.create($L)", SIMPLE_LAZILY_INITIALIZED_PROVIDER, factoryCreate)
+        : CodeBlock.of("$T.provider($L)", DOUBLE_CHECK, factoryCreate);
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
-        ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
-        : CodeBlocks.format("");
+        ? CodeBlock.of("@$T ", TypeName.get(nullableType.get()))
+        : CodeBlock.of("");
   }
 
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     switch (binding.injectionStrategy()) {
       case NO_OP:
-        return CodeBlocks.format("$T.noOp()", MEMBERS_INJECTORS);
+        return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
       case INJECT_MEMBERS:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.create($L)",
             membersInjectorNameForType(binding.bindingElement()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
@@ -1058,14 +1057,14 @@ private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency)
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
     if (resolvedBindings.frameworkClass().equals(Provider.class)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return CodeBlocks.format("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
+      return CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
     } else {
       return frameworkExpression;
     }
   }
 
   private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$T.create($L)",
         setFactoryClassName(binding.bindingType(), binding.key()),
         makeParametersCodeBlock(getDependencyArguments(binding)));
@@ -1078,7 +1077,7 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
     codeBlocks.add(
-        CodeBlocks.format(
+        CodeBlock.of(
             "$T.<$T, $T>builder($L)",
             frameworkMapFactoryClassName(binding.bindingType()),
             TypeName.get(mapType.keyType()),
@@ -1091,12 +1090,12 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
       ContributionBinding contributionBinding =
           graph.resolvedBindings().get(bindingKey).contributionBinding();
       codeBlocks.add(
-          CodeBlocks.format(
+          CodeBlock.of(
               ".put($L, $L)",
               getMapKeyExpression(contributionBinding.bindingElement()),
               getDependencyArgument(frameworkDependency)));
     }
-    codeBlocks.add(CodeBlocks.format(".build()"));
+    codeBlocks.add(CodeBlock.of(".build()"));
 
     return CodeBlocks.concat(codeBlocks.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 047f455af..dc2bf6ed2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -24,11 +24,6 @@
 
 final class CodeBlocks {
 
-  /** Shorthand for a {@link CodeBlock} with a single format and an argument list. */
-  static CodeBlock format(String format, Object... args) {
-    return CodeBlock.builder().add(format, args).build();
-  }
-
   /**
    * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
    */
@@ -61,14 +56,14 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
   }
 
   static CodeBlock stringLiteral(String toWrap) {
-    return format("$S", toWrap);
+    return CodeBlock.of("$S", toWrap);
   }
 
   private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
       new Function<TypeMirror, CodeBlock>() {
         @Override
         public CodeBlock apply(TypeMirror typeMirror) {
-          return CodeBlocks.format("$T", typeMirror);
+          return CodeBlock.of("$T", typeMirror);
         }
       };
 
@@ -76,7 +71,7 @@ public CodeBlock apply(TypeMirror typeMirror) {
       new Function<ParameterSpec, CodeBlock>() {
           @Override
           public CodeBlock apply(ParameterSpec input) {
-            return CodeBlocks.format("$N", input);
+            return CodeBlock.of("$N", input);
           }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index cc008452d..ccccf9032 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -142,7 +142,7 @@ public String apply(ComponentDescriptor componentDescriptor) {
 
   @Override
   protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder component = classBuilder(name.simpleName()).addModifiers(PUBLIC, FINAL);
+    TypeSpec.Builder component = classBuilder(name).addModifiers(PUBLIC, FINAL);
     addSupertype(component, componentDefinitionType());
     return component;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index f513e0148..a9350edfe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -127,7 +127,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         factoryBuilder =
-            classBuilder(generatedTypeName.simpleName())
+            classBuilder(generatedTypeName)
                 .addTypeVariables(typeParameters)
                 .addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
@@ -214,7 +214,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
-              CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+              CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
               dependency.kind()));
     }
     CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index ac15287b8..1f3195e04 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -111,7 +111,7 @@ ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
   Optional<TypeSpec.Builder> write(
       ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
     TypeSpec.Builder mapKeyCreatorBuilder =
-        classBuilder(generatedTypeName.simpleName()).addModifiers(PUBLIC, FINAL);
+        classBuilder(generatedTypeName).addModifiers(PUBLIC, FINAL);
 
     mapKeyCreatorBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
 
@@ -137,7 +137,7 @@ private MethodSpec buildCreateMethod(
       String parameterName = annotationMember.getSimpleName().toString();
       TypeName parameterType = TypeName.get(annotationMember.getReturnType());
       createMethod.addParameter(parameterType, parameterName);
-      parameters.add(CodeBlocks.format("$L", parameterName));
+      parameters.add(CodeBlock.of("$L", parameterName));
     }
 
     ClassName autoAnnotationClass = mapKeyGeneratedTypeName.peerClass(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 84a988f50..46ab6c2e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -185,7 +185,7 @@ static CodeBlock getMapKeyExpression(Element bindingElement) {
 
     @Override
     public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return CodeBlocks.format(
+      return CodeBlock.of(
           "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
     }
 
@@ -196,52 +196,52 @@ public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
 
     @Override
     public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
-      return CodeBlocks.format("$T.class", TypeName.get(t));
+      return CodeBlock.of("$T.class", TypeName.get(t));
     }
 
     @Override
     public CodeBlock visitString(String s, AnnotationValue p) {
-      return CodeBlocks.format("$S", s);
+      return CodeBlock.of("$S", s);
     }
 
     @Override
     public CodeBlock visitByte(byte b, AnnotationValue p) {
-      return CodeBlocks.format("(byte) $L", b);
+      return CodeBlock.of("(byte) $L", b);
     }
 
     @Override
     public CodeBlock visitChar(char c, AnnotationValue p) {
-      return CodeBlocks.format("$L", p);
+      return CodeBlock.of("$L", p);
     }
 
     @Override
     public CodeBlock visitDouble(double d, AnnotationValue p) {
-      return CodeBlocks.format("$LD", d);
+      return CodeBlock.of("$LD", d);
     }
 
     @Override
     public CodeBlock visitFloat(float f, AnnotationValue p) {
-      return CodeBlocks.format("$LF", f);
+      return CodeBlock.of("$LF", f);
     }
 
     @Override
     public CodeBlock visitInt(int i, AnnotationValue p) {
-      return CodeBlocks.format("(int) $L", i);
+      return CodeBlock.of("(int) $L", i);
     }
 
     @Override
     public CodeBlock visitLong(long i, AnnotationValue p) {
-      return CodeBlocks.format("$LL", i);
+      return CodeBlock.of("$LL", i);
     }
 
     @Override
     public CodeBlock visitShort(short s, AnnotationValue p) {
-      return CodeBlocks.format("(short) $L", s);
+      return CodeBlock.of("(short) $L", s);
     }
 
     @Override
     protected CodeBlock defaultAction(Object o, AnnotationValue p) {
-      return CodeBlocks.format("$L", o);
+      return CodeBlock.of("$L", o);
     }
 
     @Override
@@ -250,7 +250,7 @@ public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationVa
       for (int i = 0; i < values.size(); i++) {
         codeBlocks.add(this.visit(values.get(i), p));
       }
-      return CodeBlocks.format("{$L}", makeParametersCodeBlock(codeBlocks.build()));
+      return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
     }
   }
 
@@ -278,7 +278,7 @@ public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationVa
    */
   private static CodeBlock annotationExpression(
       AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$T.create$L($L)",
         mapKeyExpression.mapKeyCreator,
         mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
@@ -304,7 +304,7 @@ public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
 
         @Override
         public CodeBlock visitArray(ArrayType t, CodeBlock p) {
-          return CodeBlocks.format("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
         }
 
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 0639dbf3f..33a14838f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -61,8 +61,8 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     @Override
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? CodeBlocks.format("$L", fieldName)
-          : CodeBlocks.format("$T.this.$L", owningClass(), fieldName);
+          ? CodeBlock.of("$L", fieldName)
+          : CodeBlock.of("$T.this.$L", owningClass(), fieldName);
     }
   }
 
@@ -86,7 +86,7 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
           ? methodCodeBlock
-          : CodeBlocks.format("$T.$L", owningClass(), methodCodeBlock);
+          : CodeBlock.of("$T.$L", owningClass(), methodCodeBlock);
     }
   }
 
@@ -97,7 +97,7 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
         MEMBERS_INJECTORS,
         ImmutableList.of(type),
-        CodeBlocks.format("noOp()"),
+        CodeBlock.of("noOp()"),
         MEMBERS_INJECTOR);
   }
 
@@ -117,7 +117,7 @@ static MemberSelect emptyFrameworkMapFactory(
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
-        CodeBlocks.format("empty()"),
+        CodeBlock.of("empty()"),
         frameworkMapFactoryClass);
   }
 
@@ -130,7 +130,7 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        CodeBlocks.format("create()"),
+        CodeBlock.of("create()"),
         SET);
   }
 
@@ -158,13 +158,13 @@ CodeBlock getExpressionFor(ClassName usingClass) {
       }
 
       if (accessible) {
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
             makeParametersCodeBlock(toCodeBlocks(typeParameters)),
             methodCodeBlock);
       } else {
-        return CodeBlocks.format("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
+        return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1a0379c1f..ac1b505db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -100,7 +100,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addModifiers(PUBLIC, FINAL)
             .addTypeVariables(typeParameters);
 
@@ -176,7 +176,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       constructorBuilder.addStatement("assert $N != null", field);
       constructorBuilder.addStatement("this.$N = $N", field, field);
       dependencyFieldsBuilder.put(bindingKey, field);
-      constructorInvocationParameters.add(CodeBlocks.format("$N", field));
+      constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
     createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
     createMethodBuilder.addCode(");");
@@ -235,7 +235,7 @@ private CodeBlock directInjectMemberCodeBlock(
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       InjectionSite injectionSite) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
         getInstanceCodeBlockWithPotentialCast(
             injectionSite.element().getEnclosingElement(), binding.bindingElement()),
@@ -250,14 +250,14 @@ private CodeBlock directInjectMemberCodeBlock(
    */
   private CodeBlock delegateInjectMemberCodeBlock(
       ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$L.$L($L);",
         membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
         makeParametersCodeBlock(
             new ImmutableList.Builder<CodeBlock>()
-                .add(CodeBlocks.format("instance"))
+                .add(CodeBlock.of("instance"))
                 .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
                 .build()));
   }
@@ -276,7 +276,7 @@ private CodeBlock delegateInjectMemberCodeBlock(
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
       CodeBlock fieldCodeBlock =
-          CodeBlocks.format("$L", dependencyFields.get(dependency.bindingKey()).name);
+          CodeBlock.of("$L", dependencyFields.get(dependency.bindingKey()).name);
       parameters.add(
           passValue
               ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
@@ -288,13 +288,13 @@ private CodeBlock delegateInjectMemberCodeBlock(
   private CodeBlock getInstanceCodeBlockWithPotentialCast(
       Element injectionSiteElement, Element bindingElement) {
     if (injectionSiteElement.equals(bindingElement)) {
-      return CodeBlocks.format("instance");
+      return CodeBlock.of("instance");
     }
     TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
     if (injectionSiteName instanceof ParameterizedTypeName) {
       injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
     }
-    return CodeBlocks.format("(($T) instance)", injectionSiteName);
+    return CodeBlock.of("(($T) instance)", injectionSiteName);
   }
 
   private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
@@ -325,7 +325,7 @@ private MethodSpec injectorMethodForSubclasses(
               .build();
       methodBuilder.addParameter(parameter);
       providedParameters.add(
-          frameworkTypeUsageStatement(CodeBlocks.format("$N", parameter), dependency.kind()));
+          frameworkTypeUsageStatement(CodeBlock.of("$N", parameter), dependency.kind()));
     }
     if (injectionElement.getKind().isField()) {
       methodBuilder.addStatement(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 76a3f6b9d..438631580 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -60,7 +60,7 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .build())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index bf1990792..41fd0c0e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -96,7 +96,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addModifiers(PUBLIC, FINAL)
             .superclass(abstractProducerOf(providedTypeName));
 
@@ -133,18 +133,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
       CodeBlock futureAccess =
-          CodeBlocks.format("$L.get()", fields.get(dependency.bindingKey()).name());
+          CodeBlock.of("$L.get()", fields.get(dependency.bindingKey()).name());
       computeMethodBuilder.addStatement(
           "$T $L = $L",
           futureType,
           dependencyFutureName(dependency),
           dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-              ? CodeBlocks.format("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
+              ? CodeBlock.of("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
               : futureAccess);
     }
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
     CodeBlock transformCodeBlock =
-        CodeBlocks.format(
+        CodeBlock.of(
             Joiner.on('\n')
                 .join(
                     "new $1T<$2T, $3T>() {",
@@ -157,7 +157,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             futureTransform.applyArgType(),
             providedTypeName,
             futureTransform.hasUncheckedCast()
-                ? CodeBlocks.format("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
+                ? CodeBlock.of("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
                 : "",
             futureTypeName,
             futureTransform.applyArgName(),
@@ -217,14 +217,14 @@ private CodeBlock producerTokenConstruction(
       ClassName generatedTypeName, ProductionBinding binding) {
     CodeBlock producerTokenArgs =
         compilerOptions.writeProducerNameInToken()
-            ? CodeBlocks.format(
+            ? CodeBlock.of(
                 "$S",
                 String.format(
                     "%s#%s",
                     ClassName.get(binding.bindingTypeElement()),
                     binding.bindingElement().getSimpleName()))
-            : CodeBlocks.format("$T.class", generatedTypeName);
-    return CodeBlocks.format("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
+            : CodeBlock.of("$T.class", generatedTypeName);
+    return CodeBlock.of("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
   }
 
   /** Returns a name of the variable representing this dependency's future. */
@@ -282,7 +282,7 @@ static FutureTransform create(
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
+      return CodeBlock.of("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
     }
 
     @Override
@@ -301,7 +301,7 @@ String applyArgName() {
       for (DependencyRequest dependency : binding.dependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                 dependency.kind()));
       }
       return parameterCodeBlocks.build();
@@ -321,7 +321,7 @@ String applyArgName() {
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format("$L", dependencyFutureName(asyncDependency));
+      return CodeBlock.of("$L", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -341,12 +341,12 @@ String applyArgName() {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
-          parameterCodeBlocks.add(CodeBlocks.format("$L", applyArgName()));
+          parameterCodeBlocks.add(CodeBlock.of("$L", applyArgName()));
         } else {
           parameterCodeBlocks.add(
               // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                  CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                   dependency.kind()));
         }
       }
@@ -367,7 +367,7 @@ String applyArgName() {
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format(
+      return CodeBlock.of(
           "$T.<$T>allAsList($L)",
           FUTURES,
           OBJECT,
@@ -377,7 +377,7 @@ CodeBlock futureCodeBlock() {
                       new Function<DependencyRequest, CodeBlock>() {
                         @Override
                         public CodeBlock apply(DependencyRequest dependency) {
-                          return CodeBlocks.format("$L", dependencyFutureName(dependency));
+                          return CodeBlock.of("$L", dependencyFutureName(dependency));
                         }
                       })));
     }
@@ -434,13 +434,13 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
         codeBlocks.add(
-            CodeBlocks.format(
+            CodeBlock.of(
                 "($T) $L.get($L)", asyncDependencyType(dependency), listArgName, argIndex));
         argIndex++;
       } else {
         codeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                 dependency.kind()));
       }
     }
@@ -461,11 +461,11 @@ private CodeBlock getInvocationCodeBlock(
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
     CodeBlock moduleCodeBlock =
-        CodeBlocks.format(
+        CodeBlock.of(
             "$L.$L($L)",
             binding.bindingElement().getModifiers().contains(STATIC)
-                ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-                : CodeBlocks.format("$T.this.module", generatedTypeName),
+                ? CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement()))
+                : CodeBlock.of("$T.this.module", generatedTypeName),
             binding.bindingElement().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
@@ -473,15 +473,15 @@ private CodeBlock getInvocationCodeBlock(
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
     // factories.
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
+    codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
     final CodeBlock valueCodeBlock;
     if (binding.contributionType().equals(ContributionType.SET)) {
       if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
         valueCodeBlock =
-            CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
+            CodeBlock.of("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueCodeBlock = CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
+        valueCodeBlock = CodeBlock.of("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
       valueCodeBlock = moduleCodeBlock;
@@ -489,9 +489,9 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock returnCodeBlock =
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
             ? valueCodeBlock
-            : CodeBlocks.format(
+            : CodeBlock.of(
                 "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
-    return CodeBlocks.format(
+    return CodeBlock.of(
         Joiner.on('\n')
             .join(
                 "monitor.methodStarting();",
@@ -510,8 +510,8 @@ private CodeBlock getInvocationCodeBlock(
    */
   private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
-      return CodeBlocks.format("");
+      return CodeBlock.of("");
     }
-    return CodeBlocks.format("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
+    return CodeBlock.of("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index d6a90a70d..4a44c0869 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -59,7 +59,7 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .build())
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 61edc72e7..366240948 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -125,14 +125,14 @@ static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return CodeBlocks.format("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
+        return CodeBlock.of("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
-        return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
+        return CodeBlock.of("$L.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case PRODUCER:
       case MEMBERS_INJECTOR:
-        return CodeBlocks.format("$L", frameworkTypeMemberSelect);
+        return CodeBlock.of("$L", frameworkTypeMemberSelect);
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 17af901fe..af327aa82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -107,7 +107,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder subcomponent = classBuilder(name.simpleName()).addModifiers(PRIVATE, FINAL);
+    TypeSpec.Builder subcomponent = classBuilder(name).addModifiers(PRIVATE, FINAL);
 
     addSupertype(
         subcomponent,
@@ -192,7 +192,7 @@ private void writeSubcomponentWithoutBuilder(
         MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
         subcomponentConstructorParameters.add(
-            CodeBlocks.format("$L", moduleVariable.getSimpleName()));
+            CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
