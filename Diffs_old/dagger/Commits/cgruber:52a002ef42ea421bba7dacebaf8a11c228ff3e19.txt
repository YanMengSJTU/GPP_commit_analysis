diff --git a/.gitignore b/.gitignore
index 7de7142f7..f05f56746 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,5 +27,3 @@ obj
 .DS_Store
 
 dependency-reduced-pom.xml
-
-test_runs/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 72252f1dd..cd68d9c2a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -66,8 +66,8 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
       <version>1.0</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
     <dependency>
@@ -160,6 +160,7 @@
         </executions>
       </plugin>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
         <version>2.3</version>
         <executions>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index ce3dd4e62..217e6167a 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -48,14 +48,12 @@ limitations under the License.
       <artifactId>javax.inject-tck</artifactId>
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
       <version>${auto.value.version}</version>
       <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
     <dependency>
-      <!-- For map-bindings -->
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
       <version>${auto.factory.version}</version>
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b95143803..ec9f4bbdc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -67,8 +67,6 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -385,7 +383,9 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             return ResolvedBindings.forMembersInjectionBinding(
-                bindingKey, componentDescriptor, rollUpMembersInjectionBindings(bindingKey.key()));
+                bindingKey,
+                componentDescriptor,
+                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key()));
           default:
             throw new AssertionError();
         }
@@ -430,23 +430,6 @@ private boolean shouldOwnParentBinding(
                 getPreviouslyResolvedBindings(request.bindingKey()).get());
       }
 
-      private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
-        MembersInjectionBinding membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-
-        if (membersInjectionBinding.parentInjectorRequest().isPresent()
-            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
-          MembersInjectionBinding parentBinding =
-              rollUpMembersInjectionBindings(
-                  membersInjectionBinding.parentInjectorRequest().get().key());
-          if (parentBinding.injectionStrategy().equals(NO_OP)) {
-            return membersInjectionBinding.withoutParentInjectorRequest();
-          }
-        }
-
-        return membersInjectionBinding;
-      }
-
       private Optional<Resolver> getOwningResolver(ContributionBinding provisionBinding) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitBindingsSet.contains(provisionBinding)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index f7ca429f3..e758cb73e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
@@ -42,9 +41,11 @@
 import javax.tools.Diagnostic.Kind;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 
 /**
@@ -229,6 +230,10 @@ private MembersInjectionBinding registerBinding(
     }
   }
 
+  /**
+   * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
+   * registers one, along with all necessary members injection bindings for superclasses.
+   */
   MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
@@ -237,7 +242,14 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     if (binding != null) {
       return binding;
     }
-    return registerBinding(membersInjectionBindingFactory.forInjectedType(
-        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
+    MembersInjectionBinding newBinding =
+        membersInjectionBindingFactory.forInjectedType(
+            asDeclared(key.type()), Optional.of(key.type()));
+    registerBinding(newBinding, false);
+    if (newBinding.parentKey().isPresent()
+        && newBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
+      getOrFindMembersInjectionBinding(newBinding.parentKey().get());
+    }
+    return newBinding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f0bd3a04f..cd094febb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -227,7 +227,7 @@ Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       return forMethod(method, keyType);
     }
 
-    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
     Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 7fbcf115d..7deb9023c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -53,8 +53,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Represents the full members injection of a particular type. This does not pay attention to
- * injected members on supertypes.
+ * Represents the full members injection of a particular type.
  *
  * @author Gregory Kick
  * @since 2.0
@@ -66,7 +65,11 @@
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
-  abstract Optional<DependencyRequest> parentInjectorRequest();
+  /**
+   * The {@link Key} for the non-object superclass of {@link #bindingElement()}. Absent if
+   * {@link #bindingElement()} is a direct subclass of {@link Object}. 
+   */
+  abstract Optional<Key> parentKey();
 
   enum Strategy {
     NO_OP,
@@ -77,18 +80,6 @@ Strategy injectionStrategy() {
     return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
-  MembersInjectionBinding withoutParentInjectorRequest() {
-    return new AutoValue_MembersInjectionBinding(
-          key(),
-          dependencies(),
-          implicitDependencies(),
-          bindingPackage(),
-          hasNonDefaultTypeParameters(),
-          bindingElement(),
-          injectionSites(),
-          Optional.<DependencyRequest>absent());
-  }
-
   @Override
   protected Binding.Type bindingType() {
     return Binding.Type.MEMBERS_INJECTION;
@@ -199,13 +190,13 @@ MembersInjectionBinding forInjectedType(
                   })
               .toSet();
 
-      Optional<DependencyRequest> parentInjectorRequest =
+      Optional<Key> parentKey =
           MoreTypes.nonObjectSuperclass(types, elements, declaredType)
               .transform(
-                  new Function<DeclaredType, DependencyRequest>() {
+                  new Function<DeclaredType, Key>() {
                     @Override
-                    public DependencyRequest apply(DeclaredType input) {
-                      return dependencyRequestFactory.forMembersInjectedType(input);
+                    public Key apply(DeclaredType superclass) {
+                      return keyFactory.forMembersInjectedType(superclass);
                     }
                   });
 
@@ -219,7 +210,7 @@ public DependencyRequest apply(DeclaredType input) {
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
-          parentInjectorRequest);
+          parentKey);
     }
 
     private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index b0b4df1cc..92a710060 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -60,7 +60,7 @@
  * @author Jesse Beder
  * @since 2.0
  */
-// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
 final class ProducesMethodValidator {
   private final Elements elements;
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 7ad0acbc4..56ca8512b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -76,7 +76,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * pass two providers.  Naively (if we just referenced by resolved BindingKey),
    * we would have passed a single {@code aProvider}.
    */
-  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
+  // TODO(beder): Refactor these indexing methods so that the binding itself knows what sort of
   // binding keys and framework classes that it needs.
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
       Types types, Iterable<? extends DependencyRequest> dependencies) {
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 8ccdb4433..f3f7db027 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -35,7 +35,7 @@
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
  * component instance, no matter how many times that binding is used as a dependency.
- * TODO(user): Decide on how scope works for producers.
+ * TODO(beder): Decide on how scope works for producers.
  *
  * <h2>Component methods</h2>
  *
@@ -119,3 +119,4 @@
   @Documented
   @interface Builder {}
 }
+
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 4156e99e0..499de2a50 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -45,7 +45,7 @@
    * cancelling the input future will trigger the resulting future to succeed with a failing
    * {@code Produced}.
    */
-  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
     return Futures.catchingAsync(
