diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index acced9d23..7045643fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asExecutable;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -37,6 +39,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -44,9 +47,7 @@
 import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -56,14 +57,13 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} and
- * {@link ProductionComponent} annotations.
+ * Performs superficial validation of the contract of the {@link Component} and {@link
+ * ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
@@ -74,7 +74,8 @@
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -85,7 +86,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -97,7 +99,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  static ComponentValidator createForComponent(Elements elements,
+  static ComponentValidator createForComponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -106,7 +109,8 @@ static ComponentValidator createForComponent(Elements elements,
         elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
-  static ComponentValidator createForSubcomponent(Elements elements,
+  static ComponentValidator createForSubcomponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -114,8 +118,9 @@ static ComponentValidator createForSubcomponent(Elements elements,
   }
 
   @AutoValue
-  static abstract class ComponentValidationReport {
+  abstract static class ComponentValidationReport {
     abstract Set<Element> referencedSubcomponents();
+
     abstract ValidationReport<TypeElement> report();
   }
 
@@ -123,7 +128,8 @@ static ComponentValidator createForSubcomponent(Elements elements,
    * Validates the given component subject. Also validates any referenced subcomponents that aren't
    * already included in the {@code validatedSubcomponents} set.
    */
-  public ComponentValidationReport validate(final TypeElement subject,
+  public ComponentValidationReport validate(
+      final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
@@ -155,90 +161,86 @@ public ComponentValidationReport validate(final TypeElement subject,
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
-    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
-    // it can return a logical method multiple times (including overrides, etc.)
-    List<? extends Element> members = elements.getAllMembers(subject);
     SetMultimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
-    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
-      if (method.getModifiers().contains(ABSTRACT)) {
-        ExecutableType resolvedMethod =
-            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
-        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
-        List<? extends VariableElement> parameters = method.getParameters();
-        TypeMirror returnType = resolvedMethod.getReturnType();
-
-        // abstract methods are ones we have to implement, so they each need to be validated
-        // first, check the return type.  if it's a subcomponent, validate that method as such.
-        Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(Kind::annotationType)
-                    .toSet());
-        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(Kind::builderAnnotationType)
-                    .toSet());
-        if (subcomponentAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(
-              builder,
-              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
-                  .get(),
-              method,
-              parameters,
-              parameterTypes,
-              returnType,
-              subcomponentAnnotation);
-        } else if (subcomponentBuilderAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
-              method);
-          validateSubcomponentBuilderMethod(builder,
-              method,
-              parameters,
-              returnType,
-              validatedSubcomponentBuilders);
-        } else {
-          // if it's not a subcomponent...
-          switch (parameters.size()) {
-            case 0:
-              // no parameters means that it is a provision method
-              // basically, there are no restrictions here.  \o/
-              break;
-            case 1:
-              // one parameter means that it's a members injection method
-              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
-              if (!(returnType.getKind().equals(VOID)
-                  || types.isSameType(returnType, onlyParameter))) {
-                builder.addError(
-                    "Members injection methods may only return the injected type or void.", method);
+    getLocalAndInheritedMethods(subject, types, elements)
+        .stream()
+        .filter(method -> method.getModifiers().contains(ABSTRACT))
+        .forEachOrdered(
+            method -> {
+              ExecutableType resolvedMethod = asExecutable(types.asMemberOf(subjectType, method));
+              List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
+              List<? extends VariableElement> parameters = method.getParameters();
+              TypeMirror returnType = resolvedMethod.getReturnType();
+
+              // abstract methods are ones we have to implement, so they each need to be validated
+              // first, check the return type. if it's a subcomponent, validate that method as such.
+              Optional<AnnotationMirror> subcomponentAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::annotationType)
+                          .toSet());
+              Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::builderAnnotationType)
+                          .toSet());
+              if (subcomponentAnnotation.isPresent()) {
+                referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+                validateSubcomponentMethod(
+                    builder,
+                    ComponentDescriptor.Kind.forAnnotatedElement(
+                            MoreTypes.asTypeElement(returnType))
+                        .get(),
+                    method,
+                    parameters,
+                    parameterTypes,
+                    returnType,
+                    subcomponentAnnotation);
+              } else if (subcomponentBuilderAnnotation.isPresent()) {
+                referencedSubcomponents.put(
+                    MoreTypes.asElement(returnType).getEnclosingElement(), method);
+                validateSubcomponentBuilderMethod(
+                    builder, method, parameters, returnType, validatedSubcomponentBuilders);
+              } else {
+                // if it's not a subcomponent...
+                switch (parameters.size()) {
+                  case 0:
+                    // no parameters means that it is a provision method
+                    // basically, there are no restrictions here.  \o/
+                    break;
+                  case 1:
+                    // one parameter means that it's a members injection method
+                    TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
+                    if (!(returnType.getKind().equals(VOID)
+                        || types.isSameType(returnType, onlyParameter))) {
+                      builder.addError(
+                          "Members injection methods may only return the injected type or void.",
+                          method);
+                    }
+                    break;
+                  default:
+                    // this isn't any method that we know how to implement...
+                    builder.addError(
+                        "This method isn't a valid provision method, members injection method or "
+                            + "subcomponent factory method. Dagger cannot implement this method",
+                        method);
+                    break;
+                }
               }
-              break;
-            default:
-              // this isn't any method that we know how to implement...
-              builder.addError(
-                  "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method",
-                  method);
-              break;
-          }
-        }
-      }
-    }
+            });
 
-    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
-        referencedSubcomponents.asMap().entrySet()) {
-      if (entry.getValue().size() > 1) {
-        builder.addError(
-            String.format(
-                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(),
-                entry.getValue()),
-            subject);
-      }
-    }
+    Maps.filterValues(referencedSubcomponents.asMap(), methods -> methods.size() > 1)
+        .forEach(
+            (subcomponent, methods) ->
+                builder.addError(
+                    String.format(
+                        ErrorMessages.SubcomponentBuilderMessages.INSTANCE
+                            .moreThanOneRefToSubcomponent(),
+                        subcomponent,
+                        methods),
+                    subject));
 
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
@@ -258,14 +260,17 @@ public ComponentValidationReport validate(final TypeElement subject,
         ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
-      ComponentValidationReport subreport = subcomponentValidator.validate(
-          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      ComponentValidationReport subreport =
+          subcomponentValidator.validate(
+              MoreElements.asType(subcomponent),
+              validatedSubcomponents,
+              validatedSubcomponentBuilders);
       builder.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
 
-    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
-        builder.build());
+    return new AutoValue_ComponentValidator_ComponentValidationReport(
+        allSubcomponents.build(), builder.build());
   }
 
   private void validateSubcomponentMethod(
@@ -340,8 +345,11 @@ private void validateSubcomponentMethod(
     }
   }
 
-  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
-      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+  private void validateSubcomponentBuilderMethod(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      TypeMirror returnType,
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
