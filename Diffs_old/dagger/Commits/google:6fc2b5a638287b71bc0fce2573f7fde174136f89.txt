diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 687527e77..27e412970 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import java.util.List;
 import java.util.Set;
@@ -61,15 +62,31 @@
   public abstract Key key();
 
   /**
-   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
+   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
+   * defined by the user-defined injection sites.
    */
   abstract ImmutableSet<DependencyRequest> dependencies();
 
   /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
-   * superset of {@link #dependencies()}.  This returns an unmodifiable set.
+   * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
+   * user-defined injection site. This returns an unmodifiable set.
    */
-  abstract Set<DependencyRequest> implicitDependencies();
+  // TODO(gak): this will eventually get migrated to FrameworkDependency
+  Set<DependencyRequest> frameworkDependencies() {
+    return ImmutableSet.of();
+  }
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
+   * union of {@link #dependencies()} and {@link #frameworkDependencies()}. This returns an
+   * unmodifiable set.
+   */
+  final Set<DependencyRequest> implicitDependencies() {
+    Set<DependencyRequest> frameworkDependencies = frameworkDependencies();
+    return frameworkDependencies.isEmpty()
+        ? dependencies()
+        : Sets.union(frameworkDependencies, dependencies());
+  }
 
   /**
    * Returns the name of the package in which this binding must be managed. E.g.: a binding
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 36108cca9..816c51f80 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -32,7 +32,6 @@
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
@@ -58,17 +57,6 @@
  */
 abstract class ContributionBinding extends Binding implements HasContributionType {
 
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!membersInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(membersInjectionRequest().asSet(), dependencies());
-    }
-  }
-
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -83,9 +71,6 @@ public Kind apply(ContributionBinding binding) {
         }
       };
 
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> membersInjectionRequest();
-
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -300,8 +285,6 @@ public Object apply(ContributionBinding mapBinding) {
 
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
-    abstract B membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
-
     abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
 
     abstract B bindingKind(ContributionBinding.Kind kind);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index deb8d15be..d441ce7ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -77,11 +77,6 @@
     return Optional.absent();
   }
 
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    return dependencies();
-  }
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 06d916892..a1c3af826 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -27,7 +27,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
@@ -60,15 +59,11 @@ public BindingType bindingType() {
   }
 
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Similar optimizations to ContributionBinding.implicitDependencies().
-    if (!executorRequest().isPresent() && !monitorRequest().isPresent()) {
-      return super.implicitDependencies();
-    } else {
-      return Sets.union(
-          Sets.union(executorRequest().asSet(), monitorRequest().asSet()),
-          super.implicitDependencies());
-    }
+  Set<DependencyRequest> frameworkDependencies() {
+    return new ImmutableSet.Builder<DependencyRequest>()
+        .addAll(executorRequest().asSet())
+        .addAll(monitorRequest().asSet())
+        .build();
   }
 
   /** Returns the list of types in the throws clause of the method. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 4690145b3..3fc438624 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Set;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -58,6 +59,14 @@
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
 
+  @Override
+  Set<DependencyRequest> frameworkDependencies() {
+    return membersInjectionRequest().asSet();
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
+
   @Override
   public BindingType bindingType() {
     return BindingType.PROVISION;
@@ -78,6 +87,8 @@ private static Builder builder() {
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
 
+    abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+
     abstract Builder unresolved(ProvisionBinding unresolved);
 
     abstract Builder scope(Optional<Scope> scope);
