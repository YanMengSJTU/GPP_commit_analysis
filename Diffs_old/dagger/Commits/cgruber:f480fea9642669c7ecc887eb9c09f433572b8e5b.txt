diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
new file mode 100644
index 000000000..578fb5ffa
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with a component or production component
+ * as part of the {@link ComponentProcessor}.
+ */
+abstract class AbstractComponentProcessingStep implements ProcessingStep {
+
+  private final Class<? extends Annotation> componentAnnotation;
+  private final Messager messager;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
+
+  AbstractComponentProcessingStep(
+      Class<? extends Annotation> componentAnnotation,
+      Messager messager,
+      ComponentHierarchyValidator componentHierarchyValidator,
+      BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
+    this.componentAnnotation = componentAnnotation;
+    this.messager = messager;
+    this.componentHierarchyValidator = componentHierarchyValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public final ImmutableSet<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
+    ComponentElementValidator componentElementValidator =
+        componentElementValidator(elementsByAnnotation);
+    for (Element element : elementsByAnnotation.get(componentAnnotation)) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      try {
+        if (componentElementValidator.validateComponent(componentTypeElement, messager)) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(componentTypeElement);
+          ValidationReport<TypeElement> hierarchyReport =
+              componentHierarchyValidator.validate(componentDescriptor);
+          hierarchyReport.printMessagesTo(messager);
+          if (hierarchyReport.isClean()) {
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            ValidationReport<TypeElement> graphReport =
+                bindingGraphValidator.validate(bindingGraph);
+            graphReport.printMessagesTo(messager);
+            if (graphReport.isClean()) {
+              generateComponent(bindingGraph);
+            }
+          }
+        }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentTypeElement);
+      }
+    }
+    return rejectedElements.build();
+  }
+
+  private void generateComponent(BindingGraph bindingGraph) {
+    try {
+      componentGenerator.generate(bindingGraph);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
+
+  /**
+   * Returns an object that can validate a type element annotated with the component type.
+   */
+  protected abstract ComponentElementValidator componentElementValidator(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
+
+  /**
+   * Validates a component type element.
+   */
+  protected static abstract class ComponentElementValidator {
+    /**
+     * Validates a component type element. Prints any messages about the element to
+     * {@code messager}.
+     *
+     * @throws TypeNotPresentException if any type required to validate the component cannot be
+     *     found
+     */
+    abstract boolean validateComponent(TypeElement componentTypeElement, Messager messager);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index fb9515486..ba96ebfd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -51,22 +51,21 @@
 class BuilderValidator {
   private final Elements elements;
   private final Types types;
+  private final ComponentDescriptor.Kind componentType;
 
-  BuilderValidator(Elements elements, Types types) {
+  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
     this.elements = elements;
     this.types = types;
+    this.componentType = componentType;
   }
 
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
-
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
-    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
+    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
 
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 608a8dd56..650fb9dcc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -18,14 +18,12 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Lazy;
@@ -101,25 +99,6 @@
       return Optional.fromNullable(getOnlyElement(kinds, null));
     }
 
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #builderAnnotationType() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(getOnlyElement(kinds, null));
-    }
-
     Kind(
         Class<? extends Annotation> annotationType,
         Class<? extends Annotation> builderType,
@@ -137,58 +116,9 @@
       return builderType;
     }
 
-    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
-        case PRODUCTION_COMPONENT:
-          return Sets.immutableEnumSet(
-              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
-        default:
-          throw new AssertionError(this);
-      }
-    }
-
-    ImmutableSet<Kind> subcomponentKinds() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return ImmutableSet.of(SUBCOMPONENT);
-        case PRODUCTION_COMPONENT:
-          return ImmutableSet.of();
-        default:
-          throw new AssertionError();
-      }
-    }
-
     boolean isTopLevel() {
       return isTopLevel;
     }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.annotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
-      return TO_ANNOTATION_TYPE;
-    }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.builderAnnotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
-      return TO_BUILDER_ANNOTATION_TYPE;
-    }
   }
 
   abstract Kind kind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index fdc53d569..39b21ca32 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,162 +17,117 @@
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic.Kind;
 
 /**
- * A {@link ProcessingStep} that is responsible for dealing with a component or production component
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
  * as part of the {@link ComponentProcessor}.
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep implements ProcessingStep {
-  private final ComponentDescriptor.Kind componentKind;
+final class ComponentProcessingStep extends AbstractComponentProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentValidator subcomponentValidator;
-  private final BuilderValidator builderValidator;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
-  private final BindingGraphValidator bindingGraphValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
+  private final BuilderValidator componentBuilderValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
 
   ComponentProcessingStep(
-      ComponentDescriptor.Kind componentKind,
       Messager messager,
       ComponentValidator componentValidator,
       ComponentValidator subcomponentValidator,
-      BuilderValidator builderValidator,
+      BuilderValidator componentBuilderValidator,
+      BuilderValidator subcomponentBuilderValidator,
       ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
-    this.componentKind = componentKind;
+    super(
+        Component.class,
+        messager,
+        componentHierarchyValidator,
+        bindingGraphValidator,
+        componentDescriptorFactory,
+        bindingGraphFactory,
+        componentGenerator);
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
-    this.builderValidator = builderValidator;
-    this.componentHierarchyValidator = componentHierarchyValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
+    this.componentBuilderValidator = componentBuilderValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(
-        Component.class,
-        Component.Builder.class,
-        ProductionComponent.class,
-        ProductionComponent.Builder.class,
-        Subcomponent.class,
-        Subcomponent.Builder.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
+        Subcomponent.class, Subcomponent.Builder.class);
   }
 
   @Override
-  public final ImmutableSet<Element> process(
+  protected ComponentElementValidator componentElementValidator(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processBuilders(elementsByAnnotation.get(componentKind.builderAnnotationType()));
-    Set<Element> subcomponentBuilderElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation,
-            FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
-                .toSet());
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processBuilders(subcomponentBuilderElements);
-    Set<Element> subcomponentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation,
-            FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toAnnotationType())
-                .toSet());
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
+    final Set<Element> subcomponentBuilderElements =
+        elementsByAnnotation.get(Subcomponent.Builder.class);
+    final Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+        processSubcomponentBuilders(subcomponentBuilderElements);
+    final Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+    final Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-
-    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      try {
+    return new ComponentElementValidator() {
+      @Override
+      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
         ComponentValidationReport validationReport =
             componentValidator.validate(
                 componentTypeElement, subcomponentElements, subcomponentBuilderElements);
         validationReport.report().printMessagesTo(messager);
-        if (isClean(
+        return isClean(
             validationReport,
             builderReportsByComponent,
             reportsBySubcomponent,
-            builderReportsBySubcomponent)) {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.forComponent(componentTypeElement);
-          ValidationReport<TypeElement> hierarchyReport =
-              componentHierarchyValidator.validate(componentDescriptor);
-          hierarchyReport.printMessagesTo(messager);
-          if (hierarchyReport.isClean()) {
-            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            ValidationReport<TypeElement> graphReport =
-                bindingGraphValidator.validate(bindingGraph);
-            graphReport.printMessagesTo(messager);
-            if (graphReport.isClean()) {
-              generateComponent(bindingGraph);
-            }
-          }
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
+            builderReportsBySubcomponent);
       }
-    }
-    return rejectedElements.build();
-  }
-
-  private void generateComponent(BindingGraph bindingGraph) {
-    try {
-      componentGenerator.generate(bindingGraph);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
+    };
   }
 
-  private ImmutableSet<Element> getElementsFromAnnotations(
-      final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
-      ImmutableSet<Class<? extends Annotation>> annotations) {
-    return ImmutableSet.copyOf(
-        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
-  }
-
-  private Map<Element, ValidationReport<TypeElement>> processBuilders(
-      Set<? extends Element> builderElements) {
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : builderElements) {
+    for (Element element : componentBuilderElements) {
       ValidationReport<TypeElement> report =
-          builderValidator.validate(MoreElements.asType(element));
+          componentBuilderValidator.validate(MoreElements.asType(element));
       report.printMessagesTo(messager);
       builderReportsByComponent.put(element.getEnclosingElement(), report);
     }
     return builderReportsByComponent;
   }
 
+  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
+      Set<? extends Element> subcomponentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsBySubcomponent.put(element, report);
+    }
+    return builderReportsBySubcomponent;
+  }
+
   private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
       Set<? extends Element> subcomponentElements,
       Set<? extends Element> subcomponentBuilderElements) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index c5fd2fd5e..46571b889 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -20,6 +20,11 @@
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -88,17 +93,35 @@ public SourceVersion getSupportedSourceVersion() {
         privateMemberValidationType(processingEnv).diagnosticKind().get(),
         staticMemberValidationType(processingEnv).diagnosticKind().get());
     ModuleValidator moduleValidator =
-        new ModuleValidator(types, elements, methodSignatureFormatter);
-    BuilderValidator builderValidator = new BuilderValidator(elements, types);
-    ComponentValidator subcomponentValidator =
-        ComponentValidator.createForSubcomponent(
-            elements, types, moduleValidator, builderValidator);
-    ComponentValidator componentValidator =
-        ComponentValidator.createForComponent(
-            elements, types, moduleValidator, subcomponentValidator, builderValidator);
-    MapKeyValidator mapKeyValidator = new MapKeyValidator();
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            Module.class,
+            ImmutableList.<Class<? extends Annotation>>of(Module.class),
+            Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
+    BuilderValidator componentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
+    BuilderValidator subcomponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
+    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
+        types, moduleValidator, subcomponentBuilderValidator);
+    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
+        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
+    ModuleValidator producerModuleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            ProducerModule.class,
+            ImmutableList.of(Module.class, ProducerModule.class),
+            Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
+    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
+    BuilderValidator productionComponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.PRODUCTION_COMPONENT);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -171,11 +194,11 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             factoryGenerator),
         new ComponentProcessingStep(
-            ComponentDescriptor.Kind.COMPONENT,
             messager,
             componentValidator,
             subcomponentValidator,
-            builderValidator,
+            componentBuilderValidator,
+            subcomponentBuilderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
@@ -183,16 +206,14 @@ public SourceVersion getSupportedSourceVersion() {
             componentGenerator),
         new ProducerModuleProcessingStep(
             messager,
-            moduleValidator,
+            producerModuleValidator,
             producesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
-        new ComponentProcessingStep(
-            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
+        new ProductionComponentProcessingStep(
             messager,
-            componentValidator,
-            subcomponentValidator,
-            builderValidator,
+            productionComponentValidator,
+            productionComponentBuilderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 0be4686a9..a9e82a8cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -19,7 +19,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -27,7 +26,8 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.producers.ProductionComponent;
+import dagger.Module;
+import dagger.Subcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -56,14 +56,14 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} and
- * {@link ProductionComponent} annotations.
+ * Performs superficial validation of the contract of the {@link Component} annotation.
  *
  * @author Gregory Kick
  */
 final class ComponentValidator {
   private final Elements elements;
   private final Types types;
+  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
@@ -74,6 +74,7 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
+    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = this;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -86,6 +87,7 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
+    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -96,15 +98,21 @@ static ComponentValidator createForComponent(Elements elements,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(
-        elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentValidator,
+        subcomponentBuilderValidator);
   }
 
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements, types, moduleValidator, subcomponentBuilderValidator);
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentBuilderValidator);
   }
 
   @AutoValue
@@ -122,23 +130,20 @@ public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
-
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       builder.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
-              componentKind.annotationType().getSimpleName()),
+              componentType.annotationType().getSimpleName()),
           subject);
     }
 
     ImmutableList<DeclaredType> builders =
-        enclosedBuilders(subject, componentKind.builderAnnotationType());
+        enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
       builder.addError(
-          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
+          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
           subject);
     }
 
@@ -159,23 +164,12 @@ public ComponentValidationReport validate(final TypeElement subject,
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
         Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toAnnotationType())
-                    .toSet());
+            checkForAnnotation(returnType, Subcomponent.class);
         Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
-                    .toSet());
+            checkForAnnotation(returnType, Subcomponent.Builder.class);
         if (subcomponentAnnotation.isPresent()) {
           referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(
-              builder,
-              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
-                  .get(),
+          validateSubcomponentMethod(builder,
               method,
               parameters,
               parameterTypes,
@@ -230,10 +224,9 @@ public ComponentValidationReport validate(final TypeElement subject,
     }
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentKind.annotationType()).get();
+        getAnnotationMirror(subject, componentType.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(
-        subject, builder, moduleTypes, componentKind.moduleKinds());
+    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -254,9 +247,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         builder.build());
   }
 
-  private void validateSubcomponentMethod(
-      final ValidationReport.Builder<TypeElement> builder,
-      final ComponentDescriptor.Kind subcomponentKind,
+  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -277,26 +268,18 @@ private void validateSubcomponentMethod(
     for (int i = 0; i < parameterTypes.size(); i++) {
       VariableElement parameter = parameters.get(i);
       TypeMirror parameterType = parameterTypes.get(i);
-      Optional<TypeElement> moduleType =
-          parameterType.accept(
-              new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
-                @Override
-                protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-                  return Optional.absent();
-                }
+      Optional<TypeElement> moduleType = parameterType.accept(
+          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+              return Optional.absent();
+            }
 
-                @Override
-                public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
-                    if (MoreElements.isAnnotationPresent(
-                        t.asElement(), moduleKind.moduleAnnotation())) {
-                      return Optional.of(MoreTypes.asTypeElement(t));
-                    }
-                  }
-                  return Optional.absent();
-                }
-              },
-              null);
+            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
+                  ? Optional.of(MoreTypes.asTypeElement(t))
+                  : Optional.<TypeElement>absent();
+            }
+          }, null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
           builder.addError(
@@ -345,27 +328,18 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotations(
-      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
-    return type.accept(
-        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-          @Override
-          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-            return Optional.absent();
-          }
+  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
+      final Class<? extends Annotation> annotation) {
+    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+      @Override
+      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+        return Optional.absent();
+      }
 
-          @Override
-          public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-            for (Class<? extends Annotation> annotation : annotations) {
-              Optional<AnnotationMirror> mirror =
-                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
-              if (mirror.isPresent()) {
-                return mirror;
-              }
-            }
-            return Optional.absent();
-          }
-        },
-        null);
+      @Override
+      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
+      }
+    }, null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 58a75e5f7..c938af2c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,18 +1,14 @@
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
@@ -23,7 +19,6 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
@@ -56,59 +51,6 @@
 
   abstract DefaultCreationStrategy defaultCreationStrategy();
 
-  enum Kind {
-    MODULE(
-        Module.class, Provides.class, ImmutableSet.of(Module.class)),
-    PRODUCER_MODULE(
-        ProducerModule.class,
-        Produces.class,
-        ImmutableSet.of(Module.class, ProducerModule.class));
-
-    private final Class<? extends Annotation> moduleAnnotation;
-    private final Class<? extends Annotation> methodAnnotation;
-    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #moduleAnnotation() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
-    }
-
-    Kind(
-        Class<? extends Annotation> moduleAnnotation,
-        Class<? extends Annotation> methodAnnotation,
-        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
-      this.moduleAnnotation = moduleAnnotation;
-      this.methodAnnotation = methodAnnotation;
-      this.includesTypes = includesTypes;
-    }
-
-    Class<? extends Annotation> moduleAnnotation() {
-      return moduleAnnotation;
-    }
-
-    Class<? extends Annotation> methodAnnotation() {
-      return methodAnnotation;
-    }
-
-    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
-      return includesTypes;
-    }
-  }
-
   static final class Factory {
     private final Elements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 9bb5fd1b5..8b0c9a217 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -70,37 +70,46 @@
 final class ModuleValidator {
   private final Types types;
   private final Elements elements;
+  private final Class<? extends Annotation> moduleClass;
+  private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
+  private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
-      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
+      Types types,
+      Elements elements,
+      MethodSignatureFormatter methodSignatureFormatter,
+      Class<? extends Annotation> moduleClass,
+      ImmutableList<Class<? extends Annotation>> includedModuleClasses,
+      Class<? extends Annotation> methodClass) {
     this.types = types;
     this.elements = elements;
+    this.moduleClass = moduleClass;
+    this.includedModuleClasses = includedModuleClasses;
+    this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
-    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
+      if (isAnnotationPresent(moduleMethod, methodClass)) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
 
-    validateModuleVisibility(subject, moduleKind, builder);
-    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
+    validateModuleVisibility(subject, builder);
+    validateMethodsWithSameName(builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
-      validateProvidesOverrides(
-          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
+      validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
     }
     validateModifiers(subject, builder);
-    validateReferencedModules(subject, moduleKind, builder);
+    validateReferencedModules(subject, builder);
 
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
@@ -116,7 +125,6 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
-      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -124,8 +132,7 @@ private void validateMethodsWithSameName(
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
-              String.format(
-                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
+              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
               offendingMethod);
         }
       }
@@ -133,27 +140,11 @@ private void validateMethodsWithSameName(
   }
 
   private void validateReferencedModules(
-      TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
-      ValidationReport.Builder<TypeElement> builder) {
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
-  }
-
-  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    return FluentIterable.from(validModuleKinds)
-        .transformAndConcat(
-            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
-              @Override
-              public Set<? extends Class<? extends Annotation>> apply(
-                  ModuleDescriptor.Kind moduleKind) {
-                return moduleKind.includesTypes();
-              }
-            })
-        .toSet();
+    validateReferencedModules(subject,  builder, includedTypes);
   }
 
   /**
@@ -162,11 +153,7 @@ private void validateReferencedModules(
   void validateReferencedModules(
       final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes,
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
-        includedModuleClasses(validModuleKinds);
-
+      ImmutableList<TypeMirror> includedTypes) {
     for (TypeMirror includedType : includedTypes) {
       includedType.accept(
           new SimpleTypeVisitor6<Void, Void>() {
@@ -228,7 +215,6 @@ public String apply(
 
   private void validateProvidesOverrides(
       TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
@@ -265,13 +251,13 @@ private void validateProvidesOverrides(
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                    moduleKind.methodAnnotation().getSimpleName(),
+                    methodClass.getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {
+        if (isAnnotationPresent(superclassMethod, methodClass)) {
           for (ExecutableElement method : allMethodsByName.get(name)) {
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
@@ -279,7 +265,7 @@ private void validateProvidesOverrides(
               builder.addError(
                   String.format(
                       METHOD_OVERRIDES_PROVIDES_METHOD,
-                      moduleKind.methodAnnotation().getSimpleName(),
+                      methodClass.getSimpleName(),
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
@@ -290,9 +276,7 @@ private void validateProvidesOverrides(
     }
   }
 
-  private void validateModuleVisibility(
-      final TypeElement moduleElement,
-      ModuleDescriptor.Kind moduleKind,
+  private void validateModuleVisibility(final TypeElement moduleElement,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
@@ -309,24 +293,18 @@ private void validateModuleVisibility(
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules =
-              FluentIterable.from(
-                      getModuleIncludes(
-                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
-                  .transform(
-                      new Function<TypeMirror, Element>() {
-                        @Override
-                        public Element apply(TypeMirror input) {
-                          return types.asElement(input);
-                        }
-                      })
-                  .filter(
-                      new Predicate<Element>() {
-                        @Override
-                        public boolean apply(Element input) {
-                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                        }
-                      })
+          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
+              getAnnotationMirror(moduleElement, moduleClass).get()))
+                  .transform(new Function<TypeMirror, Element>() {
+                    @Override public Element apply(TypeMirror input) {
+                      return types.asElement(input);
+                    }
+                  })
+                  .filter(new Predicate<Element>() {
+                    @Override public boolean apply(Element input) {
+                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                    }
+                  })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
new file mode 100644
index 000000000..0581b1bb1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
+ * annotation as part of the {@link ComponentProcessor}.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
+  private final Messager messager;
+  private final ProductionComponentValidator componentValidator;
+  private final BuilderValidator componentBuilderValidator;
+
+  ProductionComponentProcessingStep(
+      Messager messager,
+      ProductionComponentValidator componentValidator,
+      BuilderValidator componentBuilderValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
+      BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
+    super(
+        ProductionComponent.class,
+        messager,
+        componentHierarchyValidator,
+        bindingGraphValidator,
+        componentDescriptorFactory,
+        bindingGraphFactory,
+        componentGenerator);
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.componentBuilderValidator = componentBuilderValidator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(
+        ProductionComponent.class, ProductionComponent.Builder.class);
+  }
+
+  // TODO(beder): Move common logic into the AbstractComponentProcessingStep when implementing
+  // production subcomponents.
+  @Override
+  protected ComponentElementValidator componentElementValidator(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(ProductionComponent.Builder.class));
+    return new ComponentElementValidator() {
+      @Override
+      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+        ValidationReport<TypeElement> validationReport =
+            componentValidator.validate(componentTypeElement);
+        validationReport.printMessagesTo(messager);
+        if (!validationReport.isClean()) {
+          return false;
+        }
+        ValidationReport<?> builderReport = builderReportsByComponent.get(componentTypeElement);
+        return builderReport == null || builderReport.isClean();
+      }
+    };
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
+    }
+    return builderReportsByComponent;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
new file mode 100644
index 000000000..2e2291d34
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentValidator {
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addError(
+          "@ProductionComponent may only be applied to an interface or abstract class", subject);
+    }
+
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, ProductionComponent.class).get();
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
+
+    // TODO(gak): make unused modules an error
+    for (TypeMirror moduleType : moduleTypes) {
+      moduleType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              checkState(t.getTypeArguments().isEmpty());
+              TypeElement moduleElement = MoreElements.asType(t.asElement());
+              if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
+                  && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
+                builder.addError(
+                    moduleElement.getQualifiedName()
+                        + " is listed as a module, but is not annotated with @Module or"
+                        + " @ProducerModule",
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 5564e52ca..a8e39b28a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -78,11 +78,10 @@
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
+    assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
+        .withErrorContaining("is not annotated with @Module or @ProducerModule");
   }
 
   @Test public void simpleComponent() {
