diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9d7022897..c4591f1f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -40,9 +40,9 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
@@ -123,7 +123,7 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
 
       // Collect Component dependencies.
       ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation));
+          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation));
       for (TypeElement componentDependency : componentDependencyTypes) {
         explicitProvisionBindingsBuilder.add(
             provisionBindingFactory.forComponent(componentDependency));
@@ -146,7 +146,7 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
 
       // Collect transitive modules provisions.
       ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(types, getComponentModules(componentAnnotation));
+          MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
 
       ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
           getTransitiveModules(types, elements, moduleTypes);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 8baeb0ed2..07893a47f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -327,7 +327,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
             getAnnotationMirror(componentType, Component.class);
         if (componentAnnotation.isPresent()) {
           ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-              MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation.get())));
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
           if (scopedDependencies.size() == 1) {
             // empty can be ignored (base-case), and > 1 is a different error reported separately.
             scopeStack.push(wrappedScope);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 1279496f3..122a2d0e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,7 +32,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -104,11 +103,9 @@
 
   static final class Factory {
     private final Elements elements;
-    private final Types types;
 
-    Factory(Elements elements, Types types) {
+    Factory(Elements elements) {
       this.elements = elements;
-      this.types = types;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -123,7 +120,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
       ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(types, getComponentDependencies(componentMirror));
+          MoreTypes.asTypeElements(getComponentDependencies(componentMirror));
 
       ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
           ImmutableMap.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a17f21d0e..719b32bce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -65,7 +65,7 @@ public SourceVersion getSupportedSourceVersion() {
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
-    
+
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     ProvisionBindingFormatter provisionBindingFormatter =
         new ProvisionBindingFormatter(methodSignatureFormatter);
@@ -111,7 +111,7 @@ public SourceVersion getSupportedSourceVersion() {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types);
+        new ComponentDescriptor.Factory(elements);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
         elements, types, injectBindingRegistry, keyFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index a8f1baab5..04f4cf90d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -115,7 +115,7 @@
       if (moduleMirror.isPresent()) {
         ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
         moduleDependenciesBuilder.addAll(
-            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get())));
+            MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
         // (note: we don't recurse on the parent class because we don't want the parent class as a
         // root that the component depends on, and also because we want the dependencies rooted
         // against this element, not the parent.)
@@ -131,7 +131,7 @@
     }
     return ImmutableMap.copyOf(moduleElements);
   }
-  
+
   /** Traverses includes from superclasses and adds them into the builder. */
   private static void addIncludesFromSuperclasses(Types types, TypeElement element,
       ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
@@ -143,7 +143,7 @@ private static void addIncludesFromSuperclasses(Types types, TypeElement element
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
           .or(getAnnotationMirror(element, ProducerModule.class));
       if (moduleMirror.isPresent()) {
-        builder.addAll(MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get())));
+        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
       }
       superclass = element.getSuperclass();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index dea62cb39..11420de3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -131,12 +131,11 @@ private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
-          fieldElement, 
+          fieldElement,
           ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
               containingType, fieldElement, resolved)));
     }
-    
-    
+
     /** Returns an unresolved version of this binding. */
     MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
       checkState(binding.isResolved());
@@ -146,7 +145,7 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
 
     /**
      * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
-     * this will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key &
+     * this will return a {@link Binding#isResolved() resolved} binding, with the key &
      * type resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
@@ -161,7 +160,7 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
         type = resolved;
         isResolved = true;
       }
-      
+
       TypeElement typeElement = MoreElements.asType(type.asElement());
       final DeclaredType resolved = type;
       ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 749712a3c..d45d44d91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -126,7 +126,7 @@ ProductionBinding forProducesMethod(
           producesMethod,
           dependencies,
           findBindingPackage(key),
-          Optional.of(MoreTypes.asTypeElement(types, declaredContainer)),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           kind,
           producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()));
@@ -146,7 +146,7 @@ ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           Optional.<TypeElement>absent(),
           Kind.FUTURE_PRODUCTION,
           Produces.Type.MAP,
-          ImmutableList.of());
+          ImmutableList.<TypeMirror>of());
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 258694ded..83c3788bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -149,8 +149,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
-    
-    
+
     /** Returns an unresolved version of this binding. */
     ProvisionBinding unresolve(ProvisionBinding binding) {
       checkState(binding.isResolved());
@@ -160,7 +159,7 @@ ProvisionBinding unresolve(ProvisionBinding binding) {
 
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key & type
+     * will return a {@link Binding#isResolved() resolved} binding, with the key & type
      * resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
@@ -250,7 +249,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           providesMethod,
           dependencies,
           findBindingPackage(key),
-          Optional.of(MoreTypes.asTypeElement(types, declaredContainer)),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Kind.PROVISION,
           providesAnnotation.type(),
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
