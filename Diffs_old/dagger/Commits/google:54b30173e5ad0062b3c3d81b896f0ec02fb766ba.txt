diff --git a/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java b/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java
new file mode 100644
index 000000000..3597b653e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ElementUtil.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+/**
+ * A collection of utilities for working with {@link Element} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ElementUtil {
+  private static final ElementVisitor<TypeElement, Void> TYPE_ELEMENT_VISITOR =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          throw new IllegalArgumentException();
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
+  /**
+   * Returns the given {@link Element} as a {@link TypeElement} or throws
+   * {@link IllegalArgumentException} if the element is not of the correct
+   * {@linkplain ElementKind kind}.
+   */
+  static TypeElement asTypeElement(Element e) {
+    return e.accept(TYPE_ELEMENT_VISITOR, null);
+  }
+
+  private ElementUtil() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
new file mode 100644
index 000000000..a5e4ededf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * The collection of error messages to be reported back to users.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ErrorMessages {
+  /*
+   * JSR-330 errors
+   *
+   * These are errors that are explicitly outlined in the JSR-330 APIs
+   */
+
+  /* constructors */
+  static final String MULTIPLE_INJECT_CONSTRUCTORS =
+      "Types may only contain one @Inject constructor.";
+
+  /* fields */
+  static final String FINAL_INJECT_FIELD = "@Inject fields may not be final";
+
+  /* methods */
+  static final String ABSTRACT_INJECT_METHOD = "Methods with @Inject may not be abstract.";
+  static final String GENERIC_INJECT_METHOD =
+      "Methods with @Inject may not declare type parameters.";
+
+  /*
+   * Dagger errors
+   *
+   * These are errors that arise due to restrictions imposed by the dagger implementation.
+   */
+
+  /* constructors */
+  static final String INJECT_ON_PRIVATE_CONSTRUCTOR =
+      "Dagger does not support injection into private constructors";
+  static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
+      "@Inject constructors are invalid on inner classes";
+  static final String INJECT_CONSTRUCTOR_ON_GENERIC_CLASS =
+      "Generic types may not use @Inject constructors. "
+          + "Use a @Provides method to bind the type parameters.";
+  static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
+      "@Inject is nonsense on the constructor of an abstract class";
+
+  /* fields */
+  static final String PRIVATE_INJECT_FIELD =
+      "Dagger does not support injection into private fields";
+
+  /* methods */
+  static final String PRIVATE_INJECT_METHOD =
+      "Dagger does not support injection into private methods";
+
+  /* all */
+  static final String INJECT_INTO_PRIVATE_CLASS =
+      "Dagger does not support injection into private classes";
+
+  private ErrorMessages() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
new file mode 100644
index 000000000..183c71f25
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static javax.lang.model.SourceVersion.RELEASE_6;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.ElementKindVisitor6;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the {@link Inject}
+ * annotation.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@SupportedSourceVersion(RELEASE_6)
+public final class InjectProcessor extends AbstractProcessor {
+  private Messager messager;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+    this.messager = processingEnv.getMessager();
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of(Inject.class.getName());
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    // TODO(gak): add some error handling for bad source files
+    for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
+      injectElement.accept(
+          new ElementKindVisitor6<Void, Void>() {
+            @Override
+            public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
+              boolean errorRaised = false;
+
+              if (constructorElement.getModifiers().contains(PRIVATE)) {
+                messager.printMessage(ERROR, INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+                errorRaised = true;
+              }
+
+              TypeElement enclosingElement =
+                  ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+
+              if (enclosingElement.getModifiers().contains(PRIVATE)) {
+                messager.printMessage(ERROR, INJECT_INTO_PRIVATE_CLASS, constructorElement);
+                errorRaised = true;
+              }
+
+              if (enclosingElement.getModifiers().contains(ABSTRACT)) {
+                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS,
+                    constructorElement);
+                errorRaised = true;
+              }
+
+              if (!enclosingElement.getTypeParameters().isEmpty()) {
+                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_GENERIC_CLASS,
+                    constructorElement);
+                errorRaised = true;
+              }
+
+              if (enclosingElement.getNestingKind().isNested()
+                  && !enclosingElement.getModifiers().contains(STATIC)) {
+                messager.printMessage(ERROR, INJECT_CONSTRUCTOR_ON_INNER_CLASS,
+                    constructorElement);
+                errorRaised = true;
+              }
+
+              // This is computationally expensive, but probably preferable to a giant index
+              FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
+                  ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
+                      .filter(new Predicate<ExecutableElement>() {
+                        @Override public boolean apply(ExecutableElement input) {
+                          return input.getAnnotation(Inject.class) != null;
+                        }
+                      });
+
+              if (injectConstructors.size() > 1) {
+                messager.printMessage(ERROR, MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+                errorRaised = true;
+              }
+
+              if (!errorRaised) {
+                // collect bindings for generating factories
+              }
+              return null;
+            }
+
+            @Override
+            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+              boolean errorRaised = false;
+
+              Set<Modifier> modifiers = fieldElement.getModifiers();
+              if (modifiers.contains(FINAL)) {
+                messager.printMessage(ERROR, FINAL_INJECT_FIELD, fieldElement);
+                errorRaised = true;
+              }
+
+              if (modifiers.contains(PRIVATE)) {
+                messager.printMessage(ERROR, PRIVATE_INJECT_FIELD, fieldElement);
+                errorRaised = true;
+              }
+
+              // TODO(gak): check for static
+
+              if (!errorRaised) {
+                // collect bindings for generating members injectors
+              }
+
+              return null;
+            }
+
+            @Override
+            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+              boolean errorRaised = false;
+
+              Set<Modifier> modifiers = methodElement.getModifiers();
+              if (modifiers.contains(ABSTRACT)) {
+                messager.printMessage(ERROR, ABSTRACT_INJECT_METHOD, methodElement);
+                errorRaised = true;
+              }
+
+              if (modifiers.contains(PRIVATE)) {
+                messager.printMessage(ERROR, PRIVATE_INJECT_METHOD, methodElement);
+                errorRaised = true;
+              }
+
+              if (!methodElement.getTypeParameters().isEmpty()) {
+                messager.printMessage(ERROR, GENERIC_INJECT_METHOD, methodElement);
+                errorRaised = true;
+              }
+
+              // TODO(gak): check for static
+
+              if (!errorRaised) {
+                // collect bindings for generating members injectors
+              }
+
+              return null;
+            }
+          }, null);
+    }
+
+    // TODO(gak): generate the factories and members injectors
+
+    return false;
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
new file mode 100644
index 000000000..0cf99d282
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.testing.compile.CompilationRule;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ElementUtilTest {
+  @Rule public CompilationRule compilation = new CompilationRule();
+
+  @Test public void asTypeElement() {
+    Element typeElement =
+        compilation.getElements().getTypeElement(String.class.getCanonicalName());
+    ASSERT.that(ElementUtil.asTypeElement(typeElement)).is(typeElement);
+  }
+
+  @Test public void asTypeElement_notATypeElement() {
+    TypeElement typeElement =
+        compilation.getElements().getTypeElement(String.class.getCanonicalName());
+    for (ExecutableElement e : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
+      try {
+        ElementUtil.asTypeElement(e);
+        fail();
+      } catch (IllegalArgumentException expected) {
+      }
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
new file mode 100644
index 000000000..3fea485d1
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class InjectProcessorTest {
+  @Test public void injectOnPrivateConstructor() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateConstructor {",
+        "  @Inject private PrivateConstructor() {}",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
+        .in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnInnerClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class OuterClass {",
+        "  class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void injectConstructorOnAbstractClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AbstractClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "abstract class AbstractClass {",
+        "  @Inject AbstractClass() {}",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
+        .in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnGenericClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<T> {",
+        "  @Inject GenericClass() {}",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS)
+        .in(file).onLine(6);
+  }
+
+  @Test public void multipleInjectConstructors() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.TooManyInjectConstructors",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class TooManyInjectConstructors {",
+        "  @Inject TooManyInjectConstructors() {}",
+        "  TooManyInjectConstructors(int i) {}",
+        "  @Inject TooManyInjectConstructors(String s) {}",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
+        .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
+  }
+
+  @Test public void finalInjectField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class FinalInjectField {",
+        "  @Inject final String s;",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectField {",
+        "  @Inject private String s;",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
+  }
+
+  @Test public void abstractInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AbstractInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "abstract class AbstractInjectMethod {",
+        "  @Inject abstract void method();",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectMethod {",
+        "  @Inject private void method();",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
+  }
+
+  @Test public void genericInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AbstractInjectMethod {",
+        "  @Inject <T> void method();",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor()).failsToCompile()
+        .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
+  }
+}
