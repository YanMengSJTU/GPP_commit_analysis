diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index f760fec5d..f56b83f07 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -19,44 +19,24 @@
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
-import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
-import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.Util.toImmutableList;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreElements;
@@ -74,28 +54,19 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.InstanceFactory;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -186,7 +157,8 @@
             this,
             childComponentNames(keyFactory, subcomponentNames),
             graph,
-            elements);
+            elements,
+            optionalFactories);
     this.componentRequirementFieldFactory =
         new ComponentRequirementField.Factory(this, componentFieldNames, name, builderFields);
   }
@@ -243,11 +215,18 @@ public void addField(FieldSpec fieldSpec) {
     component.addField(fieldSpec);
   }
 
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+  @Override
+  public void addType(TypeSpec typeSpec) {
+    component.addType(typeSpec);
+  }
+
+  @Override
+  public String getSubcomponentName(ComponentDescriptor subcomponentDescriptor) {
+    return checkNotNull(subcomponentNames.get(subcomponentDescriptor));
+  }
+
+  @Override
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
   }
 
@@ -386,14 +365,6 @@ private void createComponentRequirementFields() {
         .forEach(componentRequirementFields::add);
   }
 
-  private boolean useRawType(Binding binding) {
-    return useRawType(binding.bindingPackage());
-  }
-
-  private boolean useRawType(Optional<String> bindingPackage) {
-    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethodSignatures = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -519,47 +490,6 @@ private void writeInitializeAndInterfaceMethods() {
     component.addMethods(interfaceMethods);
   }
 
-  @Override
-  public CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression) {
-    if (bindingExpression.isProducerFromProvider()) {
-      return bindingExpressions.getDependencyExpression(
-          FrameworkDependency.create(bindingExpression.bindingKey(), PRODUCTION), name);
-    }
-
-    switch (bindingExpression.bindingKey().kind()) {
-      case CONTRIBUTION:
-        return contributionBindingInitialization(bindingExpression);
-      case MEMBERS_INJECTION:
-        return membersInjectionBindingInitialization(bindingExpression);
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private CodeBlock contributionBindingInitialization(
-      FrameworkInstanceBindingExpression bindingExpression) {
-    ContributionBinding binding =
-        graph.resolvedBindings().get(bindingExpression.bindingKey()).contributionBinding();
-    switch (binding.factoryCreationStrategy()) {
-      case DELEGATE:
-        CodeBlock delegatingCodeBlock =
-            CodeBlock.of(
-                "($T) $L",
-                binding.bindingType().frameworkClass(),
-                bindingExpressions.getDependencyExpression(
-                    getOnlyElement(binding.frameworkDependencies()), name));
-        return decorateForScope(delegatingCodeBlock, binding.scope());
-      case SINGLETON_INSTANCE:
-        checkState(binding.scope().isPresent());
-        // fall through
-      case CLASS_CONSTRUCTOR:
-        return factoryForContributionBindingInitialization(binding);
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
   private void writeMembersInjectionMethods() {
     component.addMethods(membersInjectionMethods.values());
   }
@@ -619,233 +549,9 @@ private MethodSpec membersInjectionMethod(Key key) {
     throw new IllegalArgumentException(binding.key().toString());
   }
 
-  private CodeBlock membersInjectionBindingInitialization(
-      FrameworkInstanceBindingExpression bindingExpression) {
-    BindingKey bindingKey = bindingExpression.bindingKey();
-    MembersInjectionBinding binding =
-        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
-    checkState(!binding.injectionSites().isEmpty());
-    return membersInjectorForBindingInitialization(binding);
-  }
-
-  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
-      FrameworkDependency frameworkDependency) {
-    checkState(isProducerFromProvider(frameworkDependency));
-    return producerFromProviderBindingExpressions.computeIfAbsent(
-        frameworkDependency.bindingKey(),
-        dependencyKey ->
-            bindingExpressionFactory.forProducerFromProviderField(
-                graph.resolvedBindings().get(dependencyKey)));
-  }
-
-  private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
-    ResolvedBindings resolvedBindings =
-        graph.resolvedBindings().get(frameworkDependency.bindingKey());
-    return resolvedBindings.frameworkClass().equals(Provider.class)
-        && frameworkDependency.frameworkClass().equals(Producer.class);
-  }
-
-  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
-    switch (binding.bindingKind()) {
-      case COMPONENT:
-        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
-        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
-
-      case COMPONENT_DEPENDENCY:
-        return CodeBlock.of(
-            "$T.create($L)",
-            INSTANCE_FACTORY,
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forDependency(binding.key().type()), name));
-
-      case COMPONENT_PROVISION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
-          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
-          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          CodeBlock invocation =
-              ComponentProvisionBindingExpression.maybeCheckForNull(
-                  (ProvisionBinding) binding,
-                  compilerOptions,
-                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
-          ClassName dependencyClassName = ClassName.get(dependencyType);
-          String factoryName =
-              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
-          MethodSpec.Builder getMethod =
-              methodBuilder("get")
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(bindingKeyTypeName)
-                  .addStatement("return $L", invocation);
-          if (binding.nullableType().isPresent()) {
-            getMethod.addAnnotation(
-                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
-          }
-          component.addType(
-              TypeSpec.classBuilder(factoryName)
-                  .addSuperinterface(providerOf(bindingKeyTypeName))
-                  .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
-                  .addMethod(
-                      constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
-                          .build())
-                  .addMethod(getMethod.build())
-                  .build());
-          return CodeBlock.of(
-              "new $L($L)",
-              factoryName,
-              componentRequirementFields.getExpressionDuringInitialization(
-                  ComponentRequirement.forDependency(dependencyType.asType()), name));
-        }
-
-      case SUBCOMPONENT_BUILDER:
-        String subcomponentName =
-            subcomponentNames.get(
-                graph
-                    .componentDescriptor()
-                    .subcomponentsByBuilderType()
-                    .get(MoreTypes.asTypeElement(binding.key().type())));
-        return CodeBlock.of(
-            "$L",
-            anonymousClassBuilder("")
-                .superclass(providerOf(bindingKeyTypeName))
-                .addMethod(
-                    methodBuilder("get")
-                        .addAnnotation(Override.class)
-                        .addModifiers(PUBLIC)
-                        .returns(bindingKeyTypeName)
-                        .addStatement("return new $LBuilder()", subcomponentName)
-                        .build())
-                .build());
-
-      case BUILDER_BINDING:
-        return CodeBlock.of(
-            "$T.$L($L)",
-            InstanceFactory.class,
-            binding.nullableType().isPresent() ? "createNullable" : "create",
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forBinding(binding), name));
-
-      case INJECTION:
-      case PROVISION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    name));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          CodeBlock factoryCreate =
-              CodeBlock.of(
-                  "$T.create($L)",
-                  generatedClassNameForBinding(binding),
-                  makeParametersCodeBlock(arguments));
-
-          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
-          // type properly, so cast to a raw framework type before scoping.
-          if (binding.bindingKind().equals(INJECTION)
-              && binding.unresolved().isPresent()
-              && binding.scope().isPresent()) {
-            factoryCreate =
-                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
-          }
-          return decorateForScope(factoryCreate, binding.scope());
-        }
-
-      case COMPONENT_PRODUCTION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          FieldSpec dependencyField =
-              FieldSpec.builder(
-                      ClassName.get(dependencyType),
-                      simpleVariableName(dependencyType),
-                      PRIVATE,
-                      FINAL)
-                  .initializer(
-                      componentRequirementFields.getExpressionDuringInitialization(
-                          ComponentRequirement.forDependency(dependencyType.asType()), name))
-                  .build();
-          return CodeBlock.of(
-              "$L",
-              anonymousClassBuilder("")
-                  .superclass(producerOf(bindingKeyTypeName))
-                  .addField(dependencyField)
-                  .addMethod(
-                      methodBuilder("get")
-                          .addAnnotation(Override.class)
-                          .addModifiers(PUBLIC)
-                          .returns(listenableFutureOf(bindingKeyTypeName))
-                          .addStatement(
-                              "return $N.$L()",
-                              dependencyField,
-                              binding.bindingElement().get().getSimpleName())
-                          .build())
-                  .build());
-        }
-
-      case PRODUCTION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    name));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          return CodeBlock.of(
-              "new $T($L)",
-              generatedClassNameForBinding(binding),
-              makeParametersCodeBlock(arguments));
-        }
-
-      case SYNTHETIC_MAP:
-        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
-        return CodeBlock.of(
-            "$T.create($L)",
-            mapFactoryClassName(binding),
-            bindingExpressions.getDependencyExpression(frameworkDependency, name));
-
-      case SYNTHETIC_MULTIBOUND_SET:
-        return factoryForSetMultibindingInitialization(binding);
-
-      case SYNTHETIC_MULTIBOUND_MAP:
-        return factoryForMapMultibindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
-
-      case SYNTHETIC_OPTIONAL_BINDING:
-        return factoryForSyntheticOptionalBindingInitialization(binding);
-
-      default:
-        throw new AssertionError(binding);
-    }
-  }
-
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
-  }
-
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+  // TODO(user): Pull this out into a separate Scoper object or move to field initializer?
+  @Override
+  public CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
     if (!maybeScope.isPresent()) {
       return factoryCreate;
     }
@@ -864,247 +570,34 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> mayb
     }
   }
 
-  private CodeBlock membersInjectorForBindingInitialization(MembersInjectionBinding binding) {
-    return binding.injectionSites().isEmpty()
-        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
-        : CodeBlock.of(
-            "$T.create($L)",
-            membersInjectorNameForType(binding.membersInjectedType()),
-            makeParametersCodeBlock(getDependencyArguments(binding)));
-  }
-
-  /**
-   * The expressions that represent factory arguments for the dependencies of a binding.
-   */
-  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
+  @Override
+  public ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
     ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
-    return dependencies.stream().map(this::getDependencyArgument).collect(toImmutableList());
+    return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
   }
 
-  /** Returns the expression to use as an argument for a dependency. */
-  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
+  @Override
+  public CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
     return isProducerFromProvider(frameworkDependency)
         ? getProducerFromProviderBindingExpression(frameworkDependency)
             .getDependencyExpression(frameworkDependency.dependencyRequestKind(), name)
         : bindingExpressions.getDependencyExpression(frameworkDependency, name);
   }
 
-  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
-    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key());
-      builder.add(
-          "<$T>",
-          setType.elementsAreTypeOf(Produced.class)
-              ? setType.unwrappedElementType(Produced.class)
-              : setType.elementType());
-    }
-    int individualProviders = 0;
-    int setProviders = 0;
-    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ContributionType contributionType =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
-      switch (contributionType) {
-        case SET:
-          individualProviders++;
-          methodName = "add" + methodNameSuffix;
-          break;
-        case SET_VALUES:
-          setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
-          break;
-        default:
-          throw new AssertionError(frameworkDependency + " is not a set multibinding");
-      }
-
-      builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency)));
-    }
-    builder.add("builder($L, $L)", individualProviders, setProviders);
-    builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
-
-  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
-    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall =
-        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      builderCall.add(
-          "<$T, $T>",
-          mapType.keyType(),
-          mapType.unwrappedValueType(binding.bindingType().frameworkClass()));
-    }
-    builderCall.add("builder($L)", frameworkDependencies.size());
-    codeBlocks.add(builderCall.build());
-
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
-      BindingKey bindingKey = frameworkDependency.bindingKey();
-      ContributionBinding contributionBinding =
-          graph.resolvedBindings().get(bindingKey).contributionBinding();
-      CodeBlock value =
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency));
-      codeBlocks.add(
-          CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
-    }
-    codeBlocks.add(CodeBlock.of(".build()"));
-
-    return CodeBlocks.concat(codeBlocks.build());
-  }
-
-  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
-    if (!shouldCast) {
-      return notCasted;
-    }
-    return CodeBlock.of("($T) $L", classToCast, notCasted);
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
-   *
-   * <p>The {@code get()} method just returns the component field with the {@link
-   * dagger.internal.ReferenceReleasingProviderManager} object.
-   */
-  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
-      ContributionBinding binding) {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    CodeBlock managerExpression;
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      managerExpression =
-          typedReleasableReferenceManagerDecoratorExpression(
-              getReferenceReleasingProviderManagerExpression(scope),
-              scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
-    }
-
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", managerExpression)
-                    .build())
-            .build());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
-   *
-   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
-   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
-   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
-   */
-  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
-      ContributionBinding binding) {
-    Key key = binding.key();
-    SetType keyType = SetType.from(key);
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Map.Entry<Scope, MemberSelect> entry :
-        referenceReleasingProviderManagerFields.entrySet()) {
-      Scope scope = entry.getKey();
-      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    TypeName keyTypeName = TypeName.get(key.type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyTypeName))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyTypeName)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(managerExpressions.build()))
-                    .build())
-            .build());
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T<$T>($L, $L)",
-        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-        metadata.getAnnotationType(),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
+      FrameworkDependency frameworkDependency) {
+    checkState(isProducerFromProvider(frameworkDependency));
+    return producerFromProviderBindingExpressions.computeIfAbsent(
+        frameworkDependency.bindingKey(),
+        dependencyKey ->
+            bindingExpressionFactory.forProducerFromProviderField(
+                graph.resolvedBindings().get(dependencyKey)));
   }
 
-  /**
-   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
-   * binding.
-   */
-  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
-    if (binding.explicitDependencies().isEmpty()) {
-      verify(
-          binding.bindingType().equals(BindingType.PROVISION),
-          "Absent optional bindings should be provisions: %s",
-          binding);
-      return optionalFactories.absentOptionalProvider(binding);
-    } else {
-      return optionalFactories.presentOptionalFactory(
-          binding, getOnlyElement(getDependencyArguments(binding)));
-    }
+  private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
+    ResolvedBindings resolvedBindings =
+        graph.resolvedBindings().get(frameworkDependency.bindingKey());
+    return resolvedBindings.frameworkClass().equals(Provider.class)
+        && frameworkDependency.frameworkClass().equals(Producer.class);
   }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 97b5b358e..093e5c573 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -32,16 +32,22 @@
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
-  // TODO(dpb): Put the Binding or ResolvedBindings itself here.
-  private final BindingKey bindingKey;
+  private final ResolvedBindings resolvedBindings;
+  private final ClassName componentName;
 
-  BindingExpression(BindingKey bindingKey) {
-    this.bindingKey = checkNotNull(bindingKey);
+  BindingExpression(ResolvedBindings resolvedBindings, ClassName componentName) {
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.componentName = checkNotNull(componentName);
   }
 
-  /** The key for which this instance can fulfill requests. */
-  final BindingKey bindingKey() {
-    return bindingKey;
+  /** The binding this instance uses to fulfill requests. */
+  final ResolvedBindings resolvedBindings() {
+    return resolvedBindings;
+  }
+
+  /** The name of the component owning this binding expression. */
+  final ClassName componentName() {
+    return componentName;
   }
 
   /**
@@ -64,6 +70,7 @@ abstract CodeBlock getDependencyExpression(
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
     private final Elements elements;
+    private final OptionalFactories optionalFactories;
 
     Factory(
         CompilerOptions compilerOptions,
@@ -74,7 +81,8 @@ abstract CodeBlock getDependencyExpression(
         GeneratedComponentModel generatedComponentModel,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
-        Elements elements) {
+        Elements elements,
+        OptionalFactories optionalFactories) {
       this.compilerOptions = checkNotNull(compilerOptions);
       this.componentName = checkNotNull(componentName);
       this.componentFieldNames = checkNotNull(componentFieldNames);
@@ -84,6 +92,7 @@ abstract CodeBlock getDependencyExpression(
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
       this.elements = checkNotNull(elements);
+      this.optionalFactories = checkNotNull(optionalFactories);
     }
 
     /** Creates a binding expression for a field. */
@@ -98,10 +107,16 @@ FrameworkInstanceBindingExpression forProducerFromProviderField(
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
       return producerFromProviderBindingExpression(
-          resolvedBindings.bindingKey(),
+          resolvedBindings,
+          componentName,
           Optional.of(fieldSpec),
           generatedComponentModel,
-          memberSelect);
+          memberSelect,
+          componentBindingExpressions,
+          componentRequirementFields,
+          compilerOptions,
+          graph,
+          optionalFactories);
     }
 
     /** Creates a binding expression for a static method call. */
@@ -146,7 +161,16 @@ private BindingExpression create(
         MemberSelect memberSelect) {
       FrameworkInstanceBindingExpression bindingExpression =
           FrameworkInstanceBindingExpression.create(
-              resolvedBindings, fieldSpec, generatedComponentModel, memberSelect);
+              resolvedBindings,
+              componentName,
+              fieldSpec,
+              generatedComponentModel,
+              memberSelect,
+              componentBindingExpressions,
+              componentRequirementFields,
+              compilerOptions,
+              graph,
+              optionalFactories);
 
       if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
         return bindingExpression;
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 8e45306ac..b49076575 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -115,7 +115,9 @@ private BindingExpression getBindingExpression(BindingKey bindingKey) {
 
   /** Adds a binding expression for a single binding owned by this component. */
   void addBindingExpression(BindingExpression bindingExpression) {
-    bindingExpressionsMaps.get(0).put(bindingExpression.bindingKey(), bindingExpression);
+    bindingExpressionsMaps
+        .get(0)
+        .put(bindingExpression.resolvedBindings().bindingKey(), bindingExpression);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 529d17537..0797433f8 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -216,7 +216,7 @@ protected void addFactoryMethods() {
               : "build";
       component.addMethod(
           methodBuilder("create")
-              .returns(componentDefinitionTypeName())
+              .returns(ClassName.get(graph.componentType()))
               .addModifiers(PUBLIC, STATIC)
               .addStatement("return new Builder().$L()", buildMethodName)
               .build());
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
new file mode 100644
index 000000000..a8b5b164c
--- /dev/null
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -0,0 +1,587 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.InstanceFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * An object that can initialize a framework-type component field for a binding. An instance should
+ * be created for every field.
+ */
+final class FrameworkFieldInitializer {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ComponentRequirementFields componentRequirementFields;
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+  private final CompilerOptions compilerOptions;
+  private final boolean isProducerFromProvider;
+  private final BindingGraph graph;
+  private final OptionalFactories optionalFactories;
+  private final ClassName componentName;
+
+  FrameworkFieldInitializer(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ResolvedBindings resolvedBindings,
+      CompilerOptions compilerOptions,
+      boolean isProducerFromProvider,
+      BindingGraph graph,
+      OptionalFactories optionalFactories,
+      ClassName componentName) {
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.compilerOptions = checkNotNull(compilerOptions);
+    this.isProducerFromProvider = isProducerFromProvider;
+    this.graph = checkNotNull(graph);
+    this.optionalFactories = checkNotNull(optionalFactories);
+    this.componentName = checkNotNull(componentName);
+  }
+
+  /** Returns the expression to use to initialize the field. */
+  CodeBlock getFieldInitialization() {
+    if (isProducerFromProvider) {
+      return componentBindingExpressions.getDependencyExpression(
+          FrameworkDependency.create(resolvedBindings.bindingKey(), PRODUCTION), componentName);
+    }
+
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindingInitialization();
+      case MEMBERS_INJECTION:
+        return membersInjectionBindingInitialization();
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock contributionBindingInitialization() {
+    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+    switch (contributionBinding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                contributionBinding.bindingType().frameworkClass(),
+                componentBindingExpressions.getDependencyExpression(
+                    getOnlyElement(contributionBinding.frameworkDependencies()), componentName));
+        return generatedComponentModel.decorateForScope(
+            delegatingCodeBlock, contributionBinding.scope());
+      case SINGLETON_INSTANCE:
+        checkState(contributionBinding.scope().isPresent());
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return factoryForContributionBindingInitialization(contributionBinding);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock membersInjectionBindingInitialization() {
+    MembersInjectionBinding membersInjectionBinding =
+        resolvedBindings.membersInjectionBinding().get();
+    return CodeBlock.of(
+        "$T.create($L)",
+        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
+        makeParametersCodeBlock(
+            generatedComponentModel.getBindingDependencyExpressions(membersInjectionBinding)));
+  }
+
+  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
+        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
+
+      case COMPONENT_DEPENDENCY:
+        return CodeBlock.of(
+            "$T.create($L)",
+            INSTANCE_FACTORY,
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forDependency(binding.key().type()), componentName));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
+          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          CodeBlock invocation =
+              ComponentProvisionBindingExpression.maybeCheckForNull(
+                  (ProvisionBinding) binding,
+                  compilerOptions,
+                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addStatement("return $L", invocation);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          generatedComponentModel.addType(
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
+          return CodeBlock.of(
+              "new $L($L)",
+              factoryName,
+              componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()), componentName));
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            generatedComponentModel.getSubcomponentName(
+                graph
+                    .componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
+        return CodeBlock.of(
+            "$L",
+            anonymousClassBuilder("")
+                .superclass(providerOf(bindingKeyTypeName))
+                .addMethod(
+                    methodBuilder("get")
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bindingKeyTypeName)
+                        .addStatement("return new $LBuilder()", subcomponentName)
+                        .build())
+                .build());
+
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forBinding(binding), componentName));
+
+      case INJECTION:
+      case PROVISION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+
+          CodeBlock factoryCreate =
+              CodeBlock.of(
+                  "$T.create($L)",
+                  generatedClassNameForBinding(binding),
+                  makeParametersCodeBlock(arguments));
+
+          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+          // type properly, so cast to a raw framework type before scoping.
+          if (binding.bindingKind().equals(INJECTION)
+              && binding.unresolved().isPresent()
+              && binding.scope().isPresent()) {
+            factoryCreate =
+                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+          }
+          return generatedComponentModel.decorateForScope(factoryCreate, binding.scope());
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          FieldSpec dependencyField =
+              FieldSpec.builder(
+                      ClassName.get(dependencyType),
+                      simpleVariableName(dependencyType),
+                      PRIVATE,
+                      FINAL)
+                  .initializer(
+                      componentRequirementFields.getExpressionDuringInitialization(
+                          ComponentRequirement.forDependency(dependencyType.asType()),
+                          componentName))
+                  .build();
+          return CodeBlock.of(
+              "$L",
+              anonymousClassBuilder("")
+                  .superclass(producerOf(bindingKeyTypeName))
+                  .addField(dependencyField)
+                  .addMethod(
+                      methodBuilder("get")
+                          .addAnnotation(Override.class)
+                          .addModifiers(PUBLIC)
+                          .returns(listenableFutureOf(bindingKeyTypeName))
+                          .addStatement(
+                              "return $N.$L()",
+                              dependencyField,
+                              binding.bindingElement().get().getSimpleName())
+                          .build())
+                  .build());
+        }
+
+      case PRODUCTION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+
+          return CodeBlock.of(
+              "new $T($L)",
+              generatedClassNameForBinding(binding),
+              makeParametersCodeBlock(arguments));
+        }
+
+      case SYNTHETIC_MAP:
+        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
+        return CodeBlock.of(
+            "$T.create($L)",
+            mapFactoryClassName(binding),
+            componentBindingExpressions.getDependencyExpression(
+                frameworkDependency, componentName));
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return factoryForSetMultibindingInitialization(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return factoryForMapMultibindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
+
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return factoryForSyntheticOptionalBindingInitialization(binding);
+
+      default:
+        throw new AssertionError(binding);
+    }
+  }
+
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
+  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
+    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    int individualProviders = 0;
+    int setProviders = 0;
+    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+      ContributionType contributionType =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+      String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      switch (contributionType) {
+        case SET:
+          individualProviders++;
+          methodName = "add" + methodNameSuffix;
+          break;
+        case SET_VALUES:
+          setProviders++;
+          methodName = "addCollection" + methodNameSuffix;
+          break;
+        default:
+          throw new AssertionError(frameworkDependency + " is not a set multibinding");
+      }
+
+      builderMethodCalls.add(
+          ".$L($L)",
+          methodName,
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              generatedComponentModel.getDependencyExpression(frameworkDependency)));
+    }
+    builder.add("builder($L, $L)", individualProviders, setProviders);
+    builder.add(builderMethodCalls.build());
+    return builder.add(".build()").build();
+  }
+
+  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
+
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
+    CodeBlock.Builder builderCall =
+        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      builderCall.add(
+          "<$T, $T>",
+          mapType.keyType(),
+          mapType.unwrappedValueType(binding.bindingType().frameworkClass()));
+    }
+    builderCall.add("builder($L)", frameworkDependencies.size());
+    codeBlocks.add(builderCall.build());
+
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
+      CodeBlock value =
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              generatedComponentModel.getDependencyExpression(frameworkDependency));
+      codeBlocks.add(
+          CodeBlock.of(
+              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
+    }
+    codeBlocks.add(CodeBlock.of(".build()"));
+
+    return CodeBlocks.concat(codeBlocks.build());
+  }
+
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
+  private boolean useRawType() {
+    Optional<String> bindingPackage = resolvedBindings.binding().bindingPackage();
+    return bindingPackage.isPresent() && !bindingPackage.get().equals(componentName.packageName());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      CodeBlock releasableReferenceManagerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T<$T>($L, $L)",
+        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+        metadata.getAnnotationType(),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  }
+
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
+  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
+    if (binding.explicitDependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
+      return optionalFactories.absentOptionalProvider(binding);
+    } else {
+      return optionalFactories.presentOptionalFactory(
+          binding,
+          getOnlyElement(generatedComponentModel.getBindingDependencyExpressions(binding)));
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 4bf779eeb..00b8d0b7d 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
@@ -32,22 +32,40 @@
   private final GeneratedComponentModel generatedComponentModel;
   private final MemberSelect memberSelect;
   private final FrameworkType frameworkType;
-  private final boolean isProducerFromProvider;
+  private final FrameworkFieldInitializer fieldInitializer;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   /** Returns a binding expression for a binding. */
   static FrameworkInstanceBindingExpression create(
       ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
+      MemberSelect memberSelect,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories) {
     return new FrameworkInstanceBindingExpression(
-        resolvedBindings.bindingKey(),
+        resolvedBindings,
+        componentName,
         fieldSpec,
         generatedComponentModel,
         memberSelect,
         resolvedBindings.bindingType().frameworkType(),
-        false);
+        // TODO(user): When producerFromProvider is moved, this initialization can be moved
+        // to BindingExpression.Factory
+        new FrameworkFieldInitializer(
+            generatedComponentModel,
+            componentBindingExpressions,
+            componentRequirementFields,
+            resolvedBindings,
+            compilerOptions,
+            false,
+            graph,
+            optionalFactories,
+            componentName));
   }
 
   /**
@@ -55,27 +73,51 @@ static FrameworkInstanceBindingExpression create(
    * from a {@link javax.inject.Provider}.
    */
   static FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      BindingKey bindingKey,
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect) {
+      MemberSelect memberSelect,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories) {
     return new FrameworkInstanceBindingExpression(
-        bindingKey, fieldSpec, generatedComponentModel, memberSelect, FrameworkType.PRODUCER, true);
+        resolvedBindings,
+        componentName,
+        fieldSpec,
+        generatedComponentModel,
+        memberSelect,
+        FrameworkType.PRODUCER,
+        // TODO(user): When producerFromProvider is moved, this initialization can be moved
+        // to BindingExpression.Factory
+        new FrameworkFieldInitializer(
+            generatedComponentModel,
+            componentBindingExpressions,
+            componentRequirementFields,
+            resolvedBindings,
+            compilerOptions,
+            true,
+            graph,
+            optionalFactories,
+            componentName));
   }
 
   private FrameworkInstanceBindingExpression(
-      BindingKey bindingKey,
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkType frameworkType,
-      boolean isProducerFromProvider) {
-    super(bindingKey);
+      FrameworkFieldInitializer fieldInitializer) {
+    super(resolvedBindings, componentName);
     this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
     this.fieldSpec = fieldSpec;
     this.frameworkType = frameworkType;
-    this.isProducerFromProvider = isProducerFromProvider;
+    this.fieldInitializer = fieldInitializer;
   }
 
   @Override
@@ -105,11 +147,6 @@ private String fieldName() {
     return fieldSpec.get().name;
   }
 
-  /** Returns true if this binding expression represents a producer from provider. */
-  boolean isProducerFromProvider() {
-    return isProducerFromProvider;
-  }
-
   /**
    * Sets the initialization state for the binding's underlying field. Only valid for field types.
    *
@@ -128,6 +165,7 @@ private void checkHasField() {
   }
 
   // Adds our field and initialization of our field to the component.
+  // TODO(user): Move this to the field initializer class
   private void maybeInitializeField() {
     if (!fieldSpec.isPresent()) {
       return;
@@ -141,7 +179,7 @@ private void maybeInitializeField() {
             CodeBlock.of(
                 "this.$L = $L;",
                 fieldName(),
-                checkNotNull(generatedComponentModel.getFieldInitialization(this)));
+                checkNotNull(fieldInitializer.getFieldInitialization()));
 
         if (fieldInitializationState == InitializationState.DELEGATED) {
           // If we were recursively invoked, set the delegate factory as part of our initialization
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index e21533230..f3b2a7de8 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,25 +16,51 @@
 
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
 
 /** The model of the component being generated. */
 interface GeneratedComponentModel {
 
-  /** Returns the expression used to initialize a binding expression field. */
-  // TODO(user): Move this method onto FrameworkInstanceBindingExpression and subtypes.
-  CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression);
-
   /** Adds the given field to the component. */
   void addField(FieldSpec fieldSpec);
 
   /** Adds the given code block to the initialize methods of the component. */
   void addInitialization(CodeBlock codeBlock);
 
+  /** Adds the given type to the component. */
+  void addType(TypeSpec typeSpec);
+
+  /** Returns the corresponding subcomponent name for the given subcomponent descriptor. */
+  String getSubcomponentName(ComponentDescriptor subcomponentDescriptor);
+
   /**
    * Returns the {@code private} members injection method that injects objects with the {@code key}.
    */
   MethodSpec getMembersInjectionMethod(Key key);
+
+  /**
+   * Maybe wraps the given creation code block in single/double check or reference releasing
+   * providers.
+   */
+  CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope);
+
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope);
+
+  // TODO(user): this and getDependencyArguments should go on ComponentBindingExpressions
+  // once producerFromProvider fields are pushed into their corresponding binding expressions.
+  // This cannot be done currently due to these expressions being created lazily.
+  /** Returns a code block referencing the given dependency. */
+  CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency);
+
+  /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
+  ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding);
 }
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index a56bf2590..84c8b14da 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -28,7 +28,7 @@
   private final BindingExpression delegate;
 
   SimpleInvocationBindingExpression(BindingExpression delegate) {
-    super(delegate.bindingKey());
+    super(delegate.resolvedBindings(), delegate.componentName());
     this.delegate = delegate;
   }
 
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index c53030770..65a0bbcc7 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -74,7 +74,7 @@ private static ClassName subcomponentName(AbstractComponentWriter parent, Bindin
   }
 
   @Override
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return parent.getReferenceReleasingProviderManagerExpression(scope);
   }
 
