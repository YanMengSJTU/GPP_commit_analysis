diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 8d91101d7..b27fac745 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -490,20 +490,25 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
       }
 
       /**
-       * Returns the component that "owns" {@code binding}.
+       * Returns the component that should contain the framework field for {@code binding}.
        *
-       * <p>If {@code binding} is bound in an ancestor component, resolves {@code request} in this
-       * component's parent. Returns the ancestor component in which it is bound, unless
-       * {@code binding} depends on local multibindings, in which case returns this component.
+       * <p>If {@code binding} is either not bound in an ancestor component or depends on
+       * multibinding contributions in this component, returns this component.
        *
-       * <p>If {@code binding} is not bound in an ancestor component, simply returns this component.
+       * <p>Otherwise, resolves {@code request} in this component's parent in order to resolve any
+       * multibinding contributions in the parent, and returns the parent-resolved
+       * {@link ResolvedBindings#owningComponent(ContributionBinding)}.
        */
       private ComponentDescriptor getOwningComponent(
           DependencyRequest request, ContributionBinding binding) {
-        return isResolvedInParent(request, binding)
-                && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)
-            ? getOwningResolver(binding).get().componentDescriptor
-            : componentDescriptor;
+        if (isResolvedInParent(request, binding)
+            && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {
+          ResolvedBindings parentResolvedBindings =
+              parentResolver.get().resolvedBindings.get(request.bindingKey());
+          return parentResolvedBindings.owningComponent(binding);
+        } else {
+          return componentDescriptor;
+        }
       }
 
       /**
@@ -675,18 +680,19 @@ void resolve(DependencyRequest request) {
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
          */
-        if (getPreviouslyResolvedBindings(bindingKey).isPresent()
-            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
-            && getExplicitBindings(bindingKey.key()).isEmpty()) {
+        if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
           parentResolver.get().resolve(request);
-          /* Cache the inherited parent component's bindings in case resolving at the parent found
-           * bindings in some component between this one and the previously-resolved one. */
-          ResolvedBindings inheritedBindings =
-              getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);
-          resolvedBindings.put(bindingKey, inheritedBindings);
-          return;
+          if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
+              && getExplicitBindings(bindingKey.key()).isEmpty()) {
+            /* Cache the inherited parent component's bindings in case resolving at the parent found
+             * bindings in some component between this one and the previously-resolved one. */
+            ResolvedBindings inheritedBindings =
+                getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);
+            resolvedBindings.put(bindingKey, inheritedBindings);
+            return;
+          }
         }
 
         cycleStack.push(bindingKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 40f1e5e93..0503ddcb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -151,6 +151,16 @@ boolean isEmpty() {
     return allContributionBindings().get(owningComponent());
   }
 
+  /** The component that owns {@code binding}. */
+  ComponentDescriptor owningComponent(ContributionBinding binding) {
+    checkArgument(
+        contributionBindings().contains(binding),
+        "binding is not resolved for %s: %s",
+        bindingKey(),
+        binding);
+    return getOnlyElement(allContributionBindings().inverse().get(binding));
+  }
+
   /**
    * The members-injection binding, regardless of owning component. Empty if these are contribution
    * bindings.
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 0362ef195..2c19b554c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -1561,4 +1561,78 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
         .in(parent)
         .onLine(4);
   }
+  
+  @Test
+  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "Grandchild",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  Object object();",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object dependsOnSet(Set<String> strings) {",
+            "    return \"needs strings: \" + strings;",
+            "  }",
+            "",
+            "  @Provides @IntoSet static String contributesToSet() {",
+            "    return \"parent string\";",
+            "  }",
+            "",
+            "  @Provides int missingDependency(double dub) {",
+            "    return 4;",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static String contributesToSet(int i) {",
+            "    return \"\" + i;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
+        .in(parent)
+        .onLine(4);
+  }
 }
