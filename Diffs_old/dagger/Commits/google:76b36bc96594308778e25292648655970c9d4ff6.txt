diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index dd801c685..45dc4b66d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -173,10 +173,13 @@ private void error(String message, Element element) {
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
+        Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
         for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
           TypeMirror injectableType = (TypeMirror) injectableTypeObject;
+          String providerKey = GeneratorKeys.get(injectableType);
+          injectsProvisionKeys.add(providerKey);
           String key = isInterface(injectableType)
-              ? GeneratorKeys.get(injectableType)
+              ? providerKey
               : GeneratorKeys.rawMembersKey(injectableType);
           linker.requestBinding(key, module.getQualifiedName().toString(),
               getClass().getClassLoader(), false, true);
@@ -216,6 +219,9 @@ private void error(String message, Element element) {
 
           switch (provides.type()) {
             case UNIQUE:
+              if (injectsProvisionKeys.contains(binding.provideKey)) {
+                binding.setDependedOn(true);
+              }
               addTo.put(key, binding);
               break;
 
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index 7a368a3b1..edc8816a4 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -18,12 +18,14 @@
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
@@ -32,7 +34,6 @@
   @Test public void unusedProviderMethodsPassOnLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = true)",
@@ -48,7 +49,6 @@
   @Test public void unusedProviderMethodsFailOnNonLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = false)",
@@ -58,9 +58,44 @@
         "  }",
         "}"));
     ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("Graph validation failed:").in(source).onLine(6).and()
-        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(6).and()
-        .withErrorContaining("1. TestModule.string()").in(source).onLine(6).and()
-        .withErrorContaining("Set library=true in your module").in(source).onLine(6);
+        .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
+        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
+        .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
+        .withErrorContaining("Set library=true in your module").in(source).onLine(5);
   }
+
+  @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+  @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
 }
