diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 4a87ad04a..59c547fbf 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -29,7 +29,6 @@
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
-import dagger.model.Scope;
 import java.util.Optional;
 
 /**
@@ -173,13 +172,6 @@ private boolean modifiableBindingWillBeFinalized(
       case INJECTION:
         // Once we modify any of the above a single time, then they are finalized.
         return modifyingBinding;
-      case PRODUCTION:
-        // For production bindings, we know that the binding will be finalized if the parent is a
-        // non-production component, but for @ProductionScope bindings we don't ever know because an
-        // ancestor non-production component can apply @ProductionScope. We therefore return false
-        // always. If we wanted, we could create a separate ModifiableBindingType for production
-        // scope to allow us to make this distinction.
-        return false;
       case MULTIBINDING:
         return false;
       default:
@@ -260,7 +252,6 @@ private BindingExpression createModifiableBindingExpression(
       case OPTIONAL:
       case MULTIBINDING:
       case INJECTION:
-      case PRODUCTION:
         return bindingExpressions.wrapInMethod(
             resolvedBindings,
             request,
@@ -324,12 +315,6 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
       if (binding.kind().equals(BindingKind.INJECTION)) {
         return ModifiableBindingType.INJECTION;
       }
-
-      if ((binding.scope().map(Scope::isProductionScope).orElse(false)
-              && componentImplementation.isAbstract())
-          || binding.bindingType().equals(BindingType.PRODUCTION)) {
-        return ModifiableBindingType.PRODUCTION;
-      }
     } else if (!resolvableBinding(request)) {
       return ModifiableBindingType.MISSING;
     }
@@ -414,12 +399,6 @@ private boolean shouldModifyImplementation(
       case INJECTION:
         return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
 
-      case PRODUCTION:
-        // TODO(b/117833324): Profile this to see if this check is slow
-        return !resolvedBindings
-            .owningComponent()
-            .equals(componentImplementation.componentDescriptor());
-
       default:
         throw new IllegalStateException(
             String.format(
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
index 92a66f341..7e43ec159 100644
--- a/java/dagger/internal/codegen/ModifiableBindingType.java
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -71,28 +71,6 @@
    */
   INJECTION,
 
-  /**
-   * {@link dagger.producers.ProductionScope} is a unique scope that is allowed on multiple
-   * components. In Ahead-of-Time mode, we don't actually know what component will end up owning the
-   * binding because a parent could install the same module or also be an @ProductionScoped @Inject
-   * constructor.
-   *
-   * <p>We don't apply the same logic to @Reusable, even though it can also be on multiple
-   * components, because it is by definition ok to be reimplemented across multiple components.
-   * Allowing @Reusable bindings to be redefined could only result in more code for subclass
-   * implementations.
-   *
-   * <p>All production bindings are also treated as modifiable since they are implicitly {@link
-   * dagger.producers.ProductionScope} in {@link dagger.producers.internal.AbstractProducer}. If an
-   * ancestor component includes the same module as a descendant component, the descendant's
-   * subclass implementation will need to be replaced with the ancestor's {@link
-   * dagger.producers.Producer} instance. beder@ believes this to be a bug and that, because
-   * {@code @Produces} methods are implicitly scoped, descendant components should not be allowed to
-   * redefine the same module as an ancestor. If we disallow that, we can stop treating all
-   * {@code @Produces} methods as modifiable.
-   */
-  PRODUCTION,
-
   /**
    * A {@link dagger.Binds} method whose dependency is {@link #MISSING}.
    *
@@ -105,7 +83,7 @@
   ;
 
   private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
-      ImmutableSet.of(NONE, INJECTION, MULTIBINDING, OPTIONAL, PRODUCTION);
+      ImmutableSet.of(NONE, INJECTION, MULTIBINDING, OPTIONAL);
 
   boolean isModifiable() {
     return !equals(NONE);
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 12a77379e..cb67eb055 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -4762,7 +4762,7 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "            getResponseDependencyProducer());",
             "    this.setOfResponseProducer =",
             "        SetProducer.<Response>builder(1, 0)",
-            "            .addProducer(getResponseProducer()).build();",
+            "            .addProducer(responseProducer).build();",
             "    this.responsesEntryPoint =",
             "        Producers.entryPointViewOf(getSetOfResponseProducer(), this);",
             "  }",
@@ -4780,10 +4780,6 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "",
             "  protected abstract Producer getResponseDependencyProducer();",
             "",
-            "  protected Producer getResponseProducer() {",
-            "    return responseProducer;",
-            "  }",
-            "",
             "  protected Producer getSetOfResponseProducer() {",
             "    return setOfResponseProducer;",
             "  }",
@@ -4791,7 +4787,7 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  @Override",
             "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
             "    Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
-            "    Producers.cancel(getResponseProducer(), mayInterruptIfRunning);",
+            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
             "  }",
             "",
             "  public abstract static class Builder implements Leaf.Builder {}",
@@ -5003,179 +4999,6 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
         .hasSourceEquivalentTo(generatedRoot);
   }
 
-  @Test
-  public void producesMethodInstalledInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent(modules = InstalledInLeafAndAncestorModule.class)",
-            "interface Leaf {",
-            "  Producer<Object> producer();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InstalledInLeafAndAncestorModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class InstalledInLeafAndAncestorModule {",
-            "  @Produces",
-            "  static Object producer() {",
-            "    return new Object();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
-            "  private Producer<Object> producerEntryPoint;",
-            "  private Producer<Object> producerProducer;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.producerProducer =",
-            "        InstalledInLeafAndAncestorModule_ProducerFactory.create(",
-            "            getProductionImplementationExecutorProvider(),",
-            "            getProductionComponentMonitorProvider());",
-            "    this.producerEntryPoint = Producers.entryPointViewOf(getObjectProducer(), this);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Producer<Object> producer() {",
-            "    return producerEntryPoint;",
-            "  }",
-            "",
-            "  protected abstract Provider<Executor>",
-            "    getProductionImplementationExecutorProvider();",
-            "",
-            "  protected abstract Provider<ProductionComponentMonitor> ",
-            "      getProductionComponentMonitorProvider();",
-            "",
-            "  protected Producer<Object> getObjectProducer() {",
-            "    return producerProducer;",
-            "  }",
-            "",
-            "  @Override",
-            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(getObjectProducer(), mayInterruptIfRunning);",
-            "  }",
-            "}");
-
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent(modules = InstalledInLeafAndAncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor, CancellationListener {",
-            "  private Producer<Object> producerProducer;",
-            "",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.producerProducer =",
-            "        InstalledInLeafAndAncestorModule_ProducerFactory.create(",
-            "            getProductionImplementationExecutorProvider(),",
-            "            getProductionComponentMonitorProvider());",
-            "  }",
-            "",
-            "  protected abstract Provider<Executor>",
-            "    getProductionImplementationExecutorProvider();",
-            "",
-            "  protected abstract Provider<ProductionComponentMonitor>",
-            "      getProductionComponentMonitorProvider();",
-            "",
-            "  protected Producer<Object> getObjectProducer() {",
-            "    return producerProducer;",
-            "  }",
-            "",
-            "  protected Producer<Object> getObjectProducer2() {",
-            "    return getObjectProducer();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(getObjectProducer(), mayInterruptIfRunning);",
-            "  }",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf ",
-            "      implements CancellationListener {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected final Producer<Object> getObjectProducer() {",
-            "      return DaggerAncestor.this.getObjectProducer();",
-            "    }",
-            "",
-            "    @Override",
-            "    public final Producer<Object> producer() {",
-            "      return DaggerAncestor.this.getObjectProducer2();",
-            "    }",
-            "  }",
-            "}");
-
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
   @Test
   public void lazyOfModifiableBinding() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -6430,8 +6253,7 @@ public void modifiedProducerFromProvider() {
             "            getProductionComponentMonitorProvider(),",
             "            getSetOfStringProducer());",
             "    this.dependsOnModifiedProducerFromProviderEntryPoint =",
-            "        Producers.entryPointViewOf(",
-            "            getDependsOnModifiedProducerFromProviderProducer(), this);",
+            "        Producers.entryPointViewOf(dependsOnModifiedProducer, this);",
             "  }",
             "",
             "  @Override",
@@ -6448,14 +6270,9 @@ public void modifiedProducerFromProvider() {
             "",
             "  protected abstract Producer<Set<String>> getSetOfStringProducer();",
             "",
-            "  protected Producer getDependsOnModifiedProducerFromProviderProducer() {",
-            "    return dependsOnModifiedProducer;",
-            "  }",
-            "",
             "  @Override",
             "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(",
-            "      getDependsOnModifiedProducerFromProviderProducer(), mayInterruptIfRunning);",
+            "    Producers.cancel(dependsOnModifiedProducer, mayInterruptIfRunning);",
             "  }",
             "}");
     Compilation compilation = compile(filesToCompile.build());
