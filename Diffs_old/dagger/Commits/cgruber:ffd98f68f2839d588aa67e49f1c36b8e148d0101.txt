diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 5c7a67f24..43d9ebf8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -78,7 +78,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -122,6 +121,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -159,7 +159,7 @@
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
   private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
-  protected Optional<ClassName> builderName = Optional.absent();
+  protected Optional<ClassName> builderName = Optional.empty();
   private final OptionalFactories optionalFactories;
   private boolean done;
 
@@ -248,7 +248,7 @@ private CodeBlock getComponentContributionExpression(ComponentRequirement compon
     MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
     if (fieldSelect == null) {
       if (!builderFields.containsKey(componentRequirement)) {
-        return Optional.absent();
+        return Optional.empty();
       }
       FieldSpec componentField =
           componentField(
@@ -630,7 +630,7 @@ private void addField(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<ClassName>absent());
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
     memberSelects.put(bindingKey, localField(name, frameworkField.name));
   }
 
@@ -678,7 +678,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
    * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
-  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+  private static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
@@ -734,7 +734,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
       default:
         throw new AssertionError();
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   /**
@@ -885,7 +885,7 @@ private void addSubcomponents() {
               .inverse()
               .get(subgraph.componentDescriptor());
       SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, Optional.fromNullable(componentMethodDescriptor), subgraph);
+          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph);
       component.addType(subcomponent.write().build());
     }
   }
@@ -895,7 +895,7 @@ private void addSubcomponents() {
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());
+      initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
     }
     List<List<CodeBlock>> partitions =
         Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
@@ -934,7 +934,7 @@ private void initializeFrameworkTypes() {
     // If the field is inherited or the member select is static, don't initialize.
     MemberSelect memberSelect = getMemberSelect(bindingKey);
     if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
-      return Optional.absent();
+      return Optional.empty();
     }
 
     switch (bindingKey.kind()) {
@@ -973,7 +973,7 @@ private void initializeFrameworkTypes() {
                             : delegatingCodeBlock))));
       case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
-          return Optional.absent();
+          return Optional.empty();
         }
         // fall through
       case CLASS_CONSTRUCTOR:
@@ -993,7 +993,7 @@ private void initializeFrameworkTypes() {
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
 
     if (binding.injectionSites().isEmpty()) {
-      return Optional.absent();
+      return Optional.empty();
     }
 
     return Optional.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
index a56222ff6..558b58f12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -22,7 +22,7 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Optional;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -80,7 +80,7 @@ private static boolean isTypeAccessibleFrom(TypeMirror type, Optional<String> pa
     final Optional<String> packageName;
 
     TypeAccessibilityVisitor() {
-      this(Optional.absent());
+      this(Optional.empty());
     }
 
     TypeAccessibilityVisitor(String packageName) {
@@ -182,7 +182,7 @@ static boolean isElementAccessibleFromOwnPackage(Element element) {
     final Optional<String> packageName;
 
     ElementAccessibilityVisitor() {
-      this(Optional.absent());
+      this(Optional.empty());
     }
 
     ElementAccessibilityVisitor(String packageName) {
@@ -272,7 +272,7 @@ static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
 
   /** Returns true if the raw type of {@code type} is accessible from any package. */
   static boolean isRawTypePubliclyAccessible(TypeMirror type) {
-    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.absent());
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.empty());
   }
 
   private Accessibility() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 7c89b3340..c5051bc12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -29,7 +29,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
@@ -38,6 +37,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import java.util.LinkedHashSet;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
index 62b90a63e..a8a483e11 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -19,8 +19,8 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Maps.uniqueIndex;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.Arrays.asList;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 303d05f8a..5e1d385ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -23,7 +23,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -36,6 +35,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
@@ -223,7 +223,7 @@ static DependencyAssociation create(
     Set<String> packages = nonPublicPackageUse(key().type());
     switch (packages.size()) {
       case 0:
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return Optional.of(packages.iterator().next());
       default:
@@ -283,7 +283,7 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
    * The scope of this binding.
    */
   Optional<Scope> scope() {
-    return Optional.absent();
+    return Optional.empty();
   }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 77fe5bb98..09aa53b58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
+import static dagger.internal.codegen.DaggerElements.ENCLOSING_TYPE_ELEMENT;
 
-import com.google.common.base.Optional;
 import dagger.internal.codegen.Key.HasKey;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -33,17 +33,17 @@
   abstract Optional<? extends Element> bindingElement();
 
   /**
-   * The type enclosing the {@link #bindingElement()}, or {@link Optional#absent()} if {@link
-   * #bindingElement()} is absent.
+   * The type enclosing the {@link #bindingElement()}, or {@link Optional#empty()} if {@link
+   * #bindingElement()} is empty.
    */
   Optional<TypeElement> bindingTypeElement() {
-    return bindingElement().transform(element -> element.accept(ENCLOSING_TYPE_ELEMENT, null));
+    return bindingElement().map(element -> element.accept(ENCLOSING_TYPE_ELEMENT, null));
   }
   
   /**
    * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of
    * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
-   * absent.
+   * empty.
    */
   abstract Optional<TypeElement> contributingModule();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 76644e5c8..0652b4d3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -23,7 +23,6 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
 
@@ -114,7 +113,9 @@ public String format(BindingDeclaration bindingDeclaration) {
       case EXECUTABLE:
         return methodSignatureFormatter.format(
             MoreElements.asExecutable(bindingElement),
-            bindingDeclaration.contributingModule().transform(AS_DECLARED_TYPE));
+            bindingDeclaration
+                .contributingModule()
+                .map(module -> MoreTypes.asDeclared(module.asType())));
       case DECLARED:
         return stripCommonTypePrefixes(bindingElement.asType().toString());
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 0443fffa0..8b695fda3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -35,7 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.Optional;
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -64,6 +63,7 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
@@ -150,7 +150,9 @@ TypeElement componentType() {
         .flatMap(graph -> graph.resolvedBindings().values().stream())
         .flatMap(bindings -> bindings.contributionBindings().stream())
         .filter(ContributionBinding::requiresModuleInstance)
-        .flatMap(bindingDeclaration -> bindingDeclaration.contributingModule().asSet().stream())
+        .map(bindingDeclaration -> bindingDeclaration.contributingModule())
+        .filter(Optional::isPresent)
+        .map(Optional::get)
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
         .forEach(requirements::add);
@@ -214,7 +216,7 @@ TypeElement componentType() {
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<Resolver>absent(), componentDescriptor);
+      return create(Optional.empty(), componentDescriptor);
     }
 
     private BindingGraph create(
@@ -455,27 +457,37 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
             ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
                 optionalBindingDeclarationsBuilder.build();
 
-            contributionBindings.addAll(syntheticMapOfValuesBinding(requestKey).asSet());
-            contributionBindings.addAll(
+            ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
+                ImmutableSet.builder();
+            maybeContributionBindings.add(syntheticMapOfValuesBinding(requestKey));
+            maybeContributionBindings.add(
                 syntheticMultibinding(
-                        requestKey, multibindingContributions, multibindingDeclarations)
-                    .asSet());
-            Optional<ProvisionBinding> subcomponentBuilderBinding =
-                syntheticSubcomponentBuilderBinding(subcomponentDeclarations);
-            if (subcomponentBuilderBinding.isPresent()) {
-              contributionBindings.add(subcomponentBuilderBinding.get());
-              addSubcomponentToOwningResolver(subcomponentBuilderBinding.get());
-            }
-            contributionBindings.addAll(
-                syntheticOptionalBinding(requestKey, optionalBindingDeclarations).asSet());
+                    requestKey, multibindingContributions, multibindingDeclarations));
+            syntheticSubcomponentBuilderBinding(subcomponentDeclarations)
+                .ifPresent(
+                    binding -> {
+                      contributionBindings.add(binding);
+                      addSubcomponentToOwningResolver(binding);
+                    });
+            maybeContributionBindings.add(
+                syntheticOptionalBinding(requestKey, optionalBindingDeclarations));
 
             /* If there are no bindings, add the implicit @Inject-constructed binding if there is
              * one. */
             if (contributionBindings.isEmpty()) {
-              contributionBindings.addAll(
-                  injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());
+              maybeContributionBindings.add(
+                  injectBindingRegistry
+                      .getOrFindProvisionBinding(requestKey)
+                      .map((ContributionBinding b) -> b));
             }
 
+            maybeContributionBindings
+                .build()
+                .stream()
+                .filter(Optional::isPresent)
+                .map(Optional::get)
+                .forEach(contributionBindings::add);
+
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
@@ -514,12 +526,12 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
       }
 
       private Iterable<Key> keysMatchingRequest(Key requestKey) {
-        return ImmutableSet.<Key>builder()
-            .add(requestKey)
-            .addAll(keyFactory.unwrapSetKey(requestKey, Produced.class).asSet())
-            .addAll(keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).asSet())
-            .addAll(keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).asSet())
-            .build();
+        ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
+        keys.add(requestKey);
+        keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
+        keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).ifPresent(keys::add);
+        keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).ifPresent(keys::add);
+        return keys.build();
       }
 
       /**
@@ -536,7 +548,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
                 key,
                 multibindingContributionsForValueMap(key),
                 multibindingDeclarationsForValueMap(key))
-            .transform(
+            .map(
                 syntheticMultibinding -> {
                   switch (syntheticMultibinding.bindingType()) {
                     case PROVISION:
@@ -556,10 +568,12 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
        * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
        * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
        */
-      private FluentIterable<ContributionBinding> multibindingContributionsForValueMap(Key key) {
+      private ImmutableSet<ContributionBinding> multibindingContributionsForValueMap(Key key) {
         return keyFactory
             .implicitFrameworkMapKeys(key)
-            .transformAndConcat(this::getExplicitMultibindings);
+            .stream()
+            .flatMap(mapKey -> getExplicitMultibindings(mapKey).stream())
+            .collect(toImmutableSet());
       }
 
       /**
@@ -567,35 +581,37 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
        * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
        * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
        */
-      private FluentIterable<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
+      private ImmutableSet<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
         return keyFactory
             .implicitFrameworkMapKeys(key)
-            .transformAndConcat(this::getMultibindingDeclarations);
+            .stream()
+            .flatMap(mapKey -> getMultibindingDeclarations(mapKey).stream())
+            .collect(toImmutableSet());
       }
 
       /**
        * Returns a synthetic binding that depends on individual multibinding contributions.
        *
        * <p>If there are no {@code multibindingContributions} or {@code multibindingDeclarations},
-       * returns {@link Optional#absent()}.
+       * returns {@link Optional#empty()}.
        *
        * <p>If there are production {@code multibindingContributions} or the request is for any of
        * the following types, returns a {@link ProductionBinding}.
        *
        * <ul>
-       * <li>{@code Set<Produced<T>>}
-       * <li>{@code Map<K, Producer<V>>}
-       * <li>{@code Map<K, Produced<V>>}
+       *   <li>{@code Set<Produced<T>>}
+       *   <li>{@code Map<K, Producer<V>>}
+       *   <li>{@code Map<K, Produced<V>>}
        * </ul>
        *
        * Otherwise, returns a {@link ProvisionBinding}.
        */
-      private Optional<? extends ContributionBinding> syntheticMultibinding(
+      private Optional<ContributionBinding> syntheticMultibinding(
           Key key,
           Iterable<ContributionBinding> multibindingContributions,
           Iterable<MultibindingDeclaration> multibindingDeclarations) {
         if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
-          return Optional.absent();
+          return Optional.empty();
         } else if (multibindingsRequireProduction(multibindingContributions, key)) {
           return Optional.of(
               productionBindingFactory.syntheticMultibinding(key, multibindingContributions));
@@ -622,9 +638,9 @@ private boolean multibindingsRequireProduction(
       private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
           ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
         return subcomponentDeclarations.isEmpty()
-            ? Optional.<ProvisionBinding>absent()
+            ? Optional.empty()
             : Optional.of(
-            provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
+                provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
       }
 
       /**
@@ -632,15 +648,15 @@ private boolean multibindingsRequireProduction(
        * optionalBindingDeclarations}.
        *
        * <p>If there are no bindings for the underlying key (the key for dependency requests for
-       * {@code Type}), returns a provision binding that always returns {@link Optional#absent()}.
+       * {@code Type}), returns a provision binding that always returns {@link Optional#empty()}.
        *
        * <p>If there are any production bindings for the underlying key, returns a production
        * binding. Otherwise returns a provision binding.
        */
-      private Optional<? extends ContributionBinding> syntheticOptionalBinding(
+      private Optional<ContributionBinding> syntheticOptionalBinding(
           Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
         if (optionalBindingDeclarations.isEmpty()) {
-          return Optional.absent();
+          return Optional.empty();
         }
         ResolvedBindings underlyingKeyBindings =
             lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
@@ -771,7 +787,7 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
             }
           }
           // If a @Reusable binding was not resolved in any ancestor, resolve it here.
-          return Optional.absent();
+          return Optional.empty();
         }
 
         for (Resolver requestResolver : getResolverLineage().reverse()) {
@@ -791,7 +807,7 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
             }
           }
         }
-        return Optional.absent();
+        return Optional.empty();
       }
 
       /** Returns the resolver lineage from parent to child. */
@@ -902,13 +918,13 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
-        Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
+        Optional<ResolvedBindings> result = Optional.ofNullable(resolvedBindings.get(bindingKey));
         if (result.isPresent()) {
           return result;
         } else if (parentResolver.isPresent()) {
           return parentResolver.get().getPreviouslyResolvedBindings(bindingKey);
         } else {
-          return Optional.absent();
+          return Optional.empty();
         }
       }
 
@@ -1008,7 +1024,7 @@ void resolve(BindingKey bindingKey) {
          * from subcomponents.
          *
          * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is
-         *     absent
+         *     empty
          */
         boolean dependsOnLocalBindings(BindingKey bindingKey) {
           checkArgument(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f2ae3e816..26c5d8755 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
@@ -36,6 +35,8 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
@@ -62,7 +63,6 @@
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.isAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
@@ -73,7 +73,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -92,8 +91,6 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentTreeTraverser.BindingGraphTraverser;
-import dagger.internal.codegen.ComponentTreeTraverser.ComponentTreePath;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -106,6 +103,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -458,21 +456,25 @@ private void validateDependencyScopeHierarchy(
         scopedDependencyStack.pop();
       } else {
         // TODO(beder): transitively check scopes of production components too.
-        Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(dependency, Component.class);
-        if (componentAnnotation.isPresent()) {
-          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
-          if (scopedDependencies.size() == 1) {
-            // empty can be ignored (base-case), and > 1 is a different error reported separately.
-            scopeStack.push(scopes);
-            scopedDependencyStack.push(dependency);
-            validateDependencyScopeHierarchy(
-                graph, getOnlyElement(scopedDependencies), scopeStack, scopedDependencyStack);
-            scopedDependencyStack.pop();
-            scopeStack.pop();
-          }
-        } // else: we skip component dependencies which are not components
+        getAnnotationMirror(dependency, Component.class)
+            .ifPresent(
+                componentAnnotation -> {
+                  ImmutableSet<TypeElement> scopedDependencies =
+                      scopedTypesIn(
+                          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation)));
+                  if (scopedDependencies.size() == 1) {
+                    // empty can be ignored (base-case), and > 1 is a separately-reported error.
+                    scopeStack.push(scopes);
+                    scopedDependencyStack.push(dependency);
+                    validateDependencyScopeHierarchy(
+                        graph,
+                        getOnlyElement(scopedDependencies),
+                        scopeStack,
+                        scopedDependencyStack);
+                    scopedDependencyStack.pop();
+                    scopeStack.pop();
+                  }
+                }); // else: we skip component dependencies which are not components
       }
     }
 
@@ -917,7 +919,7 @@ private boolean reportMissingReleasableReferenceManager() {
 
         Optional<DeclaredType> metadataType;
         if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
-          metadataType = Optional.absent();
+          metadataType = Optional.empty();
         } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
           List<? extends TypeMirror> typeArguments =
               MoreTypes.asDeclared(key.type()).getTypeArguments();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index cff4b4cee..084224540 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -16,7 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -38,7 +39,6 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 510f79385..ab90e093c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -16,8 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_NOT_IN_BUILDER;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index e00ee9974..e60744de6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -27,7 +27,6 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsOptionalOf;
 import dagger.Module;
@@ -65,7 +64,7 @@ protected void checkKeyType(
       ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
     super.checkKeyType(builder, keyType);
     if (isValidImplicitProvisionKey(
-            FluentIterable.from(getQualifiers(builder.getSubject())).first(), keyType, types)
+            getQualifiers(builder.getSubject()).stream().findFirst(), keyType, types)
         && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
             .isEmpty()) {
       builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 5b4337ad1..edad7b733 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,7 +19,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.Util.getUnimplementedMethods;
+import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
index fad76705b..7c97cb468 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
@@ -17,11 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.ErrorMessages.CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 
-import com.google.common.base.Optional;
 import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -45,13 +44,16 @@
 
   private void checkNoSourceRetention(
       TypeElement annotatedElement, ValidationReport.Builder<TypeElement> report) {
-    Optional<AnnotationMirror> retention = getAnnotationMirror(annotatedElement, Retention.class);
-    if (retention.isPresent() && getRetentionPolicy(retention.get()).equals(SOURCE)) {
-      report.addError(
-          CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
-          report.getSubject(),
-          retention.get());
-    }
+    getAnnotationMirror(annotatedElement, Retention.class)
+        .ifPresent(
+            retention -> {
+              if (getRetentionPolicy(retention).equals(SOURCE)) {
+                report.addError(
+                    CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
+                    report.getSubject(),
+                    retention);
+              }
+            });
   }
 
   // TODO(dpb): Move the ability to get an annotation type's retention policy somewhere common.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 5ef9b22db..ec805cb08 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
@@ -26,8 +25,9 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.Util.getUnimplementedMethods;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -36,7 +36,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
@@ -59,6 +58,7 @@
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -109,7 +109,7 @@
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(getOnlyElement(kinds, null));
+      return Optional.ofNullable(getOnlyElement(kinds, null));
     }
 
     /**
@@ -128,7 +128,7 @@
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(getOnlyElement(kinds, null));
+      return Optional.ofNullable(getOnlyElement(kinds, null));
     }
 
     Kind(
@@ -386,7 +386,7 @@ static ComponentMethodDescriptor forMembersInjection(
 
     static ComponentMethodDescriptor forSubcomponent(
         ComponentMethodKind kind, ExecutableElement methodElement) {
-      return create(kind, Optional.<DependencyRequest>absent(), methodElement);
+      return create(kind, Optional.empty(), methodElement);
     }
 
     static ComponentMethodDescriptor forSubcomponentBuilder(
@@ -470,7 +470,7 @@ ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
           kind.isPresent() && kind.get().isTopLevel(),
           "%s must be annotated with @Component or @ProductionComponent",
           componentDefinitionType);
-      return create(componentDefinitionType, kind.get(), Optional.<Kind>absent());
+      return create(componentDefinitionType, kind.get(), Optional.empty());
     }
 
     private ComponentDescriptor create(
@@ -564,7 +564,7 @@ private ComponentDescriptor create(
           ? ImmutableList.<DeclaredType>of()
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
-          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
+          Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
       Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
 
       ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
@@ -664,7 +664,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
 
     private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
       if (!builderType.isPresent()) {
-        return Optional.absent();
+        return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
       ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b9b646315..dadb44639 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -17,10 +17,10 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index b5ca7a6c7..9fb7deb3a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -107,23 +107,23 @@ static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
-        Optional.<NullPolicy>empty(),
-        Optional.<Key>empty());
+        Optional.empty(),
+        Optional.empty());
   }
 
   static ComponentRequirement forModule(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.MODULE,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
-        Optional.<NullPolicy>empty(),
-        Optional.<Key>empty());
+        Optional.empty(),
+        Optional.empty());
   }
 
   static ComponentRequirement forBinding(Key key, boolean nullable) {
     return new AutoValue_ComponentRequirement(
         Kind.BINDING,
         key.wrappedType(),
-        nullable ? Optional.of(NullPolicy.ALLOW) : Optional.<NullPolicy>empty(),
+        nullable ? Optional.of(NullPolicy.ALLOW) : Optional.empty(),
         Optional.of(key));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 65076dcbb..d2401056b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
@@ -24,6 +23,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.validateComponentDependencies;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -33,7 +34,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -48,6 +48,7 @@
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -301,7 +302,7 @@ private void validateSubcomponentMethod(
               new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
                 @Override
                 protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-                  return Optional.absent();
+                  return Optional.empty();
                 }
 
                 @Override
@@ -312,7 +313,7 @@ private void validateSubcomponentMethod(
                       return Optional.of(MoreTypes.asTypeElement(t));
                     }
                   }
-                  return Optional.absent();
+                  return Optional.empty();
                 }
               },
               null);
@@ -367,25 +368,13 @@ private void validateSubcomponentBuilderMethod(
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotations(
+  private static Optional<AnnotationMirror> checkForAnnotations(
       TypeMirror type, final Set<? extends Class<? extends Annotation>> annotations) {
     return type.accept(
-        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-          @Override
-          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-            return Optional.absent();
-          }
-
+        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>(Optional.empty()) {
           @Override
           public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-            for (Class<? extends Annotation> annotation : annotations) {
-              Optional<AnnotationMirror> mirror =
-                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
-              if (mirror.isPresent()) {
-                return mirror;
-              }
-            }
-            return Optional.absent();
+            return getAnyAnnotation(t.asElement(), annotations);
           }
         },
         null);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 214e7bc91..fe5bd95d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -17,17 +17,16 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
 import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -41,6 +40,7 @@
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
+import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
@@ -63,13 +63,11 @@
 final class ConfigurationAnnotations {
 
   static Optional<AnnotationMirror> getComponentAnnotation(TypeElement component) {
-    return getAnnotationMirror(component, Component.class)
-        .or(getAnnotationMirror(component, ProductionComponent.class));
+    return getAnyAnnotation(component, Component.class, ProductionComponent.class);
   }
 
   static Optional<AnnotationMirror> getSubcomponentAnnotation(TypeElement subcomponent) {
-    return getAnnotationMirror(subcomponent, Subcomponent.class)
-        .or(getAnnotationMirror(subcomponent, ProductionSubcomponent.class));
+    return getAnyAnnotation(subcomponent, Subcomponent.class, ProductionSubcomponent.class);
   }
 
   static boolean isSubcomponent(Element element) {
@@ -83,7 +81,7 @@ static boolean isSubcomponent(Element element) {
         return Optional.of(nestedType);
       }
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   static boolean isSubcomponentBuilder(Element element) {
@@ -124,8 +122,7 @@ static boolean isSubcomponentBuilder(Element element) {
   }
 
   static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
-    return getAnnotationMirror(moduleElement, Module.class)
-        .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+    return getAnyAnnotation(moduleElement, Module.class, ProducerModule.class);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
@@ -149,7 +146,7 @@ static boolean isSubcomponentBuilder(Element element) {
     return getTypeListValue(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
-  /** Returns the first type that specifies this' nullability, or absent if none. */
+  /** Returns the first type that specifies this' nullability, or empty if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
     for (AnnotationMirror mirror : mirrors) {
@@ -157,7 +154,7 @@ static boolean isSubcomponentBuilder(Element element) {
         return Optional.of(mirror.getAnnotationType());
       }
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   static <T extends Element> void validateComponentDependencies(
@@ -248,10 +245,11 @@ private static void addIncludesFromSuperclasses(Types types, TypeElement element
     while (!types.isSameType(objectType, superclass)
         && superclass.getKind().equals(TypeKind.DECLARED)) {
       element = MoreElements.asType(types.asElement(superclass));
-      Optional<AnnotationMirror> moduleMirror = getModuleAnnotation(element);
-      if (moduleMirror.isPresent()) {
-        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
-      }
+      getModuleAnnotation(element)
+          .ifPresent(
+              moduleMirror -> {
+                builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror)));
+              });
       superclass = element.getSuperclass();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index b363d815f..ee6edd717 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -28,7 +28,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
@@ -39,6 +38,7 @@
 import dagger.Provides;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.producers.Produces;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -255,8 +255,7 @@ final TypeMirror contributedType() {
             mapBindings,
             mapBinding -> {
               AnnotationMirror mapKey = mapBinding.mapKey().get();
-              Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
-              return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
+              return unwrapValue(mapKey).map(AnnotationValue::getValue).orElse(mapKey);
             }));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
new file mode 100644
index 000000000..fe0fa02b2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.common.collect.Lists.asList;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.stream.Collectors.toSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
+
+/**
+ * Utilities for working with {@link Element} objects. Each is a candidate to move to {@link
+ * MoreElements}.
+ */
+final class DaggerElements {
+
+  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, Types types, TypeElement type) {
+    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
+        .filter(hasModifiers(ABSTRACT))
+        .toSet();
+  }
+
+  /**
+   * A visitor that returns the input or the closest enclosing element that is a
+   * {@link TypeElement}.
+   */
+  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+  
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+      
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+   * as any of that of {@code annotationClasses}.
+   */
+  static boolean isAnyAnnotationPresent(
+      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+    for (Class<? extends Annotation> annotation : annotationClasses) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @SafeVarargs
+  static boolean isAnyAnnotationPresent(
+      Element element,
+      Class<? extends Annotation> first,
+      Class<? extends Annotation>... otherAnnotations) {
+    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
+  }
+
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
+   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
+   */
+  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .map(AnnotationMirror::getAnnotationType)
+        .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
+  }
+
+  /**
+   * Returns the annotation present on {@code element} whose type is {@code first} or within {@code
+   * rest}, checking each annotation type in order.
+   */
+  @SafeVarargs
+  static Optional<AnnotationMirror> getAnyAnnotation(
+      Element element, Class<? extends Annotation> first, Class<? extends Annotation>... rest) {
+    return getAnyAnnotation(element, asList(first, rest));
+  }
+
+  /**
+   * Returns the annotation present on {@code element} whose type is in {@code annotations},
+   * checking each annotation type in order.
+   */
+  static Optional<AnnotationMirror> getAnyAnnotation(
+      Element element, Collection<? extends Class<? extends Annotation>> annotations) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .filter(hasAnnotationTypeIn(annotations))
+        .map((AnnotationMirror a) -> a) // Avoid returning Optional<? extends AnnotationMirror>.
+        .findFirst();
+  }
+
+  /** Returns the annotations present on {@code element} of all types. */
+  @SafeVarargs
+  static ImmutableSet<AnnotationMirror> getAllAnnotations(
+      Element element, Class<? extends Annotation> first, Class<? extends Annotation>... rest) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .filter(hasAnnotationTypeIn(asList(first, rest)))
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns an {@link AnnotationMirror} for the annotation of type {@code annotationClass} on
+   * {@code element}, or {@link Optional#empty()} if no such annotation exists. This method is a
+   * safer alternative to calling {@link Element#getAnnotation} as it avoids any interaction with
+   * annotation proxies.
+   */
+  static Optional<AnnotationMirror> getAnnotationMirror(
+      Element element, Class<? extends Annotation> annotationClass) {
+    return Optional.ofNullable(MoreElements.getAnnotationMirror(element, annotationClass).orNull());
+  }
+
+  private static Predicate<AnnotationMirror> hasAnnotationTypeIn(
+      Collection<? extends Class<? extends Annotation>> annotations) {
+    Set<String> annotationClassNames =
+        annotations.stream().map(Class::getCanonicalName).collect(toSet());
+    return annotation ->
+        annotationClassNames.contains(
+            MoreTypes.asTypeElement(annotation.getAnnotationType()).getQualifiedName().toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java b/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java
new file mode 100644
index 000000000..b000e1353
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Utilities for working with {@link TypeMirror} objects. Each is a candidate to move to {@link
+ * MoreTypes}.
+ */
+final class DaggerTypes {
+  /**
+   * Returns the non-{@link Object} superclass of the type with the proper type parameters. An empty
+   * {@link Optional} is returned if there is no non-{@link Object} superclass.
+   */
+  static Optional<DeclaredType> nonObjectSuperclass(
+      Types types, Elements elements, DeclaredType type) {
+    return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index bf7c2ab29..c2d3e8d9f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -24,10 +24,10 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 3eceffff5..7838d09f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -24,6 +24,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.Optionals.firstPresent;
 import static dagger.internal.codegen.TypeNames.lazyOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
@@ -32,7 +33,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -44,6 +44,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
+import java.util.Optional;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -105,7 +106,7 @@
     }
 
     Kind() {
-      this.frameworkClass = Optional.absent();
+      this.frameworkClass = Optional.empty();
     }
 
     /**
@@ -116,11 +117,11 @@
       if (frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)) {
         List<? extends TypeMirror> typeArguments = asDeclared(type).getTypeArguments();
         if (typeArguments.isEmpty()) {
-          return Optional.absent();
+          return Optional.empty();
         }
         return Optional.of(this.ofType(getOnlyElement(typeArguments)));
       }
-      return Optional.<KindAndType>absent();
+      return Optional.empty();
     }
 
     /** Returns a {@link KindAndType} with this kind and {@code type} type. */
@@ -185,7 +186,7 @@ BindingKey bindingKey() {
   abstract boolean isNullable();
 
   /**
-   * An optional name for this request when it's referred to in generated code. If absent, it will
+   * An optional name for this request when it's referred to in generated code. If empty, it will
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
@@ -217,7 +218,7 @@ public KindAndType visitExecutable(ExecutableType executableType, Void p) {
 
           @Override
           public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
-            return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
+            return KindAndType.from(declaredType).orElse(defaultAction(declaredType, p));
           }
 
           @Override
@@ -238,10 +239,10 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
       for (Kind kind : Kind.values()) {
         Optional<KindAndType> kindAndType = kind.from(type);
         if (kindAndType.isPresent()) {
-          return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
+          return firstPresent(kindAndType.get().maybeProviderOfLazy(), kindAndType);
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
@@ -255,7 +256,7 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
           return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
   }
 
@@ -358,7 +359,7 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
-      return forRequiredVariable(variableElement, Optional.<String>absent());
+      return forRequiredVariable(variableElement, Optional.empty());
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
@@ -373,8 +374,7 @@ DependencyRequest forRequiredResolvedVariable(
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(
-          variableElement, resolvedType, qualifier, Optional.<String>absent());
+      return newDependencyRequest(variableElement, resolvedType, qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -387,10 +387,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(
-          provisionMethod,
-          provisionMethodType.getReturnType(),
-          qualifier,
-          Optional.<String>absent());
+          provisionMethod, provisionMethodType.getReturnType(), qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -411,7 +408,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             .requestElement(productionMethod)
             .build();
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
+        return newDependencyRequest(productionMethod, type, qualifier, Optional.empty());
       }
     }
 
@@ -474,7 +471,7 @@ DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, Kind kind)
           .isNullable(
               allowsNull(
                   extractKindAndType(OptionalType.from(requestKey).valueType()).kind(),
-                  Optional.<DeclaredType>absent()))
+                  Optional.empty()))
           .build();
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index dbb463341..176d97a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -23,7 +23,6 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -32,6 +31,7 @@
 import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.producers.Produces;
 import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
 import javax.inject.Provider;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 5513ae77b..95024f4d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -41,7 +41,6 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
@@ -60,6 +59,7 @@
 import dagger.internal.Preconditions;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -107,7 +107,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     if (binding.bindingKind().equals(INJECTION)
         && !injectValidator.isValidType(binding.contributedType())) {
-      return Optional.absent();
+      return Optional.empty();
     }
 
     TypeName providedTypeName = TypeName.get(binding.contributedType());
@@ -121,7 +121,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     if (factoryHasTypeParameters) {
       factoryBuilder.addTypeVariables(typeParameters);
     }
-    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.empty();
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
     ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
 
@@ -161,7 +161,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         }
         break;
       case DELEGATE:
-        return Optional.absent();
+        return Optional.empty();
       default:
         throw new AssertionError();
     }
@@ -213,7 +213,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         createMethod = Optional.of(createMethodBuilder.build());
         break;
       default:
-        createMethod = Optional.absent();
+        createMethod = Optional.empty();
     }
 
     if (constructorBuilder.isPresent()) {
@@ -274,7 +274,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       factoryBuilder.addMethod(createMethod.get());
     }
 
-    proxyMethodFor(binding).asSet().forEach(factoryBuilder::addMethod);
+    proxyMethodFor(binding).ifPresent(factoryBuilder::addMethod);
 
     return Optional.of(factoryBuilder);
   }
@@ -289,7 +289,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   private static Optional<MethodSpec> proxyMethodFor(ProvisionBinding binding) {
     ExecutableElement executableElement = MoreElements.asExecutable(binding.bindingElement().get());
     if (binding.membersInjectionRequest().isPresent() || !shouldGenerateProxy(executableElement)) {
-      return Optional.absent();
+      return Optional.empty();
     }
     return Optional.of(createProxy(executableElement));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index 720b70959..b21b5e09e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 3eff8ec54..18c1126dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -18,10 +18,10 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
@@ -69,7 +69,8 @@ static FrameworkField create(
    */
   static FrameworkField forResolvedBindings(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    return create(frameworkClass.or(ClassName.get(resolvedBindings.frameworkClass())),
+    return create(
+        frameworkClass.orElse(ClassName.get(resolvedBindings.frameworkClass())),
         TypeName.get(fieldValueType(resolvedBindings)),
         frameworkFieldName(resolvedBindings));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index f646ff078..5b87629e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -24,7 +24,6 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
@@ -36,6 +35,7 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
@@ -212,7 +212,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
 
   @CanIgnoreReturnValue
   Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
-    return tryRegisterConstructor(constructorElement, Optional.<TypeMirror>absent(), false);
+    return tryRegisterConstructor(constructorElement, Optional.empty(), false);
   }
 
   @CanIgnoreReturnValue
@@ -239,12 +239,12 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       }
       return Optional.of(binding);
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
-    return tryRegisterMembersInjectedType(typeElement, Optional.<TypeMirror>absent(), false);
+    return tryRegisterMembersInjectedType(typeElement, Optional.empty(), false);
   }
 
   @CanIgnoreReturnValue
@@ -271,14 +271,14 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       }
       return Optional.of(binding);
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @CanIgnoreReturnValue
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
     if (!key.isValidImplicitProvisionKey(types)) {
-      return Optional.absent();
+      return Optional.empty();
     }
     ProvisionBinding binding = provisionBindings.getBinding(key);
     if (binding != null) {
@@ -291,7 +291,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     switch (injectConstructors.size()) {
       case 0:
         // No constructor found.
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return tryRegisterConstructor(
             Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index 549d3d95e..4230e3d2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -47,8 +47,8 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -77,7 +77,7 @@
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   InjectValidator(Types types, Elements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.<Diagnostic.Kind>absent());
+    this(types, elements, compilerOptions, Optional.empty());
   }
 
   private InjectValidator(
@@ -131,7 +131,8 @@ InjectValidator whenGeneratingCode() {
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
           CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
@@ -142,7 +143,8 @@ InjectValidator whenGeneratingCode() {
     if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
       builder.addItem(
           INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
@@ -182,14 +184,16 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           PRIVATE_INJECT_FIELD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           STATIC_INJECT_FIELD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.staticMemberValidationKind()),
           fieldElement);
     }
 
@@ -217,14 +221,16 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           PRIVATE_INJECT_METHOD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           STATIC_INJECT_METHOD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.staticMemberValidationKind()),
           methodElement);
     }
 
@@ -275,7 +281,8 @@ InjectValidator whenGeneratingCode() {
     if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
       builder.addItem(
           INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           typeElement);
     }
     TypeMirror superclass = typeElement.getSuperclass();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index 9b2df2a06..c1d31bacc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -21,9 +21,9 @@
 import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 import com.google.auto.common.AnnotationMirrors;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
@@ -44,7 +44,7 @@
     ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
     switch (qualifierAnnotations.size()) {
       case 0:
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4b8c07b80..058c09f60 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,7 +20,6 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Optional.presentInstances;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -29,6 +28,8 @@
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Optionals.firstPresent;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.AnnotationMirrors;
@@ -38,10 +39,8 @@
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -58,8 +57,10 @@
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import java.util.stream.Stream;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
@@ -226,9 +227,7 @@ TypeMirror type() {
    * a {@link #multibindingContributionIdentifier()}.
    */
   Key withoutMultibindingContributionIdentifier() {
-    return toBuilder()
-        .multibindingContributionIdentifier(Optional.<MultibindingContributionIdentifier>absent())
-        .build();
+    return toBuilder().multibindingContributionIdentifier(Optional.empty()).build();
   }
 
   boolean isValidMembersInjectionKey() {
@@ -296,7 +295,7 @@ public Boolean visitDeclared(DeclaredType type, Void ignored) {
   public String toString() {
     return Joiner.on(' ')
         .skipNulls()
-        .join(qualifier().orNull(), type(), multibindingContributionIdentifier().orNull());
+        .join(qualifier().orElse(null), type(), multibindingContributionIdentifier().orElse(null));
   }
 
   /**
@@ -383,13 +382,13 @@ Key forProducesMethod(ExecutableElement method, TypeElement contributingModule)
     /** Returns the key bound by a {@link Binds} method. */
     Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
       checkArgument(isAnnotationPresent(method, Binds.class));
-      return forBindingMethod(method, contributingModule, Optional.<TypeElement>absent());
+      return forBindingMethod(method, contributingModule, Optional.empty());
     }
 
     /** Returns the base key bound by a {@link BindsOptionalOf} method. */
     Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {
       checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
-      return forBindingMethod(method, contributingModule, Optional.<TypeElement>absent());
+      return forBindingMethod(method, contributingModule, Optional.empty());
     }
 
     private Key forBindingMethod(
@@ -539,11 +538,12 @@ Key forProductionComponentMonitor() {
      * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
      * the classpath).
      */
-    FluentIterable<Key> implicitFrameworkMapKeys(Key requestKey) {
-      return FluentIterable.from(
-          presentInstances(
-              ImmutableList.of(
-                  implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))));
+    ImmutableSet<Key> implicitFrameworkMapKeys(Key requestKey) {
+      return Stream.of(
+              implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))
+          .filter(Optional::isPresent)
+          .map(Optional::get)
+          .collect(toImmutableSet());
     }
 
     /**
@@ -562,8 +562,9 @@ Key forProductionComponentMonitor() {
      * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return rewrapMapKey(possibleMapKey, Produced.class, Producer.class)
-          .or(wrapMapKey(possibleMapKey, Producer.class));
+      return firstPresent(
+          rewrapMapKey(possibleMapKey, Produced.class, Producer.class),
+          wrapMapKey(possibleMapKey, Producer.class));
     }
 
     /**
@@ -603,9 +604,9 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     /**
      * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
      * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
-     * Optional#absent()}.
+     * Optional#empty()}.
      *
-     * <p>Returns {@link Optional#absent()} if {@code newWrappingClass} is not in the classpath.
+     * <p>Returns {@link Optional#empty()} if {@code newWrappingClass} is not in the classpath.
      *
      * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
      *     currentWrappingClass}
@@ -620,7 +621,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
-            return Optional.absent();
+            return Optional.empty();
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(
@@ -629,15 +630,15 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
               possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
      * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
      * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
-     * Otherwise returns {@link Optional#absent()}.
+     * Otherwise returns {@link Optional#empty()}.
      *
-     * <p>Returns {@link Optional#absent()} if {@code WrappingClass} is not in the classpath.
+     * <p>Returns {@link Optional#empty()} if {@code WrappingClass} is not in the classpath.
      */
     private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
       if (MapType.isMap(possibleMapKey)) {
@@ -647,7 +648,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
-            return Optional.absent();
+            return Optional.empty();
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(wrappingElement, mapType.valueType());
@@ -655,12 +656,12 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
               possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
      * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
-     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#absent()}.
+     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#empty()}.
      */
     Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
       if (SetType.isSet(key)) {
@@ -670,7 +671,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
               key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
@@ -680,7 +681,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
      */
     Optional<Key> unwrapOptional(Key key) {
       if (!OptionalType.isOptional(key)) {
-        return Optional.absent();
+        return Optional.empty();
       }
       TypeMirror underlyingType =
           DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
@@ -712,8 +713,7 @@ Key forSetOfReleasableReferenceManagers() {
     /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
     Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
       return forQualifiedType(
-          Optional.<AnnotationMirror>absent(),
-          setOf(typedReleasableReferenceManagerOf(metadataType)));
+          Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
     }
 
     private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 3aec5796b..3db146551 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -23,11 +23,11 @@
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
 import dagger.MapKey;
 import java.util.NoSuchElementException;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -54,7 +54,7 @@
   static Optional<AnnotationMirror> getMapKey(Element bindingElement) {
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
     return mapKeys.isEmpty()
-        ? Optional.<AnnotationMirror>absent()
+        ? Optional.empty()
         : Optional.<AnnotationMirror>of(getOnlyElement(mapKeys));
   }
 
@@ -78,7 +78,7 @@
         mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
     return mapKeyAnnotation.unwrapValue()
         ? Optional.of(getOnlyElement(getAnnotationValuesWithDefaults(mapKey).values()))
-        : Optional.<AnnotationValue>absent();
+        : Optional.empty();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index ed4c2a335..507519966 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -17,17 +17,16 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.nonObjectSuperclass;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.DaggerTypes.nonObjectSuperclass;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
@@ -37,6 +36,7 @@
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -72,7 +72,7 @@
 
   @Override
   Optional<TypeElement> contributingModule() {
-    return Optional.absent();
+    return Optional.empty();
   }
 
   /** The set of individual sites where {@link Inject} is applied. */
@@ -193,7 +193,7 @@ MembersInjectionBinding forInjectedType(
 
       Optional<Key> parentKey =
           nonObjectSuperclass(types, elements, declaredType)
-              .transform(keyFactory::forMembersInjectedType);
+              .map(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
@@ -203,8 +203,8 @@ MembersInjectionBinding forInjectedType(
           typeElement,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
-                  forInjectedType(MoreTypes.asDeclared(typeElement.asType()), Optional.absent()))
-              : Optional.absent(),
+                  forInjectedType(MoreTypes.asDeclared(typeElement.asType()), Optional.empty()))
+              : Optional.empty(),
           injectionSites,
           parentKey);
     }
@@ -277,7 +277,7 @@ private boolean shouldBeInjected(
     }
 
     private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
-        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.absent()) {
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.empty()) {
           @Override
           public Optional<InjectionSite> visitExecutableAsMethod(
               ExecutableElement e, DeclaredType type) {
@@ -291,7 +291,7 @@ private boolean shouldBeInjected(
                     && !e.getModifiers().contains(PRIVATE)
                     && !e.getModifiers().contains(STATIC))
                 ? Optional.of(injectionSiteForInjectField(e, type))
-                : Optional.absent();
+                : Optional.empty();
           }
         };
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index a8598e279..2e9b5df24 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -41,7 +41,6 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -61,6 +60,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
@@ -95,10 +95,10 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
     // Empty members injection bindings are special and don't need source files.
     if (binding.injectionSites().isEmpty()) {
-      return Optional.absent();
+      return Optional.empty();
     }
     if (!injectValidator.isValidType(binding.key().type())) {
-      return Optional.absent();
+      return Optional.empty();
     }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 9e5530458..45bb9ef15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -18,12 +18,13 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -47,7 +48,7 @@
   }
 
   @Override public String format(ExecutableElement method) {
-    return format(method, Optional.<DeclaredType>absent());
+    return format(method, Optional.empty());
   }
 
   /**
@@ -96,10 +97,11 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
 
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
-    if (qualifier.isPresent()) {
-      builder.append(ErrorMessages.format(qualifier.get())).append(' ');
-    }
+    getQualifier(parameter)
+        .ifPresent(
+            qualifier -> {
+              builder.append(ErrorMessages.format(qualifier)).append(' ');
+            });
     builder.append(nameOfType(type));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c6596c27c..ec665409f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -16,12 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -30,9 +30,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Binds;
@@ -46,6 +44,7 @@
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -97,7 +96,7 @@
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
+      return kinds.stream().findFirst();
     }
 
     Kind(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index a13347b10..6d24a5c9e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
@@ -25,6 +24,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
@@ -36,7 +37,6 @@
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.EnumSet.noneOf;
 import static java.util.stream.Collectors.joining;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 2f33eb73e..5f2603e14 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -26,7 +26,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
@@ -36,6 +35,7 @@
 import dagger.producers.ProductionScope;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.Monitors;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
index fb8e5f87e..c9ab5cfcc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -18,13 +18,12 @@
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
-import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.toImmutableList;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Name;
 import javax.lang.model.type.TypeMirror;
@@ -43,9 +42,7 @@ private MoreAnnotationMirrors() {}
    */
   static Optional<Equivalence.Wrapper<AnnotationMirror>> wrapOptionalInEquivalence(
       Optional<AnnotationMirror> optional) {
-    return optional.isPresent()
-        ? Optional.of(AnnotationMirrors.equivalence().wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<AnnotationMirror>>absent();
+    return optional.map(AnnotationMirrors.equivalence()::wrap);
   }
 
   /**
@@ -54,9 +51,7 @@ private MoreAnnotationMirrors() {}
    */
   static Optional<AnnotationMirror> unwrapOptionalEquivalence(
       Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<AnnotationMirror>absent();
+    return wrappedOptional.map(Equivalence.Wrapper::get);
   }
 
   static Name simpleName(AnnotationMirror annotationMirror) {
@@ -69,7 +64,7 @@ static Name simpleName(AnnotationMirror annotationMirror) {
    * @throws IllegalArgumentException unless that member represents a single type
    */
   static TypeMirror getTypeValue(AnnotationMirror annotation, String name) {
-    return asType(getAnnotationValue(annotation, name));
+    return MoreAnnotationValues.asType(getAnnotationValue(annotation, name));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
index cfd708331..eaf7a1713 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAllAnnotations;
 
 import com.google.common.collect.ImmutableSet;
 import dagger.multibindings.ElementsIntoSet;
@@ -31,10 +31,6 @@
  */
 final class MultibindingAnnotations {
   static ImmutableSet<AnnotationMirror> forMethod(ExecutableElement method) {
-    return ImmutableSet.<AnnotationMirror>builder()
-        .addAll(getAnnotationMirror(method, IntoSet.class).asSet())
-        .addAll(getAnnotationMirror(method, ElementsIntoSet.class).asSet())
-        .addAll(getAnnotationMirror(method, IntoMap.class).asSet())
-        .build();
+    return getAllAnnotations(method, IntoSet.class, ElementsIntoSet.class, IntoMap.class);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 61bb5ccfb..df977c235 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index 279304d4f..5be39a059 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -23,7 +23,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
@@ -33,6 +32,7 @@
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index 09f528705..4785b64cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -26,7 +26,6 @@
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
 import dagger.Module;
 import dagger.Multibindings;
@@ -34,6 +33,7 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
@@ -136,13 +136,13 @@ private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableE
     return builder.toString();
   }
 
-  private Optional<BindingType> bindingType(TypeElement multibindingsType) {
+  private static Optional<BindingType> bindingType(TypeElement multibindingsType) {
     if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
       return Optional.of(BindingType.PROVISION);
     } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
       return Optional.of(BindingType.PRODUCTION);
     } else {
-      return Optional.<BindingType>absent();
+      return Optional.empty();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
index f5c14175f..357e621d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
@@ -20,8 +20,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import dagger.BindsOptionalOf;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
index 2a76b05ee..f154ab2d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -22,11 +22,11 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
+import java.util.Optional;
 import javax.lang.model.element.Name;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -75,7 +75,7 @@ CodeBlock presentExpression(CodeBlock value) {
   }
 
   private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
-      new SimpleTypeVisitor8<Optional<OptionalKind>, Void>(Optional.absent()) {
+      new SimpleTypeVisitor8<Optional<OptionalKind>, Void>(Optional.empty()) {
         @Override
         public Optional<OptionalKind> visitDeclared(DeclaredType t, Void p) {
           for (OptionalKind optionalKind : OptionalKind.values()) {
@@ -84,7 +84,7 @@ CodeBlock presentExpression(CodeBlock value) {
               return Optional.of(optionalKind);
             }
           }
-          return Optional.absent();
+          return Optional.empty();
         }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Optionals.java b/compiler/src/main/java/dagger/internal/codegen/Optionals.java
new file mode 100644
index 000000000..e74be14e4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Optionals.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Lists.asList;
+
+import java.util.Comparator;
+import java.util.Optional;
+
+/** Utilities for {@link Optional}s. */
+final class Optionals {
+  /**
+   * A {@link Comparator} that puts empty {@link Optional}s before present ones, and compares
+   * present {@link Optional}s by their values.
+   */
+  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+    return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
+        .thenComparing(Optional::get);
+  }
+
+  /** Returns the first argument that is present, or empty if none are. */
+  @SafeVarargs
+  static <T> Optional<T> firstPresent(Optional<T> first, Optional<T> second, Optional<T>... rest) {
+    return asList(first, second, rest)
+        .stream()
+        .filter(Optional::isPresent)
+        .findFirst()
+        .orElse(Optional.empty());
+  }
+
+  private Optionals() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 4e5cdf4c4..7a2c2c586 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -44,7 +44,6 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -58,6 +57,7 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
 import java.util.Map;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -112,7 +112,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     constructorBuilder,
                     uniqueFieldNames.getUniqueName("module"),
                     TypeName.get(binding.bindingTypeElement().get().asType())))
-            : Optional.<FieldSpec>absent();
+            : Optional.empty();
 
     for (Map.Entry<BindingKey, FrameworkField> entry :
         generateBindingFieldsForDependencies(binding).entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index c51f3a8c4..3dd9e7ce2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -27,11 +27,11 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -121,13 +121,13 @@ protected String badSetValuesTypeMessage() {
     return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
   }
 
-  private Optional<TypeMirror> unwrapListenableFuture(
+  private static Optional<TypeMirror> unwrapListenableFuture(
       ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror type) {
     if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
         reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
-        return Optional.absent();
+        return Optional.empty();
       } else {
         return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index bbcabc679..3f3bd5c27 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -20,17 +20,18 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
-import java.util.Set;
+import java.util.Optional;
+import java.util.stream.Stream;
 import javax.annotation.CheckReturnValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -55,15 +56,15 @@ public BindingType bindingType() {
 
   @Override
   Optional<ProductionBinding> unresolved() {
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    return new ImmutableSet.Builder<DependencyRequest>()
-        .addAll(executorRequest().asSet())
-        .addAll(monitorRequest().asSet())
-        .build();
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return Stream.of(executorRequest(), monitorRequest())
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
   }
 
   /** What kind of object this produces method returns. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index 413bd1a90..5368cd24f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -21,7 +21,6 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.common.base.Optional;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterSpec;
@@ -31,6 +30,7 @@
 import dagger.producers.Production;
 import dagger.producers.ProductionScope;
 import dagger.producers.internal.ProductionImplementation;
+import java.util.Optional;
 import java.util.concurrent.Executor;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 3a774cadc..818c73c5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -31,13 +31,12 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import java.util.Set;
+import java.util.Optional;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -63,8 +62,10 @@
 abstract class ProvisionBinding extends ContributionBinding {
 
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    return membersInjectionRequest().asSet();
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return membersInjectionRequest().isPresent()
+        ? ImmutableSet.of(membersInjectionRequest().get())
+        : ImmutableSet.of();
   }
 
   /** If this provision requires members injection, this will be the corresponding request. */
@@ -163,7 +164,7 @@ ProvisionBinding forInjectConstructor(
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
       if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
-        builder.unresolved(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()));
+        builder.unresolved(forInjectConstructor(constructorElement, Optional.empty()));
       }
       return builder.build();
     }
@@ -183,7 +184,7 @@ ProvisionBinding forInjectConstructor(
           return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     ProvisionBinding forProvidesMethod(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index c0c51c70c..c6f381a63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -19,9 +19,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toSet;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -31,6 +31,8 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
+import java.util.Optional;
+import java.util.Set;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -144,7 +146,9 @@ boolean isEmpty() {
         return ownedContributionBindings();
 
       case MEMBERS_INJECTION:
-        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());
+        return ownedMembersInjectionBinding().isPresent()
+            ? ImmutableSet.of(ownedMembersInjectionBinding().get())
+            : ImmutableSet.of();
 
       default:
         throw new AssertionError(bindingKey());
@@ -185,7 +189,7 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         FluentIterable.from(allMembersInjectionBindings().values()).toSet();
     return membersInjectionBindings.isEmpty()
-        ? Optional.<MembersInjectionBinding>absent()
+        ? Optional.empty()
         : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
   }
 
@@ -194,7 +198,7 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
    * are contribution bindings.
    */
   Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
-    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
+    return Optional.ofNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
   /** Creates a {@link ResolvedBindings} for contribution bindings. */
@@ -323,19 +327,15 @@ public ContributionType contributionType() {
    * @throws IllegalArgumentException if the bindings must be managed in more than one package
    */
   Optional<String> bindingPackage() {
-    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
-    for (Binding binding : bindings()) {
-      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
-    }
-    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
-    switch (bindingPackages.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.of(bindingPackages.iterator().next());
-      default:
-        throw new IllegalArgumentException();
-    }
+    Set<String> bindingPackages =
+        bindings()
+            .stream()
+            .map(Binding::bindingPackage)
+            .filter(Optional::isPresent)
+            .map(Optional::get)
+            .collect(toSet());
+    checkArgument(bindingPackages.size() <= 1);
+    return bindingPackages.stream().findFirst();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index d4ab29a23..74021aede 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -27,7 +27,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -35,6 +34,7 @@
 import dagger.producers.ProductionScope;
 import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
+import java.util.Optional;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -92,7 +92,7 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
   static Optional<Scope> uniqueScopeOf(Element element) {
     ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(element);
     if (scopeAnnotations.isEmpty()) {
-      return Optional.absent();
+      return Optional.empty();
     }
     return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
@@ -146,7 +146,7 @@ boolean canReleaseReferences() {
         return Optional.of(metadata);
       }
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
index 318ef7eef..505c8eaef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
@@ -48,7 +47,7 @@ private SimpleAnnotationMirror(
         annotationType);
     checkArgument(
         FluentIterable.from(methodsIn(annotationType.getEnclosedElements()))
-            .transform(ELEMENT_SIMPLE_NAME)
+            .transform(element -> element.getSimpleName().toString())
             .toSet()
             .equals(namedValues.keySet()),
         "namedValues must have values for exactly the members in %s: %s",
@@ -59,7 +58,8 @@ private SimpleAnnotationMirror(
     this.elementValues =
         Maps.toMap(
             methodsIn(annotationType.getEnclosedElements()),
-            Functions.compose(Functions.forMap(namedValues), ELEMENT_SIMPLE_NAME));
+            Functions.compose(
+                Functions.forMap(namedValues), element -> element.getSimpleName().toString()));
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 96926ee52..bc3391d00 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -19,8 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
+import java.util.Optional;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index dd451e97b..436a7484e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -18,12 +18,12 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
 import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -80,7 +80,7 @@ void generate(T input) throws SourceFileGenerationException {
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
       // otherwise, throw a new one
       throw new SourceFileGenerationException(
-          Optional.<ClassName>absent(), e, getElementForErrorReporting(input));
+          Optional.empty(), e, getElementForErrorReporting(input));
     }
   }
 
@@ -112,7 +112,7 @@ private JavaFile buildJavaFile(
 
   /**
    * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
-   * Optional#absent()} if no file should be generated.
+   * Optional#empty()} if no file should be generated.
    */
   // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.
   // consider renaming to something like typeBuilder() which conveys the mutability of the result
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 43bce4baf..6a33e8a72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -17,10 +17,10 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
-import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
-import static dagger.internal.codegen.Util.optionalComparator;
+import static java.util.Comparator.comparing;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
@@ -56,14 +56,15 @@
    */
   static final Comparator<DependencyRequest> DEPENDENCY_ORDERING =
       // put fields before parameters
-      Comparator.comparing(
-              (DependencyRequest request) -> request.requestElement().transform(Element::getKind),
+      comparing(
+              (DependencyRequest request) -> request.requestElement().map(Element::getKind),
               optionalComparator())
           // order by dependency kind
           .thenComparing(DependencyRequest::kind)
           // then sort by name
           .thenComparing(
-              request -> request.requestElement().transform(ELEMENT_SIMPLE_NAME),
+              request ->
+                  request.requestElement().map(element -> element.getSimpleName().toString()),
               optionalComparator());
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
index a6563d90c..6de7c5956 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -23,8 +23,8 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 3a9cbfc72..8f143819c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -32,7 +32,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -43,6 +42,7 @@
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -57,7 +57,7 @@
   private final AbstractComponentWriter parent;
 
   /**
-   * The parent's factory method to create this subcomponent, or {@link Optional#absent()} if the
+   * The parent's factory method to create this subcomponent, or {@link Optional#empty()} if the
    * subcomponent was added via {@link dagger.Module#subcomponents()}.
    */
   private final Optional<ComponentMethodDescriptor> subcomponentFactoryMethod;
@@ -87,8 +87,11 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   @Override
   protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
       ComponentRequirement componentRequirement) {
-    return super.getOrCreateComponentRequirementFieldExpression(componentRequirement)
-        .or(parent.getOrCreateComponentRequirementFieldExpression(componentRequirement));
+    Optional<CodeBlock> expression =
+        super.getOrCreateComponentRequirementFieldExpression(componentRequirement);
+    return expression.isPresent()
+        ? expression
+        : parent.getOrCreateComponentRequirementFieldExpression(componentRequirement);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 4276bf2d2..771652657 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -52,6 +51,7 @@
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 36a13b28a..0c6046e37 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -17,9 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreElements.hasModifiers;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.collect.Lists.asList;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
@@ -28,27 +26,16 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import java.util.Comparator;
 import java.util.stream.Collector;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.Types;
 
 /**
@@ -134,94 +121,6 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
     }
   }
 
-  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, Types types, TypeElement type) {
-    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
-        .filter(hasModifiers(ABSTRACT))
-        .toSet();
-  }
-
-  /** A function that returns the input as a {@link DeclaredType}. */
-  static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
-      typeElement -> asDeclared(typeElement.asType());
-
-  /**
-   * A visitor that returns the input or the closest enclosing element that is a
-   * {@link TypeElement}.
-   */
-  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
-  /**
-   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
-   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
-   * as any of that of {@code annotationClasses}.
-   */
-  // TODO(dpb): Move to MoreElements.
-  static boolean isAnyAnnotationPresent(
-      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
-    for (Class<? extends Annotation> annotation : annotationClasses) {
-      if (MoreElements.isAnnotationPresent(element, annotation)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @SafeVarargs
-  static boolean isAnyAnnotationPresent(
-      Element element,
-      Class<? extends Annotation> first,
-      Class<? extends Annotation>... otherAnnotations) {
-    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
-  }
-
-  /**
-   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
-   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
-   */
-  // TODO(dpb): Move to MoreElements.
-  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
-    return element
-        .getAnnotationMirrors()
-        .stream()
-        .map(AnnotationMirror::getAnnotationType)
-        .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
-  }
-
-  /**
-   * The elements in {@code elements} that are annotated with an annotation of type
-   * {@code annotation}.
-   */
-  static <E extends Element> FluentIterable<E> elementsWithAnnotation(
-      Iterable<E> elements, final Class<? extends Annotation> annotation) {
-    return FluentIterable.from(elements)
-        .filter(element -> MoreElements.isAnnotationPresent(element, annotation));
-  }
-
-  /** A function that returns the simple name of an element. */
-  static final Function<Element, String> ELEMENT_SIMPLE_NAME =
-      element -> element.getSimpleName().toString();
-
-  /**
-   * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
-   * present {@link Optional}s by their values.
-   */
-  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
-    return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
-        .thenComparing(Optional::get);
-  }
-
   /**
    * Returns a {@link Collector} that accumulates the input elements into a new {@link
    * ImmutableList}, in encounter order.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index 72bcfed07..1a26c6a3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,9 +21,9 @@
 import static javax.tools.Diagnostic.Kind.WARNING;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Optional;
 import javax.annotation.CheckReturnValue;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
@@ -225,11 +225,11 @@ T getSubject() {
     }
 
     Builder<T> addItem(String message, Kind kind, Element element) {
-      return addItem(message, kind, element, Optional.absent(), Optional.absent());
+      return addItem(message, kind, element, Optional.empty(), Optional.empty());
     }
 
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
-      return addItem(message, kind, element, Optional.of(annotation), Optional.absent());
+      return addItem(message, kind, element, Optional.of(annotation), Optional.empty());
     }
 
     Builder<T> addItem(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
index e242db08f..eb9f27109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import java.util.Optional;
 import javax.tools.Diagnostic;
 
 /**
@@ -35,7 +35,7 @@
       case WARNING:
         return Optional.of(Diagnostic.Kind.WARNING);
       default:
-        return Optional.absent();
+        return Optional.empty();
     }
   }
 }
