diff --git a/.gitignore b/.gitignore
index 972ecd34a..f05f56746 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,6 @@
+*~
+\#*\#
+
 .classpath
 .factorypath
 .project
@@ -13,6 +16,7 @@ lib
 target
 pom.xml.*
 release.properties
+build.log
 
 .idea
 *.iml
@@ -21,3 +25,5 @@ classes
 obj
 
 .DS_Store
+
+dependency-reduced-pom.xml
diff --git a/.travis.yml b/.travis.yml
index d6c3e3d99..3e1627c46 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,9 +1,41 @@
-language: java
-install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-script: mvn verify
+language: android
+
+jdk:
+  - oraclejdk7
+  - openjdk7
+
+android:
+  components:
+    - build-tools-20.0.0
+    - android-16
+  licenses:
+    - android-sdk-license-5be876d5
+
+before_install:
+  - sudo rm -f /etc/mavenrc
+  - wget http://www.us.apache.org/dist/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz
+  - tar -zxvf apache-maven-3.1.1-bin.tar.gz
+  - export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=192m"
+  - export M2_HOME=$PWD/apache-maven-3.1.1
+  - export PATH=$M2_HOME/bin:$PATH
+  - mvn --version
+
+install: mvn -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+
+script: mvn -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
 
 notifications:
-  email: false
+  email: dagger-firehose@googlegroups.com
+
+env:
+  global:
+    - secure: eGc3LHBRIPmTnXLM1YoIqG1do9BkpFI2pJm3fz5Cd8UaXtf7Oefa+Ts3rcn4ipee5A+lf8kEouPshSoaQs81KZ2/qf8rSTCIqeFjHR8hzmOVYo/0zRfS/VSUT0yqN+jeRhuNk3+A49RTPlcfJqPv3tyddtrM1vF7axhCJPQIRJM=
+    - secure: LTzrlqcSNeZTOV52D3ibY9RBdxY4Yu8dUOYhAonrWLE+eDTzuoyCzcPw8pEcYVNUi1rG6Q7v3QBDTnBztsPoCbcN5tEGjw5cQEbfEzSTkWaNCFjncWn36cLwx9lgbF+5Db/L0mYJ36unDKUpKVC8AgOtxQibfv/ffugfxxj8ohY=
+    - secure: PEdRiHTy+xVFPnlBwOhr7RVW/QIFSgd4hO0LESRBeF7KGIjxTZWtKPjnYrysZFm6tozMk6WBVJO6avOss0v7L64nemwpCnSspNYBa6pRGPgQ3rv/wgdPSzqDDmABmpPC18EHbUtF94KVdRX3Cr4kmwKQyD+YUKNRCY11Txt+xfo=
+
+after_success:
+  - util/generate-latest-docs.sh
+  - util/publish-snapshot-on-commit.sh
 
 branches:
   except:
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 000000000..957840eca
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,40 @@
+Change Log
+==========
+
+Version 1.2.0 *(2013-12-13)*
+----------------------------
+
+ * Numerous performance improvements in both the compiler and runtime.
+   * Use more efficient `String` concatenation.
+   * Module adapters are now stateless.
+   * Use read/write locks over global locks.
+   * Reflective constructor invocation is now cached with `Class.newInstance`.
+   * Avoid re-linking all bindings when calling `.plus()`.
+ * Set bindings are now unioned when calling `.plus()`.
+ * Fix: Tolerate missing type information during compilation by deferring writing
+   module adapters.
+
+
+Version 1.1.0 *(2013-08-05)*
+----------------------------
+
+ * Module loading now requires code generation via the 'dagger-compiler' artifact.
+ * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`.
+ * Request classloading from the classloader of the requesting object, not the current thread's
+   context classloader.
+ * Cache class loading at the root injector to reduce costs of loading adapters.
+ * Fix: Primitive array types are no longer incorrectly changed to their boxed type.
+ * Update JavaWriter to 2.1.1.
+
+
+Version 1.0.1 *(2013-06-03)*
+----------------------------
+
+ * Explicitly forbid declaring `@Inject` on a class type (e.g., `@Inject class Foo {}`).
+ * Update JavaWriter to 1.0.5.
+
+
+Version 1.0.0 *(2013-05-07)*
+----------------------------
+
+Initial release.
diff --git a/README.md b/README.md
index 9f9d033e4..5f4ee00af 100644
--- a/README.md
+++ b/README.md
@@ -1,47 +1,110 @@
-Dagger
-======
+Dagger 2
+========
 
 A fast dependency injector for Android and Java.
 
-For more information please see [the website][1].
+About Google's Fork
+-------------
 
+Dagger 2 is a compile-time evolution approach to dependency injection.  Taking the approach
+started in Dagger 1.x to its ultimate conclusion, Dagger 2.0 eliminates all reflection, and
+improves code clarity by removing the traditional ObjectGraph/Injector in favor of
+user-specified @Component interfaces. 
 
+This github project represents the Dagger 2 development stream.  The earlier 
+[project page][square] (Square, Inc's repository) represents the earlier 1.0 development stream.  
+Both versions have benefitted from strong involvement from Square, Google, and other contributors. 
 
-Download
+## [Dagger 2's main documentation website can be found here.][website]
+
+Status
+------
+
+  - ***Release Version:* 2.0.1**
+  - ***Snapshot Version:* 2.1-SNAPSHOT**
+
+Dagger is currently in active development, primarily internally at Google, with regular pushes
+to the open-source community.  Snapshot releases are auto-deployed to sonatype's central maven
+repository on a clean build with the version `2.1-SNAPSHOT`.
+
+Documentation
+-------------
+
+You can [find the dagger documentation here][website] which has extended usage
+instructions and other useful information.  Substantial usage information can be
+found in the [API documentation][20api].
+
+You can also learn more from [the original proposal][proposal], 
+[this talk by Greg Kick][gaktalk], and on discussions on the dagger-discuss@googlegroups.com
+mailing list. 
+
+Installation
 --------
 
-You will need to include the `dagger-${dagger.version}.jar` in your
-application's runtime.  In order to activate code generation you will need to
-include `dagger-compiler-${dagger.version}.jar` in your build at compile time.
+You will need to include the `dagger-2.0.1.jar` in your application's runtime.
+In order to activate code generation and generate implementations to manage
+your graph you will need to include `dagger-compiler-2.0.1.jar` in your build
+at compile time.
 
-In a Maven project, one would include the runtime in the dependencies section
-of your `pom.xml` (replacing `${dagger.version}` with the appropriate current
-release), and the `dagger-compiler` artifact as an "optional" dependency:
+In a Maven project, one would include the `dagger` artifact in the dependencies section
+of your `pom.xml` and the `dagger-compiler` artifact as either  an `optional` or `provided`
+dependency:
 
 ```xml
 <dependencies>
   <dependency>
-    <groupId>com.squareup</groupId>
+    <groupId>com.google.dagger</groupId>
     <artifactId>dagger</artifactId>
-    <version>${dagger.version}</version>
+    <version>2.0.1</version>
   </dependency>
   <dependency>
-    <groupId>com.squareup</groupId>
+    <groupId>com.google.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
-    <version>${dagger.version}</version>
+    <version>2.0.1</version>
     <optional>true</optional>
   </dependency>
 </dependencies>
 ```
 
-You can also find downloadable .jars on the [GitHub download page][2].
+If you use the beta `dagger-producers` extension (which supplies parallelizable execution graphs),
+then you should add this to your maven configuration:
 
+```xml
+<dependencies>
+  <dependency>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-producers</artifactId>
+    <version>2.0-beta</version>
+  </dependency>
+</dependencies>
+```
+
+
+### Download 
 
+  * 2.x (google/dagger)
+    * [Dagger 2.0 Documentation][website]
+    * [Dagger 2.0 Javadocs][20api]
+    * [Dagger development Javadocs][latestapi] (from the `master` branch on GitHub)
+    * [Google's Dagger project site on GitHub][project]
+    * <a href="https://plus.google.com/118328287768685565185" rel="publisher">Google+ Dagger Project Page</a>
+    * [Google+ Dagger Users Community][community]
+  * 1.x (square/dagger)
+    * [Square's original Dagger project site on GitHub][square]
+    * [Square Open Source Community][squarecommunity]
+
+
+If you do not use maven, gradle, ivy, or other build systems that consume maven-style binary
+artifacts, they can be downloaded directly via the [Maven Central Repository][mavensearch].
+
+Developer snapshots are available from [Sonatype's snapshot repository][dagger-snap], and
+are built on a clean build of the GitHub project's master branch.
 
 License
 -------
 
     Copyright 2012 Square, Inc.
+    Copyright 2012 Google, Inc.
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
@@ -57,5 +120,15 @@ License
 
 
 
- [1]: http://square.github.com/dagger/
- [2]: http://github.com/square/dagger/downloads
+ [mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
+ [dagger-snap]: https://oss.sonatype.org/content/repositories/snapshots/com/google/dagger/
+ [website]: http://google.github.io/dagger
+ [latestapi]: http://google.github.io/dagger/api/latest/
+ [20api]: http://google.github.io/dagger/api/2.0/
+ [gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
+ [proposal]: https://github.com/square/dagger/issues/366
+ [project]: http://github.com/google/dagger/
+ [community]: https://plus.google.com/communities/111933036769103367883
+ [square]: http://github.com/square/dagger/
+ [squarecommunity]: https://plus.google.com/communities/109244258569782858265
+
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
deleted file mode 100644
index 65aa5448e..000000000
--- a/androidmanifest/README.md
+++ /dev/null
@@ -1,69 +0,0 @@
-AndroidManifest Plugin
-======================
-
-This plugin parses an `AndroidManifest.xml` file for entry points. It has
-designed to be used both in a standalone manner (such as with Ant) and as a
-Maven plugin.
-
-The module generated from this plugin is not automatically added to your
-object graph. You will need to explicitly include it during construction:
-
-```java
-ObjectGraph og = ObjectGraph.create(
-  new MyModule(),       // Your declared module.
-  new ManifestModule()  // Module generated from this plugin.
-);
-```
-
-
-Maven Usage
------------
-
-```xml
-<plugin>
-  <groupId>com.squareup</groupId>
-  <artifactId>dagger-androidmanifest-plugin</artifactId>
-  <version>(latest version)</version>
-  <executions>
-    <execution>
-      <phase>generate-sources</phase>
-      <goals>
-        <goal>generate</goal>
-      </goals>
-    </execution>
-  </executions>
-</plugin>
-```
-
-Optional configuration:
-
- * `androidManifest` - Path to the `AndroidManifest.xml` file.
- * `moduleName` - Generated module class name. Defaults to `ManifestModule` in the package declared
-   in your manifest. May be a fully-qualified class name.
- * `outputDirectory` - Generated source directory, automatically added to build path.
-
-
-
-Ant Usage
----------
-
-```xml
-<taskdef name="dagger-manifest" classname="dagger.androidmanifest.ModuleGeneratorTask"/>
-
-<target name="-pre-build">
-  <dagger-manifest/>
-</target>
-```
-
-Optional task arguments:
-
- * `manifest` - Path to the `AndroidManifest.xml` file.
- * `name` - Generated module class name. Defaults to `ManifestModule` in the package declared in
-   your manifest. May be a fully-qualified class name.
- * `out` - Generated source directory. Defaults to `gen/`.
-
-For example,
-
-```xml
-<dagger-manifest name="com.other.pkg.ActivitiesModule"/>
-```
\ No newline at end of file
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
deleted file mode 100644
index 758f14ba6..000000000
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.androidmanifest;
-
-import dagger.Module;
-import dagger.internal.codegen.JavaWriter;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import org.w3c.dom.Attr;
-import org.w3c.dom.Document;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-/**
- * Generates an object graph module source file that has entry points for all
- * classes referenced in an {@code AndroidManifest.xml} file.
- */
-public final class ModuleGenerator {
-  private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
-  private static final String DAGGER_NS = "http://github.com/square/dagger";
-
-  /**
-   * Returns the path of the generated ManifestModule.java for {@code manifest}.
-   *
-   * @param baseDir the directory where generated files are to be created.
-   */
-  public File path(Document manifest, String moduleName, File baseDir) {
-    String packageName = packageName(manifest, moduleName);
-    int dot = moduleName.lastIndexOf('.');
-    if (dot != -1) {
-      moduleName = moduleName.substring(dot + 1);
-    }
-    return new File(baseDir, packageName.replace('.', '/') + "/" + moduleName + ".java");
-  }
-
-  String packageName(Document manifest, String moduleName) {
-    int dot = moduleName.lastIndexOf('.');
-    if (dot != -1) {
-      return moduleName.substring(0, dot);
-    }
-    Element root = manifest.getDocumentElement();
-    if (!root.getTagName().equals("manifest")) {
-      throw new IllegalArgumentException("Expected <manifest> but was <" + root.getTagName() + ">");
-    }
-    Attr packageAttr = root.getAttributeNode("package");
-    if (packageAttr == null) {
-      throw new IllegalArgumentException("Expected a package attribute");
-    }
-    return packageAttr.getValue();
-  }
-
-  public void generate(Document manifest, String moduleName, JavaWriter out) throws IOException {
-    String packageName = packageName(manifest, moduleName);
-    List<String> nameReferences = getNameReferences(manifest, packageName);
-    generate(packageName, nameReferences, moduleName, out);
-  }
-
-  void generate(String packageName, List<String> nameReferences, String moduleName, JavaWriter out)
-      throws IOException {
-    String className = moduleName.contains(".")
-        ? moduleName
-        : packageName + "." + moduleName;
-    out.emitPackage(packageName);
-    out.emitImports(Arrays.asList(Module.class.getName()));
-
-    List<String> classLiterals = namesToClassLiterals(nameReferences);
-    Collections.sort(classLiterals);
-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
-    attributes.put("entryPoints", classLiterals.toArray());
-    attributes.put("complete", "false");
-
-    out.emitAnnotation(Module.class, attributes);
-    out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);
-    out.endType();
-  }
-
-  /**
-   * Returns class name references for the given class names. This appends the
-   * {@code .class} suffix.
-   */
-  private List<String> namesToClassLiterals(List<String> classNameReferences) {
-    List<String> result = new ArrayList<String>();
-    for (String name : classNameReferences) {
-      result.add(name.replace('$', '.') + ".class");
-    }
-    return result;
-  }
-
-  /**
-   * Returns the names of classes referenced by {@code activity}, {@code
-   * provider}, {@code receiver} and {@code service} tags within {@code
-   * manifest}.
-   */
-  List<String> getNameReferences(Document manifest, String packageName) {
-    List<String> result = new ArrayList<String>();
-    Element root = manifest.getDocumentElement();
-    if (!root.getTagName().equals("manifest")) {
-      throw new IllegalArgumentException("Expected <manifest> but was <" + root.getTagName() + ">");
-    }
-    for (Element e : childElements(root)) {
-      if (!e.getTagName().equals("application")) {
-        continue;
-      }
-      for (Element ee : childElements(e)) {
-        String tagName = ee.getTagName();
-        if (tagName.equals("activity")
-            || tagName.equals("provider")
-            || tagName.equals("receiver")
-            || tagName.equals("service")) {
-          Attr nameAttr = ee.getAttributeNodeNS(ANDROID_NS, "name");
-          if (nameAttr == null) {
-            throw new IllegalArgumentException("Expected a name attribute on " + ee);
-          }
-          Attr entryPointAttr = ee.getAttributeNodeNS(DAGGER_NS, "entryPoint");
-          if (entryPointAttr != null && !Boolean.valueOf(entryPointAttr.getValue())) {
-            continue;
-          }
-          result.add(cleanActivityName(packageName, nameAttr.getValue()));
-        }
-      }
-    }
-    return result;
-  }
-
-  private List<Element> childElements(Element element) {
-    NodeList childNodes = element.getChildNodes();
-    ArrayList<Element> result = new ArrayList<Element>();
-    for (int i = 0; i < childNodes.getLength(); i++) {
-      if (childNodes.item(i).getNodeType() == Node.ELEMENT_NODE) {
-        result.add((Element) childNodes.item(i));
-      }
-    }
-    return result;
-  }
-
-  public Document manifestToDocument(InputSource androidManifestIn)
-      throws IOException, SAXException, ParserConfigurationException {
-    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
-    documentBuilderFactory.setNamespaceAware(true);
-    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
-    return documentBuilder.parse(androidManifestIn);
-  }
-
-  public static void main(String[] args) throws Exception {
-    if (args.length != 3) {
-      printUsage();
-      return;
-    }
-
-    File manifestXml = new File(args[0]);
-    String moduleName = args[1];
-    File baseDir = new File(args[2]);
-
-    if (!manifestXml.exists()) {
-      System.out.println("No such file: " + manifestXml);
-      printUsage();
-      return;
-    }
-
-    if (!baseDir.isDirectory()) {
-      System.out.println("No such directory: " + baseDir);
-      printUsage();
-      return;
-    }
-
-    generate(manifestXml, moduleName, baseDir);
-  }
-
-  /**
-   * Generate a module from the specified {@code AndroidManifest.xml}.
-   *
-   * @param manifestXml Path to the {@code AndroidManifest.xml}.
-   * @param moduleName Name of the target module.
-   * @param baseDir Destination directory for the generated module.
-   */
-  public static void generate(File manifestXml, String moduleName, File baseDir)
-      throws IOException, SAXException, ParserConfigurationException {
-    ModuleGenerator moduleGenerator = new ModuleGenerator();
-    InputSource in = new InputSource(new FileInputStream(manifestXml));
-    Document document = moduleGenerator.manifestToDocument(in);
-    File file = moduleGenerator.path(document, moduleName, baseDir);
-    file.getParentFile().mkdirs();
-    JavaWriter out = new JavaWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"));
-    moduleGenerator.generate(document, moduleName, out);
-    out.close();
-  }
-
-  static String cleanActivityName(String manifestPackage, String activityName) {
-    if (activityName.charAt(0) == '.') {
-      // Relative activity name (e.g., android:name=".ui.SomeClass").
-      return manifestPackage + activityName;
-    }
-    if (activityName.indexOf('.', 1) == -1) {
-      // Unqualified activity name (e.g., android:name="SomeClass").
-      return manifestPackage + "." + activityName;
-    }
-    // Fully-qualified activity name (e.g., "com.my.package.SomeClass").
-    return activityName;
-  }
-
-  private static void printUsage() {
-    System.out.println("Usage: ModuleGenerator manifest module out");
-    System.out.println("  manifest: path to AndroidManifest.xml");
-    System.out.println("    module: name of the generated class, like 'ManifestModule'.");
-    System.out.println("            May be fully-qualified like 'com.squareup.ManifestModule'.");
-    System.out.println("       out: base directory for generated .java source files");
-  }
-}
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
deleted file mode 100644
index fbae3693b..000000000
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
+++ /dev/null
@@ -1,69 +0,0 @@
-// Copyright 2012 Square, Inc.
-package dagger.androidmanifest;
-
-import org.apache.maven.plugin.AbstractMojo;
-import org.apache.maven.plugin.MojoExecutionException;
-import org.apache.maven.project.MavenProject;
-import org.xml.sax.SAXException;
-
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.File;
-import java.io.IOException;
-
-/**
- * Goal which generates an ActivitiesModule for the specified {@code AndroidManifest.xml}.
- *
- * @goal generate
- * @phase generate-sources
- */
-@SuppressWarnings({ "JavaDoc", "UnusedDeclaration" }) // Non-standard Javadoc used by Maven.
-public class ModuleGeneratorMojo extends AbstractMojo {
-
-  /**
-   * The {@code AndroidManifest.xml} file.
-   *
-   * @parameter default-value="${project.basedir}/AndroidManifest.xml"
-   * @required
-   */
-  private File androidManifest;
-
-  /**
-   * The {@code AndroidManifest.xml} file.
-   *
-   * @parameter default-value="ManifestModule"
-   * @required
-   */
-  private String moduleName;
-
-  /**
-   * Location of the file.
-   *
-   * @parameter expression="${project.build.directory}/generated-sources/dagger"
-   * @required
-   */
-  private File outputDirectory;
-
-  /**
-   * Maven project.
-   *
-   * @parameter expression="${project}"
-   * @required
-   * @readonly
-   */
-  private MavenProject project;
-
-  public void execute() throws MojoExecutionException {
-    try {
-      // Attempt to generate the module from the specified manifest.
-      ModuleGenerator.generate(androidManifest, moduleName, outputDirectory);
-      // Add the generated source file to the compile path.
-      project.addCompileSourceRoot(outputDirectory.getAbsolutePath());
-    } catch (IOException e) {
-      throw new MojoExecutionException("Unable to generate module.", e);
-    } catch (SAXException e) {
-      throw new MojoExecutionException("Unable to generate module.", e);
-    } catch (ParserConfigurationException e) {
-      throw new MojoExecutionException("Unable to generate module.", e);
-    }
-  }
-}
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java
deleted file mode 100644
index 2d7fb80bb..000000000
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package dagger.androidmanifest;
-
-import java.io.File;
-import java.io.IOException;
-import javax.xml.parsers.ParserConfigurationException;
-import org.apache.tools.ant.BuildException;
-import org.apache.tools.ant.Task;
-import org.xml.sax.SAXException;
-
-@SuppressWarnings("UnusedDeclaration") // Methods used implicitly by Ant.
-public class ModuleGeneratorTask extends Task {
-  private File manifestFile = new File("AndroidManifest.xml");
-  private String moduleName = "ManifestModule";
-  private File outputDirectory = new File("gen");
-
-  public void setManifest(File manifestFile) {
-    this.manifestFile = manifestFile;
-  }
-
-  public void setName(String moduleName) {
-    this.moduleName = moduleName;
-  }
-
-  public void setOut(File outputDirectory) {
-    this.outputDirectory = outputDirectory;
-  }
-
-  @Override public void execute() {
-    try {
-      ModuleGenerator.generate(manifestFile, moduleName, outputDirectory);
-    } catch (IOException e) {
-      throw new BuildException("Unable to generate module.", e);
-    } catch (SAXException e) {
-      throw new BuildException("Unable to generate module.", e);
-    } catch (ParserConfigurationException e) {
-      throw new BuildException("Unable to generate module.", e);
-    }
-  }
-}
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
deleted file mode 100644
index e7de2ac46..000000000
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.androidmanifest;
-
-import dagger.internal.codegen.JavaWriter;
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import org.junit.Test;
-import org.w3c.dom.Document;
-import org.xml.sax.InputSource;
-
-import static dagger.androidmanifest.ModuleGenerator.cleanActivityName;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ModuleGeneratorTest {
-  private final ModuleGenerator generator = new ModuleGenerator();
-  private final StringWriter stringWriter = new StringWriter();
-
-  @Test public void packageName() throws Exception {
-    Document document = document(""
-        + "<manifest\n"
-        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    package=\"com.squareup.badhorse\"\n"
-        + "    android:versionCode=\"42\"\n"
-        + "    android:versionName=\"42.0\">\n"
-        + "</manifest>");
-    assertThat(generator.packageName(document, "ActivitiesModule"))
-        .isEqualTo("com.squareup.badhorse");
-  }
-
-  @Test public void packageNameWrongDocumentType() throws Exception {
-    Document document = document("<html package=\"com.squareup.badhorse\"/>");
-    try {
-      generator.packageName(document, "ActivitiesModule");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void packageNameNoPackage() throws Exception {
-    Document document = document("<manifest/>");
-    try {
-      generator.packageName(document, "ActivitiesModule");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void packageNameUserSpecified() throws Exception {
-    Document document = document("<manifest package=\"com.squareup.badhorse\"/>");
-    assertThat(generator.packageName(document, "com.squareup.captainhammer.Module"))
-        .isEqualTo("com.squareup.captainhammer");
-  }
-
-  @Test public void extractEntryPointNames() throws Exception {
-    String manifestXml = ""
-        + "<manifest"
-        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    package=\"com.squareup.badhorse\">\n"
-        + "  <uses-permission android:name=\"not.an.entry.point\"/>\n"
-        + "  <permission android:name=\"not.an.entry.point\"/>\n"
-        + "  <application android:name=\"not.an.entry.point\">\n"
-        + "    <uses-library android:name=\"not.an.entry.point\"/>\n"
-        + "    <activity android:name=\"result.a.Activity\">\n"
-        + "      <intent-filter>\n"
-        + "        <action android:name=\"not.an.entry.point\"/>\n"
-        + "        <category android:name=\"not.an.entry.point\"/>\n"
-        + "      </intent-filter>\n"
-        + "    </activity>\n"
-        + "    <provider android:name=\"result.b.Provider\"/>\n"
-        + "    <receiver android:name=\"result.c.Receiver\">\n"
-        + "      <intent-filter>\n"
-        + "        <action android:name=\"not.an.entry.point\"/>\n"
-        + "      </intent-filter>\n"
-        + "    </receiver>\n"
-        + "    <service android:name=\"result.d.Service\"/>\n"
-        + "  </application>\n"
-        + "</manifest>\n";
-    Document document = document(manifestXml);
-    assertThat(generator.getNameReferences(document, "com.squareup.badhorse")).isEqualTo(
-        Arrays.asList("result.a.Activity", "result.b.Provider", "result.c.Receiver", "result.d.Service"));
-  }
-
-  @Test public void excludedEntryPointNames() throws Exception {
-    String manifestXml = ""
-        + "<manifest"
-        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    xmlns:dagger=\"http://github.com/square/dagger\"\n"
-        + "    package=\"com.squareup.badhorse\">\n"
-        + "  <application>\n"
-        + "    <activity android:name=\"false.Activity\" dagger:entryPoint=\"false\"/>\n"
-        + "    <activity android:name=\"true.Activity\" dagger:entryPoint=\"true\"/>\n"
-        + "    <activity android:name=\"default.Activity\"/>\n"
-        + "  </application>\n"
-        + "</manifest>\n";
-    Document document = document(manifestXml);
-    assertThat(generator.getNameReferences(document, "com.squareup.badhorse"))
-        .isEqualTo(Arrays.asList("true.Activity", "default.Activity"));
-  }
-
-  @Test public void fullyQualifyEntryPointNames() throws Exception {
-    assertThat(cleanActivityName("com.squareup.badhorse", "Activity"))
-        .isEqualTo("com.squareup.badhorse.Activity");
-    assertThat(cleanActivityName("com.squareup.badhorse", "org.other.package.Activity"))
-        .isEqualTo("org.other.package.Activity");
-    assertThat(cleanActivityName("com.squareup.badhorse", ".Activity"))
-        .isEqualTo("com.squareup.badhorse.Activity");
-    assertThat(cleanActivityName("com.squareup.badhorse", ".ui.Activity"))
-        .isEqualTo("com.squareup.badhorse.ui.Activity");
-    assertThat(cleanActivityName("com.squareup.badhorse", "com.squareup.badhorse.Activity"))
-        .isEqualTo("com.squareup.badhorse.Activity");
-  }
-
-  @Test public void generate() throws IOException {
-    String packageName = "com.squareup.badhorse";
-    List<String> nameReferences = Arrays.asList(
-        "com.squareup.badhorse.SinActivity", "com.squareup.badhorse.LeagueOfEvilActivity");
-    generator.generate(packageName, nameReferences, "ActivitiesModule",
-        new JavaWriter(stringWriter));
-    assertCode(""
-        + "package com.squareup.badhorse;\n"
-        + "import dagger.Module;\n"
-        + "\n"
-        + "@Module(\n"
-        + "  entryPoints = {\n"
-        + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
-        + "    com.squareup.badhorse.SinActivity.class\n"
-        + "  },\n"
-        + "  complete = false\n"
-        + ")\n"
-        + "public final class ActivitiesModule {\n"
-        + "}\n");
-  }
-
-  @Test public void generateWithUserSpecifiedPackageName() throws IOException {
-    String packageName = "com.squareup.badhorse";
-    List<String> nameReferences = Collections.emptyList();
-    generator.generate(packageName, nameReferences, packageName + ".ActivitiesModule",
-        new JavaWriter(stringWriter));
-    assertCode(""
-        + "package com.squareup.badhorse;\n"
-        + "import dagger.Module;\n"
-        + "\n"
-        + "@Module(\n"
-        + "  entryPoints = {\n"
-        + "  },\n"
-        + "  complete = false\n"
-        + ")\n"
-        + "public final class ActivitiesModule {\n"
-        + "}\n");
-  }
-
-  private Document document(String xml) throws Exception {
-    InputSource xmlIn = new InputSource(new StringReader(xml));
-    return generator.manifestToDocument(xmlIn);
-  }
-
-  private void assertCode(String expected) {
-    assertThat(stringWriter.toString()).isEqualTo(expected);
-  }
-}
diff --git a/checkstyle.xml b/checkstyle.xml
index 4f5575c72..e7ffbc0d5 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,132 +1,137 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-    <!--module name="NewlineAtEndOfFile"/-->
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
-
-    <!-- Trailing spaces -->
-    <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
-    </module>
-
-    <!-- Space after 'for' and 'if' -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*(for|if)[^ ]"/>
-        <property name="message" value="Space needed before opening parenthesis."/>
-    </module>
-
-    <!-- For each spacing -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-        <property name="message" value="Space needed around ':' character."/>
-    </module>
-
-    <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <!--module name="JavadocMethod"/-->
-        <!--module name="JavadocType"/-->
-        <!--module name="JavadocVariable"/-->
-        <!--module name="JavadocStyle"/-->
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <!--<module name="ConstantName"/>-->
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-            <property name="max" value="100"/>
-        </module>
-        <module name="MethodLength"/>
-        <!--module name="ParameterNumber"/-->
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!--module name="ModifierOrder"/-->
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <!--module name="AvoidNestedBlocks"/-->
-        <!--module name="EmptyBlock"/-->
-        <module name="LeftCurly"/>
-        <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
-        <module name="EmptyStatement"/>
-        <!--<module name="EqualsAvoidNull"/>-->
-        <module name="EqualsHashCode"/>
-        <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
-        <!--<module name="InnerAssignment"/>-->
-        <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <!--module name="DesignForExtension"/-->
-        <!--module name="FinalClass"/-->
-        <!--module name="HideUtilityClassConstructor"/-->
-        <!--module name="InterfaceIsType"/-->
-        <!--module name="VisibilityModifier"/-->
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <!--module name="ArrayTypeStyle"/-->
-        <!--module name="FinalParameters"/-->
-        <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
-    </module>
-</module>
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <!--module name="NewlineAtEndOfFile"/-->
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <!--module name="JavadocStyle"/-->
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!--<module name="ConstantName"/>-->
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports">
+            <property name="processJavadoc" value="true"/>
+        </module>
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="100"/>
+        </module>
+        <module name="MethodLength">
+            <property name="max" value="200"/>
+        </module>
+        <!--module name="ParameterNumber"/-->
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround">
+          <property name="allowEmptyConstructors" value="true" />
+          <property name="allowEmptyMethods" value="true" />
+        </module>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!--module name="ModifierOrder"/-->
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <!--module name="AvoidNestedBlocks"/-->
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--module name="NeedBraces"/-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--<module name="InnerAssignment"/>-->
+        <!--module name="MagicNumber"/-->
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--module name="FinalClass"/-->
+        <!--module name="HideUtilityClassConstructor"/-->
+        <!--module name="InterfaceIsType"/-->
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <!--module name="ArrayTypeStyle"/-->
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b9e29a30c..40e0fa27d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -19,10 +19,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
+    <version>2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -37,6 +36,37 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger-producers</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto</groupId>
+      <artifactId>auto-common</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto.service</groupId>
+      <artifactId>auto-service</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <!-- TODO(gak): Restore this presumably as javapoet when appropriate.
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>javawriter</artifactId>
+    </dependency>
+    -->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <optional>true</optional>
+      <version>1.0</version>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -44,8 +74,30 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+      <classifier>tests</classifier>
+    </dependency>
+    <dependency>
+      <groupId>com.google.testing.compile</groupId>
+      <artifactId>compile-testing</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
@@ -53,27 +105,47 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
+        <executions>
+          <execution>
+            <id>default-compile</id>
+            <goals><goal>compile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
+                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-test-compile</id>
+            <goals><goal>testCompile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
-
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-invoker-plugin</artifactId>
         <configuration>
           <addTestClassPath>true</addTestClassPath>
           <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
+          <cloneClean>true</cloneClean>
+          <profiles>
+            <profile>!sonatype-oss-release</profile>
+          </profiles>
           <pomIncludes>
             <pomInclude>*/pom.xml</pomInclude>
           </pomIncludes>
-          <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
-          <postBuildHookScript>verify</postBuildHookScript>
+          <localRepositoryPath>${project.build.directory}/it-repo</localRepositoryPath>
           <filterProperties>
             <dagger.version>${project.version}</dagger.version>
+            <dagger.groupId>${project.groupId}</dagger.groupId>
           </filterProperties>
+          <streamLogs>true</streamLogs>
         </configuration>
         <executions>
           <execution>
@@ -85,6 +157,40 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <artifactId>maven-shade-plugin</artifactId>
+        <version>2.3</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>shade</goal>
+            </goals>
+            <configuration>
+              <minimizeJar>true</minimizeJar>
+              <artifactSet>
+                <excludes>
+                  <!-- guava which has a consistent API and whose public types we vend in producers -->
+                  <exclude>com.google.guava</exclude>
+                  <!-- annotation processors dagger uses to be built, not to operate -->
+                  <exclude>com.google.auto.service</exclude>
+                  <exclude>com.google.auto.value</exclude>
+                  <!-- projects should depend on api projects directly -->
+                  <exclude>com.google.dagger:dagger</exclude>
+                  <exclude>com.google.dagger:dagger-producers</exclude>
+                  <exclude>javax.inject</exclude>
+                </excludes>
+              </artifactSet>
+              <relocations>
+                <relocation>
+                  <pattern>com.google.auto.common</pattern>
+                  <shadedPattern>dagger.shaded.auto.common</shadedPattern>
+                </relocation>
+              </relocations>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
deleted file mode 100644
index ddd9b4443..000000000
--- a/compiler/src/it/extension-graph/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>extension-graph</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
deleted file mode 100644
index b26e0981c..000000000
--- a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.ObjectGraph;
-import dagger.Module;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-class TestApp implements Runnable {
-  @Inject C c;
-
-  @Override public void run() {
-    c.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    extension.get(TestApp.class).run();
-  }
-  
-  @Module(entryPoints = { A.class, B.class })
-  static class RootModule { }
-
-  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
-  static class ExtensionModule { }
-
-  @Singleton
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject A a;
-    @Inject B() {}
-  }
-
-  static class C {
-    @Inject A a;
-    @Inject B b;
-    @Inject C() {}
-    public void doit() {};
-  }
-}
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
new file mode 100644
index 000000000..3a0530f81
--- /dev/null
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -0,0 +1,91 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2014 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>functional-tests</artifactId>
+  <name>Functional Tests</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <!-- For map-bindings -->
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <version>${auto.value.version}</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <configuration>
+          <failsOnError>false</failsOnError>
+          <consoleOutput>true</consoleOutput>
+          <configLocation>../../../../checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/A.java b/compiler/src/it/functional-tests/src/main/java/test/A.java
new file mode 100644
index 000000000..030f8556c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/A.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class A {
+  @Inject A() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
new file mode 100644
index 000000000..4fb0f7832
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+abstract class AbstractMembersInjectingBaseClass {
+  @Inject Thing thing;
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
new file mode 100644
index 000000000..89e94bd2f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/B.java b/compiler/src/it/functional-tests/src/main/java/test/B.java
new file mode 100644
index 000000000..dec8e2e58
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/B.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class B {
+  @Inject B() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
new file mode 100644
index 000000000..78f77dfb8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+/**
+ * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class
+ * rather than an interface.
+ */
+@Component(modules = PrimitivesModule.class)
+abstract class BasicAbstractClassComponent implements BasicComponent {
+  void throwAParty() {
+    throw new RuntimeException("Paaarrrrrtaaaaaaaay!");
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
new file mode 100644
index 000000000..a04607dd4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -0,0 +1,81 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+@Component(modules = PrimitivesModule.class)
+interface BasicComponent extends Injector<Thing> {
+  byte getByte();
+  char getChar();
+  short getShort();
+  int getInt();
+  long getLong();
+  boolean getBoolean();
+  float getFloat();
+  double getDouble();
+
+  Byte getBoxedByte();
+  Character getBoxedChar();
+  Short getBoxedShort();
+  Integer getBoxedInt();
+  Long getBoxedLong();
+  Boolean getBoxedBoolean();
+  Float getBoxedFloat();
+  Double getBoxedDouble();
+
+  Provider<Byte> getByteProvider();
+  Provider<Character> getCharProvider();
+  Provider<Short> getShortProvider();
+  Provider<Integer> getIntProvider();
+  Provider<Long> getLongProvider();
+  Provider<Boolean> getBooleanProvider();
+  Provider<Float> getFloatProvider();
+  Provider<Double> getDoubleProvider();
+
+  byte[] getByteArray();
+  char[] getCharArray();
+  short[] getShortArray();
+  int[] getIntArray();
+  long[] getLongArray();
+  boolean[] getBooleanArray();
+  float[] getFloatArray();
+  double[] getDoubleArray();
+
+  Provider<byte[]> getByteArrayProvider();
+  Provider<char[]> getCharArrayProvider();
+  Provider<short[]> getShortArrayProvider();
+  Provider<int[]> getIntArrayProvider();
+  Provider<long[]> getLongArrayProvider();
+  Provider<boolean[]> getBooleanArrayProvider();
+  Provider<float[]> getFloatArrayProvider();
+  Provider<double[]> getDoubleArrayProvider();
+
+  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
+
+  Thing thing();
+  InjectedThing injectedThing();
+  Provider<InjectedThing> injectedThingProvider();
+  Lazy<InjectedThing> lazyInjectedThing();
+  MembersInjector<InjectedThing> injectedThingMembersInjector();
+
+  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+  MembersInjector<TypeWithInheritedMembersInjection>
+      typeWithInheritedMembersInjectionMembersInjector();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
new file mode 100644
index 000000000..b30522f57
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Component(modules = BoundedGenericModule.class)
+interface BoundedGenericComponent {
+  BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+      bounds1();
+  BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+      bounds2();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
new file mode 100644
index 000000000..6bd7be4fb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Module
+class BoundedGenericModule {
+
+  @Provides
+  Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides
+  Double provideDouble() {
+    return 2d;
+  }
+
+  @Provides
+  ArrayList<String> provideArrayListString() {
+    ArrayList<String> list = new ArrayList<>();
+    list.add("arrayListOfString");
+    return list;
+  }
+
+  @Provides
+  LinkedList<String> provideLinkedListString() {
+    LinkedList<String> list = new LinkedList<>();
+    list.add("linkedListOfString");
+    return list;
+  }
+
+  @Provides
+  LinkedList<CharSequence> provideLinkedListCharSeq() {
+    LinkedList<CharSequence> list = new LinkedList<>();
+    list.add("linkedListOfCharSeq");
+    return list;
+  }
+
+  @Provides
+  @SuppressWarnings("unchecked")
+  LinkedList<Comparable<String>> provideArrayListOfComparableString() {
+    LinkedList<Comparable<String>> list = new LinkedList<>();
+    list.add("arrayListOfComparableOfString");
+    return list;
+  }
+
+  @Provides
+  List<Integer> provideListOfInteger() {
+    LinkedList<Integer> list = new LinkedList<>();
+    list.add(3);
+    return list;
+  }
+
+  @Provides
+  Set<Double> provideSetOfDouble() {
+    Set<Double> set = new HashSet<>();
+    set.add(4d);
+    return set;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
new file mode 100644
index 000000000..e26d64351
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import java.util.List;
+import javax.inject.Inject;
+
+class BoundedGenerics<A extends Number & Comparable<? super A>, 
+      B extends List<? extends CharSequence>,
+      C extends List<? super String>,
+      D extends A,
+      E extends Iterable<D>> {
+  
+  final A a;
+  final B b;
+  final C c;
+  final D d;
+  final E e;
+  
+  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {
+    this.a = a;
+    this.b = b;
+    this.c = c;
+    this.d = d;
+    this.e = e;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
new file mode 100644
index 000000000..09a1e6b72
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
@@ -0,0 +1,21 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildDoubleModule extends ParentModule<Double, String, List<Double>> {
+
+  @Provides Double provideDouble() {
+    return 3d;
+  }
+
+  @Provides List<Double> provideListOfDouble() {
+    List<Double> list = new ArrayList<>();
+    list.add(4d);
+    return list;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
new file mode 100644
index 000000000..ac9c61207
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
@@ -0,0 +1,21 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildIntegerModule extends ParentModule<Integer, String, List<Integer>> {
+
+  @Provides Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides List<Integer> provideListOfInteger() {
+    List<Integer> list = new ArrayList<>();
+    list.add(2);
+    return list;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
new file mode 100644
index 000000000..e2e327494
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class ComplexGenerics {
+  
+  final Generic2<Generic<A>> g2ga;
+  final Lazy<Generic2<Generic<A>>> g2gaLazy;
+  final Provider<Generic2<Generic<A>>> g2gaProvider;
+  final Generic2<Generic<B>> g2gb;
+  final Lazy<Generic2<Generic<B>>> g2gbLazy;
+  final Provider<Generic2<Generic<B>>> g2gbProvider;
+  final Generic2<A> g2a;
+  final Generic<Generic2<A>> gg2a;
+  final Generic<Generic2<B>> gg2b;
+  
+  @Inject ComplexGenerics(
+      Generic2<Generic<A>> g2ga,
+      Lazy<Generic2<Generic<A>>> g2gaLazy,
+      Provider<Generic2<Generic<A>>> g2gaProvider,
+      Generic2<Generic<B>> g2gb,
+      Lazy<Generic2<Generic<B>>> g2gbLazy,
+      Provider<Generic2<Generic<B>>> g2gbProvider,
+      Generic2<A> g2a,
+      Generic<Generic2<A>> gg2a,
+      Generic<Generic2<B>> gg2b) {
+    this.g2ga = g2ga;
+    this.g2gaLazy = g2gaLazy;
+    this.g2gaProvider = g2gaProvider;
+    this.g2gb = g2gb;
+    this.g2gbLazy = g2gbLazy;
+    this.g2gbProvider = g2gbProvider;
+    this.g2a = g2a;
+    this.gg2a = gg2a;
+    this.gg2b = gg2b;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic.java b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
new file mode 100644
index 000000000..ee1aa0992
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic<T> {
+  final T t;
+
+  @Inject public Generic(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
new file mode 100644
index 000000000..4a56df3ec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic2<T> {
+  final T t;
+
+  @Inject Generic2(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
new file mode 100644
index 000000000..5c65dc03e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericChild<T> extends GenericParent<T, B> {
+  
+  A registeredA;
+  T registeredT;
+  
+  @Inject GenericChild() {}
+  
+  @Inject A a;
+  @Inject T t;
+  
+  @Inject void registerA(A a) { this.registeredA = a; }
+  @Inject void registerT(T t) { this.registeredT = t; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
new file mode 100644
index 000000000..da5b9b530
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import test.sub.Exposed;
+import test.sub.PublicSubclass;
+
+@Component(modules = {ChildDoubleModule.class, ChildIntegerModule.class})
+interface GenericComponent {
+  ReferencesGeneric referencesGeneric();
+  GenericDoubleReferences<A> doubleGenericA();
+  GenericDoubleReferences<B> doubleGenericB();
+  ComplexGenerics complexGenerics();
+  GenericNoDeps<A> noDepsA();
+  GenericNoDeps<B> noDepsB();
+
+  void injectA(GenericChild<A> childA);
+  void injectB(GenericChild<B> childB);
+
+  Exposed exposed();
+  PublicSubclass publicSubclass();
+  
+  Iterable<Integer> iterableInt();
+  Iterable<Double> iterableDouble();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
new file mode 100644
index 000000000..6785c7c5f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericDoubleReferences<T> {
+  final T t;
+  final T t2;
+  final Thing a;
+  final Thing a2;
+
+  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {
+    this.t = t;
+    this.a = a;
+    this.t2 = t2;
+    this.a2 = a2;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
new file mode 100644
index 000000000..e065f7926
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericNoDeps<T> {
+  
+  @Inject GenericNoDeps() {}
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
new file mode 100644
index 000000000..0e01f5f7e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericParent<X, Y> {
+  
+  X registeredX;
+  Y registeredY;
+  B registeredB;
+  
+  
+  @Inject GenericParent() {}
+  
+  @Inject X x;
+  @Inject Y y;
+  @Inject B b;
+  
+  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject void registerY(Y y) { this.registeredY = y; }
+  @Inject void registerB(B b) { this.registeredB = b; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
new file mode 100644
index 000000000..73a46e8aa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+@SuppressWarnings("unused")
+final class InjectedThing {
+  @Inject byte primitiveByte;
+  @Inject char primitiveChar;
+  @Inject short primitiveShort;
+  @Inject int primitiveInt;
+  @Inject long primitiveLong;
+  @Inject boolean primitiveBoolean;
+  @Inject float primitiveFloat;
+  @Inject double primitiveDouble;
+
+  @Inject Provider<Byte> byteProvider;
+  @Inject Provider<Character> charProvider;
+  @Inject Provider<Short> shortProvider;
+  @Inject Provider<Integer> intProvider;
+  @Inject Provider<Long> longProvider;
+  @Inject Provider<Boolean> booleanProvider;
+  @Inject Provider<Float> floatProvider;
+  @Inject Provider<Double> doubleProvider;
+
+  @Inject Lazy<Byte> lazyByte;
+  @Inject Lazy<Character> lazyChar;
+  @Inject Lazy<Short> lazyShort;
+  @Inject Lazy<Integer> lazyInt;
+  @Inject Lazy<Long> lazyLong;
+  @Inject Lazy<Boolean> lazyBoolean;
+  @Inject Lazy<Float> lazyFloat;
+  @Inject Lazy<Double> lazyDouble;
+
+  @Inject Byte boxedBype;
+  @Inject Character boxedChar;
+  @Inject Short boxedShort;
+  @Inject Integer boxedInt;
+  @Inject Long boxedLong;
+  @Inject Boolean boxedBoolean;
+  @Inject Float boxedFloat;
+  @Inject Double boxedDouble;
+
+  @Inject byte[] byteArray;
+  @Inject char[] charArray;
+  @Inject short[] shortArray;
+  @Inject int[] intArray;
+  @Inject long[] longArray;
+  @Inject boolean[] booleanArray;
+  @Inject float[] floatArray;
+  @Inject double[] doubleArray;
+
+  @Inject Provider<byte[]> byteArrayProvider;
+  @Inject Provider<char[]> charArrayProvider;
+  @Inject Provider<short[]> shortArrayProvider;
+  @Inject Provider<int[]> intArrayProvider;
+  @Inject Provider<long[]> longArrayProvider;
+  @Inject Provider<boolean[]> booleanArrayProvider;
+  @Inject Provider<float[]> floatArrayProvider;
+  @Inject Provider<double[]> doubleArrayProvider;
+
+  @Inject Lazy<byte[]> lazyByteArray;
+  @Inject Lazy<char[]> lazyCharArray;
+  @Inject Lazy<short[]> lazyShortArray;
+  @Inject Lazy<int[]> lazyIntArray;
+  @Inject Lazy<long[]> lazyLongArray;
+  @Inject Lazy<boolean[]> lazyBooleanArray;
+  @Inject Lazy<float[]> lazy;
+  @Inject Lazy<double[]> lazyDoubleArray;
+
+  @Inject Thing thing;
+  @Inject Provider<Thing> thingProvider;
+  @Inject Lazy<Thing> lazyThing;
+  @Inject MembersInjector<Thing> thingMembersInjector;
+
+  @Inject InjectedThing(
+      byte primitiveByte,
+      char primitiveChar,
+      short primitiveShort,
+      int primitiveInt,
+      long primitiveLong,
+      boolean primitiveBoolean,
+      float primitiveFloat,
+      double primitiveDouble,
+
+      Provider<Byte> byteProvider,
+      Provider<Character> charProvider,
+      Provider<Short> shortProvider,
+      Provider<Integer> intProvider,
+      Provider<Long> longProvider,
+      Provider<Boolean> booleanProvider,
+      Provider<Float> floatProvider,
+      Provider<Double> doubleProvider,
+
+      Lazy<Byte> lazyByte,
+      Lazy<Character> lazyChar,
+      Lazy<Short> lazyShort,
+      Lazy<Integer> lazyInt,
+      Lazy<Long> lazyLong,
+      Lazy<Boolean> lazyBoolean,
+      Lazy<Float> lazyFloat,
+      Lazy<Double> lazyDouble,
+
+      Byte boxedBype,
+      Character boxedChar,
+      Short boxedShort,
+      Integer boxedInt,
+      Long boxedLong,
+      Boolean boxedBoolean,
+      Float boxedFloat,
+      Double boxedDouble,
+
+      byte[] byteArray,
+      char[] charArray,
+      short[] shortArray,
+      int[] intArray,
+      long[] longArray,
+      boolean[] booleanArray,
+      float[] floatArray,
+      double[] doubleArray,
+
+      Provider<byte[]> byteArrayProvider,
+      Provider<char[]> charArrayProvider,
+      Provider<short[]> shortArrayProvider,
+      Provider<int[]> intArrayProvider,
+      Provider<long[]> longArrayProvider,
+      Provider<boolean[]> booleanArrayProvider,
+      Provider<float[]> floatArrayProvider,
+      Provider<double[]> doubleArrayProvider,
+
+      Lazy<byte[]> lazyByteArray,
+      Lazy<char[]> lazyCharArray,
+      Lazy<short[]> lazyShortArray,
+      Lazy<int[]> lazyIntArray,
+      Lazy<long[]> lazyLongArray,
+      Lazy<boolean[]> lazyBooleanArray,
+      Lazy<float[]> lazy,
+      Lazy<double[]> lazyDoubleArray,
+
+      Thing thing,
+      Provider<Thing> thingProvider,
+      Lazy<Thing> lazyThing,
+      MembersInjector<Thing> thingMembersInjector) {}
+
+  @Inject void primitiveByte(byte primitiveByte) {}
+  @Inject void primitiveChar(char primitiveChar) {}
+  @Inject void primitiveShort(short primitiveShort) {}
+  @Inject void primitiveInt(int primitiveInt) {}
+  @Inject void primitiveLong(long primitiveLong) {}
+  @Inject void primitiveBoolean(boolean primitiveBoolean) {}
+  @Inject void primitiveFloat(float primitiveFloat) {}
+  @Inject void primitiveDouble(double primitiveDouble) {}
+
+  @Inject void byteProvider(Provider<Byte> byteProvider) {}
+  @Inject void charProvider(Provider<Character> charProvider) {}
+  @Inject void shortProvider(Provider<Short> shortProvider) {}
+  @Inject void intProvider(Provider<Integer> intProvider) {}
+  @Inject void longProvider(Provider<Long> longProvider) {}
+  @Inject void booleanProvider(Provider<Boolean> booleanProvider) {}
+  @Inject void floatProvider(Provider<Float> floatProvider) {}
+  @Inject void doubleProvider(Provider<Double> doubleProvider) {}
+
+  @Inject void lazyByte(Lazy<Byte> lazyByte) {}
+  @Inject void lazyChar(Lazy<Character> lazyChar) {}
+  @Inject void lazyShort(Lazy<Short> lazyShort) {}
+  @Inject void lazyInt(Lazy<Integer> lazyInt) {}
+  @Inject void lazyLong(Lazy<Long> lazyLong) {}
+  @Inject void lazyBoolean(Lazy<Boolean> lazyBoolean) {}
+  @Inject void lazyFloat(Lazy<Float> lazyFloat) {}
+  @Inject void lazyDouble(Lazy<Double> lazyDouble) {}
+
+  @Inject void boxedBype(Byte boxedBype) {}
+  @Inject void boxedChar(Character boxedChar) {}
+  @Inject void boxedShort(Short boxedShort) {}
+  @Inject void boxedInt(Integer boxedInt) {}
+  @Inject void boxedLong(Long boxedLong) {}
+  @Inject void boxedBoolean(Boolean boxedBoolean) {}
+  @Inject void boxedFloat(Float boxedFloat) {}
+  @Inject void boxedDouble(Double boxedDouble) {}
+
+  @Inject void byteArray(byte[] byteArray) {}
+  @Inject void charArray(char[] charArray) {}
+  @Inject void shortArray(short[] shortArray) {}
+  @Inject void intArray(int[] intArray) {}
+  @Inject void longArray(long[] longArray) {}
+  @Inject void booleanArray(boolean[] booleanArray) {}
+  @Inject void floatArray(float[] floatArray) {}
+  @Inject void doubleArray(double[] doubleArray) {}
+
+  @Inject void byteArrayProvider(Provider<byte[]> byteArrayProvider) {}
+  @Inject void charArrayProvider(Provider<char[]> charArrayProvider) {}
+  @Inject void shortArrayProvider(Provider<short[]> shortArrayProvider) {}
+  @Inject void intArrayProvider(Provider<int[]> intArrayProvider) {}
+  @Inject void longArrayProvider(Provider<long[]> longArrayProvider) {}
+  @Inject void booleanArrayProvider(Provider<boolean[]> booleanArrayProvider) {}
+  @Inject void floatArrayProvider(Provider<float[]> floatArrayProvider) {}
+  @Inject void doubleArrayProvider(Provider<double[]> doubleArrayProvider) {}
+
+  @Inject void lazyByteArray(Lazy<byte[]> lazyByteArray) {}
+  @Inject void lazyCharArray(Lazy<char[]> lazyCharArray) {}
+  @Inject void lazyShortArray(Lazy<short[]> lazyShortArray) {}
+  @Inject void lazyIntArray(Lazy<int[]> lazyIntArray) {}
+  @Inject void lazyLongArray(Lazy<long[]> lazyLongArray) {}
+  @Inject void lazyBooleanArray(Lazy<boolean[]> lazyBooleanArray) {}
+  @Inject void lazy(Lazy<float[]> lazy) {}
+  @Inject void lazyDoubleArray(Lazy<double[]> lazyDoubleArray) {}
+
+  @Inject void thing(Thing thing) {}
+  @Inject void thingProvider(Provider<Thing> thingProvider) {}
+  @Inject void lazyThing(Lazy<Thing> lazyThing) {}
+  @Inject void thingMembersInjector(MembersInjector<Thing> thingMembersInjector) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Injector.java b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
new file mode 100644
index 000000000..2a5798a03
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+/**
+ * A simple interface that exercises all forms of injection for a given type.
+ */
+interface Injector<T> {
+  T instance();
+  Provider<T> provider();
+  Lazy<T> lazy();
+  MembersInjector<T> membersInjector();
+  void injectMembers(T t);
+  T injectMembersAndReturn(T t);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
new file mode 100644
index 000000000..7fd73c139
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -0,0 +1,39 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import test.sub.ContributionsModule;
+
+@Component(
+  modules = {
+    MultibindingModule.class,
+    ContributionsModule.class
+  },
+  dependencies = MultibindingDependency.class
+)
+interface MultibindingComponent {
+  Map<String, String> map();
+  Map<String, Provider<String>> mapOfProviders();
+  Set<String> mapKeys();
+  Collection<String> mapValues();
+  Set<Integer> set();
+  Map<TestKey.NestedWrappedKey, String> nestedKeyMap();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
new file mode 100644
index 000000000..a92e029e2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+interface MultibindingDependency {
+  double doubleDependency();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
new file mode 100644
index 000000000..311ac1bd6
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -0,0 +1,61 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
+
+@Module
+class MultibindingModule {
+  @Provides(type = MAP) @TestKey("foo") String provideFooKey(double doubleDependency) {
+    return "foo value";
+  }
+
+  @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
+    return "bar value";
+  }
+
+  @Provides(type = SET) int provideFiveToSet() {
+    return 5;
+  }
+
+  @Provides(type = SET) int provideSixToSet() {
+    return 6;
+  }
+
+  @Provides Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+    return map.keySet();
+  }
+
+  @Provides Collection<String> provideMapValues(Map<String, String> map) {
+    return map.values();
+  }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Integer.class) String valueForInteger() {
+    return "integer";
+  }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Long.class) String valueForLong() {
+    return "long";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
new file mode 100644
index 000000000..43a088cdc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
@@ -0,0 +1,47 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+import javax.inject.Inject;
+import test.sub.OtherThing;
+
+@Component(dependencies = {NonComponentDependencyComponent.ThingComponent.class})
+interface NonComponentDependencyComponent {
+  ThingTwo thingTwo();
+
+  static class ThingTwo {
+    @SuppressWarnings("unused")
+    @Inject
+    ThingTwo(
+        Thing thing,
+        NonComponentDependencyComponent nonComponentDependencyComponent,
+        NonComponentDependencyComponent.ThingComponent thingComponent) {}
+  }
+
+  // A non-component interface which this interface depends upon.
+  interface ThingComponent {
+    Thing thing();
+  }
+
+  // The implementation for that interface.
+  static class ThingComponentImpl implements ThingComponent {
+    @Override
+    public Thing thing() {
+      return new Thing(new OtherThing(1));
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
new file mode 100644
index 000000000..c7fabdb2b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+final class OuterClassBar {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    InjectedThing injectedThing();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
new file mode 100644
index 000000000..86f963f5c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+final class OuterClassFoo {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    Thing thing();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
new file mode 100644
index 000000000..a161abaa8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -0,0 +1,18 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
+  @Provides Iterable<A> provideIterableOfAWithC(A a, C c) {
+    List<A> list = new ArrayList<>();
+    list.add(a);
+    for (A elt : c) {
+      list.add(elt);
+    }
+    return list;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
new file mode 100644
index 000000000..acbf271df
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
@@ -0,0 +1,93 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class PrimitivesModule {
+  static final byte BOUND_BYTE = -41;
+  static final char BOUND_CHAR = 'g';
+  static final short BOUND_SHORT = 21840;
+  static final int BOUND_INT = 1894833693;
+  static final long BOUND_LONG = -4369839828653523584L;
+  static final boolean BOUND_BOOLEAN = true;
+  static final float BOUND_FLOAT = (float) 0.9964542;
+  static final double BOUND_DOUBLE = 0.12681322049667765;
+
+  /*
+   * While we can't ensure that these constants stay constant, this is a test so we're just going to
+   * keep our fingers crossed that we're not going to be jerks.
+   */
+  static final byte[] BOUND_BYTE_ARRAY =  {1, 2, 3};
+  static final char[] BOUND_CHAR_ARRAY = {'g', 'a', 'k'};
+  static final short[] BOUND_SHORT_ARRAY = {2, 4};
+  static final int[] BOUND_INT_ARRAY = {3, 1, 2};
+  static final long[] BOUND_LONG_ARRAY = {1, 1, 2, 3, 5};
+  static final boolean[] BOUND_BOOLEAN_ARRAY = {false, true, false, false};
+  static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
+  static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
+
+  @Provides static byte provideByte() {
+    return BOUND_BYTE;
+  }
+
+  @Provides static char provideChar() {
+    return BOUND_CHAR;
+  }
+
+  @Provides static short provideShort() {
+    return BOUND_SHORT;
+  }
+
+  @Provides static int provideInt() {
+    return BOUND_INT;
+  }
+
+  @Provides static long provideLong() {
+    return BOUND_LONG;
+  }
+
+  @Provides static boolean provideBoolean() {
+    return BOUND_BOOLEAN;
+  }
+
+  @Provides static float provideFloat() {
+    return BOUND_FLOAT;
+  }
+
+  @Provides static double boundDouble() {
+    return BOUND_DOUBLE;
+  }
+
+  @Provides static byte[] provideByteArray() {
+    return BOUND_BYTE_ARRAY;
+  }
+
+  @Provides static char[] provideCharArray() {
+    return BOUND_CHAR_ARRAY;
+  }
+
+  @Provides static short[] provideShortArray() {
+    return BOUND_SHORT_ARRAY;
+  }
+
+  @Provides static int[] provideIntArray() {
+    return BOUND_INT_ARRAY;
+  }
+
+  @Provides static long[] provideLongArray() {
+    return BOUND_LONG_ARRAY;
+  }
+
+  @Provides static boolean[] provideBooleanArray() {
+    return BOUND_BOOLEAN_ARRAY;
+  }
+
+  @Provides static float[] provideFloatArray() {
+    return BOUND_FLOAT_ARRAY;
+  }
+
+  @Provides static double[] boundDoubleArray() {
+    return BOUND_DOUBLE_ARRAY;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
new file mode 100644
index 000000000..812c45d35
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class ReferencesGeneric {
+  final Generic<A> genericA;
+  
+  @Inject ReferencesGeneric(Generic<A> genericA) {
+    this.genericA = genericA;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
new file mode 100644
index 000000000..37d68e01e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
@@ -0,0 +1,12 @@
+package test;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+class ScopedGeneric<T> { 
+  final T t;  
+  @Inject ScopedGeneric(T t) {
+    this.t = t;
+  }  
+}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
new file mode 100644
index 000000000..44a2cb553
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
@@ -0,0 +1,13 @@
+package test;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface SingletonGenericComponent {
+  
+  ScopedGeneric<A> scopedGenericA();
+  ScopedGeneric<B> scopedGenericB();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
new file mode 100644
index 000000000..645af788a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestKey {
+  String value();
+
+  @MapKey(unwrapValue = false)
+  @interface NestedWrappedKey {
+    Class<?> value();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Thing.java b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
new file mode 100644
index 000000000..46cbdc999
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import javax.inject.Inject;
+import test.sub.OtherThing;
+
+final class Thing {
+  @Inject Thing(@SuppressWarnings("unused") OtherThing unused) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
new file mode 100644
index 000000000..587baade1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {
+  @Inject TypeWithInheritedMembersInjection() {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
new file mode 100644
index 000000000..8b85d606c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class ByteModule {
+  final byte b;
+
+  ByteModule(byte b) {
+    this.b = b;
+  }
+  
+  @Provides byte b() { return b; }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
new file mode 100644
index 000000000..93fd59def
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface DepComponent {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
new file mode 100644
index 000000000..2dec4a7a2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class DoubleModule {
+  @Provides
+  double d() {
+    return 4.2d;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
new file mode 100644
index 000000000..309e7ee98
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class FloatModule {  
+  @Provides
+  float f() {
+    return 5.5f;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
new file mode 100644
index 000000000..af196eeda
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+interface GenericParent<B> {  
+  B subcomponentBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
new file mode 100644
index 000000000..8cbf67b19
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = IntModuleIncludingDoubleAndFloat.class)
+interface Grandchild {
+  int i();
+  String s();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Grandchild build();
+    Builder set(IntModuleIncludingDoubleAndFloat intModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
new file mode 100644
index 000000000..5e3a92827
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(includes = { DoubleModule.class, FloatModule.class })
+class IntModuleIncludingDoubleAndFloat {
+  final int integer;
+
+  IntModuleIncludingDoubleAndFloat(int integer) {
+    this.integer = integer;
+  }
+  
+  @Provides
+  int integer() {
+    return integer;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
new file mode 100644
index 000000000..c16c9c79f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class LongModule {  
+  @Provides
+  long l() {
+    return 6L;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
new file mode 100644
index 000000000..59c29ab34
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = StringModule.class)
+interface MiddleChild {
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    MiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
similarity index 68%
rename from core/src/main/java/dagger/internal/StaticInjection.java
rename to compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
index 92a73a48a..e2fbcaa42 100644
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Square Inc.
- * Copyright (C) 2012 Google Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
+package test.builder;
 
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
 
-/**
- * Injects the static fields of a class.
- */
-public abstract class StaticInjection {
-
-  public abstract void attach(Linker linker);
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-  public abstract void inject();
+@Scope
+@Retention(RUNTIME)
+@interface MiddleScope {
 
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
new file mode 100644
index 000000000..28e43bafe
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = {StringModule.class, LongModule.class})
+interface OtherMiddleChild {
+  long l();
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    OtherMiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
new file mode 100644
index 000000000..f901b8863
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface ParentComponent {  
+  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();
+  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();
+  
+  MiddleChild.Builder middleBuilder();
+  OtherMiddleChild.Builder otherBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
new file mode 100644
index 000000000..474c61701
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = StringModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParent<Grandchild.Builder> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
new file mode 100644
index 000000000..3b979a5ab
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class StringModule {
+  final String string;
+
+  StringModule(String string) {
+    this.string = string;
+  }
+  
+  @Provides
+  String string() {
+    return string;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..8f39c1401
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+ 
+  abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void setM3(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test returning supertype.
+  }
+  
+  @Subcomponent.Builder
+  abstract class Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderAbstractClass,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance
+    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    abstract void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
new file mode 100644
index 000000000..2add34ed5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void setM3(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Subcomponent.Builder
+  interface Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..5eef53fe5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+abstract class TestComponentWithBuilderAbstractClass {
+  
+  static Builder builder() {
+    return DaggerTestComponentWithBuilderAbstractClass.builder();
+  }
+  
+  abstract String s();
+  abstract int i();
+  abstract long l();
+  abstract float f();
+  abstract double d();
+  
+
+  static abstract class SharedBuilder {
+    // Make sure we use the overriding signature.
+    abstract Object build();
+    
+    Object stringModule(@SuppressWarnings("unused") StringModule stringModule) {
+      return null;
+    } 
+
+    SharedBuilder ignoredLongModule(@SuppressWarnings("unused") LongModule longModule) {
+      return null;
+    }
+    
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder {
+    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type
+    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract & narrow
+    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args
+    abstract void depComponent(DepComponent depComponent);
+
+    Builder ignoredIntModule(
+        @SuppressWarnings("unused") IntModuleIncludingDoubleAndFloat intModule) {
+      return null;
+    }    
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
new file mode 100644
index 000000000..55214f836
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder {
+    // Make sure we use the overriding signature.
+    Object build();
+    Object stringModule(StringModule m1); 
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder {
+    @Override TestComponentWithBuilderInterface build(); // Narrowing return type
+    @Override Builder stringModule(StringModule stringModule); // Narrowing return type
+    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    void doubleModule(DoubleModule doubleModule); // Module w/o args
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
new file mode 100644
index 000000000..8032185b2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  static abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> depComponent(FloatModule floatModule); // Test return type
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder<Builder,
+      TestComponentWithGenericBuilderAbstractClass, StringModule,
+      IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    abstract void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they're implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
new file mode 100644
index 000000000..f63e3ec90
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder<Builder, TestComponentWithGenericBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed
+    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing M5 -- that's implicit.
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
new file mode 100644
index 000000000..22efcf12e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfArrayOfParentOfStringArray extends
+    MembersInjectGenericParent<MembersInjectGenericParent<String[]>[]> {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
new file mode 100644
index 000000000..e01c1c266
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfPrimitiveIntArray extends MembersInjectGenericParent<int[]> {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
new file mode 100644
index 000000000..8ec943b96
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfStringArray extends MembersInjectGenericParent<String[]> {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
new file mode 100644
index 000000000..9ab8c1928
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import dagger.Component;
+
+@Component(modules = {MembersInjectModule.class})
+interface MembersInjectComponent {
+  
+  void inject(ChildOfStringArray subfoo);
+  void inject(ChildOfArrayOfParentOfStringArray subfoo);
+  void inject(ChildOfPrimitiveIntArray subfoo);
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
new file mode 100644
index 000000000..064b88642
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import javax.inject.Inject;
+
+class MembersInjectGenericParent<T> {
+  
+  @Inject T t; 
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
new file mode 100644
index 000000000..a6c1fadb9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class MembersInjectModule {
+  
+  @Provides String[] provideStringArray() { return new String[10]; }
+  
+  @Provides int[] provideIntArray() { return new int[10]; }
+  
+  @SuppressWarnings("unchecked")
+  @Provides MembersInjectGenericParent<String[]>[] provideFooArrayOfStringArray() { return new MembersInjectGenericParent[10]; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
new file mode 100644
index 000000000..a8a572473
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(modules = NullModule.class)
+interface NullComponent {
+  NullFoo nullFoo();
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
new file mode 100644
index 000000000..05093ed60
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(dependencies = NullComponent.class)
+interface NullComponentWithDependency {
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
new file mode 100644
index 000000000..9ed4b5dea
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
@@ -0,0 +1,56 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class NullFoo {
+  final String string;
+  final Provider<String> stringProvider;
+  final Number number;
+  final Provider<Number> numberProvider;
+
+  @Inject
+  NullFoo(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.string = string;
+    this.stringProvider = stringProvider;
+    this.number = number;
+    this.numberProvider = numberProvider;
+  }
+
+  String methodInjectedString;
+  Provider<String> methodInjectedStringProvider;
+  Number methodInjectedNumber;
+  Provider<Number> methodInjectedNumberProvider;
+  @Inject void inject(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.methodInjectedString = string;
+    this.methodInjectedStringProvider = stringProvider;
+    this.methodInjectedNumber = number;
+    this.methodInjectedNumberProvider = numberProvider;
+  }
+
+  @Nullable @Inject String fieldInjectedString;
+  @Inject Provider<String> fieldInjectedStringProvider;
+  @Inject Number fieldInjectedNumber;
+  @Inject Provider<Number> fieldInjectedNumberProvider;
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
new file mode 100644
index 000000000..652d5ebbb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class NullModule {
+  Number numberValue = null;
+
+  @Nullable
+  @Provides
+  String provideNullableString() {
+    return null;
+  }
+
+  @Provides
+  Number provideNumber() {
+    return numberValue;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
new file mode 100644
index 000000000..86776406a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
@@ -0,0 +1,3 @@
+package test.nullables;
+
+@interface Nullable {}
diff --git a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
similarity index 56%
rename from compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
rename to compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
index 08243f27d..f47d36c6a 100644
--- a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,29 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static java.util.Collections.emptySet;
 
 import dagger.Module;
-import dagger.ObjectGraph;
 import dagger.Provides;
-import javax.inject.Inject;
-
-class TestApp {
-  public static void main(String[] args) {
-    Subtype subtype = ObjectGraph.create(new TestModule()).get(Subtype.class);
-  }
-
-  static class Supertype<T> {
-    @Inject String s;
-  }
+import java.util.Set;
 
-  static class Subtype extends Supertype<Integer> {
+@Module
+final class AllStaticModule {
+  @Provides(type = SET) static String contributeString() {
+    return AllStaticModule.class + ".contributeString";
   }
 
-  @Module(entryPoints = Subtype.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "a";
-    }
+  @Provides(type = SET_VALUES) static Set<Integer> contibuteEmptyIntegerSet() {
+    return emptySet();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
new file mode 100644
index 000000000..53ee14d95
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class SomeStaticModule {
+  @Provides(type = SET) static String contributeStringFromAStaticMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
+  }
+
+  @Provides(type = SET) String contributeStringFromAnInstanceMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
new file mode 100644
index 000000000..255f28c3a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+import java.util.Set;
+
+/**
+ * A simple component that demonstrates both static an non-static provides methods.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponent {
+  Set<String> getMultiboundStrings();
+  Set<Integer> getMultiboundIntegers();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
new file mode 100644
index 000000000..b10ac4533
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.sub;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
+@Module
+public final class ContributionsModule {
+  @Provides(type = SET) int contributeAnInt(double doubleDependency) {
+    return 1742;
+  }
+
+  @Provides(type = SET) int contributeAnotherInt() {
+    return 832;
+  }
+
+  @Provides(type = SET_VALUES) Set<Integer> contributeSomeInts() {
+    return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
new file mode 100644
index 000000000..9195b33f9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
@@ -0,0 +1,19 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+import test.Generic2;
+
+public class Exposed {
+  
+  @Inject public Generic2<PackagePrivate> gpp2;
+  @Inject public Generic2<PackagePrivateContainer.PublicEnclosed> gppc2;
+
+  public Generic<PackagePrivate> gpp;
+  public Generic<PackagePrivateContainer.PublicEnclosed> gppc;
+  
+  @Inject Exposed(Generic<PackagePrivate> gpp, Generic<PackagePrivateContainer.PublicEnclosed> gppc) {
+    this.gpp = gpp;
+    this.gppc = gppc;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
new file mode 100644
index 000000000..94935171f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.sub;
+
+import javax.inject.Inject;
+
+public final class OtherThing {
+  @Inject public OtherThing(int i) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
new file mode 100644
index 000000000..9af646a50
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
@@ -0,0 +1,7 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivate {  
+  @Inject PackagePrivate() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
new file mode 100644
index 000000000..765b01504
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
@@ -0,0 +1,9 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivateContainer {  
+  public static class PublicEnclosed {
+    @Inject PublicEnclosed() {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
new file mode 100644
index 000000000..586d55d93
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
@@ -0,0 +1,10 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+
+public class PublicSubclass extends Generic<PackagePrivate> {
+  @Inject public PublicSubclass(PackagePrivate pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
new file mode 100644
index 000000000..c356fa8f0
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
@@ -0,0 +1,10 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+
+public class PublicSubclass2 extends Generic<PackagePrivateContainer.PublicEnclosed> {
+  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
new file mode 100644
index 000000000..8aaa015d1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+interface AnInterface {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
new file mode 100644
index 000000000..8ae147415
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface BoundAsSingleton {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
new file mode 100644
index 000000000..6c061bc5c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = ChildModule.class)
+abstract class ChildAbstractClassComponent implements ChildComponent {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
new file mode 100644
index 000000000..67d66cae9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+import javax.inject.Provider;
+
+@Subcomponent(modules = ChildModule.class)
+interface ChildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  RequiresSingletons requiresSingleton();
+
+  Set<Object> objectSet();
+
+  GrandchildComponent newGrandchildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
new file mode 100644
index 000000000..905c68990
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {
+    ChildModule.class,
+    ChildModuleWithParameters.class,
+    ChildModuleWithState.class})
+interface ChildComponentRequiringModules {
+  int getInt();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
new file mode 100644
index 000000000..ef28bd47a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ChildModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in child";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
new file mode 100644
index 000000000..e18b4a6da
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+
+/**
+ * This is a module that can't be constructed with a default constructor.
+ */
+@Module
+final class ChildModuleWithParameters {
+  public ChildModuleWithParameters(@SuppressWarnings("unused") Object whatever) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
new file mode 100644
index 000000000..5908a005b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This is a module that can be constructed with a default constructor, but has state, so callers
+ * might want to pass a reference anyway.
+ */
+@Module
+final class ChildModuleWithState {
+  private int i = 0;
+
+  @Provides int provideInt() {
+    return i++;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
new file mode 100644
index 000000000..5580ab8d4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+interface GenericParentComponent<B> {  
+  B subcomponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
new file mode 100644
index 000000000..9f724edfc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+import javax.inject.Provider;
+
+@Subcomponent(modules = GrandchildModule.class)
+interface GrandchildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  RequiresSingletons requiresSingleton();
+
+  Set<Object> objectSet();
+
+  NeedsAnInterface needsAnInterface();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
new file mode 100644
index 000000000..b2885412f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class GrandchildModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in grandchild";
+      }
+    };
+  }
+
+  @Provides AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
+    return implementsAnInterface;
+  }
+
+  @Provides NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
+    return new NeedsAnInterface(anInterface);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
new file mode 100644
index 000000000..ff3170cba
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+class ImplementsAnInterface implements AnInterface {
+  @Inject ImplementsAnInterface() {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
new file mode 100644
index 000000000..bccde8589
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+class NeedsAnInterface {
+  NeedsAnInterface(AnInterface anInterface) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
new file mode 100644
index 000000000..ebb067d6f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentComponent extends ParentGetters {
+  ChildComponent newChildComponent();
+
+  ChildAbstractClassComponent newChildAbstractClassComponent();
+
+  ChildComponentRequiringModules newChildComponentRequiringModules(
+      ChildModuleWithParameters cmwp,
+      ChildModuleWithState childModuleWithState);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
new file mode 100644
index 000000000..3ff855a9d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Provider;
+
+interface ParentGetters {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  Set<Object> objectSet();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
new file mode 100644
index 000000000..dbe1a534a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ParentModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in parent";
+      }
+    };
+  }
+
+  @Provides(type = SET) @Singleton Object provideSingletonObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "singleton";
+      }
+    };
+  }
+
+  @Provides @Singleton @BoundAsSingleton UnscopedType provideUnscopedTypeBoundAsSingleton(
+      UnscopedType unscopedType) {
+    return unscopedType;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
new file mode 100644
index 000000000..bf8553772
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParentComponent<ChildComponent>, ParentGetters {
+}
diff --git a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
similarity index 50%
rename from compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
index 4723bccea..2d4053824 100644
--- a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,30 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package test.subcomponent;
 
-import dagger.Module;
-
-import dagger.ObjectGraph;
 import javax.inject.Inject;
 
-class TestApp implements Runnable {
-  @Inject Dependency dep;
+final class RequiresSingletons {
+  private final SingletonType singletonType;
+  private final UnscopedType unscopedTypeBoundAsSingleton;
 
-  @Override public void run() {
-    dep.doit();
+  @Inject RequiresSingletons(SingletonType singletonType,
+      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {
+    this.singletonType = singletonType;
+    this.unscopedTypeBoundAsSingleton = unscopedTypeBoundAsSingleton;
   }
 
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-  
-  static interface Dependency {
-    void doit();
+  SingletonType singletonType() {
+    return singletonType;
   }
-  
-  @Module(entryPoints = TestApp.class)
-  static class TestModule {
-    /* missing */ // @Provides Dependency a() { return new Dependency(); }
+
+  UnscopedType unscopedTypeBoundAsSingleton() {
+    return unscopedTypeBoundAsSingleton;
   }
 }
diff --git a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
similarity index 55%
rename from compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
index 3600ffd19..663e858a9 100644
--- a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,29 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package test.subcomponent;
 
-import dagger.ObjectGraph;
-import dagger.Module;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 
-class TestApp implements Runnable {
-  @Inject A a;
-
-  @Override public void run() {
-    a.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-  
-  @Module(entryPoints = { TestApp.class })
-  static class TestModule {}
-
-  @Singleton
-  static class A {
-    @Inject A() {}
-    public void doit() {};
-  }
+@Singleton
+final class SingletonType {
+  @Inject SingletonType() {}
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
new file mode 100644
index 000000000..89c00855f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+final class UnscopedType {
+  @Inject UnscopedType(@SuppressWarnings("unused") SingletonType singletonType) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
new file mode 100644
index 000000000..b95502cf8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = test.subcomponent.hiding.b.CommonModuleName.class)
+interface ChildComponent {
+  //ensure that t.s.h.a.CommonName gets bound in this component
+  test.subcomponent.hiding.a.CommonName aCommonName();
+  //ensure that t.s.h.b.CommonName gets bound in this component
+  test.subcomponent.hiding.b.CommonName bCommonName();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
new file mode 100644
index 000000000..d7c66a679
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = test.subcomponent.hiding.a.CommonModuleName.class)
+@Singleton
+interface ParentComponent {
+  // ensure that t.s.h.a.CommonName gets bound in this component
+  test.subcomponent.hiding.a.CommonName aCommonName();
+
+  ChildComponent newChildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
new file mode 100644
index 000000000..ad692896f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.a;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides String provideString() {
+    return "a";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
new file mode 100644
index 000000000..b2aefda06
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.a;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final String s;
+
+  @Inject CommonName(String s) {
+    this.s = s;
+  }
+
+  @Override
+  public String toString() {
+    return s;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
new file mode 100644
index 000000000..66deab5aa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.b;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides int provideString() {
+    return 1;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
new file mode 100644
index 000000000..023cbdbf2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding.b;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final int i;
+
+  @Inject CommonName(int i) {
+    this.i = i;
+  }
+
+  @Override
+  public String toString() {
+    return Integer.toString(i);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
new file mode 100644
index 000000000..badb7cac6
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
@@ -0,0 +1,14 @@
+
+
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface ChildComponent {
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInChild getOnlyUsedInChild();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
new file mode 100644
index 000000000..2dd8d20d3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
@@ -0,0 +1,5 @@
+package test.subcomponent.repeat;
+
+abstract class OnlyUsedInChild {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
new file mode 100644
index 000000000..cc22b1e05
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
@@ -0,0 +1,5 @@
+package test.subcomponent.repeat;
+
+abstract class OnlyUsedInParent {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
new file mode 100644
index 000000000..91df02cc3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -0,0 +1,19 @@
+package test.subcomponent.repeat;
+
+import dagger.Component;
+
+import java.util.Set;
+
+@Component(modules = RepeatedModule.class)
+interface ParentComponent {
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInParent getOnlyUsedInParent();
+
+  ChildComponent newChildComponent();
+
+  @Component.Builder
+  interface Builder {
+    ParentComponent build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
new file mode 100644
index 000000000..508a41b56
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -0,0 +1,25 @@
+package test.subcomponent.repeat;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class RepeatedModule {
+  @Provides String provideString() {
+    return "a string";
+  }
+
+  @Provides(type = SET) String contributeString() {
+    return "a string in a set";
+  }
+
+  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
+    return new OnlyUsedInParent() {};
+  }
+
+  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
+    return new OnlyUsedInChild() {};
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
new file mode 100644
index 000000000..fe9c6afe9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -0,0 +1,116 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.experimental.theories.DataPoint;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.PrimitivesModule.BOUND_BOOLEAN;
+import static test.PrimitivesModule.BOUND_BOOLEAN_ARRAY;
+import static test.PrimitivesModule.BOUND_BYTE;
+import static test.PrimitivesModule.BOUND_BYTE_ARRAY;
+import static test.PrimitivesModule.BOUND_CHAR;
+import static test.PrimitivesModule.BOUND_CHAR_ARRAY;
+import static test.PrimitivesModule.BOUND_DOUBLE;
+import static test.PrimitivesModule.BOUND_DOUBLE_ARRAY;
+import static test.PrimitivesModule.BOUND_FLOAT;
+import static test.PrimitivesModule.BOUND_FLOAT_ARRAY;
+import static test.PrimitivesModule.BOUND_INT;
+import static test.PrimitivesModule.BOUND_INT_ARRAY;
+import static test.PrimitivesModule.BOUND_LONG;
+import static test.PrimitivesModule.BOUND_LONG_ARRAY;
+import static test.PrimitivesModule.BOUND_SHORT;
+import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
+
+@RunWith(Theories.class)
+public class BasicTest {
+  @DataPoint
+  public static final BasicComponent basicComponent = DaggerBasicComponent.create();
+  @DataPoint
+  public static final BasicComponent abstractClassBasicComponent =
+      DaggerBasicAbstractClassComponent.create();
+
+  @Theory public void primitives(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
+    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
+    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
+    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
+    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
+    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
+    assertThat(basicComponent.getFloat()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
+  }
+
+  @Theory public void boxedPrimitives(BasicComponent basicComponent) {
+    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getBoxedFloat()).isEqualTo(new Float(BOUND_FLOAT));
+    assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
+  }
+
+  @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getFloatProvider().get()).isEqualTo(new Float(BOUND_FLOAT));
+    assertThat(basicComponent.getDoubleProvider().get()).isEqualTo(new Double(BOUND_DOUBLE));
+  }
+
+  @Theory public void primitiveArrays(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Theory public void primitiveArrayProviders(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArrayProvider().get()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArrayProvider().get()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArrayProvider().get()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArrayProvider().get()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Theory public void noOpMembersInjection(BasicComponent basicComponent) {
+    Object object = new Object();
+    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
+  }
+
+  @Theory public void basicObject_noDeps(BasicComponent basicComponent) {
+    assertThat(basicComponent.thing()).isNotNull();
+  }
+
+  @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {
+    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
new file mode 100644
index 000000000..f1c981f25
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.sub.Exposed;
+import test.sub.PublicSubclass;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(JUnit4.class)
+public class GenericTest {
+
+  @Test public void testGenericComponentCreate() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component).isNotNull();
+  }
+  
+  @Test public void testGenericSimpleReferences() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component.referencesGeneric().genericA.t).isNotNull();    
+  }
+  
+  @Test public void testGenericDoubleReferences() {
+    GenericComponent component = DaggerGenericComponent.create();
+    GenericDoubleReferences<A> doubleA = component.doubleGenericA();
+    assertThat(doubleA.a).isNotNull();
+    assertThat(doubleA.a2).isNotNull();
+    assertThat(doubleA.t).isNotNull();
+    assertThat(doubleA.t2).isNotNull();
+
+    GenericDoubleReferences<B> doubleB = component.doubleGenericB();
+    assertThat(doubleB.a).isNotNull();
+    assertThat(doubleB.a2).isNotNull();
+    assertThat(doubleB.t).isNotNull();
+    assertThat(doubleB.t2).isNotNull();
+  }
+  
+  @Test public void complexGenerics() {
+    GenericComponent component = DaggerGenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.complexGenerics();
+  }
+  
+  @Test public void noDepsGenerics() {
+    GenericComponent component = DaggerGenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.noDepsA();
+    component.noDepsB();
+  }
+  
+  @Test public void boundedGenerics() {
+    BoundedGenericModule expected = new BoundedGenericModule();
+    BoundedGenericComponent component = DaggerBoundedGenericComponent.create();
+    BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+        b1 = component.bounds1();
+    assertEquals(expected.provideInteger(), b1.a);
+    assertEquals(expected.provideArrayListString(), b1.b);
+    assertEquals(expected.provideLinkedListCharSeq(), b1.c);
+    assertEquals(expected.provideInteger(), b1.d);
+    assertEquals(expected.provideListOfInteger(), b1.e);
+
+    BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+        b2 = component.bounds2();
+    assertEquals(expected.provideDouble(), b2.a);
+    assertEquals(expected.provideLinkedListString(), b2.b);
+    assertEquals(expected.provideArrayListOfComparableString(), b2.c);
+    assertEquals(expected.provideDouble(), b2.d);
+    assertEquals(expected.provideSetOfDouble(), b2.e);
+  }
+  
+  @Test public void membersInjections() {
+    GenericComponent component = DaggerGenericComponent.create();
+    GenericChild<A> childA = new GenericChild<A>();
+    component.injectA(childA);
+    assertThat(childA.a).isNotNull();
+    assertThat(childA.b).isNotNull();
+    assertThat(childA.registeredA).isNotNull();
+    assertThat(childA.registeredB).isNotNull();
+    assertThat(childA.registeredT).isNotNull();
+    assertThat(childA.registeredX).isNotNull();
+    assertThat(childA.registeredY).isNotNull();
+    
+    GenericChild<B> childB = new GenericChild<B>();
+    component.injectB(childB);
+    assertThat(childB.a).isNotNull();
+    assertThat(childB.b).isNotNull();
+    assertThat(childB.registeredA).isNotNull();
+    assertThat(childB.registeredB).isNotNull();
+    assertThat(childB.registeredT).isNotNull();
+    assertThat(childB.registeredX).isNotNull();
+    assertThat(childB.registeredY).isNotNull();
+  }
+  
+  @Test public void packagePrivateTypeParameterDependencies() {
+    GenericComponent component = DaggerGenericComponent.create();
+    Exposed exposed = component.exposed();
+    assertThat(exposed.gpp.t).isNotNull();
+    assertThat(exposed.gpp2).isNotNull();
+  }
+  
+  @SuppressWarnings("rawtypes")
+  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
+    GenericComponent component = DaggerGenericComponent.create();
+    PublicSubclass publicSubclass = component.publicSubclass();
+    assertThat(((Generic)publicSubclass).t).isNotNull();
+  }
+  
+  @Test public void singletonScopesAppliesToEachResolvedType() {
+    SingletonGenericComponent component = DaggerSingletonGenericComponent.create();
+    ScopedGeneric<A> a = component.scopedGenericA();
+    assertThat(a).isSameAs(component.scopedGenericA());
+    assertThat(a.t).isNotNull();
+    
+    ScopedGeneric<B> b = component.scopedGenericB();
+    assertThat(b).isSameAs(component.scopedGenericB());
+    assertThat(b.t).isNotNull();
+    
+    assertThat(a).isNotSameAs(b);
+  }
+  
+  @Test public void genericModules() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
+    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
+    
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
new file mode 100644
index 000000000..8172ced27
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package test;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  private MultibindingComponent multibindingComponent;
+
+  @Before public void setUp() {
+    multibindingComponent = DaggerMultibindingComponent.builder()
+        .multibindingDependency(new MultibindingDependency() {
+          @Override public double doubleDependency() {
+            return 0.0;
+          }
+        })
+        .build();
+  }
+
+  @Test public void map() {
+    Map<String, String> map = multibindingComponent.map();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry("foo", "foo value");
+    assertThat(map).containsEntry("bar", "bar value");
+  }
+
+  @Test public void mapOfProviders() {
+    Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
+    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
+    assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+  }
+
+  @Test public void mapKeysAndValues() {
+    assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
+    assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
+  }
+
+  @Test public void nestedKeyMap() {
+    assertThat(multibindingComponent.nestedKeyMap()).isEqualTo(
+        ImmutableMap.of(
+            nestedWrappedKey(Integer.class), "integer",
+            nestedWrappedKey(Long.class), "long"));
+  }
+
+  @Test public void setBindings() {
+    assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
+  }
+
+  @AutoAnnotation
+  static TestKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
new file mode 100644
index 000000000..14c3e5385
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class NestedTest {
+  @Test public void nestedFoo() {
+    OuterClassFoo.NestedComponent nestedFoo = DaggerOuterClassFoo_NestedComponent.create();
+    assertThat(nestedFoo.thing()).isNotNull();
+  }
+
+  @Test public void nestedBar() {
+    OuterClassBar.NestedComponent nestedBar = DaggerOuterClassBar_NestedComponent.create();
+    assertThat(nestedBar.injectedThing()).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
new file mode 100644
index 000000000..37d3f7aec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
@@ -0,0 +1,34 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class NonComponentDependencyTest {
+  @Test public void testThing() {
+    NonComponentDependencyComponent component =
+        DaggerNonComponentDependencyComponent.builder()
+            .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())
+            .build();
+    assertThat(component).isNotNull();
+    assertThat(component.thingTwo()).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
new file mode 100644
index 000000000..ba590d2d9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class BuilderTest {
+
+  @Test public void interfaceBuilder() {
+    TestComponentWithBuilderInterface.Builder builder =
+        DaggerTestComponentWithBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassBuilder() {
+    TestComponentWithBuilderAbstractClass.Builder builder =
+        TestComponentWithBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void interfaceGenericBuilder() {
+    TestComponentWithGenericBuilderInterface.Builder builder =
+        DaggerTestComponentWithGenericBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassGenericBuilder() {
+    TestComponentWithGenericBuilderAbstractClass.Builder builder =
+        DaggerTestComponentWithGenericBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+  
+  @Test public void subcomponents_interface() {
+    ParentComponent parent = DaggerParentComponent.create();    
+    TestChildComponentWithBuilderInterface.Builder builder1 = parent.childInterfaceBuilder();
+    try {
+      builder1.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .set(new ByteModule((byte)7));
+    builder1.set(new FloatModule());
+    TestChildComponentWithBuilderInterface child1 = builder1.build();
+    assertThat(child1.s()).isEqualTo("sam");
+    assertThat(child1.i()).isEqualTo(1);
+    assertThat(child1.d()).isWithin(0).of(4.2d);
+    assertThat(child1.f()).isEqualTo(5.5f);
+    assertThat(child1.l()).isEqualTo(6L);
+    assertThat(child1.b()).isEqualTo((byte)7);
+  }
+  
+  @Test public void subcomponents_abstractclass() {
+    ParentComponent parent = DaggerParentComponent.create();
+    TestChildComponentWithBuilderAbstractClass.Builder builder2 =
+        parent.childAbstractClassBuilder();
+    try {
+      builder2.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))
+        .setM1(new StringModule("tara"))
+        .set(new ByteModule((byte)70));
+    builder2.set(new FloatModule());
+    TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
+    assertThat(child2.s()).isEqualTo("tara");
+    assertThat(child2.i()).isEqualTo(10);
+    assertThat(child2.d()).isWithin(0).of(4.2d);
+    assertThat(child2.f()).isEqualTo(5.5f);
+    assertThat(child2.l()).isEqualTo(6L);
+    assertThat(child2.b()).isEqualTo((byte)70);
+  }
+  
+  @Test
+  public void grandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle1 = parent.middleBuilder().set(new StringModule("sam")).build();
+    Grandchild grandchild1 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild grandchild2 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle1.s()).isEqualTo("sam");
+    assertThat(grandchild1.i()).isEqualTo(21);
+    assertThat(grandchild1.s()).isEqualTo("sam");
+    assertThat(grandchild2.i()).isEqualTo(22);
+    assertThat(grandchild2.s()).isEqualTo("sam");
+
+    // Make sure grandchildren from newer children have no relation to the older ones.
+    MiddleChild middle2 = parent.middleBuilder().set(new StringModule("tara")).build();
+    Grandchild grandchild3 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();
+    Grandchild grandchild4 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();
+    
+    assertThat(middle2.s()).isEqualTo("tara");
+    assertThat(grandchild3.i()).isEqualTo(23);
+    assertThat(grandchild3.s()).isEqualTo("tara");
+    assertThat(grandchild4.i()).isEqualTo(24);
+    assertThat(grandchild4.s()).isEqualTo("tara");
+  }
+  
+  @Test
+  public void diamondGrandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle = parent.middleBuilder().set(new StringModule("sam")).build();
+    OtherMiddleChild other = parent.otherBuilder().set(new StringModule("tara")).build();
+    
+    Grandchild middlegrand =
+        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild othergrand =
+        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(other.s()).isEqualTo("tara");
+    assertThat(middlegrand.s()).isEqualTo("sam");
+    assertThat(othergrand.s()).isEqualTo("tara");
+    assertThat(middlegrand.i()).isEqualTo(21);
+    assertThat(othergrand.i()).isEqualTo(22);
+  }
+  
+  @Test
+  public void genericSubcomponentMethod() {
+    ParentOfGenericComponent parent =
+        DaggerParentOfGenericComponent.builder().stringModule(new StringModule("sam")).build();
+    Grandchild.Builder builder = parent.subcomponentBuilder();
+    Grandchild child = builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    assertThat(child.s()).isEqualTo("sam");
+    assertThat(child.i()).isEqualTo(21);
+  }
+  
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
new file mode 100644
index 000000000..1b382d8f7
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -0,0 +1,45 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.membersinject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectTest {
+  @Test public void testMembersInject_arrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfStringArray childOfStringArray = new ChildOfStringArray();
+    component.inject(childOfStringArray);
+  }
+
+  @Test public void testMembersInject_nestedArrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
+        new ChildOfArrayOfParentOfStringArray();
+    component.inject(childOfArrayOfParentOfStringArray);
+  }
+
+  @Test public void testMembersInject_primitives() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
+    component.inject(childOfPrimitiveIntArray);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
new file mode 100644
index 000000000..a0e1e22f5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
@@ -0,0 +1,110 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class NullabilityTest {
+  @Test public void testNullability_provides() {
+    NullModule module = new NullModule();
+    NullComponent component = DaggerNullComponent.builder().nullModule(module).build();
+
+    // Can't construct NullFoo because it depends on Number, and Number was null.
+    try {
+      component.nullFoo();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable @Provides method");
+    }
+
+    // set number to non-null so we can create
+    module.numberValue = 1;
+    NullFoo nullFoo = component.nullFoo();
+
+    // Then set it back to null so we can test its providers.
+    module.numberValue = null;
+    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);
+    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,
+        nullFoo.methodInjectedNumberProvider);
+    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
+        nullFoo.fieldInjectedNumberProvider);
+  }
+  
+  @Test public void testNullability_components() {
+    NullComponent nullComponent = new NullComponent() {      
+      @Override public Provider<String> stringProvider() {
+        return new Provider<String>() {
+          @Override public String get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public String string() {
+        return null;
+      }
+      
+      @Override public Provider<Number> numberProvider() {
+        return new Provider<Number>() {
+          @Override public Number get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public Number number() {
+        return null;
+      }
+      
+      @Override public NullFoo nullFoo() {
+        return null;
+      }
+    };
+    NullComponentWithDependency component =
+        DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();
+    validate(false, component.string(), component.stringProvider(), component.numberProvider());
+    
+    // Also validate that the component's number() method fails
+    try {
+      component.number();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable component method");
+    }
+  }
+
+  private void validate(boolean fromProvides,
+      String string,
+      Provider<String> stringProvider,
+      Provider<Number> numberProvider) {
+    assertThat(string).isNull();
+    assertThat(numberProvider).isNotNull();
+    try {
+      numberProvider.get();
+      fail();
+    } catch(NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
+          + (fromProvides ? "@Provides" : "component") + " method");
+    }
+    assertThat(stringProvider.get()).isNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
new file mode 100644
index 000000000..53185f8fc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class StaticProvidesTest {
+  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+
+  @Test public void setMultibinding() {
+    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
+        AllStaticModule.class + ".contributeString",
+        SomeStaticModule.class + ".contributeStringFromAStaticMethod",
+        SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
new file mode 100644
index 000000000..cb6292513
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.collect.Sets.intersection;
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(Parameterized.class)
+public class SubcomponentTest {
+  private static final ParentComponent parentComponent = DaggerParentComponent.create();
+  private static final ParentOfGenericComponent parentOfGenericComponent =
+      DaggerParentOfGenericComponent.create();
+  
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {
+        { parentComponent, parentComponent.newChildComponent() },
+        { parentComponent, parentComponent.newChildAbstractClassComponent() },
+        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
+  }        
+  
+  private final ParentGetters parentGetters;
+  private final ChildComponent childComponent;
+  
+  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
+    this.parentGetters = parentGetters;
+    this.childComponent = childComponent;
+  }
+  
+
+  @Test
+  public void scopePropagatesUpward_class() {
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.requiresSingleton().singletonType());
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());
+  }
+
+  @Test
+  public void scopePropagatesUpward_provides() {
+    assertThat(childComponent
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(childComponent
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
+    assertThat(childComponent
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(childComponent.newGrandchildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
+  }
+
+  @Test
+  public void multibindingContributions() {
+    Set<Object> parentObjectSet = parentGetters.objectSet();
+    assertThat(parentObjectSet).hasSize(2);
+    Set<Object> childObjectSet = childComponent.objectSet();
+    assertThat(childObjectSet).hasSize(3);
+    Set<Object> grandchildObjectSet =
+        childComponent.newGrandchildComponent().objectSet();
+    assertThat(grandchildObjectSet).hasSize(4);
+    assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);
+    assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
+    assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
+  }
+
+  @Test
+  public void unscopedProviders() {
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent.getUnscopedTypeProvider());
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent
+            .newGrandchildComponent()
+            .getUnscopedTypeProvider());
+  }
+
+  @Test
+  public void passedModules() {
+    ChildModuleWithState childModuleWithState = new ChildModuleWithState();
+    ChildComponentRequiringModules childComponent1 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    ChildComponentRequiringModules childComponent2 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    assertThat(childComponent1.getInt()).isEqualTo(0);
+    assertThat(childComponent2.getInt()).isEqualTo(1);
+  }
+
+  @Test
+  public void dependenceisInASubcomponent() {
+    assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
+  }  
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
new file mode 100644
index 000000000..27dcbb690
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.hiding;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SubcomponentHidingTest {
+  @Test public void moduleNameHiding() {
+    ParentComponent parent = DaggerParentComponent.create();
+    assertThat(parent.aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo("1");
+  }
+}
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
deleted file mode 100644
index 45b685c6c..000000000
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>inject-parameterized-type</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/missing-at-inject-constructor/invoker.properties b/compiler/src/it/missing-at-inject-constructor/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/missing-at-inject-constructor/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
deleted file mode 100644
index 6e1535554..000000000
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <artifactId>missing-at-inject-constructor</artifactId>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
deleted file mode 100644
index 6cd594848..000000000
--- a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import javax.inject.Inject;
-
-class TestApp implements Runnable {
-  @Inject Dependency dep;
-
-  @Override public void run() {
-    dep.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-  
-  static class Dependency {
-    // missing @Inject Dependency() {}
-    public void doit() { throw AssertionError(); };
-  }
-  
-  @Module(entryPoints = TestApp.class)
-  static class TestModule {
-    /* missing */ // @Provides Dependency a() { return new Dependency(); }
-  }
-}
diff --git a/compiler/src/it/missing-at-inject-constructor/verify.bsh b/compiler/src/it/missing-at-inject-constructor/verify.bsh
deleted file mode 100644
index f1a4c7601..000000000
--- a/compiler/src/it/missing-at-inject-constructor/verify.bsh
+++ /dev/null
@@ -1,7 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "No injectable members on test.TestApp.Dependency.", 
-	"required by test.TestApp for test.TestApp.TestModule"});
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
deleted file mode 100644
index 2337e048e..000000000
--- a/compiler/src/it/multiple-provides-methods/verify.bsh
+++ /dev/null
@@ -1,12 +0,0 @@
-import java.io.File;
-
-File classes = new File(basedir, "target/classes/test/");
-
-File moduleAdapter = new File(classes, "TestApp$TestModule$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module"); 
-
-File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()"); 
-
-File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()"); 
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
new file mode 100644
index 000000000..206a7e2d8
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2014 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>producers-functional-tests</artifactId>
+  <name>Producers Functional Tests</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-producers</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.6</source>
+          <target>1.6</target>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <configuration>
+          <failsOnError>false</failsOnError>
+          <consoleOutput>true</consoleOutput>
+          <configLocation>../../../../checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
new file mode 100644
index 000000000..fa392dd8e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+
+@Component(modules = DependedModule.class)
+interface DependedComponent {
+  String getGreeting();
+}
+
diff --git a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
similarity index 64%
rename from compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
rename to compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
index 71b29f0bd..604107025 100644
--- a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,20 +17,11 @@
 
 import dagger.Module;
 import dagger.Provides;
-import javax.inject.Inject;
 
-class TestApp {
-  static class NotInjectable {
-  }
-
-  static class InjectableSubclass extends NotInjectable {
-    @Inject String string;
-  }
-
-  @Module(entryPoints = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "string";
-    }
+@Module
+final class DependedModule {
+  @Provides
+  String provideGreeting() {
+    return "Hello world!";
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
new file mode 100644
index 000000000..ad0c792a9
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import java.util.List;
+
+@ProducerModule
+final class DependedProducerModule {
+
+  @Produces
+  int produceNumberOfGreetings() {
+    return 2;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
new file mode 100644
index 000000000..57f175812
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = DependedProducerModule.class)
+interface DependedProductionComponent {
+  ListenableFuture<Integer> numGreetings();
+}
+
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
new file mode 100644
index 000000000..4b14f99b5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+import java.util.List;
+
+@ProductionComponent(
+    modules = DependentProducerModule.class,
+    dependencies = {DependedComponent.class, DependedProductionComponent.class})
+interface DependentComponent {
+  ListenableFuture<List<String>> greetings();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
new file mode 100644
index 000000000..234c088d3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import java.util.List;
+
+@ProducerModule
+final class DependentProducerModule {
+  @Produces
+  ListenableFuture<List<String>> greetings(Integer numGreetings, String greeting) {
+    List<String> greetings = ImmutableList.of(
+        String.valueOf(numGreetings), greeting, Ascii.toUpperCase(greeting));
+    return Futures.immediateFuture(greetings);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
new file mode 100644
index 000000000..561ad4a89
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = MultibindingProducerModule.class)
+interface MultibindingComponent {
+  ListenableFuture<Set<String>> strs();
+  ListenableFuture<Integer> strCount();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
new file mode 100644
index 000000000..4651afcc6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
@@ -0,0 +1,49 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+@ProducerModule
+final class MultibindingProducerModule {
+  @Produces(type = SET) ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("foo");
+  }
+
+  @Produces(type = SET) String str() {
+    return "bar";
+  }
+
+  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
+  }
+
+  @Produces(type = SET_VALUES) Set<String> strs() {
+    return ImmutableSet.of("bar1", "bar2");
+  }
+
+  @Produces int strCount(Set<String> strs) {
+    return strs.size();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
new file mode 100644
index 000000000..039d0fe55
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class Request {
+  private final String name;
+
+  @Inject
+  Request() {
+    this.name = "Request";
+  }
+
+  String name() {
+    return this.name;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
new file mode 100644
index 000000000..7a46e5b0e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+final class Response {
+  private final String data;
+
+  Response(String data) {
+    this.data = data;
+  }
+
+  String data() {
+    return this.data;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
new file mode 100644
index 000000000..bda53eb56
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ResponseProducerModule {
+  @Produces ListenableFuture<String> greeting() {
+    return Futures.immediateFuture("Hello");
+  }
+
+  @Produces Response response(String greeting, Request request) {
+    return new Response(greeting + ", " + request.name() + "!");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
new file mode 100644
index 000000000..583cd50f0
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = ResponseProducerModule.class)
+interface SimpleComponent {
+  ListenableFuture<Response> response();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
new file mode 100644
index 000000000..fa63d4822
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
@@ -0,0 +1,32 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class SimpleProducerModule {
+  @Produces ListenableFuture<String> str() {
+    return Futures.immediateFuture("Hello, World!");
+  }
+
+  @Produces int len(String str) {
+    return str.length();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
new file mode 100644
index 000000000..15aa48165
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
@@ -0,0 +1,74 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class DependentTest {
+  @Test public void dependentComponent() throws Exception {
+    DependentComponent dependentComponent = DaggerDependentComponent
+        .builder()
+        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .build())
+        .dependedComponent(DaggerDependedComponent.create())
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(dependentComponent).isNotNull();
+    assertThat(dependentComponent.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+  }
+
+  @Test public void reuseBuilderWithDependentComponent() throws Exception {
+    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent
+        .builder()
+        .executor(MoreExecutors.directExecutor());
+
+    DependentComponent componentUsingComponents = dependentComponentBuilder
+        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .build())
+        .dependedComponent(DaggerDependedComponent.create())
+        .build();
+
+    DependentComponent componentUsingJavaImpls = dependentComponentBuilder
+        .dependedProductionComponent(new DependedProductionComponent() {
+          @Override public ListenableFuture<Integer> numGreetings() {
+            return Futures.immediateFuture(3);
+          }
+        })
+        .dependedComponent(new DependedComponent() {
+          @Override public String getGreeting() {
+            return "Goodbye world!";
+          }
+        })
+        .build();
+
+    assertThat(componentUsingJavaImpls.greetings().get()).containsExactly(
+        "3", "Goodbye world!", "GOODBYE WORLD!");
+    assertThat(componentUsingComponents.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
new file mode 100644
index 000000000..20c86dc52
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test public void multibinding() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
new file mode 100644
index 000000000..3826b6ed0
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
@@ -0,0 +1,55 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class ProducerFactoryTest {
+  @Test public void noArgMethod() throws Exception {
+    SimpleProducerModule module = new SimpleProducerModule();
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(module, MoreExecutors.directExecutor());
+    assertThat(producer.get().get()).isEqualTo("Hello, World!");
+  }
+
+  @Test public void singleArgMethod() throws Exception {
+    SimpleProducerModule module = new SimpleProducerModule();
+    SettableFuture<String> strFuture = SettableFuture.create();
+    Producer<String> strProducer = producerOfFuture(strFuture);
+    Producer<Integer> producer =
+        new SimpleProducerModule_LenFactory(module, MoreExecutors.directExecutor(), strProducer);
+    assertThat(producer.get().isDone()).isFalse();
+    strFuture.set("abcdef");
+    assertThat(producer.get().get()).isEqualTo(6);
+  }
+
+  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new Producer<T>() {
+      @Override public ListenableFuture<T> get() {
+        return future;
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
new file mode 100644
index 000000000..f2b910e3c
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SimpleTest {
+  @Test public void testSimpleComponent() throws Exception {
+    SimpleComponent simpleComponent = DaggerSimpleComponent
+        .builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(simpleComponent).isNotNull();
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+  }
+}
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
deleted file mode 100644
index 7a21a8bf7..000000000
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>same-provides-method-name</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
deleted file mode 100644
index 200b3d264..000000000
--- a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import dagger.Provides;
-
-import javax.inject.Inject;
-import java.lang.Override;
-
-class TestApp implements Runnable {
-
-  @Inject Foo foo;
-
-  @Override public void run() {
-    // Yay! \o/
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-
-  static class Foo {
-  }
-
-  static class MyFoo extends Foo {
-  }
-
-  @Module(entryPoints = TestApp.class)
-  static class TestModule {
-
-    @Provides Foo providesFoo(MyFoo foo) {
-      return foo;
-    }
-
-    @Provides MyFoo providesFoo() {
-      return new MyFoo();
-    }
-  }
-}
diff --git a/compiler/src/it/simple-missing-dependency-failure/invoker.properties b/compiler/src/it/simple-missing-dependency-failure/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/simple-missing-dependency-failure/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
deleted file mode 100644
index 92d27e8da..000000000
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>missing-dependency</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/simple-missing-dependency-failure/verify.bsh b/compiler/src/it/simple-missing-dependency-failure/verify.bsh
deleted file mode 100644
index fd4e2fd52..000000000
--- a/compiler/src/it/simple-missing-dependency-failure/verify.bsh
+++ /dev/null
@@ -1,7 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "No binding for test.TestApp$Dependency",
-    "required by test.TestApp for test.TestApp.TestModule"});
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
deleted file mode 100644
index a1440c652..000000000
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>uninjectable-supertype</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
deleted file mode 100644
index e18cb9133..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A build time binding that injects the constructor and fields of a class.
- */
-final class AtInjectBinding extends Binding<Object> {
-  private final TypeElement type;
-  private final List<String> keys;
-  private final Binding<?>[] bindings;
-  private final String supertypeKey;
-  private Binding supertypeBinding;
-
-  private AtInjectBinding(String provideKey, String membersKey,
-      TypeElement type, List<String> keys, String supertypeKey) {
-    super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
-        type.getQualifiedName().toString());
-    this.type = type;
-    this.keys = keys;
-    this.bindings = new Binding<?>[keys.size()];
-    this.supertypeKey = supertypeKey;
-  }
-
-  /**
-   * @param mustBeInjectable true if the binding must have {@code @Inject}
-   *     annotations.
-   */
-  static AtInjectBinding create(TypeElement type, boolean mustBeInjectable) {
-    List<String> requiredKeys = new ArrayList<String>();
-    boolean hasInjectAnnotatedConstructor = false;
-    boolean isConstructable = false;
-
-    for (Element enclosed : type.getEnclosedElements()) {
-      switch (enclosed.getKind()) {
-      case FIELD:
-        if (hasAtInject(enclosed) && !enclosed.getModifiers().contains(Modifier.STATIC)) {
-          // Attach the non-static fields of 'type'.
-          requiredKeys.add(GeneratorKeys.get((VariableElement) enclosed));
-        }
-        break;
-
-      case CONSTRUCTOR:
-        ExecutableElement constructor = (ExecutableElement) enclosed;
-        List<? extends VariableElement> parameters = constructor.getParameters();
-        if (hasAtInject(enclosed)) {
-          if (hasInjectAnnotatedConstructor) {
-            throw new IllegalArgumentException("Too many injectable constructors on "
-                + type.getQualifiedName().toString());
-          }
-          hasInjectAnnotatedConstructor = true;
-          isConstructable = true;
-          for (VariableElement parameter : parameters) {
-            requiredKeys.add(GeneratorKeys.get(parameter));
-          }
-        } else if (parameters.isEmpty()) {
-          isConstructable = true;
-        }
-        break;
-
-      default:
-        if (hasAtInject(enclosed)) {
-          throw new IllegalArgumentException("Unexpected @Inject annotation on " + enclosed);
-        }
-      }
-    }
-
-    if (!hasInjectAnnotatedConstructor && requiredKeys.isEmpty() && mustBeInjectable) {
-      throw new IllegalArgumentException("No injectable members on "
-          + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
-    }
-
-    // Attach the supertype.
-    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
-    String supertypeKey = supertype != null
-        ? GeneratorKeys.rawMembersKey(supertype)
-        : null;
-
-    String provideKey = isConstructable ? GeneratorKeys.get(type.asType()) : null;
-    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
-    return new AtInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
-  }
-
-  private static boolean hasAtInject(Element enclosed) {
-    return enclosed.getAnnotation(Inject.class) != null;
-  }
-
-  @Override public void attach(Linker linker) {
-    String requiredBy = type.getQualifiedName().toString();
-    for (int i = 0; i < keys.size(); i++) {
-      bindings[i] = linker.requestBinding(keys.get(i), requiredBy);
-    }
-    if (supertypeKey != null) {
-      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy, false);
-    }
-  }
-
-  @Override public Object get() {
-    throw new AssertionError("Compile-time binding should never be called to inject.");
-  }
-
-  @Override public void injectMembers(Object t) {
-    throw new AssertionError("Compile-time binding should never be called to inject.");
-  }
-
-  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    for (Binding<?> binding : bindings) {
-      get.add(binding);
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
new file mode 100644
index 000000000..edb8ad6b3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * An abstract type for classes representing a Dagger binding.  Particularly, contains the
+ * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
+ * required to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding
+ * to the subtypes.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class Binding {
+  static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
+    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+    for (Binding binding : bindings) {
+      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+    }
+    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+    switch (bindingPackages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(bindingPackages.iterator().next());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  /** The {@link Key} that is provided by this binding. */
+  protected abstract Key key();
+
+  /** Returns the {@link Element} instance that is responsible for declaring the binding. */
+  abstract Element bindingElement();
+
+  /** The type enclosing the binding {@link #bindingElement()}. */
+  TypeElement bindingTypeElement() {
+    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override
+      protected TypeElement defaultAction(Element e, Void p) {
+        return MoreElements.asType(bindingElement().getEnclosingElement());
+      }
+
+      @Override
+      public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+    }, null);
+  }
+
+  /**
+   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencies();
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
+   * superset of {@link #dependencies()}.  This returns an unmodifiable set.
+   */
+  abstract Set<DependencyRequest> implicitDependencies();
+
+  /**
+   * Returns the name of the package in which this binding must be managed. E.g.: a binding
+   * may reference non-public types.
+   */
+  abstract Optional<String> bindingPackage();
+
+  protected static Optional<String> findBindingPackage(Key bindingKey) {
+    Set<String> packages = nonPublicPackageUse(bindingKey.type());
+    switch (packages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(packages.iterator().next());
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
+    ImmutableSet.Builder<String> packages = ImmutableSet.builder();
+    typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
+      @Override
+      public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
+        return t.getComponentType().accept(this, p);
+      }
+
+      @Override
+      public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
+        for (TypeMirror typeArgument : t.getTypeArguments()) {
+          typeArgument.accept(this, p);
+        }
+        // TODO(gak): address public nested types in non-public types
+        TypeElement typeElement = MoreElements.asType(t.asElement());
+        if (!typeElement.getModifiers().contains(PUBLIC)) {
+          PackageElement elementPackage = MoreElements.getPackage(typeElement);
+          Name qualifiedName = elementPackage.getQualifiedName();
+          p.add(qualifiedName.toString());
+        }
+        // Also make sure enclosing types are visible, otherwise we're fooled by
+        // class Foo { public class Bar }
+        // (Note: we can't use t.getEnclosingType() because it doesn't work!)
+        typeElement.getEnclosingElement().asType().accept(this, p);
+        return null;
+      }
+
+      @Override
+      public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
+        if (t.getExtendsBound() != null) {
+          t.getExtendsBound().accept(this, p);
+        }
+        if (t.getSuperBound() != null) {
+          t.getSuperBound().accept(this, p);
+        }
+        return null;
+      }
+    }, packages);
+    return packages.build();
+  }
+
+  /**
+   * Returns true if this is a binding for a key that has a different type parameter list than the
+   * element it's providing.
+   */
+  abstract boolean hasNonDefaultTypeParameters();
+
+  // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
+  static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
+    // If the element has no type parameters, nothing can be wrong.
+    if (element.getTypeParameters().isEmpty()) {
+      return false;
+    }
+    
+    List<TypeMirror> defaultTypes = Lists.newArrayList();
+    for (TypeParameterElement parameter : element.getTypeParameters()) {
+      defaultTypes.add(parameter.asType());
+    }
+    
+    List<TypeMirror> actualTypes =
+        type.accept(new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
+          @Override
+          protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
+            return ImmutableList.of();
+          }
+
+          @Override
+          public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
+            return ImmutableList.copyOf(t.getTypeArguments());
+          }
+        }, null);
+    
+    // The actual type parameter size can be different if the user is using a raw type.
+    if (defaultTypes.size() != actualTypes.size()) {
+      return true;
+    }
+
+    for (int i = 0; i < defaultTypes.size(); i++) {
+      if (!types.isSameType(defaultTypes.get(i), actualTypes.get(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
new file mode 100644
index 000000000..80e6c1187
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -0,0 +1,456 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.Provides;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * The canonical representation of a full-resolved graph.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class BindingGraph {
+  enum ModuleStrategy {
+    PASSED,
+    CONSTRUCTED,
+  }
+
+  abstract ComponentDescriptor componentDescriptor();
+  abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
+  abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final InjectBindingRegistry injectBindingRegistry;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final ProductionBinding.Factory productionBindingFactory;
+
+    Factory(Elements elements,
+        Types types,
+        InjectBindingRegistry injectBindingRegistry,
+        Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory,
+        ProvisionBinding.Factory provisionBindingFactory,
+        ProductionBinding.Factory productionBindingFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.injectBindingRegistry = injectBindingRegistry;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.productionBindingFactory = productionBindingFactory;
+    }
+
+    BindingGraph create(ComponentDescriptor componentDescriptor) {
+      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+    }
+
+    private BindingGraph create(Optional<RequestResolver> parentResolver,
+        ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
+          ImmutableSet.builder();
+      ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
+          ImmutableSet.builder();
+      AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
+
+      // binding for the component itself
+      TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
+      ProvisionBinding componentBinding =
+          provisionBindingFactory.forComponent(componentDefinitionType);
+      explicitProvisionBindingsBuilder.add(componentBinding);
+
+      // Collect Component dependencies.
+      Optional<AnnotationMirror> componentMirror =
+          getAnnotationMirror(componentDefinitionType, Component.class)
+              .or(getAnnotationMirror(componentDefinitionType, ProductionComponent.class));
+      ImmutableSet<TypeElement> componentDependencyTypes = componentMirror.isPresent()
+          ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
+          : ImmutableSet.<TypeElement>of();
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        explicitProvisionBindingsBuilder.add(
+            provisionBindingFactory.forComponent(componentDependency));
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement method : dependencyMethods) {
+          // MembersInjection methods aren't "provided" explicitly, so ignore them.
+          if (isComponentContributionMethod(elements, method)) {
+            if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+                && isComponentProductionMethod(elements, method)) {
+              explicitProductionBindingsBuilder.add(
+                  productionBindingFactory.forComponentMethod(method));
+            } else {
+              explicitProvisionBindingsBuilder.add(
+                  provisionBindingFactory.forComponentMethod(method));
+            }
+          }
+        }
+      }
+
+      // Collect transitive modules provisions.
+      ImmutableSet<TypeElement> moduleTypes =
+          MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
+
+      ImmutableMap.Builder<TypeElement, ModuleStrategy> transitiveModules = ImmutableMap.builder();
+      for (TypeElement module : getTransitiveModules(types, elements, moduleTypes)) {
+        transitiveModules.put(module,
+            (componentCanMakeNewInstances(module) && module.getTypeParameters().isEmpty())
+                ? ModuleStrategy.CONSTRUCTED
+                : ModuleStrategy.PASSED);
+
+        // traverse the modules, collect the bindings
+        List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
+        for (ExecutableElement moduleMethod : moduleMethods) {
+          if (isAnnotationPresent(moduleMethod, Provides.class)) {
+            explicitProvisionBindingsBuilder.add(
+                provisionBindingFactory.forProvidesMethod(moduleMethod, module.asType()));
+          }
+          if (isAnnotationPresent(moduleMethod, Produces.class)) {
+            explicitProductionBindingsBuilder.add(
+                productionBindingFactory.forProducesMethod(moduleMethod, module.asType()));
+           }
+        }
+      }
+
+      RequestResolver requestResolver = new RequestResolver(
+          parentResolver,
+          componentDescriptor.wrappedScope(),
+          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
+          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
+        Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
+        if (componentMethodRequest.isPresent()) {
+          requestResolver.resolve(componentMethodRequest.get());
+        }
+      }
+
+      ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
+          ImmutableMap.builder();
+      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+          componentDescriptor.subcomponents().entrySet()) {
+        subgraphsBuilder.put(subcomponentEntry.getKey(),
+            create(Optional.of(requestResolver), subcomponentEntry.getValue()));
+      }
+
+      return new AutoValue_BindingGraph(
+          componentDescriptor,
+          transitiveModules.build(),
+          requestResolver.getResolvedBindings(),
+          subgraphsBuilder.build());
+    }
+
+    private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
+        Iterable<? extends B> bindings) {
+      // Multimaps.index() doesn't do ImmutableSetMultimaps.
+      ImmutableSetMultimap.Builder<Key, B> builder = ImmutableSetMultimap.builder();
+      for (B binding : bindings) {
+        builder.put(binding.key(), binding);
+      }
+      return builder.build();
+    }
+
+    private final class RequestResolver {
+      final Optional<RequestResolver> parentResolver;
+      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
+      final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
+      final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
+      final Map<BindingKey, ResolvedBindings> resolvedBindings;
+      final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
+
+      RequestResolver(Optional<RequestResolver> parentResolver,
+          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
+          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
+          ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+        assert parentResolver != null;
+        this.parentResolver = parentResolver;
+        assert targetScope != null;
+        this.targetScope = targetScope;
+        assert explicitProvisionBindings != null;
+        this.explicitProvisionBindings = explicitProvisionBindings;
+        assert explicitProductionBindings != null;
+        this.explicitProductionBindings = explicitProductionBindings;
+        this.resolvedBindings = Maps.newLinkedHashMap();
+      }
+
+      /**
+       *  Looks up the bindings associated with a given dependency request and returns them.  In the
+       *  event that the binding is owned by a parent component it will trigger resolution in that
+       *  component's resolver but will return an {@link Optional#absent} value.
+       */
+      ResolvedBindings lookUpBindings(DependencyRequest request) {
+        BindingKey bindingKey = request.bindingKey();
+        switch (bindingKey.kind()) {
+          case CONTRIBUTION:
+            // First, check for explicit keys (those from modules and components)
+            ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
+                getExplicitProvisionBindings(bindingKey.key());
+            ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
+                getExplicitProductionBindings(bindingKey.key());
+
+            // If the key is Map<K, V>, get its implicit binding keys, which are either
+            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
+            Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
+            if (mapProviderKey.isPresent()) {
+              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
+            }
+
+            Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
+            if (mapProducerKey.isPresent()) {
+              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
+            }
+
+            if (!explicitProvisionBindingsForKey.isEmpty()
+                || !explicitProductionBindingsForKey.isEmpty()) {
+              // we have some explicit binding for this key, so we collect all explicit implicit map
+              // bindings that might conflict with this and let the validator sort it out
+              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
+              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
+              for (ProvisionBinding provisionBinding :
+                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
+                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
+                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                  owningResolver.get().resolve(request);
+                  inheritedBindings.add(provisionBinding);
+                } else {
+                  ownedBindings.add(provisionBinding);
+                }
+              }
+              return ResolvedBindings.create(bindingKey,
+                  ownedBindings
+                      .addAll(explicitProductionBindingsForKey)
+                      .addAll(explicitMapProductionBindings)
+                      .build(),
+                  inheritedBindings.build());
+            } else {
+              if (!explicitMapProductionBindings.isEmpty()) {
+                // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
+                // must be considered an implicit ProductionBinding
+                DependencyRequest implicitRequest =
+                    dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
+                return ResolvedBindings.create(bindingKey,
+                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
+              } else if (!explicitMapProvisionBindings.isEmpty()) {
+                // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
+                // ProvisionBinding
+                DependencyRequest implicitRequest =
+                    dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
+                return ResolvedBindings.create(bindingKey,
+                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
+              } else {
+                // no explicit binding, look it up.
+                Optional<ProvisionBinding> provisionBinding =
+                    injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
+                if (provisionBinding.isPresent()) {
+                  Optional<RequestResolver> owningResolver =
+                      getOwningResolver(provisionBinding.get());
+                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                    owningResolver.get().resolve(request);
+                    return ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(),
+                        provisionBinding.asSet());
+                  }
+                }
+                return ResolvedBindings.create(
+                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
+              }
+            }
+          case MEMBERS_INJECTION:
+            // no explicit deps for members injection, so just look it up
+            return ResolvedBindings.create(
+                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
+        MembersInjectionBinding membersInjectionBinding =
+            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+
+        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
+          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
+              membersInjectionBinding.parentInjectorRequest().get().key());
+          if (parentBinding.injectionStrategy().equals(NO_OP)) {
+            return membersInjectionBinding.withoutParentInjectorRequest();
+          }
+        }
+
+        return membersInjectionBinding;
+      }
+
+      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
+        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
+            provisionBinding.wrappedScope();
+        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.explicitProvisionBindings.containsValue(provisionBinding)) {
+             return Optional.of(requestResolver);
+          }
+        }
+        // look for scope separately.  we do this for the case where @Singleton can appear twice
+        // in the † compatibility mode
+        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+          if (bindingScope.isPresent() && bindingScope.equals(requestResolver.targetScope)) {
+            return Optional.of(requestResolver);
+          }
+        }
+        return Optional.absent();
+      }
+
+      /** Returns the resolver lineage from parent to child. */
+      private ImmutableList<RequestResolver> getResolverLineage() {
+        List<RequestResolver> resolverList = Lists.newArrayList();
+        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+            currentResolver.isPresent();
+            currentResolver = currentResolver.get().parentResolver) {
+          resolverList.add(currentResolver.get());
+        }
+        return ImmutableList.copyOf(Lists.reverse(resolverList));
+      }
+
+      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProvisionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
+      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProductionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
+      private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
+          final BindingKey bindingKey) {
+        Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
+        if (result.isPresent()) {
+          return result;
+        } else if (parentResolver.isPresent()) {
+          return parentResolver.get().getPreviouslyResolvedBindings(bindingKey);
+        } else {
+          return Optional.absent();
+        }
+      }
+
+      void resolve(DependencyRequest request) {
+        BindingKey bindingKey = request.bindingKey();
+
+        Optional<ResolvedBindings> previouslyResolvedBinding =
+            getPreviouslyResolvedBindings(bindingKey);
+        if (previouslyResolvedBinding.isPresent()
+            && !(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+                && !previouslyResolvedBinding.get().contributionBindings().isEmpty()
+                && ContributionBinding.bindingTypeFor(
+                    previouslyResolvedBinding.get().contributionBindings()).isMultibinding())) {
+          return;
+        }
+
+        if (cycleStack.contains(bindingKey)) {
+          // We found a cycle. Don't add a resolved binding, since the original request will add it
+          // with all of the other resolved deps
+          return;
+        }
+
+        cycleStack.push(bindingKey);
+        try {
+          ResolvedBindings bindings = lookUpBindings(request);
+          for (Binding binding : bindings.ownedBindings()) {
+            for (DependencyRequest dependency : binding.implicitDependencies()) {
+              resolve(dependency);
+            }
+          }
+          resolvedBindings.put(bindingKey, bindings);
+        } finally {
+          cycleStack.pop();
+        }
+      }
+
+      ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
+        ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
+            ImmutableMap.builder();
+        resolvedBindingsBuilder.putAll(resolvedBindings);
+        if (parentResolver.isPresent()) {
+          for (ResolvedBindings resolvedInParent :
+              parentResolver.get().getResolvedBindings().values()) {
+            BindingKey bindingKey = resolvedInParent.bindingKey();
+            if (!resolvedBindings.containsKey(bindingKey)) {
+              if (resolvedInParent.ownedBindings().isEmpty()) {
+                // reuse the instance if we can get away with it
+                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
+              } else {
+                resolvedBindingsBuilder.put(bindingKey,
+                    ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
+              }
+            }
+          }
+        }
+        return resolvedBindingsBuilder.build();
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
new file mode 100644
index 000000000..74080ff8e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -0,0 +1,857 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ValidationReport.Builder;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Deque;
+import java.util.Formatter;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+
+public class BindingGraphValidator implements Validator<BindingGraph> {
+
+  private final Types types;
+  private final InjectBindingRegistry injectBindingRegistry;
+  private final ValidationType scopeCycleValidationType;
+  private final Diagnostic.Kind nullableValidationType;
+  private final ProvisionBindingFormatter provisionBindingFormatter;
+  private final ProductionBindingFormatter productionBindingFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final DependencyRequestFormatter dependencyRequestFormatter;
+  private final KeyFormatter keyFormatter;
+
+  BindingGraphValidator(
+      Types types,
+      InjectBindingRegistry injectBindingRegistry,
+      ValidationType scopeCycleValidationType,
+      Diagnostic.Kind nullableValidationType,
+      ProvisionBindingFormatter provisionBindingFormatter,
+      ProductionBindingFormatter productionBindingFormatter,
+      MethodSignatureFormatter methodSignatureFormatter,
+      DependencyRequestFormatter dependencyRequestFormatter,
+      KeyFormatter keyFormatter) {
+    this.types = types;
+    this.injectBindingRegistry = injectBindingRegistry;
+    this.scopeCycleValidationType = scopeCycleValidationType;
+    this.nullableValidationType = nullableValidationType;
+    this.provisionBindingFormatter = provisionBindingFormatter;
+    this.productionBindingFormatter = productionBindingFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.dependencyRequestFormatter = dependencyRequestFormatter;
+    this.keyFormatter = keyFormatter;
+  }
+
+  @Override
+  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+    final ValidationReport.Builder<BindingGraph> reportBuilder =
+        ValidationReport.Builder.about(subject);
+    return validate(subject, reportBuilder);
+  }
+
+  private ValidationReport<BindingGraph> validate(final BindingGraph subject,
+      final ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+
+    validateComponentScope(subject, reportBuilder, resolvedBindings);
+    validateDependencyScopes(subject, reportBuilder);
+    validateBuilders(subject, reportBuilder);
+
+    for (ComponentMethodDescriptor componentMethod :
+        subject.componentDescriptor().componentMethods()) {
+      Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
+      if (entryPoint.isPresent()) {
+        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
+            Sets.<BindingKey>newHashSet(), subject, reportBuilder,
+            Sets.<DependencyRequest>newHashSet());
+      }
+    }
+
+    validateSubcomponents(subject, reportBuilder);
+    return reportBuilder.build();
+  }
+
+  private void traverseRequest(
+      DependencyRequest request,
+      Deque<ResolvedRequest> bindingPath,
+      Set<BindingKey> keysInPath,
+      BindingGraph graph,
+      ValidationReport.Builder<BindingGraph> reportBuilder,
+      Set<DependencyRequest> resolvedRequests) {
+    verify(bindingPath.size() == keysInPath.size(),
+        "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
+    BindingKey requestKey = request.bindingKey();
+    if (keysInPath.contains(requestKey)) {
+      reportCycle(request, bindingPath, reportBuilder);
+      return;
+    }
+
+     // If request has already been resolved, avoid re-traversing the binding path.
+    if (resolvedRequests.add(request)) {
+      ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
+      bindingPath.push(resolvedRequest);
+      keysInPath.add(requestKey);
+      validateResolvedBinding(bindingPath, resolvedRequest.binding(), reportBuilder);
+
+      for (Binding binding : resolvedRequest.binding().bindings()) {
+        for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+          traverseRequest(nextRequest, bindingPath, keysInPath, graph, reportBuilder,
+              resolvedRequests);
+        }
+      }
+      bindingPath.poll();
+      keysInPath.remove(requestKey);
+    }
+  }
+
+  private void validateSubcomponents(BindingGraph graph,
+      ValidationReport.Builder<BindingGraph> reportBuilder) {
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+      validate(subgraphEntry.getValue(), reportBuilder);
+    }
+  }
+
+  /**
+   * Validates that the set of bindings resolved is consistent with the type of the binding, and
+   * returns true if the bindings are valid.
+   */
+  private boolean validateResolvedBinding(
+      Deque<ResolvedRequest> path,
+      ResolvedBindings resolvedBinding,
+      Builder<BindingGraph> reportBuilder) {
+    if (resolvedBinding.bindings().isEmpty()) {
+      reportMissingBinding(path, reportBuilder);
+      return false;
+    }
+
+    ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
+        ImmutableSet.builder();
+    ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
+        ImmutableSet.builder();
+    ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
+        ImmutableSet.builder();
+    for (Binding binding : resolvedBinding.bindings()) {
+      if (binding instanceof ProvisionBinding) {
+        provisionBindingsBuilder.add((ProvisionBinding) binding);
+      }
+      if (binding instanceof ProductionBinding) {
+        productionBindingsBuilder.add((ProductionBinding) binding);
+      }
+      if (binding instanceof MembersInjectionBinding) {
+        membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
+      }
+    }
+    ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
+    ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        membersInjectionBindingsBuilder.build();
+
+    switch (resolvedBinding.bindingKey().kind()) {
+      case CONTRIBUTION:
+        if (!membersInjectionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "contribution binding keys should never have members injection bindings");
+        }
+        Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
+        if (!validateNullability(path.peek().request(), combined, reportBuilder)) {
+          return false;
+        }
+        if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+          reportProviderMayNotDependOnProducer(path, reportBuilder);
+          return false;
+        }
+        if ((provisionBindings.size() + productionBindings.size()) <= 1) {
+          return true;
+        }
+        ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+            ContributionBinding.bindingTypesFor(
+                Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
+        if (bindingsByType.keySet().size() > 1) {
+          reportMultipleBindingTypes(path, reportBuilder);
+          return false;
+        } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+          reportDuplicateBindings(path, reportBuilder);
+          return false;
+        }
+        break;
+      case MEMBERS_INJECTION:
+        if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "members injection binding keys should never have contribution bindings");
+        }
+        if (membersInjectionBindings.size() > 1) {
+          reportDuplicateBindings(path, reportBuilder);
+          return false;
+        }
+        if (membersInjectionBindings.size() == 1) {
+          MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
+          if (!validateMembersInjectionBinding(binding, path, reportBuilder)) {
+            return false;
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+    return true;
+  }
+
+  /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
+  private boolean validateNullability(DependencyRequest request,
+      Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
+    boolean valid = true;
+    if (!request.isNullable()) {
+      String typeName = null;
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          String methodSignature;
+          if (binding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+            methodSignature = provisionBindingFormatter.format(provisionBinding);
+          } else {
+            ProductionBinding productionBinding = (ProductionBinding) binding;
+            methodSignature = productionBindingFormatter.format(productionBinding);
+          }
+          // Note: the method signature will include the @Nullable in it!
+          // TODO(sameb): Sometimes javac doesn't include the Element in its output.
+          // (Maybe this happens if the code was already compiled before this point?)
+          // ... we manually print ouf the request in that case, otherwise the error
+          // message is kind of useless.
+          if (typeName == null) {
+            typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+          }
+          reportBuilder.addItem(
+              String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
+              + "\n at: " + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
+        }
+      }
+    }
+    return valid;
+  }
+
+  /**
+   * Validates a members injection binding, returning false (and reporting the error) if it wasn't
+   * valid.
+   */
+  private boolean validateMembersInjectionBinding(MembersInjectionBinding binding,
+      final Deque<ResolvedRequest> path, final Builder<BindingGraph> reportBuilder) {
+    return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        reportBuilder.addItem("Invalid members injection request.",
+            path.peek().request().requestElement());
+        return false;
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // If the key has type arguments, validate that each type argument is declared.
+        // Otherwise the type argument may be a wildcard (or other type), and we can't
+        // resolve that to actual types.  If the arg was an array, validate the type
+        // of the array.
+        for (TypeMirror arg : type.getTypeArguments()) {
+          boolean declared;
+          switch (arg.getKind()) {
+            case ARRAY:
+              declared = MoreTypes.asArray(arg).getComponentType().accept(
+                  new SimpleTypeVisitor6<Boolean, Void>() {
+                    @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+                      return false;
+                    }
+
+                    @Override public Boolean visitDeclared(DeclaredType t, Void p) {
+                      for (TypeMirror arg : t.getTypeArguments()) {
+                        if (!arg.accept(this, null)) {
+                          return false;
+                        }
+                      }
+                      return true;
+                    }
+
+                    @Override public Boolean visitArray(ArrayType t, Void p) {
+                      return t.getComponentType().accept(this, null);
+                    }
+
+                    @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                      return true;
+                    }
+                  }, null);
+              break;
+            case DECLARED:
+              declared = true;
+              break;
+            default:
+              declared = false;
+          }
+          if (!declared) {
+            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                .transform(dependencyRequestFormatter)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse();
+            reportBuilder.addItem(
+                String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                    arg.toString(),
+                    type.toString(),
+                    Joiner.on('\n').join(printableDependencyPath)),
+                    path.peek().request().requestElement());
+            return false;
+          }
+        }
+
+        TypeElement element = MoreElements.asType(type.asElement());
+        // Also validate that the key is not the erasure of a generic type.
+        // If it is, that means the user referred to Foo<T> as just 'Foo',
+        // which we don't allow.  (This is a judgement call -- we *could*
+        // allow it and instantiate the type bounds... but we don't.)
+        if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+            && types.isSameType(types.erasure(element.asType()), type)) {
+            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                .transform(dependencyRequestFormatter)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse();
+          reportBuilder.addItem(
+              String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
+                  type.toString(),
+                  Joiner.on('\n').join(printableDependencyPath)),
+              path.peek().request().requestElement());
+          return false;
+        }
+
+        return true; // valid
+      }
+    }, null);
+  }
+
+  /**
+   * Validates that among the dependencies are at most one scoped dependency,
+   * that there are no cycles within the scoping chain, and that singleton
+   * components have no scoped dependencies.
+   */
+  private void validateDependencyScopes(BindingGraph subject,
+      Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor descriptor = subject.componentDescriptor();
+    Optional<AnnotationMirror> scope = subject.componentDescriptor().scope();
+    ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
+    if (scope.isPresent()) {
+      // Dagger 1.x scope compatibility requires this be suppress-able.
+      if (scopeCycleValidationType.diagnosticKind().isPresent()
+          && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+        // Singleton is a special-case representing the longest lifetime, and therefore
+        // @Singleton components may not depend on scoped components
+        if (!scopedDependencies.isEmpty()) {
+          StringBuilder message = new StringBuilder(
+              "This @Singleton component cannot depend on scoped components:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          reportBuilder.addItem(message.toString(),
+              scopeCycleValidationType.diagnosticKind().get(),
+              descriptor.componentDefinitionType(),
+              descriptor.componentAnnotation());
+        }
+      } else if (scopedDependencies.size() > 1) {
+        // Scoped components may depend on at most one scoped component.
+        StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+            .append(' ')
+            .append(descriptor.componentDefinitionType().getQualifiedName())
+            .append(" depends on more than one scoped component:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      } else {
+        // Dagger 1.x scope compatibility requires this be suppress-able.
+        if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
+          validateScopeHierarchy(descriptor.componentDefinitionType(),
+              descriptor.componentDefinitionType(),
+              reportBuilder,
+              new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+              new ArrayDeque<TypeElement>());
+        }
+      }
+    } else {
+      // Scopeless components may not depend on scoped components.
+      if (!scopedDependencies.isEmpty()) {
+        StringBuilder message =
+            new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
+                .append(" (unscoped) cannot depend on scoped components:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      }
+    }
+  }
+
+  private void validateBuilders(BindingGraph subject, Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor componentDesc = subject.componentDescriptor();
+    if (!componentDesc.builderSpec().isPresent()) {
+      // If no builder, nothing to validate.
+      return;
+    }
+
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                subject.transitiveModules().keySet(),
+                componentDesc.dependencies()),
+            componentDesc.executorDependency().asSet());
+    Set<TypeElement> requiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    final BuilderSpec spec = componentDesc.builderSpec().get();
+    Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+
+    ErrorMessages.ComponentBuilderMessages msgs =
+        ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
+    Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+    if (!extraSetters.isEmpty()) {
+      Collection<ExecutableElement> excessMethods =
+          Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
+      Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
+          new Function<ExecutableElement, String>() {
+            @Override public String apply(ExecutableElement input) {
+              return methodSignatureFormatter.format(input,
+                  Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
+            }});
+      reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
+          spec.builderDefinitionType());
+    }
+
+    Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+    if (!missingSetters.isEmpty()) {
+      reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
+          spec.builderDefinitionType());
+    }
+  }
+
+  /**
+   * Append and format a list of indented component types (with their scope annotations)
+   */
+  private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
+    for (TypeElement scopedComponent : types) {
+      message.append(INDENT);
+      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      if (scope.isPresent()) {
+        message.append(ErrorMessages.format(scope.get())).append(' ');
+      }
+      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
+          .append('\n');
+    }
+  }
+
+  /**
+   * Returns a set of type elements containing only those found in the input set that have
+   * a scoping annotation.
+   */
+  private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+    return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
+      @Override public boolean apply(TypeElement input) {
+        return getScopeAnnotation(input).isPresent();
+      }
+    }).toSet();
+  }
+
+  /**
+   * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
+   * components are in a hierarchical relationship terminating with Singleton.
+   *
+   * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
+   * themselves, since a component's presence within its own dependency path implies a cyclical
+   * relationship between scopes.
+   */
+  private void validateScopeHierarchy(TypeElement rootComponent,
+      TypeElement componentType,
+      Builder<BindingGraph> reportBuilder,
+      Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+      Deque<TypeElement> scopedDependencyStack) {
+    Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+    if (scope.isPresent()) {
+      Equivalence.Wrapper<AnnotationMirror> wrappedScope =
+          AnnotationMirrors.equivalence().wrap(scope.get());
+      if (scopeStack.contains(wrappedScope)) {
+        scopedDependencyStack.push(componentType);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
+          reportBuilder.addItem(message.toString(),
+              scopeCycleValidationType.diagnosticKind().get(),
+              rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
+          if (scopedDependencies.size() == 1) {
+            // empty can be ignored (base-case), and > 1 is a different error reported separately.
+            scopeStack.push(wrappedScope);
+            scopedDependencyStack.push(componentType);
+            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                reportBuilder, scopeStack, scopedDependencyStack);
+            scopedDependencyStack.pop();
+            scopeStack.pop();
+          }
+        } // else: we skip component dependencies which are not components
+      }
+    }
+  }
+
+  /**
+   * Validates that the scope (if any) of this component are compatible with the scopes of the
+   * bindings available in this component
+   */
+  void validateComponentScope(final BindingGraph subject,
+      final ValidationReport.Builder<BindingGraph> reportBuilder,
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings) {
+    Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
+        subject.componentDescriptor().wrappedScope();
+    ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
+    for (ResolvedBindings bindings : resolvedBindings.values()) {
+      if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
+          if (contributionBinding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+            if (provisionBinding.scope().isPresent()
+                && !componentScope.equals(provisionBinding.wrappedScope())) {
+              // Scoped components cannot reference bindings to @Provides methods or @Inject
+              // types decorated by a different scope annotation. Unscoped components cannot
+              // reference to scoped @Provides methods or @Inject types decorated by any
+              // scope annotation.
+              switch (provisionBinding.bindingKind()) {
+                case PROVISION:
+                  ExecutableElement provisionMethod =
+                      MoreElements.asExecutable(provisionBinding.bindingElement());
+                  incompatiblyScopedMethodsBuilder.add(
+                      methodSignatureFormatter.format(provisionMethod));
+                  break;
+                case INJECTION:
+                  incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
+                      provisionBinding.scope().get().toString()) + " class "
+                          + provisionBinding.bindingTypeElement().getQualifiedName());
+                  break;
+                default:
+                  throw new IllegalStateException();
+              }
+            }
+          }
+        }
+      }
+    }
+    ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
+    if (!incompatiblyScopedMethods.isEmpty()) {
+      TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
+      StringBuilder message = new StringBuilder(componentType.getQualifiedName());
+      if (componentScope.isPresent()) {
+        message.append(" scoped with ");
+        message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
+        message.append(" may not reference bindings with different scopes:\n");
+      } else {
+        message.append(" (unscoped) may not reference scoped bindings:\n");
+      }
+      for (String method : incompatiblyScopedMethods) {
+        message.append(ErrorMessages.INDENT).append(method).append("\n");
+      }
+      reportBuilder.addItem(message.toString(), componentType,
+          subject.componentDescriptor().componentAnnotation());
+    }
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportProviderMayNotDependOnProducer(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder errorMessage = new StringBuilder();
+    if (path.size() == 1) {
+      new Formatter(errorMessage).format(
+          ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+          keyFormatter.format(path.peek().request().key()));
+    } else {
+      ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
+      // TODO(user): Consider displaying all dependent provisions in the error message. If we do
+      // that, should we display all productions that depend on them also?
+      new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+          keyFormatter.format(dependentProvisions.iterator().next().key()));
+    }
+    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+  }
+
+  private void reportMissingBinding(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    Key key = path.peek().request().key();
+    TypeMirror type = key.type();
+    String typeName = TypeNames.forTypeMirror(type).toString();
+    boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
+    boolean requiresProvision = doesPathRequireProvisionOnly(path);
+    StringBuilder errorMessage = new StringBuilder();
+    String requiresErrorMessageFormat = requiresContributionMethod
+        ? requiresProvision
+            ? REQUIRES_PROVIDER_FORMAT
+            : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
+        : requiresProvision
+            ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+            : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+    errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
+    if (key.isValidMembersInjectionKey()
+        && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
+            .isEmpty()) {
+      errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+    }
+    ImmutableList<String> printableDependencyPath =
+        FluentIterable.from(path)
+            .transform(REQUEST_FROM_RESOLVED_REQUEST)
+            .transform(dependencyRequestFormatter)
+            .filter(Predicates.not(Predicates.equalTo("")))
+            .toList()
+            .reverse();
+    for (String dependency :
+        printableDependencyPath.subList(1, printableDependencyPath.size())) {
+      errorMessage.append("\n").append(dependency);
+    }
+    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+  }
+
+  /**
+   * Returns whether the given dependency path would require the most recent request to be resolved
+   * by only provision bindings.
+   */
+  private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
+    if (path.size() == 1) {
+      // if this is an entry-point, then we check the request
+      switch (path.peek().request().kind()) {
+        case INSTANCE:
+        case PROVIDER:
+        case LAZY:
+        case MEMBERS_INJECTOR:
+          return true;
+        case PRODUCER:
+        case PRODUCED:
+        case FUTURE:
+          return false;
+        default:
+          throw new AssertionError();
+      }
+    }
+    // otherwise, the second-most-recent bindings determine whether the most recent one must be a
+    // provision
+    ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
+    return !dependentProvisions.isEmpty();
+  }
+
+  /**
+   * Returns any provision bindings resolved for the second-most-recent request in the given path;
+   * that is, returns those provision bindings that depend on the latest request in the path.
+   */
+  private ImmutableSet<ProvisionBinding> provisionsDependingOnLatestRequest(
+      Deque<ResolvedRequest> path) {
+    Iterator<ResolvedRequest> iterator = path.iterator();
+    final DependencyRequest request = iterator.next().request();
+    ResolvedRequest previousResolvedRequest = iterator.next();
+    @SuppressWarnings("unchecked")  // validated by instanceof below
+    ImmutableSet<ProvisionBinding> bindings = (ImmutableSet<ProvisionBinding>) FluentIterable
+        .from(previousResolvedRequest.binding().bindings())
+        .filter(new Predicate<Binding>() {
+            @Override public boolean apply(Binding binding) {
+              return binding instanceof ProvisionBinding
+                  && binding.implicitDependencies().contains(request);
+            }
+        }).toSet();
+    return bindings;
+  }
+
+  private static final int DUPLICATE_SIZE_LIMIT = 10;
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportDuplicateBindings(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ResolvedBindings resolvedBinding = path.peek().binding();
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+        keyFormatter.format(path.peek().request().key()));
+    for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
+      builder.append('\n').append(INDENT);
+      // TODO(user): Refactor the formatters so we don't need these instanceof checks.
+      if (binding instanceof ProvisionBinding) {
+        builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+      } else if (binding instanceof ProductionBinding) {
+        builder.append(productionBindingFormatter.format((ProductionBinding) binding));
+      }
+    }
+    int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
+    if (numberOfOtherBindings > 0) {
+      builder.append('\n').append(INDENT)
+          .append("and ").append(numberOfOtherBindings).append(" other");
+    }
+    if (numberOfOtherBindings > 1) {
+      builder.append('s');
+    }
+    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportMultipleBindingTypes(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ResolvedBindings resolvedBinding = path.peek().binding();
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+        keyFormatter.format(path.peek().request().key()));
+    ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+        ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
+    for (BindingType type :
+        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      builder.append(INDENT);
+      builder.append(formatBindingType(type));
+      builder.append(" bindings:\n");
+      for (ContributionBinding binding : bindingsByType.get(type)) {
+        builder.append(INDENT).append(INDENT);
+        if (binding instanceof ProvisionBinding) {
+          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+        } else if (binding instanceof ProductionBinding) {
+          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
+        }
+        builder.append('\n');
+      }
+    }
+    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+  }
+
+  private String formatBindingType(BindingType type) {
+    switch(type) {
+      case MAP:
+        return "Map";
+      case SET:
+        return "Set";
+      case UNIQUE:
+        return "Unique";
+      default:
+        throw new IllegalStateException("Unknown binding type: " + type);
+    }
+  }
+
+  private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path,
+      final ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
+        .add(request)
+        .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
+        .build();
+    ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
+        .transform(dependencyRequestFormatter)
+        .filter(Predicates.not(Predicates.equalTo("")))
+        .toList()
+        .reverse();
+    DependencyRequest rootRequest = path.getLast().request();
+    TypeElement componentType =
+        MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+    // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
+    reportBuilder.addItem(
+        String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            componentType.getQualifiedName(),
+            rootRequest.requestElement().getSimpleName(),
+            Joiner.on("\n")
+                .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+        rootRequest.requestElement());
+  }
+
+  @AutoValue
+  abstract static class ResolvedRequest {
+    abstract DependencyRequest request();
+    abstract ResolvedBindings binding();
+
+    static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
+      BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+          resolvedBindings == null
+              ? ResolvedBindings.create(bindingKey,
+                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+              : resolvedBindings);
+    }
+  }
+
+  private static final Function<ResolvedRequest, DependencyRequest> REQUEST_FROM_RESOLVED_REQUEST =
+      new Function<ResolvedRequest, DependencyRequest>() {
+        @Override public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+          return resolvedRequest.request();
+        }
+      };
+
+  abstract static class Traverser {
+    abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
new file mode 100644
index 000000000..cd29d8d69
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+/**
+ * A value object that pairs a {@link Key} with the style of its binding (i.e., whether it's a
+ * members injector or normal contribution).
+ *
+ *  @author Gregory Kick
+ *  @since 2.0
+ */
+@AutoValue
+abstract class BindingKey {
+  /** The style of binding that makes a {@link Key} available. */
+  enum Kind {
+    CONTRIBUTION, MEMBERS_INJECTION;
+  }
+
+  static BindingKey create(Kind kind, Key key) {
+    return new AutoValue_BindingKey(kind, key);
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
new file mode 100644
index 000000000..3bb85e3f9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/** 
+ * Validates {@link dagger.Component.Builder} annotations.
+ * 
+ * @author sameb@google.com (Sam Berlin)  
+ */
+class BuilderValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+  private final ComponentDescriptor.Kind componentType;
+  
+  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = componentType;
+  }
+
+  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    Element componentElement = subject.getEnclosingElement();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
+    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    checkArgument(subject.getAnnotation(builderAnnotation) != null);
+    
+    if (!isAnnotationPresent(componentElement, componentAnnotation)) {
+      builder.addItem(msgs.mustBeInComponent(), subject);
+    }
+
+    switch (subject.getKind()) {
+      case CLASS:
+        List<? extends Element> allElements = subject.getEnclosedElements();
+        List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
+        if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
+          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
+        }
+        break;
+      case INTERFACE:
+        break;
+      default:
+        // If not the correct type, exit early since the rest of the messages will be bogus.
+        builder.addItem(msgs.mustBeClassOrInterface(), subject);
+        return builder.build(); 
+    }    
+
+    
+    if (!subject.getTypeParameters().isEmpty()) {
+      builder.addItem(msgs.generics(), subject);
+    }
+
+    Set<Modifier> modifiers = subject.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(msgs.isPrivate(), subject);
+    }
+    if (!modifiers.contains(STATIC)) {
+      builder.addItem(msgs.mustBeStatic(), subject);
+    }
+    // Note: Must be abstract, so no need to check for final.
+    if (!modifiers.contains(ABSTRACT)) {
+      builder.addItem(msgs.mustBeAbstract(), subject);
+    }
+    
+    ExecutableElement buildMethod = null;
+    Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
+        LinkedHashMultimap.create();    
+    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+      ExecutableType resolvedMethodType =
+          MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
+      TypeMirror returnType = resolvedMethodType.getReturnType();
+      if (method.getParameters().size() == 0) {
+        // If this is potentially a build() method, validate it returns the correct type.
+        if (types.isSameType(returnType, componentElement.asType())) {
+          if (buildMethod != null) {
+            // If we found more than one build-like method, fail.
+            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+                buildMethod);
+          }
+        } else {
+          error(builder, method, msgs.buildMustReturnComponentType(),
+              msgs.inheritedBuildMustReturnComponentType());
+        }
+        // We set the buildMethod regardless of the return type to reduce error spam.
+        buildMethod = method;
+      } else if (method.getParameters().size() > 1) {
+        // If this is a setter, make sure it has one arg.
+        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
+      } else if (returnType.getKind() != TypeKind.VOID
+          && !types.isSubtype(subject.asType(), returnType)) {
+        // If this correctly had one arg, make sure the return types are valid.
+        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),
+            msgs.inheritedMethodsMustReturnVoidOrBuilder());
+      } else {
+        // If the return types are valid, record the method.
+        methodsPerParam.put(
+            MoreTypes.equivalence().<TypeMirror>wrap(
+                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
+            method);
+      }
+      
+      if (!method.getTypeParameters().isEmpty()) {
+        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
+            msgs.inheritedMethodsMayNotHaveTypeParameters());
+      }
+    }
+    
+    if (buildMethod == null) {
+      builder.addItem(msgs.missingBuildMethod(), subject);
+    }
+    
+    // Go back through each recorded method per param type.  If we had more than one method
+    // for a given param, fail.
+    for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
+        methodsPerParam.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        TypeMirror type = entry.getKey().get();
+        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
+      }
+    }
+    
+    // Note: there's more validation in BindingGraphValidator,
+    // specifically to make sure the setter methods mirror the deps.
+
+    return builder.build();
+  }
+  
+  /**
+   * Generates one of two error messages. If the method is enclosed in the subject, we target the
+   * error to the method itself. Otherwise we target the error to the subject and list the method as
+   * an argumnent. (Otherwise we have no way of knowing if the method is being compiled in this pass
+   * too, so javac might not be able to pinpoint it's line of code.)
+   */
+  /*
+   * For Component.Builder, the prototypical example would be if someone had:
+   *    libfoo: interface SharedBuilder { void badSetter(A a, B b); }
+   *    libbar: BarComponent { BarBuilder extends SharedBuilder } }
+   * ... the compiler only validates BarBuilder when compiling libbar, but it fails because
+   * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
+   * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
+   * failure.
+   * 
+   * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
+   * class was included in this compile run.  But that's hard, and this is close enough.
+   */
+  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
+      String enclosedError, String inheritedError, Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addItem(String.format(enclosedError, extraArgs), method);
+    } else {
+      Object[] newArgs = new Object[extraArgs.length + 1];
+      newArgs[0] = method;
+      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
+      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
deleted file mode 100644
index d4ab7df1a..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Keys;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-/**
- * Support for annotation processors.
- */
-final class CodeGen {
-  private CodeGen() {
-  }
-
-  public static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns the supertype, or {@code null} if the supertype is a platform
-   * class. This is intended for annotation processors that assume platform
-   * classes will never be annotated with application annotations.
-   */
-  public static TypeMirror getApplicationSupertype(TypeElement type) {
-    TypeMirror supertype = type.getSuperclass();
-    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
-  }
-
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
-  }
-
-  /** Returns a string like {@code java.util.List<java.lang.String>}. */
-  public static String parameterizedType(Class<?> raw, String... parameters) {
-    StringBuilder result = new StringBuilder();
-    result.append(raw.getName());
-    result.append("<");
-    for (int i = 0; i < parameters.length; i++) {
-      if (i != 0) {
-        result.append(", ");
-      }
-      result.append(parameters[i]);
-    }
-    result.append(">");
-    return result.toString();
-  }
-
-  /** Returns a string for {@code type}. Primitive types are always boxed. */
-  public static String typeToString(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    typeToString(type, result, '.');
-    return result.toString();
-  }
-
-  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
-  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
-    if (!(type instanceof DeclaredType)) {
-      throw new IllegalArgumentException("Unexpected type: " + type);
-    }
-    StringBuilder result = new StringBuilder();
-    DeclaredType declaredType = (DeclaredType) type;
-    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
-    return result.toString();
-  }
-
-  /**
-   * Appends a string for {@code type} to {@code result}. Primitive types are
-   * always boxed.
-   *
-   * @param innerClassSeparator either '.' or '$', which will appear in a
-   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
-   *     Use '.' for references to existing types in code. Use '$' to define new
-   *     class names and for strings that will be used by runtime reflection.
-   */
-  public static void typeToString(final TypeMirror type, final StringBuilder result,
-      final char innerClassSeparator) {
-    type.accept(new SimpleTypeVisitor6<Void, Void>() {
-      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
-        TypeElement typeElement = (TypeElement) declaredType.asElement();
-        rawTypeToString(result, typeElement, innerClassSeparator);
-        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-        if (!typeArguments.isEmpty()) {
-          result.append("<");
-          for (int i = 0; i < typeArguments.size(); i++) {
-            if (i != 0) {
-              result.append(", ");
-            }
-            typeToString(typeArguments.get(i), result, innerClassSeparator);
-          }
-          result.append(">");
-        }
-        return null;
-      }
-      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
-        return null;
-      }
-      @Override public Void visitArray(ArrayType arrayType, Void v) {
-        typeToString(arrayType.getComponentType(), result, innerClassSeparator);
-        result.append("[]");
-        return null;
-      }
-      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
-        result.append(typeVariable); // TypeVariable.toString() returns the name, like 'T'.
-        return null;
-      }
-      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
-        throw new UnsupportedOperationException(
-            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
-      }
-    }, null);
-  }
-
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR
-      = new SimpleAnnotationValueVisitor6<Object, Void>() {
-    @Override protected Object defaultAction(Object o, Void v) {
-      return o;
-    }
-    @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-      Object[] result = new Object[values.size()];
-      for (int i = 0; i < values.size(); i++) {
-        result[i] = values.get(i).accept(this, null);
-      }
-      return result;
-    }
-  };
-
-  /**
-   * Returns the annotation on {@code element} formatted as a Map. This returns
-   * a Map rather than an instance of the annotation interface to work-around
-   * the fact that Class and Class[] fields won't work at code generation time.
-   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
-   */
-  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!annotation.getAnnotationType().toString().equals(annotationType.getName())) {
-        continue;
-      }
-
-      Map<String, Object> result = new LinkedHashMap<String, Object>();
-      for (Method m : annotationType.getMethods()) {
-        result.put(m.getName(), m.getDefaultValue());
-      }
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
-          : annotation.getElementValues().entrySet()) {
-        String name = e.getKey().getSimpleName().toString();
-        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
-        Object defaultValue = result.get(name);
-        if (!lenientIsInstance(defaultValue.getClass(), value)) {
-          throw new IllegalStateException(String.format(
-              "Value of %s.%s is a %s but expected a %s\n    value: %s",
-              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
-              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
-        }
-        result.put(name, value);
-      }
-      return result;
-    }
-
-    return null; // Annotation not found.
-  }
-
-  /**
-   * Returns true if {@code value} can be assigned to {@code expectedClass}.
-   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
-   */
-  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
-    if (expectedClass.isArray()) {
-      Class<?> componentType = expectedClass.getComponentType();
-      if (!(value instanceof Object[])) {
-        return false;
-      }
-      for (Object element : (Object[]) value) {
-        if (!lenientIsInstance(componentType, element)) return false;
-      }
-      return true;
-    } else if (expectedClass == Class.class) {
-      return value instanceof TypeMirror;
-    } else {
-      return expectedClass == value.getClass();
-    }
-  }
-
-  static void rawTypeToString(StringBuilder result, TypeElement type,
-      char innerClassSeparator) {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String qualifiedName = type.getQualifiedName().toString();
-    if (packageName.isEmpty()) {
-        result.append(qualifiedName.replace('.', innerClassSeparator));
-    } else {
-      result.append(packageName);
-      result.append('.');
-      result.append(
-          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
-    }
-  }
-
-  private static Class<?> box(PrimitiveType primitiveType) {
-    switch (primitiveType.getKind()) {
-      case BYTE:
-        return Byte.class;
-      case SHORT:
-        return Short.class;
-      case INT:
-        return Integer.class;
-      case LONG:
-        return Long.class;
-      case FLOAT:
-        return Float.class;
-      case DOUBLE:
-        return Double.class;
-      case BOOLEAN:
-        return Boolean.class;
-      case CHAR:
-        return Character.class;
-      case VOID:
-        return Void.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the no-args constructor for {@code type}, or null if no such
-   * constructor exists.
-   */
-  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
-    for (Element enclosed : type.getEnclosedElements()) {
-      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) enclosed;
-      if (constructor.getParameters().isEmpty()) {
-        return constructor;
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns true if generated code can invoke {@code constructor}. That is, if
-   * the constructor is non-private and its enclosing class is either a
-   * top-level class or a static nested class.
-   */
-  public static boolean isCallableConstructor(ExecutableElement constructor) {
-    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-      return false;
-    }
-    TypeElement type = (TypeElement) constructor.getEnclosingElement();
-    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
-        || type.getModifiers().contains(Modifier.STATIC);
-  }
-
-  /**
-   * Returns a set comprised of the given items
-   */
-  public static <T> Set<T> setOf(T ... items) {
-    Set<T> set = new LinkedHashSet<T>();
-    set.addAll(Arrays.asList(items));
-    return set;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
deleted file mode 100644
index 61e0f4afe..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
-import dagger.internal.StaticInjection;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@code Binding.Resolver} suitable for tool use at build time. The bindings created by
- * this {@code Binding.Resolver} have the correct dependency graph, but do not implement
- * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
- * for graph analysis and error detection.
- */
-public final class CompileTimePlugin implements Plugin {
-
-  private final ProcessingEnvironment processingEnv;
-
-  public CompileTimePlugin(ProcessingEnvironment processingEnv) {
-    this.processingEnv = processingEnv;
-  }
-
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
-    String sourceClassName = className.replace('$', '.');
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
-    if (type == null) {
-      // We've encountered a type that the compiler can't introspect. If this
-      // causes problems in practice (due to incremental compiles, etc.) we
-      // should return a new unresolved binding and warn about the possibility
-      // of runtime failures.
-      return null;
-    }
-    if (type.getKind() == ElementKind.INTERFACE) {
-      return null;
-    }
-    return AtInjectBinding.create(type, mustBeInjectable);
-  }
-
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
new file mode 100644
index 000000000..6c514f99c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * The logical representation of a {@link Component} or {@link ProductionComponent} definition.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ComponentDescriptor {
+  ComponentDescriptor() {}
+
+  enum Kind {
+    COMPONENT(Component.class, Component.Builder.class),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
+    PRODUCTION_COMPONENT(ProductionComponent.class, null);
+
+    private final Class<? extends Annotation> annotationType;
+    private final Class<? extends Annotation> builderType;
+
+    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
+      this.annotationType = annotationType;
+      this.builderType = builderType;
+    }
+
+    Class<? extends Annotation> annotationType() {
+      return annotationType;
+    }
+    
+    Class<? extends Annotation> builderAnnotationType() {
+      return builderType;
+    }
+  }
+
+  abstract Kind kind();
+
+  abstract AnnotationMirror componentAnnotation();
+
+  /**
+   * The type (interface or abstract class) that defines the component. This is the element to which
+   * the {@link Component} annotation was applied.
+   */
+  abstract TypeElement componentDefinitionType();
+
+  /**
+   * The set of component dependencies listed in {@link Component#dependencies}.
+   */
+  abstract ImmutableSet<TypeElement> dependencies();
+
+  /**
+   * An index of the type to which this component holds a reference (the type listed in
+   * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the
+   * enclosing type) for each method from a component dependency that can be used for binding.
+   */
+  abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
+
+  /**
+   * The element representing {@link Executor}, if it should be a dependency of this component.
+   */
+  abstract Optional<TypeElement> executorDependency();
+
+  /**
+   * An optional annotation constraining the scope of this component.
+   */
+  Optional<AnnotationMirror> scope() {
+    return unwrapOptionalEquivalence(wrappedScope());
+  }
+
+  /**
+   * An optional annotation constraining the scope of this component wrapped in an
+   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
+   * {@link AnnotationMirror}.
+   */
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
+
+  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+
+  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
+
+  // TODO(gak): Consider making this non-optional and revising the
+  // interaction between the spec & generation
+  abstract Optional<BuilderSpec> builderSpec();
+
+  @AutoValue
+  static abstract class ComponentMethodDescriptor {
+    abstract ComponentMethodKind kind();
+    abstract Optional<DependencyRequest> dependencyRequest();
+    abstract ExecutableElement methodElement();
+  }
+
+  enum ComponentMethodKind {
+    PROVISON,
+    PRODUCTION,
+    MEMBERS_INJECTION,
+    SUBCOMPONENT,
+    SUBCOMPONENT_BUILDER,
+  }
+  
+  @AutoValue
+  static abstract class BuilderSpec {    
+    abstract TypeElement builderDefinitionType();
+    abstract Map<TypeElement, ExecutableElement> methodMap();
+    abstract ExecutableElement buildMethod();
+    abstract TypeMirror componentType();
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
+      return create(componentDefinitionType, Kind.COMPONENT);
+    }
+
+    ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType) {
+      return create(componentDefinitionType, Kind.PRODUCTION_COMPONENT);
+    }
+
+    private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
+      DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
+      AnnotationMirror componentMirror =
+          getAnnotationMirror(componentDefinitionType, kind.annotationType())
+              .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
+              .get();
+      ImmutableSet<TypeElement> componentDependencyTypes =
+          isComponent(componentDefinitionType)
+              ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
+              : ImmutableSet.<TypeElement>of();
+
+      ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
+          ImmutableMap.builder();
+
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement dependencyMethod : dependencyMethods) {
+          if (isComponentContributionMethod(elements, dependencyMethod)) {
+            dependencyMethodIndex.put(dependencyMethod, componentDependency);
+          }
+        }
+      }
+
+      Optional<TypeElement> executorDependency =
+          kind.equals(Kind.PRODUCTION_COMPONENT)
+              ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
+              : Optional.<TypeElement>absent();
+
+      ImmutableSet<ExecutableElement> unimplementedMethods =
+          Util.getUnimplementedMethods(elements, componentDefinitionType);
+
+      ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
+          ImmutableSet.builder();
+
+      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+          ImmutableMap.builder();
+      for (ExecutableElement componentMethod : unimplementedMethods) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
+        ComponentMethodDescriptor componentMethodDescriptor =
+            getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
+        componentMethodsBuilder.add(componentMethodDescriptor);
+        switch (componentMethodDescriptor.kind()) {
+          case SUBCOMPONENT:
+            subcomponentDescriptors.put(componentMethod,
+                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+                    Kind.SUBCOMPONENT));
+            break;
+          case SUBCOMPONENT_BUILDER:
+            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
+                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+                    Kind.SUBCOMPONENT));
+            break;
+          default: // nothing special to do for other methods.
+        }
+        
+      }
+      
+      ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
+          ? ImmutableList.<DeclaredType>of()
+          : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
+      Optional<DeclaredType> builderType =
+          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));        
+
+      Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
+      return new AutoValue_ComponentDescriptor(
+          kind,
+          componentMirror,
+          componentDefinitionType,
+          componentDependencyTypes,
+          dependencyMethodIndex.build(),
+          executorDependency,
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          subcomponentDescriptors.build(),
+          componentMethodsBuilder.build(),
+          createBuilderSpec(builderType));
+    }
+
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
+        Kind componentKind,
+        ExecutableElement componentMethod) {
+      ExecutableType resolvedComponentMethod = MoreTypes.asExecutable(types.asMemberOf(
+          MoreTypes.asDeclared(componentElement.asType()), componentMethod));
+      TypeMirror returnType = resolvedComponentMethod.getReturnType();
+      if (returnType.getKind().equals(DECLARED)) {
+        if (MoreTypes.isTypeOf(Provider.class, returnType)
+            || MoreTypes.isTypeOf(Lazy.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.PROVISON,
+              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                  resolvedComponentMethod)),
+              componentMethod);
+        } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.MEMBERS_INJECTION,
+              Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                  componentMethod,
+                  resolvedComponentMethod)),
+              componentMethod);
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType),
+            Subcomponent.Builder.class)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT_BUILDER,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
+        }
+      }
+
+      // a typical provision method
+      if (componentMethod.getParameters().isEmpty()
+          && !componentMethod.getReturnType().getKind().equals(VOID)) {
+        switch (componentKind) {
+          case COMPONENT:
+          case SUBCOMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PROVISON,
+                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                    resolvedComponentMethod)),
+                componentMethod);
+          case PRODUCTION_COMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PRODUCTION,
+                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod,
+                    resolvedComponentMethod)),
+                componentMethod);
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      List<? extends TypeMirror> parameterTypes = resolvedComponentMethod.getParameterTypes();
+      if (parameterTypes.size() == 1
+          && (returnType.getKind().equals(VOID)
+              || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
+        return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+            ComponentMethodKind.MEMBERS_INJECTION,
+            Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod,
+                resolvedComponentMethod)),
+            componentMethod);
+      }
+
+      throw new IllegalArgumentException("not a valid component method: " + componentMethod);
+    }
+
+    private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
+      if (!builderType.isPresent()) {
+        return Optional.absent();
+      }
+      TypeElement element = MoreTypes.asTypeElement(builderType.get());
+      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
+      ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
+      ExecutableElement buildMethod = null;
+      for (ExecutableElement method : methods) {
+        if (method.getParameters().isEmpty()) {
+          buildMethod = method;
+        } else {
+          ExecutableType resolved =
+              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
+          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);
+        }
+      }
+      verify(buildMethod != null); // validation should have ensured this.
+      return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
+          map.build(), buildMethod, element.getEnclosingElement().asType()));
+    }
+  }
+
+  static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
+    return method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID)
+        && !elements.getTypeElement(Object.class.getCanonicalName())
+            .equals(method.getEnclosingElement());
+  }
+
+  static boolean isComponentProductionMethod(Elements elements, ExecutableElement method) {
+    return isComponentContributionMethod(elements, method)
+        && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
new file mode 100644
index 000000000..3886ba1d8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -0,0 +1,1506 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.MembersInjector;
+import dagger.internal.Factory;
+import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.ScopedProvider;
+import dagger.internal.SetFactory;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeWriter;
+import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetProducer;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.Binding.bindingPackageFor;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * Generates the implementation of the abstract types annotated with {@link Component}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
+  private final Types types;
+  private final Diagnostic.Kind nullableValidationType;
+
+  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
+    super(filer);
+    this.types = types;
+    this.nullableValidationType = nullableValidationType;
+  }
+
+  @Override
+  ClassName nameGeneratedType(BindingGraph input) {
+    ClassName componentDefinitionClassName =
+        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
+    String componentName =
+        "Dagger" + componentDefinitionClassName.classFileName().replace('$', '_');
+    return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(BindingGraph input) {
+    return ImmutableSet.of(input.componentDescriptor().componentDefinitionType());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+    return Optional.of(input.componentDescriptor().componentDefinitionType());
+  }
+
+  @AutoValue
+  static abstract class ProxyClassAndField {
+    abstract ClassWriter proxyWriter();
+    abstract FieldWriter proxyFieldWriter();
+
+    static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyFieldWriter) {
+      return new AutoValue_ComponentGenerator_ProxyClassAndField(proxyWriter, proxyFieldWriter);
+    }
+  }
+
+  @AutoValue static abstract class MemberSelect {
+    static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, false, snippet);
+    }
+
+    static MemberSelect staticSelect(ClassName owningClass, Snippet snippet) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, true, snippet);
+    }
+
+    static MemberSelect staticMethodInvocationWithCast(
+        ClassName owningClass, Snippet snippet, TypeName castType) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.of(castType), owningClass, true, snippet);
+    }
+
+    /**
+     * This exists only to facilitate edge cases in which we need to select a member, but that
+     * member uses a type parameter that can't be inferred.
+     */
+    abstract Optional<TypeName> selectedCast();
+    abstract ClassName owningClass();
+    abstract boolean staticMember();
+    abstract Snippet snippet();
+
+    private Snippet qualifiedSelectSnippet() {
+      return Snippet.format(
+          "%s" + (staticMember() ? "" : ".this") + ".%s",
+          owningClass(), snippet());
+    }
+
+    Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
+      Snippet snippet = getSnippetFor(usingClass);
+      return selectedCast().isPresent()
+          ? Snippet.format("(%s) %s", selectedCast().get(), snippet)
+          : snippet;
+    }
+
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? snippet()
+          : qualifiedSelectSnippet();
+    }
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
+    TypeElement componentDefinitionType = input.componentDescriptor().componentDefinitionType();
+    ClassName componentDefinitionTypeName =
+        ClassName.fromTypeElement(componentDefinitionType);
+
+    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
+
+    ClassWriter componentWriter = writer.addClass(componentName.simpleName());
+    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
+    componentWriter.addModifiers(PUBLIC, FINAL);
+    switch (componentDefinitionType.getKind()) {
+      case CLASS:
+        checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
+        componentWriter.setSuperType(componentDefinitionTypeName);
+        break;
+      case INTERFACE:
+        componentWriter.addImplementedType(componentDefinitionTypeName);
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+
+    Set<JavaWriter> javaWriters = Sets.newHashSet();
+    javaWriters.add(writer);
+    writeComponent(input, componentDefinitionTypeName, componentWriter, javaWriters);
+
+    return ImmutableSet.copyOf(javaWriters);
+  }
+
+  /**
+   * Writes out a builder for a component or subcomponent.
+   *
+   * @param input the component or subcomponent
+   * @param componentApiName the API name of the component we're building (not our impl)
+   * @param componentImplName the implementation name of the component we're building
+   * @param componentWriter the class we're adding this builder to
+   * @param componentContributionFields a map of member selects so we can later use the fields
+   */
+  private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
+      ClassName componentImplName, ClassWriter componentWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields) {
+    ClassWriter builderWriter;
+    Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
+    switch (input.componentDescriptor().kind()) {
+      case COMPONENT:
+      case PRODUCTION_COMPONENT:
+        builderWriter = componentWriter.addNestedClass("Builder");
+        builderWriter.addModifiers(STATIC);
+
+        // Only top-level components have the factory builder() method.
+        // Mirror the user's builder API type if they had one.
+        MethodWriter builderFactoryMethod = builderSpec.isPresent()
+            ? componentWriter.addMethod(
+                builderSpec.get().builderDefinitionType().asType(), "builder")
+            : componentWriter.addMethod(builderWriter, "builder");
+        builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+        builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+        break;
+      case SUBCOMPONENT:
+        verify(builderSpec.isPresent()); // we only write subcomponent builders if there was a spec
+        builderWriter =
+            componentWriter.addNestedClass(componentApiName.simpleName() + "Builder");
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+    builderWriter.addModifiers(FINAL);
+    builderWriter.addConstructor().addModifiers(PRIVATE);
+    if (builderSpec.isPresent()) {
+      builderWriter.addModifiers(PRIVATE);
+      TypeElement builderType = builderSpec.get().builderDefinitionType();
+      switch (builderType.getKind()) {
+        case CLASS:
+          builderWriter.setSuperType(builderType);
+          break;
+        case INTERFACE:
+          builderWriter.addImplementedType(builderType);
+          break;
+        default:
+          throw new IllegalStateException("not a class or interface: " + builderType);
+      }
+    } else {
+      builderWriter.addModifiers(PUBLIC);
+    }
+
+    // the full set of types that calling code uses to construct a component instance
+    ImmutableMap<TypeElement, String> componentContributionNames =
+        ImmutableMap.copyOf(Maps.asMap(
+            Sets.union(
+                Sets.union(
+                    input.transitiveModules().keySet(),
+                    input.componentDescriptor().dependencies()),
+                input.componentDescriptor().executorDependency().asSet()),
+            Functions.compose(
+                CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
+                new Function<TypeElement, String>() {
+                  @Override public String apply(TypeElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })));
+
+    MethodWriter buildMethod;
+    if (builderSpec.isPresent()) {
+      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+      // Note: we don't use the specBuildMethod.getReturnType() as the return type
+      // because it might be a type variable.  We make use of covariant returns to allow
+      // us to return the component type, which will always be valid.
+      buildMethod = builderWriter.addMethod(componentApiName,
+          specBuildMethod.getSimpleName().toString());
+      buildMethod.annotate(Override.class);
+    } else {
+      buildMethod = builderWriter.addMethod(componentApiName, "build");
+    }
+    buildMethod.addModifiers(PUBLIC);
+
+    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
+      TypeElement contributionElement = entry.getKey();
+      String contributionName = entry.getValue();
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
+      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
+          componentImplName, Snippet.format("builder.%s", builderField.name())));
+      if (componentCanMakeNewInstances(contributionElement)) {
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", builderField.name())
+            .addSnippet("  this.%s = new %s();",
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
+            .addSnippet("}");
+      } else {
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", builderField.name())
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
+            .addSnippet("}");
+      }
+      MethodWriter builderMethod;
+      boolean returnsVoid = false;
+      if (builderSpec.isPresent()) {
+        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
+        if (method == null) { // no method in the API, nothing to write out.
+          continue;
+        }
+        // If the return type is void, we add a method with the void return type.
+        // Otherwise we use the builderWriter and take advantage of covariant returns
+        // (so that we don't have to worry about setter methods that return type variables).
+        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
+          returnsVoid = true;
+          builderMethod =
+              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
+        } else {
+          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
+        }
+        builderMethod.annotate(Override.class);
+      } else {
+        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
+      }
+      // TODO(gak): Mirror the API's visibility.
+      // (Makes no difference to the user since this class is private,
+      //  but makes generated code prettier.)
+      builderMethod.addModifiers(PUBLIC);
+      builderMethod.addParameter(contributionElement, contributionName);
+      builderMethod.body()
+          .addSnippet("if (%s == null) {", contributionName)
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(contributionName))
+          .addSnippet("}")
+          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
+      if (!returnsVoid) {
+        builderMethod.body().addSnippet("return this;");
+      }
+    }
+    buildMethod.body().addSnippet("return new %s(this);", componentImplName);
+    return builderWriter;
+  }
+
+  /** Returns true if the graph has any dependents that can't be automatically constructed. */
+  private boolean requiresUserSuppliedDependents(BindingGraph input) {
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
+            input.componentDescriptor().executorDependency().asSet());
+    Set<TypeElement> userRequiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    return !userRequiredDependents.isEmpty();
+  }
+
+  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
+      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters) {
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+    ClassWriter builderWriter = writeBuilder(input, componentDefinitionTypeName,
+        componentWriter.name(), componentWriter, componentContributionFields);
+    if (!requiresUserSuppliedDependents(input)) {
+      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod.body().addSnippet("return builder().%s();",
+          input.componentDescriptor().builderSpec().isPresent()
+              ? input.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
+              : "build");
+    }
+
+    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
+
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
+
+    writeFields(input,
+        componentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+    initializeFrameworkTypes(input,
+        componentWriter,
+        constructorWriter,
+        Optional.of(builderWriter.name()),
+        componentContributionFields,
+        memberSelectSnippets,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
+      writeSubcomponent(componentWriter,
+          MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
+          proxyWriters,
+          memberSelectSnippets,
+          multibindingContributionSnippets,
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
+
+    return memberSelectSnippets;
+  }
+
+  private void writeSubcomponent(ClassWriter componentWriter,
+      DeclaredType containingComponent,
+      Set<JavaWriter> proxyWriters,
+      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph) {
+    ClassName subcomponentApiName =
+        ClassName.fromTypeElement(subgraph.componentDescriptor().componentDefinitionType());
+    ClassWriter subcomponentWriter =
+        componentWriter.addNestedClass(subcomponentApiName.simpleName() + "Impl");
+    subcomponentWriter.addModifiers(PRIVATE, FINAL);
+
+    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.body();
+
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+
+    TypeMirror subcomponentType;
+    MethodWriter componentMethod;
+    Optional<ClassName> builderName;
+    if (subgraph.componentDescriptor().builderSpec().isPresent()) {
+      BuilderSpec spec = subgraph.componentDescriptor().builderSpec().get();
+      subcomponentType = spec.componentType();
+      componentMethod = componentWriter.addMethod(
+          ClassName.fromTypeElement(spec.builderDefinitionType()),
+          subcomponentFactoryMethod.getSimpleName().toString());
+      ClassWriter builderWriter = writeBuilder(subgraph, subcomponentApiName,
+          subcomponentWriter.name(), componentWriter, componentContributionFields);
+      builderName = Optional.of(builderWriter.name());
+      constructorWriter.addParameter(builderWriter, "builder");
+      constructorWriter.body().addSnippet("assert builder != null;");
+      componentMethod.body().addSnippet("return new %s();", builderWriter.name());
+    } else {
+      builderName = Optional.absent();
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(containingComponent, subcomponentFactoryMethod));
+      subcomponentType = resolvedMethod.getReturnType();
+      componentMethod = componentWriter.addMethod(subcomponentType,
+          subcomponentFactoryMethod.getSimpleName().toString());
+      writeSubcomponentWithoutBuilder(subcomponentFactoryMethod,
+          subgraph,
+          subcomponentWriter,
+          constructorWriter,
+          componentContributionFields,
+          subcomponentConstructorParameters,
+          componentMethod,
+          resolvedMethod);
+    }
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
+
+    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
+    Element subcomponentElement = MoreTypes.asElement(subcomponentType);
+    switch (subcomponentElement.getKind()) {
+      case CLASS:
+        checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
+        subcomponentWriter.setSuperType(subcomponentTypeName);
+        break;
+      case INTERFACE:
+        subcomponentWriter.addImplementedType(subcomponentTypeName);
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+
+    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
+
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
+
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
+
+    writeFields(subgraph,
+        subcomponentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    for (Entry<BindingKey, MemberSelect> parentBindingEntry :
+        parentMemberSelectSnippets.entrySet()) {
+      if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
+        memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
+      }
+    }
+
+    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    initializeFrameworkTypes(subgraph,
+        subcomponentWriter,
+        constructorWriter,
+        builderName,
+        componentContributionFields,
+        memberSelectSnippets,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(subgraph, subcomponentWriter, memberSelectSnippets, enumBindingKeys);
+
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
+      writeSubcomponent(subcomponentWriter,
+          MoreTypes.asDeclared(subgraph.componentDescriptor().componentDefinitionType().asType()),
+          proxyWriters,
+          memberSelectSnippets,
+          new ImmutableMap.Builder<ContributionBinding, Snippet>()
+              .putAll(parentMultibindingContributionSnippets)
+              .putAll(multibindingContributionSnippets)
+              .build(),
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
+  }
+
+  private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph,
+      ClassWriter subcomponentWriter,
+      ConstructorWriter constructorWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableList.Builder<Snippet> subcomponentConstructorParameters,
+      MethodWriter componentMethod,
+      ExecutableType resolvedMethod) {
+    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
+    for (int i = 0; i < params.size(); i++) {
+      VariableElement moduleVariable = params.get(i);
+      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      verify(subgraph.transitiveModules().containsKey(moduleTypeElement));
+      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+            moduleTypeElement.getSimpleName().toString());
+        FieldWriter contributionField =
+            subcomponentWriter.addField(moduleTypeElement, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(moduleType, actualModuleName);
+        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "if (%s == null) {",
+            "  throw new NullPointerException();",
+            "}"), actualModuleName));
+        constructorWriter.body().addSnippet(
+            Snippet.format("this.%1$s = %1$s;", actualModuleName));
+        MemberSelect moduleSelect = MemberSelect.instanceSelect(
+            subcomponentWriter.name(), Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        subcomponentConstructorParameters.add(
+            Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
+
+    SetView<TypeElement> uninitializedModules = Sets.difference(
+        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+          moduleType.getSimpleName().toString());
+      FieldWriter contributionField =
+          subcomponentWriter.addField(moduleType, preferredModuleName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet(
+          Snippet.format("this.%s = new %s();", actualModuleName,
+              ClassName.fromTypeElement(moduleType)));
+      MemberSelect moduleSelect = MemberSelect.instanceSelect(
+          subcomponentWriter.name(), Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
+    }
+
+    componentMethod.body().addSnippet("return new %s(%s);",
+        subcomponentWriter.name(),
+        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+  }
+
+  private void writeFields(BindingGraph input,
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies) {
+    for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
+      writeField(
+          componentWriter,
+          proxyWriters,
+          memberSelectSnippetsBuilder,
+          parentMultibindingContributionSnippetsBuilder,
+          multibindingContributionSnippetsBuilder,
+          enumBindingKeysBuilder,
+          packageProxies,
+          resolvedBindings);
+    }
+  }
+
+  private void writeField(
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.ownedContributionBindings().isEmpty()
+        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
+            .isMultibinding()) {
+      return;
+    }
+
+    if (resolvedBindings.bindings().size() == 1) {
+      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding =
+            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+        if (!contributionBinding.bindingType().isMultibinding()
+            && (contributionBinding instanceof ProvisionBinding)) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+              && !provisionBinding.scope().isPresent()) {
+            enumBindingKeysBuilder.add(bindingKey);
+            // skip keys whose factories are enum instances and aren't scoped
+            memberSelectSnippetsBuilder.put(bindingKey,
+                MemberSelect.staticSelect(
+                    factoryNameForProvisionBinding(provisionBinding),
+                    Snippet.format("create()")));
+            return;
+          }
+        }
+      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
+        MembersInjectionBinding membersInjectionBinding =
+            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
+        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
+          // TODO(gak): refactor to use enumBindingKeys throughout the generator
+          enumBindingKeysBuilder.add(bindingKey);
+          // TODO(gak): suppress the warnings in a reasonable place
+          memberSelectSnippetsBuilder.put(bindingKey,
+              MemberSelect.staticMethodInvocationWithCast(
+                  ClassName.fromClass(MembersInjectors.class),
+                  Snippet.format("noOp()"),
+                  ClassName.fromClass(MembersInjector.class)));
+          return;
+        }
+      }
+    }
+
+    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
+        .or(componentWriter.name().packageName());
+
+    final Optional<String> proxySelector;
+    final TypeWriter classWithFields;
+    final Set<Modifier> fieldModifiers;
+
+    if (bindingPackage.equals(componentWriter.name().packageName())) {
+      // no proxy
+      proxySelector = Optional.absent();
+      // component gets the fields
+      classWithFields = componentWriter;
+      // private fields
+      fieldModifiers = EnumSet.of(PRIVATE);
+    } else {
+      // get or create the proxy
+      ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
+      if (proxyClassAndField == null) {
+        JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
+        proxyWriters.add(proxyJavaWriter);
+        ClassWriter proxyWriter =
+            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "_PackageProxy");
+        proxyWriter.annotate(Generated.class)
+            .setValue(ComponentProcessor.class.getCanonicalName());
+        proxyWriter.addModifiers(PUBLIC, FINAL);
+        // create the field for the proxy in the component
+        FieldWriter proxyFieldWriter =
+            componentWriter.addField(proxyWriter.name(),
+                bindingPackage.replace('.', '_') + "_Proxy");
+        proxyFieldWriter.addModifiers(PRIVATE, FINAL);
+        proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
+        proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
+        packageProxies.put(bindingPackage, proxyClassAndField);
+      }
+      // add the field for the member select
+      proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
+      // proxy gets the fields
+      classWithFields = proxyClassAndField.proxyWriter();
+      // public fields in the proxy
+      fieldModifiers = EnumSet.of(PUBLIC);
+    }
+
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ImmutableSet<? extends ContributionBinding> contributionBindings =
+          resolvedBindings.contributionBindings();
+      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+        // note that here we rely on the order of the resolved bindings being from parent to child
+        // otherwise, the numbering wouldn't work
+        int contributionNumber = 0;
+        for (ContributionBinding contributionBinding : contributionBindings) {
+          if (!contributionBinding.isSyntheticBinding()) {
+            contributionNumber++;
+            if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+              FrameworkField contributionBindingField =
+                  frameworkFieldForSyntheticContributionBinding(
+                        bindingKey, contributionNumber, contributionBinding);
+              FieldWriter contributionField = classWithFields.addField(
+                  contributionBindingField.frameworkType(), contributionBindingField.name());
+              contributionField.addModifiers(fieldModifiers);
+
+              ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
+                  .addAll(proxySelector.asSet())
+                  .add(contributionField.name())
+                  .build();
+              multibindingContributionSnippetsBuilder.put(contributionBinding,
+                  Snippet.memberSelectSnippet(contributionSelectTokens));
+            }
+          }
+        }
+      }
+    }
+
+    FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
+    FieldWriter frameworkField =
+        classWithFields.addField(bindingField.frameworkType(), bindingField.name());
+    frameworkField.addModifiers(fieldModifiers);
+
+    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+        .addAll(proxySelector.asSet())
+        .add(frameworkField.name())
+        .build();
+    memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
+        componentWriter.name(),
+        Snippet.memberSelectSnippet(memberSelectTokens)));
+  }
+
+  private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
+      ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+
+    for (ComponentMethodDescriptor componentMethod :
+        input.componentDescriptor().componentMethods()) {
+      if (componentMethod.dependencyRequest().isPresent()) {
+        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+        ExecutableElement requestElement =
+            MoreElements.asExecutable(interfaceRequest.requestElement());
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
+            requestElement));
+        MethodSignature signature = MethodSignature.fromExecutableType(
+            requestElement.getSimpleName().toString(),
+            requestType);
+        if (!interfaceMethods.contains(signature)) {
+          interfaceMethods.add(signature);
+          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
+              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(requestType.getReturnType(),
+                      requestElement.getSimpleName().toString());
+          interfaceMethod.annotate(Override.class);
+          interfaceMethod.addModifiers(PUBLIC);
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          switch(interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.body().addSnippet("return %s;",
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()));
+              } else {
+                VariableElement parameter = Iterables.getOnlyElement(parameters);
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(
+                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod.body().addSnippet("%s.injectMembers(%s);",
+                    // in this case we know we won't need the cast because we're never going to pass
+                    // the reference to anything
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()),
+                    parameterName);
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+              }
+              break;
+            case INSTANCE:
+              if (enumBindingKeys.contains(bindingKey)
+                  && (bindingKey.key().type().getKind().equals(DECLARED)
+                      && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty())) {
+                // If using a parameterized enum type, then we need to store the factory
+                // in a temporary variable, in order to help javac be able to infer
+                // the generics of the Factory.create methods.
+                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                    TypeNames.forTypeMirror(requestType.getReturnType()));
+                interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
+                interfaceMethod.body().addSnippet("return factory.get();");
+                break;
+              }
+              // fall through in the else case.
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case FUTURE:
+              interfaceMethod.body().addSnippet("return %s;",
+                  frameworkTypeUsageStatement(
+                      memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
+                      interfaceRequest.kind()));
+              break;
+            default:
+              throw new AssertionError();
+          }
+        }
+      }
+    }
+  }
+
+  private void initializeFrameworkTypes(BindingGraph input,
+      ClassWriter componentWriter,
+      ConstructorWriter constructorWriter,
+      Optional<ClassName> builderName,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
+      throws AssertionError {
+    List<List<BindingKey>> partitions = Lists.partition(
+        input.resolvedBindings().keySet().asList(), 100);
+    for (int i = 0; i < partitions.size(); i++) {
+      MethodWriter initializeMethod =
+          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
+      initializeMethod.body();
+      initializeMethod.addModifiers(PRIVATE);
+      if (builderName.isPresent()) {
+        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
+        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
+      } else {
+        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
+      }
+
+      for (BindingKey bindingKey : partitions.get(i)) {
+        Snippet memberSelectSnippet =
+            memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
+        ResolvedBindings resolvedBindings = input.resolvedBindings().get(bindingKey);
+        switch (bindingKey.kind()) {
+          case CONTRIBUTION:
+            ImmutableSet<? extends ContributionBinding> bindings =
+                resolvedBindings.contributionBindings();
+
+            switch (ContributionBinding.bindingTypeFor(bindings)) {
+              case SET:
+                boolean hasOnlyProvisions =
+                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
+                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+                for (ContributionBinding binding : bindings) {
+                  if (multibindingContributionSnippets.containsKey(binding)) {
+                    Snippet initializeSnippet = initializeFactoryForContributionBinding(
+                        binding,
+                        input,
+                        componentWriter.name(),
+                        componentContributionFields,
+                        memberSelectSnippets);
+                    Snippet snippet = multibindingContributionSnippets.get(binding);
+                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+                    parameterSnippets.add(snippet);
+                  } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
+                    parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
+                  } else {
+                    throw new IllegalStateException(binding + " was not found in");
+                  }
+                }
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    hasOnlyProvisions
+                        ? ClassName.fromClass(SetFactory.class)
+                        : ClassName.fromClass(SetProducer.class),
+                    Snippet.makeParametersSnippet(parameterSnippets.build()));
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet, initializeSetSnippet);
+                break;
+              case MAP:
+                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
+                    .isEmpty()) {
+                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
+                  ImmutableSet<ProvisionBinding> provisionBindings =
+                      (ImmutableSet<ProvisionBinding>) bindings;
+                  for (ProvisionBinding provisionBinding : provisionBindings) {
+                    if (!isNonProviderMap(provisionBinding)
+                        && multibindingContributionSnippets.containsKey(provisionBinding)) {
+                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          snippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              componentWriter.name(),
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields,
+                              memberSelectSnippets));
+                    }
+                  }
+                  if (!provisionBindings.isEmpty()) {
+                    Snippet initializeMapSnippet = initializeMapBinding(
+                        componentWriter.name(), memberSelectSnippets,
+                        new ImmutableMap.Builder<ContributionBinding, Snippet>()
+                            .putAll(parentMultibindingContributionSnippets)
+                            .putAll(multibindingContributionSnippets)
+                            .build(),
+                        provisionBindings);
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet, initializeMapSnippet);
+                  }
+                } else {
+                  // TODO(user): Implement producer map bindings.
+                  throw new IllegalStateException("producer map bindings not implemented yet");
+                }
+                break;
+              case UNIQUE:
+                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
+                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
+                  if (binding instanceof ProvisionBinding) {
+                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                        || provisionBinding.scope().isPresent()) {
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          memberSelectSnippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              componentWriter.name(),
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields, memberSelectSnippets));
+                    }
+                  } else if (binding instanceof ProductionBinding) {
+                    ProductionBinding productionBinding = (ProductionBinding) binding;
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet,
+                        initializeFactoryForProductionBinding(productionBinding,
+                            input,
+                            componentWriter.name(),
+                            input.componentDescriptor().dependencyMethodIndex(),
+                            componentContributionFields, memberSelectSnippets));
+                  } else {
+                    throw new AssertionError();
+                  }
+                }
+                break;
+              default:
+                throw new IllegalStateException();
+            }
+            break;
+          case MEMBERS_INJECTION:
+            MembersInjectionBinding binding = Iterables.getOnlyElement(
+                resolvedBindings.membersInjectionBindings());
+            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+              initializeMethod.body().addSnippet("this.%s = %s;",
+                  memberSelectSnippet,
+                  initializeMembersInjectorForBinding(
+                      componentWriter.name(), binding, memberSelectSnippets));
+            }
+            break;
+          default:
+            throw new AssertionError();
+        }
+      }
+    }
+  }
+
+  private static FrameworkField frameworkFieldForSyntheticContributionBinding(BindingKey bindingKey,
+      int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
+    switch (contributionBinding.bindingType()) {
+      case MAP:
+        return FrameworkField.createForMapBindingContribution(
+            contributionBinding.frameworkClass(),
+            BindingKey.create(bindingKey.kind(), contributionBinding.key()),
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+      case SET:
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
+            bindingKey,
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+      case UNIQUE:
+        return FrameworkField.createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
+            bindingKey,
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+          if (binding instanceof ProductionBinding) {
+            return Producer.class;
+          }
+        }
+        return Provider.class;
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        ImmutableSet<? extends ContributionBinding> contributionBindings =
+            resolvedBindings.contributionBindings();
+        BindingType bindingsType = ProvisionBinding.bindingTypeFor(contributionBindings);
+        switch (bindingsType) {
+          case SET:
+          case MAP:
+            return FrameworkField.createWithTypeFromKey(
+                frameworkClassForResolvedBindings(resolvedBindings),
+                bindingKey,
+                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
+          case UNIQUE:
+            ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
+            return FrameworkField.createWithTypeFromKey(
+                frameworkClassForResolvedBindings(resolvedBindings),
+                bindingKey,
+                binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                  @Override
+                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                    return e.getEnclosingElement().accept(this, null);
+                  }
+
+                  @Override
+                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                    return e.getSimpleName().toString();
+                  }
+
+                  @Override
+                  public String visitType(TypeElement e, Void p) {
+                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                        e.getSimpleName().toString());
+                  }
+                }, null));
+          default:
+            throw new AssertionError();
+        }
+      case MEMBERS_INJECTION:
+        return FrameworkField.createWithTypeFromKey(
+            MembersInjector.class,
+            bindingKey,
+            CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                Iterables.getOnlyElement(resolvedBindings.bindings())
+                .bindingElement().getSimpleName().toString()));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding,
+      BindingGraph input,
+      ClassName componentName,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    if (binding instanceof ProvisionBinding) {
+      return initializeFactoryForProvisionBinding(
+          (ProvisionBinding) binding,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else if (binding instanceof ProductionBinding) {
+      return initializeFactoryForProductionBinding(
+          (ProductionBinding) binding,
+          input,
+          componentName,
+          input.componentDescriptor().dependencyMethodIndex(),
+          componentContributionFields,
+          memberSelectSnippets);
+    } else {
+      throw new AssertionError();
+    }
+}
+
+  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
+      ClassName componentName,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
+      Map<TypeElement, MemberSelect> contributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    switch(binding.bindingKind()) {
+      case COMPONENT:
+        MemberSelect componentContributionSelect =
+            contributionFields.get(MoreTypes.asTypeElement(binding.key().type()));
+        return Snippet.format("%s.<%s>create(%s)",
+            ClassName.fromClass(InstanceFactory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            componentContributionSelect != null
+                ? componentContributionSelect.getSnippetFor(componentName) : "this");
+      case COMPONENT_PROVISION:
+        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
+        String sourceFieldName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
+        if (binding.nullableType().isPresent()
+            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+          Snippet nullableSnippet = binding.nullableType().isPresent()
+              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
+              : Snippet.format("");
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %3$s;",
+            "  %5$s@Override public %2$s get() {",
+            "    return %7$s.%4$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
+            binding.bindingElement().getSimpleName().toString(),
+            nullableSnippet,
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
+        } else {
+          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          StringLiteral failMsg =
+              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %3$s;",
+            "  @Override public %2$s get() {",
+            "    %2$s provided = %7$s.%4$s();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(%5$s);",
+            "    }",
+            "    return provided;",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
+            binding.bindingElement().getSimpleName().toString(),
+            failMsg,
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
+        }
+      case INJECTION:
+      case PROVISION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
+          parameters.add(contributionFields.get(binding.contributedBy().get())
+              .getSnippetFor(componentName));
+        }
+        parameters.addAll(getDependencyParameters(componentName, binding.implicitDependencies(),
+            memberSelectSnippets));
+
+        Snippet factorySnippet = Snippet.format("%s.create(%s)",
+            factoryNameForProvisionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+        return binding.scope().isPresent()
+            ? Snippet.format("%s.create(%s)",
+                ClassName.fromClass(ScopedProvider.class),
+                factorySnippet)
+            : factorySnippet;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
+      BindingGraph bindingGraph,
+      ClassName componentName,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
+      Map<TypeElement, MemberSelect> contributionFields,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    switch (binding.bindingKind()) {
+      case COMPONENT_PRODUCTION:
+        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
+        String sourceFieldName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
+        return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  private final %6$s %7$s = %4$s;",
+            "  @Override public %3$s<%2$s> get() {",
+            "    return %7$s.%5$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Producer.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            ClassName.fromClass(ListenableFuture.class),
+            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
+            binding.bindingElement().getSimpleName().toString(),
+            TypeNames.forTypeMirror(bindingTypeElement.asType()),
+            sourceFieldName);
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+        parameters.add(contributionFields.get(binding.bindingTypeElement())
+            .getSnippetFor(componentName));
+        parameters.add(contributionFields.get(
+            bindingGraph.componentDescriptor().executorDependency().get())
+                .getSnippetFor(componentName));
+        parameters.addAll(getProducerDependencyParameters(
+            bindingGraph, componentName, binding.dependencies(), memberSelectSnippets));
+
+        return Snippet.format("new %s(%s)",
+            factoryNameForProductionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet initializeMembersInjectorForBinding(
+      ClassName componentName,
+      MembersInjectionBinding binding,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return Snippet.format("%s.noOp()",
+            ClassName.fromClass(MembersInjectors.class));
+      case DELEGATE:
+        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
+        return Snippet.format("%s.delegatingTo(%s)",
+            ClassName.fromClass(MembersInjectors.class),
+            memberSelectSnippets.get(parentInjectorRequest.bindingKey())
+                .getSnippetFor(componentName));
+      case INJECT_MEMBERS:
+        List<Snippet> parameters = getDependencyParameters(
+            componentName,
+            binding.implicitDependencies(),
+            memberSelectSnippets);
+        return Snippet.format("%s.create(%s)",
+            membersInjectorNameForMembersInjectionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private List<Snippet> getDependencyParameters(
+      ClassName componentName,
+      Iterable<DependencyRequest> dependencies,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          })
+          .toSet());
+      parameters.add(memberSelectSnippets.get(key).getSnippetWithRawTypeCastFor(componentName));
+    }
+    return parameters.build();
+  }
+
+  private List<Snippet> getProducerDependencyParameters(
+      BindingGraph bindingGraph,
+      ClassName componentName,
+      Iterable<DependencyRequest> dependencies,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          }));
+      ResolvedBindings resolvedBindings = bindingGraph.resolvedBindings().get(key);
+      Class<?> frameworkClass =
+          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
+      if (frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
+          && frameworkClass.equals(Producer.class)) {
+        parameters.add(Snippet.format(
+            "%s.producerFromProvider(%s)",
+            ClassName.fromClass(Producers.class),
+            memberSelectSnippets.get(key).getSnippetFor(componentName)));
+      } else {
+        parameters.add(memberSelectSnippets.get(key).getSnippetFor(componentName));
+      }
+    }
+    return parameters.build();
+  }
+
+  private Snippet initializeMapBinding(
+      ClassName componentName,
+      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
+      Set<ProvisionBinding> bindings) {
+    Iterator<ProvisionBinding> iterator = bindings.iterator();
+    // get type information from first binding in iterator
+    ProvisionBinding firstBinding = iterator.next();
+    if (isNonProviderMap(firstBinding)) {
+      return Snippet.format("%s.create(%s)",
+          ClassName.fromClass(MapFactory.class),
+          memberSelectSnippets.get(
+              Iterables.getOnlyElement(firstBinding.dependencies()).bindingKey())
+                  .getSnippetFor(componentName));
+    } else {
+      DeclaredType mapType = asDeclared(firstBinding.key().type());
+      TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
+      TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
+      StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
+      for (int i = 0; i < bindings.size(); i++) {
+        snippetFormatBuilder.append("\n    .put(%s, %s)");
+      }
+      snippetFormatBuilder.append("\n    .build()");
+
+      List<Object> argsBuilder = Lists.newArrayList();
+      argsBuilder.add(ClassName.fromClass(MapProviderFactory.class));
+      argsBuilder.add(TypeNames.forTypeMirror(mapKeyType));
+      argsBuilder.add(TypeNames.forTypeMirror(mapValueType));
+      argsBuilder.add(bindings.size());
+
+      writeEntry(argsBuilder, firstBinding, multibindingContributionSnippets.get(firstBinding));
+      while (iterator.hasNext()) {
+        ProvisionBinding binding = iterator.next();
+        writeEntry(argsBuilder, binding, multibindingContributionSnippets.get(binding));
+      }
+
+      return Snippet.format(snippetFormatBuilder.toString(),
+          argsBuilder.toArray(new Object[0]));
+    }
+  }
+
+  // add one map entry for map Provider in Constructor
+  private void writeEntry(List<Object> argsBuilder, Binding binding,
+      Snippet factory) {
+    AnnotationMirror mapKeyAnnotationMirror =
+        Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+        mapKeyAnnotationMirror.getElementValues();
+    MapKey mapKey =
+        mapKeyAnnotationMirror.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    if (!mapKey.unwrapValue()) {// wrapped key case
+      FluentIterable<AnnotationValue> originIterable = FluentIterable.from(
+          AnnotationMirrors.getAnnotationValuesWithDefaults(mapKeyAnnotationMirror).values());
+      FluentIterable<Snippet> annotationValueNames =
+          originIterable.transform(new Function<AnnotationValue, Snippet>() {
+            @Override
+            public Snippet apply(AnnotationValue value) {
+              return getValueSnippet(value);
+            }
+          });
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (Snippet snippet : annotationValueNames) {
+        snippets.add(snippet);
+      }
+      argsBuilder.add(Snippet.format("%s.create(%s)",
+          Util.getMapKeyCreatorClassName(
+              MoreTypes.asTypeElement(mapKeyAnnotationMirror.getAnnotationType())),
+          Snippet.makeParametersSnippet(snippets.build())));
+      argsBuilder.add(factory);
+    } else { // unwrapped key case
+      argsBuilder.add(Iterables.getOnlyElement(map.entrySet()).getValue());
+      argsBuilder.add(factory);
+    }
+  }
+
+  // Get the Snippet representation of a Annotation Value
+  // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
+  private Snippet getValueSnippet(AnnotationValue value) {
+    AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<Snippet, Void>() {
+          @Override
+          public Snippet visitEnumConstant(VariableElement c, Void p) {
+            return Snippet.format("%s.%s",
+                TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+          }
+
+          @Override
+          public Snippet visitAnnotation(AnnotationMirror a, Void p) {
+            if (a.getElementValues().isEmpty()) {
+              return Snippet.format("@%s", TypeNames.forTypeMirror(a.getAnnotationType()));
+            } else {
+              Map<ExecutableElement, AnnotationValue> map =
+                  AnnotationMirrors.getAnnotationValuesWithDefaults(a);
+              // build "@Annotation(a = , b = , c = ))
+              ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+              for (Entry<ExecutableElement, AnnotationValue> entry : map.entrySet()) {
+                snippets.add(Snippet.format("%s = %s",
+                    TypeNames.forTypeMirror(entry.getKey().asType()),
+                    getValueSnippet(entry.getValue())));
+
+              }
+              return Snippet.format("@%s(%s)", TypeNames.forTypeMirror(a.getAnnotationType()),
+                  Snippet.makeParametersSnippet(snippets.build()));
+            }
+          }
+
+          @Override
+          public Snippet visitType(TypeMirror t, Void p) {
+            return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+          }
+
+          @Override
+          public Snippet visitString(String s, Void p) {
+            return Snippet.format("\"%s\"", s);
+          }
+
+          @Override
+          protected Snippet defaultAction(Object o, Void v) {
+            return Snippet.format("%s", o);
+          }
+
+          @Override
+          public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
+            ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+            for (int i = 0; i < values.size(); i++) {
+              snippets.add(values.get(i).accept(this, null));
+            }
+            return Snippet.format("[%s]", Snippet.makeParametersSnippet(snippets.build()));
+          }
+        };
+    return value.accept(mapKeyVisitor, null);
+  }
+
+  private boolean isNonProviderMap(Binding binding) {
+    TypeMirror bindingType = binding.key().type();
+    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
new file mode 100644
index 000000000..a7f486897
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.SetMultimap;
+import dagger.Component;
+import dagger.Subcomponent;
+import dagger.internal.codegen.ComponentDescriptor.Factory;
+import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
+import java.lang.annotation.Annotation;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * as part of the {@link ComponentProcessor}.
+ *
+ * @author Gregory Kick
+ */
+final class ComponentProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ComponentValidator componentValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator componentBuilderValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
+
+  ComponentProcessingStep(
+      Messager messager,
+      ComponentValidator componentValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator componentBuilderValidator,
+      BuilderValidator subcomponentBuilderValidator,
+      BindingGraphValidator bindingGraphValidator,
+      Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.componentBuilderValidator = componentBuilderValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
+        Subcomponent.class, Subcomponent.Builder.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
+    Set<? extends Element> subcomponentBuilderElements =
+        elementsByAnnotation.get(Subcomponent.Builder.class);
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+        processSubcomponentBuilders(subcomponentBuilderElements);
+    Set<? extends Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+        processSubcomponents(subcomponentElements, subcomponentBuilderElements);
+    Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
+    processComponents(componentElements, builderReportsByComponent, subcomponentElements,
+        reportsBySubcomponent, subcomponentBuilderElements, builderReportsBySubcomponent);
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
+    }
+    return builderReportsByComponent;
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
+      Set<? extends Element> subcomponentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsBySubcomponent.put(element, report);
+    }
+    return builderReportsBySubcomponent;
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
+      Set<? extends Element> subcomponentElements,
+      Set<? extends Element> subcomponentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentElements) {
+      ComponentValidationReport report = subcomponentValidator.validate(
+          MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      reportsBySubcomponent.put(element, report.report());
+    }
+    return reportsBySubcomponent;
+  }
+
+  private void processComponents(
+      Set<? extends Element> componentElements,
+      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
+      Set<? extends Element> subcomponentElements,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Set<? extends Element> subcomponentBuilderElements,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ComponentValidationReport report = componentValidator.validate(
+          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      if (isClean(report, builderReportsByComponent, reportsBySubcomponent,
+          builderReportsBySubcomponent)) {
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.forComponent(componentTypeElement);
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport =
+            bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns true if the component's report is clean, its builder report is clean, and all
+   * referenced subcomponent reports & subcomponent builder reports are clean.
+   */
+  private boolean isClean(ComponentValidationReport report,
+      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    Element component = report.report().subject();
+    ValidationReport<?> componentReport = report.report();
+    if (!componentReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> builderReport = builderReportsByComponent.get(component);
+    if (builderReport != null && !builderReport.isClean()) {
+      return false;
+    }
+    for (Element element : report.referencedSubcomponents()) {
+      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
+      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+        return false;
+      }
+      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
+      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+        return false;
+      }
+    }
+    return true;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
new file mode 100644
index 000000000..1214684ec
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+/**
+ * The annotation processor responsible for generating the classes that drive the Dagger 2.0
+ * implementation.
+ *
+ * TODO(gak): give this some better documentation
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoService(Processor.class)
+public final class ComponentProcessor extends BasicAnnotationProcessor {
+  private InjectBindingRegistry injectBindingRegistry;
+  private FactoryGenerator factoryGenerator;
+  private MembersInjectorGenerator membersInjectorGenerator;
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY, NULLABLE_VALIDATION_KEY);
+  }
+
+  @Override
+  protected Iterable<ProcessingStep> initSteps() {
+    Messager messager = processingEnv.getMessager();
+    Types types = processingEnv.getTypeUtils();
+    Elements elements = processingEnv.getElementUtils();
+    Filer filer = processingEnv.getFiler();
+
+    Diagnostic.Kind nullableDiagnosticType =
+        nullableValidationType(processingEnv).diagnosticKind().get();
+
+    MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
+    ProvisionBindingFormatter provisionBindingFormatter =
+        new ProvisionBindingFormatter(methodSignatureFormatter);
+    ProductionBindingFormatter productionBindingFormatter =
+        new ProductionBindingFormatter(methodSignatureFormatter);
+    DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
+    KeyFormatter keyFormatter = new KeyFormatter();
+
+    InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
+    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
+        Module.class, Provides.class);
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
+    BuilderValidator componentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
+    BuilderValidator subcomponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
+    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
+        types, moduleValidator, subcomponentBuilderValidator);
+    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
+        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
+    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
+        methodSignatureFormatter, ProducerModule.class, Produces.class);
+    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
+    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
+
+    Key.Factory keyFactory = new Key.Factory(types, elements);
+
+    this.factoryGenerator =
+        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
+    this.membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, types, nullableDiagnosticType);
+    ProducerFactoryGenerator producerFactoryGenerator =
+        new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
+
+    DependencyRequest.Factory dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    ProvisionBinding.Factory provisionBindingFactory =
+        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+    ProductionBinding.Factory productionBindingFactory =
+        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+
+    MembersInjectionBinding.Factory membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+
+    this.injectBindingRegistry = new InjectBindingRegistry(
+        elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
+
+    ComponentDescriptor.Factory componentDescriptorFactory =
+        new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
+
+    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
+        elements, types, injectBindingRegistry, keyFactory,
+        dependencyRequestFactory, provisionBindingFactory, productionBindingFactory);
+
+    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
+        types,
+        injectBindingRegistry,
+        scopeValidationType(processingEnv),
+        nullableDiagnosticType,
+        provisionBindingFormatter,
+        productionBindingFormatter,
+        methodSignatureFormatter,
+        dependencyRequestFormatter,
+        keyFormatter);
+
+    return ImmutableList.<ProcessingStep>of(
+        new MapKeyProcessingStep(
+            messager,
+            mapKeyValidator,
+            mapKeyGenerator),
+        new InjectProcessingStep(
+            messager,
+            injectConstructorValidator,
+            injectFieldValidator,
+            injectMethodValidator,
+            provisionBindingFactory,
+            membersInjectionBindingFactory,
+            injectBindingRegistry),
+        new ModuleProcessingStep(
+            messager,
+            moduleValidator,
+            providesMethodValidator,
+            provisionBindingFactory,
+            factoryGenerator),
+        new ComponentProcessingStep(
+            messager,
+            componentValidator,
+            subcomponentValidator,
+            componentBuilderValidator,
+            subcomponentBuilderValidator,
+            bindingGraphValidator,
+            componentDescriptorFactory,
+            bindingGraphFactory,
+            componentGenerator),
+        new ProducerModuleProcessingStep(
+            messager,
+            producerModuleValidator,
+            producesMethodValidator,
+            productionBindingFactory,
+            producerFactoryGenerator),
+        new ProductionComponentProcessingStep(
+            messager,
+            productionComponentValidator,
+            bindingGraphValidator,
+            componentDescriptorFactory,
+            bindingGraphFactory,
+            componentGenerator));
+  }
+
+  @Override
+  protected void postProcess() {
+    try {
+      injectBindingRegistry.generateSourcesForRequiredBindings(
+          factoryGenerator, membersInjectorGenerator);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(processingEnv.getMessager());
+    }
+  }
+
+  private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
+      "dagger.disableInterComponentScopeValidation";
+
+  private static final String NULLABLE_VALIDATION_KEY =
+      "dagger.nullableValidation";
+
+  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.allOf(ValidationType.class));
+  }
+
+  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        NULLABLE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType validationTypeFor(ProcessingEnvironment processingEnv, String key,
+      ValidationType defaultValue, Set<ValidationType> validValues) {
+    Map<String, String> options = processingEnv.getOptions();
+    if (options.containsKey(key)) {
+      try {
+        ValidationType type = ValidationType.valueOf(options.get(key).toUpperCase());
+        if (!validValues.contains(type)) {
+          throw new IllegalArgumentException(); // let handler below print out good msg.
+        }
+        return type;
+      } catch (IllegalArgumentException e) {
+        processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
+            + key + " may only have the values " + validValues
+            + " (case insensitive), found: " + options.get(key));
+      }
+    }
+    return defaultValue;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
new file mode 100644
index 000000000..469b37591
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * Performs superficial validation of the contract of the {@link Component} annotation.
+ *
+ * @author Gregory Kick
+ */
+final class ComponentValidator {
+  private final Elements elements;
+  private final Types types;
+  private final ComponentDescriptor.Kind componentType;
+  private final ModuleValidator moduleValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
+  
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
+    this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = this;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
+
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = ComponentDescriptor.Kind.COMPONENT;
+    this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
+  
+  static ComponentValidator createForComponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  static ComponentValidator createForSubcomponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  @AutoValue
+  static abstract class ComponentValidationReport {
+    abstract Set<Element> referencedSubcomponents();
+    abstract ValidationReport<TypeElement> report();
+  }
+
+  /**
+   * Validates the given component subject. Also validates any referenced subcomponents that aren't
+   * already included in the {@code validatedSubcomponents} set.
+   */
+  public ComponentValidationReport validate(final TypeElement subject,
+      Set<? extends Element> validatedSubcomponents,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
+          componentType.annotationType().getSimpleName()), subject);
+    }
+    
+    ImmutableList<DeclaredType> builders =
+        enclosedBuilders(subject, componentType.builderAnnotationType());
+    if (builders.size() > 1) {
+      builder.addItem(
+          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+          subject);
+    }
+    
+    DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
+
+    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
+    // it can return a logical method multiple times (including overrides, etc.)
+    List<? extends Element> members = elements.getAllMembers(subject);
+    Multimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
+    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
+      if (method.getModifiers().contains(ABSTRACT)) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
+        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
+        List<? extends VariableElement> parameters = method.getParameters();
+        TypeMirror returnType = resolvedMethod.getReturnType();
+
+        // abstract methods are ones we have to implement, so they each need to be validated
+        // first, check the return type.  if it's a subcomponent, validate that method as such.
+        Optional<AnnotationMirror> subcomponentAnnotation =
+            checkForAnnotation(returnType, Subcomponent.class);
+        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+            checkForAnnotation(returnType, Subcomponent.Builder.class);
+        if (subcomponentAnnotation.isPresent()) {
+          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+          validateSubcomponentMethod(builder,
+              method,
+              parameters,
+              parameterTypes,
+              returnType,
+              subcomponentAnnotation);
+        } else if (subcomponentBuilderAnnotation.isPresent()) {
+          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
+              method);
+          validateSubcomponentBuilderMethod(builder,
+              method,
+              parameters,
+              returnType,
+              validatedSubcomponentBuilders);
+        } else {
+          // if it's not a subcomponent...
+          switch (parameters.size()) {
+            case 0:
+              // no parameters means that it is a provision method
+              // basically, there are no restrictions here.  \o/
+              break;
+            case 1:
+              // one parameter means that it's a members injection method
+              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
+              if (!(returnType.getKind().equals(VOID)
+                  || types.isSameType(returnType, onlyParameter))) {
+                builder.addItem(
+                    "Members injection methods may only return the injected type or void.",
+                    method);
+              }
+              break;
+            default:
+              // this isn't any method that we know how to implement...
+              builder.addItem(
+                  "This method isn't a valid provision method, members injection method or "
+                      + "subcomponent factory method. Dagger cannot implement this method", method);
+              break;
+          }
+        }
+      }
+    }
+    
+    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
+        referencedSubcomponents.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        builder.addItem(
+            String.format(
+                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
+                entry.getKey(), entry.getValue()),
+            subject);
+      }
+    }
+
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, componentType.annotationType()).get();
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
+    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
+    
+    // Make sure we validate any subcomponents we're referencing, unless we know we validated
+    // them already in this pass.
+    // TODO(sameb): If subcomponents refer to each other and both aren't in
+    //              'validatedSubcomponents' (e.g, both aren't compiled in this pass),
+    //              then this can loop forever.
+    ImmutableSet.Builder<Element> allSubcomponents =
+        ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
+    for (Element subcomponent :
+        Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
+      ComponentValidationReport subreport = subcomponentValidator.validate(
+          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      builder.addItems(subreport.report().items());
+      allSubcomponents.addAll(subreport.referencedSubcomponents());
+    }
+    
+    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
+        builder.build());
+  }
+
+  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      List<? extends TypeMirror> parameterTypes,
+      TypeMirror returnType,
+      Optional<AnnotationMirror> subcomponentAnnotation) {
+    ImmutableSet<TypeElement> moduleTypes =
+        MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
+
+    ImmutableSet<TypeElement> transitiveModules =
+        getTransitiveModules(types, elements, moduleTypes);
+
+    ImmutableSet<TypeElement> requiredModules =
+        FluentIterable.from(transitiveModules)
+            .filter(new Predicate<TypeElement>() {
+              @Override public boolean apply(TypeElement input) {
+                return !componentCanMakeNewInstances(input);
+              }
+            })
+            .toSet();
+
+    Set<TypeElement> variableTypes = Sets.newHashSet();
+
+    for (int i = 0; i < parameterTypes.size(); i++) {
+      VariableElement parameter = parameters.get(i);
+      TypeMirror parameterType = parameterTypes.get(i);
+      Optional<TypeElement> moduleType = parameterType.accept(
+          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+              return Optional.absent();
+            }
+
+            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
+                  ? Optional.of(MoreTypes.asTypeElement(t))
+                  : Optional.<TypeElement>absent();
+            }
+          }, null);
+      if (moduleType.isPresent()) {
+        if (variableTypes.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "A module may only occur once an an argument in a Subcomponent factory "
+                      + "method, but %s was already passed.",
+                  moduleType.get().getQualifiedName()), parameter);
+        }
+        if (!transitiveModules.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "%s is present as an argument to the %s factory method, but is not one of the"
+                      + " modules used to implement the subcomponent.",
+                  moduleType.get().getQualifiedName(),
+                  MoreTypes.asTypeElement(returnType).getQualifiedName()),
+              method);
+        }
+        variableTypes.add(moduleType.get());
+      } else {
+        builder.addItem(
+            String.format(
+                "Subcomponent factory methods may only accept modules, but %s is not.",
+                parameterType),
+            parameter);
+      }
+    }
+
+    SetView<TypeElement> missingModules =
+        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
+    if (!missingModules.isEmpty()) {
+      builder.addItem(
+          String.format(
+              "%s requires modules which have no visible default constructors. "
+                  + "Add the following modules as parameters to this method: %s",
+              MoreTypes.asTypeElement(returnType).getQualifiedName(),
+              Joiner.on(", ").join(missingModules)),
+          method);
+    }
+  }
+
+  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+
+    if (!parameters.isEmpty()) {
+      builder.addItem(
+          ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+    }
+    
+    // If we haven't already validated the subcomponent builder itself, validate it now.
+    TypeElement builderElement = MoreTypes.asTypeElement(returnType);
+    if (!validatedSubcomponentBuilders.contains(builderElement)) {
+      // TODO(sameb): The builder validator right now assumes the element is being compiled
+      // in this pass, which isn't true here.  We should change error messages to spit out
+      // this method as the subject and add the original subject to the message output.
+      builder.addItems(subcomponentBuilderValidator.validate(builderElement).items());
+    }
+  }
+
+  
+  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
+      final Class<? extends Annotation> annotation) {
+    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+      @Override
+      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+        return Optional.absent();
+      }
+
+      @Override
+      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
+      }
+    }, null);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
new file mode 100644
index 000000000..176755d3f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
+ * and {@link Module}).
+ *
+ * @author Gregory Kick
+ */
+final class ConfigurationAnnotations {
+
+  static boolean isComponent(TypeElement componentDefinitionType) {
+    return MoreElements.isAnnotationPresent(componentDefinitionType, Component.class)
+        || MoreElements.isAnnotationPresent(componentDefinitionType, ProductionComponent.class);
+  }
+
+  private static final String MODULES_ATTRIBUTE = "modules";
+
+  static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
+    checkNotNull(componentAnnotation);
+    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
+  }
+
+  private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
+
+  static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
+    checkNotNull(componentAnnotation);
+    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+  }
+
+  private static final String INCLUDES_ATTRIBUTE = "includes";
+
+  static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
+    checkNotNull(moduleAnnotation);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
+  }
+
+  private static final String INJECTS_ATTRIBUTE = "injects";
+
+  static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
+    checkNotNull(moduleAnnotation);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
+  }
+
+  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
+  }
+
+  /** Returns the first type that specifies this' nullability, or absent if none. */
+  static Optional<DeclaredType> getNullableType(Element element) {
+    List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
+    for (AnnotationMirror mirror : mirrors) {
+      if (mirror.getAnnotationType().asElement().getSimpleName().toString().equals("Nullable")) {
+        return Optional.of(mirror.getAnnotationType());
+      }
+    }
+    return Optional.absent();
+  }
+
+  static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
+      AnnotationMirror annotationMirror, final String elementName) {
+    @SuppressWarnings("unchecked") // that's the whole point of this method
+    List<? extends AnnotationValue> listValue = (List<? extends AnnotationValue>)
+        getAnnotationValue(annotationMirror, elementName).getValue();
+    return FluentIterable.from(listValue).transform(new Function<AnnotationValue, TypeMirror>() {
+      @Override public TypeMirror apply(AnnotationValue typeValue) {
+        return (TypeMirror) typeValue.getValue();
+      }
+    }).toList();
+  }
+
+  /**
+   * Returns the full set of modules transitively {@linkplain Module#includes included} from the
+   * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
+   * is not annotated with {@link Module}, it is ignored.
+   */
+  static ImmutableSet<TypeElement> getTransitiveModules(
+      Types types, Elements elements, Iterable<TypeElement> seedModules) {
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    for (TypeElement moduleElement = moduleQueue.poll();
+        moduleElement != null;
+        moduleElement = moduleQueue.poll()) {
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class)
+          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+      if (moduleMirror.isPresent()) {
+        ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
+        moduleDependenciesBuilder.addAll(
+            MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
+        // (note: we don't recurse on the parent class because we don't want the parent class as a
+        // root that the component depends on, and also because we want the dependencies rooted
+        // against this element, not the parent.)
+        addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
+        ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
+        moduleElements.add(moduleElement);
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+    }
+    return ImmutableSet.copyOf(moduleElements);
+  }
+  
+  /** Returns the enclosed elements annotated with the given annotation type. */
+  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
+      final Class<? extends Annotation> annotation) {
+    final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
+    for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
+        builders.add(MoreTypes.asDeclared(element.asType()));
+      }
+    }
+    return builders.build();
+  }
+
+  static boolean isSubcomponentType(TypeMirror type) {
+    return type.accept(new SubcomponentDetector(), null).isPresent();
+  }
+
+  private static final class SubcomponentDetector
+      extends SimpleTypeVisitor6<Optional<AnnotationMirror>, Void> {
+    @Override
+    protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+      return Optional.absent();
+    }
+
+    @Override
+    public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+      return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
+    }
+  }
+
+  /** Traverses includes from superclasses and adds them into the builder. */
+  private static void addIncludesFromSuperclasses(Types types, TypeElement element,
+      ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
+    // Also add the superclass to the queue, in case any @Module definitions were on that.
+    TypeMirror superclass = element.getSuperclass();
+    while (!types.isSameType(objectType, superclass)
+        && superclass.getKind().equals(TypeKind.DECLARED)) {
+      element = MoreElements.asType(types.asElement(superclass));
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
+          .or(getAnnotationMirror(element, ProducerModule.class));
+      if (moduleMirror.isPresent()) {
+        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
+      }
+      superclass = element.getSuperclass();
+    }
+  }
+
+  private ConfigurationAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
new file mode 100644
index 000000000..0630dfc7d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import java.util.EnumSet;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * An abstract class for a value object representing the mechanism by which a {@link Key} can be
+ * contributed to a dependency graph.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+abstract class ContributionBinding extends Binding {
+  static enum BindingType {
+    /** Represents map bindings. */
+    MAP,
+    /** Represents set bindings. */
+    SET,
+    /** Represents a valid non-collection binding. */
+    UNIQUE;
+
+    boolean isMultibinding() {
+      return !this.equals(UNIQUE);
+    }
+  }
+
+  abstract BindingType bindingType();
+
+  /** Returns the type that specifies this' nullability, absent if not nullable. */
+  abstract Optional<DeclaredType> nullableType();
+
+  /**
+   * If this is a provision request from an {@code @Provides} or {@code @Produces} method, this will
+   * be the element that contributed it. In the case of subclassed modules, this may differ than the
+   * binding's enclosed element, as this will return the subclass whereas the enclosed element will
+   * be the superclass.
+   */
+  abstract Optional<TypeElement> contributedBy();
+
+  /**
+   * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
+   * implicitly by the framework.
+   */
+  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
+  // this field the source of truth for synthetic bindings.
+  abstract boolean isSyntheticBinding();
+
+  /**
+   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
+   * ProvisionBinding.
+   */
+  abstract Class<?> frameworkClass();
+
+  /**
+   * Returns the set of {@link BindingType} enum values implied by a given
+   * {@link ContributionBinding} collection.
+   */
+  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
+      Iterable<? extends B> bindings) {
+    ImmutableListMultimap.Builder<BindingType, B> builder =
+        ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<BindingType>natural());
+    for (B binding : bindings) {
+      builder.put(binding.bindingType(), binding);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Returns a single {@code BindingsType} represented by a given collection of
+   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
+   * are not all of one type.
+   */
+  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
+    checkNotNull(bindings);
+    checkArgument(!Iterables.isEmpty(bindings), "no bindings");
+    Set<BindingType> types = EnumSet.noneOf(BindingType.class);
+    for (ContributionBinding binding : bindings) {
+      types.add(binding.bindingType());
+    }
+    if (types.size() > 1) {
+      throw new IllegalArgumentException(
+          String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+    }
+    return Iterables.getOnlyElement(types);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
new file mode 100644
index 000000000..2fbb507c2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.type.TypeKind.DECLARED;
+
+/**
+ * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
+ * or {@link Provides} methods are examples of key requests.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): Set bindings and the permutations thereof need to be addressed
+@AutoValue
+abstract class DependencyRequest {
+  enum Kind {
+    /** A default request for an instance.  E.g.: {@code Blah} */
+    INSTANCE,
+    /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
+    PROVIDER,
+    /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
+    LAZY,
+    /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
+    MEMBERS_INJECTOR,
+    /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
+    PRODUCER,
+    /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
+    PRODUCED,
+    /**
+     * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
+     * These can only be requested by component interfaces.
+     */
+    FUTURE,
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+
+  BindingKey bindingKey() {
+    switch (kind()) {
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+      case PRODUCER:
+      case PRODUCED:
+      case FUTURE:
+        return BindingKey.create(BindingKey.Kind.CONTRIBUTION, key());
+      case MEMBERS_INJECTOR:
+        return BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key());
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  abstract Element requestElement();
+
+  /**
+   * Returns the possibly resolved type that contained the requesting element. For members injection
+   * requests, this is the type itself.
+   */
+  abstract DeclaredType enclosingType();
+
+  /** Returns true if this request allows null objects. */
+  abstract boolean isNullable();
+
+  static final class Factory {
+    private final Key.Factory keyFactory;
+
+    Factory(Key.Factory keyFactory) {
+      this.keyFactory = keyFactory;
+    }
+
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(DeclaredType container,
+        List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
+      checkState(resolvedTypes.size() == variables.size());
+      ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
+      for (int i = 0; i < variables.size(); i++) {
+        builder.add(forRequiredResolvedVariable(container, variables.get(i), resolvedTypes.get(i)));
+      }
+      return builder.build();
+    }
+
+    ImmutableSet<DependencyRequest> forRequiredVariables(
+        List<? extends VariableElement> variables) {
+      return FluentIterable.from(variables)
+          .transform(new Function<VariableElement, DependencyRequest>() {
+            @Override public DependencyRequest apply(VariableElement input) {
+              return forRequiredVariable(input);
+            }
+          })
+          .toSet();
+    }
+
+    /**
+     * Creates a DependencyRequest for implictMapBinding, this request's key will be
+     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
+     * whose key is {@code Map<K, V>}
+     */
+    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
+      checkNotNull(delegatingRequest);
+      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
+          delegatingRequest.requestElement(),
+          getEnclosingType(delegatingRequest.requestElement()),
+          false /* doesn't allow null */);
+    }
+
+    DependencyRequest forRequiredVariable(VariableElement variableElement) {
+      checkNotNull(variableElement);
+      TypeMirror type = variableElement.asType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, type, qualifier,
+          getEnclosingType(variableElement));
+    }
+
+    DependencyRequest forRequiredResolvedVariable(DeclaredType container,
+        VariableElement variableElement,
+        TypeMirror resolvedType) {
+      checkNotNull(variableElement);
+      checkNotNull(resolvedType);
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, resolvedType, qualifier, container);
+    }
+
+    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
+        ExecutableType provisionMethodType) {
+      checkNotNull(provisionMethod);
+      checkNotNull(provisionMethodType);
+      checkArgument(provisionMethod.getParameters().isEmpty(),
+          "Component provision methods must be empty: " + provisionMethod);
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
+      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
+          getEnclosingType(provisionMethod));
+    }
+
+    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
+        ExecutableType productionMethodType) {
+      checkNotNull(productionMethod);
+      checkNotNull(productionMethodType);
+      checkArgument(productionMethod.getParameters().isEmpty(),
+          "Component production methods must be empty: %s", productionMethod);
+      TypeMirror type = productionMethodType.getReturnType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
+      DeclaredType container = getEnclosingType(productionMethod);
+      // Only a component production method can be a request for a ListenableFuture, so we
+      // special-case it here.
+      if (isTypeOf(ListenableFuture.class, type)) {
+        return new AutoValue_DependencyRequest(
+            Kind.FUTURE,
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
+            productionMethod,
+            container,
+            false /* doesn't allow null */);
+      } else {
+        return newDependencyRequest(productionMethod, type, qualifier, container);
+      }
+    }
+
+    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod,
+        ExecutableType membersInjectionMethodType) {
+      checkNotNull(membersInjectionMethod);
+      checkNotNull(membersInjectionMethodType);
+      Optional<AnnotationMirror> qualifier =
+          InjectionAnnotations.getQualifier(membersInjectionMethod);
+      checkArgument(!qualifier.isPresent());
+      TypeMirror returnType = membersInjectionMethodType.getReturnType();
+      if (returnType.getKind().equals(DECLARED)
+          && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      } else {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      }
+    }
+
+    DependencyRequest forMembersInjectedType(DeclaredType type) {
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+          keyFactory.forMembersInjectedType(type),
+          type.asElement(),
+          type,
+          false /* doesn't allow null */);
+    }
+
+    private DependencyRequest newDependencyRequest(Element requestElement,
+        TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
+      KindAndType kindAndType = extractKindAndType(type);
+      if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
+        checkArgument(!qualifier.isPresent());
+      }
+      // Only instance types can be non-null -- all other requests are wrapped
+      // inside something (e.g, Provider, Lazy, etc..).
+      // TODO(sameb): should Produced/Producer always require non-nullable?
+      boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
+          || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
+      return new AutoValue_DependencyRequest(kindAndType.kind(),
+          keyFactory.forQualifiedType(qualifier, kindAndType.type()),
+          requestElement,
+          container,
+          allowsNull);
+    }
+
+    @AutoValue
+    static abstract class KindAndType {
+      abstract Kind kind();
+      abstract TypeMirror type();
+    }
+
+    /**
+     * Extracts the correct requesting type & kind out a request type. For example, if a user
+     * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
+     */
+    static KindAndType extractKindAndType(TypeMirror type) {
+      // We must check TYPEVAR explicitly before the below checks because calling
+      // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
+      // represented as a Class).
+      if (type.getKind().equals(TypeKind.TYPEVAR)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
+      } else if (isTypeOf(Provider.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
+      } else if (isTypeOf(Lazy.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
+      } else if (isTypeOf(MembersInjector.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
+      } else if (isTypeOf(Producer.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
+      } else if (isTypeOf(Produced.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
+      } else {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
+      }
+    }
+
+    static DeclaredType getEnclosingType(Element element) {
+      while (!MoreElements.isType(element)) {
+        element = element.getEnclosingElement();
+      }
+      return MoreTypes.asDeclared(element.asType());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
new file mode 100644
index 000000000..0e5f1f240
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import java.util.List;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+
+/**
+ * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
+ * a chain of dependencies.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+  private final Types types;
+
+  DependencyRequestFormatter(Types types) {
+    this.types = types;
+  }
+
+  // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
+  // TODO(cgruber): consider returning a small structure containing strings to be indented later.
+  @Override public String format(final DependencyRequest request) {
+    Element requestElement = request.requestElement();
+    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
+    return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
+
+      /* Handle component methods */
+      @Override public String visitExecutable(
+          ExecutableElement method, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        if (method.getParameters().isEmpty()) {
+          // some.package.name.MyComponent.myMethod()
+          //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
+          appendEnclosingTypeAndMemberName(method, builder).append("()\n")
+              .append(INDENT).append(INDENT).append("[component method with return type: ");
+          if (qualifier.isPresent()) {
+            // TODO(cgruber) use chenying's annotation mirror stringifier
+            builder.append(qualifier.get()).append(' ');
+          }
+          builder.append(method.getReturnType()).append(']');
+        } else {
+          // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
+          //     [component injection method for type: some.package.name.Foo]
+          VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
+          appendEnclosingTypeAndMemberName(method, builder).append("(");
+          appendParameter(componentMethodParameter, componentMethodParameter.asType(), builder);
+          builder.append(")\n");
+          builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
+              .append(componentMethodParameter.asType())
+              .append(']');
+        }
+        return builder.toString();
+      }
+
+      /* Handle injected fields or method/constructor parameter injection. */
+      @Override public String visitVariable(
+          VariableElement variable, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        TypeMirror resolvedVariableType =
+            MoreTypes.asMemberOf(types, request.enclosingType(), variable);
+        if (variable.getKind().equals(ElementKind.PARAMETER)) {
+          // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
+          //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
+          ExecutableElement methodOrConstructor =
+              MoreElements.asExecutable(variable.getEnclosingElement());
+          ExecutableType resolvedMethodOrConstructor = MoreTypes.asExecutable(
+              types.asMemberOf(request.enclosingType(), methodOrConstructor));
+          appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
+          List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
+          List<? extends TypeMirror> parameterTypes =
+              resolvedMethodOrConstructor.getParameterTypes();
+          checkState(parameters.size() == parameterTypes.size());
+          for (int i = 0; i < parameters.size(); i++) {
+            appendParameter(parameters.get(i), parameterTypes.get(i), builder);
+            if (i != parameters.size() - 1) {
+              builder.append(", ");
+            }
+          }
+          builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
+        } else {
+          // some.package.name.MyClass.myField
+          //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
+          appendEnclosingTypeAndMemberName(variable, builder).append("\n")
+              .append(INDENT).append(INDENT).append("[injected field of type: ");
+        }
+        if (qualifier.isPresent()) {
+          // TODO(cgruber) use chenying's annotation mirror stringifier
+          builder.append(qualifier.get()).append(' ');
+        }
+        builder.append(resolvedVariableType)
+            .append(' ')
+            .append(variable.getSimpleName())
+            .append(']');
+        return builder.toString();
+      }
+
+      @Override
+      public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
+        return ""; // types by themselves provide no useful information.
+      }
+
+      @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
+        throw new IllegalStateException(
+            "Invalid request " + element.getKind() +  " element " + element);
+      }
+    }, qualifier);
+  }
+
+  private StringBuilder appendParameter(VariableElement parameter, TypeMirror type,
+      StringBuilder builder) {
+    return builder.append(type).append(' ').append(parameter.getSimpleName());
+  }
+
+  private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
+    TypeElement type = MoreElements.asType(member.getEnclosingElement());
+    return builder.append(type.getQualifiedName())
+        .append('.')
+        .append(member.getSimpleName());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
new file mode 100644
index 000000000..1dc48fc8b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+/**
+ * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
+ * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ *
+ *  @author Jesse Beder
+ *  @since 2.0
+ */
+abstract class DependencyRequestMapper {
+  abstract Class<?> getFrameworkClass(DependencyRequest request);
+
+  /**
+   * Returns the framework class to use for a collection of requests of the same {@link BindingKey}.
+   * This allows factories to only take a single argument for multiple requests of the same key.
+   */
+  Class<?> getFrameworkClass(Iterable<DependencyRequest> requests) {
+    ImmutableSet<Class<?>> classes = FluentIterable.from(requests)
+        .transform(new Function<DependencyRequest, Class<?>>() {
+          @Override public Class<?> apply(DependencyRequest request) {
+            return getFrameworkClass(request);
+          }
+        })
+        .toSet();
+    if (classes.size() == 1) {
+      return getOnlyElement(classes);
+    } else if (classes.equals(ImmutableSet.of(Producer.class, Provider.class))) {
+      return Provider.class;
+    } else {
+      throw new IllegalStateException("Bad set of framework classes: " + classes);
+    }
+  }
+
+  private static final class MapperForProvider extends DependencyRequestMapper {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PROVIDER:
+        case LAZY:
+          return Provider.class;
+        case MEMBERS_INJECTOR:
+          return MembersInjector.class;
+        case PRODUCED:
+        case PRODUCER:
+          throw new IllegalArgumentException();
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PROVIDER = new MapperForProvider();
+
+  private static final class MapperForProducer extends DependencyRequestMapper {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PRODUCED:
+        case PRODUCER:
+          return Producer.class;
+        case PROVIDER:
+        case LAZY:
+          return Provider.class;
+        case MEMBERS_INJECTOR:
+          return MembersInjector.class;
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
new file mode 100644
index 000000000..1643adbc4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Function;
+import dagger.Lazy;
+import javax.inject.Provider;
+
+/**
+ * Picks a reasonable name for what we think is being provided from the variable name associated
+ * with the {@link DependencyRequest}.  I.e. strips out words like "lazy" and "provider" if we
+ * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being
+ * provided.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+//TODO(gak): develop the heuristics to get better names
+final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+  @Override
+  public String apply(DependencyRequest dependency) {
+    String variableName = dependency.requestElement().getSimpleName().toString();
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return variableName;
+      case LAZY:
+        return variableName.startsWith("lazy") && !variableName.equals("lazy")
+            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            : variableName;
+      case PROVIDER:
+        return variableName.endsWith("Provider") && !variableName.equals("Provider")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
+      case MEMBERS_INJECTOR:
+        return variableName.endsWith("MembersInjector") && !variableName.equals("MembersInjector")
+            ? variableName.substring(0, variableName.length() - 15)
+            : variableName;
+      case PRODUCED:
+        return variableName.startsWith("produced") && !variableName.equals("produced")
+            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            : variableName;
+      case PRODUCER:
+        return variableName.endsWith("Producer") && !variableName.equals("Producer")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java b/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
deleted file mode 100644
index 4fb8c92d3..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Emits dot graphs.
- */
-public final class DotWriter implements Closeable {
-  private static final String INDENT = "  ";
-  private final Writer out;
-  private int indent = 0;
-  private int nextName = 1;
-  private final Map<String, String> generatedNames = new LinkedHashMap<String, String>();
-
-  /**
-   * @param out the stream to which dot data will be written. This should be a
-   *     buffered stream.
-   */
-  public DotWriter(Writer out) {
-    this.out = out;
-  }
-
-  public void beginGraph(String... attributes) throws IOException {
-    indent();
-    String type = indent == 0 ? "digraph " : "subgraph ";
-    String name = nextName(indent == 0 ? "G" : "cluster");
-    out.write(type);
-    out.write(name);
-    out.write(" {\n");
-    indent++;
-    attributes(attributes);
-  }
-
-  public void endGraph() throws IOException {
-    indent--;
-    indent();
-    out.write("}\n");
-  }
-
-  public void node(String name, String... attributes) throws IOException {
-    name = nodeName(name);
-    indent();
-    out.write(name);
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void edge(String source, String target, String... attributes) throws IOException {
-    source = nodeName(source);
-    target = nodeName(target);
-    indent();
-    out.write(source);
-    out.write(" -> ");
-    out.write(target);
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void nodeDefaults(String... attributes) throws IOException {
-    if (attributes.length == 0) return;
-    indent();
-    out.write("node");
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void edgeDefaults(String... attributes) throws IOException {
-    if (attributes.length == 0) return;
-    indent();
-    out.write("edge");
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  private void attributes(String[] attributes) throws IOException {
-    if (attributes.length == 0) return;
-    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
-    for (int i = 0; i < attributes.length; i += 2) {
-      indent();
-      out.write(attributes[i]);
-      out.write(" = ");
-      out.write(literal(attributes[i + 1]));
-      out.write(";\n");
-    }
-  }
-
-  private void inlineAttributes(String[] attributes) throws IOException {
-    if (attributes.length == 0) return;
-    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
-    out.write(" [");
-    for (int i = 0; i < attributes.length; i += 2) {
-      if (i != 0) out.write(";");
-      out.write(attributes[i]);
-      out.write("=");
-      out.write(literal(attributes[i + 1]));
-    }
-    out.write("]");
-  }
-
-  private String nodeName(String name) throws IOException {
-    if (name.matches("\\w+")) return name;
-    String generatedName = generatedNames.get(name);
-    if (generatedName != null) return generatedName;
-    generatedName = nextName("n");
-    generatedNames.put(name, generatedName);
-    node(generatedName, "label", name);
-    return generatedName;
-  }
-
-  private String literal(String raw) {
-    return raw.matches("\\w+") ? raw : JavaWriter.stringLiteral(raw);
-  }
-
-  private void indent() throws IOException {
-    for (int i = 0; i < indent; i++) {
-      out.write(INDENT);
-    }
-  }
-
-  private String nextName(String prefix) {
-    return prefix + (nextName++);
-  }
-
-  @Override public void close() throws IOException {
-    out.close();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
new file mode 100644
index 000000000..5e5e57478
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Provides;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.lang.model.element.AnnotationMirror;
+
+/**
+ * The collection of error messages to be reported back to users.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ErrorMessages {
+  /*
+   * Common constants.
+   */
+  static final String INDENT = "    ";
+
+  /*
+   * JSR-330 errors
+   *
+   * These are errors that are explicitly outlined in the JSR-330 APIs
+   */
+
+  /* constructors */
+  static final String MULTIPLE_INJECT_CONSTRUCTORS =
+      "Types may only contain one @Inject constructor.";
+
+  /* fields */
+  static final String FINAL_INJECT_FIELD = "@Inject fields may not be final";
+
+  /* methods */
+  static final String ABSTRACT_INJECT_METHOD = "Methods with @Inject may not be abstract.";
+  static final String GENERIC_INJECT_METHOD =
+      "Methods with @Inject may not declare type parameters.";
+
+  /* qualifiers */
+  static final String MULTIPLE_QUALIFIERS =
+      "A single injection site may not use more than one @Qualifier.";
+
+  /* scope */
+  static final String MULTIPLE_SCOPES = "A single binding may not declare more than one @Scope.";
+
+  /*
+   * Dagger errors
+   *
+   * These are errors that arise due to restrictions imposed by the dagger implementation.
+   */
+
+  /* constructors */
+  static final String INJECT_ON_PRIVATE_CONSTRUCTOR =
+      "Dagger does not support injection into private constructors";
+  static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
+      "@Inject constructors are invalid on inner classes";
+  static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
+      "@Inject is nonsense on the constructor of an abstract class";
+    static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
+      "@Qualifier annotations are not allowed on @Inject constructors.";
+
+  /* fields */
+  static final String PRIVATE_INJECT_FIELD =
+      "Dagger does not support injection into private fields";
+
+  /* methods */
+  static final String PRIVATE_INJECT_METHOD =
+      "Dagger does not support injection into private methods";
+
+  /* all */
+  static final String INJECT_INTO_PRIVATE_CLASS =
+      "Dagger does not support injection into private classes";
+
+  /*
+   * Configuration errors
+   *
+   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
+   * etc.)
+   */
+  static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
+      "%s is bound multiple times:";
+
+  static final String PROVIDES_METHOD_RETURN_TYPE =
+      "@Provides methods must either return a primitive, an array or a declared type.";
+
+  static final String PRODUCES_METHOD_RETURN_TYPE =
+      "@Produces methods must either return a primitive, an array or a declared type, or a"
+      + " ListenableFuture of one of those types.";
+
+  static final String PRODUCES_METHOD_RAW_FUTURE =
+      "@Produces methods cannot return a raw ListenableFuture.";
+
+  static final String BINDING_METHOD_SET_VALUES_RAW_SET =
+      "@%s methods of type set values cannot return a raw Set";
+
+  static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
+      "@Provides methods of type set values must return a Set";
+
+  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
+      "@Produces methods of type set values must return a Set or ListenableFuture of Set";
+
+  static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
+      "@%s methods must return a value (not void).";
+
+  static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
+
+  static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
+
+  static final String BINDING_METHOD_TYPE_PARAMETER =
+      "@%s methods may not have type parameters.";
+
+  static final String BINDING_METHOD_NOT_IN_MODULE =
+      "@%s methods can only be present within a @%s";
+
+  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
+      "@%s methods of non map type cannot declare a map key";
+
+  static final String BINDING_METHOD_WITH_NO_MAP_KEY =
+      "@%s methods of type map must declare a map key";
+
+  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEY =
+      "@%s methods may not have more than one @MapKey-marked annotation";
+
+  static final String BINDING_METHOD_WITH_SAME_NAME =
+      "Cannot have more than one @%s method with the same name in a single module";
+
+  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
+      "Modules with type parameters must be abstract";
+
+  static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
+      "%s is listed as a module, but is abstract";
+
+  static final String REFERENCED_MODULE_NOT_ANNOTATED =
+      "%s is listed as a module, but is not annotated with @%s";
+
+  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
+      "%s is listed as a module, but has type parameters";
+
+  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER =
+      "@%s methods may not override another method. Overrides: %s";
+
+  static final String METHOD_OVERRIDES_PROVIDES_METHOD =
+      "@%s methods may not be overridden in modules. Overrides: %s";
+
+  static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
+      "Cannot use more than one @Qualifier on a @Provides or @Produces method";
+
+  /* mapKey errors*/
+  static final String MAPKEY_WITHOUT_FIELDS =
+      "Map key annotation does not have fields";
+
+  /* collection binding errors */
+  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+      "More than one binding present of different types %s";
+
+  static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
+      "%s has incompatible bindings:\n";
+
+  static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
+      "%s is a provision entry-point, which cannot depend on a production.";
+
+  static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
+      "%s is a provision, which cannot depend on a production.";
+
+  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
+
+  static final String REQUIRES_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Provides-annotated method.";
+
+  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT =
+      "%s cannot be provided without an @Inject constructor or from an @Provides- or "
+      + "@Produces-annotated method.";
+
+  static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT =
+      "%s cannot be provided without an @Provides- or @Produces-annotated method.";
+
+  static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
+      "This type supports members injection but cannot be implicitly provided.";
+
+  static final String MEMBERS_INJECTION_WITH_RAW_TYPE =
+      "%s has type parameters, cannot members inject the raw type. via:\n%s";
+
+  static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
+      "Type parameters must be bounded for members injection. %s required by %s, via:\n%s";
+
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+
+  static final String MALFORMED_MODULE_METHOD_FORMAT =
+      "Cannot generated a graph because method %s on module %s was malformed";
+
+  static final String NULLABLE_TO_NON_NULLABLE =
+      "%s is not nullable, but is being provided by %s";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
+      "Cannot return null from a non-@Nullable component method";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
+      "Cannot return null from a non-@Nullable @Provides method";
+  
+  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
+    switch(kind) {
+      case COMPONENT:
+        return ComponentBuilderMessages.INSTANCE;
+      case SUBCOMPONENT:
+        return SubcomponentBuilderMessages.INSTANCE;
+      default:
+        throw new IllegalStateException(kind.toString());
+    }
+  }
+
+  static class ComponentBuilderMessages {
+    static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
+
+    protected String process(String s) { return s; }
+    
+    /** Errors for component builders. */
+    final String moreThanOne() {
+      return process("@Component has more than one @Component.Builder: %s");
+    }
+    
+    final String cxtorOnlyOneAndNoArgs() {
+      return process("@Component.Builder classes must have exactly one constructor,"
+          + " and it must not have any parameters");
+    }
+    
+    final String generics() {
+      return process("@Component.Builder types must not have any generic types");
+    }
+    
+    final String mustBeInComponent() {
+      return process("@Component.Builder types must be nested within a @Component");
+    }
+    
+    final String mustBeClassOrInterface() {
+      return process("@Component.Builder types must be abstract classes or interfaces");
+    }
+    
+    final String isPrivate() {
+      return process("@Component.Builder types must not be private");
+    }
+    
+    final String mustBeStatic() {
+      return process("@Component.Builder types must be static");
+    }
+    
+    final String mustBeAbstract() {
+      return process("@Component.Builder types must be abstract");
+    }
+    
+    final String missingBuildMethod() {
+      return process("@Component.Builder types must have exactly one no-args method that "
+          + " returns the @Component type");
+    }
+    
+    final String manyMethodsForType() {
+      return process("@Component.Builder types must not have more than one setter method per type,"
+          + " but %s is set by %s");
+    }
+    
+    final String extraSetters() {
+      return process(
+          "@Component.Builder has setters for modules or components that aren't required: %s");
+    }
+    
+    final String missingSetters() {
+      return process(
+          "@Component.Builder is missing setters for required modules or components: %s");
+    }
+    
+    final String twoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Already found: %s");
+    }
+    
+    final String inheritedTwoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Found %s and %s");
+    }
+    
+    final String buildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type");
+    }
+    
+    final String inheritedBuildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type"
+          + " Inherited method: %s");
+    }
+    
+    final String methodsMustTakeOneArg() {
+      return process("@Component.Builder methods must not have more than one argument");
+    }
+    
+    final String inheritedMethodsMustTakeOneArg() {
+      return process(
+          "@Component.Builder methods must not have more than one argument. Inherited method: %s");
+    }
+    
+    final String methodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + " or a supertype of the builder");
+    }
+    
+    final String inheritedMethodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + "or a supertype of the builder. Inherited method: %s");
+    }
+    
+    final String methodsMayNotHaveTypeParameters() {
+      return process("@Component.Builder methods must not have type parameters");
+    }
+
+    final String inheritedMethodsMayNotHaveTypeParameters() {
+      return process(
+          "@Component.Builder methods must not have type parameters. Inherited method: %s");
+    }
+  }
+
+  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
+    
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
+    }
+
+    String builderMethodRequiresNoArgs() {
+      return "Methods returning a @Subcomponent.Builder must have no arguments";
+    }
+    
+    String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given subcomponent. %s is created by: %s";
+    }
+  }
+
+  /**
+   * A regular expression to match a small list of specific packages deemed to
+   * be unhelpful to display in fully qualified types in error messages.
+   *
+   * Note: This should never be applied to messages themselves.
+   */
+  private static final Pattern COMMON_PACKAGE_PATTERN = Pattern.compile(
+      "(?:^|[^.a-z_])"     // What we want to match on but not capture.
+      + "((?:"             // Start a group with a non-capturing or part
+      + "java[.]lang"
+      + "|java[.]util"
+      + "|javax[.]inject"
+      + "|dagger"
+      + "|com[.]google[.]common[.]base"
+      + "|com[.]google[.]common[.]collect"
+      + ")[.])"            // Always end with a literal .
+      + "[A-Z]");           // What we want to match on but not capture.
+
+  /**
+   * A method to strip out common packages and a few rare type prefixes
+   * from types' string representation before being used in error messages.
+   *
+   * This type assumes a String value that is a valid fully qualified
+   * (and possibly parameterized) type, and should NOT be used with
+   * arbitrary text, especially prose error messages.
+   *
+   * TODO(cgruber): Tighten these to take type representations (mirrors
+   *     and elements) to avoid accidental mis-use by running errors
+   *     through this method.
+   */
+  static String stripCommonTypePrefixes(String type) {
+    // Special case this enum's constants since they will be incredibly common.
+    type = type.replace(Provides.Type.class.getCanonicalName() + ".", "");
+
+    // Do regex magic to remove common packages we care to shorten.
+    Matcher matcher = COMMON_PACKAGE_PATTERN.matcher(type);
+    StringBuilder result = new StringBuilder();
+    int index = 0;
+    while (matcher.find()) {
+      result.append(type.subSequence(index, matcher.start(1)));
+      index = matcher.end(1); // Skip the matched pattern content.
+    }
+    result.append(type.subSequence(index, type.length()));
+    return result.toString();
+  }
+
+  //TODO(cgruber): Extract Formatter and do something less stringy.
+  static String format(AnnotationMirror annotation) {
+    return stripCommonTypePrefixes(annotation.toString());
+  }
+
+  private ErrorMessages() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
new file mode 100644
index 000000000..c7eb6326f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import dagger.MembersInjector;
+import dagger.Provides.Type;
+import dagger.internal.Factory;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.EnumWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
+ * {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+  private final DependencyRequestMapper dependencyRequestMapper;
+  private final Diagnostic.Kind nullableValidationType;
+
+  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper,
+      Diagnostic.Kind nullableValidationType) {
+    super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
+    this.nullableValidationType = nullableValidationType;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ProvisionBinding binding) {
+    return factoryNameForProvisionBinding(binding);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ProvisionBinding binding) {
+    return ImmutableSet.of(binding.bindingElement());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.hasNonDefaultTypeParameters());
+
+    TypeMirror keyType = binding.provisionType().equals(Type.MAP)
+        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
+        : binding.key().type();
+    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+
+    final TypeWriter factoryWriter;
+    final Optional<ConstructorWriter> constructorWriter;
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+     typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
+    }
+    switch (binding.factoryCreationStrategy()) {
+      case ENUM_INSTANCE:
+        EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
+        enumWriter.addConstant("INSTANCE");
+        constructorWriter = Optional.absent();
+        factoryWriter = enumWriter;
+        // If we have type parameters, then remove the parameters from our providedTypeName,
+        // since we'll be implementing an erased version of it.
+        if (!typeParameters.isEmpty()) {
+          factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
+          providedTypeName = ((ParameterizedTypeName) providedTypeName).type();
+        }
+        break;
+      case CLASS_CONSTRUCTOR:
+        ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+        classWriter.addTypeParameters(typeParameters);
+        classWriter.addModifiers(FINAL);
+        constructorWriter = Optional.of(classWriter.addConstructor());
+        constructorWriter.get().addModifiers(PUBLIC);
+        factoryWriter = classWriter;
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
+          TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
+          factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
+          constructorWriter.get().addParameter(enclosingType, "module");
+          constructorWriter.get().body()
+              .addSnippet("assert module != null;")
+              .addSnippet("this.module = module;");
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    factoryWriter.addModifiers(PUBLIC);
+    factoryWriter.addImplementedType(
+        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
+
+    MethodWriter getMethodWriter = factoryWriter.addMethod(providedTypeName, "get");
+    getMethodWriter.annotate(Override.class);
+    getMethodWriter.addModifiers(PUBLIC);
+
+    if (binding.memberInjectionRequest().isPresent()) {
+      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+          MembersInjector.class, providedTypeName);
+      factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
+      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
+      constructorWriter.get().body()
+          .addSnippet("assert membersInjector != null;")
+          .addSnippet("this.membersInjector = membersInjector;");
+    }
+
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.dependencies());
+
+    for (FrameworkField bindingField : fields.values()) {
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.get().addParameter(field.type(), field.name());
+      constructorWriter.get().body()
+          .addSnippet("assert %s != null;", field.name())
+          .addSnippet("this.%1$s = %1$s;", field.name());
+    }
+
+    // If constructing a factory for @Inject or @Provides bindings, we use a static create method
+    // so that generated components can avoid having to refer to the generic types
+    // of the factory.  (Otherwise they may have visibility problems referring to the types.)
+    switch(binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        // The return type is usually the same as the implementing type, except in the case
+        // of enums with type variables (where we cast).
+        TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(keyType));
+        MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
+        createMethodWriter.addTypeParameters(typeParameters);
+        createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+        Map<String, TypeName> params = constructorWriter.isPresent()
+            ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
+        for (Map.Entry<String, TypeName> param : params.entrySet()) {
+          createMethodWriter.addParameter(param.getValue(), param.getKey());
+        }
+        switch (binding.factoryCreationStrategy()) {
+          case ENUM_INSTANCE:
+            if (typeParameters.isEmpty()) {
+              createMethodWriter.body().addSnippet("return INSTANCE;");
+            } else {
+              // We use an unsafe cast here because the types are different.
+              // It's safe because the type is never referenced anywhere.
+              createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+              createMethodWriter.body().addSnippet("return (Factory) INSTANCE;");
+            }
+            break;
+          case CLASS_CONSTRUCTOR:
+            createMethodWriter.body().addSnippet("return new %s(%s);",
+                parameterizedFactoryNameForProvisionBinding(binding),
+                Joiner.on(", ").join(params.keySet()));
+            break;
+          default:
+            throw new AssertionError();
+        }
+        break;
+      default: // do nothing.
+    }
+
+    List<Snippet> parameters = Lists.newArrayList();
+    for (DependencyRequest dependency : binding.dependencies()) {
+      parameters.add(frameworkTypeUsageStatement(
+          Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+    }
+    Snippet parametersSnippet = makeParametersSnippet(parameters);
+
+    if (binding.bindingKind().equals(PROVISION)) {
+      Snippet providesMethodInvocation = Snippet.format("%s.%s(%s)",
+          binding.bindingElement().getModifiers().contains(STATIC)
+              ? ClassName.fromTypeElement(binding.bindingTypeElement())
+              : "module",
+          binding.bindingElement().getSimpleName(),
+          parametersSnippet);
+
+      if (binding.provisionType().equals(SET)) {
+        TypeName paramTypeName = TypeNames.forTypeMirror(
+            MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
+        // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
+        getMethodWriter.body().addSnippet("return %s.<%s>singleton(%s);",
+            ClassName.fromClass(Collections.class), paramTypeName, providesMethodInvocation);
+      } else if (binding.nullableType().isPresent()
+          || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+        if (binding.nullableType().isPresent()) {
+          getMethodWriter.annotate(
+              (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
+        }
+        getMethodWriter.body().addSnippet("return %s;", providesMethodInvocation);
+      } else {
+        StringLiteral failMsg =
+            StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+        getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "%s provided = %s;",
+            "if (provided == null) {",
+            "  throw new NullPointerException(%s);",
+            "}",
+            "return provided;"),
+            getMethodWriter.returnType(),
+            providesMethodInvocation,
+            failMsg));
+      }
+    } else if (binding.memberInjectionRequest().isPresent()) {
+      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
+          providedTypeName, parametersSnippet);
+      getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
+      getMethodWriter.body().addSnippet("return instance;");
+    } else {
+      getMethodWriter.body()
+          .addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
+    }
+
+    // TODO(gak): write a sensible toString
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
new file mode 100644
index 000000000..880b78705
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+
+/**
+ * A formatter which transforms an instance of a particular type into a string
+ * representation.
+ *
+ * @param <T> the type of the object to be transformed.
+ * @author Christian Gruber
+ * @since 2.0
+ */
+abstract class Formatter<T> implements Function<T, String> {
+
+  /**
+   * Performs the transformation of an object into a string representation.
+   */
+  public abstract String format(T object);
+
+  /**
+   * Performs the transformation of an object into a string representation in
+   * conformity with the {@link Function}{@code <T, String>} contract, delegating
+   * to {@link #format(Object)}.
+   *
+   * @deprecated Call {@link #format(T)} instead.  This method exists to make
+   * formatters easy to use when functions are required, but shouldn't be called directly.
+   */
+  @SuppressWarnings("javadoc")
+  @Deprecated
+  @Override final public String apply(T object) {
+    return format(object);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
new file mode 100644
index 000000000..f6b207c09
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A value object that represents a field used by Dagger-generated code.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+@AutoValue
+abstract class FrameworkField {
+  // TODO(gak): reexamine the this class and how consistently we're using it and its creation
+  // methods
+
+  static FrameworkField createWithTypeFromKey(
+      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+    String suffix = frameworkClass.getSimpleName();
+    ParameterizedTypeName frameworkType = ParameterizedTypeName.create(
+        ClassName.fromClass(frameworkClass),
+        TypeNames.forTypeMirror(bindingKey.key().type()));
+    return new AutoValue_FrameworkField(frameworkClass, frameworkType, bindingKey,
+        name.endsWith(suffix) ? name : name + suffix);
+  }
+
+  static FrameworkField createForMapBindingContribution(
+      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+    TypeMirror mapValueType =
+        MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
+    return new AutoValue_FrameworkField(frameworkClass,
+        TypeNames.forTypeMirror(mapValueType),
+        bindingKey,
+        name);
+  }
+
+  abstract Class<?> frameworkClass();
+  abstract TypeName frameworkType();
+  abstract BindingKey bindingKey();
+  abstract String name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
deleted file mode 100644
index 3c194c5a8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.SetBinding;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-import javax.tools.FileObject;
-import javax.tools.JavaFileManager;
-import javax.tools.StandardLocation;
-
-/**
- * Performs full graph analysis on a module.
- */
-@SupportedAnnotationTypes("dagger.Module")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
-public final class FullGraphProcessor extends AbstractProcessor {
-  private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
-
-  /**
-   * Perform full-graph analysis on complete modules. This checks that all of
-   * the module's dependencies are satisfied.
-   */
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    if (!env.processingOver()) {
-      // Storing module names for later retrieval as the element instance is invalidated across
-      // passes.
-      for (Element e : env.getElementsAnnotatedWith(Module.class)) {
-        delayedModuleNames.add(((TypeElement) e).getQualifiedName().toString());
-      }
-      return true;
-    }
-
-    Set<Element> modules = new LinkedHashSet<Element>();
-    for (String moduleName : delayedModuleNames) {
-      modules.add(processingEnv.getElementUtils().getTypeElement(moduleName));
-    }
-
-    for (Element element : modules) {
-      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, element);
-      if (!annotation.get("complete").equals(Boolean.TRUE)) {
-        continue;
-      }
-      TypeElement moduleType = (TypeElement) element;
-      Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
-      try {
-        writeDotFile(moduleType, bindings);
-      } catch (IOException e) {
-        error("Graph processing failed: " + e, moduleType);
-      }
-    }
-    return true;
-  }
-
-  private void error(String message, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
-  }
-
-  private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
-    Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
-    collectIncludesRecursively(rootModule, allModules);
-
-    Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
-        new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
-    // Linker requires synchronization for calls to requestBinding and linkAll.
-    // We know statically that we're single threaded, but we synchronize anyway
-    // to make the linker happy.
-    synchronized (linker) {
-      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
-      for (TypeElement module : allModules.values()) {
-        Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-        boolean overrides = (Boolean) annotation.get("overrides");
-        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
-
-        // Gather the entry points from the annotation.
-        for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
-          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
-              module.getQualifiedName().toString(), false);
-        }
-
-        // Gather the static injections.
-        // TODO.
-
-        // Gather the enclosed @Provides methods.
-        for (Element enclosed : module.getEnclosedElements()) {
-          Provides provides = enclosed.getAnnotation(Provides.class);
-          if (provides == null) {
-            continue;
-          }
-          ExecutableElement providerMethod = (ExecutableElement) enclosed;
-          String key = GeneratorKeys.get(providerMethod);
-          ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
-          switch (provides.type()) {
-            case UNIQUE:
-              ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
-              if (clobbered != null) {
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-                    "Duplicate bindings for " + key
-                        + ": " + shortMethodName(clobbered.method)
-                        + ", " + shortMethodName(binding.method),
-                    binding.method);
-              }
-              break;
-
-            case SET:
-              String elementKey = GeneratorKeys.getElementKey(providerMethod);
-              SetBinding.add(addTo, elementKey, binding);
-              break;
-
-            default:
-              throw new AssertionError("Unknown @Provides type " + provides.type());
-          }
-        }
-      }
-
-      linker.installBindings(baseBindings);
-      linker.installBindings(overrideBindings);
-
-      // Link the bindings. This will traverse the dependency graph, and report
-      // errors if any dependencies are missing.
-      return linker.linkAll();
-    }
-  }
-
-  private String shortMethodName(ExecutableElement method) {
-    return method.getEnclosingElement().getSimpleName().toString()
-        + "." + method.getSimpleName() + "()";
-  }
-
-  private void collectIncludesRecursively(TypeElement module, Map<String, TypeElement> result) {
-    // Add the module.
-    result.put(module.getQualifiedName().toString(), module);
-
-    // Recurse for each included module.
-    Types typeUtils = processingEnv.getTypeUtils();
-    Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-    List<Object> seedModules = new ArrayList<Object>();
-    seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
-    if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
-    for (Object include : seedModules) {
-      if (!(include instanceof TypeMirror)) {
-        // TODO(tbroyer): pass annotation information
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value for include: " + include + " in " + module, module);
-        continue;
-      }
-      TypeElement includedModule = (TypeElement) typeUtils.asElement((TypeMirror) include);
-      collectIncludesRecursively(includedModule, result);
-    }
-  }
-
-  static class ProviderMethodBinding extends Binding<Object> {
-    private final ExecutableElement method;
-    private final Binding<?>[] parameters;
-
-    protected ProviderMethodBinding(String provideKey, ExecutableElement method) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, method.toString());
-      this.method = method;
-      this.parameters = new Binding[method.getParameters().size()];
-    }
-
-    @Override public void attach(Linker linker) {
-      for (int i = 0; i < method.getParameters().size(); i++) {
-        VariableElement parameter = method.getParameters().get(i);
-        String parameterKey = GeneratorKeys.get(parameter);
-        parameters[i] = linker.requestBinding(parameterKey, method.toString());
-      }
-    }
-
-    @Override public Object get() {
-      throw new AssertionError("Compile-time binding should never be called to inject.");
-    }
-
-    @Override public void injectMembers(Object t) {
-      throw new AssertionError("Compile-time binding should never be called to inject.");
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding<?> binding : parameters) {
-        get.add(binding);
-      }
-    }
-  }
-
-  void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
-    JavaFileManager.Location location = StandardLocation.SOURCE_OUTPUT;
-    String path = CodeGen.getPackage(module).getQualifiedName().toString();
-    String file = module.getQualifiedName().toString().substring(path.length() + 1) + ".dot";
-    FileObject resource = processingEnv.getFiler().createResource(location, path, file, module);
-
-    Writer writer = resource.openWriter();
-    DotWriter dotWriter = new DotWriter(writer);
-    new GraphVisualizer().write(bindings, dotWriter);
-    dotWriter.close();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
deleted file mode 100644
index f93220c42..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
- * APIs not available on Android.
- */
-final class GeneratorKeys {
-  private static final String SET_PREFIX = Set.class.getName() + "<";
-
-  private GeneratorKeys() {
-  }
-
-  /**
-   * Returns the members injector key for the raw type of {@code type}.
-   * Parameterized types are not currently supported for members injection in
-   * generated code.
-   */
-  public static String rawMembersKey(TypeMirror type) {
-    return "members/" + CodeGen.rawTypeToString(type, '$');
-  }
-
-  /** Returns the provider key for {@code type}. */
-  public static String get(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    CodeGen.typeToString(type, result, '$');
-    return result.toString();
-  }
-
-  /** Returns the provided key for {@code method}. */
-  public static String get(ExecutableElement method) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    CodeGen.typeToString(method.getReturnType(), result, '$');
-    return result.toString();
-  }
-
-  /** Returns the provided key for {@code method} wrapped by {@code Set}. */
-  public static String getElementKey(ExecutableElement method) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    result.append(SET_PREFIX);
-    CodeGen.typeToString(method.getReturnType(), result, '$');
-    result.append(">");
-    return result.toString();
-  }
-
-  /** Returns the provider key for {@code variable}. */
-  public static String get(VariableElement variable) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(variable.getAnnotationMirrors(), variable);
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    CodeGen.typeToString(variable.asType(), result, '$');
-    return result.toString();
-  }
-
-  private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
-    // TODO: guarantee that element values are sorted by name (if there are multiple)
-    result.append('@');
-    CodeGen.typeToString(qualifier.getAnnotationType(), result, '$');
-    result.append('(');
-    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
-        : qualifier.getElementValues().entrySet()) {
-      result.append(entry.getKey().getSimpleName());
-      result.append('=');
-      result.append(entry.getValue().getValue());
-    }
-    result.append(")/");
-  }
-
-  private static AnnotationMirror getQualifier(
-      List<? extends AnnotationMirror> annotations, Object member) {
-    AnnotationMirror qualifier = null;
-    for (AnnotationMirror annotation : annotations) {
-      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
-        continue;
-      }
-      if (qualifier != null) {
-        throw new IllegalArgumentException("Too many qualifier annotations on " + member);
-      }
-      qualifier = annotation;
-    }
-    return qualifier;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
deleted file mode 100644
index 8d8070bd3..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Binding;
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Emits an object graph in dot format.
- */
-public final class GraphVisualizer {
-  private static final Pattern KEY_PATTERN = Pattern.compile(""
-      + "(?:@"            // Full annotation start.
-      + "(?:[\\w$]+\\.)*" // Annotation package
-      + "([\\w$]+)"       // Annotation simple name. Group 1.
-      + "(?:\\(.*\\))?"   // Annotation arguments
-      + "/)?"             // Full annotation end.
-      + "(?:members/)?"   // Members prefix.
-      + "(?:[\\w$]+\\.)*" // Type package.
-      + "([\\w$]+)"       // Type simple name. Group 2.
-      + "(\\<[^/]+\\>)?"  // Type parameters. Group 3.
-      + "((\\[\\])*)"     // Arrays. Group 4.
-      + "");
-
-  public void write(Map<String, Binding<?>> bindings, DotWriter writer) throws IOException {
-    Map<Binding<?>, String> namesIndex = buildNamesIndex(bindings);
-
-    writer.beginGraph("concentrate", "true");
-    for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
-      Binding<?> sourceBinding = entry.getKey();
-      String sourceName = entry.getValue();
-      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
-      sourceBinding.getDependencies(dependencies, dependencies);
-      for (Binding<?> targetBinding : dependencies) {
-        String targetName = namesIndex.get(targetBinding);
-        if (targetName == null) {
-          targetName = "Unbound:" + targetBinding.provideKey;
-        }
-        writer.edge(sourceName, targetName);
-      }
-    }
-    writer.endGraph();
-  }
-
-  private Map<Binding<?>, String> buildNamesIndex(Map<String, Binding<?>> bindings) {
-    // Optimistically shorten each binding to the class short name; remembering collisions.
-    Map<String, Binding<?>> shortNameToBinding = new TreeMap<String, Binding<?>>();
-    Set<Binding<?>> collisions = new HashSet<Binding<?>>();
-    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
-      String key = entry.getKey();
-      Binding<?> binding = entry.getValue();
-      String shortName = shortName(key);
-      Binding<?> collision = shortNameToBinding.put(shortName, binding);
-      if (collision != null && collision != binding) {
-        collisions.add(binding);
-        collisions.add(collision);
-      }
-    }
-
-    // Replace collisions with full names.
-    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
-      Binding<?> binding = entry.getValue();
-      if (collisions.contains(binding)) {
-        String key = entry.getKey();
-        String shortName = shortName(key);
-        shortNameToBinding.remove(shortName);
-        shortNameToBinding.put(key, binding);
-      }
-    }
-
-    // Reverse the map.
-    Map<Binding<?>, String> bindingToName = new LinkedHashMap<Binding<?>, String>();
-    for (Map.Entry<String, Binding<?>> entry : shortNameToBinding.entrySet()) {
-      bindingToName.put(entry.getValue(), entry.getKey());
-    }
-
-    return bindingToName;
-  }
-
-  String shortName(String key) {
-    Matcher matcher = KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) throw new IllegalArgumentException("Unexpected key: " + key);
-    StringBuilder result = new StringBuilder();
-
-    String annotationSimpleName = matcher.group(1);
-    if (annotationSimpleName != null) {
-      result.append('@').append(annotationSimpleName).append(' ');
-    }
-
-    String simpleName = matcher.group(2);
-    result.append(simpleName);
-
-    String typeParameters = matcher.group(3);
-    if (typeParameters != null) {
-      result.append(typeParameters);
-    }
-
-    String arrays = matcher.group(4);
-    if (arrays != null) {
-      result.append(arrays);
-    }
-
-    return result.toString();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
new file mode 100644
index 000000000..09a7f1b21
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Maintains the collection of provision bindings from {@link Inject} constructors and members
+ * injection bindings from {@link Inject} fields and methods known to the annotation processor.
+ * Note that this registry <b>does not</b> handle any explicit bindings (those from {@link Provides}
+ * methods, {@link Component} dependencies, etc.).
+ *
+ * @author Gregory Kick
+ */
+final class InjectBindingRegistry {
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+
+  final class BindingsCollection<B extends Binding> {
+    private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
+    private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
+    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+
+    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+      for (B binding = bindingsRequiringGeneration.poll();
+          binding != null;
+          binding = bindingsRequiringGeneration.poll()) {
+        checkState(!binding.hasNonDefaultTypeParameters());
+        generator.generate(binding);
+        materializedBindings.add(binding);
+      }
+    }
+
+    /** Returns a previously cached binding. */
+    B getBinding(Key key) {
+      return bindingsByKey.get(key);
+    }
+
+    /** Caches the binding and pretends a binding is generated without actually generating it. */
+    B pretendBindingGenerated(B binding, ClassName factoryName) {
+      tryToCacheBinding(binding);
+      if (shouldGenerateBinding(binding, factoryName)) {
+        materializedBindings.add(binding);
+      }
+      return binding;
+    }
+
+    /** Caches the binding and generates it if it needs generation. */
+    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+      tryToCacheBinding(binding);
+      tryToGenerateBinding(binding, factoryName, explicit);
+    }
+    
+    /**
+     * Tries to generate a binding, not generating if it already is generated. For resolved
+     * bindings, this will try to generate the unresolved version of the binding.
+     */
+    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
+      if (shouldGenerateBinding(binding, factoryName)) {
+        bindingsRequiringGeneration.offer(binding);
+        if (!explicit) {
+          messager.printMessage(Kind.NOTE, String.format(
+              "Generating a MembersInjector or Factory for %s. "
+                    + "Prefer to run the dagger processor over that class instead.",
+              types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
+        }
+      }
+    }
+    
+    /** Returns true if the binding needs to be generated. */
+    private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
+      return !binding.hasNonDefaultTypeParameters()
+          && elements.getTypeElement(factoryName.canonicalName()) == null
+          && !materializedBindings.contains(binding)
+          && !bindingsRequiringGeneration.contains(binding);
+        
+    }
+
+    /** Caches the binding for future lookups by key. */
+    private void tryToCacheBinding(B binding) {
+      // We only cache resolved bindings or unresolved bindings w/o type arguments.
+      // Unresolved bindings w/ type arguments aren't valid for the object graph.
+      if (binding.hasNonDefaultTypeParameters()          
+          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {        
+        Key key = binding.key();
+        Binding previousValue = bindingsByKey.put(key, binding);
+        checkState(previousValue == null || binding.equals(previousValue),
+            "couldn't register %s. %s was already registered for %s",
+            binding, previousValue, key);
+      }
+    }
+  }
+
+  private final BindingsCollection<ProvisionBinding> provisionBindings = new BindingsCollection<>();
+  private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
+      new BindingsCollection<>();
+
+  InjectBindingRegistry(Elements elements,
+      Types types,
+      Messager messager,
+      ProvisionBinding.Factory provisionBindingFactory,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+  }
+
+  /**
+   * This method ensures that sources for all registered {@link Binding bindings} (either
+   * {@linkplain #registerBinding explicitly} or implicitly via
+   * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
+   */
+  void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
+      MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
+    provisionBindings.generateBindings(factoryGenerator);
+    membersInjectionBindings.generateBindings(membersInjectorGenerator);
+  }
+
+  ProvisionBinding registerBinding(ProvisionBinding binding) {
+    return registerBinding(binding, true);
+  }
+
+  MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
+    return registerBinding(binding, true);
+  }
+
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
+  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
+    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
+    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
+    if (binding.hasNonDefaultTypeParameters()) {
+      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
+          factoryName, explicit);
+    }
+    return binding;
+  }
+
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
+  private MembersInjectionBinding registerBinding(
+      MembersInjectionBinding binding, boolean explicit) {
+    ClassName membersInjectorName =
+        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    if (binding.injectionSites().isEmpty()) {
+      // empty members injection bindings are special and don't need source files.
+      // so, we just pretend
+      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
+      if (binding.hasNonDefaultTypeParameters()) {
+        membersInjectionBindings.pretendBindingGenerated(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
+      }
+    } else {
+      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+      if (binding.hasNonDefaultTypeParameters()) {
+        membersInjectionBindings.tryToGenerateBinding(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
+      }
+    }
+    return binding;
+  }
+
+  Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
+    checkNotNull(key);
+    if (!key.isValidImplicitProvisionKey(types)) {
+      return Optional.absent();
+    }
+    ProvisionBinding binding = provisionBindings.getBinding(key);
+    if (binding != null) {
+      return Optional.of(binding);
+    }
+    
+    // ok, let's see if we can find an @Inject constructor
+    TypeElement element = MoreElements.asType(types.asElement(key.type()));
+    List<ExecutableElement> constructors =
+        ElementFilter.constructorsIn(element.getEnclosedElements());
+    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
+        .filter(new Predicate<ExecutableElement>() {
+          @Override public boolean apply(ExecutableElement input) {
+            return isAnnotationPresent(input, Inject.class);
+          }
+        }).toSet();
+    switch (injectConstructors.size()) {
+      case 0:
+        // No constructor found.
+        return Optional.absent();
+      case 1:
+        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
+            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
+        return Optional.of(registerBinding(constructorBinding, false));
+      default:
+        throw new IllegalStateException("Found multiple @Inject constructors: "
+            + injectConstructors);
+    }
+  }
+
+  MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
+    checkNotNull(key);
+    // TODO(gak): is checking the kind enough?
+    checkArgument(key.isValidMembersInjectionKey());
+    MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
+    if (binding != null) {
+      return binding;
+    }
+    return registerBinding(membersInjectionBindingFactory.forInjectedType(
+        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
new file mode 100644
index 000000000..ac4f914e3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * A {@link Validator} for {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectConstructorValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(constructorElement);
+    if (constructorElement.getModifiers().contains(PRIVATE)) {
+      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+    }
+
+    for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
+      builder.addItem(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+    }
+
+    for (VariableElement parameter : constructorElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+        }
+      }
+    }
+
+    TypeElement enclosingElement =
+        MoreElements.asType(constructorElement.getEnclosingElement());
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
+
+    if (typeModifiers.contains(PRIVATE)) {
+      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    }
+
+    if (typeModifiers.contains(ABSTRACT)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+    }
+
+    if (enclosingElement.getNestingKind().isNested()
+        && !typeModifiers.contains(STATIC)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+    }
+
+    // This is computationally expensive, but probably preferable to a giant index
+    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
+        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override public boolean apply(ExecutableElement input) {
+                return isAnnotationPresent(input, Inject.class);
+              }
+            });
+
+    if (injectConstructors.size() > 1) {
+      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
+    if (scopes.size() > 1) {
+      for (AnnotationMirror scope : scopes) {
+        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
new file mode 100644
index 000000000..1841290ea
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+/**
+ * A {@link Validator} for {@link Inject} fields.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectFieldValidator implements Validator<VariableElement> {
+  @Override
+  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder =
+        ValidationReport.Builder.about(fieldElement);
+    Set<Modifier> modifiers = fieldElement.getModifiers();
+    if (modifiers.contains(FINAL)) {
+      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
new file mode 100644
index 000000000..9454f230e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+/**
+ * A {@link Validator} for {@link Inject} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectMethodValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(methodElement);
+    Set<Modifier> modifiers = methodElement.getModifiers();
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+    }
+
+    if (!methodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+    }
+
+    for (VariableElement parameter : methodElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        }
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
new file mode 100644
index 000000000..faa69dc5f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the {@link Inject}
+ * annotation.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+  private final Messager messager;
+  private final InjectConstructorValidator constructorValidator;
+  private final InjectFieldValidator fieldValidator;
+  private final InjectMethodValidator methodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final InjectBindingRegistry injectBindingRegistry;
+
+  InjectProcessingStep(Messager messager,
+      InjectConstructorValidator constructorValidator,
+      InjectFieldValidator fieldValidator,
+      InjectMethodValidator methodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      InjectBindingRegistry factoryRegistrar) {
+    this.messager = messager;
+    this.constructorValidator = constructorValidator;
+    this.fieldValidator = fieldValidator;
+    this.methodValidator = methodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.injectBindingRegistry = factoryRegistrar;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Inject.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    // TODO(gak): add some error handling for bad source files
+    final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
+    // TODO(gak): instead, we should collect reports by type and check later
+    final ImmutableSet.Builder<DeclaredType> membersInjectedTypes = ImmutableSet.builder();
+
+    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
+      injectElement.accept(
+          new ElementKindVisitor6<Void, Void>() {
+            @Override
+            public Void visitExecutableAsConstructor(
+                ExecutableElement constructorElement, Void v) {
+              ValidationReport<ExecutableElement> report =
+                  constructorValidator.validate(constructorElement);
+
+              report.printMessagesTo(messager);
+
+              if (report.isClean()) {
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
+                    Optional.<TypeMirror>absent()));
+              }
+
+              return null;
+            }
+
+            @Override
+            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
+
+              report.printMessagesTo(messager);
+
+              if (report.isClean()) {
+                membersInjectedTypes.add(
+                    MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
+              }
+
+              return null;
+            }
+
+            @Override
+            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+              ValidationReport<ExecutableElement> report =
+                  methodValidator.validate(methodElement);
+
+              report.printMessagesTo(messager);
+
+              if (report.isClean()) {
+                membersInjectedTypes.add(
+                    MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
+              }
+
+              return null;
+            }
+          }, null);
+    }
+
+    for (DeclaredType injectedType : membersInjectedTypes.build()) {
+      injectBindingRegistry.registerBinding(membersInjectionBindingFactory.forInjectedType(
+          injectedType, Optional.<TypeMirror>absent()));
+    }
+
+    for (ProvisionBinding binding : provisions.build()) {
+      injectBindingRegistry.registerBinding(binding);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
deleted file mode 100644
index 0fb56ff39..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ /dev/null
@@ -1,459 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.MembersInjector;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PUBLIC;
-
-/**
- * Generates an implementation of {@link Binding} that injects the
- * {@literal @}{@code Inject}-annotated members of a class.
- */
-@SupportedAnnotationTypes("javax.inject.Inject")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
-public final class InjectProcessor extends AbstractProcessor {
-  private final Set<String> remainingTypeNames = new LinkedHashSet<String>();
-
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    remainingTypeNames.addAll(getInjectedClassNames(env));
-    for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
-      InjectedClass injectedClass = getInjectedClass(i.next());
-      // Verify that we have access to all types to be injected on this pass.
-      boolean missingDependentClasses =
-          !allTypesExist(injectedClass.fields)
-          || (injectedClass.constructor != null && !allTypesExist(injectedClass.constructor
-              .getParameters()))
-          || !allTypesExist(injectedClass.staticFields);
-      if (!missingDependentClasses) {
-        try {
-          writeInjectionsForClass(injectedClass);
-        } catch (IOException e) {
-          error("Code gen failed: " + e, injectedClass.type);
-        }
-        i.remove();
-      }
-    }
-    if (env.processingOver() && !remainingTypeNames.isEmpty()) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-          "Could not find injection type required by " + remainingTypeNames);
-    }
-    return true;
-  }
-
-  private void writeInjectionsForClass(InjectedClass injectedClass) throws IOException {
-    if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
-      writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
-    }
-    if (!injectedClass.staticFields.isEmpty()) {
-      writeStaticInjection(injectedClass.type, injectedClass.staticFields);
-    }
-  }
-
-  /**
-   * Return true if all element types are currently available in this code
-   * generation pass. Unavailable types will be of kind {@link TypeKind#ERROR}.
-   */
-  private boolean allTypesExist(Collection<? extends Element> elements) {
-    for (Element element : elements) {
-      if (element.asType().getKind() == TypeKind.ERROR) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private Set<String> getInjectedClassNames(RoundEnvironment env) {
-    // First gather the set of classes that have @Inject-annotated members.
-    Set<String> injectedTypeNames = new LinkedHashSet<String>();
-    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      TypeMirror type = element.getEnclosingElement().asType();
-      injectedTypeNames.add(CodeGen.rawTypeToString(type, '.'));
-    }
-    return injectedTypeNames;
-  }
-
-  /**
-   * @param injectedClassName the name of a class with an @Inject-annotated member.
-   */
-  private InjectedClass getInjectedClass(String injectedClassName) {
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
-    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
-    List<Element> staticFields = new ArrayList<Element>();
-    ExecutableElement constructor = null;
-    List<Element> fields = new ArrayList<Element>();
-    for (Element member : type.getEnclosedElements()) {
-      if (member.getAnnotation(Inject.class) == null) {
-        continue;
-      }
-
-      switch (member.getKind()) {
-        case FIELD:
-          if (member.getModifiers().contains(Modifier.STATIC)) {
-            staticFields.add(member);
-          } else {
-            fields.add(member);
-          }
-          break;
-        case CONSTRUCTOR:
-          if (constructor != null) {
-            // TODO(tbroyer): pass annotation information
-            error("Too many injectable constructors on " + type.getQualifiedName(), member);
-          } else if (isAbstract) {
-            // TODO(tbroyer): pass annotation information
-            error("Abstract class " + type.getQualifiedName()
-                + " must not have an @Inject-annotated constructor.", member);
-          }
-          constructor = (ExecutableElement) member;
-          break;
-        default:
-          // TODO(tbroyer): pass annotation information
-          error("Cannot inject " + member, member);
-          break;
-      }
-    }
-
-    if (constructor == null && !isAbstract) {
-      constructor = findNoArgsConstructor(type);
-    }
-
-    return new InjectedClass(type, staticFields, constructor, fields);
-  }
-
-  /**
-   * Returns the no args constructor for {@code typeElement}, or null if no such
-   * constructor exists.
-   */
-  private ExecutableElement findNoArgsConstructor(TypeElement typeElement) {
-    for (Element element : typeElement.getEnclosedElements()) {
-      if (element.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) element;
-      if (constructor.getParameters().isEmpty()) {
-        if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-          return null;
-        } else {
-          return constructor;
-        }
-      }
-    }
-    return null;
-  }
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
-  /**
-   * Write a companion class for {@code type} that extends {@link Binding}.
-   *
-   * @param constructor the injectable constructor, or null if this binding
-   *     supports members injection only.
-   */
-  private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
-      List<Element> fields) throws IOException {
-    String packageName = CodeGen.getPackage(type).getQualifiedName().toString();
-    String strippedTypeName = strippedTypeName(type.getQualifiedName().toString(), packageName);
-    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
-    String adapterName = CodeGen.adapterName(type, INJECT_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
-    boolean injectMembers = !fields.isEmpty() || supertype != null;
-    boolean disambiguateFields = !fields.isEmpty()
-        && (constructor != null)
-        && !constructor.getParameters().isEmpty();
-    boolean dependent = injectMembers
-        || ((constructor != null) && !constructor.getParameters().isEmpty());
-
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(packageName);
-    writer.emitEmptyLine();
-    writer.emitImports(getImports(dependent, injectMembers, constructor != null));
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(binderTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
-    writer.beginType(adapterName, "class", PUBLIC | FINAL,
-        CodeGen.parameterizedType(Binding.class, strippedTypeName),
-        interfaces(strippedTypeName, injectMembers, constructor != null));
-
-    if (constructor != null) {
-      for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitField(CodeGen.parameterizedType(Binding.class,
-            CodeGen.typeToString(parameter.asType())),
-            parameterName(disambiguateFields, parameter), PRIVATE);
-      }
-    }
-    for (Element field : fields) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
-          CodeGen.typeToString(field.asType())),
-          fieldName(disambiguateFields, field), PRIVATE);
-    }
-    if (supertype != null) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
-          CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
-    }
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, PUBLIC);
-    String key = (constructor != null)
-        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
-        : null;
-    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
-    boolean singleton = type.getAnnotation(Singleton.class) != null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
-    writer.endMethod();
-    if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-      if (constructor != null) {
-        for (VariableElement parameter : constructor.getParameters()) {
-          writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
-              parameterName(disambiguateFields, parameter),
-              writer.compressType(CodeGen.parameterizedType(Binding.class,
-                  CodeGen.typeToString(parameter.asType()))),
-              JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
-              strippedTypeName);
-        }
-      }
-      for (Element field : fields) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
-            fieldName(disambiguateFields, field),
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
-                CodeGen.typeToString(field.asType()))),
-            JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
-            strippedTypeName);
-      }
-      if (supertype != null) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
-            "supertype",
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
-                CodeGen.rawTypeToString(supertype, '.'))),
-            JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
-            strippedTypeName);
-      }
-      writer.endMethod();
-
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-          setOfBindings, "injectMembersBindings");
-      if (constructor != null) {
-        for (Element parameter : constructor.getParameters()) {
-          writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
-        }
-      }
-      for (Element field : fields) {
-        writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
-      }
-      if (supertype != null) {
-        writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
-      }
-      writer.endMethod();
-    }
-
-    if (constructor != null) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, strippedTypeName);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod(strippedTypeName, "get", PUBLIC);
-      StringBuilder newInstance = new StringBuilder();
-      newInstance.append(strippedTypeName).append(" result = new ");
-      newInstance.append(strippedTypeName).append('(');
-      boolean first = true;
-      for (VariableElement parameter : constructor.getParameters()) {
-        if (!first) newInstance.append(", ");
-        else first = false;
-        newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
-      }
-      newInstance.append(')');
-      writer.emitStatement(newInstance.toString());
-      if (injectMembers) {
-        writer.emitStatement("injectMembers(result)");
-      }
-      writer.emitStatement("return result");
-      writer.endMethod();
-    }
-
-    if (injectMembers) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
-      for (Element field : fields) {
-        writer.emitStatement("object.%s = %s.get()", field.getSimpleName(),
-            fieldName(disambiguateFields, field));
-      }
-      if (supertype != null) {
-        writer.emitStatement("supertype.injectMembers(object)");
-      }
-      writer.endMethod();
-    }
-
-    writer.endType();
-    writer.close();
-  }
-
-  private String[] interfaces(String strippedTypeName, boolean hasFields, boolean isProvider) {
-    List<String> interfaces = new ArrayList<String>();
-    if (isProvider) {
-      interfaces.add(CodeGen.parameterizedType(Provider.class, strippedTypeName));
-    }
-    if (hasFields) {
-      interfaces.add(CodeGen.parameterizedType(MembersInjector.class, strippedTypeName));
-    }
-    return interfaces.toArray(new String[0]);
-  }
-
-  private Set<String> getImports(boolean dependent, boolean injectMembers, boolean isProvider) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getName());
-    if (dependent) {
-      imports.add(Linker.class.getName());
-      imports.add(Set.class.getName());
-    }
-    if (injectMembers) imports.add(MembersInjector.class.getName());
-    if (isProvider) imports.add(Provider.class.getName());
-    return imports;
-  }
-
-  private String strippedTypeName(String type, String packageName) {
-    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
-  }
-
-  /**
-   * Write a companion class for {@code type} that extends {@link StaticInjection}.
-   */
-  private void writeStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
-    String adapterName = CodeGen.adapterName(type, STATIC_INJECTION_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-
-    writer.emitEmptyLine();
-    writer.emitImports(CodeGen.setOf(
-        StaticInjection.class.getName(),
-        Binding.class.getName(),
-        Linker.class.getName()));
-
-    writer.emitEmptyLine();
-
-    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
-
-    for (Element field : fields) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
-          CodeGen.typeToString(field.asType())),
-          fieldName(false, field), PRIVATE);
-    }
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-    for (Element field : fields) {
-      writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          fieldName(false, field),
-          writer.compressType(CodeGen.parameterizedType(Binding.class,
-              CodeGen.typeToString(field.asType()))),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
-          typeName);
-    }
-    writer.endMethod();
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECT_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "inject", PUBLIC);
-    for (Element field : fields) {
-      writer.emitStatement("%s.%s = %s.get()",
-          writer.compressType(typeName),
-          field.getSimpleName().toString(),
-          fieldName(false, field));
-    }
-    writer.endMethod();
-
-    writer.endType();
-    writer.close();
-  }
-
-  private String fieldName(boolean disambiguateFields, Element field) {
-    return (disambiguateFields ? "field_" : "") + field.getSimpleName().toString();
-  }
-
-  private String parameterName(boolean disambiguateFields, Element parameter) {
-    return (disambiguateFields ? "parameter_" : "") + parameter.getSimpleName().toString();
-  }
-
-  static class InjectedClass {
-    final TypeElement type;
-    final List<Element> staticFields;
-    final ExecutableElement constructor;
-    final List<Element> fields;
-
-    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor,
-        List<Element> fields) {
-      this.type = type;
-      this.staticFields = staticFields;
-      this.constructor = constructor;
-      this.fields = fields;
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
new file mode 100644
index 000000000..b3b245dfb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utilities relating to annotations defined in the {@code javax.inject} package.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectionAnnotations {
+  static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
+    checkNotNull(e);
+    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(e);
+    switch (scopeAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(scopeAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Scope annotation");
+    }
+  }
+
+  static Optional<AnnotationMirror> getQualifier(Element e) {
+    checkNotNull(e);
+    ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
+    switch (qualifierAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Qualifier annotation");
+    }
+  }
+
+  static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
+  }
+
+  static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
+  }
+
+  private InjectionAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
deleted file mode 100644
index a1ffc2f2a..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ /dev/null
@@ -1,585 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Emits Java source files.
- *
- * @author Jesse Wilson
- */
-public final class JavaWriter implements Closeable {
-  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w$]+)");
-  private static final String INDENT = "  ";
-
-  /** Map fully qualified type names to their short names. */
-  private final Map<String, String> importedTypes = new HashMap<String, String>();
-
-  private String packagePrefix;
-  private final List<Scope> scopes = new ArrayList<Scope>();
-  private final Writer out;
-
-  /**
-   * @param out the stream to which Java source will be written. This should be
-   *     a buffered stream.
-   */
-  public JavaWriter(Writer out) {
-    this.out = out;
-  }
-
-  /**
-   * Emit a package declaration.
-   */
-  public void emitPackage(String packageName) throws IOException {
-    if (this.packagePrefix != null) {
-      throw new IllegalStateException();
-    }
-    if (packageName.isEmpty()) {
-      this.packagePrefix = "";
-    } else {
-      out.write("package ");
-      out.write(packageName);
-      out.write(";\n");
-      this.packagePrefix = packageName + ".";
-    }
-  }
-
-  /**
-   * Emit an import for each {@code type} in the provided {@code Set}. For
-   * the duration of the file, all references to these classes will be
-   * automatically shortened.
-   */
-  public void emitImports(Collection<String> types) throws IOException {
-    for (String type : new TreeSet<String>(types)) {
-      Matcher matcher = TYPE_PATTERN.matcher(type);
-      if (!matcher.matches()) {
-        throw new IllegalArgumentException(type);
-      }
-      if (importedTypes.put(type, matcher.group(1)) != null) {
-        throw new IllegalArgumentException(type);
-      }
-      out.write("import ");
-      out.write(type);
-      out.write(";\n");
-    }
-    emitEmptyLine();
-  }
-
-  /**
-   * Emits a name like {@code java.lang.String} or {@code
-   * java.util.List<java.lang.String>}, shorting it with imports if
-   * possible.
-   */
-  private void emitType(String type) throws IOException {
-    out.write(compressType(type));
-  }
-
-  String compressType(String type) {
-    StringBuffer sb = new StringBuffer();
-    if (this.packagePrefix == null) {
-      throw new IllegalStateException();
-    }
-
-    Matcher m = TYPE_PATTERN.matcher(type);
-    int pos = 0;
-    while (true) {
-      boolean found = m.find(pos);
-
-      // copy non-matching characters like "<"
-      int typeStart = found ? m.start() : type.length();
-      sb.append(type, pos, typeStart);
-
-      if (!found) {
-        break;
-      }
-
-      // copy a single class name, shortening it if possible
-      String name = m.group(0);
-      String imported;
-      if ((imported = importedTypes.get(name)) != null) {
-        sb.append(imported);
-      } else if (isClassInPackage(name)) {
-        sb.append(name.substring(packagePrefix.length()));
-      } else if (name.startsWith("java.lang.")) {
-        sb.append(name.substring("java.lang.".length()));
-      } else {
-        sb.append(name);
-      }
-      pos = m.end();
-    }
-    String result = sb.toString();
-    return result;
-  }
-
-  private boolean isClassInPackage(String name) {
-    if (name.startsWith(packagePrefix)) {
-      if (name.indexOf('.', packagePrefix.length()) == -1) {
-        return true;
-      }
-      int index = name.indexOf('.');
-      if (name.substring(index + 1, index + 2).matches("[A-Z]")) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   */
-  public void beginType(String type, String kind, int modifiers) throws IOException {
-    beginType(type, kind, modifiers, null);
-  }
-
-  /**
-   * Emits a type declaration.
-   *
-   * @param kind such as "class", "interface" or "enum".
-   * @param extendsType the class to extend, or null for no extends clause.
-   */
-  public void beginType(String type, String kind, int modifiers,
-      String extendsType, String... implementsTypes) throws IOException {
-    indent();
-    out.write(modifiers(modifiers).toString());
-    out.write(kind);
-    out.write(" ");
-    emitType(type);
-    if (extendsType != null) {
-      out.write(" extends ");
-      emitType(extendsType);
-    }
-    if (implementsTypes.length > 0) {
-      out.write("\n");
-      indent();
-      out.write("    implements ");
-      for (int i = 0; i < implementsTypes.length; i++) {
-        if (i != 0) {
-          out.write(", ");
-        }
-        emitType(implementsTypes[i]);
-      }
-    }
-    out.write(" {\n");
-    pushScope(Scope.TYPE_DECLARATION);
-  }
-
-  /**
-   * Completes the current type declaration.
-   */
-  public void endType() throws IOException {
-    popScope(Scope.TYPE_DECLARATION);
-    indent();
-    out.write("}\n");
-  }
-
-  /**
-   * Emits a field declaration.
-   */
-  public void emitField(String type, String name, int modifiers) throws IOException {
-    field(type, name, modifiers, null);
-  }
-
-  public void field(String type, String name, int modifiers, String initialValue)
-      throws IOException {
-    indent();
-    out.write(modifiers(modifiers).toString());
-    emitType(type);
-    out.write(" ");
-    out.write(name);
-
-    if (initialValue != null) {
-      out.write(" = ");
-      out.write(initialValue);
-    }
-    out.write(";\n");
-  }
-
-  /**
-   * Emit a method declaration.
-   *
-   * @param returnType the method's return type, or null for constructors.
-   * @param parameters alternating parameter types and names.
-   * @param name the method name, or the fully qualified class name for
-   *     constructors.
-   */
-  public void beginMethod(String returnType, String name, int modifiers, String... parameters)
-      throws IOException {
-    indent();
-    out.write(modifiers(modifiers).toString());
-    if (returnType != null) {
-      emitType(returnType);
-      out.write(" ");
-      out.write(name);
-    } else {
-      emitType(name);
-    }
-    out.write("(");
-    for (int p = 0; p < parameters.length;) {
-      if (p != 0) {
-        out.write(", ");
-      }
-      emitType(parameters[p++]);
-      out.write(" ");
-      emitType(parameters[p++]);
-    }
-    out.write(")");
-    if ((modifiers & Modifier.ABSTRACT) != 0) {
-      out.write(";\n");
-      pushScope(Scope.ABSTRACT_METHOD);
-    } else {
-      out.write(" {\n");
-      pushScope(Scope.NON_ABSTRACT_METHOD);
-    }
-  }
-
-  /**
-   * Emits some javadoc comments with line separated by {@code \n}.
-   */
-  public void emitJavadoc(String javadoc, Object ... params) throws IOException {
-    String formatted = (params.length == 0) ? javadoc : String.format(javadoc, params);
-    indent();
-    out.write("/**\n");
-    for (String line : formatted.split("\n")) {
-      indent();
-      out.write(" * ");
-      out.write(line);
-      out.write("\n");
-    }
-    indent();
-    out.write(" */\n");
-  }
-
-  /**
-   * Emits some javadoc comments.
-   */
-  public void emitEndOfLineComment(String comment) throws IOException {
-    out.write("// ");
-    out.write(comment);
-    out.write("\n");
-  }
-
-  public void emitEmptyLine() throws IOException {
-    out.write("\n");
-  }
-
-  /**
-   * Equivalent to {@code annotation(annotation, emptyMap())}.
-   */
-  public void emitAnnotation(String annotation) throws IOException {
-    emitAnnotation(annotation, Collections.<String, Object>emptyMap());
-  }
-
-
-  /**
-   * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.
-   */
-  public void emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {
-    emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());
-  }
-
-  /**
-   * Annotates the next element with {@code annotation} and a {@code value}.
-   *
-   * @param value an object used as the default (value) parameter of the annotation.
-   *     The value will be encoded using Object.toString(); use {@link #stringLiteral}
-   *     for String values. Object arrays are written one element per line.
-   */
-  public void emitAnnotation(Class<? extends Annotation> annotation, Object value)
-      throws IOException {
-    indent();
-    out.write("@");
-    emitType(annotation.getName());
-    out.write("(");
-    emitAnnotationValue(value);
-    out.write(")");
-    out.write("\n");
-  }
-
-  /**
-   * Equivalent to {@code annotation(annotationType.getName(), attributes)}.
-   */
-  public void emitAnnotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)
-      throws IOException {
-    emitAnnotation(annotationType.getName(), attributes);
-  }
-
-  /**
-   * Annotates the next element with {@code annotation} and {@code attributes}.
-   *
-   * @param attributes a map from annotation attribute names to their values.
-   *     Values are encoded using Object.toString(); use {@link #stringLiteral}
-   *     for String values. Object arrays are written one element per line.
-   */
-  public void emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException {
-    indent();
-    out.write("@");
-    emitType(annotation);
-    if (!attributes.isEmpty()) {
-      out.write("(");
-      pushScope(Scope.ANNOTATION_ATTRIBUTE);
-      boolean firstAttribute = true;
-      for (Map.Entry<String, ?> entry : attributes.entrySet()) {
-        if (firstAttribute) {
-          firstAttribute = false;
-          out.write("\n");
-        } else {
-          out.write(",\n");
-        }
-        indent();
-        out.write(entry.getKey());
-        out.write(" = ");
-        Object value = entry.getValue();
-        emitAnnotationValue(value);
-      }
-      popScope(Scope.ANNOTATION_ATTRIBUTE);
-      out.write("\n");
-      indent();
-      out.write(")");
-    }
-    out.write("\n");
-  }
-
-  /**
-   * Writes a single annotation value. If the value is an array, each element in
-   * the array will be written to its own line.
-   */
-  private void emitAnnotationValue(Object value) throws IOException {
-    if (value instanceof Object[]) {
-      out.write("{");
-      boolean firstValue = true;
-      pushScope(Scope.ANNOTATION_ARRAY_VALUE);
-      for (Object o : ((Object[]) value)) {
-        if (firstValue) {
-          firstValue = false;
-          out.write("\n");
-        } else {
-          out.write(",\n");
-        }
-        indent();
-        out.write(o.toString());
-      }
-      popScope(Scope.ANNOTATION_ARRAY_VALUE);
-      out.write("\n");
-      indent();
-      out.write("}");
-    } else {
-      out.write(value.toString());
-    }
-  }
-
-  /**
-   * @param pattern a code pattern like "int i = %s". Shouldn't contain a
-   * trailing semicolon or newline character.
-   */
-  public void emitStatement(String pattern, Object... args) throws IOException {
-    checkInMethod();
-    indent();
-    out.write(String.format(pattern, args));
-    out.write(";\n");
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as
-   *     "if (foo == 5)". Shouldn't contain braces or newline characters.
-   */
-  public void beginControlFlow(String controlFlow) throws IOException {
-    checkInMethod();
-    indent();
-    out.write(controlFlow);
-    out.write(" {\n");
-    pushScope(Scope.CONTROL_FLOW);
-  }
-
-  /**
-   * @param controlFlow the control flow construct and its code, such as
-   *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
-   */
-  public void nextControlFlow(String controlFlow) throws IOException {
-    popScope(Scope.CONTROL_FLOW);
-    indent();
-    pushScope(Scope.CONTROL_FLOW);
-    out.write("} ");
-    out.write(controlFlow);
-    out.write(" {\n");
-  }
-
-  public void endControlFlow() throws IOException {
-    endControlFlow(null);
-  }
-
-  /**
-   * @param controlFlow the optional control flow construct and its code, such
-   *     as "while(foo == 20)". Only used for "do/while" control flows.
-   */
-  public void endControlFlow(String controlFlow) throws IOException {
-    popScope(Scope.CONTROL_FLOW);
-    indent();
-    if (controlFlow != null) {
-      out.write("} ");
-      out.write(controlFlow);
-      out.write(";\n");
-    } else {
-      out.write("}\n");
-    }
-  }
-
-  /**
-   * Completes the current method declaration.
-   */
-  public void endMethod() throws IOException {
-    Scope popped = popScope();
-    if (popped == Scope.NON_ABSTRACT_METHOD) {
-      indent();
-      out.write("}\n");
-    } else if (popped != Scope.ABSTRACT_METHOD) {
-      throw new IllegalStateException();
-    }
-  }
-
-  /**
-   * Returns the string literal representing {@code data}, including wrapping
-   * quotes.
-   */
-  public static String stringLiteral(String data) {
-    StringBuilder result = new StringBuilder();
-    result.append('"');
-    for (int i = 0; i < data.length(); i++) {
-      char c = data.charAt(i);
-      switch (c) {
-        case '"':
-          result.append("\\\"");
-          break;
-        case '\\':
-          result.append("\\\\");
-          break;
-        case '\t':
-          result.append("\\\t");
-          break;
-        case '\b':
-          result.append("\\\b");
-          break;
-        case '\n':
-          result.append("\\\n");
-          break;
-        case '\r':
-          result.append("\\\r");
-          break;
-        case '\f':
-          result.append("\\\f");
-          break;
-        default:
-          result.append(c);
-      }
-    }
-    result.append('"');
-    return result.toString();
-  }
-
-  @Override public void close() throws IOException {
-    out.close();
-  }
-
-  /**
-   * Emit modifier names.
-   */
-  static StringBuffer modifiers(int modifiers) {
-    StringBuffer out = new StringBuffer();
-    if ((modifiers & Modifier.PUBLIC) != 0) {
-      out.append("public ");
-    }
-    if ((modifiers & Modifier.PRIVATE) != 0) {
-      out.append("private ");
-    }
-    if ((modifiers & Modifier.PROTECTED) != 0) {
-      out.append("protected ");
-    }
-    if ((modifiers & Modifier.STATIC) != 0) {
-      out.append("static ");
-    }
-    if ((modifiers & Modifier.FINAL) != 0) {
-      out.append("final ");
-    }
-    if ((modifiers & Modifier.ABSTRACT) != 0) {
-      out.append("abstract ");
-    }
-    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
-      out.append("synchronized ");
-    }
-    if ((modifiers & Modifier.TRANSIENT) != 0) {
-      out.append("transient ");
-    }
-    if ((modifiers & Modifier.VOLATILE) != 0) {
-      out.append("volatile ");
-    }
-    return out;
-  }
-
-  private void indent() throws IOException {
-    for (int i = 0; i < scopes.size(); i++) {
-      out.write(INDENT);
-    }
-  }
-
-  private void checkInMethod() {
-    Scope scope = peekScope();
-    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-  }
-
-  private void pushScope(Scope pushed) {
-    scopes.add(pushed);
-  }
-
-  private Scope peekScope() {
-    return scopes.get(scopes.size() - 1);
-  }
-
-  private Scope popScope() {
-    return scopes.remove(scopes.size() - 1);
-  }
-
-  private void popScope(Scope expected) {
-    if (scopes.remove(scopes.size() - 1) != expected) {
-      throw new IllegalStateException();
-    }
-  }
-
-  private enum Scope {
-    TYPE_DECLARATION,
-    ABSTRACT_METHOD,
-    NON_ABSTRACT_METHOD,
-    CONTROL_FLOW,
-    ANNOTATION_ATTRIBUTE,
-    ANNOTATION_ARRAY_VALUE,
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
new file mode 100644
index 000000000..ca01668b7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.MoreObjects;
+import com.google.common.base.Optional;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.producers.Producer;
+import dagger.producers.Produces;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
+
+/**
+ * Represents a unique combination of {@linkplain TypeMirror type} and
+ * {@linkplain Qualifier qualifier} to which binding can occur.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class Key {
+  /**
+   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
+   * for the type of this key.
+   *
+   * Despite documentation in {@link AnnotationMirror}, equals and hashCode aren't implemented
+   * to represent logical equality, so {@link AnnotationMirrors#equivalence()}
+   * provides this facility.
+   */
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier();
+
+  /**
+   * The type represented by this key.
+   *
+   * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
+   * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
+   */
+  abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+
+  Optional<AnnotationMirror> qualifier() {
+    return unwrapOptionalEquivalence(wrappedQualifier());
+  }
+
+  TypeMirror type() {
+    return wrappedType().get();
+  }
+
+  private static TypeMirror normalize(Types types, TypeMirror type) {
+    TypeKind kind = type.getKind();
+    return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
+  }
+
+  Key withType(Types types, TypeMirror newType) {
+    return new AutoValue_Key(wrappedQualifier(),
+        MoreTypes.equivalence().wrap(normalize(types, newType)));
+  }
+
+  boolean isValidMembersInjectionKey() {
+    return !qualifier().isPresent();
+  }
+
+  /**
+   * Returns true if the key is valid as an implicit key (that is, if it's valid for a just-in-time
+   * binding by discovering an {@code @Inject} constructor).
+   */
+  boolean isValidImplicitProvisionKey(final Types types) {
+    // Qualifiers disqualify implicit provisioning.
+    if (qualifier().isPresent()) {
+      return false;
+    }
+
+    return type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        return false; // Only declared types are allowed.
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // Non-classes or abstract classes aren't allowed.
+        TypeElement element = MoreElements.asType(type.asElement());
+        if (!element.getKind().equals(ElementKind.CLASS)
+            || element.getModifiers().contains(Modifier.ABSTRACT)) {
+          return false;
+        }
+
+        // If the key has type arguments, validate that each type argument is declared.
+        // Otherwise the type argument may be a wildcard (or other type), and we can't
+        // resolve that to actual types.
+        for (TypeMirror arg : type.getTypeArguments()) {
+          if (arg.getKind() != TypeKind.DECLARED) {
+            return false;
+          }
+        }
+
+        // Also validate that the key is not the erasure of a generic type.
+        // If it is, that means the user referred to Foo<T> as just 'Foo',
+        // which we don't allow.  (This is a judgement call -- we *could*
+        // allow it and instantiate the type bounds... but we don't.)
+        return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+            || !types.isSameType(types.erasure(element.asType()), type());
+      }
+    }, null);
+  }
+
+  @Override
+  public String toString() {
+    return MoreObjects.toStringHelper(Key.class)
+        .omitNullValues()
+        .add("qualifier", qualifier().orNull())
+        .add("type", type())
+        .toString();
+  }
+
+  static final class Factory {
+    private final Types types;
+    private final Elements elements;
+
+    Factory(Types types, Elements elements) {
+      this.types = checkNotNull(types);
+      this.elements = checkNotNull(elements);
+    }
+
+    private TypeElement getSetElement() {
+      return elements.getTypeElement(Set.class.getCanonicalName());
+    }
+
+    private TypeElement getMapElement() {
+      return elements.getTypeElement(Map.class.getCanonicalName());
+    }
+
+    private TypeElement getProviderElement() {
+      return elements.getTypeElement(Provider.class.getCanonicalName());
+    }
+
+    private TypeElement getProducerElement() {
+      return elements.getTypeElement(Producer.class.getCanonicalName());
+    }
+
+    private TypeElement getClassElement(Class<?> cls) {
+      return elements.getTypeElement(cls.getCanonicalName());
+    }
+
+    Key forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
+          MoreTypes.equivalence().wrap(returnType));
+    }
+
+    Key forProductionComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
+      TypeMirror keyType = returnType;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      }
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
+          MoreTypes.equivalence().wrap(keyType));
+    }
+
+    Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      Provides providesAnnotation = e.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      switch (providesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(returnType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
+          TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(mapType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(returnType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(returnType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // Produces.Type are no longer different.
+    Key forProducesMethod(ExecutableType executableType, ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      Produces producesAnnotation = e.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror keyType = returnType;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      }
+      switch (producesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), keyType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
+          TypeMirror valueType = types.getDeclaredType(getProducerElement(), keyType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(mapType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(keyType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) keyType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    Key forInjectConstructorWithResolvedType(TypeMirror type) {
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(type));
+    }
+
+    Key forComponent(TypeMirror type) {
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(normalize(types, type)));
+    }
+
+    Key forMembersInjectedType(TypeMirror type) {
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(normalize(types, type)));
+    }
+
+    Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
+          MoreTypes.equivalence().wrap(normalize(types, type)));
+    }
+
+    /**
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
+     * valid key can be inferred from the given key.  Specifically, if the key represents a
+     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     */
+    Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
+      return maybeWrapMapValue(possibleMapKey, Provider.class);
+    }
+
+    /**
+     * Optionally extract a {@link Key} for the underlying production binding(s) if such a
+     * valid key can be inferred from the given key.  Specifically, if the key represents a
+     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Producer<V>>} will be returned.
+     */
+    Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
+      return maybeWrapMapValue(possibleMapKey, Producer.class);
+    }
+
+    /**
+     * Returns a key of {@link Map}{@code <K, WrappingClass<V>>} if the input key represents a
+     * {@code Map<K, V>}.
+     */
+    private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
+      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
+        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
+        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+        if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
+          DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
+          TypeElement wrappingElement = getClassElement(wrappingClass);
+          if (wrappingElement == null) {
+            // This target might not be compiled with Producers, so wrappingClass might not have an
+            // associated element.
+            return Optional.absent();
+          }
+          DeclaredType wrappedType = types.getDeclaredType(wrappingElement, mapValueType);
+          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, wrappedType);
+          return Optional.<Key>of(new AutoValue_Key(
+              possibleMapKey.wrappedQualifier(),
+              MoreTypes.equivalence().wrap(mapType)));
+        }
+      }
+      return Optional.absent();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
new file mode 100644
index 000000000..d2e62fcab
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class KeyFormatter extends Formatter<Key> {
+
+  @Override public String format(Key request) {
+    StringBuilder builder = new StringBuilder();
+    if (request.qualifier().isPresent()) {
+      builder.append(request.qualifier()); // TODO(cgruber): Use AnnotationMirrorFormatter.
+      builder.append(' ');
+    }
+    builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
+    return builder.toString();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
new file mode 100644
index 000000000..c32d50806
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import java.util.Iterator;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+/**
+ * Suggests a variable name for a type based on a {@link Key}. Prefer
+ * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+enum KeyVariableNamer implements Function<Key, String> {
+  INSTANCE;
+
+  @Override
+  public String apply(Key key) {
+    StringBuilder builder = new StringBuilder();
+
+    if (key.qualifier().isPresent()) {
+      if (!key.qualifier().get().getElementValues().isEmpty()) {
+        // TODO(gak): obviously we need to support this
+        throw new UnsupportedOperationException();
+      }
+      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
+    }
+
+    key.type().accept(new SimpleTypeVisitor6<Void, StringBuilder>() {
+      @Override
+      public Void visitDeclared(DeclaredType t, StringBuilder builder) {
+        builder.append(t.asElement().getSimpleName());
+        Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+        if (argumentIterator.hasNext()) {
+          builder.append("Of");
+          TypeMirror first = argumentIterator.next();
+          first.accept(this, builder);
+          while (argumentIterator.hasNext()) {
+            builder.append("And");
+            argumentIterator.next().accept(this, builder);
+          }
+        }
+        return null;
+      }
+    }, builder);
+
+    return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
new file mode 100644
index 000000000..e0be1493a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Generates implementations to create {@link MapKey} instances
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyGenerator extends SourceFileGenerator<Element> {
+  MapKeyGenerator(Filer filer) {
+    super(filer);
+  }
+
+  @Override
+  ClassName nameGeneratedType(Element e) {
+    return Util.getMapKeyCreatorClassName((TypeElement) e);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(Element e) {
+    return ImmutableSet.of(e);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(Element e) {
+    return Optional.of(e);
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    TypeWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
+    mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    mapKeyWriter.addModifiers(PUBLIC);
+
+    //create map key create method, which will return an instance of map key
+    MethodWriter getMethodWriter = mapKeyWriter.addMethod(e.asType(), "create");
+    //get parameter list of create method
+    List<? extends Element> enclosingElements = e.getEnclosedElements();
+    List<String> paraList = new ArrayList<String>();
+
+    //Using AutoAnnotation to generate mapkey creator files later
+    getMethodWriter.annotate(AutoAnnotation.class);
+    getMethodWriter.addModifiers(PUBLIC, STATIC);
+
+    for (Element element : enclosingElements) {
+      if (element instanceof ExecutableElement) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        Name parameterName = executableElement.getSimpleName();
+        getMethodWriter.addParameter(
+            (TypeElement) ((DeclaredType) (executableElement.getReturnType())).asElement(),
+            parameterName.toString());
+        paraList.add(parameterName.toString());
+      } else {
+        throw new IllegalStateException();
+      }
+    }
+
+    getMethodWriter.body().addSnippet(
+        "return new AutoAnnotation_" + generatedTypeName.simpleName() + "_create(%s);",
+        Joiner.on(", ").join(paraList));
+
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
new file mode 100644
index 000000000..488f031c1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.MapKey;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * The annotation processor responsible for validating the mapKey annotation and auto-generate
+ * implementation of annotations marked with &#064MapKey where necessary.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+  private final Messager messager;
+  private final MapKeyValidator mapKeyValidator;
+  private final MapKeyGenerator mapKeyGenerator;
+
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator,
+      MapKeyGenerator mapKeyGenerator) {
+    this.messager = messager;
+    this.mapKeyValidator = mapKeyValidator;
+    this.mapKeyGenerator = mapKeyGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(MapKey.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.get(MapKey.class)) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+      mapKeyReport.printMessagesTo(messager);
+
+      if (mapKeyReport.isClean()) {
+        MapKey mapkey = element.getAnnotation(MapKey.class);
+        if (!mapkey.unwrapValue()) {
+          try {
+            mapKeyGenerator.generate(element);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
new file mode 100644
index 000000000..8411b20fb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_FIELDS;
+
+/**
+ * A {@link Validator} for {@link MapKey} Annotation.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyValidator implements Validator<Element> {
+  @Override
+  public ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+    if (((TypeElement) element).getEnclosedElements().isEmpty()) {
+      builder.addItem(MAPKEY_WITHOUT_FIELDS, element);
+    }
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
new file mode 100644
index 000000000..4f48d8d59
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Ordering;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Represents the full members injection of a particular type. This does not pay attention to
+ * injected members on supertypes.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class MembersInjectionBinding extends Binding {
+  @Override abstract TypeElement bindingElement();
+
+  /** The set of individual sites where {@link Inject} is applied. */
+  abstract ImmutableSortedSet<InjectionSite> injectionSites();
+
+  abstract Optional<DependencyRequest> parentInjectorRequest();
+
+  enum Strategy {
+    NO_OP,
+    DELEGATE,
+    INJECT_MEMBERS,
+  }
+
+  Strategy injectionStrategy() {
+    if (injectionSites().isEmpty()) {
+      return parentInjectorRequest().isPresent()
+          ? Strategy.DELEGATE
+          : Strategy.NO_OP;
+    } else {
+      return Strategy.INJECT_MEMBERS;
+    }
+  }
+
+  MembersInjectionBinding withoutParentInjectorRequest() {
+    return new AutoValue_MembersInjectionBinding(
+          key(),
+          dependencies(),
+          implicitDependencies(),
+          bindingPackage(),
+          hasNonDefaultTypeParameters(),
+          bindingElement(),
+          injectionSites(),
+          Optional.<DependencyRequest>absent());
+  }
+
+  private static final Ordering<InjectionSite> INJECTION_ORDERING =
+      new Ordering<InjectionSite>() {
+        @Override
+        public int compare(InjectionSite left, InjectionSite right) {
+          checkArgument(left.element().getEnclosingElement()
+              .equals(right.element().getEnclosingElement()));
+          return ComparisonChain.start()
+              // fields before methods
+              .compare(left.element().getKind(), right.element().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
+              .result();
+        }
+
+        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
+          return injectionSite.element().getEnclosingElement().getEnclosedElements()
+              .indexOf(injectionSite.element());
+        }
+      };
+
+  @AutoValue
+  abstract static class InjectionSite {
+    enum Kind {
+      FIELD,
+      METHOD,
+    }
+
+    abstract Kind kind();
+
+    abstract Element element();
+
+    abstract ImmutableSet<DependencyRequest> dependencies();
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = checkNotNull(elements);
+      this.types = checkNotNull(types);
+      this.keyFactory = checkNotNull(keyFactory);
+      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+    }
+
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
+        DeclaredType containingType) {
+      checkNotNull(methodElement);
+      checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+      checkArgument(isAnnotationPresent(methodElement, Inject.class));
+      ExecutableType resolved =
+          MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+          methodElement,
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              containingType,
+              methodElement.getParameters(),
+              resolved.getParameterTypes()));
+    }
+
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
+        DeclaredType containingType) {
+      checkNotNull(fieldElement);
+      checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+      checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+      TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+          fieldElement,
+          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
+              containingType, fieldElement, resolved)));
+    }
+
+    /** Returns an unresolved version of this binding. */
+    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
+      checkState(binding.hasNonDefaultTypeParameters());
+      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
+      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
+    }
+
+    /**
+     * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
+     * this will return a resolved binding, with the key & type resolved to the given type (using
+     * {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+      // If the class this is injecting has some type arguments, resolve everything.
+      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(type));
+        type = resolved;
+      }
+
+      TypeElement typeElement = MoreElements.asType(type.asElement());
+      final DeclaredType resolved = type;
+      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
+          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
+        injectionSitesBuilder.addAll(enclosedElement.accept(
+            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
+                Optional.<InjectionSite>absent()) {
+                  @Override
+                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
+                      Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
+                        : Optional.<InjectionSite>absent();
+                  }
+
+                  @Override
+                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectField(e, resolved))
+                        : Optional.<InjectionSite>absent();
+                  }
+                }, null).asSet());
+      }
+      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
+
+      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
+          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+            @Override public Set<DependencyRequest> apply(InjectionSite input) {
+              return input.dependencies();
+            }
+          })
+          .toSet();
+
+      Optional<DependencyRequest> parentInjectorRequest =
+          MoreTypes.nonObjectSuperclass(types, elements, type)
+              .transform(new Function<DeclaredType, DependencyRequest>() {
+                @Override public DependencyRequest apply(DeclaredType input) {
+                  return dependencyRequestFactory.forMembersInjectedType(input);
+                }
+              });
+
+      Key key = keyFactory.forMembersInjectedType(type);
+      return new AutoValue_MembersInjectionBinding(
+          key,
+          dependencies,
+          new ImmutableSet.Builder<DependencyRequest>()
+              .addAll(parentInjectorRequest.asSet())
+              .addAll(dependencies)
+              .build(),
+          findBindingPackage(key),
+          hasNonDefaultTypeParameters(typeElement, key.type(), types),
+          typeElement,
+          injectionSites,
+          parentInjectorRequest);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
new file mode 100644
index 000000000..c4d0db6cc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import dagger.MembersInjector;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
+import dagger.internal.codegen.writer.VoidName;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final Elements elements;
+  private final Types types;
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  MembersInjectorGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      DependencyRequestMapper dependencyRequestMapper) {
+    super(filer);
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+    this.dependencyRequestMapper = dependencyRequestMapper;
+  }
+
+  @Override
+  ClassName nameGeneratedType(MembersInjectionBinding binding) {
+    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(
+      MembersInjectionBinding binding) {
+    return FluentIterable.from(binding.injectionSites())
+        .transform(new Function<InjectionSite, Element>() {
+          @Override public Element apply(InjectionSite injectionSite) {
+            return injectionSite.element();
+          }
+        })
+        .toSet();
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.hasNonDefaultTypeParameters());
+
+    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+
+    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
+    }
+    injectorWriter.addTypeParameters(typeParameters);
+    injectorWriter.annotate(Generated.class)
+        .setValue(ComponentProcessor.class.getCanonicalName());
+    injectorWriter.addModifiers(PUBLIC, FINAL);
+    TypeName implementedType =
+        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
+    injectorWriter.addImplementedType(implementedType);
+
+    ConstructorWriter constructorWriter = injectorWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+    MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
+    injectMembersWriter.addModifiers(PUBLIC);
+    injectMembersWriter.annotate(Override.class);
+    injectMembersWriter.addParameter(injectedTypeName, "instance");
+    injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
+        "if (instance == null) {",
+        "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "}"));
+
+    Optional<DeclaredType> supertype =
+        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
+    if (supertype.isPresent()) {
+      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
+          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
+      injectorWriter
+          .addField(supertypeMemebersInjectorType, "supertypeInjector")
+          .addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
+      constructorWriter.body()
+          .addSnippet("assert supertypeInjector != null;")
+          .addSnippet("this.supertypeInjector = supertypeInjector;");
+      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
+    }
+
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
+
+    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
+        ImmutableMap.builder();
+
+    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
+      FrameworkField bindingField = fieldEntry.getValue();
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body().addSnippet("assert %s != null;", field.name());
+      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
+      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
+    }
+    
+    // We use a static create method so that generated components can avoid having
+    // to refer to the generic types of the factory.
+    // (Otherwise they may have visibility problems referring to the types.)
+    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
+    createMethodWriter.addTypeParameters(typeParameters);
+    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+    Map<String, TypeName> params = constructorWriter.parameters();
+    for (Map.Entry<String, TypeName> param : params.entrySet()) {
+      createMethodWriter.addParameter(param.getValue(), param.getKey());      
+    }
+    createMethodWriter.body().addSnippet("  return new %s(%s);",
+        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
+        Joiner.on(", ").join(params.keySet()));
+    
+    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    for (InjectionSite injectionSite : binding.injectionSites()) {
+      switch (injectionSite.kind()) {
+        case FIELD:
+          DependencyRequest fieldDependency =
+              Iterables.getOnlyElement(injectionSite.dependencies());
+          FieldWriter singleField = depedencyFields.get(
+              fieldDependency.bindingKey());
+          injectMembersWriter.body().addSnippet("instance.%s = %s;",
+              injectionSite.element().getSimpleName(),
+              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
+                  fieldDependency.kind()));
+          break;
+        case METHOD:
+          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+          for (DependencyRequest methodDependency : injectionSite.dependencies()) {
+            FieldWriter field = depedencyFields.get(
+                methodDependency.bindingKey());
+            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
+                methodDependency.kind()));
+          }
+          injectMembersWriter.body().addSnippet("instance.%s(%s);",
+              injectionSite.element().getSimpleName(),
+              Snippet.makeParametersSnippet(parameters.build()));
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
new file mode 100644
index 000000000..447ed24ef
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -0,0 +1,33 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableList;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+@AutoValue
+abstract class MethodSignature {
+  abstract String name();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> parameterTypes();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> thrownTypes();
+
+  static MethodSignature fromExecutableType(String methodName, ExecutableType methodType) {
+    checkNotNull(methodType);
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
+    for (TypeMirror parameter : methodType.getParameterTypes()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter));
+    }
+    for (TypeMirror thrownType : methodType.getThrownTypes()) {
+      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
+    }
+    return new AutoValue_MethodSignature(
+        methodName,
+        parameters.build(),
+        thrownTypes.build());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
new file mode 100644
index 000000000..078977e16
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import java.util.Iterator;
+import java.util.List;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+
+/**
+ * Formats the signature of an {@link ExecutableElement} suitable for use in error messages.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
+  private final Types types;
+
+  MethodSignatureFormatter(Types types) {
+    this.types = types;
+  }
+
+  @Override public String format(ExecutableElement method) {
+    return format(method, Optional.<DeclaredType>absent());
+  }
+
+  /**
+   * Formats an ExecutableElement as if it were contained within the container, if the container is
+   * present.
+   */
+  public String format(ExecutableElement method, Optional<DeclaredType> container) {
+    StringBuilder builder = new StringBuilder();
+    TypeElement type = MoreElements.asType(method.getEnclosingElement());
+    ExecutableType executableType = MoreTypes.asExecutable(method.asType());
+    if (container.isPresent()) {
+      executableType = MoreTypes.asExecutable(types.asMemberOf(container.get(), method));
+      type = MoreElements.asType(container.get().asElement());
+    }
+
+    // TODO(cgruber): AnnotationMirror formatter.
+    List<? extends AnnotationMirror> annotations = method.getAnnotationMirrors();
+    if (!annotations.isEmpty()) {
+      Iterator<? extends AnnotationMirror> annotationIterator = annotations.iterator();
+      for (int i = 0; annotationIterator.hasNext(); i++) {
+        if (i > 0) {
+          builder.append(' ');
+        }
+        builder.append(ErrorMessages.format(annotationIterator.next()));
+      }
+      builder.append(' ');
+    }
+    builder.append(nameOfType(executableType.getReturnType()));
+    builder.append(' ');
+    builder.append(type.getQualifiedName());
+    builder.append('.');
+    builder.append(method.getSimpleName());
+    builder.append('(');
+    checkState(method.getParameters().size() == executableType.getParameterTypes().size());
+    Iterator<? extends VariableElement> parameters = method.getParameters().iterator();
+    Iterator<? extends TypeMirror> parameterTypes = executableType.getParameterTypes().iterator();
+    for (int i = 0; parameters.hasNext(); i++) {
+      if (i > 0) {
+        builder.append(", ");
+      }
+      appendParameter(builder, parameters.next(), parameterTypes.next());
+    }
+    builder.append(')');
+    return builder.toString();
+  }
+
+  private static void appendParameter(StringBuilder builder, VariableElement parameter,
+      TypeMirror type) {
+    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
+    if (qualifier.isPresent()) {
+      builder.append(ErrorMessages.format(qualifier.get())).append(' ');
+    }
+    builder.append(nameOfType(type));
+  }
+
+  private static String nameOfType(TypeMirror type) {
+    if (type.getKind().isPrimitive()) {
+      return MoreTypes.asPrimitiveType(type).toString();
+    } else if (type.getKind() == TypeKind.VOID) {
+      return "void";
+    } else {
+      return stripCommonTypePrefixes(MoreTypes.asDeclared(type).toString());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
new file mode 100644
index 000000000..423848868
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the {@link Module}
+ * (and {@link Provides}) annotation.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ModuleProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+  private final Messager messager;
+  private final ModuleValidator moduleValidator;
+  private final ProvidesMethodValidator providesMethodValidator;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
+
+  ModuleProcessingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      ProvidesMethodValidator providesMethodValidator,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator) {
+    this.messager = messager;
+    this.moduleValidator = moduleValidator;
+    this.providesMethodValidator = providesMethodValidator;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Module.class, Provides.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    // first, check and collect all provides methods
+    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
+    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
+    ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
+
+    // process each module
+    for (Element moduleElement :
+        Sets.difference(elementsByAnnotation.get(Module.class), processedModuleElements)) {
+      ValidationReport<TypeElement> report =
+          moduleValidator.validate(MoreElements.asType(moduleElement));
+      report.printMessagesTo(messager);
+
+      if (report.isClean()) {
+        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+            ImmutableSet.builder();
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+        for (ExecutableElement methodElement : moduleMethods) {
+          if (isAnnotationPresent(methodElement, Provides.class)) {
+            moduleProvidesMethodsBuilder.add(methodElement);
+          }
+        }
+        ImmutableSet<ExecutableElement> moduleProvidesMethods =
+            moduleProvidesMethodsBuilder.build();
+
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+          // all of the provides methods in this module are valid!
+          // time to generate some factories!
+          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+              .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                @Override
+                public ProvisionBinding apply(ExecutableElement providesMethod) {
+                  return provisionBindingFactory.forProvidesMethod(providesMethod,
+                      providesMethod.getEnclosingElement().asType());
+                }
+              })
+              .toSet();
+
+          try {
+            for (ProvisionBinding binding : bindings) {
+              factoryGenerator.generate(binding);
+            }
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+      processedModuleElements.add(moduleElement);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
new file mode 100644
index 000000000..f30ef9133
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.Visibility;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.Visibility.PRIVATE;
+import static com.google.auto.common.Visibility.PUBLIC;
+import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ModuleValidator implements Validator<TypeElement> {
+  private final Types types;
+  private final Elements elements;
+  private final Class<? extends Annotation> moduleClass;
+  private final Class<? extends Annotation> methodClass;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  ModuleValidator(
+      Types types,
+      Elements elements,
+      MethodSignatureFormatter methodSignatureFormatter,
+      Class<? extends Annotation> moduleClass,
+      Class<? extends Annotation> methodClass) {
+    this.types = types;
+    this.elements = elements;
+    this.moduleClass = moduleClass;
+    this.methodClass = methodClass;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
+    ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
+    ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
+    for (ExecutableElement moduleMethod : moduleMethods) {
+      if (isAnnotationPresent(moduleMethod, methodClass)) {
+        bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+      }
+      allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+    }
+      
+    validateModuleVisibility(subject, builder);
+    validateMethodsWithSameName(builder, bindingMethodsByName);
+    validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+    validateModifiers(subject, builder);    
+    validateReferencedModules(subject, builder);
+    
+    // TODO(gak): port the dagger 1 module validation?
+    return builder.build();
+  }
+
+  private void validateModifiers(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder) {    
+    // This coupled with the check for abstract modules in ComponentValidator guarantees that
+    // only modules without type parameters are referenced from @Component(modules={...}). 
+    if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
+      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+    }
+  }
+  
+  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
+    for (Entry<String, Collection<ExecutableElement>> entry :
+        bindingMethodsByName.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        for (ExecutableElement offendingMethod : entry.getValue()) {
+          builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+              offendingMethod);
+        }
+      }
+    }    
+  }
+  
+  private void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder) {
+    // Validate that all the modules we include are valid for inclusion.
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
+    validateReferencedModules(subject,  builder, includedTypes);
+  }
+  
+  /**
+   * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
+   */
+  void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder,
+      ImmutableList<TypeMirror> includedTypes) {
+    for (TypeMirror includedType : includedTypes) {
+      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          TypeElement element = MoreElements.asType(t.asElement()); 
+          if (!t.getTypeArguments().isEmpty()) {
+            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
+                element.getQualifiedName()), subject);
+          }
+          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
+            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
+                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
+          }
+          if (element.getModifiers().contains(ABSTRACT)) {
+            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+                element.getQualifiedName()), subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+  }
+  
+  private void validateProvidesOverrides(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> allMethodsByName,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+    // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
+    // Consider the following hierarchy:
+    // class Parent {
+    //    @Provides Foo a() {}
+    //    @Provides Foo b() {}
+    //    Foo c() {}
+    // }
+    // class Child extends Parent {
+    //    @Provides Foo a() {}
+    //    Foo b() {}
+    //    @Provides Foo c() {}
+    // }
+    // In each of those cases, we want to fail.  "a" is clear, "b" because Child is overriding
+    // a method marked @Provides in Parent, and "c" because Child is defining an @Provides
+    // method that overrides Parent.
+    TypeElement currentClass = subject;
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    // We keep track of methods that failed so we don't spam with multiple failures.
+    Set<ExecutableElement> failedMethods = Sets.newHashSet();
+    while (!types.isSameType(currentClass.getSuperclass(), objectType)) {
+      currentClass = MoreElements.asType(types.asElement(currentClass.getSuperclass()));
+      List<ExecutableElement> superclassMethods =
+          ElementFilter.methodsIn(currentClass.getEnclosedElements());
+      for (ExecutableElement superclassMethod : superclassMethods) {
+        String name = superclassMethod.getSimpleName().toString();
+        // For each method in the superclass, confirm our @Provides methods don't override it
+        for (ExecutableElement providesMethod : bindingMethodsByName.get(name)) {
+          if (!failedMethods.contains(providesMethod)
+              && elements.overrides(providesMethod, superclassMethod, subject)) {
+            failedMethods.add(providesMethod);
+            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                providesMethod);
+          }
+        }
+        // For each @Provides method in superclass, confirm our methods don't override it.
+        if (isAnnotationPresent(superclassMethod, methodClass)) {
+          for (ExecutableElement method : allMethodsByName.get(name)) {
+            if (!failedMethods.contains(method)
+                && elements.overrides(method, superclassMethod, subject)) {
+              failedMethods.add(method);
+              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
+                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                  method);
+            }
+          }
+        }
+        allMethodsByName.put(superclassMethod.getSimpleName().toString(), superclassMethod);
+      }
+    }
+  }
+
+  private void validateModuleVisibility(final TypeElement moduleElement,
+      final ValidationReport.Builder<?> reportBuilder) {
+    Visibility moduleVisibility = Visibility.ofElement(moduleElement);
+    if (moduleVisibility.equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+    } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+    }
+
+    switch (moduleElement.getNestingKind()) {
+      case ANONYMOUS:
+        throw new IllegalStateException("Can't apply @Module to an anonymous class");
+      case LOCAL:
+        throw new IllegalStateException("Local classes shouldn't show up in the processor");
+      case MEMBER:
+      case TOP_LEVEL:
+        if (moduleVisibility.equals(PUBLIC)) {
+          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
+              getAnnotationMirror(moduleElement, moduleClass).get()))
+                  .transform(new Function<TypeMirror, Element>() {
+                    @Override public Element apply(TypeMirror input) {
+                      return types.asElement(input);
+                    }
+                  })
+                  .filter(new Predicate<Element>() {
+                    @Override public boolean apply(Element input) {
+                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                    }
+                  })
+                  .toSet();
+          if (!nonPublicModules.isEmpty()) {
+            reportBuilder.addItem(
+                String.format(
+                    "This module is public, but it includes non-public "
+                        + "(or effectively non-public) modules. "
+                        + "Either reduce the visibility of this module or make %s public.",
+                    formatListForErrorMessage(nonPublicModules.asList())),
+                moduleElement);
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static String formatListForErrorMessage(List<?> things) {
+    switch (things.size()) {
+      case 0:
+        return "";
+      case 1:
+        return things.get(0).toString();
+      default:
+        StringBuilder output = new StringBuilder();
+        Joiner.on(", ").appendTo(output, things.subList(0, things.size() - 1));
+        output.append(" and ").append(things.get(things.size() - 1));
+        return output.toString();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
new file mode 100644
index 000000000..bb9ba982c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.annotation.processing.Messager;
+
+/**
+ * An interface for types that represent a compilation
+ * {@linkplain javax.tools.Diagnostic.Kind#ERROR error} (though, not necessarily a
+ * {@link Throwable}) that can be printed using a {@link Messager}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+interface PrintableErrorMessage {
+  /**
+   * Prints the information represented by this object to the given {@link Messager} as an
+   * {@link javax.tools.Diagnostic.Kind#ERROR}.
+   */
+  void printMessageTo(Messager messager);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
deleted file mode 100644
index 51bc22835..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-/**
- * Utility class providing some commonly used boilerplate between {@code InjectProcessor}
- * and {@code ProvidesProcessor}.
- */
-public final class ProcessorJavadocs {
-  static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
-  static final String MEMBERS_INJECT_METHOD = ""
-      + "Injects any {@code @Inject} annotated fields in the given instance,\n"
-      + "satisfying the contract for {@code Provider<%s>}.";
-  static final String GET_METHOD = ""
-      + "Returns the fully provisioned instance satisfying the contract for\n"
-      + "{@code Provider<%s>}.";
-  static final String GET_DEPENDENCIES_METHOD = ""
-      + "Used internally obtain dependency information, such as for cyclical\n"
-      + "graph detection.";
-  static final String ATTACH_METHOD = ""
-      + "Used internally to link bindings/providers together at run time\n"
-      + "according to their dependency graph.";
-  static final String STATIC_INJECT_METHOD = ""
-      + "Performs the injections of dependencies into static fields when requested by\n"
-      + "the {@code dagger.ObjectGraph}.";
-  static final String MODULE_TYPE = ""
-      + "A manager of modules and provides adapters allowing for proper linking and\n"
-      + "instance provision of types served by {@code @Provides} methods.";
-  static final String STATIC_INJECTION_TYPE = ""
-      + "A manager for {@code %s}'s injections into static fields.";
-
-  /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String binderTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
-    StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binder<").append(type).append(">} implementation which satisfies\n");
-    sb.append("Dagger's infrastructure requirements including:");
-    if (dependent) {
-      sb.append("\n\n");
-      sb.append("Owning the dependency links between {@code " + type + "} and its\n");
-      sb.append("dependencies.");
-    }
-    if (!abstrakt) {
-      sb.append("\n\n");
-      sb.append("Being a {@code Provider<" + type + ">} and handling creation and\n");
-      sb.append("preparation of object instances.");
-    }
-    if (members) {
-      sb.append("\n\n");
-      sb.append("Being a {@code MembersInjector<" + type + ">} and handling injection\n");
-      sb.append("of annotated fields.");
-    }
-    return sb.toString();
-  }
-
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
new file mode 100644
index 000000000..d4d55f8d3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Provides.Type;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.Produces;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.Producers;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
+
+import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  ProducerFactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ProductionBinding binding) {
+    return factoryNameForProductionBinding(binding);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ProductionBinding binding) {
+    return ImmutableSet.of(binding.bindingElement());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
+    TypeMirror keyType = binding.productionType().equals(Type.MAP)
+        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
+        : binding.key().type();
+    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
+    TypeName futureTypeName = ParameterizedTypeName.create(
+        ClassName.fromClass(ListenableFuture.class), providedTypeName);
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+
+    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
+    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+
+    factoryWriter.addField(binding.bindingTypeElement(), "module")
+        .addModifiers(PRIVATE, FINAL);
+    constructorWriter.addParameter(binding.bindingTypeElement(), "module");
+    constructorWriter.body()
+        .addSnippet("assert module != null;")
+        .addSnippet("this.module = module;");
+
+    factoryWriter.addField(Executor.class, "executor")
+        .addModifiers(PRIVATE, FINAL);
+    constructorWriter.addParameter(Executor.class, "executor");
+    constructorWriter.body()
+        .addSnippet("assert executor != null;")
+        .addSnippet("this.executor = executor;");
+
+    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    factoryWriter.addModifiers(PUBLIC);
+    factoryWriter.addModifiers(FINAL);
+    factoryWriter.setSuperType(
+        ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
+
+    MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
+    getMethodWriter.annotate(Override.class);
+    getMethodWriter.addModifiers(PROTECTED);
+
+    final ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.dependencies());
+
+    for (FrameworkField bindingField : fields.values()) {
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body()
+          .addSnippet("assert %s != null;", field.name())
+          .addSnippet("this.%1$s = %1$s;", field.name());
+    }
+
+    boolean returnsFuture = binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION);
+    ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
+        .from(binding.dependencies())
+        .filter(new Predicate<DependencyRequest>() {
+          @Override public boolean apply(DependencyRequest dependency) {
+            return isAsyncDependency(dependency);
+          }
+        })
+        .toList();
+
+    for (DependencyRequest dependency : asyncDependencies) {
+      ParameterizedTypeName futureType = ParameterizedTypeName.create(
+          ClassName.fromClass(ListenableFuture.class),
+          asyncDependencyType(dependency));
+      String name = fields.get(dependency.bindingKey()).name();
+      Snippet futureAccess = Snippet.format("%s.get()", name);
+      getMethodWriter.body().addSnippet("%s %sFuture = %s;",
+          futureType,
+          name,
+          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+              ? Snippet.format("%s.createFutureProduced(%s)",
+                  ClassName.fromClass(Producers.class), futureAccess)
+              : futureAccess);
+    }
+
+    if (asyncDependencies.isEmpty()) {
+      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        parameterSnippets.add(frameworkTypeUsageStatement(
+            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+      }
+      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
+      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+          parameterSnippets.build());
+      TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
+      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+      Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
+          "new %1$s<%2$s>() {",
+          "  @Override public %2$s call() %3$s{",
+          "    return %4$s;",
+          "  }",
+          "}"),
+          ClassName.fromClass(Callable.class),
+          callableReturnType,
+          throwsClause,
+          invocationSnippet);
+      getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
+          ParameterizedTypeName.create(
+              ClassName.fromClass(ListenableFuture.class),
+              callableReturnType),
+          ClassName.fromClass(Producers.class),
+          callableSnippet);
+      getMethodWriter.body().addSnippet("return %s;",
+          returnsFuture
+              ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
+              : "future");
+    } else {
+      final Snippet futureSnippet;
+      final Snippet transformSnippet;
+      if (asyncDependencies.size() == 1) {
+        DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
+        futureSnippet = Snippet.format("%s",
+            fields.get(asyncDependency.bindingKey()).name() + "Future");
+        String argName = asyncDependency.requestElement().getSimpleName().toString();
+        ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+        for (DependencyRequest dependency : binding.dependencies()) {
+          // We really want to compare instances here, because asyncDependency is an element in the
+          // set binding.dependencies().
+          if (dependency == asyncDependency) {
+            parameterSnippets.add(Snippet.format("%s", argName));
+          } else {
+            parameterSnippets.add(frameworkTypeUsageStatement(
+                Snippet.format(fields.get(dependency.bindingKey()).name()),
+                dependency.kind()));
+          }
+        }
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets.build());
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+        transformSnippet = Snippet.format(Joiner.on('\n').join(
+            "new %1$s<%2$s, %3$s>() {",
+            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
+            "    return %7$s;",
+            "  }",
+            "}"),
+            ClassName.fromClass(AsyncFunction.class),
+            asyncDependencyType(asyncDependency),
+            providedTypeName,
+            futureTypeName,
+            argName,
+            throwsClause,
+            invocationSnippet);
+      } else {
+        futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
+            ClassName.fromClass(Futures.class),
+            ClassName.fromClass(Object.class),
+            Joiner.on(",").join(FluentIterable
+                .from(asyncDependencies)
+                .transform(new Function<DependencyRequest, String>() {
+                  @Override public String apply(DependencyRequest dependency) {
+                    return fields.get(dependency.bindingKey()).name() + "Future";
+                  }
+                })));
+        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets);
+        ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
+            ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+        transformSnippet = Snippet.format(Joiner.on('\n').join(
+            "new %1$s<%2$s, %3$s>() {",
+            "  @SuppressWarnings(\"unchecked\")  // safe by specification",
+            "  @Override public %4$s apply(%2$s args) %5$s{",
+            "    return %6$s;",
+            "  }",
+            "}"),
+            ClassName.fromClass(AsyncFunction.class),
+            listOfObject,
+            providedTypeName,
+            futureTypeName,
+            throwsClause,
+            invocationSnippet);
+      }
+      getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
+          ClassName.fromClass(Futures.class),
+          "transform",
+          futureSnippet,
+          transformSnippet);
+    }
+
+    // TODO(gak): write a sensible toString
+    return ImmutableSet.of(writer);
+  }
+
+  private boolean isAsyncDependency(DependencyRequest dependency) {
+    switch (dependency.kind()) {
+      case INSTANCE:
+      case PRODUCED:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  private TypeName asyncDependencyType(DependencyRequest dependency) {
+    TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return keyName;
+      case PRODUCED:
+        return ParameterizedTypeName.create(ClassName.fromClass(Produced.class), keyName);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
+      ImmutableMap<BindingKey, FrameworkField> fields,
+      String listArgName) {
+    int argIndex = 0;
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    for (DependencyRequest dependency : binding.dependencies()) {
+      if (isAsyncDependency(dependency)) {
+        snippets.add(Snippet.format(
+            "(%s) %s.get(%s)",
+            asyncDependencyType(dependency),
+            listArgName,
+            argIndex));
+        argIndex++;
+      } else {
+        snippets.add(frameworkTypeUsageStatement(
+            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+      }
+    }
+    return snippets.build();
+  }
+
+  /**
+   * Creates a Snippet for the invocation of the producer method from the module.
+   *
+   * @param wrapWithFuture If true, wraps the result of the call to the producer method
+   *        in an immediate future.
+   * @param binding The binding to generate the invocation snippet for.
+   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   */
+  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
+      ImmutableList<Snippet> parameterSnippets) {
+    Snippet moduleSnippet = Snippet.format("module.%s(%s)",
+        binding.bindingElement().getSimpleName(),
+        makeParametersSnippet(parameterSnippets));
+    if (wrapWithFuture) {
+      moduleSnippet = Snippet.format("%s.immediateFuture(%s)",
+          ClassName.fromClass(Futures.class),
+          moduleSnippet);
+    }
+    if (binding.productionType().equals(Produces.Type.SET)) {
+      if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
+        return Snippet.format("%s.createFutureSingletonSet(%s)",
+            ClassName.fromClass(Producers.class),
+            moduleSnippet);
+      } else {
+        return Snippet.format("%s.of(%s)",
+            ClassName.fromClass(ImmutableSet.class),
+            moduleSnippet);
+      }
+    } else {
+      return moduleSnippet;
+    }
+  }
+
+  /**
+   * Creates a Snippet for the throws clause.
+   *
+   * @param thrownTypes the list of thrown types.
+   */
+  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+    if (thrownTypes.isEmpty()) {
+      return Snippet.format("");
+    }
+    return Snippet.format("throws %s ",
+        Snippet.makeParametersSnippet(FluentIterable
+            .from(thrownTypes)
+            .transform(new Function<TypeMirror, Snippet>() {
+              @Override public Snippet apply(TypeMirror thrownType) {
+                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
+              }
+            })
+            .toList()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
new file mode 100644
index 000000000..3e7d81dc6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.SuperficialValidation;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the
+ * {@link ProducerModule} (and {@link Produces}) annotation.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProducerModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ModuleValidator moduleValidator;
+  private final ProducesMethodValidator producesMethodValidator;
+  private final ProductionBinding.Factory productionBindingFactory;
+  private final ProducerFactoryGenerator factoryGenerator;
+  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
+
+  ProducerModuleProcessingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      ProducesMethodValidator producesMethodValidator,
+      ProductionBinding.Factory productionBindingFactory,
+      ProducerFactoryGenerator factoryGenerator) {
+    this.messager = messager;
+    this.moduleValidator = moduleValidator;
+    this.producesMethodValidator = producesMethodValidator;
+    this.productionBindingFactory = productionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Produces.class, ProducerModule.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    // first, check and collect all produces methods
+    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
+    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
+      if (producesElement.getKind().equals(METHOD)) {
+        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            producesMethodValidator.validate(producesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProducesMethodsBuilder.add(producesMethodElement);
+        }
+      }
+    }
+    ImmutableSet<ExecutableElement> validProducesMethods = validProducesMethodsBuilder.build();
+
+    // process each module
+    for (Element moduleElement :
+        Sets.difference(elementsByAnnotation.get(ProducerModule.class),
+            processedModuleElements)) {
+      if (SuperficialValidation.validateElement(moduleElement)) {
+        ValidationReport<TypeElement> report =
+            moduleValidator.validate(MoreElements.asType(moduleElement));
+        report.printMessagesTo(messager);
+
+        if (report.isClean()) {
+          ImmutableSet.Builder<ExecutableElement> moduleProducesMethodsBuilder =
+              ImmutableSet.builder();
+          List<ExecutableElement> moduleMethods =
+              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+          for (ExecutableElement methodElement : moduleMethods) {
+            if (isAnnotationPresent(methodElement, Produces.class)) {
+              moduleProducesMethodsBuilder.add(methodElement);
+            }
+          }
+          ImmutableSet<ExecutableElement> moduleProducesMethods =
+              moduleProducesMethodsBuilder.build();
+
+          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
+            // all of the produces methods in this module are valid!
+            // time to generate some factories!
+            ImmutableSet<ProductionBinding> bindings = FluentIterable.from(moduleProducesMethods)
+                .transform(new Function<ExecutableElement, ProductionBinding>() {
+                  @Override
+                  public ProductionBinding apply(ExecutableElement producesMethod) {
+                    return productionBindingFactory.forProducesMethod(producesMethod,
+                        producesMethod.getEnclosingElement().asType());
+                  }
+                })
+                .toSet();
+
+            try {
+              for (ProductionBinding binding : bindings) {
+                factoryGenerator.generate(binding);
+              }
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
+          }
+        }
+
+        processedModuleElements.add(moduleElement);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
new file mode 100644
index 000000000..cf4b43ec7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * A {@link Validator} for {@link Produces} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// Produces.Type are reconciled.
+final class ProducesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProducesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(producesMethodElement);
+
+    Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
+    checkArgument(producesAnnotation != null);
+
+    Element enclosingElement = producesMethodElement.getEnclosingElement();
+    if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
+          producesMethodElement);
+    }
+
+    if (!producesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+    }
+
+    Set<Modifier> modifiers = producesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+    }
+
+    TypeMirror returnType = producesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          producesMethodElement);
+    }
+
+    // check mapkey is right
+    if (!producesAnnotation.type().equals(Produces.Type.MAP)
+        && (getMapKeys(producesMethodElement) != null
+            && !getMapKeys(producesMethodElement).isEmpty())) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          producesMethodElement);
+    }
+
+    ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
+
+    switch (producesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateSingleReturnType(builder, returnType);
+        break;
+      case MAP:
+        validateSingleReturnType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(producesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                producesMethodElement);
+            break;
+          case 1:
+            break;
+          default:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                producesMethodElement);
+            break;
+        }
+        break;
+      case SET_VALUES:
+        if (returnTypeKind.equals(DECLARED)
+            && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+          DeclaredType declaredReturnType = MoreTypes.asDeclared(returnType);
+          if (!declaredReturnType.getTypeArguments().isEmpty()) {
+            validateSetType(builder, Iterables.getOnlyElement(
+                declaredReturnType.getTypeArguments()));
+          }
+        } else {
+          validateSetType(builder, returnType);
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName(), ProducerModule.class.getSimpleName());
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+
+  private void validateSingleReturnType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+      DeclaredType declaredType = MoreTypes.asDeclared(type);
+      if (declaredType.getTypeArguments().isEmpty()) {
+        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+      } else {
+        validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+      }
+    } else {
+      validateKeyType(reportBuilder, type);
+    }
+  }
+
+  private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (!type.getKind().equals(DECLARED)) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      return;
+    }
+
+    // TODO(gak): should we allow "covariant return" for set values?
+    DeclaredType declaredType = MoreTypes.asDeclared(type);
+    if (!declaredType.asElement().equals(getSetElement())) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+    } else if (declaredType.getTypeArguments().isEmpty()) {
+      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+          reportBuilder.getSubject());
+    } else {
+      validateSingleReturnType(reportBuilder,
+          Iterables.getOnlyElement(declaredType.getTypeArguments()));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
new file mode 100644
index 000000000..38d45e6a2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.Produces;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be produced. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProductionBinding extends ContributionBinding {
+  @Override
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return dependencies();
+  }
+
+  enum Kind {
+    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
+    IMMEDIATE,
+    /** Represents a binding configured by {@link Produces} that returns a future. */
+    FUTURE_PRODUCTION,
+    /**
+     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC_PRODUCTION,
+    /**
+     * Represents a binding from a production method on a component dependency that returns a
+     * future. Methods that return immediate values are considered provision bindings.
+     */
+    COMPONENT_PRODUCTION,
+  }
+
+  /**
+   * The type of binding (whether the {@link Produces} method returns a future). For the particular
+   * type of production, use {@link #productionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Produces.Type productionType();
+
+  /** Returns the list of types in the throws clause of the method. */
+  abstract ImmutableList<? extends TypeMirror> thrownTypes();
+
+  @Override
+  BindingType bindingType() {
+    switch (productionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown production type: " + productionType());
+    }
+  }
+
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Producer.class;
+  }
+
+  static final class Factory {
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Types types,
+        Key.Factory keyFactory,
+        DependencyRequest.Factory
+        dependencyRequestFactory) {
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    ProductionBinding forProducesMethod(
+        ExecutableElement producesMethod, TypeMirror contributedBy) {
+      checkNotNull(producesMethod);
+      checkArgument(producesMethod.getKind().equals(METHOD));
+      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
+      Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, producesMethod));
+      Key key = keyFactory.forProducesMethod(resolvedMethod, producesMethod);
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              declaredContainer,
+              producesMethod.getParameters(),
+              resolvedMethod.getParameterTypes());
+      Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
+          ? Kind.FUTURE_PRODUCTION
+          : Kind.IMMEDIATE;
+      return new AutoValue_ProductionBinding(
+          key,
+          producesMethod,
+          dependencies,
+          findBindingPackage(key),
+          false,
+          ConfigurationAnnotations.getNullableType(producesMethod),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          kind,
+          producesAnnotation.type(),
+          ImmutableList.copyOf(producesMethod.getThrownTypes()));
+    }
+
+    ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
+        DependencyRequest implicitRequest) {
+      checkNotNull(explicitRequest);
+      checkNotNull(implicitRequest);
+      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+      return new AutoValue_ProductionBinding(
+          explicitRequest.key(),
+          implicitRequest.requestElement(),
+          dependencies,
+          findBindingPackage(explicitRequest.key()),
+          false,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.SYNTHETIC_PRODUCTION,
+          Produces.Type.MAP,
+          ImmutableList.<TypeMirror>of());
+    }
+
+    ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      checkArgument(componentMethod.getParameters().isEmpty());
+      checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
+      return new AutoValue_ProductionBinding(
+          keyFactory.forProductionComponentMethod(componentMethod),
+          componentMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.COMPONENT_PRODUCTION,
+          Produces.Type.UNIQUE,
+          ImmutableList.copyOf(componentMethod.getThrownTypes()));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
new file mode 100644
index 000000000..e7e7e778a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.auto.common.MoreTypes.asDeclared;
+
+/**
+ * Formats a {@link ProductionBinding} into a {@link String} suitable for use in error messages.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProductionBindingFormatter extends Formatter<ProductionBinding> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  ProductionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override public String format(ProductionBinding binding) {
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+            Optional.of(asDeclared(binding.contributedBy().get().asType())));
+      case COMPONENT_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+      default:
+        throw new UnsupportedOperationException(
+            "Not yet supporting " + binding.bindingKind() + " binding types.");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
new file mode 100644
index 000000000..187cecd73
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
+ * annotation as part of the {@link ComponentProcessor}.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ProductionComponentValidator componentValidator;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
+
+  ProductionComponentProcessingStep(
+      Messager messager,
+      ProductionComponentValidator componentValidator,
+      BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(ProductionComponent.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Set<? extends Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
+
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> componentReport =
+          componentValidator.validate(componentTypeElement);
+      componentReport.printMessagesTo(messager);
+      if (componentReport.isClean()) {
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.forProductionComponent(componentTypeElement);
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport =
+            bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
new file mode 100644
index 000000000..6107280e4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentValidator implements Validator<TypeElement> {
+  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addItem("@ProductionComponent may only be applied to an interface or abstract class",
+          subject);
+    }
+
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, ProductionComponent.class).get();
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
+
+    // TODO(gak): make unused modules an error
+    for (TypeMirror moduleType : moduleTypes) {
+      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          checkState(t.getTypeArguments().isEmpty());
+          TypeElement moduleElement = MoreElements.asType(t.asElement());
+          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
+              && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
+            builder.addItem(moduleElement.getQualifiedName()
+                + " is listed as a module, but is not annotated with @Module or @ProducerModule",
+                subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
new file mode 100644
index 000000000..535c5fa26
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.Module;
+import dagger.Provides;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * A {@link Validator} for {@link Provides} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProvidesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(providesMethodElement);
+
+    Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
+    checkArgument(providesAnnotation != null);
+
+    Element enclosingElement = providesMethodElement.getEnclosingElement();
+    if (!isAnnotationPresent(enclosingElement, Module.class)) {
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
+          providesMethodElement);
+    }
+    
+    if (!providesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
+          providesMethodElement);
+    }
+
+    Set<Modifier> modifiers = providesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
+          providesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
+    }
+
+    TypeMirror returnType = providesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          providesMethodElement);
+    }
+  
+    // check mapkey is right
+    if (!providesAnnotation.type().equals(Provides.Type.MAP) 
+        && (getMapKeys(providesMethodElement) != null
+            && getMapKeys(providesMethodElement).size() > 0)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          providesMethodElement);
+    }
+
+    validateMethodQualifiers(builder, providesMethodElement);
+
+    switch (providesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateKeyType(builder, returnType);
+        break;
+      case MAP:
+        validateKeyType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(providesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                providesMethodElement);
+            break;
+          case 1:
+            break;
+          default:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                providesMethodElement);
+            break;
+        }
+        break;
+      case SET_VALUES:
+        if (!returnTypeKind.equals(DECLARED)) {
+          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+        } else {
+          DeclaredType declaredReturnType = (DeclaredType) returnType;
+          // TODO(gak): should we allow "covariant return" for set values?
+          if (!declaredReturnType.asElement().equals(getSetElement())) {
+            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
+            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+                providesMethodElement);
+          } else {
+            validateKeyType(builder,
+                Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  /** Validates that a Provides or Produces method doesn't have multiple qualifiers. */
+  static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement methodElement) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+      }
+    }
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
deleted file mode 100644
index f4bf614fb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ /dev/null
@@ -1,418 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
-import static java.lang.reflect.Modifier.PUBLIC;
-import static java.lang.reflect.Modifier.STATIC;
-
-/**
- * Generates an implementation of {@link ModuleAdapter} that includes a binding
- * for each {@code @Provides} method of a target class.
- */
-@SupportedAnnotationTypes("dagger.Provides")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
-public final class ProvidesProcessor extends AbstractProcessor {
-  private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
-      new LinkedHashMap<String, List<ExecutableElement>>();
-  private static final String BINDINGS_MAP = CodeGen.parameterizedType(
-      Map.class, String.class.getName(), Binding.class.getName() + "<?>");
-
-  // TODO: include @Provides methods from the superclass
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    remainingTypes.putAll(providerMethodsByClass(env));
-    for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
-      String typeName = i.next();
-      TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
-      List<ExecutableElement> providesTypes = remainingTypes.get(typeName);
-      try {
-        // Attempt to get the annotation. If types are missing, this will throw
-        // IllegalStateException.
-        Map<String, Object> parsedAnnotation = CodeGen.getAnnotation(Module.class, type);
-        try {
-          writeModuleAdapter(type, parsedAnnotation, providesTypes);
-        } catch (IOException e) {
-          error("Code gen failed: " + e, type);
-        }
-        i.remove();
-      } catch (IllegalStateException e) {
-        // a dependent type was not defined, we'll catch it on another pass
-      }
-    }
-    if (env.processingOver() && remainingTypes.size() > 0) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-          "Could not find types required by provides methods for " + remainingTypes.keySet());
-    }
-    return true;
-  }
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
-  /**
-   * Returns a map containing all {@code @Provides} methods, indexed by class.
-   */
-  private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
-    Map<String, List<ExecutableElement>> result
-        = new HashMap<String, List<ExecutableElement>>();
-    for (Element providerMethod : providesMethods(env)) {
-      TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
-      Set<Modifier> typeModifiers = type.getModifiers();
-      if (type.getKind() != ElementKind.CLASS) {
-        // TODO(tbroyer): pass annotation information
-        error("Unexpected @Provides on " + providerMethod, providerMethod);
-        continue;
-      }
-      if (typeModifiers.contains(Modifier.PRIVATE)
-          || typeModifiers.contains(Modifier.ABSTRACT)) {
-        error("Classes declaring @Provides methods must not be private or abstract: "
-                + type.getQualifiedName(), type);
-        continue;
-      }
-
-      Set<Modifier> methodModifiers = providerMethod.getModifiers();
-      if (methodModifiers.contains(Modifier.PRIVATE)
-          || methodModifiers.contains(Modifier.ABSTRACT)
-          || methodModifiers.contains(Modifier.STATIC)) {
-        error("@Provides methods must not be private, abstract or static: "
-                + type.getQualifiedName() + "." + providerMethod, providerMethod);
-        continue;
-      }
-
-      List<ExecutableElement> methods = result.get(type.toString());
-      if (methods == null) {
-        methods = new ArrayList<ExecutableElement>();
-        result.put(type.toString(), methods);
-      }
-      methods.add((ExecutableElement) providerMethod);
-    }
-
-    return result;
-  }
-
-  private Set<? extends Element> providesMethods(RoundEnvironment env) {
-    Set<Element> result = new LinkedHashSet<Element>();
-    result.addAll(env.getElementsAnnotatedWith(Provides.class));
-    return result;
-  }
-
-  /**
-   * Write a companion class for {@code type} that implements {@link
-   * ModuleAdapter} to expose its provider methods.
-   */
-  private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
-      List<ExecutableElement> providerMethods) throws IOException {
-    if (module == null) {
-      error(type + " has @Provides methods but no @Module annotation", type);
-      return;
-    }
-
-    Object[] staticInjections = (Object[]) module.get("staticInjections");
-    Object[] entryPoints = (Object[]) module.get("entryPoints");
-    Object[] includes = (Object[]) module.get("includes");
-
-    boolean overrides = (Boolean) module.get("overrides");
-    boolean complete = (Boolean) module.get("complete");
-
-    String adapterName = CodeGen.adapterName(type, MODULE_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    boolean multibindings = checkForMultibindings(providerMethods);
-    boolean providerMethodDependencies = checkForDependencies(providerMethods);
-
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-    writer.emitEmptyLine();
-    writer.emitImports(getImports(multibindings, providerMethodDependencies));
-
-    String typeName = type.getQualifiedName().toString();
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.MODULE_TYPE);
-    writer.beginType(adapterName, "class", PUBLIC | FINAL,
-        CodeGen.parameterizedType(ModuleAdapter.class, typeName));
-
-    StringBuilder entryPointsField = new StringBuilder().append("{ ");
-    for (Object entryPoint : entryPoints) {
-      TypeMirror typeMirror = (TypeMirror) entryPoint;
-      String key = GeneratorKeys.rawMembersKey(typeMirror);
-      entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
-    }
-    entryPointsField.append("}");
-    writer.field("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
-        entryPointsField.toString());
-
-    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
-    for (Object staticInjection : staticInjections) {
-      TypeMirror typeMirror = (TypeMirror) staticInjection;
-      staticInjectionsField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
-    }
-    staticInjectionsField.append("}");
-    writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
-        staticInjectionsField.toString());
-
-    StringBuilder includesField = new StringBuilder().append("{ ");
-    for (Object include : includes) {
-      if (!(include instanceof TypeMirror)) {
-        // TODO(tbroyer): pass annotation information
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value: " + include + " in includes of " + type, type);
-        continue;
-      }
-      TypeMirror typeMirror = (TypeMirror) include;
-      includesField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
-    }
-    includesField.append("}");
-    writer.field("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, PUBLIC);
-    writer.emitStatement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/)", overrides, complete);
-    writer.endMethod();
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
-
-    Map<ExecutableElement, String> methodToClassName
-        = new LinkedHashMap<ExecutableElement, String>();
-    Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
-    for (ExecutableElement providerMethod : providerMethods) {
-      Provides provides = providerMethod.getAnnotation(Provides.class);
-      switch (provides.type()) {
-        case UNIQUE: {
-          String key = GeneratorKeys.get(providerMethod);
-          writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        case SET: {
-          String key = GeneratorKeys.getElementKey(providerMethod);
-          writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
-              JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        default:
-          throw new AssertionError("Unknown @Provides type " + provides.type());
-      }
-    }
-    writer.endMethod();
-
-    writer.emitEmptyLine();
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(typeName, "newModule", PROTECTED);
-    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
-    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
-      writer.emitStatement("return new %s()", typeName);
-    } else {
-      writer.emitStatement("throw new UnsupportedOperationException(%s)",
-          JavaWriter.stringLiteral("No no-args constructor on " + type));
-    }
-    writer.endMethod();
-
-    for (ExecutableElement providerMethod : providerMethods) {
-      writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId);
-    }
-
-    writer.endType();
-    writer.close();
-  }
-
-  private Set<String> getImports(boolean multibindings, boolean dependencies) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getName());
-    imports.add(Map.class.getName());
-    imports.add(Provider.class.getName());
-    imports.add(ModuleAdapter.class.getName());
-    if (dependencies) {
-      imports.add(Linker.class.getName());
-      imports.add(Set.class.getName());
-    }
-    if (multibindings) {
-      imports.add(SetBinding.class.getName());
-    }
-    return imports;
-  }
-
-  private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      if (!element.getParameters().isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      if (element.getAnnotation(Provides.class).type() == Provides.Type.SET) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private String bindingClassName(ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId) {
-    String className = methodToClassName.get(providerMethod);
-    if (className != null) return className;
-
-    String methodName = providerMethod.getSimpleName().toString();
-    String suffix = "";
-    AtomicInteger id = methodNameToNextId.get(methodName);
-    if (id == null) {
-      methodNameToNextId.put(methodName, new AtomicInteger(2));
-    } else {
-      suffix = id.toString();
-      id.incrementAndGet();
-    }
-    String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
-        + methodName.substring(1);
-    className = uppercaseMethodName + "ProvidesAdapter" + suffix;
-    methodToClassName.put(providerMethod, className);
-    return className;
-  }
-
-  private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId)
-      throws IOException {
-    String methodName = providerMethod.getSimpleName().toString();
-    String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
-    String className = bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
-    String returnType = CodeGen.typeToString(providerMethod.getReturnType());
-    List<? extends VariableElement> parameters = providerMethod.getParameters();
-    boolean dependent = !parameters.isEmpty();
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(binderTypeDocs(returnType, false, false, dependent));
-    writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
-        CodeGen.parameterizedType(Binding.class, returnType),
-        CodeGen.parameterizedType(Provider.class, returnType));
-    writer.emitField(moduleType, "module", PRIVATE | FINAL);
-    for (Element parameter : parameters) {
-      TypeMirror parameterType = parameter.asType();
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
-          CodeGen.typeToString(parameterType)),
-          parameterName(parameter), PRIVATE);
-    }
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, className, PUBLIC, moduleType, "module");
-    boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
-    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    String membersKey = null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
-    writer.emitStatement("this.module = module");
-    writer.endMethod();
-
-    if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-      for (VariableElement parameter : parameters) {
-        String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
-            parameterName(parameter),
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
-                CodeGen.typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(parameterKey),
-            writer.compressType(moduleType));
-      }
-      writer.endMethod();
-
-      writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-          setOfBindings, "injectMembersBindings");
-      for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
-      }
-      writer.endMethod();
-    }
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, returnType);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(returnType, "get", PUBLIC);
-    StringBuilder args = new StringBuilder();
-    boolean first = true;
-    for (Element parameter : parameters) {
-      if (!first) args.append(", ");
-      else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
-    }
-    writer.emitStatement("return module.%s(%s)", methodName, args.toString());
-    writer.endMethod();
-
-    writer.endType();
-  }
-
-  private String parameterName(Element parameter) {
-    if (parameter.getSimpleName().equals("module")) {
-      return "parameter_" + parameter.getSimpleName().toString();
-    }
-    return parameter.getSimpleName().toString();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
new file mode 100644
index 000000000..aec51f038
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import dagger.Provides;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be provided. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProvisionBinding extends ContributionBinding {
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
+    if (!memberInjectionRequest().isPresent()) {
+      return dependencies();
+    } else {
+      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
+      return Sets.union(memberInjectionRequest().asSet(), dependencies());
+    }
+  }
+
+  enum Kind {
+    /** Represents an {@link Inject} binding. */
+    INJECTION,
+    /** Represents a binding configured by {@link Provides}. */
+    PROVISION,
+    /**
+     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC_PROVISON,
+    /** Represents the implicit binding to the component. */
+    COMPONENT,
+    /** Represents a binding from a provision method on a component dependency. */
+    COMPONENT_PROVISION,
+  }
+
+  /**
+   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
+   * use {@link #provisionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
+
+  /** The scope in which the binding declares the {@link #key()}. */
+  Optional<AnnotationMirror> scope() {
+    return unwrapOptionalEquivalence(wrappedScope());
+  }
+
+  /**
+   * An optional annotation constraining the scope of this component wrapped in an
+   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
+   * {@link AnnotationMirror}.
+   */
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> memberInjectionRequest();
+
+  @Override
+  BindingType bindingType() {
+    switch (provisionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown provision type: " + provisionType());
+    }
+  }
+
+  @Override
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
+  }
+
+  @Override
+  Class<?> frameworkClass() {
+    return Provider.class;
+  }
+
+  enum FactoryCreationStrategy {
+    ENUM_INSTANCE,
+    CLASS_CONSTRUCTOR,
+  }
+
+  FactoryCreationStrategy factoryCreationStrategy() {
+    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    if (bindingKind().equals(PROVISION)
+        && implicitDependencies().isEmpty()
+        && bindingElement().getModifiers().contains(STATIC)) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    /** Returns an unresolved version of this binding. */
+    ProvisionBinding unresolve(ProvisionBinding binding) {
+      checkState(binding.hasNonDefaultTypeParameters());
+      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
+          Optional.<TypeMirror>absent());
+    }
+
+    /**
+     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
+     * will return a resolved binding, with the key & type resolved to the given type (using
+     * {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
+        Optional<TypeMirror> resolvedType) {
+      checkNotNull(constructorElement);
+      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
+      checkArgument(isAnnotationPresent(constructorElement, Inject.class));
+      checkArgument(!getQualifier(constructorElement).isPresent());
+
+      ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
+      DeclaredType enclosingCxtorType =
+          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+      // If the class this is constructing has some type arguments, resolve everything.
+      if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(enclosingCxtorType));
+        cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
+        enclosingCxtorType = resolved;
+      }
+
+      Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
+      checkArgument(!key.qualifier().isPresent());
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredResolvedVariables(enclosingCxtorType,
+              constructorElement.getParameters(),
+              cxtorType.getParameterTypes());
+      Optional<DependencyRequest> membersInjectionRequest =
+          membersInjectionRequest(enclosingCxtorType);
+      Optional<AnnotationMirror> scope =
+          getScopeAnnotation(constructorElement.getEnclosingElement());
+
+      TypeElement bindingTypeElement =
+          MoreElements.asType(constructorElement.getEnclosingElement());
+
+      return new AutoValue_ProvisionBinding(
+          key,
+          constructorElement,
+          dependencies,
+          findBindingPackage(key),
+          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.INJECTION,
+          Provides.Type.UNIQUE,
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          membersInjectionRequest);
+    }
+
+    private static final ImmutableSet<ElementKind> MEMBER_KINDS =
+        Sets.immutableEnumSet(METHOD, FIELD);
+
+    private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
+      TypeElement typeElement = MoreElements.asType(type.asElement());
+      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
+          typeElement.getSuperclass())) {
+        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
+      }
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
+        if (MEMBER_KINDS.contains(enclosedElement.getKind())
+            && (isAnnotationPresent(enclosedElement, Inject.class))) {
+          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
+        }
+      }
+      return Optional.absent();
+    }
+
+    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror contributedBy) {
+      checkNotNull(providesMethod);
+      checkArgument(providesMethod.getKind().equals(METHOD));
+      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
+      Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
+      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
+      Key key = keyFactory.forProvidesMethod(resolvedMethod, providesMethod);
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              declaredContainer,
+              providesMethod.getParameters(),
+              resolvedMethod.getParameterTypes());
+      Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
+      return new AutoValue_ProvisionBinding(
+          key,
+          providesMethod,
+          dependencies,
+          findBindingPackage(key),
+          false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(providesMethod),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Kind.PROVISION,
+          providesAnnotation.type(),
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          Optional.<DependencyRequest>absent());
+    }
+
+    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
+        DependencyRequest implicitRequest) {
+      checkNotNull(explicitRequest);
+      checkNotNull(implicitRequest);
+      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+      Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
+      return new AutoValue_ProvisionBinding(
+          explicitRequest.key(),
+          implicitRequest.requestElement(),
+          dependencies,
+          findBindingPackage(explicitRequest.key()),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.SYNTHETIC_PROVISON,
+          Provides.Type.MAP,
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          Optional.<DependencyRequest>absent());
+    }
+
+    ProvisionBinding forComponent(TypeElement componentDefinitionType) {
+      checkNotNull(componentDefinitionType);
+      return new AutoValue_ProvisionBinding(
+          keyFactory.forComponent(componentDefinitionType.asType()),
+          componentDefinitionType,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.COMPONENT,
+          Provides.Type.UNIQUE,
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          Optional.<DependencyRequest>absent());
+    }
+
+    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      checkArgument(componentMethod.getParameters().isEmpty());
+      Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
+      return new AutoValue_ProvisionBinding(
+          keyFactory.forComponentMethod(componentMethod),
+          componentMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(componentMethod),
+          Optional.<TypeElement>absent(),
+          Kind.COMPONENT_PROVISION,
+          Provides.Type.UNIQUE,
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          Optional.<DependencyRequest>absent());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
new file mode 100644
index 000000000..92d031042
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.auto.common.MoreTypes.asDeclared;
+
+/**
+ * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  
+  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override public String format(ProvisionBinding binding) {
+    switch (binding.bindingKind()) {
+      case PROVISION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+            Optional.of(asDeclared(binding.contributedBy().get().asType())));
+      case COMPONENT_PROVISION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+      default:
+        throw new UnsupportedOperationException(
+            "Not yet supporting " + binding.bindingKind() + " binding types.");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
deleted file mode 100644
index 74b98fbd7..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Linker;
-import java.util.List;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
-
-/**
- * A {@code Linker.ErrorHandler} which gathers errors and reports them via a processing
- * environment.
- */
-final class ReportingErrorHandler implements Linker.ErrorHandler {
-  private final ProcessingEnvironment processingEnv;
-  private final String moduleName;
-
-  ReportingErrorHandler(ProcessingEnvironment processingEnv, String moduleName) {
-    this.processingEnv = processingEnv;
-    this.moduleName = moduleName;
-  }
-
-  @Override public void handleErrors(List<String> errors) {
-    TypeElement module = processingEnv.getElementUtils().getTypeElement(moduleName);
-    for (String error : errors) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error + " for " + moduleName,
-          module);
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
new file mode 100644
index 000000000..e44ba4ca7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * The collection of bindings that have been resolved for a binding key.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class ResolvedBindings {
+  abstract BindingKey bindingKey();
+  abstract ImmutableSet<? extends Binding> ownedBindings();
+  abstract ImmutableSet<? extends Binding> bindings();
+
+  static ResolvedBindings create(
+      BindingKey bindingKey,
+      Set<? extends Binding> ownedBindings,
+      Set<? extends Binding> inheritedBindings) {
+    ImmutableSet<Binding> immutableOwnedBindings = ImmutableSet.copyOf(ownedBindings);
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        immutableOwnedBindings,
+        ImmutableSet.<Binding>builder()
+        .addAll(inheritedBindings)
+        .addAll(immutableOwnedBindings)
+        .build());
+  }
+
+  static ResolvedBindings create(
+      BindingKey bindingKey,
+      Binding... ownedBindings) {
+    ImmutableSet<Binding> bindings = ImmutableSet.copyOf(ownedBindings);
+    return new AutoValue_ResolvedBindings(bindingKey, bindings, bindings);
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends ContributionBinding> contributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return (ImmutableSet<? extends ContributionBinding>) bindings();
+  }
+
+  @SuppressWarnings("unchecked")  // checked by validator
+  ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
new file mode 100644
index 000000000..6ea9729d1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+/**
+ * An exception thrown to indicate that a source file could not be generated.
+ *
+ * <p>This exception <b>should not</b> be used to report detectable, logical errors as it may mask
+ * other errors that might have been caught upon further processing.  Use a {@link ValidationReport}
+ * for that.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
+  private final ImmutableSet<ClassName> generatedClassNames;
+  private final Optional<? extends Element> associatedElement;
+
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
+      Optional<? extends Element> associatedElement) {
+    super(createMessage(generatedClassNames, cause.getMessage()), cause);
+    this.generatedClassNames = ImmutableSet.copyOf(generatedClassNames);
+    this.associatedElement = checkNotNull(associatedElement);
+  }
+
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause) {
+    this(generatedClassNames, cause, Optional.<Element>absent());
+  }
+
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
+      Element associatedElement) {
+    this(generatedClassNames, cause, Optional.of(associatedElement));
+  }
+
+  public ImmutableSet<ClassName> generatedClassNames() {
+    return generatedClassNames;
+  }
+
+  public Optional<? extends Element> associatedElement() {
+    return associatedElement;
+  }
+
+  private static String createMessage(Iterable<ClassName> generatedClassNames, String message) {
+    return String.format("Could not generate %s: %s.",
+        Iterables.isEmpty(generatedClassNames)
+            ? "unknown files"
+            : Iterables.toString(generatedClassNames),
+        message);
+  }
+
+  @Override
+  public void printMessageTo(Messager messager) {
+    if (associatedElement.isPresent()) {
+      messager.printMessage(ERROR, getMessage(), associatedElement.get());
+    } else {
+      messager.printMessage(ERROR, getMessage());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
new file mode 100644
index 000000000..13430c670
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.io.IOException;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * @param <T> The input type from which source is to be generated.
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class SourceFileGenerator<T> {
+  private final Filer filer;
+
+  SourceFileGenerator(Filer filer) {
+    this.filer = checkNotNull(filer);
+  }
+
+  final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
+    try {
+      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
+      for (JavaWriter javaWriter : writers) {
+        try {
+          javaWriter.file(filer, originatingElements);
+        } catch (IOException e) {
+          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
+              e, getElementForErrorReporting(input));
+        }
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
+          getElementForErrorReporting(input));
+    }
+  }
+
+  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
+    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
+      @Override public ClassName apply(TypeWriter input) {
+        return input.name();
+      }
+    });
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Implementations should return {@link Element} instances from which the source is to be
+   * generated.
+   */
+  abstract Iterable<? extends Element> getOriginatingElements(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   */
+  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
new file mode 100644
index 000000000..57c815b23
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.CaseFormat;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+/**
+ * Utilities for generating files.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+class SourceFiles {
+  /**
+   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
+   * importance.
+   */
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
+    @Override
+    public int compare(DependencyRequest left, DependencyRequest right) {
+      return ComparisonChain.start()
+      // put fields before parameters
+          .compare(left.requestElement().getKind(), right.requestElement().getKind())
+          // order by dependency kind
+          .compare(left.kind(), right.kind())
+          // then sort by name
+          .compare(left.requestElement().getSimpleName().toString(),
+              right.requestElement().getSimpleName().toString()).result();
+    }
+  };
+
+  /**
+   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
+   * to requests.  This is used when generating component's initialize()
+   * methods (and in members injectors) in order to instantiate dependent
+   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
+   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
+   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
+   * if it was referenced as {@code Foo<A>}, we need to make sure we still
+   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
+   * we would have passed a single {@code aProvider}.
+   */
+  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
+  // binding keys and framework classes that it needs.
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
+      Types types, Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
+    for (DependencyRequest dependency : dependencies) {
+      BindingKey resolved = dependency.bindingKey();
+      // To get the proper unresolved type, we have to extract the proper type from the
+      // request type again (because we're looking at the actual element's type).
+      TypeMirror unresolvedType =
+          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
+      BindingKey unresolved =
+          BindingKey.create(resolved.kind(), resolved.key().withType(types, unresolvedType));
+      dependenciesByKeyBuilder.put(unresolved, dependency);
+    }
+    return dependenciesByKeyBuilder.build();
+  }
+
+  /**
+   * Allows dependency requests to be grouped by the key they're requesting.
+   * This is used by factory generation in order to minimize the number of parameters
+   * required in the case where a given key is requested more than once.  This expects
+   * unresolved dependency requests, otherwise we may generate factories based on
+   * a particular usage of a class as opposed to the generic types of the class.
+   */
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
+      Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
+    for (DependencyRequest dependency : dependencies) {
+      dependenciesByKeyBuilder.put(dependency.bindingKey(), dependency);
+    }
+    return dependenciesByKeyBuilder.build();
+  }
+
+  /**
+   * This method generates names and keys for the framework classes necessary for all of the
+   * bindings. It is responsible for the following:
+   * <ul>
+   * <li>Choosing a name that associates the binding with all of the dependency requests for this
+   * type.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
+   * <li>Ensuring that no two bindings end up with the same name.
+   * </ul>
+   *
+   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
+   */
+  static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
+      DependencyRequestMapper dependencyRequestMapper,
+      Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
+        indexDependenciesByKey(dependencies);
+    Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+        dependenciesByKey.asMap();
+    ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
+    for (Entry<BindingKey, Collection<DependencyRequest>> entry
+        : dependenciesByKeyMap.entrySet()) {
+      BindingKey bindingKey = entry.getKey();
+      Collection<DependencyRequest> requests = entry.getValue();
+      Class<?> frameworkClass =
+          dependencyRequestMapper.getFrameworkClass(requests.iterator().next());
+      // collect together all of the names that we would want to call the provider
+      ImmutableSet<String> dependencyNames =
+          FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
+
+      if (dependencyNames.size() == 1) {
+        // if there's only one name, great! use it!
+        String name = Iterables.getOnlyElement(dependencyNames);
+        bindingFields.put(bindingKey,
+            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
+      } else {
+        // in the event that a field is being used for a bunch of deps with different names,
+        // add all the names together with "And"s in the middle. E.g.: stringAndS
+        Iterator<String> namesIterator = dependencyNames.iterator();
+        String first = namesIterator.next();
+        StringBuilder compositeNameBuilder = new StringBuilder(first);
+        while (namesIterator.hasNext()) {
+          compositeNameBuilder.append("And").append(
+              CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+        }
+        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(
+            frameworkClass, bindingKey, compositeNameBuilder.toString()));
+      }
+    }
+    return bindingFields.build();
+  }
+
+  static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
+      DependencyRequest.Kind dependencyKind) {
+    switch (dependencyKind) {
+      case LAZY:
+        return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
+            frameworkTypeMemberSelect);
+      case INSTANCE:
+      case FUTURE:
+        return Snippet.format("%s.get()", frameworkTypeMemberSelect);
+      case PROVIDER:
+      case PRODUCER:
+      case MEMBERS_INJECTOR:
+        return Snippet.format("%s", frameworkTypeMemberSelect);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    switch (binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        return enclosingClassName.topLevelClassName().peerNamed(
+            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
+      case SYNTHETIC_PROVISON:
+        throw new IllegalArgumentException();
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   */
+  static TypeName parameterizedFactoryNameForProvisionBinding(
+      ProvisionBinding binding) {
+    ClassName factoryName = factoryNameForProvisionBinding(binding);
+    List<TypeName> parameters = ImmutableList.of();
+    if (binding.bindingType().equals(BindingType.UNIQUE)) {
+      switch(binding.bindingKind()) {
+        case INJECTION:
+          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+          // If the binding is parameterized, parameterize the factory.
+          if (bindingName instanceof ParameterizedTypeName) {
+            parameters = ((ParameterizedTypeName) bindingName).parameters();
+          }
+          break;
+        case PROVISION:
+          // For provision bindings, we parameterize creation on the types of
+          // the module, not the types of the binding.
+          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
+            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
+                binding.bindingTypeElement().asType())).parameters();
+          }
+          break;
+        default: // fall through.
+      }
+    }
+    return parameters.isEmpty() ? factoryName
+        : ParameterizedTypeName.create(factoryName, parameters);
+  }
+
+  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return enclosingClassName.topLevelClassName().peerNamed(
+            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
+   */
+  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
+      MembersInjectionBinding binding) {
+    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
+    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+    // If the binding is parameterized, parameterize the MembersInjector.
+    if (bindingName instanceof ParameterizedTypeName) {
+      return ParameterizedTypeName.create(factoryName,
+          ((ParameterizedTypeName) bindingName).parameters());
+    }
+    return factoryName;
+  }
+
+  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
+    return injectedClassName.topLevelClassName().peerNamed(
+        injectedClassName.classFileName() + "_MembersInjector");
+  }
+
+  private static String factoryPrefix(ProvisionBinding binding) {
+    switch (binding.bindingKind()) {
+      case INJECTION:
+        return "";
+      case PROVISION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  private static String factoryPrefix(ProductionBinding binding) {
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  private SourceFiles() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
new file mode 100644
index 000000000..3adf6f6bd
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSet.Builder;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.ClassName;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Utilities for handling types in annotation processors
+ */
+final class Util {
+  /**
+   * Returns the {@code V} type for a {@link Map} type like Map<K, Provider<V>>} if the map
+   * includes such a construction
+   */
+  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
+  }
+
+  // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
+  /**
+   * returns the value type for a {@link Map} type like Map<K, V>}.
+   */
+  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
+    return mapArgs.get(1);
+  }
+
+  /**
+   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
+   */
+  public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
+    return MoreTypes.asDeclared(mapArgs.get(0));
+  }
+
+  /**
+   * Returns the unwrapped key's {@link TypeElement} for a {@link Map} given the
+   * {@link AnnotationMirror} of the key.
+   */
+  public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
+    // TODO(user) Support literals other than String and Enum
+    AnnotationValueVisitor<TypeElement, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
+          @Override
+          public TypeElement visitEnumConstant(VariableElement c, Void p) {
+            return MoreElements.asType(c.getEnclosingElement()) ;
+          }
+
+          @Override
+          public TypeElement visitString(String s, Void p) {
+            return elements.getTypeElement(String.class.getCanonicalName());
+          }
+
+          @Override
+          protected TypeElement defaultAction(Object o, Void v) {
+            throw new IllegalStateException(
+                "Non-supported key type for map binding " + o.getClass().getCanonicalName());
+          }
+        };
+    TypeElement keyTypeElement =
+        Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
+    return keyTypeElement;
+  }
+
+  /**
+   * Returns the name of the generated class that contains the static {@code create} method for a
+   * {@code @MapKey} annotation type.
+   */
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
+    return enclosingClassName.topLevelClassName().peerNamed(
+        enclosingClassName.classFileName() + "Creator");
+  }
+
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
+   */
+  static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
+      Equivalence<T> equivalence, Optional<T> optional) {
+    return optional.isPresent()
+        ? Optional.of(equivalence.wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<T>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
+   * type.
+   */
+  static <T> Optional<T> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<T>absent();
+  }
+
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError("TypeElement cannot have nesting kind: "
+            + typeElement.getNestingKind());
+    }
+  }
+
+  /**
+   * Returns true if and only if a component can instantiate new instances (typically of a module)
+   * rather than requiring that they be passed.
+   */
+  static boolean componentCanMakeNewInstances(TypeElement typeElement) {
+    switch (typeElement.getKind()) {
+      case CLASS:
+        break;
+      case ENUM:
+      case ANNOTATION_TYPE:
+      case INTERFACE:
+        return false;
+      default:
+        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+    }
+
+    if (typeElement.getModifiers().contains(ABSTRACT)) {
+      return false;
+    }
+
+    if (requiresEnclosingInstance(typeElement)) {
+      return false;
+    }
+
+    for (Element enclosed : typeElement.getEnclosedElements()) {
+      if (enclosed.getKind().equals(CONSTRUCTOR)
+          && ((ExecutableElement) enclosed).getParameters().isEmpty()) {
+        return true;
+      }
+    }
+
+    // TODO(gak): still need checks for visibility
+
+    return false;
+  }
+
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
+      TypeElement type) {
+    List<ExecutableElement> methods = Lists.newArrayList();
+    TypeElement objectType = elements.getTypeElement(Object.class.getName());
+    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
+    return ImmutableList.copyOf(methods);
+  }
+
+  private static void findLocalAndInheritedMethodsRecursive(TypeElement objectType,
+      Elements elements, TypeElement type, List<ExecutableElement> methods) {
+    if (objectType.equals(type)) {
+      return;
+    }
+
+    for (TypeMirror superInterface : type.getInterfaces()) {
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
+    }
+    if (type.getSuperclass().getKind() != TypeKind.NONE) {
+      // Visit the superclass after superinterfaces so we will always see the implementation of a
+      // method after any interfaces that declared it.
+      findLocalAndInheritedMethodsRecursive(objectType,
+          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
+    }
+    // Add each method of this class, and in so doing remove any inherited method it overrides.
+    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
+    // that while still using Elements.overrides.
+    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
+    for (ExecutableElement method : theseMethods) {
+      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
+        boolean alreadySeen = false;
+        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
+          ExecutableElement otherMethod = methodIter.next();
+          if (elements.overrides(method, otherMethod, type)) {
+            methodIter.remove();
+          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
+              && method.getParameters().equals(otherMethod.getParameters())) {
+            // If we inherit this method on more than one path, we don't want to add it twice.
+            alreadySeen = true;
+          }
+        }
+        if (!alreadySeen) {
+          methods.add(method);
+        }
+      }
+    }
+  }
+
+  /*
+   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
+   */
+  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, TypeElement type) {
+    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
+    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
+        unimplementedMethods.add(method);
+      }
+    }
+    return unimplementedMethods.build();
+  }
+
+  private Util() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
new file mode 100644
index 000000000..d9e9daef7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
+
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+/**
+ * A collection of items describing contractual issues with the code as presented to an annotation
+ * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}.
+ * Callers will typically print the results of the report to a {@link Messager} instance using
+ * {@link #printMessagesTo}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ValidationReport<T> {
+  abstract T subject();
+  abstract ImmutableSet<Item> items();
+
+  boolean isClean() {
+    for (Item item : items()) {
+      switch (item.kind()) {
+        case ERROR:
+          return false;
+        default:
+          break;
+      }
+    }
+    return true;
+  }
+
+  void printMessagesTo(Messager messager) {
+    for (Item item : items()) {
+      item.printMessageTo(messager);
+    }
+  }
+
+  @AutoValue
+  static abstract class Item implements PrintableErrorMessage {
+    abstract String message();
+    abstract Kind kind();
+    abstract Element element();
+    abstract Optional<AnnotationMirror> annotation();
+
+    @Override
+    public void printMessageTo(Messager messager) {
+      if (annotation().isPresent()) {
+        messager.printMessage(kind(), message(), element(), annotation().get());
+      } else {
+        messager.printMessage(kind(), message(), element());
+      }
+    }
+  }
+
+  static final class Builder<T> {
+    static <T> Builder<T> about(T subject) {
+      return new Builder<T>(subject);
+    }
+
+    private final T subject;
+    private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
+
+    private Builder(T subject) {
+      this.subject = subject;
+    }
+
+    T getSubject() {
+      return subject;
+    }
+    
+    Builder<T> addItems(Iterable<Item> newItems) {
+      items.addAll(newItems);
+      return this;
+    }
+
+    Builder<T> addItem(String message, Element element) {
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, ERROR, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
+      addItem(message, kind, element, Optional.of(annotation));
+      return this;
+    }
+
+    private Builder<T> addItem(String message, Kind kind, Element element,
+        Optional<AnnotationMirror> annotation) {
+      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));
+      return this;
+    }
+
+    ValidationReport<T> build() {
+      return new AutoValue_ValidationReport<T>(subject, items.build());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
new file mode 100644
index 000000000..d60207241
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -0,0 +1,40 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import javax.tools.Diagnostic;
+
+/**
+ * Allows options to control how component process validates things such as scope cycles
+ * or nullability.
+ */
+enum ValidationType {
+  ERROR,
+  WARNING,
+  NONE;
+
+  Optional<Diagnostic.Kind> diagnosticKind() {
+    switch (this) {
+      case ERROR:
+        return Optional.of(Diagnostic.Kind.ERROR);
+      case WARNING:
+        return Optional.of(Diagnostic.Kind.WARNING);
+      default:
+        return Optional.absent();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
new file mode 100644
index 000000000..615f863c0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validator.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Validates a given subject and produces a {@link ValidationReport} containing the result.
+ *
+ * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
+ */
+interface Validator<T> {
+  ValidationReport<T> validate(T subject);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
new file mode 100644
index 000000000..b2cb45134
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.SortedMap;
+
+import static dagger.internal.codegen.writer.Writables.toStringWritable;
+
+public final class AnnotationWriter implements Writable, HasClassReferences {
+  private final ClassName annotationName;
+  private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
+
+  AnnotationWriter(ClassName annotationName) {
+    this.annotationName = annotationName;
+  }
+
+  public void setValue(String value) {
+    setMember("value", value);
+  }
+
+  public void setMember(String name, int value) {
+    memberMap.put(name, toStringWritable(value));
+  }
+
+  public void setMember(String name, String value) {
+    memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append('@');
+    annotationName.write(appendable, context);
+    if (!memberMap.isEmpty()) {
+      appendable.append('(');
+      if (memberMap.size() == 1) {
+        Entry<String, Writable> onlyEntry = Iterables.getOnlyElement(memberMap.entrySet());
+        if (!onlyEntry.getKey().equals("value")) {
+          appendable.append(onlyEntry.getKey()).append(" = ");
+        }
+        onlyEntry.getValue().write(appendable, context);
+      }
+      appendable.append(')');
+    }
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of(annotationName);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
new file mode 100644
index 000000000..e7960629e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import java.io.IOException;
+import java.util.Set;
+
+final class ArrayTypeName implements TypeName {
+  private final TypeName componentType;
+
+  ArrayTypeName(TypeName componentType) {
+    this.componentType = componentType;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return componentType.referencedClasses();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return componentType.write(appendable, context).append("[]");
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return (obj instanceof ArrayTypeName)
+        && this.componentType.equals(((ArrayTypeName) obj).componentType);
+  }
+
+  @Override
+  public int hashCode() {
+    return componentType.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
new file mode 100644
index 000000000..c00dd5f07
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+
+public final class BlockWriter implements Writable, HasClassReferences {
+  private final List<Snippet> snippets;
+
+  BlockWriter() {
+    this.snippets = Lists.newArrayList();
+  }
+
+  public BlockWriter addSnippet(String snippet, Object... args) {
+    snippets.add(Snippet.format(snippet, args));
+    return this;
+  }
+
+  public BlockWriter addSnippet(Snippet snippet) {
+    snippets.add(snippet);
+    return this;
+  }
+
+  boolean isEmpty() {
+    return snippets.isEmpty();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    for (Snippet snippet : snippets) {
+      appendable.append('\n');
+      snippet.write(appendable, context);
+    }
+    return appendable.append('\n');
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(snippets)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
new file mode 100644
index 000000000..0b2615e9a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Optional;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.NestingKind;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
+
+/**
+ * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and
+ * {@link NestingKind#MEMBER} classes.
+ *
+ * @since 2.0
+ */
+public final class ClassName implements TypeName, Comparable<ClassName> {
+  private String fullyQualifiedName = null;
+  private final String packageName;
+  /* From top to bottom.  E.g.: this field will contain ["A", "B"] for pgk.A.B.C */
+  private final ImmutableList<String> enclosingSimpleNames;
+  private final String simpleName;
+
+  private ClassName(String packageName, ImmutableList<String> enclosingSimpleNames,
+      String simpleName) {
+    this.packageName = packageName;
+    this.enclosingSimpleNames = enclosingSimpleNames;
+    this.simpleName = simpleName;
+  }
+
+  public String packageName() {
+    return packageName;
+  }
+
+  public ImmutableList<String> enclosingSimpleNames() {
+    return enclosingSimpleNames;
+  }
+
+  public Optional<ClassName> enclosingClassName() {
+    return enclosingSimpleNames.isEmpty()
+        ? Optional.<ClassName>absent()
+        : Optional.of(new ClassName(packageName,
+            enclosingSimpleNames.subList(0, enclosingSimpleNames.size() - 1),
+            enclosingSimpleNames.get(enclosingSimpleNames.size() - 1)));
+  }
+
+  public String simpleName() {
+    return simpleName;
+  }
+
+  public String canonicalName() {
+    if (fullyQualifiedName == null) {
+      StringBuilder builder = new StringBuilder(packageName());
+      if (builder.length() > 0) {
+        builder.append('.');
+      }
+      for (String enclosingSimpleName : enclosingSimpleNames()) {
+        builder.append(enclosingSimpleName).append('.');
+      }
+      fullyQualifiedName = builder.append(simpleName()).toString();
+    }
+    return fullyQualifiedName;
+  }
+
+  public String classFileName() {
+    StringBuilder builder = new StringBuilder();
+    Joiner.on('$').appendTo(builder, enclosingSimpleNames());
+    if (!enclosingSimpleNames().isEmpty()) {
+      builder.append('$');
+    }
+    return builder.append(simpleName()).toString();
+  }
+
+  public ClassName topLevelClassName() {
+    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
+    return enclosingIterator.hasNext()
+        ? new ClassName(packageName(), ImmutableList.<String>of(),
+            enclosingIterator.next())
+        : this;
+  }
+
+  public ClassName nestedClassNamed(String memberClassName) {
+    checkNotNull(memberClassName);
+    checkArgument(SourceVersion.isIdentifier(memberClassName));
+    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
+    return new ClassName(packageName(),
+        new ImmutableList.Builder<String>()
+            .addAll(enclosingSimpleNames())
+            .add(simpleName())
+            .build(),
+        memberClassName);
+  }
+
+  public ClassName peerNamed(String peerClassName) {
+    checkNotNull(peerClassName);
+    checkArgument(SourceVersion.isIdentifier(peerClassName));
+    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
+    return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
+  }
+
+  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
+      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
+
+  public static ClassName fromTypeElement(TypeElement element) {
+    checkNotNull(element);
+    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+    String simpleName = element.getSimpleName().toString();
+    List<String> enclosingNames = new ArrayList<String>();
+    Element current = element.getEnclosingElement();
+    while (current.getKind().isClass() || current.getKind().isInterface()) {
+      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+      enclosingNames.add(current.getSimpleName().toString());
+      current = current.getEnclosingElement();
+    }
+    PackageElement packageElement = getPackage(current);
+    Collections.reverse(enclosingNames);
+    return new ClassName(packageElement.getQualifiedName().toString(),
+        ImmutableList.copyOf(enclosingNames), simpleName);
+  }
+
+  public static ClassName fromClass(Class<?> clazz) {
+    checkNotNull(clazz);
+    List<String> enclosingNames = new ArrayList<String>();
+    Class<?> current = clazz.getEnclosingClass();
+    while (current != null) {
+      enclosingNames.add(current.getSimpleName());
+      current = current.getEnclosingClass();
+    }
+    Collections.reverse(enclosingNames);
+    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
+  }
+
+  private static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
+  /**
+   * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
+   * method assumes that the input is ASCII and follows typical Java style (lower-case package
+   * names, upper-camel-case class names) and may produce incorrect results or throw
+   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and
+   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
+   * instances without such restrictions.
+   */
+  public static ClassName bestGuessFromString(String classNameString) {
+    checkNotNull(classNameString);
+    List<String> parts = Splitter.on('.').splitToList(classNameString);
+    int firstClassPartIndex = -1;
+    for (int i = 0; i < parts.size(); i++) {
+      String part = parts.get(i);
+      checkArgument(SourceVersion.isIdentifier(part));
+      char firstChar = part.charAt(0);
+      if (Ascii.isLowerCase(firstChar)) {
+        // looks like a package part
+        if (firstClassPartIndex >= 0) {
+          throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+        }
+      } else if (Ascii.isUpperCase(firstChar)) {
+        // looks like a class part
+        if (firstClassPartIndex < 0) {
+          firstClassPartIndex = i;
+        }
+      } else {
+        throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+      }
+    }
+    int lastIndex = parts.size() - 1;
+    return new ClassName(
+        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
+        firstClassPartIndex == lastIndex
+            ? ImmutableList.<String>of()
+            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),
+        parts.get(lastIndex));
+  }
+
+  public static ClassName create(
+      String packageName, List<String> enclosingSimpleNames, String simpleName) {
+    return new ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
+        simpleName);
+  }
+
+  public static ClassName create(String packageName, String simpleName) {
+    return new ClassName(packageName, ImmutableList.<String>of(), simpleName);
+  }
+
+  @Override
+  public String toString() {
+    return canonicalName();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append(context.sourceReferenceForClassName(this));
+    return appendable;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof ClassName) {
+      ClassName that = (ClassName) obj;
+      return this.packageName.equals(that.packageName)
+          && this.enclosingSimpleNames.equals(that.enclosingSimpleNames)
+          && this.simpleName.equals(that.simpleName);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);
+  }
+
+  @Override
+  public int compareTo(ClassName o) {
+    return canonicalName().compareTo(o.canonicalName());
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of(this);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
new file mode 100644
index 000000000..20b373f40
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+public final class ClassWriter extends TypeWriter {
+  private final List<ConstructorWriter> constructorWriters;
+  private final List<TypeVariableName> typeParameters;
+
+  ClassWriter(ClassName className) {
+    super(className);
+    this.constructorWriters = Lists.newArrayList();
+    this.typeParameters = Lists.newArrayList();
+  }
+
+  public ConstructorWriter addConstructor() {
+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
+    constructorWriters.add(constructorWriter);
+    return constructorWriter;
+  }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
+  
+  public List<TypeVariableName> typeParameters() {
+    return ImmutableList.copyOf(typeParameters);
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("class ").append(name.simpleName());
+    Writables.join(", ", typeParameters, "<", ">", appendable, context);
+    if (supertype.isPresent()) {
+      appendable.append(" extends ");
+      supertype.get().write(appendable, context);
+    }
+    Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
+    appendable.append(" {");
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
+      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
+    }
+    for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
+      if (!isDefaultConstructor(constructorWriter)) {
+        constructorWriter.write(new IndentingAppendable(appendable), context);
+      }
+    }
+    for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  private static final Set<Modifier> VISIBILIY_MODIFIERS =
+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
+
+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
+        && constructorWriter.body().isEmpty();
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations, typeParameters);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
new file mode 100644
index 000000000..f4a2c15f7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {
+  private final String name;
+  private final Map<String, VariableWriter> parameterWriters;
+  private final BlockWriter blockWriter;
+
+  ConstructorWriter(String name) {
+    this.name = name;
+    this.parameterWriters = Maps.newLinkedHashMap();
+    this.blockWriter = new BlockWriter();
+  }
+
+  public VariableWriter addParameter(Class<?> type, String name) {
+    return addParameter(ClassName.fromClass(type), name);
+  }
+
+  public VariableWriter addParameter(TypeElement type, String name) {
+    return addParameter(ClassName.fromTypeElement(type), name);
+  }
+
+  public VariableWriter addParameter(TypeWriter type, String name) {
+    return addParameter(type.name, name);
+  }
+
+  public VariableWriter addParameter(TypeName type, String name) {
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+  
+  public Map<String, TypeName> parameters() {
+    ImmutableMap.Builder<String, TypeName> params = ImmutableMap.builder();
+    for (Map.Entry<String, VariableWriter> entry : parameterWriters.entrySet()) {
+      params.put(entry.getKey(), entry.getValue().type());
+    }
+    return params.build();
+  }
+
+  public BlockWriter body() {
+    return blockWriter;
+  }
+
+  private VariableWriter addParameter(ClassName type, String name) {
+    checkArgument(!parameterWriters.containsKey(name));
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(
+        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))
+            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(HasClassReferences input) {
+                return input.referencedClasses();
+              }
+            })
+            .toSet();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeModifiers(appendable).append(name).append('(');
+    Writables.join(", ", parameterWriters.values(), appendable, context);
+    appendable.append(") {");
+    blockWriter.write(new IndentingAppendable(appendable), context);
+    return appendable.append("}\n");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
new file mode 100644
index 000000000..f3dcd9a12
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+public final class EnumWriter extends TypeWriter {
+  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();
+  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();
+
+  EnumWriter(ClassName name) {
+    super(name);
+  }
+
+  public ConstantWriter addConstant(String name) {
+    ConstantWriter constantWriter = new ConstantWriter(name);
+    constantWriters.put(name, constantWriter);
+    return constantWriter;
+  }
+
+  public ConstructorWriter addConstructor() {
+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
+    constructorWriters.add(constructorWriter);
+    return constructorWriter;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("enum ").append(name.simpleName());
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
+
+    checkState(!constantWriters.isEmpty(), "Cannot write an enum with no constants.");
+    appendable.append('\n');
+    ImmutableList<ConstantWriter> constantWriterList =
+        ImmutableList.copyOf(constantWriters.values());
+    for (ConstantWriter constantWriter
+        : constantWriterList.subList(0, constantWriterList.size() - 1)) {
+      constantWriter.write(appendable, context);
+      appendable.append(",\n");
+    }
+    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);
+    appendable.append(";\n");
+
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
+      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
+    }
+    for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
+      if (!isDefaultConstructor(constructorWriter)) {
+        constructorWriter.write(new IndentingAppendable(appendable), context);
+      }
+    }
+    for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  private static final Set<Modifier> VISIBILIY_MODIFIERS =
+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
+
+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
+        && constructorWriter.body().isEmpty();
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
+            constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  public static final class ConstantWriter implements Writable, HasClassReferences {
+    private final String name;
+    private final List<Snippet> constructorSnippets;
+
+    private ConstantWriter(String name) {
+      this.name = name;
+      this.constructorSnippets = Lists.newArrayList();
+    }
+
+    ConstantWriter addArgument(Snippet snippet) {
+      constructorSnippets.add(snippet);
+      return this;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      appendable.append(name);
+      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();
+      if (snippetIterator.hasNext()) {
+        appendable.append('(');
+        snippetIterator.next().write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          appendable.append(", ");
+          snippetIterator.next().write(appendable, context);
+        }
+        appendable.append(')');
+      }
+      return appendable;
+    }
+
+    @Override
+    public Set<ClassName> referencedClasses() {
+      return FluentIterable.from(constructorSnippets)
+          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
+            @Override
+            public Set<ClassName> apply(Snippet input) {
+              return input.referencedClasses();
+            }
+          })
+          .toSet();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
new file mode 100644
index 000000000..b45e5d9ae
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import java.io.IOException;
+import java.util.Set;
+
+public final class FieldWriter extends VariableWriter {
+  private Optional<Snippet> initializer;
+
+  FieldWriter(TypeName type, String name) {
+    super(type, name);
+    this.initializer = Optional.absent();
+  }
+
+  public void setInitializer(Snippet initializer) {
+    this.initializer = Optional.of(initializer);
+  }
+
+  public void setInitializer(String initializer, Object... args) {
+    this.initializer = Optional.of(Snippet.format(initializer, args));
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    super.write(appendable, context);
+    if (initializer.isPresent()) {
+      appendable.append(" = ");
+      initializer.get().write(appendable, context);
+    }
+    appendable.append(';');
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
new file mode 100644
index 000000000..15b412068
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import java.util.Set;
+
+public interface HasClassReferences {
+  Set<ClassName> referencedClasses();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
new file mode 100644
index 000000000..a6909ed10
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+interface HasTypeName {
+  TypeName name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
new file mode 100644
index 000000000..d96f8a3a2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.AbstractIterator;
+import java.io.IOException;
+import java.util.Iterator;
+
+final class IndentingAppendable implements Appendable {
+  private final String indentation;
+  private final Appendable delegate;
+  private boolean requiresIndent = true;
+
+  IndentingAppendable(Appendable delegate) {
+    this("  ", delegate);
+  }
+
+  IndentingAppendable(String indentation, Appendable delegate) {
+    this.indentation = indentation;
+    this.delegate = delegate;
+  }
+
+  @Override
+  public Appendable append(CharSequence csq) throws IOException {
+    return append(csq, 0, csq.length());
+  }
+
+  @Override
+  public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    Iterator<CharSequence> lines = lines(csq, start, end);
+    while (lines.hasNext()) {
+      CharSequence line = lines.next();
+      maybeIndent();
+      delegate.append(line);
+      if (line.charAt(line.length() - 1) == '\n') {
+        requiresIndent = true;
+      }
+    }
+    return this;
+  }
+
+  @Override
+  public Appendable append(char c) throws IOException {
+    maybeIndent();
+    delegate.append(c);
+    if (c == '\n') {
+      requiresIndent = true;
+    }
+    return this;
+  }
+
+  void maybeIndent() throws IOException {
+    if (requiresIndent) {
+      delegate.append(indentation);
+    }
+    requiresIndent = false;
+  }
+
+  private static Iterator<CharSequence> lines(
+      final CharSequence csq, final int start, final int end) {
+    return new AbstractIterator<CharSequence>() {
+      int index = start;
+
+      @Override protected CharSequence computeNext() {
+        int nextStart = index;
+        while (index < end && csq.charAt(index) != '\n') {
+          index++;
+        }
+        if (index < end && csq.charAt(index) == '\n') {
+          index++;
+        }
+        int nextEnd = index;
+        return nextStart >= end
+            ? endOfData()
+            : csq.subSequence(nextStart, nextEnd);
+      }
+    };
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
new file mode 100644
index 000000000..0db9ff864
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+public final class InterfaceWriter extends TypeWriter {
+  private final List<TypeVariableName> typeVariables;
+  InterfaceWriter(ClassName name) {
+    super(name);
+    this.typeVariables = Lists.newArrayList();
+  }
+
+  public void addTypeVariable(TypeVariableName typeVariable) {
+    this.typeVariables.add(typeVariable);
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("interface ").append(name.simpleName());
+    if (!typeVariables.isEmpty()) {
+      appendable.append('<');
+      Joiner.on(", ").appendTo(appendable, typeVariables);
+      appendable.append('>');
+    }
+    if (supertype.isPresent()) {
+      appendable.append(" extends ");
+      supertype.get().write(appendable, context);
+    }
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
+    for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),
+            annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
new file mode 100644
index 000000000..a13c98164
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Ordering;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import com.google.common.io.Closer;
+import dagger.internal.codegen.writer.Writable.Context;
+import java.io.IOException;
+import java.util.Deque;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableList;
+
+/**
+ * Writes a single compilation unit.
+ */
+public final class JavaWriter {
+  public static JavaWriter inPackage(String packageName) {
+    return new JavaWriter(packageName);
+  }
+
+  public static JavaWriter inPackage(Package enclosingPackage) {
+    return new JavaWriter(enclosingPackage.getName());
+  }
+
+  public static JavaWriter inPackage(PackageElement packageElement) {
+    return new JavaWriter(packageElement.getQualifiedName().toString());
+  }
+
+  private final String packageName;
+  // TODO(gak): disallow multiple types in a file?
+  private final List<TypeWriter> typeWriters;
+  private final List<ClassName> explicitImports;
+
+  private JavaWriter(String packageName) {
+    this.packageName = packageName;
+    this.typeWriters = Lists.newArrayList();
+    this.explicitImports = Lists.newArrayList();
+  }
+
+  public List<TypeWriter> getTypeWriters() {
+    return unmodifiableList(typeWriters);
+  }
+
+  public JavaWriter addImport(Class<?> importedClass) {
+    explicitImports.add(ClassName.fromClass(importedClass));
+    return this;
+  }
+
+  public ClassWriter addClass(String simpleName) {
+    checkNotNull(simpleName);
+    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));
+    typeWriters.add(classWriter);
+    return classWriter;
+  }
+
+  public EnumWriter addEnum(String simpleName) {
+    checkNotNull(simpleName);
+    EnumWriter writer = new EnumWriter(ClassName.create(packageName, simpleName));
+    typeWriters.add(writer);
+    return writer;
+  }
+
+  public InterfaceWriter addInterface(String simpleName) {
+    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
+    typeWriters.add(writer);
+    return writer;
+  }
+
+  public Appendable write(Appendable appendable) throws IOException {
+    if (!packageName.isEmpty()) {
+      appendable.append("package ").append(packageName).append(";\n\n");
+    }
+
+    // write imports
+    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+
+    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
+        .addAll(explicitImports)
+        .addAll(classNames)
+        .build();
+    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet();
+
+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);
+    while (!declaredTypes.isEmpty()) {
+      TypeWriter currentType = declaredTypes.pop();
+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());
+      declaredTypes.addAll(currentType.nestedTypeWriters);
+    }
+
+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
+
+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
+    for (ClassName className : importCandidates) {
+      if (!(className.packageName().equals(packageName)
+              && !className.enclosingClassName().isPresent())
+          && !(className.packageName().equals("java.lang")
+              && className.enclosingSimpleNames().isEmpty())
+          && !typeNames.contains(className.topLevelClassName())) {
+        Optional<ClassName> importCandidate = Optional.of(className);
+        while (importCandidate.isPresent()
+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())
+                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {
+          importCandidate = importCandidate.get().enclosingClassName();
+        }
+        if (importCandidate.isPresent()) {
+          appendable.append("import ").append(importCandidate.get().canonicalName()).append(";\n");
+          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());
+        }
+      }
+    }
+
+    appendable.append('\n');
+
+    CompilationUnitContext context =
+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));
+
+    // write types
+    for (TypeWriter typeWriter : typeWriters) {
+      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\n');
+    }
+    return appendable;
+  }
+
+  public void file(Filer filer, Iterable<? extends Element> originatingElements)
+      throws IOException {
+    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);
+  }
+
+  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
+      throws IOException {
+    JavaFileObject sourceFile = filer.createSourceFile(name,
+        Iterables.toArray(originatingElements, Element.class));
+    Closer closer = Closer.create();
+    try {
+      write(closer.register(sourceFile.openWriter()));
+    } catch (Exception e) {
+      try {
+        sourceFile.delete();
+      } catch (Exception e2) {
+        // couldn't delete the file
+      }
+      throw closer.rethrow(e);
+    } finally {
+      closer.close();
+    }
+  }
+
+  @Override
+  public String toString() {
+    try {
+      return write(new StringBuilder()).toString();
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  static final class CompilationUnitContext implements Context {
+    private final String packageName;
+    private final ImmutableSortedSet<ClassName> visibleClasses;
+
+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {
+      this.packageName = packageName;
+      this.visibleClasses =
+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);
+    }
+
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));
+    }
+
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
+      if (isImported(className)) {
+        return className.simpleName();
+      }
+      Optional<ClassName> enclosingClassName = className.enclosingClassName();
+      while (enclosingClassName.isPresent()) {
+        if (isImported(enclosingClassName.get())) {
+          return enclosingClassName.get().simpleName()
+              + className.canonicalName()
+                  .substring(enclosingClassName.get().canonicalName().length());
+        }
+        enclosingClassName = enclosingClassName.get().enclosingClassName();
+      }
+      return className.canonicalName();
+    }
+
+    private boolean collidesWithVisibleClass(ClassName className) {
+      return collidesWithVisibleClass(className.simpleName());
+    }
+
+    private boolean collidesWithVisibleClass(String simpleName) {
+      return FluentIterable.from(visibleClasses)
+          .transform(new Function<ClassName, String>() {
+            @Override public String apply(ClassName input) {
+              return input.simpleName();
+            }
+          })
+          .contains(simpleName);
+    }
+
+    private boolean isImported(ClassName className) {
+      return (packageName.equals(className.packageName())
+              && !className.enclosingClassName().isPresent()
+              && !collidesWithVisibleClass(className)) // need to account for scope & hiding
+          || visibleClasses.contains(className)
+          || (className.packageName().equals("java.lang")
+              && className.enclosingSimpleNames().isEmpty());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
new file mode 100644
index 000000000..7831fe816
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+public final class MethodWriter extends Modifiable implements HasClassReferences, Writable {
+  private final TypeName returnType;
+  private final String name;
+  private final Map<String, VariableWriter> parameterWriters;
+  private final List<TypeVariableName> typeParameters;
+  private Optional<BlockWriter> body;
+
+  MethodWriter(TypeName returnType, String name) {
+    this.returnType = returnType;
+    this.name = name;
+    this.parameterWriters = Maps.newLinkedHashMap();
+    this.typeParameters = Lists.newArrayList();
+    this.body = Optional.absent();
+  }
+
+  public String name() {
+    return name;
+  }
+  
+  public TypeName returnType() {
+    return returnType;
+  }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
+
+  public VariableWriter addParameter(Class<?> type, String name) {
+    return addParameter(ClassName.fromClass(type), name);
+  }
+
+  public VariableWriter addParameter(TypeElement type, String name) {
+    return addParameter(ClassName.fromTypeElement(type), name);
+  }
+
+  public VariableWriter addParameter(TypeWriter type, String name) {
+    return addParameter(type.name, name);
+  }
+
+  public VariableWriter addParameter(TypeName type, String name) {
+    checkArgument(!parameterWriters.containsKey(name));
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+
+  public BlockWriter body() {
+    if (body.isPresent()) {
+      return body.get();
+    } else {
+      BlockWriter blockWriter = new BlockWriter();
+      body = Optional.of(blockWriter);
+      return blockWriter;
+    }
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable);
+    Writables.join(", ", typeParameters, "<", "> ", appendable, context);
+    returnType.write(appendable, context);
+    appendable.append(' ').append(name).append('(');
+    Writables.join(", ", parameterWriters.values(), appendable, context);
+    appendable.append(")");
+    if (body.isPresent()) {
+      appendable.append(" {");
+      body.get().write(new IndentingAppendable(appendable), context);
+      appendable.append("}\n");
+    } else {
+      appendable.append(";\n");
+    }
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(
+        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))
+            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(HasClassReferences input) {
+                return input.referencedClasses();
+              }
+            })
+            .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
new file mode 100644
index 000000000..bb4c6ffd9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.Writable.Context;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+public abstract class Modifiable {
+  final Set<Modifier> modifiers;
+  final List<AnnotationWriter> annotations;
+
+  Modifiable() {
+    this.modifiers = EnumSet.noneOf(Modifier.class);
+    this.annotations = Lists.newArrayList();
+  }
+
+  public void addModifiers(Modifier first, Modifier... rest) {
+    addModifiers(Lists.asList(first, rest));
+  }
+
+  public void addModifiers(Iterable<Modifier> modifiers) {
+    Iterables.addAll(this.modifiers, modifiers);
+  }
+
+  public AnnotationWriter annotate(ClassName annotation) {
+    AnnotationWriter annotationWriter = new AnnotationWriter(annotation);
+    this.annotations.add(annotationWriter);
+    return annotationWriter;
+  }
+
+  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
+    return annotate(ClassName.fromClass(annotation));
+  }
+
+  Appendable writeModifiers(Appendable appendable) throws IOException {
+    for (Modifier modifier : modifiers) {
+      appendable.append(modifier.toString()).append(' ');
+    }
+    return appendable;
+  }
+
+  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {
+    for (AnnotationWriter annotationWriter : annotations) {
+      annotationWriter.write(appendable, context).append('\n');
+    }
+    return appendable;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
new file mode 100644
index 000000000..0d3588b77
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+
+enum NullName implements TypeName {
+  NULL;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return appendable.append("null");
+  }
+
+  @Override
+  public String toString() {
+    return "null";
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
new file mode 100644
index 000000000..63cf3dd95
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+
+public final class ParameterizedTypeName implements TypeName {
+  private final ClassName type;
+  private final ImmutableList<TypeName> parameters;
+
+  ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
+    this.type = type;
+    this.parameters = ImmutableList.copyOf(parameters);
+  }
+  
+  public ClassName type() {
+    return type;
+  }
+  
+  public ImmutableList<TypeName> parameters() {
+    return parameters;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>()
+        .add(type);
+    for (TypeName parameter : parameters) {
+      builder.addAll(parameter.referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append(context.sourceReferenceForClassName(type));
+    Iterator<? extends TypeName> parameterIterator = parameters.iterator();
+    verify(parameterIterator.hasNext(), type.toString());
+    appendable.append('<');
+    parameterIterator.next().write(appendable, context);
+    while (parameterIterator.hasNext()) {
+      appendable.append(", ");
+      parameterIterator.next().write(appendable, context);
+    }
+    appendable.append('>');
+    return appendable;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof ParameterizedTypeName) {
+      ParameterizedTypeName that = (ParameterizedTypeName) obj;
+      return this.type.equals(that.type)
+          && this.parameters.equals(that.parameters);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(type, parameters);
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+
+  public static ParameterizedTypeName create(ClassName className,
+      TypeName... parameters) {
+    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
+  }
+
+  public static ParameterizedTypeName create(ClassName className,
+      Iterable<? extends TypeName> parameters) {
+    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
+  }
+
+  public static ParameterizedTypeName create(Class<?> parameterizedClass,
+      TypeName... parameters) {
+    checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
+    return new ParameterizedTypeName(ClassName.fromClass(parameterizedClass),
+        ImmutableList.copyOf(parameters));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
new file mode 100644
index 000000000..94961dd7a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+import javax.lang.model.type.PrimitiveType;
+
+public enum PrimitiveName implements TypeName {
+  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public String toString() {
+    return Ascii.toLowerCase(name());
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return appendable.append(toString());
+  }
+
+  static PrimitiveName forTypeMirror(PrimitiveType mirror) {
+    switch (mirror.getKind()) {
+      case BOOLEAN:
+        return BOOLEAN;
+      case BYTE:
+        return BYTE;
+      case SHORT:
+        return SHORT;
+      case INT:
+        return INT;
+      case LONG:
+        return LONG;
+      case CHAR:
+        return CHAR;
+      case FLOAT:
+        return FLOAT;
+      case DOUBLE:
+        return DOUBLE;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static PrimitiveName forClass(Class<?> primitiveClass) {
+    if (boolean.class.equals(primitiveClass)) {
+      return BOOLEAN;
+    }
+    if (byte.class.equals(primitiveClass)) {
+      return BYTE;
+    }
+    if (short.class.equals(primitiveClass)) {
+      return SHORT;
+    }
+    if (int.class.equals(primitiveClass)) {
+      return INT;
+    }
+    if (long.class.equals(primitiveClass)) {
+      return LONG;
+    }
+    if (char.class.equals(primitiveClass)) {
+      return CHAR;
+    }
+    if (float.class.equals(primitiveClass)) {
+      return FLOAT;
+    }
+    if (double.class.equals(primitiveClass)) {
+      return DOUBLE;
+    }
+    throw new IllegalArgumentException(primitiveClass + " is not a primitive type");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
new file mode 100644
index 000000000..52aeb44b0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Formatter;
+import java.util.Iterator;
+import java.util.Set;
+
+public final class Snippet implements HasClassReferences, Writable {
+  private final String format;
+  private final ImmutableSet<TypeName> types;
+  private final ImmutableList<Object> args;
+
+  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
+    this.format = format;
+    this.types = types;
+    this.args = args;
+  }
+
+  public String format() {
+    return format;
+  }
+
+  public ImmutableList<Object> args() {
+    return args;
+  }
+
+  public ImmutableSet<TypeName> types() {
+    return types;
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(types)
+        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(TypeName input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
+    for (Object arg : args) {
+      if (arg instanceof Writable) {
+        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
+      } else {
+        formattedArgsBuilder.add(arg);
+      }
+    }
+
+    @SuppressWarnings("resource") // intentionally don't close the formatter
+    Formatter formatter = new Formatter(appendable);
+    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));
+
+    return appendable;
+  }
+
+  public static Snippet format(String format, Object... args) {
+    ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
+    for (Object arg : args) {
+      if (arg instanceof Snippet) {
+        types.addAll(((Snippet) arg).types);
+      }
+      if (arg instanceof TypeName) {
+        types.add((TypeName) arg);
+      }
+      if (arg instanceof HasTypeName) {
+        types.add(((HasTypeName) arg).name());
+      }
+    }
+    return new Snippet(format, types.build(), ImmutableList.copyOf(args));
+  }
+
+  public static Snippet format(String format, Iterable<? extends Object> args) {
+    return format(format, Iterables.toArray(args, Object.class));
+  }
+
+  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {
+    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), "%s")),
+        selectors);
+  }
+
+  public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
+    Iterator<Snippet> iterator = parameterSnippets.iterator();
+    StringBuilder stringBuilder = new StringBuilder();
+    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
+    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();
+    if (iterator.hasNext()) {
+      Snippet firstSnippet = iterator.next();
+      stringBuilder.append(firstSnippet.format());
+      typesBuilder.addAll(firstSnippet.types());
+      argsBuilder.addAll(firstSnippet.args());
+    }
+    while (iterator.hasNext()) {
+      Snippet nextSnippet = iterator.next();
+      stringBuilder.append(", ").append(nextSnippet.format());
+      typesBuilder.addAll(nextSnippet.types());
+      argsBuilder.addAll(nextSnippet.args());
+    }
+    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
new file mode 100644
index 000000000..2d059f9af
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import java.util.Formatter;
+
+/**
+ * Represents a string literal as found in Java source code.
+ */
+public final class StringLiteral {
+  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */
+  public static StringLiteral forValue(String value) {
+    return new StringLiteral(value, stringLiteral(value));
+  }
+
+  /** Returns the string literal representing {@code data}, including wrapping quotes. */
+  private static String stringLiteral(String value) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < value.length(); i++) {
+      char c = value.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\b':
+          result.append("\\b");
+          break;
+        case '\t':
+          result.append("\\t");
+          break;
+        case '\n':
+          result.append("\\n");
+          break;
+        case '\f':
+          result.append("\\f");
+          break;
+        case '\r':
+          result.append("\\r");
+          break;
+        default:
+          if (Character.isISOControl(c)) {
+            new Formatter(result).format("\\u%04x", (int) c);
+          } else {
+            result.append(c);
+          }
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
+  private final String value;
+  private final String literal;
+
+  private StringLiteral(String value, String literal) {
+    this.value = value;
+    this.literal = literal;
+  }
+
+  public String value() {
+    return value;
+  }
+
+  public String literal() {
+    return literal;
+  }
+
+  @Override
+  public String toString() {
+    return literal;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof StringLiteral) {
+      return this.value.equals(((StringLiteral) obj).value);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return value.hashCode();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
new file mode 100644
index 000000000..e0daf5312
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+public interface TypeName extends HasClassReferences, Writable {
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
new file mode 100644
index 000000000..4bc234739
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+public final class TypeNames {
+  static final Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
+      new Function<TypeMirror, TypeName>() {
+        @Override public TypeName apply(TypeMirror input) {
+          return forTypeMirror(input);
+        }
+      };
+
+  public static TypeName forClass(Class<?> clazz) {
+    if (clazz.isPrimitive()) {
+      return PrimitiveName.forClass(clazz);
+    } else if (void.class.equals(clazz)) {
+      return VoidName.VOID;
+    } else if (clazz.isArray()) {
+      return new ArrayTypeName(forClass(clazz.getComponentType()));
+    } else {
+      return ClassName.fromClass(clazz);
+    }
+  }
+
+  public static TypeName forTypeMirror(TypeMirror mirror) {
+    return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
+      @Override
+      protected TypeName defaultAction(TypeMirror e, Void p) {
+        throw new IllegalArgumentException(e.toString());
+      }
+      
+      @Override
+      public TypeName visitTypeVariable(TypeVariable t, Void p) {
+        return TypeVariableName.fromTypeVariable(t);
+      }
+
+      @Override
+      public ArrayTypeName visitArray(ArrayType t, Void p) {
+        return new ArrayTypeName(t.getComponentType().accept(this, null));
+      }
+
+      @Override
+      public TypeName visitDeclared(DeclaredType t, Void p) {
+        return t.getTypeArguments().isEmpty()
+            ? ClassName.fromTypeElement((TypeElement) t.asElement())
+            : new ParameterizedTypeName(
+                ClassName.fromTypeElement((TypeElement) t.asElement()),
+                FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));
+      }
+
+      @Override
+      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {
+        return PrimitiveName.forTypeMirror(t);
+      }
+
+      @Override
+      public WildcardName visitWildcard(WildcardType t, Void p) {
+        return WildcardName.forTypeMirror(t);
+      }
+
+      @Override
+      public NullName visitNull(NullType t, Void p) {
+        return NullName.NULL;
+      }
+
+      @Override
+      public TypeName visitNoType(NoType t, Void p) {
+        switch (t.getKind()) {
+          case VOID:
+            return VoidName.VOID;
+          case PACKAGE:
+            throw new IllegalArgumentException();
+          default:
+            throw new IllegalStateException();
+        }
+      }
+    }, null);
+  }
+
+  private TypeNames() {
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
new file mode 100644
index 000000000..c6ee533ca
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Objects;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Set;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+
+public final class TypeVariableName implements TypeName {
+  private final CharSequence name;
+  private final Iterable<? extends TypeName> extendsBounds;
+
+  TypeVariableName(CharSequence name, Iterable<? extends TypeName> extendsBounds) {
+    this.name = name;
+    this.extendsBounds = extendsBounds;
+  }
+
+  public CharSequence name() {
+    return name;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
+    for (TypeName bound : extendsBounds) {
+      builder.addAll(bound.referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append(name);
+    if (!Iterables.isEmpty(extendsBounds)) {
+      appendable.append(" extends ");
+      Iterator<? extends TypeName> iter = extendsBounds.iterator();
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(" & ");
+        iter.next().write(appendable, context);  
+      }
+    }
+    return appendable;
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof TypeVariableName) {
+      TypeVariableName that = (TypeVariableName) obj;
+      return this.name.toString().equals(that.name.toString())
+          && this.extendsBounds.equals(that.extendsBounds);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(name, extendsBounds);
+  }
+
+  static TypeVariableName named(CharSequence name) {
+    return new TypeVariableName(name, ImmutableList.<TypeName>of());
+  }
+  
+  public static TypeVariableName fromTypeVariable(TypeVariable variable) {
+    // Note: We don't have any use right now for the bounds because these are references
+    // to the type & not the specification of the type itself.  We never generate
+    // code with type variables that include upper or lower bounds.
+    return named(variable.asElement().getSimpleName());
+  }
+
+  // TODO(sameb): Consider making this a whole different thing: TypeParameterName since it
+  // has different semantics than a TypeVariable (parameters only have upper bounds).
+  public static TypeVariableName fromTypeParameterElement(TypeParameterElement element) {
+    // We filter out bounds of type Object because those would just clutter the generated code.
+    Iterable<? extends TypeName> bounds =
+        FluentIterable.from(element.getBounds())
+            .filter(new Predicate<TypeMirror>() {
+              @Override public boolean apply(TypeMirror input) {
+                return !MoreTypes.isType(input) || !MoreTypes.isTypeOf(Object.class, input);
+              }
+            })
+            .transform(TypeNames.FOR_TYPE_MIRROR);
+    return new TypeVariableName(element.getSimpleName(), bounds);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
new file mode 100644
index 000000000..364b3a239
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Only named types. Doesn't cover anonymous inner classes.
+ */
+public abstract class TypeWriter /* ha ha */ extends Modifiable
+    implements Writable, HasTypeName, HasClassReferences {
+  final ClassName name;
+  Optional<TypeName> supertype;
+  final List<TypeName> implementedTypes;
+  final List<MethodWriter> methodWriters;
+  final List<TypeWriter> nestedTypeWriters;
+  final Map<String, FieldWriter> fieldWriters;
+
+  TypeWriter(ClassName name) {
+    this.name = name;
+    this.supertype = Optional.absent();
+    this.implementedTypes = Lists.newArrayList();
+    this.methodWriters = Lists.newArrayList();
+    this.nestedTypeWriters = Lists.newArrayList();
+    this.fieldWriters = Maps.newLinkedHashMap();
+  }
+
+  @Override
+  public ClassName name() {
+    return name;
+  }
+
+  public MethodWriter addMethod(TypeWriter returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeMirror returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeName returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(Class<?> returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(ClassName.fromClass(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public ClassWriter addNestedClass(String name) {
+    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
+    nestedTypeWriters.add(innerClassWriter);
+    return innerClassWriter;
+  }
+
+  public void addImplementedType(TypeName typeReference) {
+    implementedTypes.add(typeReference);
+  }
+
+  public void addImplementedType(TypeElement typeElement) {
+    implementedTypes.add(ClassName.fromTypeElement(typeElement));
+  }
+
+  public void setSuperType(TypeName typeReference) {
+    checkState(!supertype.isPresent());
+    supertype = Optional.of(typeReference);
+  }
+
+  public void setSuperType(TypeElement typeElement) {
+    setSuperType(ClassName.fromTypeElement(typeElement));
+  }
+
+  public FieldWriter addField(Class<?> type, String name) {
+    return addField(ClassName.fromClass(type), name);
+  }
+
+  public FieldWriter addField(TypeElement type, String name) {
+    return addField(ClassName.fromTypeElement(type), name);
+  }
+
+  public FieldWriter addField(TypeName type, String name) {
+    String candidateName = name;
+    int differentiator = 1;
+    while (fieldWriters.containsKey(candidateName)) {
+      candidateName = name + differentiator;
+      differentiator++;
+    }
+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
+    fieldWriters.put(candidateName, fieldWriter);
+    return fieldWriter;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
new file mode 100644
index 000000000..28a290e35
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import java.io.IOException;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
+  private final TypeName type;
+  private final String name;
+
+  VariableWriter(TypeName type, String name) {
+    this.type = checkNotNull(type);
+    this.name = checkNotNull(name);
+  }
+
+  public TypeName type() {
+    return type;
+  }
+
+  public String name() {
+    return name;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeModifiers(appendable);
+    type.write(appendable, context);
+    return appendable.append(' ').append(name);
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return type.referencedClasses();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
new file mode 100644
index 000000000..f82a4cab4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+
+public enum VoidName implements TypeName {
+  VOID;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public String toString() {
+    return "void";
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return appendable.append("void");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
new file mode 100644
index 000000000..7756f9311
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+import javax.lang.model.type.WildcardType;
+
+import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;
+
+public final class WildcardName implements TypeName {
+  private final Optional<TypeName> extendsBound;
+  private final Optional<TypeName> superBound;
+
+  WildcardName(Optional<TypeName> extendsBound,
+      Optional<TypeName> superBound) {
+    this.extendsBound = extendsBound;
+    this.superBound = superBound;
+  }
+
+  static WildcardName forTypeMirror(WildcardType mirror) {
+    return new WildcardName(
+        Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),
+        Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
+    if (extendsBound.isPresent()) {
+      builder.addAll(extendsBound.get().referencedClasses());
+    }
+    if (superBound.isPresent()) {
+      builder.addAll(superBound.get().referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append('?');
+    if (extendsBound.isPresent()) {
+      appendable.append(" extends ");
+      extendsBound.get().write(appendable, context);
+    }
+    if (superBound.isPresent()) {
+      appendable.append(" super ");
+      superBound.get().write(appendable, context);
+    }
+    return appendable;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
new file mode 100644
index 000000000..9a88f433d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import java.io.IOException;
+import java.util.Set;
+
+interface Writable {
+  interface Context {
+    String sourceReferenceForClassName(ClassName className);
+    Context createSubcontext(Set<ClassName> newTypes);
+  }
+
+  Appendable write(Appendable appendable, Context context) throws IOException;
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
new file mode 100644
index 000000000..0186cbfcf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import dagger.internal.codegen.writer.Writable.Context;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Set;
+
+final class Writables {
+
+  /**
+   * Joins the writables by the given delimiter, writing out the
+   * prefix & suffix if there's at least one element.
+   */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      String prefix, String suffix,
+      Appendable appendable, Context context) throws IOException {
+    Iterator<? extends Writable> iter = writables.iterator();
+    if (iter.hasNext()) {
+      appendable.append(prefix);
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(delimiter);
+        iter.next().write(appendable, context);
+      }
+      appendable.append(suffix);
+    }
+  }
+
+  /** Joins the writables by the given delimiter. */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      Appendable appendable, Context context) throws IOException {
+    join(delimiter, writables, "", "", appendable, context);
+  }
+
+  static Writable toStringWritable(final Object object) {
+    return new Writable() {
+      @Override
+      public Appendable write(Appendable appendable, Context context) throws IOException {
+        return appendable.append(object.toString());
+      }
+    };
+  }
+
+  private static final Context DEFAULT_CONTEXT = new Context() {
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
+      return className.canonicalName();
+    }
+
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      throw new UnsupportedOperationException();
+    }
+  };
+
+  static String writeToString(Writable writable) {
+    StringBuilder builder = new StringBuilder();
+    try {
+      writable.write(builder, DEFAULT_CONTEXT);
+    } catch (IOException e) {
+      throw new AssertionError("StringBuilder doesn't throw IOException" + e);
+    }
+    return builder.toString();
+  }
+
+  private Writables() {
+  }
+}
diff --git a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
deleted file mode 100644
index db389355b..000000000
--- a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ /dev/null
@@ -1,3 +0,0 @@
-dagger.internal.codegen.InjectProcessor
-dagger.internal.codegen.ProvidesProcessor
-dagger.internal.codegen.FullGraphProcessor
\ No newline at end of file
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
new file mode 100644
index 000000000..eaaa595d3
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.MembersInjector;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link FrameworkField}.
+ */
+@RunWith(JUnit4.class)
+public class BindingFieldTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+  }
+
+  private ExecutableElement getXConstructor() {
+    TypeElement classElement = elements.getTypeElement(X.class.getCanonicalName());
+    return Iterables.getOnlyElement(
+        ElementFilter.constructorsIn(classElement.getEnclosedElements()));
+  }
+
+  @Test public void frameworkType() {
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
+    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
+        .frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(Provider.class), xClass));
+    assertThat(FrameworkField.createWithTypeFromKey(MembersInjector.class,
+            BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key), "test")
+        .frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(MembersInjector.class), xClass));
+  }
+
+  @Test public void nameSuffix() {
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
+        .isEqualTo("fooProvider");
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "fooProvider").name())
+        .isEqualTo("fooProvider");
+
+  }
+
+  static final class X {
+    @Inject X() {}
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
new file mode 100644
index 000000000..de59af6ec
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -0,0 +1,938 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** Tests for {@link dagger.Component.Builder} */
+@RunWith(JUnit4.class)
+public class ComponentBuilderTest {
+  
+  private static final ErrorMessages.ComponentBuilderMessages MSGS =
+      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+  
+  @Test
+  public void testEmptyBuilder() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",        
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import test.SimpleComponent",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static SimpleComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  private static final class Builder implements SimpleComponent.Builder {",
+        "    @Override",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testUsesBuildAndSetterNames() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder setTestModule(TestModule testModule);",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().create();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    @Override",
+        "    public TestComponent create() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder setTestModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testIgnoresModulesNotInApi() {
+    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule1 {",
+        "  @Provides String string() { return null; }",
+        "}");
+    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule2 {",
+        "  @Provides Integer integer() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule1.class, TestModule2.class})",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    Builder testModule1(TestModule1 testModule);",
+        "    TestComponent build();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<String> stringProvider;",
+        "  private Provider<Integer> integerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static TestComponent.Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+        "  }",
+        "",
+        "  @Override",
+        "  public String string() {",
+        "    return stringProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer integer() {",
+        "    return integerProvider.get();",
+        "  }",
+        "",
+        "  private static final class Builder implements TestComponent.Builder {",
+        "    private TestModule1 testModule1;",
+        "    private TestModule2 testModule2;",
+        "",
+        "    @Override",
+        "    public TestComponent build() {",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule1();",
+        "      }",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new TestModule2();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Override",
+        "    public Builder testModule1(TestModule1 testModule1) {",
+        "      if (testModule1 == null) {",
+        "        throw new NullPointerException(\"testModule1\");",
+        "      }",
+        "      this.testModule1 = testModule1;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module1, module2, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  static interface Builder {",
+        "     SimpleComponent build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder2 {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder<T> {",
+        "     SimpleComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract());
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(componentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    SimpleComponent create();",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(componentFile).onLine(12)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(componentFile).onLine(13);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(componentFile).onLine(15);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(componentFile).onLine(12);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent {",
+        "    SimpleComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(componentFile).onLine(15);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(componentFile).onLine(10);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Component.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    SimpleComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(componentFile).onLine(14);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "abstract class SimpleComponent {",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    SimpleComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.SimpleComponent.Builder.set1(String),"
+                  + " void test.SimpleComponent.Builder.set2(Integer)]"))
+            .in(componentFile).onLine(10);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+        "           dependencies = OtherComponent.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Component.Builder",
+        "  interface Builder {",
+        "    TestComponent create();",
+        "  }",
+        "}");
+    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface OtherComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(),
+                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+            .in(componentFile).onLine(12);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
new file mode 100644
index 000000000..c5841c8db
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -0,0 +1,1841 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
+import javax.tools.JavaFileObject;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+
+@RunWith(JUnit4.class)
+public class ComponentProcessorTest {
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "final class NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "@interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = Object.class)",
+        "interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is not annotated with @Module");
+  }
+
+  @Test public void cannotReferToAbstractModules() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface BadComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
+  }
+
+  @Test public void doubleBindingFromResolvedModules() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A> {",
+        "  @Provides List<A> provideListB(A a) { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<Integer> {",
+        "  @Provides Integer provideInteger() { return null; }",
+        "}");
+    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "class AnotherModule {",
+        "  @Provides List<Integer> provideListOfInteger() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
+        "interface BadComponent {",
+        "  List<Integer> listOfInteger();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile().withErrorContaining(
+            "java.util.List<java.lang.Integer> is bound multiple times")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
+  }
+
+  @Test public void simpleComponent() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "    return DoubleCheckLazy.create(SomeInjectableType_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "    return SomeInjectableType_Factory.create();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentWithScope() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import dagger.internal.ScopedProvider;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectableTypeProvider =",
+        "        ScopedProvider.create(SomeInjectableType_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "    return someInjectableTypeProvider;",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerOuterType_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
+        "import test.OuterType.SimpleComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<B> bMembersInjector;",
+        "",
+        "  private DaggerOuterType_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.bMembersInjector =",
+        "        OuterType$B_MembersInjector.create(OuterType$A_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
+        "    return OuterType$A_Factory.create().get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public void inject(B b) {",
+        "    bMembersInjector.injectMembers(b);",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerOuterType_SimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentWithModule() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "interface B {}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides B b(C c) { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<B> bProvider;",
+        "  private Provider<A> aProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
+        "        C_Factory.create());",
+        "    this.aProvider = A_Factory.create(bProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void transitiveModuleDeps() {
+    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class AlwaysIncluded {}");
+    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
+        "final class TestModule extends ParentTestModule {}");
+    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
+        "class ParentTestModule {}");
+    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentTestIncluded {}");
+    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
+        "final class DepModule extends ParentDepModule {}");
+    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class RefByDep extends ParentDepModule {}");
+    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
+        "class ParentDepModule {}");
+    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentDepIncluded {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "}");
+    // Generated code includes all includes, but excludes the parent modules.
+    // The "always" module should only be listed once.
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "    private DepModule depModule;",
+        "    private AlwaysIncluded alwaysIncluded;",
+        "    private ParentTestIncluded parentTestIncluded;",
+        "    private RefByDep refByDep;",
+        "    private ParentDepIncluded parentDepIncluded;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      if (depModule == null) {",
+        "        this.depModule = new DepModule();",
+        "      }",
+        "      if (alwaysIncluded == null) {",
+        "        this.alwaysIncluded = new AlwaysIncluded();",
+        "      }",
+        "      if (parentTestIncluded == null) {",
+        "        this.parentTestIncluded = new ParentTestIncluded();",
+        "      }",
+        "      if (refByDep == null) {",
+        "        this.refByDep = new RefByDep();",
+        "      }",
+        "      if (parentDepIncluded == null) {",
+        "        this.parentDepIncluded = new ParentDepIncluded();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder depModule(DepModule depModule) {",
+        "      if (depModule == null) {",
+        "        throw new NullPointerException(\"depModule\");",
+        "      }",
+        "      this.depModule = depModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
+        "      if (alwaysIncluded == null) {",
+        "        throw new NullPointerException(\"alwaysIncluded\");",
+        "      }",
+        "      this.alwaysIncluded = alwaysIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      if (parentTestIncluded == null) {",
+        "        throw new NullPointerException(\"parentTestIncluded\");",
+        "      }",
+        "      this.parentTestIncluded = parentTestIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      if (refByDep == null) {",
+        "        throw new NullPointerException(\"refByDep\");",
+        "      }",
+        "      this.refByDep = refByDep;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
+        "      if (parentDepIncluded == null) {",
+        "        throw new NullPointerException(\"parentDepIncluded\");",
+        "      }",
+        "      this.parentDepIncluded = parentDepIncluded;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(always,
+            testModule,
+            parentTest,
+            parentTestIncluded,
+            depModule,
+            refByDep,
+            parentDep,
+            parentDepIncluded,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void testDefaultPackage() {
+    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
+    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
+        "import javax.inject.Inject;",
+        "",
+        "class BClass {",
+        "  @Inject BClass(AClass a) {}",
+        "}");
+    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module class AModule {",
+        "  @Provides AClass aClass() {",
+        "    return new AClass();",
+        "  }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = AModule.class)",
+        "interface SomeComponent {",
+        "  BClass bClass();",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aModule, aClass, bClass, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class EmptySetModule {",
+        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides(type = SET) String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.SetFactory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Set<String>> setOfStringContribution1Provider;",
+        "  private Provider<Set<String>> setOfStringContribution2Provider;",
+        "  private Provider<Set<String>> setOfStringProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.setOfStringContribution1Provider =",
+        "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
+        "    this.setOfStringContribution2Provider =",
+        "        SetModule_StringFactory.create(builder.setModule);",
+        "    this.setOfStringProvider = SetFactory.create(",
+        "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Set<String> strings() {",
+        "    return setOfStringProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private EmptySetModule emptySetModule;",
+        "    private SetModule setModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (emptySetModule == null) {",
+        "        this.emptySetModule = new EmptySetModule();",
+        "      }",
+        "      if (setModule == null) {",
+        "        this.setModule = new SetModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+        "      if (emptySetModule == null) {",
+        "        throw new NullPointerException(\"emptySetModule\");",
+        "      }",
+        "      this.emptySetModule = emptySetModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder setModule(SetModule setModule) {",
+        "      if (setModule == null) {",
+        "        throw new NullPointerException(\"setModule\");",
+        "      }",
+        "      this.setModule = setModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void membersInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  void inject(SomeInjectedType instance);",
+        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectedTypeMembersInjector =",
+        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public void inject(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(SimpleComponent component) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.internal.InstanceFactory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private Provider<SimpleComponent> simpleComponentProvider;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+        "    this.someInjectableTypeProvider =",
+        "        SomeInjectableType_Factory.create(simpleComponentProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void membersInjectionInsideProvision() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  @Inject SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectedType createAndInject();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectedTypeMembersInjector =",
+        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
+        "    this.someInjectedTypeProvider =",
+        "        SomeInjectedType_Factory.create(someInjectedTypeMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType createAndInject() {",
+        "    return someInjectedTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void injectionWithGenericBaseClass() {
+    JavaFileObject genericType = JavaFileObjects.forSourceLines("test.AbstractGenericType",
+        "package test;",
+        "",
+        "abstract class AbstractGenericType<T> {",
+        "}");
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType extends AbstractGenericType<String> {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectableTypeProvider =",
+        "        SomeInjectableType_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(genericType, injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void componentDependency() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(A a) {}",
+        "}");
+    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface AComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = AComponent.class)",
+        "interface BComponent {",
+        "  B b();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerBComponent",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerBComponent implements BComponent {",
+        "  private Provider<A> aProvider;",
+        "  private Provider<B> bProvider;",
+        "",
+        "  private DaggerBComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.aProvider = new Factory<A>() {",
+        "      private final AComponent aComponent = builder.aComponent;",
+        "      @Override public A get() {",
+        "        A provided = aComponent.a();",
+        "        if (provided == null) {",
+        "          throw new NullPointerException(" + NPE_LITERAL + ");",
+        "        }",
+        "        return provided;",
+        "      }",
+        "    };",
+        "    this.bProvider = B_Factory.create(aProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public B b() {",
+        "    return bProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AComponent aComponent;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public BComponent build() {",
+        "      if (aComponent == null) {",
+        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "      }",
+        "      return new DaggerBComponent(this);",
+        "    }",
+        "",
+        "    public Builder aComponent(AComponent aComponent) {",
+        "      if (aComponent == null) {",
+        "        throw new NullPointerException(\"aComponent\");",
+        "      }",
+        "      this.aComponent = aComponent;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void moduleNameCollision() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "public final class A {}");
+    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
+        "package other.test;",
+        "",
+        "public final class A {}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
+        "package other.test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
+        "interface TestComponent {",
+        "  A a();",
+        "  other.test.A otherA();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.test.A;",
+        "import other.test.TestModule;",
+        "import other.test.TestModule_AFactory;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<test.A> aProvider;",
+        "  private Provider<A> aProvider1;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.aProvider = test.TestModule_AFactory.create(builder.testModule);",
+        "    this.aProvider1 = TestModule_AFactory.create(builder.testModule1);",
+        "  }",
+        "",
+        "  @Override",
+        "  public test.A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public A otherA() {",
+        "    return aProvider1.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private test.TestModule testModule;",
+        "    private TestModule testModule1;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new test.TestModule();",
+        "      }",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(test.TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule1 = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void resolutionOrder() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(C c) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class X {",
+        "  @Inject X(C c) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  A a();",
+        "  C c();",
+        "  X x();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<B> bProvider;",
+        "  private Provider<A> aProvider;",
+        "  private Provider<X> xProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.bProvider = B_Factory.create(C_Factory.create());",
+        "    this.aProvider = A_Factory.create(bProvider);",
+        "    this.xProvider = X_Factory.create(C_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public C c() {",
+        "    return C_Factory.create().get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public X x() {",
+        "    return xProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void simpleComponent_redundantComponentMethod() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeA {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeB {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends SupertypeA, SupertypeB {",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {}",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(
+            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void simpleComponent_inheritedComponentMethodDep() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertype = JavaFileObjects.forSourceLines("test.Supertype",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface Supertype {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject depComponentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends Supertype {",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithDep",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = SimpleComponent.class)",
+        "interface ComponentWithDep {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {}",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(
+            injectableTypeFile, componentSupertype, depComponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void wildcardGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<? extends A> bA) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
+  }
+
+  @Test
+  @Ignore // modify this test as necessary while debugging for your situation.
+  @SuppressWarnings("unused")
+  public void genericTestToLetMeDebugInEclipse() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+         "import javax.inject.Inject;",
+         "",
+         "public final class A {",
+         "  @Inject A() {}",
+         "}");
+     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+         "package test;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "",
+         "public class B<T> {",
+         "  @Inject B() {}",
+         "}");
+     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
+         "package test.sub;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "import test.B;",
+         "",
+         "public class D {",
+         "  @Inject D(B<A.InA> ba) {}",
+         "}");
+     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+         "package test;",
+         "",
+         "import dagger.Component;",
+         "import dagger.Lazy;",
+         "",
+         "import javax.inject.Provider;",
+         "",
+         "@Component",
+         "interface SimpleComponent {",
+         "  B<A> d();",
+         "  Provider<B<A>> d2();",
+         "}");
+     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+         "test.DaggerSimpleComponent",
+         "package test;",
+         "",
+         "import javax.annotation.Generated;",
+         "import javax.inject.Provider;",
+         "",
+         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+         "public final class DaggerSimpleComponent implements SimpleComponent {",
+         "  private Provider<D> dProvider;",
+         "",
+         "  private DaggerSimpleComponent(Builder builder) {",
+         "    assert builder != null;",
+         "    initialize();",
+         "  }",
+         "",
+         "  public static Builder builder() {",
+         "    return new Builder();",
+         "  }",
+         "",
+         "  public static SimpleComponent create() {",
+         "    return builder().build();",
+         "  }",
+         "",
+         "  private void initialize() {",
+         "    this.dProvider = new D_Factory(B_Factory.INSTANCE);",
+         "  }",
+         "",
+         "  @Override",
+         "  public D d() {",
+         "    return dProvider.get();",
+         "  }",
+         "",
+         "  public static final class Builder {",
+         "    private Builder() {",
+         "    }",
+         "",
+         "    public SimpleComponent build() {",
+         "      return new DaggerSimpleComponent(this);",
+         "    }",
+         "  }",
+         "}");
+     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
+         .processedWith(new ComponentProcessor())
+         .compilesWithoutError()
+         .and().generatesSources(generatedComponent);
+   }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
new file mode 100644
index 000000000..76b28e461
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.List;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link DependencyRequestMapper}.
+ */
+@RunWith(JUnit4.class)
+public class DependencyRequestMapperTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+  private DependencyRequest.Factory dependencyRequestFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+  }
+
+  private List<? extends VariableElement> sampleProviderParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return providesMethod.getParameters();
+  }
+
+  private List<? extends VariableElement> sampleProducerParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodModule.class.getCanonicalName());
+    ExecutableElement producesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return producesMethod.getParameters();
+  }
+
+  private DependencyRequest dependencyRequestForInstance() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForLazy() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
+  }
+
+  private DependencyRequest dependencyRequestForProvider() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
+  }
+
+  private DependencyRequest dependencyRequestForMembersInjector() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
+  }
+
+  private DependencyRequest dependencyRequestForProducer() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForProduced() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(1));
+  }
+
+  @Test public void forProvider() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PROVIDER;
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
+  }
+
+  @Test public void forProducer() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PRODUCER;
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProducer()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProduced()))
+        .isEqualTo(Producer.class);
+  }
+
+  @Module
+  static final class ProvidesMethodModule {
+    @Provides String provideString(
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+      return null;
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodModule {
+    @Produces String produceString(Producer<Integer> a, Produced<Integer> b) {
+      return null;
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
deleted file mode 100644
index f7a7c58bd..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-public final class DotWriterTest {
-  private final StringWriter stringWriter = new StringWriter();
-  private final DotWriter dotWriter = new DotWriter(stringWriter);
-
-  @Test public void graphWithAttributes() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.edge("CoffeeMaker", "Heater", "style", "dotted", "color", "red");
-    dotWriter.edge("CoffeeMaker", "Pump");
-    dotWriter.node("CoffeeMaker", "shape", "box");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  CoffeeMaker -> Heater [style=dotted;color=red];\n"
-        + "  CoffeeMaker -> Pump;\n"
-        + "  CoffeeMaker [shape=box];\n"
-        + "}\n");
-  }
-
-  @Test public void subgraph() throws IOException {
-    dotWriter.beginGraph("label", "10\" tall");
-    dotWriter.beginGraph("style", "filled", "color", "lightgrey");
-    dotWriter.edge("ElectricHeater", "Heater");
-    dotWriter.endGraph();
-    dotWriter.edge("CoffeeMaker", "Heater");
-    dotWriter.edge("CoffeeMaker", "Pump");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  label = \"10\\\" tall\";\n"
-        + "  subgraph cluster2 {\n"
-        + "    style = filled;\n"
-        + "    color = lightgrey;\n"
-        + "    ElectricHeater -> Heater;\n"
-        + "  }\n"
-        + "  CoffeeMaker -> Heater;\n"
-        + "  CoffeeMaker -> Pump;\n"
-        + "}\n");
-  }
-
-  @Test public void defaultAttributes() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.nodeDefaults("color", "red");
-    dotWriter.edgeDefaults("style", "dotted");
-    dotWriter.edge("CoffeeMaker", "Heater");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  node [color=red];\n"
-        + "  edge [style=dotted];\n"
-        + "  CoffeeMaker -> Heater;\n"
-        + "}\n");
-  }
-
-  @Test public void invalidNodeNames() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.edge("a.b", "a c");
-    dotWriter.edge("a c", "a_d");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  n2 [label=\"a.b\"];\n"
-        + "  n3 [label=\"a c\"];\n"
-        + "  n2 -> n3;\n"
-        + "  n3 -> a_d;\n"
-        + "}\n");
-  }
-
-  private void assertGraph(String expected) {
-    assertThat(stringWriter.toString()).isEqualTo(expected);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java b/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
new file mode 100644
index 000000000..141d5c452
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class ErrorMessagesTest {
+  @Test public void stripCommonTypePrefixes() {
+    String typeName = "com.google.common.collect.ImmutableList<java.lang.Boolean>";
+    assertThat(ErrorMessages.stripCommonTypePrefixes(typeName)).isEqualTo("ImmutableList<Boolean>");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
new file mode 100644
index 000000000..da0c2b06c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class GraphValidationScopingTest {
+  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @Singleton String string() { return \"a string\"; }",
+        "  @Provides long integer() { return 0L; }",
+        "  @Provides float floatingPoint() { return 0.0f; }",
+        "}");
+    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
+        + "      @Provides @Singleton String test.ScopedModule.string()\n"
+        + "      @Singleton class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope",
+        "@interface PerTest {}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "@PerTest", // incompatible scope
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
+        "  @Provides long integer() { return 0L; }", // unscoped - valid
+        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+        "}");
+    String errorMessage = "test.MyComponent scoped with @Singleton "
+        + "may not reference bindings with different scopes:\n"
+        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
+        + "      @test.PerTest class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
+    // If a scoped component will have dependencies, they must only include, at most, a single
+    // scoped component
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  static class A { @Inject A() {} }",
+        "  static class B { @Inject B() {} }",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject singletonScopedA = JavaFileObjects.forSourceLines("test.SingletonComponentA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentA {",
+        "  SimpleType.A type();",
+        "}");
+    JavaFileObject singletonScopedB = JavaFileObjects.forSourceLines("test.SingletonComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentB {",
+        "  SimpleType.B type();",
+        "}");
+    JavaFileObject scopeless = JavaFileObjects.forSourceLines("test.ScopelessComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface ScopelessComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
+        "interface SimpleScopedComponent {",
+        "  SimpleType.A type();",
+        "}");
+    String errorMessage =
+        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
+        + "      @Singleton test.SingletonComponentA\n"
+        + "      @Singleton test.SingletonComponentB";
+    assert_().about(javaSources())
+        .that(
+            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopedComponent = JavaFileObjects.forSourceLines("test.ScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface ScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject unscopedComponent = JavaFileObjects.forSourceLines("test.UnscopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(dependencies = ScopedComponent.class)",
+        "interface UnscopedComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
+        + "      @Singleton test.ScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, scopedComponent, unscopedComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
+    // Singleton must be the widest lifetime of present scopes.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component",
+        "interface SimpleScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject singletonScoped = JavaFileObjects.forSourceLines("test.SingletonComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(dependencies = SimpleScopedComponent.class)",
+        "interface SingletonComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "This @Singleton component cannot depend on scoped components:\n"
+        + "      @test.SimpleScope test.SimpleScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, simpleScope, simpleScoped, singletonScoped))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentScopeAncestryMustNotCycle() {
+    // The dependency relationship of components is necessarily from shorter lifetimes to
+    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
+    // scopes on components such that they cycle.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopeA = JavaFileObjects.forSourceLines("test.ScopeA",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeA {}");
+    JavaFileObject scopeB = JavaFileObjects.forSourceLines("test.ScopeB",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeB {}");
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component",
+        "interface ComponentLong {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeB",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
+        + "      @test.ScopeA test.ComponentLong\n"
+        + "      @test.ScopeB test.ComponentMedium\n"
+        + "      @test.ScopeA test.ComponentShort";
+    assert_().about(javaSources())
+        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
new file mode 100644
index 000000000..19b9c9419
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -0,0 +1,824 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
+
+@RunWith(JUnit4.class)
+public class GraphValidationTest {
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+            .in(component).onLine(7);
+  }
+
+  @Test public void componentProvisionWithNoDependencyChain() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(10);
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.A cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(15);
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.B cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method. "
+        + "This type supports members injection but cannot be implicitly provided.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(19);
+  }
+
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.CComponent.getC() contains a dependency cycle:\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(23);
+  }
+
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+
+        "  static class D {",
+        "    @Inject D(C cParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface DComponent {",
+        "    D getD();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
+        + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(26);
+  }
+
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.A test.Outer.Parent.getA()\n"
+        + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
+        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(24);
+  }
+
+  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.MapKey;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.MapKey;",
+        "import java.util.HashMap;",
+        "import java.util.HashSet;",
+        "import java.util.Map;",
+        "import java.util.Set;",
+        "",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "import static dagger.Provides.Type.MAP;",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "final class Outer {",
+        "  @MapKey(unwrapValue = true)",
+        "  @interface StringKey {",
+        "    String value();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule1 {",
+        "    @Provides(type = MAP)",
+        "    @StringKey(\"foo\")",
+        "    String stringMapEntry() { return \"\"; }",
+        "",
+        "    @Provides(type = SET) String stringSetElement() { return \"\"; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule2 {",
+        "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+        "",
+        "    @Provides Map<String, String> stringMap() {",
+        "      return new HashMap<String, String>();",
+        "    }",
+        "  }",
+        "",
+        "  @Component(modules = { TestModule1.class, TestModule2.class })",
+        "  interface TestComponent {",
+        "    Set<String> getStringSet();",
+        "    Map<String, String> getStringMap();",
+        "  }",
+        "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings:\n"
+            + "      Set bindings:\n"
+            + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
+            + "      Unique bindings:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
+            + "      Map bindings:\n"
+            + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
+            + " test.Outer.TestModule1.stringMapEntry()\n"
+            + "      Unique bindings:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError).in(component).onLine(43)
+        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+  }
+
+  @Test public void duplicateBindings_TruncateAfterLimit() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module3 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module4 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module5 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module6 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module7 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module8 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module9 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module10 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module11 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module12 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = {",
+        "    Module1.class,",
+        "    Module2.class,",
+        "    Module3.class,",
+        "    Module4.class,",
+        "    Module5.class,",
+        "    Module6.class,",
+        "    Module7.class,",
+        "    Module8.class,",
+        "    Module9.class,",
+        "    Module10.class,",
+        "    Module11.class,",
+        "    Module12.class",
+        "  })",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      @Provides test.Outer.A test.Outer.Module1.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module2.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module3.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module4.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module5.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module6.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module7.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module8.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module9.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
+        + "      and 2 others";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(86);
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  static class B {",
+        "    @Inject B(A a) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject B b;",
+        "    @Inject C(B b) {}",
+        "  }",
+        "",
+        "  interface D { }",
+        "",
+        "  static class DImpl implements D {",
+        "    @Inject DImpl(C c, B b) {}",
+        "  }",
+        "",
+        "  @Module",
+        "  static class DModule {",
+        "    @Provides D d(DImpl impl) { return impl; }",
+        "  }",
+        "",
+        "  @Component(modules = { DModule.class })",
+        "  interface AComponent {",
+        "    D getFoo();",
+        "    C injectC(C c);",
+        "  }",
+        "}");
+    String errorText =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.\n";
+    String firstError = errorText
+        + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
+        + "          [parameter: test.TestClass.DImpl impl]\n"
+        + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
+        + "          [parameter: test.TestClass.C c]\n"
+        + "      test.TestClass.C.b\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    String secondError = errorText
+        + "      test.TestClass.C.b\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(firstError).in(component).onLine(33)
+        .and().withErrorContaining(secondError).in(component).onLine(34);
+  }
+
+  @Test public void resolvedParametersInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject Generic(T t) {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg = Joiner.on("\n").join(
+        "java.util.List cannot be provided without an @Provides-annotated method.",
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
+        "      test.Generic.<init>(test.TestClass t)",
+        "          [parameter: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
+        "          [parameter: java.util.List list]");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+
+  @Test public void resolvedVariablesInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject T t;",
+        "  @Inject Generic() {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg = Joiner.on("\n").join(
+        "java.util.List cannot be provided without an @Provides-annotated method.",
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
+        "      test.Generic.t",
+        "          [injected field of type: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
+        "          [parameter: java.util.List list]");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject String string;",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
deleted file mode 100644
index 8f0a13515..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Keys;
-import java.lang.reflect.Field;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-public final class GraphVisualizerTest {
-  private final GraphVisualizer graphVisualizer = new GraphVisualizer();
-
-  String simpleKey;
-  @Test public void testSimpleKey() throws Exception {
-    String key = fieldKey("simpleKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
-  }
-
-  @Named String annotatedKey;
-  @Test public void testAnnotatedKey() throws Exception {
-    String key = fieldKey("annotatedKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
-  }
-
-  @Named("/@<>[]()") String annotatedKeyWithParameters;
-  @Test public void testAnnotatedKeyWithParameters() throws Exception {
-    String key = fieldKey("annotatedKeyWithParameters");
-    // We intentionally omit parameters on annotated keys!
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
-  }
-
-  String[][] arrayKey;
-  @Test public void testArrayKey() throws Exception {
-    String key = fieldKey("arrayKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String[][]");
-  }
-
-  Map<String, Set<Object>> typeParameterKey;
-  @Test public void testTypeParameterKey() throws Exception {
-    String key = fieldKey("typeParameterKey");
-    assertThat(graphVisualizer.shortName(key))
-        .isEqualTo("Map<java.lang.String, java.util.Set<java.lang.Object>>");
-  }
-
-  @Named("/@<>[]()") Map<String, Set<Object>>[] everythingKey;
-  @Test public void testEverythingKey() throws Exception {
-    String key = fieldKey("everythingKey");
-    assertThat(graphVisualizer.shortName(key))
-        .isEqualTo("@Named Map<java.lang.String, java.util.Set<java.lang.Object>>[]");
-  }
-
-  @Test public void testMembersKey() throws Exception {
-    String key = Keys.getMembersKey(String.class);
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
-  }
-
-  private String fieldKey(String fieldName) throws NoSuchFieldException {
-    Field field = GraphVisualizerTest.class.getDeclaredField(fieldName);
-    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
new file mode 100644
index 000000000..6310b1d16
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -0,0 +1,1036 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+
+@RunWith(JUnit4.class)
+// TODO(gak): add tests for generation in the default package.
+public final class InjectConstructorFactoryGeneratorTest {
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+  private static final JavaFileObject SCOPE_A =
+      JavaFileObjects.forSourceLines("test.ScopeA",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeA {}");
+  private static final JavaFileObject SCOPE_B =
+      JavaFileObjects.forSourceLines("test.ScopeB",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeB {}");
+
+  @Test public void injectOnPrivateConstructor() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateConstructor {",
+        "  @Inject private PrivateConstructor() {}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnInnerClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class OuterClass {",
+        "  class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
+  }
+
+  @Test public void injectConstructorOnAbstractClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AbstractClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "abstract class AbstractClass {",
+        "  @Inject AbstractClass() {}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnGenericClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<T> {",
+        "  @Inject GenericClass(T t) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public GenericClass_Factory(Provider<T> tProvider) {",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<T> get() {",
+        "    return new GenericClass<T>(tProvider.get());",
+        "  }",
+        "",
+        "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
+        "    return new GenericClass_Factory<T>(tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
+        "",
+        "  public GenericClass_Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    return new GenericClass_Factory<A, B>(membersInjector);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void genericClassWithNoDependencies() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<T> {",
+        "  @Inject GenericClass() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@SuppressWarnings(\"rawtypes\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum GenericClass_Factory implements Factory<GenericClass> {",
+        "  INSTANCE;",
+        "",
+        "  @Override",
+        "  public GenericClass get() {",
+        "    return new GenericClass();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  public static <T> Factory<GenericClass<T>> create() {",
+        "    return (Factory) INSTANCE;",
+        "  }",
+        "",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void twoGenericTypes() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+  
+  @Test public void boundedGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "class GenericClass<A extends Number & Comparable<A>,",
+        "    B extends List<? extends String>,",
+        "    C extends List<? super String>> {",
+        "  @Inject GenericClass(A a, B b, C c) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
+        "        B extends List<? extends String>,",
+        "        C extends List<? super String>>",
+        "    implements Factory<GenericClass<A, B, C>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "",
+        "  public GenericClass_Factory(Provider<A> aProvider,",
+        "      Provider<B> bProvider,",
+        "      Provider<C> cProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "    assert cProvider != null;",
+        "    this.cProvider = cProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B, C> get() {",
+        "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
+        "  }",
+        "",
+        "  public static <A extends Number & Comparable<A>,",
+        "      B extends List<? extends String>,",
+        "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
+        "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
+        "    return new GenericClass_Factory<A, B, C>(aProvider, bProvider, cProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void multipleSameTypesWithGenericsAndQualifiersAndLazies() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "import dagger.Lazy;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, A a2, Provider<A> pa, @QualifierA A qa, Lazy<A> la, ",
+        "                       String s, String s2, Provider<String> ps, ",
+        "                       @QualifierA String qs, Lazy<String> ls,",
+        "                       B b, B b2, Provider<B> pb, @QualifierA B qb, Lazy<B> lb) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+        "  private final Provider<A> qaProvider;",
+        "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+        "  private final Provider<String> qsProvider;",
+        "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+        "  private final Provider<B> qbProvider;",
+        "",
+        "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    assert aAndA2AndPaAndLaProvider != null;",
+        "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+        "    assert qaProvider != null;",
+        "    this.qaProvider = qaProvider;",
+        "    assert sAndS2AndPsAndLsProvider != null;",
+        "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+        "    assert qsProvider != null;",
+        "    this.qsProvider = qsProvider;",
+        "    assert bAndB2AndPbAndLbProvider != null;",
+        "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+        "    assert qbProvider != null;",
+        "    this.qbProvider = qbProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider,",
+        "      qaProvider.get(),",
+        "      DoubleCheckLazy.create(aAndA2AndPaAndLaProvider),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider,",
+        "      qsProvider.get(),",
+        "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
+        "      bAndB2AndPbAndLbProvider.get(),",
+        "      bAndB2AndPbAndLbProvider.get(),", 
+        "      bAndB2AndPbAndLbProvider,",
+        "      qbProvider.get(),",
+        "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    return new GenericClass_Factory<A, B>(",
+        "        aAndA2AndPaAndLaProvider,",
+        "        qaProvider,",
+        "        sAndS2AndPsAndLsProvider,",
+        "        qsProvider,",
+        "        bAndB2AndPbAndLbProvider,",
+        "        qbProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void multipleInjectConstructors() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.TooManyInjectConstructors",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class TooManyInjectConstructors {",
+        "  @Inject TooManyInjectConstructors() {}",
+        "  TooManyInjectConstructors(int i) {}",
+        "  @Inject TooManyInjectConstructors(String s) {}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
+        .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
+  }
+
+  @Test public void multipleQualifiersOnInjectConstructorParameter() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierConstructorParam",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierConstructorParam {",
+        "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        // for whatever reason, javac only reports the error once on the constructor
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructorOnClassWithMultipleScopes() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleScopeClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "@ScopeA @ScopeB class MultipleScopeClass {",
+        "  @Inject MultipleScopeClass() {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
+        .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
+  }
+
+  @Test public void injectConstructorWithQualifier() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleScopeClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleScopeClass {",
+        "  @Inject",
+        "  @QualifierA",
+        "  @QualifierB",
+        "  MultipleScopeClass() {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)
+        .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
+  }
+
+  @Test public void finalInjectField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class FinalInjectField {",
+        "  @Inject final String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectField {",
+        "  @Inject private String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
+  }
+
+  @Test public void multipleQualifiersOnField() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierInjectField {",
+        "  @Inject @QualifierA @QualifierB String s;",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
+        .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
+  }
+
+  @Test public void abstractInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AbstractInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "abstract class AbstractInjectMethod {",
+        "  @Inject abstract void method();",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
+  }
+
+  @Test public void privateInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectMethod {",
+        "  @Inject private void method();",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
+  }
+
+  @Test public void genericInjectMethod() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AbstractInjectMethod {",
+        "  @Inject <T> void method();",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
+  }
+
+  @Test public void multipleQualifiersOnInjectMethodParameter() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierMethodParam",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleQualifierMethodParam {",
+        "  @Inject void method(@QualifierA @QualifierB String s) {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        // for whatever reason, javac only reports the error once on the method
+        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+  }
+
+  @Test public void injectConstructor() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(String s) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor_Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public InjectConstructor_Factory(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(sProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
+        "    return new InjectConstructor_Factory(sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.AllInjections_Factory",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class AllInjections_Factory ",
+        "    implements Factory<AllInjections> {",
+        "",
+        "  private final MembersInjector<AllInjections> membersInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections_Factory(MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public AllInjections get() {",
+        "    AllInjections instance = new AllInjections(sProvider.get());",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static Factory<AllInjections> create(",
+        "      MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    return new AllInjections_Factory(membersInjector, sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedFactory);
+  }
+
+  @Test public void supertypeRequiresMemberInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject B() {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.B_Factory",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B_Factory implements Factory<B> {",
+        "",
+        "  private final MembersInjector<B> membersInjector;",
+        "",
+        "  public B_Factory(MembersInjector<B> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override public B get() {",
+        "    B instance = new B();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
+        "    return new B_Factory(membersInjector);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedFactory);
+  }
+
+  @Test
+  public void wildcardDependency() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import java.util.List;",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(List<? extends Object> objects) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor_Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<List<? extends Object>> objectsProvider;",
+        "",
+        "  public InjectConstructor_Factory(Provider<List<? extends Object>> objectsProvider) {",
+        "    assert objectsProvider != null;",
+        "    this.objectsProvider = objectsProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(objectsProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<List<? extends Object>> objectsProvider) {",
+        "    return new InjectConstructor_Factory(objectsProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void basicNameCollision() {
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("other.pkg.Factory",
+        "package other.pkg;",
+        "",
+        "public class Factory {}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import other.pkg.Factory;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(Factory factory) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor_Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<other.pkg.Factory> factoryProvider;",
+        "",
+        "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
+        "    assert factoryProvider != null;",
+        "    this.factoryProvider = factoryProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(factoryProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<other.pkg.Factory> factoryProvider) {",
+        "    return new InjectConstructor_Factory(factoryProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void nestedNameCollision() {
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("other.pkg.Outer",
+        "package other.pkg;",
+        "",
+        "public class Outer {",
+        "  public class Factory {}",
+        "}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import other.pkg.Outer;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(Outer.Factory factory) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.pkg.Outer;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor_Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<Outer.Factory> factoryProvider;",
+        "",
+        "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
+        "    assert factoryProvider != null;",
+        "    this.factoryProvider = factoryProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(factoryProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<Outer.Factory> factoryProvider) {",
+        "    return new InjectConstructor_Factory(factoryProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void samePackageNameCollision() {
+    JavaFileObject samePackageInterface = JavaFileObjects.forSourceLines("test.CommonName",
+        "package test;",
+        "",
+        "public interface CommonName {}");
+    JavaFileObject differentPackageInterface = JavaFileObjects.forSourceLines(
+        "other.pkg.CommonName",
+        "package other.pkg;",
+        "",
+        "public interface CommonName {}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor implements CommonName {",
+        "  @Inject InjectConstructor(other.pkg.CommonName otherPackage, CommonName samePackage) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.pkg.CommonName;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor_Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<CommonName> otherPackageProvider;",
+        "  private final Provider<test.CommonName> samePackageProvider;",
+        "",
+        "  public InjectConstructor_Factory(Provider<CommonName> otherPackageProvider,",
+        "      Provider<test.CommonName> samePackageProvider) {",
+        "    assert otherPackageProvider != null;",
+        "    this.otherPackageProvider = otherPackageProvider;",
+        "    assert samePackageProvider != null;",
+        "    this.samePackageProvider = samePackageProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<CommonName> otherPackageProvider,",
+        "      Provider<test.CommonName> samePackageProvider) {",
+        "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void noDeps() {
+    JavaFileObject simpleType = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum SimpleType_Factory implements Factory<SimpleType> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public SimpleType get() {",
+        "    return new SimpleType();",
+        "  }",
+        "",
+        "  public static Factory<SimpleType> create() {",
+        "    return INSTANCE;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(simpleType)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factory);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
+        "test.OuterType$A_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "import test.OuterType.A;",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum OuterType$A_Factory implements Factory<A> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public A get() {",
+        "    return new A();",
+        "  }",
+        "",
+        "  public static Factory<A> create() {",
+        "    return INSTANCE;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(aFactory);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
deleted file mode 100644
index c487c8906..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import dagger.internal.Binding;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.lang.reflect.Modifier;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-
-import static dagger.internal.codegen.CodeGen.setOf;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-
-public final class JavaWriterTest {
-  private final StringWriter stringWriter = new StringWriter();
-  private final JavaWriter javaWriter = new JavaWriter(stringWriter);
-
-  @Test public void typeDeclaration() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "public final class Foo {\n"
-        + "}\n");
-  }
-
-  @Test public void fieldDeclaration() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.emitField("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  private static String string;\n"
-        + "}\n");
-  }
-
-  @Test public void fieldDeclarationWithInitialValue() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.field("java.lang.String", "string", 0, "\"bar\" + \"baz\"");
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  String string = \"bar\" + \"baz\";\n"
-        + "}\n");
-  }
-
-  @Test public void abstractMethodDeclaration() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("java.lang.String", "foo", Modifier.ABSTRACT | Modifier.PUBLIC,
-        "java.lang.Object", "object", "java.lang.String", "s");
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  public abstract String foo(Object object, String s);\n"
-        + "}\n");
-  }
-
-  @Test public void nonAbstractMethodDeclaration() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  int foo(String s) {\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void constructorDeclaration() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  public Foo(String s) {\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void statement() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.emitStatement("int j = s.length() + %s", 13);
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  int foo(String s) {\n"
-        + "    int j = s.length() + 13;\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void addImport() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.emitImports(setOf("java.util.ArrayList"));
-    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
-    javaWriter.field("java.util.ArrayList", "list", 0, "new java.util.ArrayList()");
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "import java.util.ArrayList;\n"
-        + "\n"
-        + "public final class Foo {\n"
-        + "  ArrayList list = new java.util.ArrayList();\n"
-        + "}\n");
-  }
-
-  @Test public void addImportFromSubpackage() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
-    javaWriter.emitField("com.squareup.bar.Baz", "baz", 0);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "public final class Foo {\n"
-        + "  com.squareup.bar.Baz baz;\n"
-        + "}\n");
-  }
-
-  @Test public void ifControlFlow() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.beginControlFlow("if (s.isEmpty())");
-    javaWriter.emitStatement("int j = s.length() + %s", 13);
-    javaWriter.endControlFlow();
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  int foo(String s) {\n"
-        + "    if (s.isEmpty()) {\n"
-        + "      int j = s.length() + 13;\n"
-        + "    }\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void doWhileControlFlow() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.beginControlFlow("do");
-    javaWriter.emitStatement("int j = s.length() + %s", 13);
-    javaWriter.endControlFlow("while (s.isEmpty())");
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  int foo(String s) {\n"
-        + "    do {\n"
-        + "      int j = s.length() + 13;\n"
-        + "    } while (s.isEmpty());\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void tryCatchFinallyControlFlow() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.beginControlFlow("try");
-    javaWriter.emitStatement("int j = s.length() + %s", 13);
-    javaWriter.nextControlFlow("catch (RuntimeException e)");
-    javaWriter.emitStatement("e.printStackTrace()");
-    javaWriter.nextControlFlow("finally");
-    javaWriter.emitStatement("int k = %s", 13);
-    javaWriter.endControlFlow();
-    javaWriter.endMethod();
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  int foo(String s) {\n"
-        + "    try {\n"
-        + "      int j = s.length() + 13;\n"
-        + "    } catch (RuntimeException e) {\n"
-        + "      e.printStackTrace();\n"
-        + "    } finally {\n"
-        + "      int k = 13;\n"
-        + "    }\n"
-        + "  }\n"
-        + "}\n");
-  }
-
-  @Test public void annotatedType() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.emitImports(setOf("javax.inject.Singleton"));
-    javaWriter.emitAnnotation("javax.inject.Singleton");
-    javaWriter.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "import javax.inject.Singleton;\n"
-        + "\n"
-        + "@Singleton\n"
-        + "@SuppressWarnings(\"unchecked\")\n"
-        + "class Foo {\n"
-        + "}\n");
-  }
-
-  @Test public void annotatedMember() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.emitAnnotation(Deprecated.class);
-    javaWriter.emitField("java.lang.String", "s", 0);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "class Foo {\n"
-        + "  @Deprecated\n"
-        + "  String s;\n"
-        + "}\n");
-  }
-
-  @Test public void annotatedWithAttributes() throws IOException {
-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
-    attributes.put("overrides", true);
-    attributes.put("entryPoints", new Object[] { "entryPointA", "entryPointB", "entryPointC" });
-    attributes.put("staticInjections", "com.squareup.Quux");
-
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.emitAnnotation("Module", attributes);
-    javaWriter.beginType("com.squareup.FooModule", "class", 0);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "@Module(\n"
-        + "  overrides = true,\n"
-        + "  entryPoints = {\n"
-        + "    entryPointA,\n"
-        + "    entryPointB,\n"
-        + "    entryPointC\n"
-        + "  },\n"
-        + "  staticInjections = com.squareup.Quux\n"
-        + ")\n"
-        + "class FooModule {\n"
-        + "}\n");
-  }
-
-  @Test public void parameterizedType() throws IOException {
-    javaWriter.emitPackage("com.squareup");
-    javaWriter.emitImports(setOf("java.util.Map", "java.util.Date"));
-    javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.emitField("java.util.Map<java.lang.String, java.util.Date>", "map", 0);
-    javaWriter.endType();
-    assertCode(""
-        + "package com.squareup;\n"
-        + "import java.util.Date;\n"
-        + "import java.util.Map;\n"
-        + "\n"
-        + "class Foo {\n"
-        + "  Map<String, Date> map;\n"
-        + "}\n");
-  }
-
-  @Test public void eolComment() throws IOException {
-    javaWriter.emitEndOfLineComment("foo");
-    assertCode(""
-        + "// foo\n");
-  }
-
-  @Test public void javadoc() throws IOException {
-    javaWriter.emitJavadoc("foo");
-    assertCode(""
-        + "/**\n"
-        + " * foo\n"
-        + " */\n");
-  }
-
-  @Test public void multilineJavadoc() throws IOException {
-    javaWriter.emitJavadoc("0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\n"
-        + "0123456789 0123456789 0123456789 0123456789");
-    assertCode(""
-        + "/**\n"
-        + " * 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\n"
-        + " * 0123456789 0123456789 0123456789 0123456789\n"
-        + " */\n");
-  }
-
-  @Test public void testStringLiteral() {
-    assertThat(JavaWriter.stringLiteral("")).isEqualTo("\"\"");
-    assertThat(JavaWriter.stringLiteral("JavaWriter")).isEqualTo("\"JavaWriter\"");
-    assertThat(JavaWriter.stringLiteral("\\")).isEqualTo("\"\\\\\"");
-    assertThat(JavaWriter.stringLiteral("\"")).isEqualTo("\"\\\"\"");
-    assertThat(JavaWriter.stringLiteral("\t")).isEqualTo("\"\\\t\"");
-    assertThat(JavaWriter.stringLiteral("\n")).isEqualTo("\"\\\n\"");
-  }
-
-  @Test public void compressType() throws IOException {
-    javaWriter.emitPackage("blah");
-    javaWriter.emitImports(setOf(Set.class.getName(), Binding.class.getName()));
-    String actual = javaWriter.compressType("java.util.Set<dagger.internal.Binding<blah.Foo.Blah>>");
-    assertEquals("Set<Binding<Foo.Blah>>", actual);
-  }
-
-  @Test public void compressDeeperType() throws IOException {
-    javaWriter.emitPackage("blah");
-    javaWriter.emitImports(setOf(Binding.class.getName()));
-    String actual = javaWriter.compressType("dagger.internal.Binding<blah.foo.Foo.Blah>");
-    assertEquals("Binding<blah.foo.Foo.Blah>", actual);
-  }
-
-  private void assertCode(String expected) {
-    assertThat(stringWriter.toString()).isEqualTo(expected);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
new file mode 100644
index 000000000..c1d622dfd
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.testing.compile.CompilationRule;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
+/**
+ * Tests {@link Key}.
+ */
+@RunWith(JUnit4.class)
+public class KeyTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+  }
+
+  @Test public void forInjectConstructorWithResolvedType() {
+    TypeElement typeElement =
+        compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
+    ExecutableElement constructor =
+        Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
+    assertThat(
+        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType()))
+        .isEqualTo(new AutoValue_Key(
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(typeElement.asType())));
+  }
+
+  static final class InjectedClass {
+    @SuppressWarnings("unused")
+    @Inject InjectedClass(String s, int i) {}
+  }
+
+  @Test public void forProvidesMethod() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    assertThat(
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
+        .isEqualTo(new AutoValue_Key(
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(stringType)));
+  }
+
+  @Module
+  static final class ProvidesMethodModule {
+    @Provides String provideString() {
+      return null;
+    }
+  }
+
+  @Test public void forProvidesMethod_qualified() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement qualifierElement =
+        elements.getTypeElement(TestQualifier.class.getCanonicalName());
+    TypeElement moduleElement =
+        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    Key key =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+    assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+        .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
+    assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+  }
+
+  @Test public void qualifiedKeyEquivalents() {
+    TypeElement moduleElement =
+        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    Key provisionKey =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
+
+    TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement injectableElement =
+        elements.getTypeElement(QualifiedFieldHolder.class.getCanonicalName());
+    Element injectionField =
+        Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));
+    AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
+    Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
+
+    assertThat(provisionKey).isEqualTo(injectionKey);
+  }
+
+  @Module
+  static final class QualifiedProvidesMethodModule {
+    @Provides
+    @TestQualifier(@InnerAnnotation)
+    String provideQualifiedString() {
+      return null;
+    }
+  }
+
+  static final class QualifiedFieldHolder {
+    @TestQualifier(@InnerAnnotation) String aString;
+  }
+
+  @Qualifier
+  @interface TestQualifier {
+    InnerAnnotation[] value();
+  }
+
+  @interface InnerAnnotation {}
+
+  @Test public void forProvidesMethod_sets() {
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement providesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(
+          keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
+              .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(setOfStringsType)));
+    }
+  }
+
+  @Module
+  static final class SetProvidesMethodsModule {
+    @Provides(type = SET) String provideString() {
+      return null;
+    }
+
+    @Provides(type = SET_VALUES) Set<String> provideStrings() {
+      return null;
+    }
+  }
+
+  @Module
+  static final class PrimitiveTypes {
+    @Provides int foo() {
+      return 0;
+    }
+  }
+
+  @Module
+  static final class BoxedPrimitiveTypes {
+    @Provides Integer foo() {
+      return 0;
+    }
+  }
+
+  @Test public void primitiveKeysMatchBoxedKeys() {
+    TypeElement primitiveHolder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
+    ExecutableElement intMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(primitiveHolder.getEnclosedElements()));
+    TypeElement boxedPrimitiveHolder =
+        elements.getTypeElement(BoxedPrimitiveTypes.class.getCanonicalName());
+    ExecutableElement integerMethod = Iterables.getOnlyElement(
+        ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));
+
+    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
+    TypeMirror intType = intMethod.getReturnType();
+    assertThat(intType.getKind().isPrimitive()).isTrue();
+    TypeMirror integerType = integerMethod.getReturnType();
+    assertThat(integerType.getKind().isPrimitive()).isFalse();
+    assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
+
+    Key intKey = keyFactory.forProvidesMethod((ExecutableType) intMethod.asType(), intMethod);
+    Key integerKey =
+        keyFactory.forProvidesMethod((ExecutableType) integerMethod.asType(), integerMethod);
+    assertThat(intKey).isEqualTo(integerKey);
+  }
+
+  @Test public void forProducesMethod() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(
+          (ExecutableType) producesMethod.asType(), producesMethod))
+              .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(stringType)));
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodsModule {
+    @Produces String produceString() {
+      return null;
+    }
+
+    @Produces ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+  }
+
+  @Test public void forProducesMethod_sets() {
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(
+          (ExecutableType) producesMethod.asType(), producesMethod))
+          .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(setOfStringsType)));
+    }
+  }
+
+  @ProducerModule
+  static final class SetProducesMethodsModule {
+    @Produces(type = Produces.Type.SET) String produceString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES)
+    ListenableFuture<Set<String>> produceFutureStrings() {
+      return null;
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
new file mode 100644
index 000000000..74f33aeaa
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -0,0 +1,801 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MapBindingComponentProcessorTest {
+
+  @Test
+  public void mapBindingsWithEnumKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<PathEnum, Provider<Handler>>>",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(test.PathEnum.ADMIN,",
+        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
+        "            .put(test.PathEnum.LOGIN,",
+        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface StringKey {",
+        "  String value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<String, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<String, Provider<Handler>>>",
+        "      mapOfStringAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfStringAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfStringAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfStringAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<String, Handler>builder(2)",
+        "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
+        "            .put(\"Login\", mapOfStringAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, Provider<Handler>> dispatcher() {",
+        "    return mapOfStringAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            stringKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithWrappedKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @ClassKey(Integer.class) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @ClassKey(Long.class) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject classKeyFile = JavaFileObjects.forSourceLines("test.ClassKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface ClassKey {",
+        "  Class<?> value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<ClassKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<ClassKey, Provider<Handler>>>",
+        "      mapOfClassKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfClassKeyAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfClassKeyAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<ClassKey, Handler>builder(2)",
+        "            .put(ClassKeyCreator.create(Integer.class), mapOfClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(ClassKeyCreator.create(Long.class), mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<ClassKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfClassKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            classKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithNonProviderValue() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Handler> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapFactory;",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<PathEnum, Provider<Handler>>>",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(test.PathEnum.ADMIN,",
+        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
+        "            .put(test.PathEnum.LOGIN,",
+        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "    this.mapOfPathEnumAndHandlerProvider =",
+        "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Handler> dispatcher() {",
+        "    return mapOfPathEnumAndHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile)).
+        processedWith(new ComponentProcessor())
+            .compilesWithoutError()
+            .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void injectMapWithoutMapBinding() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.HashMap;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "final class MapModule {",
+        "  @Provides Map<String, String> provideAMap() {",
+        "    Map<String, String> map = new HashMap<String, String>();",
+        "    map.put(\"Hello\", \"World\");",
+        "    return map;",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModule.class})",
+        "interface TestComponent {",
+        "  Map<String, String> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Map<String, String>> provideAMapProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, String> dispatcher() {",
+        "    return provideAMapProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModule mapModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModule == null) {",
+        "        this.mapModule = new MapModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModule(MapModule mapModule) {",
+        "      if (mapModule == null) {",
+        "        throw new NullPointerException(\"mapModule\");",
+        "      }",
+        "      this.mapModule = mapModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+        .processedWith(new ComponentProcessor()).compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
new file mode 100644
index 000000000..b003a4fef
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -0,0 +1,469 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MapKeyProcessorTest {
+  @Test
+  public void mapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public class PathKeyCreator {",
+        "  @com.google.auto.value.AutoAnnotation",
+        "  public static PathKey create(PathEnum value, String relativePath) {",
+        "    return new AutoAnnotation_PathKeyCreator_create(value, relativePath);",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void nestedMapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.Container",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "public interface Container {",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Container.PathKey",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public class Container$PathKeyCreator {",
+            "  @com.google.auto.value.AutoAnnotation",
+            "  public static PathKey create(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container$PathKeyCreator_create(value, relativePath);",
+            "  }",
+            "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDisorderedKeyField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "      Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<PathKey, Provider<Handler>>>",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
+        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDefaultField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<PathKey, Provider<Handler>>>",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
+        "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
+        "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
+        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
new file mode 100644
index 000000000..25762ea94
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -0,0 +1,662 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionTest {
+  @Test
+  public void parentClass_noInjectedMembers() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "public abstract class Parent {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.childProvider =",
+        "        Child_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void parentClass_injectedMembersInSupertype() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public abstract class Parent {",
+        "  @Inject Dep dep;",
+        "}");
+    JavaFileObject depFile = JavaFileObjects.forSourceLines("test.Dep",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class Dep {",
+        "  @Inject Dep() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private MembersInjector<Parent> parentMembersInjector;",
+        "  private MembersInjector<Child> childMembersInjector;",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = Child_Factory.create(childMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass_MembersInjector<A, B>",
+        "    implements MembersInjector<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass_MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(GenericClass<A, B> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "    instance.register(bProvider.get())",
+        "  }",
+        "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void subclassedGenericMembersInjectors() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject a2 = JavaFileObjects.forSourceLines("test.A2",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A2 {",
+        "  @Inject A2() {}",
+        "}");
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Parent<X, Y> {",
+        "  @Inject X x;",
+        "  @Inject Y y;",
+        "  @Inject A2 a2;",
+        "",
+        "  @Inject Parent() {}",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Child<T> extends Parent<T, A> {",
+        "  @Inject A a;",
+        "  @Inject T t;",
+        "",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Child_MembersInjector<T>",
+        "    implements MembersInjector<Child<T>> {",
+        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public Child_MembersInjector(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(Child<T> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.a = aProvider.get();",
+        "    instance.t = tProvider.get();",
+        "  }",
+        "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class FieldInjection_MembersInjector ",
+        "    implements MembersInjector<FieldInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(FieldInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringProvider.get();",
+        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<FieldInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new FieldInjection_MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MethodInjection_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MethodInjection_MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MethodInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.noArgs();",
+        "    instance.oneArg(stringProvider.get());",
+        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
+        "        stringProvider);",
+        "  }",
+        "",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection_MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MixedMemberInjection_MembersInjector ",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<String> stringAndSProvider;",
+        "  private final Provider<Object> objectAndOProvider;",
+        "",
+        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection_MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class AllInjections_MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections_MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "    return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B_MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(",
+        "      MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    return new B_MembersInjector(supertypeInjector, sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
+        "test.OuterType$B_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<A> aProvider;",
+        "",
+        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "  }",
+         "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+        "    return new OuterType$B_MembersInjector(aProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(bMembersInjector);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
new file mode 100644
index 000000000..45791c75c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.InnerClass;
+import javax.inject.Singleton;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+@RunWith(JUnit4.class)
+public class MethodSignatureFormatterTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  static class OuterClass {
+    @interface Foo {
+       Class<?> bar();
+    }
+
+    static class InnerClass {
+      @Foo(bar = String.class)
+      @Singleton
+      String foo(@SuppressWarnings("unused") int a, ImmutableList<Boolean> blah) { return "foo"; }
+    }
+  }
+
+  @Test public void methodSignatureTest() {
+    Elements elements = compilationRule.getElements();
+    TypeElement inner = elements.getTypeElement(InnerClass.class.getCanonicalName());
+    ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
+    String formatted = new MethodSignatureFormatter(compilationRule.getTypes()).format(method);
+    // This is gross, but it turns out that annotation order is not guaranteed when getting
+    // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
+    // less brittle.
+    assertThat(formatted).contains("@Singleton");
+    assertThat(formatted).doesNotContain("@javax.inject.Singleton"); // maybe more importantly
+    assertThat(formatted)
+        .contains("@dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.Foo"
+            + "(bar=String.class)");
+    assertThat(formatted).contains(" String "); // return type compressed
+    assertThat(formatted).contains("int, ImmutableList<Boolean>)"); // parameters compressed.
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
new file mode 100644
index 000000000..0ec5f8083
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -0,0 +1,1068 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+
+@RunWith(JUnit4.class)
+public class ModuleFactoryGeneratorTest {
+
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+  
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
+  // for @Inject
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Provides");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Provides", "Module");
+  }
+
+  @Test public void providesMethodNotInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+  }
+
+  @Test public void providesMethodAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "abstract class TestModule {",
+        "  @Provides abstract String provideString();",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+  }
+
+  @Test public void providesMethodPrivate() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides private String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+  }
+
+  @Test public void providesMethodReturnVoid() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides void provideNothing() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+  }
+
+  @Test public void providesMethodWithTypeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides <T> String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+  }
+
+  @Test public void providesMethodSetValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void providesMethodSetValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void providesMethodSetValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void modulesWithTypeParamsMustBeAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule<A> {}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT);
+  }
+
+  @Test public void provideOverriddenByNoProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void provideOverriddenByProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void providesOverridesNonProvides() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "String test.Parent.foo()"));
+  }
+
+  @Test public void validatesIncludedModules() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = Void.class)",
+        "class TestModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+            "java.lang.Void", "Module"));
+  }
+
+  @Test public void referencedModulesMustNotBeAbstract() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AbstractModule.class)",
+        "class TestModule {}");
+    JavaFileObject abstractModule = JavaFileObjects.forSourceLines("test.AbstractModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class AbstractModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module, abstractModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+            "test.AbstractModule"));
+  }
+
+  @Test public void singleProvidesMethodNoArgs() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    String provided = module.provideString();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule_ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProvidesMethodNoArgs_disableNullable() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule_ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void nullableProvides() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides @Nullable String provideString() { return null; }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  @Nullable",
+        "  public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule_ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test public void multipleProvidesMethods() {
+    JavaFileObject classXFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class X {",
+        "  @Inject public String s;",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Arrays;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides List<Object> provideObjects(",
+        "      @QualifierA Object a, @QualifierB Object b, MembersInjector<X> x) {",
+        "    return Arrays.asList(a, b);",
+        "  }",
+        "",
+        "  @Provides @QualifierA Object provideAObject() {",
+        "    return new Object();",
+        "  }",
+        "",
+        "  @Provides @QualifierB Object provideBObject() {",
+        "    return new Object();",
+        "  }",
+        "}");
+    JavaFileObject listFactoryFile = JavaFileObjects.forSourceLines(
+        "TestModule_ProvideObjectsFactory",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
+        "  private final TestModule module;",
+        "  private final Provider<Object> aProvider;",
+        "  private final Provider<Object> bProvider;",
+        "  private final MembersInjector<X> xMembersInjector;",
+        "",
+        "  public TestModule_ProvideObjectsFactory(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "    assert xMembersInjector != null;",
+        "    this.xMembersInjector = xMembersInjector;",
+        "  }",
+        "",
+        "  @Override public List<Object> get() {",
+        "    List<Object> provided =",
+        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<List<Object>> create(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
+        "    return new TestModule_ProvideObjectsFactory(",
+        "        module, aProvider, bProvider, xMembersInjector);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(
+            ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listFactoryFile);
+  }
+
+  @Test public void providesSetElement() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import java.util.logging.Logger;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET) String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    return Collections.<String>singleton(module.provideString());",
+        "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule_ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void providesSetElementWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import java.util.logging.Logger;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.ArrayList;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET) List<List<?>> provideWildcardList() {",
+        "    return new ArrayList<>();",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines(
+        "TestModule_ProvideWildcardListFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.Collections;",
+        "import java.util.List;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideWildcardListFactory implements "
+            + "Factory<Set<List<List<?>>>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<List<List<?>>> get() {",
+        "    return Collections.<List<List<?>>>singleton(module.provideWildcardList());",
+        "  }",
+        "",
+        "  public static Factory<Set<List<List<?>>>> create(TestModule module) {",
+        "    return new TestModule_ProvideWildcardListFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void providesSetValues() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringsFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule_ProvideStringsFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    Set<String> provided = module.provideStrings();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule_ProvideStringsFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void multipleProvidesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides Object provide(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Provides String provide() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
+        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .in(moduleFile).onLine(12);
+  }
+
+  @Test
+  public void providedTypes() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.io.Closeable;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<String> strings() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<? extends Closeable> closeables() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides String[] stringArray() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides int integer() {",
+        "    return 0;",
+        "  }",
+        "",
+        "  @Provides int[] integers() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  @Module private static final class PrivateModule {",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @Module static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "public final class OtherPublicModule {",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
+  
+  @Test
+  public void genericSubclassedModule() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "import java.util.ArrayList;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A extends CharSequence,",
+        "                            B,",
+        "                            C extends Number & Comparable<C>> {",
+        "  @Provides List<B> provideListB(B b) {",
+        "    List<B> list = new ArrayList<B>();",
+        "    list.add(b);",
+        "    return list;",
+        "  }",
+        "}");
+    JavaFileObject numberChild = JavaFileObjects.forSourceLines("test.ChildNumberModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<String, Number, Double> {",
+        "  @Provides Number provideNumber() { return 1; }",
+        "}");
+    JavaFileObject integerChild = JavaFileObjects.forSourceLines("test.ChildIntegerModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildIntegerModule extends ParentModule<StringBuilder, Integer, Float> {",
+        "  @Provides Integer provideInteger() { return 2; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules={ChildNumberModule.class, ChildIntegerModule.class})",
+        "interface C {",
+        "  List<Number> numberList();",
+        "  List<Integer> integerList();",
+        "}");
+    JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
+        "test.ParentModule_ProvidesListBFactory",
+        "package test;", 
+        "", 
+        "import dagger.internal.Factory;",
+        "import java.util.List;", 
+        "import javax.annotation.Generated;", 
+        "import javax.inject.Provider;", 
+        "", 
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")", 
+        "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
+        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {", 
+        "  private final ParentModule<A, B, C> module;", 
+        "  private final Provider<B> bProvider;", 
+        "", 
+        "  public ParentModule_ProvideListBFactory(",
+        "        ParentModule<A, B, C> module, Provider<B> bProvider) {", 
+        "    assert module != null;", 
+        "    this.module = module;", 
+        "    assert bProvider != null;", 
+        "    this.bProvider = bProvider;", 
+        "  }", 
+        "", 
+        "  @Override", 
+        "  public List<B> get() {  ", 
+        "    List<B> provided = module.provideListB(bProvider.get());",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;", 
+        "  }", 
+        "", 
+        "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+        "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);", 
+        "  }", 
+        "}");
+    JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
+        "test.ChildNumberModule_ProvideNumberFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
+        "  private final ChildNumberModule module;",
+        "",
+        "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Number get() {  ",
+        "    Number provided = module.provideNumber();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Number> create(ChildNumberModule module) {",
+        "    return new ChildNumberModule_ProvideNumberFactory(module);",
+        "  }",
+        "}");
+    JavaFileObject integerFactory = JavaFileObjects.forSourceLines(
+        "test.ChildIntegerModule_ProvideIntegerFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildIntegerModule_ProvideIntegerFactory",
+        "    implements Factory<Integer> {",
+        "  private final ChildIntegerModule module;",
+        "",
+        "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer get() {  ",
+        "    Integer provided = module.provideInteger();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Integer> create(ChildIntegerModule module) {",
+        "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listBFactory, numberFactory, integerFactory);
+  }
+
+  @Test public void providesMethodMultipleQualifiers() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import javax.annotation.Nullable;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides @QualifierA @QualifierB String provideString() {",
+        "    return \"foo\";",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
new file mode 100644
index 000000000..27e720d01
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MultipleRequestTest {
+  private static final JavaFileObject DEP_FILE = JavaFileObjects.forSourceLines("test.Dep",
+      "package test;",
+      "",
+      "import javax.inject.Inject;",
+      "",
+      "class Dep {",
+      "  @Inject Dep() {}",
+      "}");
+
+  @Test public void multipleRequests_constructor() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.ConstructorInjectsMultiple",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "class ConstructorInjectsMultiple {",
+                "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  ConstructorInjectsMultiple get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void multipleRequests_field() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "class FieldInjectsMultiple {",
+                "  @Inject Dep d1;",
+                "  @Inject Dep d2;",
+                "  @Inject FieldInjectsMultiple() {}",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  FieldInjectsMultiple get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void multipleRequests_providesMethod() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "class SimpleModule {",
+                "  @Provides Object provide(Dep d1, Dep d2) {",
+                "    return null;",
+                "  }",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component(modules = SimpleModule.class)",
+                "interface SimpleComponent {",
+                "  Object get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
new file mode 100644
index 000000000..40ceb7ede
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -0,0 +1,255 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class PackageProxyTest {
+  @Test public void basicPackageProxy() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class PublicClass {",
+        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
+        "}");
+    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass1 {",
+        "  @Inject NonPublicClass1(NoDepClass dep) {}",
+        "}");
+    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass2 {",
+        "  @Inject NonPublicClass2(NoDepClass dep) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import foreign.PublicClass;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  PublicClass publicClass();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import foreign.DaggerTestComponent_PackageProxy;",
+        "import foreign.NoDepClass_Factory;",
+        "import foreign.NonPublicClass1_Factory;",
+        "import foreign.NonPublicClass2_Factory;",
+        "import foreign.PublicClass;",
+        "import foreign.PublicClass_Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
+        "      new DaggerTestComponent_PackageProxy();",
+        "  private Provider<PublicClass> publicClassProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.foreign_Proxy.nonPublicClass1Provider =",
+        "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
+        "    this.foreign_Proxy.nonPublicClass2Provider =",
+        "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
+        "    this.publicClassProvider = PublicClass_Factory.create(",
+        "        foreign_Proxy.nonPublicClass1Provider,",
+        "        foreign_Proxy.nonPublicClass2Provider,",
+        "        NoDepClass_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public PublicClass publicClass() {",
+        "    return publicClassProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            noDepClassFile,
+            publicClassFile,
+            nonPublicClass1File,
+            nonPublicClass2File,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void memberInjectionPackageProxy() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import foreign.B;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A extends B {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
+        "package foreign;",
+        "",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "public class B extends C {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
+        "package foreign;",
+        "",
+        "import test.D;",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "class C extends D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public class D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  void injectA(A a);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import foreign.B;",
+        "import foreign.B_MembersInjector;",
+        "import foreign.C_MembersInjector;",
+        "import foreign.DaggerTestComponent_PackageProxy;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private MembersInjector<D> dMembersInjector;",
+        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
+        "      new DaggerTestComponent_PackageProxy();",
+        "  private MembersInjector<B> bMembersInjector;",
+        "  private MembersInjector<A> aMembersInjector;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
+        "    this.foreign_Proxy.cMembersInjector =",
+        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
+        "    this.bMembersInjector = B_MembersInjector.create(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
+        "    this.aMembersInjector = A_MembersInjector.create(",
+        "        bMembersInjector, NoDepClass_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectA(A a) {",
+        "    aMembersInjector.injectMembers(a);",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            noDepClassFile,
+            aClassFile,
+            bClassFile,
+            cClassFile,
+            dClassFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
new file mode 100644
index 000000000..9e209bb00
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -0,0 +1,1171 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
+
+@RunWith(JUnit4.class)
+public class ProducerModuleFactoryGeneratorTest {
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Produces");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Produces", "ProducerModule");
+  }
+
+  @Test public void producesMethodNotInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produces;",
+        "",
+        "final class TestModule {",
+        "  @Produces String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+  }
+
+  @Test public void producesMethodAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "abstract class TestModule {",
+        "  @Produces abstract String produceString();",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+  }
+
+  @Test public void producesMethodPrivate() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces private String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+  }
+
+  @Test public void producesMethodReturnVoid() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces void produceNothing() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+  }
+
+  @Test public void producesMethodReturnRawFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RAW_FUTURE);
+  }
+
+  @Test public void producesMethodReturnWildcardFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<?> produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodWithTypeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces <T> String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+  }
+
+  @Test public void producesMethodSetValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set<?> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) List<String> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void producesMethodSetValuesWildcardInFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set<?>> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesFutureRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set> produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesFutureNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<List<String>> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void multipleProducesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces Object produce(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Produces String produce() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
+        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+  }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  @ProducerModule private static final class PrivateModule {",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @ProducerModule static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "public final class OtherPublicModule {",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
+
+  @Test public void singleProducesMethodNoArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+        "      new Callable<ListenableFuture<String>>() {",
+        "        @Override public ListenableFuture<String> call() {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  ListenableFuture<String> produceString() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
+        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
+        "      @Override public ListenableFuture<Set<String>> call() {",
+        "        return Producers.createFutureSingletonSet(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<String> future = Producers.submitToExecutor(",
+        "      new Callable<String>() {",
+        "        @Override public String call() {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsNoFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.collect.ImmutableSet;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<Set<String>> future =",
+        "        Producers.submitToExecutor(new Callable<Set<String>>() {",
+        "      @Override public Set<String> call() {",
+        "        return ImmutableSet.of(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule_ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
+        "            return module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodArgsNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule_ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
+        "            return Futures.immediateFuture(module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider));",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodSingleArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(int a) {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "",
+        "  public TestModule_ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    return Futures.transform(aProducerFuture,",
+        "        new AsyncFunction<Integer, String>() {",
+        "          @Override public ListenableFuture<String> apply(Integer a) {",
+        "            return module.produceString(a);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedException() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString()",
+        "      throws InterruptedException, IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+        "      new Callable<ListenableFuture<String>>() {",
+        "        @Override public ListenableFuture<String> call()",
+        "            throws InterruptedException, IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString() throws IOException {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<String> future = Producers.submitToExecutor(",
+        "      new Callable<String>() {",
+        "        @Override public String call() throws IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
+        "          throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule_ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args)",
+        "              throws IOException {",
+        "            return module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  ListenableFuture<String> produceString() throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule_ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
+        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
+        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
+        "        return Producers.createFutureSingletonSet(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test public void producesMethodMultipleQualifiers() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces @QualifierA @QualifierB abstract String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
new file mode 100644
index 000000000..b5ebd972b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(JUnit4.class)
+public class ProductionComponentProcessorTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "final class NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "@interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent(modules = Object.class)",
+        "interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is not annotated with @Module or @ProducerModule");
+  }
+
+  @Test public void simpleComponent() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static final class C {",
+        "    @Inject C() {}",
+        "  }",
+        "",
+        "  interface A {}",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static final class BModule {",
+        "    @Provides B b(C c) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class AModule {",
+        "    @Produces ListenableFuture<A> a(B b) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestClass_SimpleComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestClass.A;",
+        "import test.TestClass.AModule;",
+        "import test.TestClass.B;",
+        "import test.TestClass.BModule;",
+        "import test.TestClass.SimpleComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+        "  private Provider<B> bProvider;",
+        "  private Producer<A> aProducer;",
+        "",
+        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.bProvider = TestClass$BModule_BFactory.create(",
+        "        builder.bModule, TestClass$C_Factory.create());",
+        "    this.aProducer = new TestClass$AModule_AFactory(",
+        "        builder.aModule, builder.executor, Producers.producerFromProvider(bProvider));",
+        "  }",
+        "",
+        "  @Override",
+        "  public ListenableFuture<A> a() {",
+        "    return aProducer.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AModule aModule;",
+        "    private BModule bModule;",
+        "    private Executor executor;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      if (aModule == null) {",
+        "        this.aModule = new AModule();",
+        "      }",
+        "      if (bModule == null) {",
+        "        this.bModule = new BModule();",
+        "      }",
+        "      if (executor == null) {",
+        "        throw new IllegalStateException(\"executor must be set\");",
+        "      }",
+        "      return new DaggerTestClass_SimpleComponent(this);",
+        "    }",
+        "",
+        "    public Builder aModule(AModule aModule) {",
+        "      if (aModule == null) {",
+        "        throw new NullPointerException(\"aModule\");",
+        "      }",
+        "      this.aModule = aModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder bModule(BModule bModule) {",
+        "      if (bModule == null) {",
+        "        throw new NullPointerException(\"bModule\");",
+        "      }",
+        "      this.bModule = bModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder executor(Executor executor) {",
+        "      if (executor == null) {",
+        "        throw new NullPointerException(\"executor\");",
+        "      }",
+        "      this.executor = executor;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
new file mode 100644
index 000000000..9f577b722
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/**
+ * Unit tests for {@link BindingGraphValidator} that exercise producer-specific logic.
+ */
+@RunWith(JUnit4.class)
+public class ProductionGraphValidationTest {
+  @Test public void componentWithUnprovidedInput() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent(modules = FooModule.class)",
+        "interface MyComponent {",
+        "  ListenableFuture<Foo> getFoo();",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.FooModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "class Foo {}",
+        "class Bar {}",
+        "",
+        "@ProducerModule",
+        "class FooModule {",
+        "  @Produces Foo foo(Bar bar) {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(Arrays.asList(module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Inject constructor or from "
+            + "an @Provides- or @Produces-annotated method.")
+            .in(component).onLine(8);
+  }
+
+  @Test public void componentProductionWithNoDependencyChain() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @ProductionComponent()",
+        "  interface AComponent {",
+        "    ListenableFuture<A> getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(11);
+  }
+
+  @Test public void provisionDependsOnProduction() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  final class AModule {",
+        "    @Provides A a(B b) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  final class BModule {",
+        "    @Produces ListenableFuture<B> b() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  interface AComponent {",
+        "    ListenableFuture<A> getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A is a provision, which cannot depend on a production.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void provisionEntryPointDependsOnProduction() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @ProducerModule",
+        "  final class AModule {",
+        "    @Produces ListenableFuture<A> a() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = AModule.class)",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(20);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
new file mode 100644
index 000000000..6311a90ca
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** Tests for {@link dagger.Subcomponent.Builder} validation. */
+@RunWith(JUnit4.class)
+public class SubcomponentBuilderValidationTest {
+  
+  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
+      new ErrorMessages.SubcomponentBuilderMessages();
+  
+  @Test
+  public void testRefSubcomponentAndSubBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent child();",
+        "  ChildComponent.Builder builder();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[child(), builder()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testRefSubBuilderTwiceFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder1();",
+        "  ChildComponent.Builder builder2();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[builder1(), builder2()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder1 {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  static interface Builder2 {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder<T> {",
+        "     ChildComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(childComponentFile).onLine(9);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(10)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(8);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    ChildComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.ChildComponent.Builder.set1(String),"
+                  + " void test.ChildComponent.Builder.set2(Integer)]"))
+            .in(childComponentFile).onLine(8);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
+        "interface ChildComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile,
+            module2File,
+            module3File,
+            componentFile,
+            childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
+            .in(childComponentFile).onLine(11);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
new file mode 100644
index 000000000..91035b291
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentValidationTest {
+  @Test public void factoryMethod_missingModulesWithParameters() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ModuleWithParameters.class)",
+        "interface ChildComponent {}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class ModuleWithParameters {",
+        "  ModuleWithParameters(Object whatever) {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.ChildComponent requires modules which have no visible default constructors. "
+                + "Add the following modules as parameters to this method: "
+                + "test.ModuleWithParameters")
+        .in(componentFile).onLine(7);
+  }
+
+  @Test public void factoryMethod_nonModuleParameter() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(String someRandomString);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
+        .in(componentFile).onLine(7).atColumn(43);
+  }
+
+  @Test public void factoryMethod_duplicateParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "A module may only occur once an an argument in a Subcomponent factory method, "
+                + "but test.TestModule was already passed.")
+        .in(componentFile).onLine(7).atColumn(71);
+  }
+
+  @Test public void factoryMethod_superflouousModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(
+        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
+            + "is not one of the modules used to implement the subcomponent.")
+                .in(componentFile).onLine(7);
+  }
+
+  @Test public void missingBinding() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(int i) {",
+        "    return Integer.toString(i);",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {",
+        "  String getString();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method");
+  }
+
+  @Test public void subcomponentOnConcreteType() {
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.NotASubcomponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "final class NotASubcomponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void scopeMismatch() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component",
+        "@Singleton",
+        "interface ParentComponent {",
+        "  ChildComponent childComponent();",
+        "}");
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ChildModule.class)",
+        "interface ChildComponent {",
+        "  Object getObject();",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "final class ChildModule {",
+        "  @Provides @Singleton Object provideObject() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Singleton");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
new file mode 100644
index 000000000..acf895e74
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;
+import java.util.Map;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class ClassNameTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  @Test public void bestGuessForString_simpleClass() {
+    assertThat(ClassName.bestGuessFromString(String.class.getName()))
+        .isEqualTo(ClassName.create("java.lang", "String"));
+  }
+
+  static class OuterClass {
+    static class InnerClass {}
+  }
+
+  @Test public void bestGuessForString_nestedClass() {
+    assertThat(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
+        .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
+    assertThat(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
+        .isEqualTo(
+            ClassName.create("dagger.internal.codegen.writer",
+                ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
+  }
+
+  @Test public void bestGuessForString_defaultPackage() {
+    assertThat(ClassName.bestGuessFromString("SomeClass"))
+        .isEqualTo(ClassName.create("", "SomeClass"));
+    assertThat(ClassName.bestGuessFromString("SomeClass.Nested"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
+    assertThat(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
+  }
+
+  @Test public void bestGuessForString_confusingInput() {
+    try {
+      ClassName.bestGuessFromString("com.test.$");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("com.test.LooksLikeAClass.pkg");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("!@#$gibberish%^&*");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+
+  @Test public void classNameFromTypeElement() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
+    assertThat(ClassName.fromTypeElement(element).canonicalName())
+        .isEqualTo("java.lang.Object");
+  }
+
+  @Test public void peerNamed_topLevelClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    assertThat(peerName.canonicalName())
+        .isEqualTo("dagger.internal.codegen.writer.Foo");
+  }
+
+  @Test public void peerNamed_nestedClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    assertThat(peerName.canonicalName())
+        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.Foo");
+  }
+
+  @Test public void peerNamed_deeplyNestedClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    assertThat(peerName.canonicalName())
+        .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo");
+  }
+
+  @Test public void fromClass_NonNestedClass() {
+    ClassName className = ClassName.fromClass(ClassNameTest.class);
+    assertThat(className.canonicalName()).isEqualTo(
+        "dagger.internal.codegen.writer.ClassNameTest");
+  }
+
+  @Test public void fromClass_NestedClass() {
+    ClassName className = ClassName.fromClass(InnerClass.class);
+    assertThat(className.canonicalName()).isEqualTo(
+        "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
new file mode 100644
index 000000000..e775f7487
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class JavaWriterTest {
+  @Test public void referencedAndDeclaredSimpleName() {
+    JavaWriter javaWriter = JavaWriter.inPackage("test");
+    ClassWriter topClass = javaWriter.addClass("Top");
+    topClass.addNestedClass("Middle").addNestedClass("Bottom");
+    topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
+    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
new file mode 100644
index 000000000..ec82e9605
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import com.google.testing.compile.CompilationRule;
+import java.nio.charset.Charset;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class TypeNamesTest {
+  @Rule public final CompilationRule compilation = new CompilationRule();
+
+  private TypeElement getElement(Class<?> clazz) {
+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
+  }
+
+  private TypeMirror getType(Class<?> clazz) {
+    return getElement(clazz).asType();
+  }
+
+  @Test
+  public void forTypeMirror_basicTypes() {
+    assertThat(TypeNames.forTypeMirror(getType(Object.class)))
+        .isEqualTo(ClassName.fromClass(Object.class));
+    assertThat(TypeNames.forTypeMirror(getType(Charset.class)))
+        .isEqualTo(ClassName.fromClass(Charset.class));
+    assertThat(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
+  }
+
+  @Test
+  public void forTypeMirror_parameterizedType() {
+    DeclaredType setType =
+        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
+    assertThat(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_typeVariables() {
+    TypeMirror setType = getType(Set.class);
+    assertThat(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, TypeVariableName.named("E")));
+  }
+
+  @Test
+  public void forTypeMirror_primitive() {
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+        .isEqualTo(PrimitiveName.BOOLEAN);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+        .isEqualTo(PrimitiveName.BYTE);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+        .isEqualTo(PrimitiveName.SHORT);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+        .isEqualTo(PrimitiveName.INT);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+        .isEqualTo(PrimitiveName.LONG);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+        .isEqualTo(PrimitiveName.CHAR);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+        .isEqualTo(PrimitiveName.FLOAT);
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+        .isEqualTo(PrimitiveName.DOUBLE);
+  }
+
+  @Test
+  public void forTypeMirror_arrays() {
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_void() {
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+        .isEqualTo(VoidName.VOID);
+  }
+
+  @Test
+  public void forTypeMirror_null() {
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+        .isEqualTo(NullName.NULL);
+  }
+}
diff --git a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
deleted file mode 100644
index 61060617c..000000000
--- a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.testing.it;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.nio.MappedByteBuffer;
-import java.nio.channels.FileChannel;
-import java.nio.charset.Charset;
-
-public class BuildLogValidator {
-
-  /**
-   * Processes a log file, ensuring it has all the provided strings within it.
-   *
-   * @param buildLogfile a log file to be searched
-   * @param expectedStrings the strings that must be present in the log file for it to be valid
-   */
-  public void assertHasText(File buildLogfile, String ... expectedStrings) throws Throwable {
-    String buildOutput;
-    FileInputStream stream = new FileInputStream(buildLogfile);
-    try {
-      FileChannel fc = stream.getChannel();
-      MappedByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
-      buildOutput = Charset.defaultCharset().decode(buf).toString();
-    } finally {
-      stream.close();
-    }
-    if (buildOutput == null) {
-      throw new Exception("Could not read build output");
-    }
-
-    StringBuilder sb = new StringBuilder("Build output did not contain expected error text:");
-    boolean missing = false;
-
-    for (String expected : expectedStrings) {
-      if (!buildOutput.contains(expected)) {
-        missing = true;
-        sb.append("\n    \"").append(expected).append("\"");
-      }
-    }
-    if (missing) {
-      sb.append("\n\nBuild Output:\n\n");
-      boolean containsError = false;
-      for(String line : buildOutput.split("\n")) {
-        if (line.contains("[ERROR]")) {
-          containsError = true;
-          sb.append("\n        ").append(line);
-        }
-      }
-      if (!containsError) {
-        sb.append("\nTEST BUILD SUCCEEDED.\n");
-      }
-      throw new Exception(sb.toString());
-    }
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
new file mode 100644
index 000000000..349b2feee
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -0,0 +1,142 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public final class PrimitiveInjectionTest {
+
+  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
+  /*
+  JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
+      "package test;",
+      "import javax.inject.Qualifier;",
+      "@Qualifier",
+      "public @interface ForTest {",
+      "}");
+  */
+
+  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
+  JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
+      "package test;",
+      "import javax.inject.Inject;",
+      "class PrimitiveInjectable {",
+      "  @Inject PrimitiveInjectable(int ignored) {}",
+      "}");
+
+  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
+      "package test;",
+      "import dagger.Module;",
+      "import dagger.Provides;",
+      "@Module",
+      "class PrimitiveModule {",
+      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
+      "}");
+
+  JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
+      "package test;",
+      "import dagger.Component;",
+      "import dagger.Provides;",
+      "@Component(modules = PrimitiveModule.class)",
+      "interface PrimitiveComponent {",
+      "  int primitiveInt();",
+      "  PrimitiveInjectable primitiveInjectable();",
+      "}");
+
+  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
+      "test.DaggerPrimitiveComponent",
+      "package test;",
+      "",
+      "import javax.annotation.Generated;",
+      "import javax.inject.Provider;",
+      "",
+      "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+      "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
+      "  private Provider<Integer> primitiveIntProvider;",
+      "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+      "",
+      "  private DaggerPrimitiveComponent(Builder builder) {",
+      "    assert builder != null;",
+      "    initialize(builder);",
+      "  }",
+      "",
+      "  public static Builder builder() {",
+      "    return new Builder();",
+      "  }",
+      "",
+      "  public static PrimitiveComponent create() {",
+      "    return builder().build();",
+      "  }",
+      "",
+      "  private void initialize(final Builder builder) {",
+      "    this.primitiveIntProvider =",
+      "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
+      "    this.primitiveInjectableProvider =",
+      "        PrimitiveInjectable_Factory.create(primitiveIntProvider);",
+      "  }",
+      "",
+      "  @Override",
+      "  public int primitiveInt() {",
+      "    return primitiveIntProvider.get();",
+      "  }",
+      "",
+      "  @Override",
+      "  public PrimitiveInjectable primitiveInjectable() {",
+      "    return primitiveInjectableProvider.get();",
+      "  }",
+      "",
+      "  public static final class Builder {",
+      "    private PrimitiveModule primitiveModule;",
+      "",
+      "    private Builder() {",
+      "    }",
+      "",
+      "    public PrimitiveComponent build() {",
+      "      if (primitiveModule == null) {",
+      "        this.primitiveModule = new PrimitiveModule();",
+      "      }",
+      "      return new DaggerPrimitiveComponent(this);",
+      "    }",
+      "",
+      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+      "      if (primitiveModule == null) {",
+      "        throw new NullPointerException(\"primitiveModule\");",
+      "      }",
+      "      this.primitiveModule = primitiveModule;",
+      "      return this;",
+      "    }",
+      "  }",
+      "}");
+
+  @Test public void primitiveArrayTypesAllInjected() {
+    assert_().about(javaSources())
+        .that(asList(component, primitiveInjectable, primitiveModule))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedComponent);
+  }
+}
diff --git a/core/pom.xml b/core/pom.xml
index 209c49a82..eab9dd8b5 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -18,31 +18,78 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
+    <version>2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
-  <packaging>jar</packaging>
   <name>Dagger</name>
 
+  <properties>
+    <!-- Runtime must remain Java6 to support android. -->
+    <java.version>1.6</java.version>
+  </properties>
+
   <dependencies>
     <dependency>
       <groupId>javax.inject</groupId>
       <artifactId>javax.inject</artifactId>
     </dependency>
 
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.8</version><!-- 1.9+ requires JDK7 on the build machine -->
+        <executions>
+          <execution>
+            <id>sniff-api</id>
+            <goals><goal>check</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>test-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
new file mode 100644
index 000000000..7d724017e
--- /dev/null
+++ b/core/src/main/java/dagger/Component.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.inject.Singleton;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @Component} prepended with {@code Dagger}. For
+ * example, {@code @Component interface MyComponent {...}} will produce an implementation named
+ * {@code DaggerMyComponent}.
+ *
+ * <a name="component-methods">
+ * <h2>Component methods</h2>
+ * </a>
+ *
+ * <p>Every type annotated with {@code @Component} must contain at least one abstract component
+ * method. Component methods may have any name, but must have signatures that conform to either
+ * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts.
+ *
+ * <a name="provision-methods">
+ * <h3>Provision methods</h3>
+ * </a>
+ *
+ * <p>Provision methods have no parameters and return an {@link Inject injected} or
+ * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The
+ * following are all valid provision method declarations: <pre><code>
+ *   SomeType getSomeType();
+ *   {@literal Set<SomeType>} getSomeTypes();
+ *   {@literal @PortNumber} int getPortNumber();
+ * </code></pre>
+ *
+ * <p>Provision methods, like typical {@link Inject injection} sites, may use {@link Provider} or
+ * {@link Lazy} to more explicitly control provision requests. A {@link Provider} allows the user
+ * of the component to request provision any number of times by calling {@link Provider#get}. A
+ * {@link Lazy} will only ever request a single provision, but will defer it until the first call to
+ * {@link Lazy#get}. The following provision methods all request provision of the same type, but
+ * each implies different semantics: <pre><code>
+ *   SomeType getSomeType();
+ *   {@literal Provider<SomeType>} getSomeTypeProvider();
+ *   {@literal Lazy<SomeType>} getLazySomeType();
+ * </code></pre>
+ *
+ * <a name="members-injection-methods">
+ * <h3>Members-injection methods</h3>
+ * </a>
+ *
+ * <p>Members-injection methods have a single parameter and inject dependencies into each of the
+ * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method
+ * may be void or return its single parameter as a convenience for chaining. The following are all
+ * valid members-injection method declarations: <pre><code>
+ *   void injectSomeType(SomeType someType);
+ *   SomeType injectAndReturnSomeType(SomeType someType);
+ * </code></pre>
+ *
+ * <p>A method with no parameters that returns a {@link MembersInjector} is equivalent to a members
+ * injection method. Calling {@link MembersInjector#injectMembers} on the returned object will
+ * perform the same work as a members injection method. For example: <pre><code>
+ *   {@literal MembersInjector<SomeType>} getSomeTypeMembersInjector();
+ * </code></pre>
+ *
+ * <h4>A note about covariance</h4>
+ *
+ * <p>While a members-injection method for a type will accept instances of its subtypes, only
+ * {@link Inject}-annotated members of the parameter type and its supertypes will be injected;
+ * members of subtypes will not. For example, given the following types, only {@code a} and
+ * {@code b} will be injected into an instance of {@code Child} when it is passed to the
+ * members-injection method {@code injectSelf(Self instance)}: <pre><code>
+ *   class Parent {
+ *     {@literal @}Inject A a;
+ *   }
+ *
+ *   class Self extends Parent {
+ *     {@literal @}Inject B b;
+ *   }
+ *
+ *   class Child extends Self {
+ *     {@literal @}Inject C c;
+ *   }
+ * </code></pre>
+ *
+ * <a name="instantiation">
+ * <h2>Instantiation</h2>
+ * </a>
+ *
+ * <p>Component implementations are primarily instantiated via a generated
+ * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
+ * is obtained using the {@code builder()} method on the component implementation.
+ * If a nested {@code @Component.Builder} type exists in the component, the {@code builder()}
+ * method will return a generated implementation of that type.  If no nested
+ * {@code @Component.Builder} exists, the returned builder has a method to set each of the
+ * {@linkplain #modules} and component {@linkplain #dependencies} named with the
+ * <a href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module
+ * or dependency type. Each component dependency and module without a visible default constructor
+ * must be set explicitly, but any module with a default or no-args constructor accessible to the
+ * component implementation may be elided. This is an example usage of a component builder:
+ * <pre><code>
+ *   public static void main(String[] args) {
+ *     OtherComponent otherComponent = ...;
+ *     MyComponent component = DaggerMyComponent.builder()
+ *         // required because component dependencies must be set
+ *         .otherComponent(otherComponent)
+ *         // required because FlagsModule has constructor parameters
+ *         .flagsModule(new FlagsModule(args))
+ *         // may be elided because a no-args constructor is visible
+ *         .myApplicationModule(new MyApplicationModule())
+ *         .build();
+ *   }
+ * </code></pre>
+ *
+ * <p>In the case that a component has no component dependencies and only no-arg modules, the
+ * generated component will also have a factory method {@code create()}.
+ * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
+ * equivalent.
+ *
+ * <a name="scope">
+ * <h2>Scope</h2>
+ * </a>
+ *
+ * <p>Each Dagger component can be associated with a scope by annotating it with the
+ * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one
+ * provision of each scoped binding per instance of the component. If the component declares a
+ * scope, it may only contain unscoped bindings or bindings of that scope anywhere in the graph. For
+ * example: <pre><code>
+ *   {@literal @}Singleton {@literal @}Component
+ *   interface MyApplicationComponent {
+ *     // this component can only inject types using unscoped or {@literal @}Singleton bindings
+ *   }
+ * </code></pre>
+ *
+ * <p>In order to get the proper behavior associated with a scope annotation, it is the caller's
+ * responsibility to instantiate new component instances when appropriate. A {@link Singleton}
+ * component, for instance, should only be instantiated once per application, while a
+ * {@code RequestScoped} component should be instantiated once per request. Because components are
+ * self-contained implementations, exiting a scope is as simple as dropping all references to the
+ * component instance.
+ *
+ * <a name="component-relationships">
+ * <h2>Component relationships</h2>
+ * </a>
+ *
+ * <p>While there is much utility in isolated components with purely unscoped bindings, many
+ * applications will call for multiple components with multiple scopes to interact. Dagger provides
+ * two mechanisms for relating components.
+ *
+ * <a name="subcomponents">
+ * <h3>Subcomponents</h3>
+ * </a>
+ *
+ * <p>The simplest way to relate two components is by declaring a {@link Subcomponent}. A
+ * subcomponent behaves exactly like a component, but has its implementation generated within
+ * a parent component or subcomponent. That relationship allows the subcomponent implementation to
+ * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason,
+ * a subcomponent isn't evaluated for completeness until it is associated with a parent.
+ *
+ * <p>Subcomponents are declared via a factory method on a parent component or subcomponent. The
+ * method may have any name, but must return the subcomponent. The factory method's parameters may
+ * be any number of the subcomponent's modules, but must at least include those without visible
+ * no-arg constructors. The following is an example of a factory method that creates a
+ * request-scoped subcomponent from a singleton-scoped parent: <pre><code>
+ *   {@literal @}Singleton {@literal @}Component
+ *   interface ApplicationComponent {
+ *     // component methods...
+ *
+ *     RequestComponent newRequestComponent(RequestModule requestModule);
+ *   }
+ * </code></pre>
+ *
+ * <a name="component-dependencies">
+ * <h3>Component dependencies</h3>
+ * </a>
+ *
+ * <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
+ * tightly coupled with the parents; they may use any binding defined by their ancestor component
+ * and subcomponents. As an alternative, components can use bindings only from another
+ * <em>component interface</em> by declaring a {@linkplain #dependencies component dependency}. When
+ * a type is used as a component dependency, each <a href="#provision-methods">provision method</a>
+ * on the dependency is bound as a provider. Note that <em>only</em> the bindings exposed as
+ * provision methods are available through component dependencies.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
+@Target(TYPE)
+@Documented
+public @interface Component {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * component implementation. Note that through the use of {@link Module#includes} the full set of
+   * modules used to implement the component may include more modules that just those listed here.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as <a href="#component-dependencies">component
+   * dependencies</a>.
+   */
+  Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @Component.Builder}.  If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the Builder type, or a supertype of the builder.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (e.g, the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   * 
+   * For example, this could be a valid Component with a Builder: <pre><code>
+   * {@literal @}Component(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   MyWidget myWidget();
+   *   
+   *   {@literal @}Component.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
+}
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 6b064661c..59419abd3 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -21,6 +21,10 @@
  * the first call to {@code get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
+ * <p>{@code null} is not a supported value.  Implementations of {@code Lazy}
+ * are expected to throw {@link NullPointerException} if the computed value is
+ * {@code null}.
+ *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
@@ -148,6 +152,8 @@
   /**
    * Return the underlying value, computing the value if necessary. All calls to
    * the same {@code Lazy} instance will return the same result.
+   *
+   * @throws NullPointerException if the computed value is {@code null}.
    */
   T get();
 }
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
new file mode 100644
index 000000000..fcde154ce
--- /dev/null
+++ b/core/src/main/java/dagger/MapKey.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Identifies annotation types that are used to associate keys with values returned by
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides#Type#MAP map}.
+ *
+ * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
+ * annotation that identifies the key for that map entry. That annotation's type must be annotated
+ * with {@code @MapKey}.
+ *
+ * <p>Typically, the key annotation has a single member element, whose value is used as the map key.
+ *
+ * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
+ * an annotation called {@code @StringKey}:
+ *
+ * <pre><code>
+ * {@literal @}MapKey
+ * {@literal @}interface StringKey {
+ *   String value();
+ * }
+ *
+ * {@literal @}Module
+ * class SomeModule {
+ *   {@literal @}Provides(type = MAP)
+ *   {@literal @}StringKey("foo")
+ *   Integer provideFooValue() {
+ *     return 2;
+ *   }
+ * }
+ *
+ * class SomeInjectedType {
+ *   {@literal @}Inject
+ *   SomeInjectedType(Map<String, Integer> map) {
+ *     assert map.get("foo") == 2;
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <p><b>Note:</b> Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed,
+ * if {@code unwrapValue} is true, the annotation's single element must be a {@code String} or
+ * enumerated type.
+ *
+ * <h2>Annotations as keys</h2>
+ *
+ * <p>If {@link #unwrapValue} is false, then the annotation itself is used as the map key. For
+ * example, to add an entry to a {@code Map<MyMapKey, Integer>} map:
+ *
+ * <pre><code>
+ * {@literal @}MapKey(unwrapValue = false)
+ * {@literal @}interface MyMapKey {
+ *   String someString();
+ *   MyEnum someEnum();
+ * }
+ *
+ * {@literal @}Module
+ * class SomeModule {
+ *   {@literal @}Provides(type = MAP)
+ *   {@literal @}MyMapKey(someString = "foo", someEnum = BAR)
+ *   Integer provideFooBarValue() {
+ *     return 2;
+ *   }
+ * }
+ *
+ * class SomeInjectedType {
+ *   {@literal @}Inject
+ *   SomeInjectedType(Map<MyMapKey, Integer> map) {
+ *     assert map.get(new MyMapKeyImpl("foo", MyEnum.BAR)) == 2;
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
+ * order to call {@link Map#get()} on the provided map.)
+ */
+@Documented
+@Target(ANNOTATION_TYPE)
+@Retention(RUNTIME)
+@Beta
+public @interface MapKey {
+  /**
+   * True to use the value of the single element of the annotated annotation as the map key; false
+   * to use the annotation instance as the map key.
+   *
+   * <p>Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed, if true
+   * the single element must be a {@code String} or an enumerated type.
+   */
+  boolean unwrapValue() default true;
+}
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index 372c9f585..d0de7f396 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -17,26 +17,28 @@
 package dagger;
 
 /**
- * Injects dependencies into the fields and methods on instances of type
- * {@code T}. Ignores the presence or absence of an injectable constructor.
+ * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
+ * presence or absence of an injectable constructor.
  *
  * @param <T> type to inject members of
  *
  * @author Bob Lee
  * @author Jesse Wilson
+ * @since 2.0 (since 1.0 without the provision that {@link #injectMembers} cannot accept
+ *      {@code null})
  */
 public interface MembersInjector<T> {
 
   /**
-   * Injects dependencies into the fields and methods of {@code instance}.
-   * Ignores the presence or absence of an injectable constructor.
+   * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
+   * absence of an injectable constructor.
    *
-   * <p>Whenever the object graph creates an instance, it performs this
-   * injection automatically (after first performing constructor injection), so
-   * if you're able to let the object graph create all your objects for you,
-   * you'll never need to use this method.
+   * <p>Whenever the object graph creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the object graph
+   * create all your objects for you, you'll never need to use this method.
    *
-   * @param instance to inject members on. May be {@code null}.
+   * @param instance into which members are to be injected
+   * @throws NullPointerException if {@code instance} is {@code null}
    */
   void injectMembers(T instance);
 }
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 075210db9..05f0f3a6a 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -26,38 +26,11 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 public @interface Module {
-  Class<?>[] entryPoints() default { };
-  Class<?>[] staticInjections() default { };
-
-  /**
-   * True if {@code @Provides} methods from this module are permitted to
-   * override those of other modules. This is a dangerous feature as it permits
-   * binding conflicts to go unnoticed. It should only be used in test and
-   * development modules.
-   */
-  boolean overrides() default false;
-
   /**
    * Additional {@code @Module}-annotated classes from which this module is
    * composed. The de-duplicated contributions of the modules in
    * {@code includes}, and of their inclusions recursively, are all contributed
    * to the object graph.
    */
-  Class<?>[] includes() default { };
-
-  /**
-   * An optional {@code @Module}-annotated class upon which this module can be
-   * {@link ObjectGraph#plus added} to form a complete graph.
-   */
-  Class<?> addsTo() default Void.class;
-
-  /**
-   * True if all of the bindings required by this module can also be satisfied
-   * by this module, its {@link #includes} and its {@link #addsTo}. If a module
-   * is complete it is eligible for additional static checking: tools can detect
-   * if required bindings are not available. Modules that have external
-   * dependencies must use {@code complete = false}.
-   */
-  boolean complete() default true;
-
+  Class<?>[] includes() default {};
 }
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
deleted file mode 100644
index 6bb906d2b..000000000
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
-import dagger.internal.ProblemDetector;
-import dagger.internal.RuntimeAggregatingPlugin;
-import dagger.internal.StaticInjection;
-import dagger.internal.ThrowingErrorHandler;
-import dagger.internal.UniqueMap;
-import dagger.internal.plugins.loading.ClassloadingPlugin;
-import dagger.internal.plugins.reflect.ReflectivePlugin;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import static dagger.internal.RuntimeAggregatingPlugin.getAllModuleAdapters;
-
-/**
- * A graph of objects linked by their dependencies.
- *
- * <p>The following injection features are supported:
- * <ul>
- *   <li>Field injection. A class may have any number of field injections, and
- *       fields may be of any visibility. Static fields will be injected each
- *       time an instance is injected.
- *   <li>Constructor injection. A class may have a single
- *       {@code @Inject}-annotated constructor. Classes that have fields
- *       injected may omit the {@code @Inject} annotation if they have a public
- *       no-arguments constructor.
- *   <li>Injection of {@code @Provides} method parameters.
- *   <li>{@code @Provides} methods annotated {@code @Singleton}.
- *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@code Provider}s.
- *   <li>Injection of {@code MembersInjector}s.
- *   <li>Qualifier annotations on injected parameters and fields.
- *   <li>JSR 330 annotations.
- * </ul>
- *
- * <p>The following injection features are not currently supported:
- * <ul>
- *   <li>Method injection.</li>
- *   <li>Circular dependencies.</li>
- * </ul>
- */
-public final class ObjectGraph {
-  private final ObjectGraph base;
-  private final Linker linker;
-  private final Map<Class<?>, StaticInjection> staticInjections;
-  private final Map<String, Class<?>> entryPoints;
-  private final Plugin plugin;
-
-  ObjectGraph(ObjectGraph base,
-      Linker linker,
-      Plugin plugin,
-      Map<Class<?>, StaticInjection> staticInjections,
-      Map<String, Class<?>> entryPoints) {
-    if (linker == null) throw new NullPointerException("linker");
-    if (plugin == null) throw new NullPointerException("plugin");
-    if (staticInjections == null) throw new NullPointerException("staticInjections");
-    if (entryPoints == null) throw new NullPointerException("entryPoints");
-
-    this.base = base;
-    this.linker = linker;
-    this.plugin = plugin;
-    this.staticInjections = staticInjections;
-    this.entryPoints = entryPoints;
-  }
-
-  /**
-   * Returns a new dependency graph using the {@literal @}{@link
-   * Module}-annotated modules.
-   *
-   * <p>This <strong>does not</strong> inject any members. Most applications
-   * should call {@link #injectStatics} to inject static members and {@link
-   * #inject} or get {@link #get(Class)} to inject instance members when this
-   * method has returned.
-   *
-   * <p>This <strong>does not</strong> validate the graph. Rely on build time
-   * tools for graph validation, or call {@link #validate} to find problems in
-   * the graph at runtime.
-   */
-  public static ObjectGraph create(Object... modules) {
-    RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
-            new ClassloadingPlugin(), new ReflectivePlugin());
-    return makeGraph(null, plugin, modules);
-  }
-
-  private static ObjectGraph makeGraph(ObjectGraph base, Plugin plugin, Object... modules) {
-    Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
-    Map<Class<?>, StaticInjection> staticInjections
-        = new LinkedHashMap<Class<?>, StaticInjection>();
-
-    // Extract bindings in the 'base' and 'overrides' set. Within each set no
-    // duplicates are permitted.
-    Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-    Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
-    for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-      for (String key : moduleAdapter.entryPoints) {
-        entryPoints.put(key, moduleAdapter.getModule().getClass());
-      }
-      for (Class<?> c : moduleAdapter.staticInjections) {
-        staticInjections.put(c, null);
-      }
-      Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-      moduleAdapter.getBindings(addTo);
-    }
-
-    // Create a linker and install all of the user's bindings
-    Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-        new ThrowingErrorHandler());
-    linker.installBindings(baseBindings);
-    linker.installBindings(overrideBindings);
-
-    return new ObjectGraph(base, linker, plugin, staticInjections, entryPoints);
-  }
-
-  /**
-   * Returns a new object graph that includes all of the objects in this graph,
-   * plus additional objects in the {@literal @}{@link Module}-annotated
-   * modules. This graph is a subgraph of the returned graph.
-   *
-   * <p>The current graph is not modified by this operation: its objects and the
-   * dependency links between them are unchanged. But this graph's objects may
-   * be shared by both graphs. For example, the singletons of this graph may be
-   * injected and used by the returned graph.
-   *
-   * <p>This <strong>does not</strong> inject any members or validate the graph.
-   * See {@link #create} for guidance on injection and validation.
-   */
-  public ObjectGraph plus(Object... modules) {
-    linkEverything();
-    return makeGraph(this, plugin, modules);
-  }
-
-
-  private void linkStaticInjections() {
-    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-      StaticInjection staticInjection = entry.getValue();
-      if (staticInjection == null) {
-        staticInjection = plugin.getStaticInjection(entry.getKey());
-        entry.setValue(staticInjection);
-      }
-      staticInjection.attach(linker);
-    }
-  }
-
-  private void linkEntryPoints() {
-    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestBinding(entry.getKey(), entry.getValue(), false);
-    }
-  }
-
-  /**
-   * Do runtime graph problem detection. For fastest graph creation, rely on
-   * build time tools for graph validation.
-   *
-   * @throws IllegalStateException if this graph has problems.
-   */
-  public void validate() {
-    Map<String, Binding<?>> allBindings = linkEverything();
-    new ProblemDetector().detectProblems(allBindings.values());
-  }
-
-  /**
-   * Links all bindings, entry points and static injections.
-   */
-  private Map<String, Binding<?>> linkEverything() {
-    synchronized (linker) {
-      linkStaticInjections();
-      linkEntryPoints();
-      return linker.linkAll();
-    }
-  }
-
-  /**
-   * Injects the static fields of the classes listed in the object graph's
-   * {@code staticInjections} property.
-   */
-  public void injectStatics() {
-    // We call linkStaticInjections() twice on purpose. The first time through
-    // we request all of the bindings we need. The linker returns null for
-    // bindings it doesn't have. Then we ask the linker to link all of those
-    // requested bindings. Finally we call linkStaticInjections() again: this
-    // time the linker won't return null because everything has been linked.
-    synchronized (linker) {
-      linkStaticInjections();
-      linker.linkRequested();
-      linkStaticInjections();
-    }
-
-    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-      entry.getValue().inject();
-    }
-  }
-
-  /**
-   * Returns an instance of {@code type}.
-   *
-   * @throws IllegalArgumentException if {@code type} is not one of this object
-   *     graph's entry point types.
-   */
-  public <T> T get(Class<T> type) {
-    String key = Keys.get(type);
-    String entryPointKey = Keys.getMembersKey(type);
-    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);
-    return binding.get();
-  }
-
-  /**
-   * Injects the members of {@code instance}, including injectable members
-   * inherited from its supertypes.
-   *
-   * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not one of this object graph's entry point types.
-   */
-  public <T> T inject(T instance) {
-    String membersKey = Keys.getMembersKey(instance.getClass());
-    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
-    binding.injectMembers(instance);
-    return instance;
-  }
-
-  /**
-   * @param entryPointKey the key used to store the entry point. This is always
-   *     a members injection key because those keys can always be created, even
-   *     if the type has no injectable constructor.
-   * @param key the key to use when retrieving the binding. This may be a
-   *     regular (provider) key or a members key.
-   */
-  private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
-    Class<?> moduleClass = null;
-    for (ObjectGraph graph = this; graph != null; graph = graph.base) {
-      moduleClass = graph.entryPoints.get(entryPointKey);
-      if (moduleClass != null) break;
-    }
-    if (moduleClass == null) {
-      throw new IllegalArgumentException("No entry point for " + entryPointKey
-          + ". You must explicitly add an entry point to one of your modules.");
-    }
-
-    synchronized (linker) {
-      Binding<?> binding = linker.requestBinding(key, moduleClass, false);
-      if (binding == null || !binding.isLinked()) {
-        linker.linkRequested();
-        binding = linker.requestBinding(key, moduleClass, false);
-      }
-      return binding;
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index f9f66ac72..b0524b4ef 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -25,7 +26,7 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The object graph will
+ * method's return type is bound to its returned value. The object graph will
  * pass dependencies to the method as parameters.
  *
  * @author Bob Lee
@@ -46,7 +47,23 @@
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
      */
-    SET
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
+     * contributed to the set. An example use is to provide a default empty set binding, which is
+     * otherwise not possible using {@link #SET}.
+     */
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    @Beta
+    MAP;
   }
 
   Type type() default Type.UNIQUE;
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
new file mode 100644
index 000000000..0ef47011f
--- /dev/null
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * A subcomponent that inherits the bindings from a parent {@link Component} or
+ * {@link Subcomponent}. The details of how to associate a subcomponent with a parent are described
+ * in the documentation for {@link Component}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@Target(TYPE)
+@Documented
+public @interface Subcomponent {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * subcomponent implementation.  Note that through the use of {@link Module#includes} the full set
+   * of modules used to implement the subcomponent may include more modules that just those listed
+   * here.
+   */
+  Class<?>[] modules() default {};
+  
+  /**
+   * A builder for a subcomponent.  This follows all the rules of {@link Component.Builder}, except
+   * it must appear in classes annotated with {@link Subcomponent} instead of {@code Component}.
+   * Components can have methods that return a {@link Subcomponent.Builder}-annotated type,
+   * allowing the user to set modules on the subcomponent using their defined API.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
+}
diff --git a/core/src/main/java/dagger/internal/Beta.java b/core/src/main/java/dagger/internal/Beta.java
new file mode 100644
index 000000000..a0a82c659
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Beta.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+/**
+ * Signifies that a public API (public class, method or field) is subject to
+ * incompatible changes, or even removal, in a future release. An API bearing
+ * this annotation is exempt from any compatibility guarantees made by its
+ * containing library. Note that the presence of this annotation implies nothing
+ * about the quality or performance of the API in question, only the fact that
+ * it is not "API-frozen."
+ */
+@Documented
+@Retention(SOURCE)
+public @interface Beta {}
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
deleted file mode 100644
index 1fe88a690..000000000
--- a/core/src/main/java/dagger/internal/Binding.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.MembersInjector;
-import java.util.Set;
-import javax.inject.Provider;
-
-/**
- * Injects a value of a specific type.
- */
-public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
-    @Override public Object get() {
-      throw new AssertionError("Unresolved binding should never be called to inject.");
-    }
-    @Override public void injectMembers(Object t) {
-      throw new AssertionError("Unresolved binding should never be called to inject.");
-    }
-  };
-  protected static final boolean IS_SINGLETON = true;
-  protected static final boolean NOT_SINGLETON = false;
-
-  /** Set if the provided instance is always the same object. */
-  private static final int SINGLETON = 1 << 0;
-
-  /** Set if this binding's {@link #attach} completed without any missing dependencies. */
-  private static final int LINKED = 1 << 1;
-
-  /** Set if {@link ProblemDetector} is actively visiting this binding. */
-  private static final int VISITING = 1 << 2;
-
-  /** Set if {@link ProblemDetector} has confirmed this binding has no circular dependencies. */
-  private static final int CYCLE_FREE = 1 << 3;
-
-  /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
-  public final String provideKey;
-
-  /** The key used to inject members of 'T', or null if this binding cannot inject members. */
-  public final String membersKey;
-
-  /** Bitfield of states like SINGLETON and LINKED. */
-  private int bits;
-
-  public final Object requiredBy;
-
-  protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
-    if (singleton && provideKey == null) {
-      throw new IllegalArgumentException();
-    }
-    this.provideKey = provideKey;
-    this.membersKey = membersKey;
-    this.bits = (singleton ? SINGLETON : 0);
-    this.requiredBy = requiredBy;
-  }
-
-  /**
-   * Links this binding to its dependencies.
-   */
-  public void attach(Linker linker) {
-  }
-
-  @Override public void injectMembers(T t) {
-    // If no members to inject, no-op.  Some classes will have no injectable members even
-    // if their supertypes do.
-  }
-
-  @Override public T get() {
-    throw new UnsupportedOperationException("No injectable constructor on " + getClass().getName());
-  }
-
-  /**
-   * Populates {@code getBindings} and {@code injectMembersBindings} with the
-   * bindings used by this binding to satisfy {@link #get} and {@link
-   * #injectMembers} calls, respectively.
-   *
-   * @param getBindings the bindings required by this binding's {@code get}
-   *     method. Although {@code get} usually calls into {@code injectMembers},
-   *     this <i>does not</i> contain the injectMembers bindings.
-   * @param injectMembersBindings the bindings required by this binding's {@code
-   *     injectMembers} method.
-   */
-  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    // Do nothing.  No override == no dependencies to contribute.
-  }
-
-  void setLinked() {
-    bits |= LINKED;
-  }
-
-  public boolean isLinked() {
-    return (bits & LINKED) != 0;
-  }
-
-  boolean isSingleton() {
-    return (bits & SINGLETON) != 0;
-  }
-
-  public boolean isVisiting() {
-    return (bits & VISITING) != 0;
-  }
-
-  public void setVisiting(boolean visiting) {
-    this.bits = visiting ? (bits | VISITING) : (bits & ~VISITING);
-  }
-
-  public boolean isCycleFree() {
-    return (bits & CYCLE_FREE) != 0;
-  }
-
-  public void setCycleFree(boolean cycleFree) {
-    this.bits = cycleFree ? (bits | CYCLE_FREE) : (bits & ~CYCLE_FREE);
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName()
-            + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
-  }
-
-}
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
deleted file mode 100644
index d6787bcb4..000000000
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-
-/**
- * Injects a Provider or a MembersInjector.
- */
-final class BuiltInBinding<T> extends Binding<T> {
-  private final String delegateKey;
-  private Binding<?> delegate;
-
-  public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
-    super(key, null, false, requiredBy);
-    this.delegateKey = delegateKey;
-  }
-
-  @Override public void attach(Linker linker) {
-    delegate = linker.requestBinding(delegateKey, requiredBy);
-  }
-
-  @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException();
-  }
-
-  @SuppressWarnings("unchecked") // At runtime we know 'T' is a Provider or MembersInjector.
-  @Override public T get() {
-    return (T) delegate;
-  }
-
-  public Binding<?> getDelegate() {
-    return delegate;
-  }
-
-  // public void getDependencies() not overridden.
-  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-}
diff --git a/core/src/main/java/dagger/internal/Collections.java b/core/src/main/java/dagger/internal/Collections.java
new file mode 100644
index 000000000..55f26ebab
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Collections.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+
+final class Collections {
+  /**
+   * The maximum value for a signed 32-bit integer that is equal to a power of 2.
+   */
+  private static final int MAX_POWER_OF_TWO = 1 << (Integer.SIZE - 2);
+
+  private Collections() {
+  }
+
+  /**
+   * Creates a {@link LinkedHashSet} instance, with a high enough "initial capacity" that it
+   * <em>should</em> hold {@code expectedSize} elements without growth.
+   */
+  static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
+    return new LinkedHashSet<E>(calculateInitialCapacity(expectedSize));
+  }
+
+  /**
+   * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
+   * <em>should</em> hold {@code expectedSize} elements without growth.
+   */
+  static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
+    return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
+  }
+
+  private static int calculateInitialCapacity(int expectedSize) {
+    if (expectedSize < 3) {
+      return expectedSize + 1;
+    }
+    if (expectedSize < MAX_POWER_OF_TWO) {
+      // This is the calculation used in JDK8 to resize when a putAll
+      // happens; it seems to be the most conservative calculation we
+      // can make.  0.75 is the default load factor.
+      return (int) (expectedSize / 0.75F + 1.0F);
+    }
+    return Integer.MAX_VALUE; // any large value
+  }
+}
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
new file mode 100644
index 000000000..6db11f381
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+
+/**
+ * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
+ * using the double-check idiom described in Effective Java 2: Item 71.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): Unify the duplicated code between this and ScopedProvider.
+public final class DoubleCheckLazy<T> implements Lazy<T> {
+  private static final Object UNINITIALIZED = new Object();
+
+  private final Provider<T> provider;
+  private volatile Object instance = UNINITIALIZED;
+
+  private DoubleCheckLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @Override
+  public T get() {
+    // to suppress it.
+    Object result = instance;
+    if (result == UNINITIALIZED) {
+      synchronized (this) {
+        result = instance;
+        if (result == UNINITIALIZED) {
+          instance = result = provider.get();
+        }
+      }
+    }
+    return (T) result;
+  }
+
+  public static <T> Lazy<T> create(Provider<T> provider) {
+    if (provider == null) {
+      throw new NullPointerException();
+    }
+    return new DoubleCheckLazy<T>(provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Factory.java b/core/src/main/java/dagger/internal/Factory.java
new file mode 100644
index 000000000..3e2774cec
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Factory.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Scope;
+
+/**
+ * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may<i> apply
+ * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise
+ * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to
+ * {@link #get}.
+ *
+ * <p>Note that while subsequent calls to {@link #get} will create new instances for bindings such
+ * as those created by {@link Inject} constructors, a new instance is not guaranteed by all
+ * bindings. For example, {@link Provides} methods may be implemented in ways that return the same
+ * instance for each call.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public interface Factory<T> extends Provider<T> {
+}
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
new file mode 100644
index 000000000..59b1fcb8b
--- /dev/null
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@link Factory} implementation that returns a single instance for all invocations of
+ * {@link #get}.
+ *
+ * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
+ * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
+ * is redundant and unnecessary.  However, using this with the {@link ScopedProvider} is valid and
+ * may be desired for testing or contractual guarantees.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class InstanceFactory<T> implements Factory<T> {
+  public static <T> Factory<T> create(T instance) {
+    if (instance == null) {
+      throw new NullPointerException();
+    }
+    return new InstanceFactory<T>(instance);
+  }
+
+  private final T instance;
+
+  private InstanceFactory(T instance) {
+    this.instance = instance;
+  }
+
+  @Override
+  public T get() {
+    return instance;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
deleted file mode 100644
index 71fa9b21f..000000000
--- a/core/src/main/java/dagger/internal/Keys.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-/**
- * Formats strings that identify the value to be injected. Keys are of one of
- * three forms:
- * <ol>
- *   <li>{@code com.square.Foo}: provides instances of Foo.
- *   <li>{@code @com.square.Bar/com.square.Foo}: provides instances of Foo
- *       qualified by the annotation.
- *   <li>{@code members/com.square.Foo}: injects members of Foo.
- * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
- * created from {@code @Inject}-annotated members of a class are of the first
- * and last types.
- */
-public final class Keys {
-  private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
-  private static final String MEMBERS_INJECTOR_PREFIX = MembersInjector.class.getName() + "<";
-  private static final String LAZY_PREFIX = Lazy.class.getName() + "<";
-  private static final String SET_PREFIX = Set.class.getName() + "<";
-
-  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
-      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
-    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
-      return annotationType.isAnnotationPresent(Qualifier.class);
-    }
-  };
-
-  Keys() {
-  }
-
-  /** Returns a key for {@code type} with no annotation. */
-  public static String get(Type type) {
-    return get(type, null);
-  }
-
-
-  /** Returns a key for the members of {@code type}. */
-  public static String getMembersKey(Class<?> key) {
-    return "members/" + get(key);
-  }
-
-  /** Returns a key for {@code type} annotated by {@code annotation}. */
-  public static String get(Type type, Annotation annotation) {
-    type = boxIfPrimitive(type);
-    if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {
-      return ((Class<?>) type).getName();
-    }
-    StringBuilder result = new StringBuilder();
-    if (annotation != null) {
-      result.append(annotation).append("/");
-    }
-    typeToString(type, result, true);
-    return result.toString();
-  }
-
-  /**
-   * Returns a key for {@code type} annotated with {@code annotations},
-   * wrapped by {@code Set}, reporting failures against {@code subject}.
-   *
-   * @param annotations the annotations on a single method, field or parameter.
-   *     This array may contain at most one qualifier annotation.
-   */
-  public static String getElementKey(Type type, Annotation[] annotations, Object subject) {
-    Annotation qualifier = extractQualifier(annotations, subject);
-    type = boxIfPrimitive(type);
-    StringBuilder result = new StringBuilder();
-    if (qualifier != null) {
-      result.append(qualifier).append("/");
-    }
-    result.append(SET_PREFIX);
-    typeToString(type, result, true);
-    result.append(">");
-    return result.toString();
-  }
-
-  /**
-   * Returns a key for {@code type} annotated with {@code annotations},
-   * reporting failures against {@code subject}.
-   *
-   * @param annotations the annotations on a single method, field or parameter.
-   *     This array may contain at most one qualifier annotation.
-   */
-  public static String get(Type type, Annotation[] annotations, Object subject) {
-    return get(type, extractQualifier(annotations, subject));
-  }
-
-  /**
-   * Validates that among {@code annotations} there exists only one annotation which is, itself
-   * qualified by {@code \@Qualifier}
-   */
-  private static Annotation extractQualifier(Annotation[] annotations,
-      Object subject) {
-    Annotation qualifier = null;
-    for (Annotation a : annotations) {
-      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
-        continue;
-      }
-      if (qualifier != null) {
-        throw new IllegalArgumentException("Too many qualifier annotations on " + subject);
-      }
-      qualifier = a;
-    }
-    return qualifier;
-  }
-
-  /**
-   * @param topLevel true if this is a top-level type where primitive types
-   *     like 'int' are forbidden. Recursive calls pass 'false' to support
-   *     arrays like {@code int[]}.
-   */
-  private static void typeToString(Type type, StringBuilder result, boolean topLevel) {
-    if (type instanceof Class) {
-      Class<?> c = (Class<?>) type;
-      if (c.isArray()) {
-        typeToString(c.getComponentType(), result, false);
-        result.append("[]");
-      } else if (c.isPrimitive()) {
-        if (topLevel) {
-          throw new UnsupportedOperationException("Uninjectable type " + type);
-        }
-        result.append(c.getName());
-      } else {
-        result.append(c.getName());
-      }
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      typeToString(parameterizedType.getRawType(), result, true);
-      Type[] arguments = parameterizedType.getActualTypeArguments();
-      result.append("<");
-      for (int i = 0; i < arguments.length; i++) {
-        if (i != 0) {
-          result.append(", ");
-        }
-        typeToString(arguments[i], result, true);
-      }
-      result.append(">");
-    } else if (type instanceof GenericArrayType) {
-      GenericArrayType genericArrayType = (GenericArrayType) type;
-      typeToString(genericArrayType.getGenericComponentType(), result, false);
-      result.append("[]");
-    } else {
-      throw new UnsupportedOperationException("Uninjectable type " + type);
-    }
-  }
-
-  /**
-   * Returns a key for the type provided by, or injected by this key. For
-   * example, if this is a key for a {@code Provider<Foo>}, this returns the
-   * key for {@code Foo}. This retains annotations and supports both Provider
-   * keys and MembersInjector keys.
-   */
-  static String getBuiltInBindingsKey(String key) {
-    int start = startOfType(key);
-    if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
-      return extractKey(key, start, key.substring(0, start), PROVIDER_PREFIX);
-    } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
-      return extractKey(key, start, "members/", MEMBERS_INJECTOR_PREFIX);
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Returns a key for the underlying binding of a Lazy<T> value. For example,
-   * if this is a key for a {@code Lazy<Foo>}, this returns the key for
-   * {@code Foo}. This retains annotations.
-   */
-  static String getLazyKey(String key) {
-    int start = startOfType(key);
-    if (substringStartsWith(key, start, LAZY_PREFIX)) {
-      return extractKey(key, start, key.substring(0, start), LAZY_PREFIX);
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the start of a key if it is a plain key, and the start of the
-   * underlying key if it is an annotated key
-   */
-  private static int startOfType(String key) {
-    return (key.startsWith("@")) ? key.lastIndexOf('/') + 1 : 0;
-  }
-
-  /**
-   * Returns an unwrapped key (the key for T from a Provider<T> for example),
-   * removing all wrapping key information, but preserving annotations or known
-   * prefixes.
-   *
-   * @param key the key from which the delegate key should be extracted.
-   * @param start
-   *          an index into the key representing the key's "real" start after
-   *          any annotations.
-   * @param delegatePrefix
-   *          key prefix elements extracted from the underlying delegate
-   *          (annotations, "members/", etc.)
-   * @param prefix the prefix to strip.
-   */
-  private static String extractKey(String key, int start, String delegatePrefix, String prefix) {
-    return delegatePrefix + key.substring(start + prefix.length(), key.length() - 1);
-  }
-
-  /** Returns true if {@code string.substring(offset).startsWith(substring)}. */
-  private static boolean substringStartsWith(String string, int offset, String substring) {
-    return string.regionMatches(offset, substring, 0, substring.length());
-  }
-
-  /** Returns true if {@code key} is a binding that supports members injection. */
-  public static boolean isMembersInjection(String key) {
-    return key.startsWith("members/");
-  }
-
-  /** Returns true if {@code key} has a qualifier annotation. */
-  public static boolean isAnnotated(String key) {
-    return key.startsWith("@");
-  }
-
-  /**
-   * Returns the class name for {@code key}, if {@code key} was created with a
-   * class instance. Returns null if {@code key} represents a parameterized type
-   * or an array type.
-   */
-  public static String getClassName(String key) {
-    int start = 0;
-    if (key.startsWith("@") || key.startsWith("members/")) {
-      start = key.lastIndexOf('/') + 1;
-    }
-    return (key.indexOf('<', start) == -1 && key.indexOf('[', start) == -1)
-        ? key.substring(start)
-        : null;
-  }
-
-  /** Returns true if {@code name} is the name of a platform-provided class. */
-  public static boolean isPlatformType(String name) {
-    return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
-  }
-
-  private static Type boxIfPrimitive(Type type) {
-    if (type == byte.class) return Byte.class;
-    if (type == short.class) return Short.class;
-    if (type == int.class) return Integer.class;
-    if (type == long.class) return Long.class;
-    if (type == char.class) return Character.class;
-    if (type == boolean.class) return Boolean.class;
-    if (type == float.class) return Float.class;
-    if (type == double.class) return Double.class;
-    if (type == void.class) return Void.class;
-    return type;
-  }
-
-}
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
deleted file mode 100644
index a3bacc348..000000000
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-
-/**
- * Injects a Lazy wrapper for a type T
- */
-final class LazyBinding<T> extends Binding<Lazy<T>> {
-
-  private final static Object NOT_PRESENT = new Object();
-
-  private final String lazyKey;
-  private Binding<T> delegate;
-
-  public LazyBinding(String key, Object requiredBy, String lazyKey) {
-    super(key, null, false, requiredBy);
-    this.lazyKey = lazyKey;
-  }
-
-  @SuppressWarnings("unchecked") // At runtime we know it's a Binding<Lazy<T>>.
-  @Override
-  public void attach(Linker linker) {
-    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy);
-  }
-
-  @Override public void injectMembers(Lazy<T> t) {
-    throw new UnsupportedOperationException(); // not a member injection binding.
-  }
-
-  @Override
-  public Lazy<T> get() {
-    return new Lazy<T>() {
-      private Object cacheValue = NOT_PRESENT;
-
-      @SuppressWarnings("unchecked") // Delegate is of type T
-      @Override
-      public T get() {
-        return (T) ((cacheValue != NOT_PRESENT) ? cacheValue : (cacheValue = delegate.get()));
-      }
-    };
-  }
-
-  // public void getDependencies() not overridden.
-  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-}
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
deleted file mode 100644
index 6a016eb50..000000000
--- a/core/src/main/java/dagger/internal/Linker.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-
-/**
- * Links bindings to their dependencies.
- */
-public final class Linker {
-  private static final Object UNINITIALIZED = new Object();
-
-  /**
-   * The base {@code Linker} which will be consulted to satisfy bindings not
-   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
-   * in a chain will have a null base linker.
-   */
-  private final Linker base;
-
-  /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
-
-  /** True unless calls to requestBinding() were unable to satisfy the binding. */
-  private boolean attachSuccess = true;
-
-  /** All errors encountered during injection. */
-  private final List<String> errors = new ArrayList<String>();
-
-  /** All of the object graph's bindings. This may contain unlinked bindings. */
-  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
-
-  private final Plugin plugin;
-
-  private final ErrorHandler errorHandler;
-
-  public Linker(Linker base, Plugin plugin, ErrorHandler errorHandler) {
-    if (plugin == null) throw new NullPointerException("plugin");
-    if (errorHandler == null) throw new NullPointerException("errorHandler");
-
-    this.base = base;
-    this.plugin = plugin;
-    this.errorHandler = errorHandler;
-  }
-
-  /**
-   * Adds all bindings in {@code toInstall}. The caller must call either {@link
-   * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
-   * bindings can be used.
-   */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
-    for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
-      bindings.put(entry.getKey(), scope(entry.getValue()));
-    }
-  }
-
-  /**
-   * Links requested bindings and installed bindings, plus all of their
-   * transitive dependencies. This creates JIT bindings as necessary to fill in
-   * the gaps.
-   *
-   * @return all bindings known by this linker, which will all be linked.
-   */
-  public Map<String, Binding<?>> linkAll() {
-    for (Binding<?> binding : bindings.values()) {
-      if (!binding.isLinked()) {
-        toLink.add(binding);
-      }
-    }
-    linkRequested();
-    return bindings;
-  }
-
-  /**
-   * Links all requested bindings plus their transitive dependencies. This
-   * creates JIT bindings as necessary to fill in the gaps.
-   */
-  public void linkRequested() {
-    assertLockHeld();
-
-    Binding<?> binding;
-    while ((binding = toLink.poll()) != null) {
-      if (binding instanceof DeferredBinding) {
-        DeferredBinding deferredBinding = (DeferredBinding) binding;
-        String key = deferredBinding.deferredKey;
-        boolean mustBeInjectable = deferredBinding.mustBeInjectable;
-        if (bindings.containsKey(key)) {
-          continue; // A binding for this key has since been linked.
-        }
-        try {
-          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustBeInjectable);
-          // Fail if the type of binding we got wasn't capable of what was requested.
-          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
-            throw new IllegalStateException("Unable to create binding for " + key);
-          }
-          // Enqueue the JIT binding so its own dependencies can be linked.
-          toLink.add(jitBinding);
-          putBinding(jitBinding);
-        } catch (Exception e) {
-          if (e.getMessage() != null) {
-            addError(e.getMessage() + " required by " + binding.requiredBy);
-            bindings.put(key, Binding.UNRESOLVED);
-          } else if (e instanceof RuntimeException) {
-            throw (RuntimeException) e;
-          } else {
-            throw new RuntimeException(e);
-          }
-        }
-      } else {
-        // Attempt to attach the binding to its dependencies. If any dependency
-        // is not available, the attach will fail. We'll enqueue creation of
-        // that dependency and retry the attachment later.
-        attachSuccess = true;
-        binding.attach(this);
-        if (attachSuccess) {
-          binding.setLinked();
-        } else {
-          toLink.add(binding);
-        }
-      }
-    }
-
-    try {
-      errorHandler.handleErrors(errors);
-    } finally {
-      errors.clear();
-    }
-  }
-
-  /**
-   * Don't permit bindings to be linked without a lock. Callers should lock
-   * before requesting any bindings, link the requested bindings, retrieve
-   * the linked bindings, and then release the lock.
-   */
-  private void assertLockHeld() {
-    if (!Thread.holdsLock(this)) throw new AssertionError();
-  }
-
-  /**
-   * Creates a just-in-time binding for the key in {@code deferred}. The type of binding
-   * to be created depends on the key's type:
-   * <ul>
-   *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
-   *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
-   *       {@code Blah} respectively.
-   *   <li>Injections of other types will use the injectable constructors of those classes.
-   * </ul>
-   */
-  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustBeInjectable)
-      throws ClassNotFoundException {
-    String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
-    if (builtInBindingsKey != null) {
-      return new BuiltInBinding<Object>(key, requiredBy, builtInBindingsKey);
-    }
-    String lazyKey = Keys.getLazyKey(key);
-    if (lazyKey != null) {
-      return new LazyBinding<Object>(key, requiredBy, lazyKey);
-    }
-
-    String className = Keys.getClassName(key);
-    if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustBeInjectable);
-      if (atInjectBinding != null) {
-        return atInjectBinding;
-      }
-    }
-
-    throw new IllegalArgumentException("No binding for " + key);
-  }
-
-
-  /**
-   * Returns the binding if it exists immediately. Otherwise this returns
-   * null. If the returned binding didn't exist or was unlinked, it will be
-   * enqueued to be linked.
-   */
-  public Binding<?> requestBinding(String key, Object requiredBy) {
-    return requestBinding(key, requiredBy, true);
-  }
-
-  /**
-   * Returns the binding if it exists immediately. Otherwise this returns
-   * null. If the returned binding didn't exist or was unlinked, it will be
-   * enqueued to be linked.
-   *
-   * @param mustBeInjectable true if the the referenced key doesn't need to be
-   *     injectable. This is necessary for entry points (so that framework code
-   *     can inject arbitrary entry points like JUnit test cases or Android
-   *     activities) and for supertypes.
-   */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable) {
-    assertLockHeld();
-
-    Binding<?> binding = null;
-    for (Linker linker = this; linker != null; linker = linker.base) {
-      binding = linker.bindings.get(key);
-      if (binding != null) {
-        if (linker != this && !binding.isLinked()) throw new AssertionError();
-        break;
-      }
-    }
-
-    if (binding == null) {
-      // We can't satisfy this binding. Make sure it'll work next time!
-      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
-      toLink.add(deferredBinding);
-      attachSuccess = false;
-      return null;
-    }
-
-    if (!binding.isLinked()) {
-      toLink.add(binding); // This binding was never linked; link it now!
-    }
-
-    return binding;
-  }
-
-  private <T> void putBinding(Binding<T> binding) {
-    binding = scope(binding);
-
-    // At binding insertion time it's possible that another binding for the same
-    // key to already exist. This occurs when an @Provides method returns a type T
-    // and we also inject the members of that type.
-    if (binding.provideKey != null) {
-      putIfAbsent(bindings, binding.provideKey, binding);
-    }
-    if (binding.membersKey != null) {
-      putIfAbsent(bindings, binding.membersKey, binding);
-    }
-  }
-
-  /**
-   * Returns a scoped binding for {@code binding}.
-   */
-  static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton()) {
-      return binding;
-    }
-    if (binding instanceof SingletonBinding) throw new AssertionError();
-    return new SingletonBinding<T>(binding);
-  }
-
-  /**
-   * Puts the mapping {@code key, value} in {@code map} if no mapping for {@code
-   * key} already exists.
-   */
-  private <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
-    V replaced = map.put(key, value); // Optimistic: prefer only one hash operation lookup.
-    if (replaced != null) {
-      map.put(key, replaced);
-    }
-  }
-
-  /** Enqueue {@code message} as a fatal error to be reported to the user. */
-  private void addError(String message) {
-    errors.add(message);
-  }
-
-  /**
-   * A Binding that implements singleton behaviour around an existing binding.
-   */
-  private static class SingletonBinding<T> extends Binding<T> {
-    private final Binding<T> binding;
-    private Object onlyInstance = UNINITIALIZED;
-
-    private SingletonBinding(Binding<T> binding) {
-      super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
-      this.binding = binding;
-    }
-
-    @Override public void attach(Linker linker) {
-      binding.attach(linker);
-    }
-
-    @Override public void injectMembers(T t) {
-      binding.injectMembers(t);
-    }
-
-    @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
-    @Override public T get() {
-      // TODO (cgruber): Fix concurrency risk.
-      if (onlyInstance == UNINITIALIZED) {
-        onlyInstance = binding.get();
-      }
-      return (T) onlyInstance;
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      binding.getDependencies(get, injectMembers);
-    }
-
-    @Override public String toString() {
-      return "@Singleton/" + binding.toString();
-    }
-  }
-
-  /** Handles linker errors appropriately. */
-  public interface ErrorHandler {
-    /**
-     * Fail if any errors have been enqueued.
-     * Implementations may throw exceptions or report the errors through another
-     * channel.  Callers are responsible for clearing enqueued errors.
-     *
-     * @param errors a potentially empty list of error messages.
-     */
-    void handleErrors(List<String> errors);
-  }
-
-  private static class DeferredBinding extends Binding<Object> {
-    final String deferredKey;
-    final boolean mustBeInjectable;
-    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInjectable) {
-      super(null, null, false, requiredBy);
-      this.deferredKey = deferredKey;
-      this.mustBeInjectable = mustBeInjectable;
-    }
-    @Override public void injectMembers(Object t) {
-      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
-    }
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
-    }
-  }
-
-}
diff --git a/core/src/main/java/dagger/internal/LruCache.java b/core/src/main/java/dagger/internal/LruCache.java
deleted file mode 100644
index 6ca506247..000000000
--- a/core/src/main/java/dagger/internal/LruCache.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Private copy of {@code android.util.LruCache}.
- */
-class LruCache<K, V> {
-  private final LinkedHashMap<K, V> map;
-
-  /** Size of this cache in units. Not necessarily the number of elements. */
-  private int size;
-  private int maxSize;
-
-  private int putCount;
-  private int createCount;
-  private int evictionCount;
-  private int hitCount;
-  private int missCount;
-
-  /**
-   * @param maxSize for caches that do not override {@link #sizeOf}, this is
-   *     the maximum number of entries in the cache. For all other caches,
-   *     this is the maximum sum of the sizes of the entries in this cache.
-   */
-  public LruCache(int maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    this.maxSize = maxSize;
-    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
-  }
-
-  /**
-   * Returns the value for {@code key} if it exists in the cache or can be
-   * created by {@code #create}. If a value was returned, it is moved to the
-   * head of the queue. This returns null if a value is not cached and cannot
-   * be created.
-   */
-  public final V get(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V mapValue;
-    synchronized (this) {
-      mapValue = map.get(key);
-      if (mapValue != null) {
-        hitCount++;
-        return mapValue;
-      }
-      missCount++;
-    }
-
-    /*
-    * Attempt to create a value. This may take a long time, and the map
-    * may be different when create() returns. If a conflicting value was
-    * added to the map while create() was working, we leave that value in
-    * the map and release the created value.
-    */
-
-    V createdValue = create(key);
-    if (createdValue == null) {
-      return null;
-    }
-
-    synchronized (this) {
-      createCount++;
-      mapValue = map.put(key, createdValue);
-
-      if (mapValue != null) {
-        // There was a conflict so undo that last put
-        map.put(key, mapValue);
-      } else {
-        size += safeSizeOf(key, createdValue);
-      }
-    }
-
-    if (mapValue != null) {
-      entryRemoved(false, key, createdValue, mapValue);
-      return mapValue;
-    } else {
-      trimToSize(maxSize);
-      return createdValue;
-    }
-  }
-
-  /**
-   * Caches {@code value} for {@code key}. The value is moved to the head of
-   * the queue.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V put(K key, V value) {
-    if (key == null || value == null) {
-      throw new NullPointerException("key == null || value == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      putCount++;
-      size += safeSizeOf(key, value);
-      previous = map.put(key, value);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, value);
-    }
-
-    trimToSize(maxSize);
-    return previous;
-  }
-
-  /**
-   * @param maxSize the maximum size of the cache before returning. May be -1
-   *     to evict even 0-sized elements.
-   */
-  private void trimToSize(int maxSize) {
-    while (true) {
-      K key;
-      V value;
-      synchronized (this) {
-        if (size < 0 || (map.isEmpty() && size != 0)) {
-          throw new IllegalStateException(getClass().getName()
-              + ".sizeOf() is reporting inconsistent results!");
-        }
-
-        if (size <= maxSize || map.isEmpty()) {
-          break;
-        }
-
-        Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
-        key = toEvict.getKey();
-        value = toEvict.getValue();
-        map.remove(key);
-        size -= safeSizeOf(key, value);
-        evictionCount++;
-      }
-
-      entryRemoved(true, key, value, null);
-    }
-  }
-
-  /**
-   * Removes the entry for {@code key} if it exists.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V remove(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      previous = map.remove(key);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, null);
-    }
-
-    return previous;
-  }
-
-  /**
-   * Called for entries that have been evicted or removed. This method is
-   * invoked when a value is evicted to make space, removed by a call to
-   * {@link #remove}, or replaced by a call to {@link #put}. The default
-   * implementation does nothing.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * @param evicted true if the entry is being removed to make space, false
-   *     if the removal was caused by a {@link #put} or {@link #remove}.
-   * @param newValue the new value for {@code key}, if it exists. If non-null,
-   *     this removal was caused by a {@link #put}. Otherwise it was caused by
-   *     an eviction or a {@link #remove}.
-   */
-  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
-  }
-
-  /**
-   * Called after a cache miss to compute a value for the corresponding key.
-   * Returns the computed value or null if no value can be computed. The
-   * default implementation returns null.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * <p>If a value for {@code key} exists in the cache when this method
-   * returns, the created value will be released with {@link #entryRemoved}
-   * and discarded. This can occur when multiple threads request the same key
-   * at the same time (causing multiple values to be created), or when one
-   * thread calls {@link #put} while another is creating a value for the same
-   * key.
-   */
-  protected V create(K key) {
-    return null;
-  }
-
-  private int safeSizeOf(K key, V value) {
-    int result = sizeOf(key, value);
-    if (result < 0) {
-      throw new IllegalStateException("Negative size: " + key + "=" + value);
-    }
-    return result;
-  }
-
-  /**
-   * Returns the size of the entry for {@code key} and {@code value} in
-   * user-defined units.  The default implementation returns 1 so that size
-   * is the number of entries and max size is the maximum number of entries.
-   *
-   * <p>An entry's size must not change while it is in the cache.
-   */
-  protected int sizeOf(K key, V value) {
-    return 1;
-  }
-
-  /**
-   * Clear the cache, calling {@link #entryRemoved} on each removed entry.
-   */
-  public final void evictAll() {
-    trimToSize(-1); // -1 will evict 0-sized elements
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the number
-   * of entries in the cache. For all other caches, this returns the sum of
-   * the sizes of the entries in this cache.
-   */
-  public synchronized final int size() {
-    return size;
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the maximum
-   * number of entries in the cache. For all other caches, this returns the
-   * maximum sum of the sizes of the entries in this cache.
-   */
-  public synchronized final int maxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned a value.
-   */
-  public synchronized final int hitCount() {
-    return hitCount;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned null or required a new
-   * value to be created.
-   */
-  public synchronized final int missCount() {
-    return missCount;
-  }
-
-  /**
-   * Returns the number of times {@link #create(Object)} returned a value.
-   */
-  public synchronized final int createCount() {
-    return createCount;
-  }
-
-  /**
-   * Returns the number of times {@link #put} was called.
-   */
-  public synchronized final int putCount() {
-    return putCount;
-  }
-
-  /**
-   * Returns the number of values that have been evicted.
-   */
-  public synchronized final int evictionCount() {
-    return evictionCount;
-  }
-
-  /**
-   * Returns a copy of the current contents of the cache, ordered from least
-   * recently accessed to most recently accessed.
-   */
-  public synchronized final Map<K, V> snapshot() {
-    return new LinkedHashMap<K, V>(map);
-  }
-
-  @Override public synchronized final String toString() {
-    int accesses = hitCount + missCount;
-    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
-    return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
-        maxSize, hitCount, missCount, hitPercent);
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
new file mode 100644
index 000000000..4dac1262b
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.inject.Provider;
+
+import static dagger.internal.Collections.newLinkedHashMapWithExpectedSize;
+import static java.util.Collections.unmodifiableMap;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
+  }
+
+  /**
+   * Returns a new MapFactory.
+   */
+  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+    Map<K, Provider<V>> map = mapProviderFactory.get();
+    return new MapFactory<K, V>(map);
+  }
+
+  /**
+   * Returns a {@code Map<K, V>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   */
+  @Override
+  public Map<K, V> get() {
+    Map<K, V> result = newLinkedHashMapWithExpectedSize(contributingMap.size());
+    for (Entry<K, Provider<V>> entry: contributingMap.entrySet()) {
+      result.put(entry.getKey(), entry.getValue().get());
+    }
+    return unmodifiableMap(result);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
new file mode 100644
index 000000000..00c0fd33a
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import javax.inject.Provider;
+
+import static dagger.internal.Collections.newLinkedHashMapWithExpectedSize;
+import static java.util.Collections.unmodifiableMap;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+    this.contributingMap = unmodifiableMap(contributingMap);
+  }
+
+  /**
+   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, Provider<V>> get() {
+    return this.contributingMap;
+  }
+
+  /**
+   * A builder to help build the {@link MapProviderFactory}
+   */
+  public static final class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(user): consider which way to initialize mapBuilder is better
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /**
+     * Returns a new {@link MapProviderFactory}
+     */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<K, V>(this.mapBuilder);
+    }
+
+    /**
+     * Associate k with providerOfValue in {@code Builder}
+     */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      if (key == null) {
+        throw new NullPointerException("The key is null");
+      }
+      if (providerOfValue == null) {
+        throw new NullPointerException("The provider of the value is null");
+      }
+
+      this.mapBuilder.put(key, providerOfValue);
+      return this;
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
new file mode 100644
index 000000000..ee4c7b4cf
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.MembersInjector;
+import javax.inject.Inject;
+
+/**
+ * Basic {@link MembersInjector} implementations used by the framework.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class MembersInjectors {
+  /**
+   * Returns a {@link MembersInjector} implementation that injects no members
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> noOp() {
+    return (MembersInjector<T>) NoOpMembersInjector.INSTANCE;
+  }
+
+  private static enum NoOpMembersInjector implements MembersInjector<Object> {
+    INSTANCE;
+
+    @Override public void injectMembers(Object instance) {
+      if (instance == null) {
+        throw new NullPointerException();
+      }
+    }
+  }
+
+  /**
+   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its
+   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}
+   * members, but must still inject members on its supertype(s).
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
+    return (MembersInjector<T>) delegate;
+  }
+
+  private MembersInjectors() {}
+}
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
deleted file mode 100644
index d4eafb46b..000000000
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-
-import java.util.Map;
-
-/**
- * Extracts bindings from an {@code @Module}-annotated class.
- */
-public abstract class ModuleAdapter<T> {
-  public final String[] entryPoints;
-  public final Class<?>[] staticInjections;
-  public final boolean overrides;
-  public final Class<?>[] includes;
-  public final boolean complete;
-  protected T module;
-
-  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
-      Class<?>[] includes, boolean complete) {
-    this.entryPoints = entryPoints;
-    this.staticInjections = staticInjections;
-    this.overrides = overrides;
-    this.includes = includes;
-    this.complete = complete;
-  }
-
-  /**
-   * Returns bindings for the {@code @Provides} methods of {@code module}. The
-   * returned bindings must be linked before they can be used to inject values.
-   */
-  public abstract void getBindings(Map<String, Binding<?>> map);
-
-  /**
-   * Returns a new instance of the module class created using a no-args
-   * constructor. Only used when a manually-constructed module is not supplied.
-   */
-  protected abstract T newModule();
-
-  public T getModule() {
-    return module;
-  }
-
-
-}
diff --git a/core/src/main/java/dagger/internal/Plugin.java b/core/src/main/java/dagger/internal/Plugin.java
deleted file mode 100644
index db803a33b..000000000
--- a/core/src/main/java/dagger/internal/Plugin.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-/**
- * Provides a point of configuration of the basic resolving functions within Dagger, namely
- * that of Module handling, injection binding creation, and static injection.  A plugin must
- * provide all resolution methods
- */
-public interface Plugin {
-  /**
-   * Returns a binding that uses {@code @Inject} annotations.
-   */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable);
-
-  /**
-   * Returns a module adapter for {@code module}.
-   */
-  <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
-
-  /**
-   * Returns the static injection for {@code injectedClass}.
-   */
-  StaticInjection getStaticInjection(Class<?> injectedClass);
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
deleted file mode 100644
index e58b51ff4..000000000
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.AbstractSet;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Detects problems like cyclic dependencies.
- */
-public final class ProblemDetector {
-  public void detectProblems(Collection<Binding<?>> bindings) {
-    detectCircularDependencies(bindings, new ArrayList<Binding<?>>());
-  }
-
-  public void detectCircularDependencies(Collection<Binding<?>> bindings, List<Binding<?>> path) {
-    for (Binding<?> binding : bindings) {
-      if (binding.isCycleFree()) {
-        continue;
-      }
-
-      if (binding.isVisiting()) {
-        int index = path.indexOf(binding);
-        StringBuilder message = new StringBuilder()
-            .append("Dependency cycle:");
-        for (int i = index; i < path.size(); i++) {
-          message.append("\n    ").append(i - index).append(". ")
-              .append(path.get(i).provideKey).append(" bound by ").append(path.get(i));
-        }
-        message.append("\n    ").append(0).append(". ").append(binding.provideKey);
-        throw new IllegalStateException(message.toString());
-      }
-
-      binding.setVisiting(true);
-      path.add(binding);
-      try {
-        ArraySet<Binding<?>> dependencies = new ArraySet<Binding<?>>();
-        binding.getDependencies(dependencies, dependencies);
-        detectCircularDependencies(dependencies, path);
-        binding.setCycleFree(true);
-      } finally {
-        path.remove(path.size() - 1);
-        binding.setVisiting(false);
-      }
-    }
-  }
-
-  static class ArraySet<T> extends AbstractSet<T> {
-    private ArrayList<T> list = new ArrayList<T>();
-
-    @Override public boolean add(T t) {
-      list.add(t);
-      return true;
-    }
-
-    @Override public Iterator<T> iterator() {
-      return list.iterator();
-    }
-
-    @Override public int size() {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
deleted file mode 100644
index 75b02533f..000000000
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.ObjectGraph;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * Aggregates provided plugins and delegates its operations to them in order.  Also provides some
- * specific runtime facilities needed by the runtime.
- */
-public final class RuntimeAggregatingPlugin implements Plugin {
-  private static final Logger logger = Logger.getLogger(ObjectGraph.class.getName());
-
-  /** A list of {@code Linker.Plugin}s which will be consulted in-order to resolve requests. */
-  private final Plugin[] plugins;
-
-  public RuntimeAggregatingPlugin(Plugin ... plugins) {
-    if (plugins == null || plugins.length == 0) {
-      throw new IllegalArgumentException("Must provide at least one plugin.");
-    }
-    this.plugins = plugins;
-  }
-
-  /**
-   * Returns a full set of module adapters, including module adapters for included
-   * modules.
-   */
-  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Plugin plugin,
-      Object[] seedModules) {
-    // Create a module adapter for each seed module.
-    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
-    int s = 0;
-    for (Object module : seedModules) {
-      if (module instanceof Class) {
-        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Plugin constructs.
-      } else {
-        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
-      }
-    }
-
-    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
-        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-
-    // Add the adapters that we have module instances for. This way we won't
-    // construct module objects when we have a user-supplied instance.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
-    }
-
-    // Next add adapters for the modules that we need to construct. This creates
-    // instances of modules as necessary.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
-    }
-
-    return adaptersByModuleType;
-  }
-
-  /**
-   * Fills {@code result} with the module adapters for the includes of {@code
-   * adapter}, and their includes recursively.
-   */
-  private static void collectIncludedModulesRecursively(Plugin plugin, ModuleAdapter<?> adapter,
-      Map<Class<?>, ModuleAdapter<?>> result) {
-    for (Class<?> include : adapter.includes) {
-      if (!result.containsKey(include)) {
-        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
-        result.put(include, includedModuleAdapter);
-        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
-      }
-    }
-  }
-
-  /**
-   * Obtains a module adapter for {@code module} from the first responding resolver.
-   */
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    for (int i = 0; i < plugins.length; i++) {
-      try {
-        ModuleAdapter<T> result = plugins[i].getModuleAdapter(moduleClass, module);
-        result.module = (module != null) ? module : result.newModule();
-        return result;
-      } catch (RuntimeException e) {
-        if (i == plugins.length - 1) throw e;
-        logNotFound("Module adapter", moduleClass.getName(), e);
-      }
-    }
-    throw new AssertionError();
-  }
-
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) {
-    for (int i = 0; i < plugins.length; i++) {
-      try {
-        return plugins[i].getAtInjectBinding(key, className, mustBeInjectable);
-      } catch (RuntimeException e) {
-        if (i == plugins.length - 1) throw e;
-        logNotFound("Binding", className, e);
-      }
-    }
-    throw new AssertionError();
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    for (int i = 0; i < plugins.length; i++) {
-      try {
-        return plugins[i].getStaticInjection(injectedClass);
-      } catch (RuntimeException e) {
-        if (i == plugins.length - 1) throw e;
-        logNotFound("Static injection", injectedClass.getName(), e);
-      }
-    }
-    throw new AssertionError();
-  }
-
-  private void logNotFound(String type, String name, RuntimeException e) {
-    if (logger.isLoggable(Level.FINE)) {
-      logger.log(Level.FINE, String.format("%s for %s not found.", type, name), e);
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
new file mode 100644
index 000000000..15917dd27
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class ScopedProvider<T> implements Provider<T> {
+  private static final Object UNINITIALIZED = new Object();
+
+  private final Factory<T> factory;
+  private volatile Object instance = UNINITIALIZED;
+
+  private ScopedProvider(Factory<T> factory) {
+    assert factory != null;
+    this.factory = factory;
+  }
+
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @Override
+  public T get() {
+    // double-check idiom from EJ2: Item 71
+    Object result = instance;
+    if (result == UNINITIALIZED) {
+      synchronized (this) {
+        result = instance;
+        if (result == UNINITIALIZED) {
+          instance = result = factory.get();
+        }
+      }
+    }
+    return (T) result;
+  }
+
+  /** Returns a new scoped provider for the given factory. */
+  public static <T> Provider<T> create(Factory<T> factory) {
+    if (factory == null) {
+      throw new NullPointerException();
+    }
+    return new ScopedProvider<T>(factory);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
deleted file mode 100644
index 153627525..000000000
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * A {@code Binding<T>} which contains contributors (other bindings marked with
- * {@code @Provides} {@code @OneOf}), to which it delegates provision
- * requests on an as-needed basis.
- */
-public final class SetBinding<T> extends Binding<Set<T>> {
-
-  public static <T> void add(Map<String, Binding<?>> bindings, String elementKey,
-      Binding<?> binding) {
-    SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
-    if (elementBinding == null) {
-      elementBinding = new SetBinding<T>(elementKey);
-      bindings.put(elementBinding.provideKey, elementBinding);
-    }
-    elementBinding.contributors.add(Linker.scope(binding));
-  }
-
-  private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
-
-  public SetBinding(String key) {
-    super(key, null, false, null);
-  }
-
-  @Override public void attach(Linker linker) {
-    for (Binding<?> contributor : contributors) {
-      contributor.attach(linker);
-    }
-  }
-
-  @SuppressWarnings("unchecked") // Bindings<T> are the only thing added to contributors.
-  @Override public Set<T> get() {
-    Set<T> result = new LinkedHashSet<T>(contributors.size());
-    for (Binding<?> contributor : contributors) {
-      result.add((T) contributor.get()); // Let runtime exceptions through.
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  @Override public void getDependencies(
-      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    getBindings.addAll(contributors);
-  }
-
-  @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a multi-binder Set");
-  }
-
-  @Override public String toString() {
-    return "SetBinding" + contributors;
-  }
-}
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
new file mode 100644
index 000000000..9b73e79db
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Provider;
+
+import static dagger.internal.Collections.newLinkedHashSetWithExpectedSize;
+import static java.util.Collections.unmodifiableSet;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
+ * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
+ * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class SetFactory<T> implements Factory<Set<T>> {
+  /**
+   * A message for NPEs that trigger on bad argument lists.
+   */
+  private static final String ARGUMENTS_MUST_BE_NON_NULL =
+      "SetFactory.create() requires its arguments to be non-null";
+
+  /**
+   * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
+   * result.
+   */
+  public static <T> Factory<Set<T>> create(Factory<Set<T>> factory) {
+    assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
+    return factory;
+  }
+  
+  /**
+   * Returns a new factory that creates {@link Set} instances that form the union of the given
+   * {@link Provider} instances.  Callers must not modify the providers array after invoking this
+   * method; no copy is made.
+   */
+  public static <T> Factory<Set<T>> create(
+      @SuppressWarnings("unchecked") Provider<Set<T>>... providers) {
+    assert providers != null : ARGUMENTS_MUST_BE_NON_NULL;
+
+    List<Provider<Set<T>>> contributingProviders = Arrays.asList(providers);
+
+    assert !contributingProviders.contains(null)
+        : "Codegen error?  Null within provider list.";
+    assert !hasDuplicates(contributingProviders)
+        : "Codegen error?  Duplicates in the provider list";
+
+    return new SetFactory<T>(contributingProviders);
+  }
+
+  /**
+   * Returns true if at least one pair of items in (@code original) are equals.
+   */
+  private static boolean hasDuplicates(List<? extends Object> original) {
+    Set<Object> asSet = new HashSet<Object>(original);
+    return original.size() != asSet.size();
+  }
+
+  private final List<Provider<Set<T>>> contributingProviders;
+
+  private SetFactory(List<Provider<Set<T>>> contributingProviders) {
+    this.contributingProviders = contributingProviders;
+  }
+
+  /**
+   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
+   *
+   * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
+   *     are {@code null}
+   */
+  @Override
+  public Set<T> get() {
+    int size = 0;
+
+    // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
+    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is 
+    // faster for ArrayLists, at least through Java 8.
+
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
+    for (int i = 0, c = contributingProviders.size(); i < c; i++) {
+      Provider<Set<T>> provider = contributingProviders.get(i);
+      Set<T> providedSet = provider.get();
+      if (providedSet == null) {
+        throw new NullPointerException(provider + " returned null");
+      }
+      providedSets.add(providedSet);
+      size += providedSet.size();
+    }
+
+    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    for (int i = 0, c = providedSets.size(); i < c; i++) {
+      for (T element : providedSets.get(i)) {
+        if (element == null) {
+          throw new NullPointerException("a null element was provided");
+        }
+        result.add(element);
+      }
+    }
+    return unmodifiableSet(result);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
deleted file mode 100644
index d17ae7a92..000000000
--- a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.List;
-
-/**
- * Handles errors by throwing an exception containing all the available errors.
- */
-public final class ThrowingErrorHandler implements Linker.ErrorHandler {
-
-  @Override public void handleErrors(List<String> errors) {
-    if (errors.isEmpty()) {
-      return;
-    }
-    StringBuilder message = new StringBuilder();
-    message.append("Errors creating object graph:");
-    for (String error : errors) {
-      message.append("\n  ").append(error);
-    }
-    throw new IllegalStateException(message.toString());
-  }
-}
diff --git a/core/src/main/java/dagger/internal/UniqueMap.java b/core/src/main/java/dagger/internal/UniqueMap.java
deleted file mode 100644
index 04a42a718..000000000
--- a/core/src/main/java/dagger/internal/UniqueMap.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * A map that fails when existing values are clobbered.
- */
-public class UniqueMap<K, V> extends LinkedHashMap<K, V> {
-  @Override public V put(K key, V value) {
-    V clobbered = super.put(key, value);
-    if (clobbered != null) {
-      super.put(key, clobbered); // Put things back as they were.
-      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
-    }
-    return null;
-  }
-  @Override public void putAll(Map<? extends K, ? extends V> map) {
-    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
-      put(entry.getKey(), entry.getValue());
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
deleted file mode 100644
index c6646a2b1..000000000
--- a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.plugins.loading;
-
-import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Constructor;
-
-/**
- * A runtime {@link Plugin} that loads generated classes.
- */
-public final class ClassloadingPlugin implements Plugin {
-  public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
-  public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
-
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);
-  }
-
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
-    return instantiate(className, INJECT_ADAPTER_SUFFIX);
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX);
-  }
-
-  @SuppressWarnings("unchecked") // We use a naming convention to defend against mismatches.
-  private <T> T instantiate(String className, String suffix) {
-    String name = className + suffix;
-    try {
-      Class<?> generatedClass = Class.forName(name);
-      Constructor<?> constructor = generatedClass.getConstructor();
-      constructor.setAccessible(true);
-      return (T) constructor.newInstance();
-    } catch (Exception e) {
-      throw new RuntimeException("Unexpected failure loading " + name, e);
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
deleted file mode 100644
index 9bc174032..000000000
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.plugins.reflect;
-
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-/**
- * Injects the {@code @Inject}-annotated fields and constructors of a class
- * using reflection.
- */
-final class ReflectiveAtInjectBinding<T> extends Binding<T> {
-  private final Field[] fields;
-  private final Constructor<T> constructor;
-  private final Class<?> supertype;
-  private final String[] keys;
-  private final Binding<?>[] fieldBindings;
-  private final Binding<?>[] parameterBindings;
-  private Binding<? super T> supertypeBinding;
-
-  /**
-   * @param keys keys for the fields, constructor parameters and supertype in
-   *     that order. These are precomputed to minimize reflection when {@code
-   *     attach} is called multiple times.
-   * @param constructor the injectable constructor, or null if this binding
-   *     supports members injection only.
-   * @param supertype the injectable supertype, or null if the supertype is a
-   */
-  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton,
-      Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
-      Class<?> supertype, String[] keys) {
-    super(provideKey, membersKey, singleton, type);
-    this.constructor = constructor;
-    this.fields = fields;
-    this.supertype = supertype;
-    this.keys = keys;
-    this.parameterBindings = new Binding<?>[parameterCount];
-    this.fieldBindings = new Binding<?>[fields.length];
-  }
-
-  @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
-  @Override public void attach(Linker linker) {
-    int k = 0;
-    for (int i = 0; i < fields.length; i++) {
-      if (fieldBindings[i] == null) {
-        fieldBindings[i] = linker.requestBinding(keys[k], fields[i]);
-      }
-      k++;
-    }
-    if (constructor != null) {
-      for (int i = 0; i < parameterBindings.length; i++) {
-        if (parameterBindings[i] == null) {
-          parameterBindings[i] = linker.requestBinding(keys[k], constructor);
-        }
-        k++;
-      }
-    }
-    if (supertype != null && supertypeBinding == null) {
-      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false);
-    }
-  }
-
-  @Override public T get() {
-    if (constructor == null) {
-      throw new UnsupportedOperationException();
-    }
-    Object[] args = new Object[parameterBindings.length];
-    for (int i = 0; i < parameterBindings.length; i++) {
-      args[i] = parameterBindings[i].get();
-    }
-    T result;
-    try {
-      result = constructor.newInstance(args);
-    } catch (InvocationTargetException e) {
-      Throwable cause = e.getCause();
-      throw cause instanceof RuntimeException
-          ? (RuntimeException) cause
-          : new RuntimeException(cause);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException(e);
-    }
-    injectMembers(result);
-    return result;
-  }
-
-  @Override public void injectMembers(T t) {
-    try {
-      for (int i = 0; i < fields.length; i++) {
-        fields[i].set(t, fieldBindings[i].get());
-      }
-      if (supertypeBinding != null) {
-        supertypeBinding.injectMembers(t);
-      }
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    if (parameterBindings != null) {
-      for (Binding<?> binding : parameterBindings) {
-        get.add(binding);
-      }
-    }
-    for (Binding<?> binding : fieldBindings) {
-      injectMembers.add(binding);
-    }
-    if (supertypeBinding != null) {
-      injectMembers.add(supertypeBinding);
-    }
-  }
-
-  @Override public String toString() {
-    return provideKey != null ? provideKey : membersKey;
-  }
-
-  /**
-   * @param mustBeInjectable true if the binding must have {@code @Inject}
-   *     annotations.
-   */
-  public static <T> Binding<T> create(Class<T> type, boolean mustBeInjectable) {
-    boolean singleton = type.isAnnotationPresent(Singleton.class);
-    List<String> keys = new ArrayList<String>();
-
-    // Lookup the injectable fields and their corresponding keys.
-    List<Field> injectedFields = new ArrayList<Field>();
-    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
-      for (Field field : c.getDeclaredFields()) {
-        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
-          continue;
-        }
-        field.setAccessible(true);
-        injectedFields.add(field);
-        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
-      }
-    }
-
-    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
-    // constructor, use a default public constructor if the class has other
-    // injections. Otherwise treat the class as non-injectable.
-    Constructor<T> injectedConstructor = null;
-    for (Constructor<T> constructor : getConstructorsForType(type)) {
-      if (!constructor.isAnnotationPresent(Inject.class)) {
-        continue;
-      }
-      if (injectedConstructor != null) {
-        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
-      }
-      injectedConstructor = constructor;
-    }
-    if (injectedConstructor == null) {
-      if (injectedFields.isEmpty() && mustBeInjectable) {
-        throw new IllegalArgumentException("No injectable members on " + type.getName()
-            + ". Do you want to add an injectable constructor?");
-      }
-      try {
-        injectedConstructor = type.getDeclaredConstructor();
-      } catch (NoSuchMethodException ignored) {
-      }
-    }
-
-    int parameterCount;
-    String provideKey;
-    if (injectedConstructor != null) {
-      provideKey = Keys.get(type);
-      injectedConstructor.setAccessible(true);
-      Type[] types = injectedConstructor.getGenericParameterTypes();
-      parameterCount = types.length;
-      if (parameterCount != 0) {
-        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
-        for (int p = 0; p < types.length; p++) {
-          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
-        }
-      }
-    } else {
-      provideKey = null;
-      parameterCount = 0;
-      if (singleton) {
-        throw new IllegalArgumentException(
-            "No injectable constructor on @Singleton " + type.getName());
-      }
-    }
-
-    Class<? super T> supertype = type.getSuperclass();
-    if (supertype != null) {
-      if (Keys.isPlatformType(supertype.getName())) {
-        supertype = null;
-      } else {
-        keys.add(Keys.getMembersKey(supertype));
-      }
-    }
-
-    String membersKey = Keys.getMembersKey(type);
-    return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton, type,
-        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
-        parameterCount, supertype, keys.toArray(new String[keys.size()]));
-  }
-
-  @SuppressWarnings("unchecked") // Class.getDeclaredConstructors is an unsafe API.
-  private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
-    return (Constructor<T>[]) type.getDeclaredConstructors();
-  }
-}
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
deleted file mode 100644
index ab1e8ecc8..000000000
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.plugins.reflect;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Singleton;
-
-final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
-  final Class<?> moduleClass;
-
-  public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
-    super(
-        toMemberKeys(annotation.entryPoints()),
-        annotation.staticInjections(),
-        annotation.overrides(),
-        annotation.includes(),
-        annotation.complete());
-    this.moduleClass = moduleClass;
-  }
-
-  private static String[] toMemberKeys(Class<?>[] entryPoints) {
-    String[] result = new String[entryPoints.length];
-    for (int i = 0; i < entryPoints.length; i++) {
-      result[i] = Keys.getMembersKey(entryPoints[i]);
-    }
-    return result;
-  }
-
-  @Override public void getBindings(Map<String, Binding<?>> bindings) {
-    for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
-      for (Method method : c.getDeclaredMethods()) {
-        Provides provides = method.getAnnotation(Provides.class);
-        if (provides != null) {
-          String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
-          switch (provides.type()) {
-            case UNIQUE:
-              handleBindings(bindings, method, key);
-              break;
-            case SET:
-              handleSetBindings(bindings, method, key);
-              break;
-            default:
-              throw new AssertionError("Unknown @Provides type " + provides.type());
-          }
-        }
-      }
-    }
-  }
-
-  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key) {
-    bindings.put(key, new ProviderMethodBinding<T>(method, key, module));
-  }
-
-  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key) {
-    String elementKey =
-        Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module));
-  }
-
-  @Override protected Object newModule() {
-    try {
-      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return constructor.newInstance();
-    } catch (InvocationTargetException e) {
-      throw new IllegalArgumentException(e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
-    } catch (InstantiationException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /**
-   * Invokes a method to provide a value. The method's parameters are injected.
-   */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
-    private Binding<?>[] parameters;
-    private final Method method;
-    private final Object instance;
-
-    public ProviderMethodBinding(Method method, String key, Object instance) {
-      super(key, null, method.isAnnotationPresent(Singleton.class), method);
-      this.method = method;
-      this.instance = instance;
-      method.setAccessible(true);
-    }
-
-    @Override public void attach(Linker linker) {
-      Type[] types = method.getGenericParameterTypes();
-      Annotation[][] annotations = method.getParameterAnnotations();
-      parameters = new Binding[types.length];
-      for (int i = 0; i < parameters.length; i++) {
-        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, method);
-      }
-    }
-
-    @SuppressWarnings("unchecked") // We defined 'T' in terms of the method's return type.
-    @Override public T get() {
-      Object[] args = new Object[parameters.length];
-      for (int i = 0; i < parameters.length; i++) {
-        args[i] = parameters[i].get();
-      }
-      try {
-        return (T) method.invoke(instance, args);
-      } catch (InvocationTargetException e) {
-        Throwable cause = e.getCause();
-        throw cause instanceof RuntimeException
-            ? (RuntimeException) cause
-            : new RuntimeException(cause);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding<?> binding : parameters) {
-        get.add(binding);
-      }
-    }
-
-    @Override public void injectMembers(T t) {
-      throw new AssertionError("Provides method bindings are not MembersInjectors");
-    }
-
-    @Override public String toString() {
-      return method.toString();
-    }
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
deleted file mode 100644
index 99ead709e..000000000
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.plugins.reflect;
-
-import dagger.Module;
-import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
-import javax.inject.Inject;
-
-/**
- * Uses reflection to create bindings, module adapters and static injections.
- */
-public final class ReflectivePlugin implements Plugin {
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
-    Class<?> c;
-    try {
-      c = Class.forName(className);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-
-    if (c.isInterface()) {
-      return null;
-    }
-
-    return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
-  }
-
-  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    Module annotation = moduleClass.getAnnotation(Module.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
-    }
-    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    List<Field> fields = new ArrayList<Field>();
-    for (Field field : injectedClass.getDeclaredFields()) {
-      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
-        field.setAccessible(true);
-        fields.add(field);
-      }
-    }
-    if (fields.isEmpty()) {
-      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
-    }
-    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
deleted file mode 100644
index 519d7cebc..000000000
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.plugins.reflect;
-
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Field;
-
-/**
- * Uses reflection to inject the static fields of a class.
- */
-final class ReflectiveStaticInjection extends StaticInjection {
-  private final Field[] fields;
-  private Binding<?>[] bindings;
-
-  public ReflectiveStaticInjection(Field[] fields) {
-    this.fields = fields;
-  }
-
-  @Override public void attach(Linker linker) {
-    bindings = new Binding<?>[fields.length];
-    for (int i = 0; i < fields.length; i++) {
-      Field field = fields[i];
-      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field);
-    }
-  }
-
-  @Override public void inject() {
-    try {
-      for (int f = 0; f < fields.length; f++) {
-        fields[f].set(null, bindings[f].get());
-      }
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/package-info.java b/core/src/main/java/dagger/package-info.java
new file mode 100644
index 000000000..e5cc67f39
--- /dev/null
+++ b/core/src/main/java/dagger/package-info.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the public API for the <a href="http://google.github.io/dagger/">Dagger
+ * 2</a> dependency injection framework.  By building upon
+ * <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>, Dagger 2 provides an
+ * annotation-driven API for dependency injection whose implementation is entirely generated at
+ * compile time by <a href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation
+ * processors</a>.
+ *
+ * <p>The entry point into the API is the {@link Component}, which annotates abstract types for
+ * Dagger 2 to implement.  The dependency graph is configured using using annotations such as
+ * {@link Module}, {@link Provides} and {@link javax.inject.Inject}.
+ *
+ * <p>{@code dagger.internal.codegen.ComponentProcessor} is the processor responsible for generating
+ * the implementation.  Dagger uses the annotation procesor
+ * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so
+ * explict build configuration shouldn't be necessary.
+ */
+package dagger;
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
deleted file mode 100644
index a4b9c9772..000000000
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import java.util.Arrays;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
-
-public final class ExtensionTest {
-  @Singleton
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject A a;
-  }
-
-  @Singleton
-  static class C {
-    @Inject A a;
-    @Inject B b;
-  }
-
-  static class D {
-    @Inject A a;
-    @Inject B b;
-    @Inject C c;
-  }
-
-  @Module(entryPoints = { A.class, B.class }) static class RootModule { }
-
-  @Module(addsTo = RootModule.class, entryPoints = { C.class, D.class })
-  static class ExtensionModule { }
-
-  @Test public void basicExtension() {
-    assertNotNull(ObjectGraph.create(new RootModule()).plus(new ExtensionModule()));
-  }
-
-  @Test public void basicInjection() {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
-    assertThat(root.get(A.class)).isNotNull();
-    assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
-    assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
-    assertFailNoEntryPoint(root, C.class); // Not declared in RootModule.
-    assertFailNoEntryPoint(root, D.class); // Not declared in RootModule.
-
-    // Extension graph behaves as the root graph would for root-ish things.
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    assertThat(root.get(A.class)).isSameAs(extension.get(A.class));
-    assertThat(root.get(B.class)).isNotSameAs(extension.get(B.class));
-    assertThat(root.get(B.class).a).isSameAs(extension.get(B.class).a);
-
-    assertThat(extension.get(C.class).a).isNotNull();
-    assertThat(extension.get(D.class).c).isNotNull();
-  }
-
-  @Test public void scopedGraphs() {
-    ObjectGraph app = ObjectGraph.create(new RootModule());
-    assertThat(app.get(A.class)).isNotNull();
-    assertThat(app.get(A.class)).isSameAs(app.get(A.class));
-    assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
-    assertFailNoEntryPoint(app, C.class);
-    assertFailNoEntryPoint(app, D.class);
-
-    ObjectGraph request1 = app.plus(new ExtensionModule());
-    ObjectGraph request2 = app.plus(new ExtensionModule());
-    for (ObjectGraph request : Arrays.asList(request1, request2)) {
-      assertThat(request.get(A.class)).isNotNull();
-      assertThat(request.get(A.class)).isSameAs(request.get(A.class));
-      assertThat(request.get(B.class)).isNotSameAs(request.get(B.class));
-      assertThat(request.get(C.class)).isNotNull();
-      assertThat(request.get(C.class)).isSameAs(request.get(C.class));
-      assertThat(request.get(D.class)).isNotSameAs(request.get(D.class));
-    }
-
-    // Singletons are one-per-graph-instance where they are declared.
-    assertThat(request1.get(C.class)).isNotSameAs(request2.get(C.class));
-    // Singletons that come from common roots should be one-per-common-graph-instance.
-    assertThat(request1.get(C.class).a).isSameAs(request2.get(C.class).a);
-  }
-
-  private void assertFailNoEntryPoint(ObjectGraph graph, Class<?> clazz) {
-    try {
-      assertThat(graph.get(clazz)).isNull();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).contains("No entry point");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
deleted file mode 100644
index 18d685a0b..000000000
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import javax.inject.Inject;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-public final class InjectStaticsTest {
-  @Before public void setUp() {
-    InjectsOneField.staticField = null;
-    InjectsStaticAndNonStatic.staticField = null;
-  }
-
-  public static class InjectsOneField {
-    @Inject static String staticField;
-  }
-
-  public static class InjectsStaticAndNonStatic {
-    @Inject Integer nonStaticField;
-    @Inject static String staticField;
-  }
-
-  @Test public void injectStatics() {
-    @Module(staticInjections = InjectsOneField.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "static";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertThat(InjectsOneField.staticField).isNull();
-    graph.injectStatics();
-    assertThat(InjectsOneField.staticField).isEqualTo("static");
-  }
-
-  @Test public void instanceFieldsNotInjectedByInjectStatics() {
-    @Module(
-        staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "static";
-      }
-      @Provides Integer provideInteger() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    graph.injectStatics();
-    assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
-  }
-
-  @Test public void staticFieldsNotInjectedByInjectMembers() {
-    @Module(
-        staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new AssertionError();
-      }
-      @Provides Integer provideInteger() {
-        return 5;
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
-    graph.inject(object);
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    assertThat(object.nonStaticField).isEqualTo(5);
-  }
-}
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
deleted file mode 100644
index bb22100f1..000000000
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-/**
- * Tests of injection of Lazy<T> bindings.
- */
-public final class InjectionOfLazyTest {
-  @Test public void lazyValueCreation() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Lazy<Integer> i;
-      @Inject Lazy<Integer> j;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    assertEquals(1, ep.i.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(2, ep.j.get().intValue());
-    assertEquals(1, ep.i.get().intValue());
-    assertEquals(2, counter.get());
-  }
-
-  @Test public void lazyNullCreation() {
-    final AtomicInteger provideCounter = new AtomicInteger(0);
-    class TestEntryPoint {
-      @Inject Lazy<String> i;
-    }
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideInteger() {
-        provideCounter.incrementAndGet();
-        return null;
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, provideCounter.get());
-    assertNull(ep.i.get());
-    assertEquals(1, provideCounter.get());
-    assertNull(ep.i.get()); // still null
-    assertEquals(1, provideCounter.get()); // still only called once.
-  }
-
-  @Test public void providerOfLazyOfSomething() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Provider<Lazy<Integer>> providerOfLazyInteger;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    Lazy<Integer> i = ep.providerOfLazyInteger.get();
-    assertEquals(1, i.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(1, i.get().intValue());
-    Lazy<Integer> j = ep.providerOfLazyInteger.get();
-    assertEquals(2, j.get().intValue());
-    assertEquals(2, counter.get());
-    assertEquals(1, i.get().intValue());
-  }
-
-  @Test public void sideBySideLazyVsProvider() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Provider<Integer> providerOfInteger;
-      @Inject Lazy<Integer> lazyInteger;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    assertEquals(0, counter.get());
-    assertEquals(1, ep.lazyInteger.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(2, ep.providerOfInteger.get().intValue()); // fresh instance
-    assertEquals(1, ep.lazyInteger.get().intValue()); // still the same instance
-    assertEquals(2, counter.get());
-    assertEquals(3, ep.providerOfInteger.get().intValue()); // fresh instance
-    assertEquals(1, ep.lazyInteger.get().intValue()); // still the same instance.
-  }
-
-  private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
-  }
-}
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
deleted file mode 100644
index abd6c6bbc..000000000
--- a/core/src/test/java/dagger/InjectionTest.java
+++ /dev/null
@@ -1,731 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import java.util.AbstractList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.RandomAccess;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Named;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class InjectionTest {
-  @Test public void basicInjection() {
-    class TestEntryPoint {
-      @Inject Provider<G> gProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides E provideE(F f) {
-        return new E(f);
-      }
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    G g = entryPoint.gProvider.get();
-    assertThat(g.a).isNotNull();
-    assertThat(g.b).isNotNull();
-    assertThat(g.c).isNotNull();
-    assertThat(g.d).isNotNull();
-    assertThat(g.e).isNotNull();
-    assertThat(g.e.f).isNotNull();
-  }
-
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject B() {}
-  }
-
-  @Singleton
-  static class C {
-    @Inject C() {}
-  }
-
-  @Singleton
-  static class D {
-    @Inject D() {}
-  }
-
-  static class E {
-    F f;
-    E(F f) {
-      this.f = f;
-    }
-  }
-
-  static class F {}
-
-  static class G {
-    @Inject A a;
-    @Inject B b;
-    C c;
-    D d;
-    @Inject E e;
-    @Inject G(C c, D d) {
-      this.c = c;
-      this.d = d;
-    }
-  }
-
-  @Test public void providerInjection() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-
-    assertThat(entryPoint.aProvider.get()).isNotNull();
-    assertThat(entryPoint.aProvider.get()).isNotNull();
-    assertThat(entryPoint.aProvider.get()).isNotSameAs(entryPoint.aProvider.get());
-  }
-
-
-  @Test public void singletons() {
-    class TestEntryPoint {
-      @Inject Provider<F> fProvider;
-      @Inject Provider<I> iProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
-    assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
-  }
-
-  @Singleton
-  static class I {
-    @Inject I() {}
-  }
-
-  @Test public void bindingAnnotations() {
-    final A one = new A();
-    final A two = new A();
-
-    class TestEntryPoint {
-      @Inject A a;
-      @Inject @Named("one") A aOne;
-      @Inject @Named("two") A aTwo;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Named("one") A getOne() {
-        return one;
-      }
-      @Provides @Named("two") A getTwo() {
-        return two;
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.a).isNotNull();
-    assertThat(one).isSameAs(entryPoint.aOne);
-    assertThat(two).isSameAs(entryPoint.aTwo);
-  }
-
-  @Test public void singletonBindingAnnotationAndProvider() {
-    class TestEntryPoint {
-      @Inject Provider<L> lProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      A a1;
-      A a2;
-
-      @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
-        a1 = aProvider.get();
-        a2 = aProvider.get();
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
-    entryPoint.lProvider.get();
-
-    assertThat(module.a1).isNotNull();
-    assertThat(module.a2).isNotNull();
-    assertThat(module.a1).isNotSameAs(module.a2);
-    assertThat(entryPoint.lProvider.get()).isSameAs(entryPoint.lProvider.get());
-  }
-
-  @Singleton
-  public static class L {
-    @Inject @Named("one") F f;
-    @Inject Provider<L> lProvider;
-  }
-
-  @Test public void singletonInGraph() {
-    class TestEntryPoint {
-      @Inject N n1;
-      @Inject N n2;
-      @Inject F f1;
-      @Inject F f2;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-
-    assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f1);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.fProvider.get());
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.fProvider.get());
-  }
-
-  public static class N {
-    @Inject F f1;
-    @Inject F f2;
-    @Inject Provider<F> fProvider;
-  }
-
-  @Test public void noJitBindingsForAnnotations() {
-    class TestEntryPoint {
-      @Inject @Named("a") A a;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void injectableSupertypes() {
-    class TestEntryPoint {
-      @Inject Q q;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.q.f).isNotNull();
-  }
-
-  @Test public void uninjectableSupertypes() {
-    class TestEntryPoint {
-      @Inject T t;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.t).isNotNull();
-  }
-
-  public static class P {
-    @Inject F f;
-  }
-
-  public static class Q extends P {
-    @Inject Q() {}
-  }
-
-  static class S {
-  }
-
-  public static class T extends S {
-    @Inject T() {}
-  }
-
-  @Test public void singletonsAreNotEager() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      boolean sInjected = false;
-
-      @Provides F provideF(R r) {
-        return new F();
-      }
-
-      @Provides @Singleton S provideS() {
-        sInjected = true;
-        return new S();
-      }
-    }
-
-    R.injected = false;
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
-
-    assertThat(R.injected).isFalse();
-    assertThat(module.sInjected).isFalse();
-  }
-
-  @Singleton
-  static class R {
-    static boolean injected = false;
-    @Inject R() {
-      injected = true;
-    }
-  }
-
-  @Test public void providerMethodsConflict() {
-    @Module
-    class TestModule {
-      @Provides A provideA1() {
-        throw new AssertionError();
-      }
-      @Provides A provideA2() {
-        throw new AssertionError();
-      }
-    }
-
-    try {
-      ObjectGraph.create(new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void singletonsInjectedOnlyIntoProviders() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton A provideA() {
-        return new A();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
-  }
-
-  @Test public void moduleOverrides() {
-    class TestEntryPoint {
-      @Inject Provider<E> eProvider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class BaseModule {
-      @Provides F provideF() {
-        throw new AssertionError();
-      }
-      @Provides E provideE(F f) {
-        return new E(f);
-      }
-    }
-
-    @Module(overrides = true)
-    class OverridesModule {
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new BaseModule(), new OverridesModule()).inject(entryPoint);
-    E e = entryPoint.eProvider.get();
-    assertThat(e).isNotNull();
-    assertThat(e.f).isNotNull();
-  }
-
-  @Test public void noJitBindingsForInterfaces() {
-    class TestEntryPoint {
-      @Inject RandomAccess randomAccess;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void noProvideBindingsForAbstractClasses() {
-    class TestEntryPoint {
-      @Inject AbstractList<?> abstractList;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  static class ExtendsParameterizedType extends AbstractList<Integer> {
-    @Inject String string;
-    @Override public Integer get(int i) {
-      throw new AssertionError();
-    }
-    @Override public int size() {
-      throw new AssertionError();
-    }
-  }
-
-  /**
-   * We've had bugs where we look for the wrong keys when a class extends a
-   * parameterized class. Explicitly test that we can inject such classes.
-   */
-  @Test public void extendsParameterizedType() {
-    class TestEntryPoint {
-      @Inject ExtendsParameterizedType extendsParameterizedType;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
-  }
-
-  @Test public void injectParameterizedType() {
-    class TestEntryPoint {
-      @Inject List<String> listOfStrings;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides List<String> provideList() {
-        return Arrays.asList("a", "b");
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
-  }
-
-  @Test public void injectWildcardType() {
-    class TestEntryPoint {
-      @Inject List<? extends Number> listOfNumbers;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides List<? extends Number> provideList() {
-        return Arrays.asList(1, 2);
-      }
-    }
-
-    try {
-      ObjectGraph.create(new TestModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
-    class Parameterized<T> {
-      @Inject String string;
-    }
-
-    class TestEntryPoint {
-      @Inject Parameterized<Long> parameterized;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void moduleWithNoProvidesMethods() {
-    @Module
-    class TestModule {
-    }
-
-    ObjectGraph.create(new TestModule());
-  }
-
-  @Test public void getInstance() {
-    final AtomicInteger next = new AtomicInteger(0);
-
-    @Module(entryPoints = Integer.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return next.getAndIncrement();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertEquals(0, (int) graph.get(Integer.class));
-    assertEquals(1, (int) graph.get(Integer.class));
-  }
-
-  @Test public void getInstanceRequiresEntryPoint() {
-    @Module
-    class TestModule {
-      @Provides Integer provideInteger() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(Integer.class);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void getInstanceOfPrimitive() {
-    @Module(entryPoints = int.class)
-    class TestModule {
-      @Provides int provideInt() {
-        return 1;
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertEquals(1, (int) graph.get(int.class));
-  }
-
-  @Test public void getInstanceOfArray() {
-    @Module(entryPoints = int[].class)
-    class TestModule {
-      @Provides int[] provideIntArray() {
-        return new int[] { 1, 2, 3 };
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertEquals("[1, 2, 3]", Arrays.toString(graph.get(int[].class)));
-  }
-
-  @Test public void getInstanceAndInjectMembersUseDifferentKeys() {
-    class BoundTwoWays {
-      @Inject String s;
-    }
-
-    @Module(entryPoints = BoundTwoWays.class)
-    class TestModule {
-      @Provides
-      BoundTwoWays provideBoundTwoWays() {
-        BoundTwoWays result = new BoundTwoWays();
-        result.s = "Pepsi";
-        return result;
-      }
-
-      @Provides String provideString() {
-        return "Coke";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    BoundTwoWays provided = graph.get(BoundTwoWays.class);
-    assertEquals("Pepsi", provided.s);
-
-    BoundTwoWays membersInjected = new BoundTwoWays();
-    graph.inject(membersInjected);
-    assertEquals("Coke", membersInjected.s);
-  }
-
-  static class NoInjections {
-    NoInjections(Void noDefaultConstructorEither) {
-    }
-  }
-
-  @Test public void entryPointNeedsNoInjectAnnotation() {
-    @Module(entryPoints = NoInjections.class)
-    class TestModule {
-    }
-
-    ObjectGraph.create(new TestModule()).validate();
-  }
-
-  static class InjectMembersOnly {
-    InjectMembersOnly(Void noInjectableConstructor) {
-    }
-    @Inject String string;
-  }
-
-  @Test public void cannotGetOnMembersOnlyInjectionPoint() {
-    @Module(entryPoints = InjectMembersOnly.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(InjectMembersOnly.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    InjectMembersOnly instance = new InjectMembersOnly(null);
-    graph.inject(instance);
-    assertThat(instance.string).isEqualTo("injected");
-  }
-
-  @Test public void nonEntryPointNeedsInjectAnnotation() {
-    @Module
-    class TestModule {
-      @Provides String provideString(NoInjections noInjections) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  static class TwoAtInjectConstructors {
-    @Inject TwoAtInjectConstructors() {
-    }
-    @Inject TwoAtInjectConstructors(String s) {
-    }
-  }
-
-  @Test public void twoAtInjectConstructorsIsRejected() {
-    @Module(entryPoints = TwoAtInjectConstructors.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void runtimeProvidesMethodsExceptionsAreNotWrapped() {
-    class TestEntryPoint {
-      @Inject String string;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new ClassCastException("foo");
-      }
-    }
-
-    try {
-      ObjectGraph.create(new TestModule()).inject(new TestEntryPoint());
-      fail();
-    } catch (ClassCastException e) {
-      assertThat(e.getMessage()).isEqualTo("foo");
-    }
-  }
-
-  static class ThrowsOnConstruction {
-    @Inject ThrowsOnConstruction() {
-      throw new ClassCastException("foo");
-    }
-  }
-
-  @Test public void runtimeConstructorExceptionsAreNotWrapped() {
-    @Module(entryPoints = ThrowsOnConstruction.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.create(new TestModule()).get(ThrowsOnConstruction.class);
-      fail();
-    } catch (ClassCastException e) {
-      assertThat(e.getMessage()).isEqualTo("foo");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
deleted file mode 100644
index c5a3a4285..000000000
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import javax.inject.Inject;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-public final class LazyInjectionTest {
-  @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
-    @Module(entryPoints = LazyEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph.create(new TestModule());
-    assertThat(lazyEntryPointLoaded).isFalse();
-  }
-
-  private static boolean lazyEntryPointLoaded = false;
-  static class LazyEntryPoint {
-    static {
-      lazyEntryPointLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseProvidesParametersToBeLoaded() {
-    @Module
-    class TestModule {
-      @Provides Object provideObject(LazyProvidesParameter parameter) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph.create(new TestModule());
-    assertThat(lazyProvidesParameterLoaded).isFalse();
-  }
-
-  private static boolean lazyProvidesParameterLoaded = false;
-  static class LazyProvidesParameter {
-    static {
-      lazyProvidesParameterLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseProvidesResultToBeLoaded() {
-    @Module
-    class TestModule {
-      @Provides LazyProvidesResult provideLazy() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph.create(new TestModule());
-    assertThat(lazyProvidesResultLoaded).isFalse();
-  }
-
-  private static boolean lazyProvidesResultLoaded = false;
-  static class LazyProvidesResult {
-    static {
-      lazyProvidesResultLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
-    @Module(staticInjections = LazyInjectStatics.class)
-    class TestModule {
-    }
-
-    ObjectGraph.create(new TestModule());
-    assertThat(LazyInjectStaticsLoaded).isFalse();
-  }
-
-  private static boolean LazyInjectStaticsLoaded = false;
-  static class LazyInjectStatics {
-    static {
-      LazyInjectStaticsLoaded = true;
-    }
-  }
-
-  @Test public void lazyInjectionRequiresProvidesMethod() {
-    class TestEntryPoint {
-      @Inject String injected;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString(Integer integer) {
-        return integer.toString();
-      }
-      @Provides Integer provideInteger() {
-        return 5;
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.injected).isEqualTo("5");
-  }
-}
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
deleted file mode 100644
index 59f288313..000000000
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * Tests MembersInjector injection, and how object graph features interact with
- * types unconstructable types (types that support members injection only).
- */
-public final class MembersInjectorTest {
-  @Test public void injectMembers() {
-    class TestEntryPoint {
-      @Inject MembersInjector<Injectable> membersInjector;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class StringModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
-    Injectable injectable = new Injectable();
-    entryPoint.membersInjector.injectMembers(injectable);
-    assertThat(injectable.injected).isEqualTo("injected");
-  }
-
-  static class Injectable {
-    @Inject String injected;
-  }
-
-  static class Unconstructable {
-    final String constructor;
-    @Inject String injected;
-    Unconstructable(String constructor) {
-      this.constructor = constructor;
-    }
-  }
-
-  @Test public void membersInjectorOfUnconstructableIsOkay() {
-    class TestEntryPoint {
-      @Inject MembersInjector<Unconstructable> membersInjector;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class StringModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
-    Unconstructable object = new Unconstructable("constructor");
-    entryPoint.membersInjector.injectMembers(object);
-    assertThat(object.constructor).isEqualTo("constructor");
-    assertThat(object.injected).isEqualTo("injected");
-  }
-
-
-  @Test public void injectionOfUnconstructableFails() {
-    class TestEntryPoint {
-      @Inject Unconstructable unconstructable;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void instanceInjectionOfMembersOnlyType() {
-    class TestEntryPoint {
-      @Inject Provider<Unconstructable> provider;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void rejectUnconstructableSingleton() {
-    class TestEntryPoint {
-      @Inject MembersInjector<UnconstructableSingleton> membersInjector;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Singleton
-  static class UnconstructableSingleton {
-    final String constructor;
-    @Inject String injected;
-    UnconstructableSingleton(String constructor) {
-      this.constructor = constructor;
-    }
-  }
-
-  class NonStaticInner {
-    @Inject String injected;
-  }
-
-  @Test public void membersInjectorOfNonStaticInnerIsOkay() {
-    class TestEntryPoint {
-      @Inject MembersInjector<NonStaticInner> membersInjector;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    NonStaticInner nonStaticInner = new NonStaticInner();
-    entryPoint.membersInjector.injectMembers(nonStaticInner);
-    assertThat(nonStaticInner.injected).isEqualTo("injected");
-  }
-
-  @Test public void instanceInjectionOfNonStaticInnerFailsEarly() {
-    class TestEntryPoint {
-      @Inject NonStaticInner nonStaticInner;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void providesMethodsAndMembersInjectionDoNotConflict() {
-    class InjectsString {
-      @Inject String value;
-    }
-
-    class TestEntryPoint {
-      @Inject Provider<InjectsString> provider;
-      @Inject MembersInjector<InjectsString> membersInjector;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides InjectsString provideInjectsString() {
-        InjectsString result = new InjectsString();
-        result.value = "provides";
-        return result;
-      }
-      @Provides String provideString() {
-        return "members";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-
-    InjectsString provided = entryPoint.provider.get();
-    assertThat(provided.value).isEqualTo("provides");
-
-    InjectsString membersInjected = new InjectsString();
-    entryPoint.membersInjector.injectMembers(membersInjected);
-    assertThat(membersInjected.value).isEqualTo("members");
-  }
-}
\ No newline at end of file
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
deleted file mode 100644
index b72f2e967..000000000
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import javax.inject.Inject;
-import org.junit.Test;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ModuleIncludesTest {
-  static class TestEntryPoint {
-    @Inject String s;
-  }
-
-  @Module(entryPoints = TestEntryPoint.class)
-  static class ModuleWithEntryPoint {
-  }
-
-  @Test public void childModuleWithEntryPoint() {
-    @Module(includes = ModuleWithEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
-    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  static class TestStaticInjection {
-    @Inject static String s;
-  }
-
-  @Module(staticInjections = TestStaticInjection.class)
-  static class ModuleWithStaticInjection {
-  }
-
-  @Test public void childModuleWithStaticInjection() {
-    @Module(includes = ModuleWithStaticInjection.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
-    TestStaticInjection.s = null;
-    objectGraph.injectStatics();
-    assertThat(TestStaticInjection.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithBinding {
-    @Provides String provideString() {
-      return "injected";
-    }
-  }
-
-  @Test public void childModuleWithBinding() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
-
-    @Module(
-        entryPoints = TestEntryPoint.class,
-        includes = ModuleWithBinding.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module(includes = ModuleWithBinding.class)
-  static class ModuleWithChildModule {
-  }
-
-  @Test public void childModuleWithChildModule() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
-
-    @Module(
-        entryPoints = TestEntryPoint.class,
-        includes = ModuleWithChildModule.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithConstructor {
-    private final String value;
-
-    ModuleWithConstructor(String value) {
-      this.value = value;
-    }
-
-    @Provides String provideString() {
-      return value;
-    }
-  }
-
-  @Test public void childModuleMissingManualConstruction() {
-    @Module(includes = ModuleWithConstructor.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.create(new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void childModuleWithManualConstruction() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
-
-    @Module(
-        entryPoints = TestEntryPoint.class,
-        includes = ModuleWithConstructor.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.create(new ModuleWithConstructor("a"), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("a");
-  }
-
-  static class A {}
-
-  static class B { @Inject A a; }
-
-  @Module(entryPoints = A.class) public static class TestModuleA {
-    @Provides A a() { return new A(); }
-  }
-
-  @Module(includes = TestModuleA.class, entryPoints = B.class) public static class TestModuleB {}
-
-  @Test public void autoInstantiationOfModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(TestModuleA.class);
-    assertThat(objectGraph.get(A.class)).isNotNull();
-  }
-
-  @Test public void autoInstantiationOfIncludedModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModuleB()); // TestModuleA auto-created.
-    assertThat(objectGraph.get(A.class)).isNotNull();
-    assertThat(objectGraph.get(B.class).a).isNotNull();
-  }
-}
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
deleted file mode 100644
index 2bd75853c..000000000
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import javax.inject.Inject;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public final class ProblemDetectorTest {
-  @Test public void atInjectCircularDependenciesDetected() {
-    class TestEntryPoint {
-      @Inject Rock rock;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (RuntimeException expected) {
-    }
-  }
-
-  @Test public void providesCircularDependenciesDetected() {
-    @Module
-    class TestModule {
-      @Provides Integer provideInteger(String s) {
-        throw new AssertionError();
-      }
-      @Provides String provideString(Integer i) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (RuntimeException expected) {
-    }
-  }
-
-  @Test public void validateLazy() {
-    @Module
-    class TestModule {
-      @Provides Integer dependOnLazy(Lazy<String> lazyString) {
-        throw new AssertionError();
-      }
-      @Provides String provideLazyValue() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    graph.validate();
-  }
-
-  static class Rock {
-    @Inject Scissors scissors;
-  }
-
-  static class Scissors {
-    @Inject Paper paper;
-  }
-
-  static class Paper {
-    @Inject Rock rock;
-  }
-}
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
deleted file mode 100644
index 7e3913528..000000000
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.inject.Inject;
-import javax.inject.Named;
-import javax.inject.Singleton;
-import org.junit.Test;
-
-import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-public final class SetBindingTest {
-  @Test public void multiValueBindings_SingleModule() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideFirstString() { return "string1"; }
-      @Provides(type=SET) String provideSecondString() { return "string2"; }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-  }
-
-  @Test public void multiValueBindings_MultiModule() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module
-    class TestIncludesModule {
-      @Provides(type=SET) String provideSecondString() { return "string2"; }
-    }
-
-    @Module(entryPoints = TestEntryPoint.class, includes = TestIncludesModule.class)
-    class TestModule {
-      @Provides(type=SET) String provideFirstString() { return "string1"; }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
-        new TestModule(), new TestIncludesModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-  }
-
-  @Test public void multiValueBindings_WithSingletonAndDefaultValues() {
-    final AtomicInteger singletonCounter = new AtomicInteger(100);
-    final AtomicInteger defaultCounter = new AtomicInteger(200);
-    class TestEntryPoint {
-      @Inject Set<Integer> objects1;
-      @Inject Set<Integer> objects2;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set(100, 200), ep.objects1);
-    assertEquals(set(100, 201), ep.objects2);
-  }
-
-  @Test public void multiValueBindings_WithSingletonsAcrossMultipleEntryPoints() {
-    final AtomicInteger singletonCounter = new AtomicInteger(100);
-    final AtomicInteger defaultCounter = new AtomicInteger(200);
-    class TestEntryPoint1 {
-      @Inject Set<Integer> objects1;
-    }
-    class TestEntryPoint2 {
-      @Inject Set<Integer> objects2;
-    }
-
-    @Module(entryPoints = { TestEntryPoint1.class, TestEntryPoint2.class })
-    class TestModule {
-      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    TestEntryPoint1 ep1 = graph.inject(new TestEntryPoint1());
-    TestEntryPoint2 ep2 = graph.inject(new TestEntryPoint2());
-    assertEquals(set(100, 200), ep1.objects1);
-    assertEquals(set(100, 201), ep2.objects2);
-
- }
-
-  @Test public void multiValueBindings_WithQualifiers() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-      @Inject @Named("foo") Set<String> fooStrings;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideString1() { return "string1"; }
-      @Provides(type=SET) String provideString2() { return "string2"; }
-      @Provides(type=SET) @Named("foo") String provideString3() { return "string3"; }
-      @Provides(type=SET) @Named("foo") String provideString4() { return "string4"; }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-    assertEquals(set("string4", "string3"), ep.fooStrings);
-  }
-
-  // TODO(cgruber): Move this into an example project.
-  @Test public void sampleMultiBindingLogger() {
-    class TestEntryPoint {
-      @Inject Logger logger;
-      public void doStuff() {
-        Throwable t = new NullPointerException("Naughty Naughty");
-        this.logger.log("Logging an error", t);
-      }
-    }
-
-    final AtomicReference<String> logoutput = new AtomicReference<String>();
-    @Module
-    class LogModule {
-      @Provides(type=SET) LogSink outputtingLogSink() {
-        return new LogSink() {
-          @Override public void log(LogMessage message) {
-            StringWriter sw = new StringWriter();
-            message.error.printStackTrace(new PrintWriter(sw));
-            logoutput.set(message.message + "\n" + sw.getBuffer().toString());
-          }
-        };
-      }
-    }
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) LogSink nullLogger() {
-        return new LogSink() { @Override public void log(LogMessage message) {} };
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),new TestModule(), new LogModule());
-    assertNull(logoutput.get());
-    ep.doStuff();
-    assertNotNull(logoutput.get());
-    assertThat(logoutput.get()).contains("Naughty Naughty");
-    assertThat(logoutput.get()).contains("NullPointerException");
-  }
-
-  @Test public void validateSetBinding() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(entryPoints = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideString1() { return "string1"; }
-      @Provides(type=SET) String provideString2() { return "string2"; }
-    }
-
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
-    graph.validate();
-  }
-
-  static class Logger {
-    @Inject Set<LogSink> loggers;
-    public void log(String text, Throwable error) {
-      LogMessage m = new LogMessage(text, error);
-      for (LogSink sink : loggers) {
-        sink.log(m);
-      }
-    }
-  }
-
-  static class LogMessage {
-    public final String message;
-    public final Throwable error;
-    public LogMessage (String message, Throwable error) {
-      this.message = message;
-      this.error = error;
-    }
-  }
-
-  static interface LogSink {
-    void log(LogMessage message);
-  }
-
-  private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
-  }
-
-  private <T> Set<T> set(T... ts) {
-    return new LinkedHashSet<T>(Arrays.asList(ts));
-  }
-
-}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
new file mode 100644
index 000000000..579e0405f
--- /dev/null
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.Uninterruptibles;
+import dagger.Lazy;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class DoubleCheckLazyTest {
+  @Test public void get() throws Exception {
+    int numThreads = 10;
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+
+    final CountDownLatch latch = new CountDownLatch(numThreads);
+    LatchedProvider provider = new LatchedProvider(latch);
+    final Lazy<Object> lazy = DoubleCheckLazy.create(provider);
+
+    List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
+    for (int i = 0; i < numThreads; i++) {
+      tasks.add(new Callable<Object>() {
+        @Override public Object call() throws Exception {
+          latch.countDown();
+          return lazy.get();
+        }
+      });
+    }
+
+    List<Future<Object>> futures = executor.invokeAll(tasks);
+
+    assert_().that(provider.provisions.get()).isEqualTo(1);
+    Set<Object> results = Sets.newIdentityHashSet();
+    for (Future<Object> future : futures) {
+      results.add(future.get());
+    }
+    assert_().that(results.size()).isEqualTo(1);
+  }
+
+  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
+  @Ignore @Test public void get_null() {
+    Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
+      @Override public Object get() {
+        return null;
+      }
+    });
+    try {
+      lazy.get();
+      fail();
+    } catch (NullPointerException expected) {}
+  }
+
+  private static class LatchedProvider implements Provider<Object> {
+    final AtomicInteger provisions;
+    final CountDownLatch latch;
+
+    LatchedProvider(CountDownLatch latch) {
+      this.latch = latch;
+      this.provisions = new AtomicInteger();
+    }
+
+    @Override
+    public Object get() {
+      if (latch != null) {
+        Uninterruptibles.awaitUninterruptibly(latch);
+      }
+      provisions.incrementAndGet();
+      return new Object();
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
new file mode 100644
index 000000000..acaf20d79
--- /dev/null
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+
+@RunWith(JUnit4.class)
+public final class InstanceFactoryTest {
+  @Rule public final ExpectedException thrown = ExpectedException.none();
+
+  @Test public void instanceFactory() {
+    Object instance = new Object();
+    Factory<Object> factory = InstanceFactory.create(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
+  }
+
+  @Test public void create_throwsNullPointerException() {
+    thrown.expect(NullPointerException.class);
+    InstanceFactory.create(null);
+  }
+}
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
deleted file mode 100644
index d99158a0d..000000000
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import dagger.Provides;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.List;
-import java.util.Map;
-import javax.inject.Named;
-import javax.inject.Provider;
-import org.junit.Test;
-
-import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
-
-public final class KeysTest {
-  int primitive;
-  @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
-    assertThat(fieldKey("primitive"))
-        .isEqualTo("java.lang.Integer");
-  }
-
-  Map<String, List<Integer>> mapStringListInteger;
-  @Test public void parameterizedTypes() throws NoSuchFieldException {
-    assertThat(fieldKey("mapStringListInteger"))
-        .isEqualTo("java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>");
-  }
-
-  Map<String, int[]> mapStringArrayInt;
-  @Test public void parameterizedTypeOfPrimitiveArray() throws NoSuchFieldException {
-    assertThat(fieldKey("mapStringArrayInt"))
-        .isEqualTo("java.util.Map<java.lang.String, int[]>");
-  }
-
-  @Named("foo") String annotatedType;
-  @Test public void annotatedType() throws NoSuchFieldException {
-    assertThat(fieldKey("annotatedType"))
-        .isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
-  }
-
-  String className;
-  @Test public void testGetClassName() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("className")))
-        .isEqualTo("java.lang.String");
-  }
-
-  @Named("foo") String classNameWithAnnotation;
-  @Test public void testGetClassNameWithoutAnnotation() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameWithAnnotation")))
-        .isEqualTo("java.lang.String");
-  }
-
-  String[] classNameArray;
-  @Test public void testGetClassNameArray() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameArray"))).isNull();
-  }
-
-  List<String> classNameParameterized;
-  @Test public void testGetClassParameterized() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameParameterized"))).isNull();
-  }
-
-  @Named("foo") String annotated;
-  @Test public void testAnnotated() throws NoSuchFieldException {
-    assertThat(fieldKey("annotated")).isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
-    assertThat(Keys.isAnnotated(fieldKey("annotated"))).isTrue();
-  }
-
-  String notAnnotated;
-  @Test public void testIsAnnotatedFalse() throws NoSuchFieldException {
-    assertThat(Keys.isAnnotated(fieldKey("notAnnotated"))).isFalse();
-  }
-
-  Provider<String> providerOfType;
-  String providedType;
-  @Test public void testGetDelegateKey() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("providerOfType")))
-        .isEqualTo(fieldKey("providedType"));
-  }
-
-  @Named("/@") Provider<String> providerOfTypeAnnotated;
-  @Named("/@") String providedTypeAnnotated;
-  @Test public void testGetDelegateKeyWithAnnotation() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("providerOfTypeAnnotated")))
-        .isEqualTo(fieldKey("providedTypeAnnotated"));
-  }
-
-  @Named("/@") MembersInjector<String> membersInjectorOfType;
-  @Named("/@") String injectedType;
-  @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("membersInjectorOfType")))
-        .isEqualTo("members/java.lang.String");
-  }
-
-  @Named("/@") Lazy<String> lazyAnnotatedString;
-  @Named("/@") String eagerAnnotatedString;
-  @Test public void testAnnotatedGetLazyKey() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("lazyAnnotatedString")))
-        .isEqualTo(fieldKey("eagerAnnotatedString"));
-  }
-
-  Lazy<String> lazyString;
-  String eagerString;
-  @Test public void testGetLazyKey() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("lazyString"))).isEqualTo(fieldKey("eagerString"));
-  }
-
-  @Test public void testGetLazyKey_WrongKeyType() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
-  }
-
-  @Provides(type=SET) String elementProvides() { return "foo"; }
-
-  @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
-    Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
-        .isEqualTo("java.util.Set<java.lang.String>");
-  }
-
-  @Named("foo")
-  @Provides(type=SET) String qualifiedElementProvides() { return "foo"; }
-
-  @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
-    Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
-        .isEqualTo("@javax.inject.Named(value=foo)/java.util.Set<java.lang.String>");
-  }
-
-  private String fieldKey(String fieldName) throws NoSuchFieldException {
-    Field field = KeysTest.class.getDeclaredField(fieldName);
-    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
-  }
-
-}
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
new file mode 100644
index 000000000..b4496e926
--- /dev/null
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class MapProviderFactoryTest {
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullKey() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put(null, incrementingIntegerProvider(1));
+  }
+
+  @Test
+  public void nullValue() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put("Hello", null);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Provider<Integer> p1 = incrementingIntegerProvider(10);
+    Provider<Integer> p2 = incrementingIntegerProvider(20);
+    Provider<Integer> p3 = incrementingIntegerProvider(30);
+    Provider<Integer> p4 = incrementingIntegerProvider(40);
+    Provider<Integer> p5 = incrementingIntegerProvider(50);
+
+    Factory<Map<String, Provider<Integer>>> factory = MapProviderFactory
+        .<String, Integer>builder(4)
+        .put("two", p2)
+        .put("one", p1)
+        .put("three", p3)
+        .put("one", p5)
+        .put("four", p4)
+        .build();
+
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    expectedMap.put("two", p2);
+    expectedMap.put("one", p1);
+    expectedMap.put("three", p3);
+    expectedMap.put("one", p5);
+    expectedMap.put("four", p4);
+    assert_()
+        .that(factory.get().entrySet())
+        .containsExactlyElementsIn(expectedMap.entrySet())
+        .inOrder();
+  }
+
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Integer>() {
+      @Override
+      public Integer get() {
+        return value.getAndIncrement();
+      }
+    };
+  }
+}
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
new file mode 100644
index 000000000..84b02c510
--- /dev/null
+++ b/core/src/test/java/dagger/internal/ScopedProviderTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link ScopedProvider}.
+ */
+@RunWith(JUnit4.class)
+public class ScopedProviderTest {
+  @Test public void create_nullPointerException() {
+    try {
+      ScopedProvider.create(null);
+      fail();
+    } catch (NullPointerException expected) { }
+  }
+
+  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
+  @Ignore @Test public void get_nullPointerException() {
+    Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
+      @Override public Object get() {
+        return null;
+      }
+    });
+    try {
+      scopedProvider.get();
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void get() {
+    Provider<Integer> scopedProvider = ScopedProvider.create(new Factory<Integer>() {
+      int i = 0;
+
+      @Override public Integer get() {
+        return i++;
+      }
+    });
+    assert_().that(scopedProvider.get()).isEqualTo(0);
+    assert_().that(scopedProvider.get()).isEqualTo(0);
+    assert_().that(scopedProvider.get()).isEqualTo(0);
+  }
+}
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
new file mode 100644
index 000000000..04b982281
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import com.google.common.collect.ContiguousSet;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Range;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.collect.DiscreteDomain.integers;
+import static com.google.common.truth.Truth.assert_;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class SetFactoryTest {
+  @Rule public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    }, incrementingIntegerProvider(0));
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void providerReturnsNullSet_single() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void providerReturnsSetWithNullElement() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void providerReturnsSetWithNullElement_single() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
+      }
+    }, incrementingIntegerProvider(0));
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void invokesProvidersEverytTime() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        incrementingIntegerProvider(0),
+        incrementingIntegerProvider(10),
+        incrementingIntegerProvider(20));
+    assert_().that(factory.get()).containsExactly(0, 10, 20);
+    assert_().that(factory.get()).containsExactly(1, 11, 21);
+    assert_().that(factory.get()).containsExactly(2, 12, 22);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        integerSetProvider(Range.closed(5, 9)),
+        integerSetProvider(Range.closed(3, 6)),
+        integerSetProvider(Range.closed(0, 5)));
+    assert_().that(factory.get()).containsExactly(5, 6, 7, 8, 9, 3, 4, 0, 1, 2).inOrder();
+  }
+
+  private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return ImmutableSet.of(value.getAndIncrement());
+      }
+    };
+  }
+
+  private static Provider<Set<Integer>> integerSetProvider(Range<Integer> range) {
+    final ContiguousSet<Integer> set = ContiguousSet.create(range, integers());
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return set;
+      }
+    };
+  }
+}
diff --git a/deploy_website.sh b/deploy_website.sh
index 2afa5f0e7..1fde1bd57 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -6,13 +6,17 @@
 
 set -ex
 
+REPO="git@github.com:square/dagger.git"
+GROUP_ID="com.squareup.dagger"
+ARTIFACT_ID="dagger"
+
 DIR=temp-dagger-clone
 
 # Delete any existing temporary website clone
 rm -rf $DIR
 
 # Clone the current repo into temp folder
-git clone git@github.com:square/dagger.git $DIR
+git clone $REPO $DIR
 
 # Move working directory into temp folder
 cd $DIR
@@ -26,6 +30,12 @@ rm -rf *
 # Copy website files from real repo
 cp -R ../website/* .
 
+# Download the latest javadoc
+curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+mkdir javadoc
+unzip javadoc.zip -d javadoc
+rm javadoc.zip
+
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
deleted file mode 100644
index b6be33a31..000000000
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package coffee;
-
-import javax.inject.Inject;
-
-import dagger.ObjectGraph;
-
-public class CoffeeApp implements Runnable {
-  @Inject CoffeeMaker coffeeMaker;
-
-  @Override public void run() {
-    coffeeMaker.brew();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
-    coffeeApp.run();
-  }
-}
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/example/src/main/java/coffee/CoffeeMaker.java
deleted file mode 100644
index a4e818012..000000000
--- a/example/src/main/java/coffee/CoffeeMaker.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package coffee;
-
-import dagger.Lazy;
-import javax.inject.Inject;
-
-class CoffeeMaker {
-  @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
-  @Inject Pump pump;
-
-  public void brew() {
-    heater.get().on();
-    pump.pump();
-    System.out.println(" [_]P coffee! [_]P ");
-    heater.get().off();
-  }
-}
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/AndroidManifest.xml
new file mode 100644
index 000000000..234406dfa
--- /dev/null
+++ b/examples/android-activity-graphs/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    android:versionCode="1"
+    android:versionName="1.0.0"
+    package="com.example.dagger.activitygraphs">
+
+  <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
+
+  <application
+      android:label="app_name"
+      android:name=".DemoApplication">
+    <activity
+        android:label="app_name"
+        android:name=".ui.HomeActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
diff --git a/examples/android-activity-graphs/README.md b/examples/android-activity-graphs/README.md
new file mode 100644
index 000000000..ac3680bb5
--- /dev/null
+++ b/examples/android-activity-graphs/README.md
@@ -0,0 +1,24 @@
+Example: Android Activity Graphs
+================================
+
+Building on top of the simple Android example, this example demonstrates how it is possible to
+create child graphs for each activity which extend from the global graph.
+
+Some of the advantages of the activity scope:
+
+ * Provides the ability to inject objects which require the activity to be constructed.
+ * Allows for the use of singletons on a per-activity basis. This is a great way to manage a
+   resource that is shared by a bunch of fragments in an activity.
+ * Keeps the global object graph clear of things that can be used only by activities.
+
+While this example only shows the presence of an activity scope, you should be able to see the
+potential for other useful scopes that can be used. For example, having a dedicated object graph
+for the current user session is a great way to manage data that is tied to the currently logged-in
+user.
+
+_Note: The app does not actually do anything when it is run. It is only to show how you can
+ structure Dagger within an Android app_
+
+_Note: The app is in transition to Dagger 2 and may not reflect recommended patterns.  Before
+ we release Dagger 2.0 it will, but until this note is removed, please do not rely on this
+ example as a strong recommendation._
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/examples/android-activity-graphs/pom.xml
similarity index 51%
rename from compiler/src/it/multiple-provides-methods/pom.xml
rename to examples/android-activity-graphs/pom.xml
index a796c6e00..53de228ff 100644
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
  Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -15,34 +14,49 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>multiple-provides-methods</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
+
+  <parent>
+    <groupId>com.google.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>android-activity-graphs</artifactId>
+  <name>Examples: Android - Activity Graphs</name>
+  <packaging>apk</packaging>
+
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>support-v4</artifactId>
+    </dependency>
   </dependencies>
+
   <build>
     <plugins>
       <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <artifactId>android-maven-plugin</artifactId>
+        <extensions>true</extensions>
       </plugin>
     </plugins>
   </build>
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
new file mode 100644
index 000000000..c08ccc390
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Activity;
+import dagger.Component;
+
+/**
+ * A base component upon which fragment's components may depend.  Activity-level components
+ * should extend this component.
+ */
+@PerActivity // Subtypes of ActivityComponent should be decorated with @PerActivity.
+@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
+public interface AbstractActivityComponent {
+  Activity activity(); // Expose the activity to sub-graphs.
+}
diff --git a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
similarity index 60%
rename from compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index d5f0771a7..cf5462e50 100644
--- a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,28 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package com.example.dagger.activitygraphs;
 
+import android.app.Activity;
 import dagger.Module;
 import dagger.Provides;
-import javax.inject.Inject;
 
-class TestApp {
-  static class NotInjectable {
-  }
+/**
+ * A module to wrap the Activity state and expose it to the graph.
+ */
+@Module
+public class ActivityModule {
+  private final Activity activity;
 
-  static class InjectableSubclass extends NotInjectable {
-    @Inject String string;
-    @Inject Integer integer;
+  public ActivityModule(Activity activity) {
+    this.activity = activity;
   }
 
-  @Module(entryPoints = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String string() {
-      return "string";
-    }
-    @Provides Integer integer() {
-      return 5;
-    }
+  /**
+   * Expose the activity to dependents in the graph.
+   */
+  @Provides @PerActivity Activity activity() {
+    return activity;
   }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
new file mode 100644
index 000000000..04c206225
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Application;
+import android.location.LocationManager;
+import dagger.Component;
+import javax.inject.Singleton;
+
+/**
+ * A component whose lifetime is the life of the application.
+ */
+@Singleton // Constraints this component to one-per-application or unscoped bindings.
+@Component(modules = DemoApplicationModule.class)
+public interface ApplicationComponent {
+  // Field injections of any dependencies of the DemoApplication
+  void inject(DemoApplication application);
+
+  // Exported for child-components.
+  Application application();
+  LocationManager locationManager();
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
new file mode 100644
index 000000000..72057332c
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Application;
+import android.location.LocationManager;
+import javax.inject.Singleton;
+import javax.inject.Inject;
+
+public class DemoApplication extends Application {
+  private ApplicationComponent applicationComponent;
+
+  // TODO(cgruber): Figure out a better example of something one might inject into the app.
+  @Inject LocationManager locationManager; // to illustrate injecting something into the app.
+
+  @Override public void onCreate() {
+    super.onCreate();
+    applicationComponent = DaggerApplicationComponent.builder()
+        .demoApplicationModule(new DemoApplicationModule(this))
+        .build();
+  }
+
+  public ApplicationComponent component() {
+    return applicationComponent;
+  }
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
new file mode 100644
index 000000000..070d2c79d
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Application;
+import android.location.LocationManager;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static android.content.Context.LOCATION_SERVICE;
+
+/**
+ * A module for Android-specific dependencies which require a {@link Context} or
+ * {@link android.app.Application} to create.
+ */
+@Module
+public class DemoApplicationModule {
+  private final Application application;
+
+  public DemoApplicationModule(Application application) {
+    this.application = application;
+  }
+
+  /**
+   * Expose the application to the graph.
+   */
+  @Provides @Singleton Application application() {
+    return application;
+  }
+
+  @Provides @Singleton LocationManager provideLocationManager() {
+    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
+  }
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
new file mode 100644
index 000000000..d54b193e3
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scoping annotation to permit objects whose lifetime should
+ * conform to the life of the activity to be memoized in the
+ * correct component.
+ */
+@Scope
+@Retention(RUNTIME)
+public @interface PerActivity {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
new file mode 100644
index 000000000..c416c75b3
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.app.Activity;
+import com.example.dagger.activitygraphs.PerActivity;
+import javax.inject.Inject;
+
+/**
+ * A simple abstraction which provides the ability to set the title on an activity.
+ * <p>
+ * Fragments should not directly modify any part of an activity outside of the view or dialog that
+ * it creates. This class provides a way for fragments to inject a controller that will allow for
+ * control of the activity title. While not exceedingly useful in practice, this concept could be
+ * expanded to things like facilitating control over the action bar, dialogs, notifications, etc.
+ */
+@PerActivity
+public class ActivityTitleController {
+  private final Activity activity;
+
+  @Inject public ActivityTitleController(Activity activity) {
+    this.activity = activity;
+  }
+
+  public void setTitle(CharSequence title) {
+    activity.setTitle(title);
+  }
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
new file mode 100644
index 000000000..1f3bb7002
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.location.LocationManager;
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import com.example.dagger.activitygraphs.ActivityModule;
+import com.example.dagger.activitygraphs.DemoApplication;
+import javax.inject.Inject;
+
+public class HomeActivity extends FragmentActivity {
+  @Inject LocationManager locationManager;
+  private HomeComponent component;
+
+  HomeComponent component() {
+    if (component == null) {
+      component = DaggerHomeComponent.builder()
+          .applicationComponent(((DemoApplication) getApplication()).component())
+          .activityModule(new ActivityModule(this))
+          .build();
+    }
+    return component;
+  }
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    component().inject(this);
+
+    if (savedInstanceState == null) {
+      getSupportFragmentManager().beginTransaction()
+          .add(android.R.id.content, new HomeFragment())
+          .commit();
+    }
+
+    // TODO do something with the injected dependencies here!
+  }
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
new file mode 100644
index 000000000..84d2a427c
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import com.example.dagger.activitygraphs.AbstractActivityComponent;
+import com.example.dagger.activitygraphs.ActivityModule;
+import com.example.dagger.activitygraphs.ApplicationComponent;
+import com.example.dagger.activitygraphs.PerActivity;
+import dagger.Component;
+
+@PerActivity
+@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
+public interface HomeComponent extends AbstractActivityComponent {
+  void inject(HomeActivity homeActivity);
+  void inject(HomeFragment homeFragment);
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
new file mode 100644
index 000000000..1df2724cb
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+import javax.inject.Inject;
+
+import static android.view.Gravity.CENTER;
+
+public class HomeFragment extends Fragment {
+  @Inject ActivityTitleController titleController;
+
+  @Override public void onActivityCreated(Bundle savedInstanceState) {
+    super.onActivityCreated(savedInstanceState);
+    ((HomeActivity) getActivity()).component().inject(this);
+  }
+
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    TextView tv = new TextView(getActivity());
+    tv.setGravity(CENTER);
+    tv.setText("Hello, World");
+    return tv;
+  }
+
+  @Override public void onResume() {
+    super.onResume();
+
+    // Fragments should not modify things outside of their own view. Use an external controller to
+    // ask the activity to change its title.
+    titleController.setTitle("Home Fragment");
+  }
+}
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/AndroidManifest.xml
new file mode 100644
index 000000000..53c83bfd3
--- /dev/null
+++ b/examples/android-simple/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    android:versionCode="1"
+    android:versionName="1.0.0"
+    package="com.example.dagger.simple">
+
+  <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
+
+  <application
+      android:label="app_name"
+      android:name=".DemoApplication">
+    <activity
+        android:label="app_name"
+        android:name=".ui.HomeActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
diff --git a/examples/android-simple/README.md b/examples/android-simple/README.md
new file mode 100644
index 000000000..944d01533
--- /dev/null
+++ b/examples/android-simple/README.md
@@ -0,0 +1,17 @@
+Example: Android Simple
+=======================
+
+This example demonstrates how to structure an Android application with Dagger.
+
+A custom `Application` class is used to manage a global object graph of objects. Modules are
+assembled with a `getModules` method on the application that can be overridden to add additional
+modules in development versions of your applications or in tests.
+
+Injection of activities is done automatically in a base activity.
+
+_Note: The app does not actually do anything when it is run. It is only to show how you can
+ structure Dagger within an Android app_
+
+_Note: The app is in transition to Dagger 2 and may not reflect recommended patterns.  Before
+ we release Dagger 2.0 it will, but until this note is removed, please do not rely on this
+ example as a strong recommendation._
diff --git a/example/pom.xml b/examples/android-simple/pom.xml
similarity index 64%
rename from example/pom.xml
rename to examples/android-simple/pom.xml
index c6cd863f7..332aeb66b 100644
--- a/example/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2013 Square, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -18,38 +18,41 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
-    <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
+    <groupId>com.google.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
   </parent>
 
-  <artifactId>dagger-example</artifactId>
-  <packaging>jar</packaging>
-  <name>Dagger Example</name>
+  <artifactId>android-simple</artifactId>
+  <name>Examples: Android - Simple</name>
+  <packaging>apk</packaging>
 
   <dependencies>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
+
   <build>
     <plugins>
       <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-Xlint:all</compilerArgument>
-          <showWarnings>true</showWarnings>
-          <showDeprecation>true</showDeprecation>
-        </configuration>
+        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <artifactId>android-maven-plugin</artifactId>
+        <extensions>true</extensions>
       </plugin>
     </plugins>
   </build>
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
new file mode 100644
index 000000000..18184d164
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.content.Context;
+import android.location.LocationManager;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static android.content.Context.LOCATION_SERVICE;
+
+/**
+ * A module for Android-specific dependencies which require a {@link Context} or
+ * {@link android.app.Application} to create.
+ */
+@Module
+public class AndroidModule {
+  private final DemoApplication application;
+
+  public AndroidModule(DemoApplication application) {
+    this.application = application;
+  }
+
+  /**
+   * Allow the application context to be injected but require that it be annotated with
+   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   */
+  @Provides @Singleton @ForApplication Context provideApplicationContext() {
+    return application;
+  }
+
+  @Provides @Singleton LocationManager provideLocationManager() {
+    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
+  }
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
new file mode 100644
index 000000000..aa09f2d0a
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public abstract class DemoActivity extends Activity {
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    // Perform injection so that when this call returns all dependencies will be available for use.
+    ((DemoApplication) getApplication()).component().inject(this);
+  }
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
new file mode 100644
index 000000000..55402c654
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.app.Application;
+import android.location.LocationManager;
+import com.example.dagger.simple.ui.HomeActivity;
+import dagger.Component;
+import java.util.Arrays;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+public class DemoApplication extends Application {
+  
+  @Singleton
+  @Component(modules = AndroidModule.class)
+  public interface ApplicationComponent {
+    void inject(DemoApplication application);
+    void inject(HomeActivity homeActivity);
+    void inject(DemoActivity demoActivity);
+  }
+  
+  @Inject LocationManager locationManager; // for some reason.
+  
+  private ApplicationComponent component;
+
+  @Override public void onCreate() {
+    super.onCreate();
+    component = DaggerDemoApplication_ApplicationComponent.builder()
+        .androidModule(new AndroidModule(this))
+        .build();
+    component().inject(this); // As of now, LocationManager should be injected into this.
+  }
+
+  public ApplicationComponent component() {
+    return component;
+  }
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
new file mode 100644
index 000000000..84d224740
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Qualifier @Retention(RUNTIME)
+public @interface ForApplication {
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
new file mode 100644
index 000000000..7e33b8eec
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple.ui;
+
+import android.location.LocationManager;
+import android.os.Bundle;
+import android.util.Log;
+import com.example.dagger.simple.DemoActivity;
+import com.example.dagger.simple.DemoApplication;
+import javax.inject.Inject;
+
+public class HomeActivity extends DemoActivity {
+  @Inject LocationManager locationManager;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    ((DemoApplication) getApplication()).component().inject(this);
+
+    // TODO do something with the injected dependencies here!
+    Log.d("HomeActivity", locationManager.toString());
+  }
+}
diff --git a/examples/pom.xml b/examples/pom.xml
new file mode 100644
index 000000000..708635f1a
--- /dev/null
+++ b/examples/pom.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Google, Inc.
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+
+  <groupId>com.google.dagger.example</groupId>
+  <artifactId>dagger-example-parent</artifactId>
+  <packaging>pom</packaging>
+  <name>Examples</name>
+
+  <modules>
+    <module>simple</module>
+    <module>android-simple</module>
+    <module>android-activity-graphs</module>
+  </modules>
+
+  <!-- Example-only dependencies. -->
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>4.1.1.4</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>support-v4</artifactId>
+        <version>r7</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <build>
+    <pluginManagement>
+      <plugins>
+       <plugin>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <configuration>
+            <source>1.6</source>
+            <target>1.6</target>
+          </configuration>
+        </plugin>
+        <plugin>
+          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <artifactId>android-maven-plugin</artifactId>
+          <version>3.8.2</version>
+          <configuration>
+            <sdk>
+              <platform>16</platform>
+            </sdk>
+          </configuration>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+  </build>
+</project>
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/examples/simple/pom.xml
similarity index 59%
rename from compiler/src/it/default-package-injected-type/pom.xml
rename to examples/simple/pom.xml
index a0f1ea218..0be10b86d 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/examples/simple/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
  Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -15,33 +14,29 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>default-package-injected-type</artifactId>
-  <version>@dagger.version@</version>
+
+  <parent>
+    <groupId>com.google.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>2.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>simple</artifactId>
+  <name>Examples: Simple</name>
+
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
-      </plugin>
-    </plugins>
-  </build>
 </project>
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
new file mode 100644
index 000000000..b0a93ec3c
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+public class CoffeeApp {
+  @Singleton
+  @Component(modules = { DripCoffeeModule.class })
+  public interface Coffee {
+    CoffeeMaker maker();
+  }
+
+  public static void main(String[] args) {
+    Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();
+    coffee.maker().brew();
+  }
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
new file mode 100644
index 000000000..6410336d0
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -0,0 +1,21 @@
+package coffee;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+
+class CoffeeMaker {
+  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
+  private final Pump pump;
+
+  @Inject CoffeeMaker(Lazy<Heater> heater, Pump pump) {
+    this.heater = heater;
+    this.pump = pump;
+  }
+
+  public void brew() {
+    heater.get().on();
+    pump.pump();
+    System.out.println(" [_]P coffee! [_]P ");
+    heater.get().off();
+  }
+}
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
similarity index 72%
rename from example/src/main/java/coffee/DripCoffeeModule.java
rename to examples/simple/src/main/java/coffee/DripCoffeeModule.java
index 1b1d3fe88..e50d249e1 100644
--- a/example/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -4,10 +4,7 @@
 import dagger.Provides;
 import javax.inject.Singleton;
 
-@Module(
-    entryPoints = CoffeeApp.class,
-    includes = PumpModule.class
-)
+@Module(includes = PumpModule.class)
 class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
diff --git a/example/src/main/java/coffee/ElectricHeater.java b/examples/simple/src/main/java/coffee/ElectricHeater.java
similarity index 100%
rename from example/src/main/java/coffee/ElectricHeater.java
rename to examples/simple/src/main/java/coffee/ElectricHeater.java
diff --git a/example/src/main/java/coffee/Heater.java b/examples/simple/src/main/java/coffee/Heater.java
similarity index 100%
rename from example/src/main/java/coffee/Heater.java
rename to examples/simple/src/main/java/coffee/Heater.java
diff --git a/example/src/main/java/coffee/Pump.java b/examples/simple/src/main/java/coffee/Pump.java
similarity index 100%
rename from example/src/main/java/coffee/Pump.java
rename to examples/simple/src/main/java/coffee/Pump.java
diff --git a/example/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
similarity index 85%
rename from example/src/main/java/coffee/PumpModule.java
rename to examples/simple/src/main/java/coffee/PumpModule.java
index 3324b842c..338ad33c2 100644
--- a/example/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -3,7 +3,7 @@
 import dagger.Module;
 import dagger.Provides;
 
-@Module(complete = false)
+@Module
 class PumpModule {
   @Provides Pump providePump(Thermosiphon pump) {
     return pump;
diff --git a/example/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
similarity index 100%
rename from example/src/main/java/coffee/Thermosiphon.java
rename to examples/simple/src/main/java/coffee/Thermosiphon.java
diff --git a/pom.xml b/pom.xml
index d9b59a8bd..61458696f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,45 +23,50 @@
     <version>7</version>
   </parent>
 
-  <groupId>com.squareup</groupId>
+  <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0-SNAPSHOT</version>
+  <version>2.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
-  <description>A JSR-330 dependency injector for Android and Java.</description>
+  <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
 
   <modules>
-    <module>androidmanifest</module>
     <module>compiler</module>
     <module>core</module>
-    <module>example</module>
+    <!-- examples are handled in a default profile (see below) -->
+    <module>producers</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <maven.version>2.0.6</maven.version>
-    <ant.version>1.8.2</ant.version>
+    <javawriter.version>2.5.0</javawriter.version>
+    <auto.common.version>0.4</auto.common.version>
+    <auto.service.version>1.0-rc2</auto.service.version>
+    <auto.value.version>1.0</auto.value.version>
+    <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
-    <fest.version>1.4</fest.version>
+    <compile-testing.version>0.7</compile-testing.version>
+    <junit.version>4.11</junit.version>
+    <mockito.version>1.9.5</mockito.version>
+    <truth.version>0.26</truth.version>
   </properties>
 
   <scm>
-    <url>http://github.com/square/dagger/</url>
-    <connection>scm:git:git://github.com/square/dagger.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
+    <url>http://github.com/google/dagger/</url>
+    <connection>scm:git:git://github.com/google/dagger.git</connection>
+    <developerConnection>scm:git:ssh://git@github.com/google/dagger.git</developerConnection>
     <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
     <system>GitHub Issues</system>
-    <url>http://github.com/square/dagger/issues</url>
+    <url>http://github.com/google/dagger/issues</url>
   </issueManagement>
 
   <licenses>
@@ -72,8 +77,8 @@
   </licenses>
 
   <organization>
-    <name>Square, Inc.</name>
-    <url>http://squareup.com</url>
+    <name>Google, Inc.</name>
+    <url>http://www.google.com</url>
   </organization>
 
   <dependencyManagement>
@@ -84,19 +89,34 @@
         <version>${javax.inject.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.apache.maven</groupId>
-        <artifactId>maven-plugin-api</artifactId>
-        <version>${maven.version}</version>
+        <groupId>com.squareup</groupId>
+        <artifactId>javawriter</artifactId>
+        <version>${javawriter.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.apache.maven</groupId>
-        <artifactId>maven-core</artifactId>
-        <version>${maven.version}</version>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.apache.ant</groupId>
-        <artifactId>ant</artifactId>
-        <version>${ant.version}</version>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava-testlib</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.auto</groupId>
+        <artifactId>auto-common</artifactId>
+        <version>${auto.common.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.auto.service</groupId>
+        <artifactId>auto-service</artifactId>
+        <version>${auto.service.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.auto.value</groupId>
+        <artifactId>auto-value</artifactId>
+        <version>${auto.value.version}</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
@@ -104,19 +124,44 @@
         <version>${junit.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.easytesting</groupId>
-        <artifactId>fest-assert</artifactId>
-        <version>${fest.version}</version>
+        <groupId>com.google.testing.compile</groupId>
+        <artifactId>compile-testing</artifactId>
+        <version>${compile-testing.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.mockito</groupId>
+        <artifactId>mockito-core</artifactId>
+        <version>${mockito.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.truth</groupId>
+        <artifactId>truth</artifactId>
+        <version>${truth.version}</version>
       </dependency>
     </dependencies>
   </dependencyManagement>
 
   <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <artifactId>maven-invoker-plugin</artifactId>
+          <version>1.7</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <version>3.1</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-jar-plugin</artifactId>
+          <version>2.5</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5</version>
         <configuration>
           <source>${java.version}</source>
           <target>${java.version}</target>
@@ -127,26 +172,31 @@
       </plugin>
 
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.3.2</version>
+        <version>2.3.2</version><!--$NO-MVN-MAN-VER$-->
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
       </plugin>
 
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
+        </configuration>
+      </plugin>
+
+      <plugin>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.10</version>
         <configuration>
-          <failsOnError>true</failsOnError>
+          <failsOnError>false</failsOnError>
           <consoleOutput>true</consoleOutput>
           <configLocation>checkstyle.xml</configLocation>
         </configuration>
         <executions>
           <execution>
-            <phase>verify</phase>
+            <phase>compile</phase>
             <goals>
               <goal>checkstyle</goal>
             </goals>
@@ -154,21 +204,25 @@
         </executions>
       </plugin>
     </plugins>
-
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-plugin-plugin</artifactId>
-          <version>2.8</version>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-invoker-plugin</artifactId>
-          <version>1.7</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
   </build>
+
+  <!--
+    A profile which when switched off excludes example modules.  By default the profile
+    is on and invokes examples.  However, when processing javadocs, it is switched off
+    omitting the example code from the javadoc.
+  -->
+  <profiles>
+    <profile>
+      <id>examples</id>
+      <activation>
+        <activeByDefault>true</activeByDefault>
+      </activation>
+      <modules>
+        <module>core</module>
+        <module>compiler</module>
+        <module>examples</module>
+        <module>producers</module>
+      </modules>
+    </profile>
+  </profiles>
 </project>
diff --git a/androidmanifest/pom.xml b/producers/pom.xml
similarity index 52%
rename from androidmanifest/pom.xml
rename to producers/pom.xml
index c3d3ef7b7..32ecaf0a5 100644
--- a/androidmanifest/pom.xml
+++ b/producers/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2014 Google, Inc.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -18,15 +18,16 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
+    <version>2.1-SNAPSHOT</version>
   </parent>
 
-  <artifactId>dagger-androidmanifest-plugin</artifactId>
-  <packaging>maven-plugin</packaging>
-  <name>Dagger AndroidManifest.xml Module Generator</name>
+  <artifactId>dagger-producers</artifactId>
+  <name>Dagger Production Graphs</name>
+  <description>
+    An asynchronous dependency injection system that extends JSR-330.
+  </description>
 
   <dependencies>
     <dependency>
@@ -35,46 +36,18 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>org.apache.maven</groupId>
-      <artifactId>maven-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.apache.maven</groupId>
-      <artifactId>maven-plugin-api</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.ant</groupId>
-      <artifactId>ant</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-plugin-plugin</artifactId>
-        <configuration>
-          <goalPrefix>dagger</goalPrefix>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
 </project>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
new file mode 100644
index 000000000..3fbbee24c
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.internal.Beta;
+import java.util.concurrent.ExecutionException;
+
+/**
+ * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
+ * or an exception that was thrown during that production. For any type {@code T} that can be
+ * injected, you can also inject {@code Produced<T>}, which enables handling of any exceptions that
+ * were thrown during the production of {@code T}.
+ *
+ * <p>For example: <pre><code>
+ *   {@literal @}Produces Html getResponse(
+ *       UserInfo criticalInfo, {@literal Produced<ExtraInfo>} noncriticalInfo) {
+ *     try {
+ *       return new Html(criticalInfo, noncriticalInfo.get());
+ *     } catch (ExecutionException e) {
+ *       logger.warning(e, "Noncritical info");
+ *       return new Html(criticalInfo);
+ *     }
+ *   }
+ * </code></pre>
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public interface Produced<T> {
+  /**
+   * Returns the result of a production.
+   *
+   * @throws ExecutionException if the production threw an exception
+   */
+  T get() throws ExecutionException;
+}
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
new file mode 100644
index 000000000..eb159bbf6
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.internal.Beta;
+import com.google.common.util.concurrent.ListenableFuture;
+
+/**
+ * An interface that represents the production of a type {@code T}. You can also inject
+ * {@code Producer<T>} instead of {@code T}, which will delay the execution of any code that
+ * produces the {@code T} until {@link #get} is called.
+ *
+ * <p>For example, you might inject {@code Producer} to lazily choose between several different
+ * implementations of some type: <pre><code>
+ *   {@literal @Produces ListenableFuture<Heater>} getHeater(
+ *       HeaterFlag flag,
+ *       {@literal @Electric Producer<Heater>} electricHeater,
+ *       {@literal @Gas Producer<Heater>} gasHeater) {
+ *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();
+ *   }
+ * </code></pre>
+ *
+ * <p>Here is a complete example that demonstrates how calling {@code get()} will cause each
+ * method to be executed: <pre><code>
+ *
+ *   {@literal @}ProducerModule
+ *   final class MyModule {
+ *     {@literal @Produces ListenableFuture<A>} a() {
+ *       System.out.println("a");
+ *       return Futures.immediateFuture(new A());
+ *     }
+ *
+ *     {@literal @Produces ListenableFuture<B>} b(A a) {
+ *       System.out.println("b");
+ *       return Futures.immediateFuture(new B(a));
+ *     }
+ *
+ *     {@literal @Produces ListenableFuture<C>} c(B b) {
+ *       System.out.println("c");
+ *       return Futures.immediateFuture(new C(b));
+ *     }
+ *
+ *     {@literal @Produces @Delayed ListenableFuture<C>} delayedC(A a, {@literal Producer<C>} c) {
+ *       System.out.println("delayed c");
+ *       return c.get();
+ *     }
+ *   }
+ *
+ *   {@literal @}ProductionComponent(modules = MyModule.class)
+ *   interface MyComponent {
+ *     {@literal @Delayed ListenableFuture<C>} delayedC();
+ *   }
+ * </code></pre>
+ * Suppose we instantiate the generated implementation of this component and call
+ * {@code delayedC()}: <pre><code>
+ *   MyComponent component = DaggerMyComponent
+ *       .builder()
+ *       .executor(MoreExecutors.directExecutor())
+ *       .build();
+ *   System.out.println("Constructed component");
+ *   {@literal ListenableFuture<C>} cFuture = component.delayedC();
+ *   System.out.println("Retrieved future");
+ *   C c = cFuture.get();
+ *   System.out.println("Retrieved c");
+ * </code></pre>
+ * Here, we're using {@code MoreExecutors.directExecutor} in order to illustrate how each call
+ * directly causes code to execute. The above code will print: <pre><code>
+ *   Constructed component
+ *   a
+ *   delayed c
+ *   b
+ *   c
+ *   Retrieved future
+ *   Retrieved c
+ * </code></pre>
+ *
+ * @author Jesse Beder
+ */
+@Beta
+public interface Producer<T> {
+  /**
+   * Returns a future representing a running task that produces a value. Calling this method will
+   * trigger the submission of this task to the executor, if it has not already been triggered. In
+   * order to trigger this task's submission, the transitive dependencies required to produce the
+   * {@code T} will be submitted to the executor, as their dependencies become available.
+   *
+   * <p>If the key is bound to a {@link Produces} method, then calling this method multiple times
+   * will return the same future.
+   */
+  ListenableFuture<T> get();
+}
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
new file mode 100644
index 000000000..714e3fa3e
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Module;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates a class that contributes {@link Produces} bindings to the production component.
+ *
+ * @author Jesse Beder
+ */
+@Documented
+@Target(TYPE)
+@Beta
+public @interface ProducerModule {
+  /**
+   * Additional {@code @ProducerModule}- or {@link Module}-annotated classes from which this module
+   * is composed. The de-duplicated contributions of the modules in {@code includes}, and of their
+   * inclusions recursively, are all contributed to the object graph.
+   */
+  Class<?>[] includes() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
new file mode 100644
index 000000000..1b57bc39d
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.internal.Beta;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * Annotates methods of a producer module to create a production binding. If the method returns
+ * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the
+ * future provides; otherwise, the return type is bound to the returned value. The production
+ * component will pass dependencies to the method as parameters.
+ *
+ * @author Jesse Beder
+ */
+@Documented
+@Target(METHOD)
+@Beta
+public @interface Produces {
+  /** The type of binding into which the return type of the annotated method contributes. */
+  enum Type {
+    /**
+     * The method is the only one which can produce the value for the specified type. This is the
+     * default behavior.
+     */
+    UNIQUE,
+
+    /**
+     * The method's resulting type forms the generic type argument of a {@code Set<T>}, and the
+     * returned value or future is contributed to the set. The {@code Set<T>} produced from the
+     * accumulation of values will be immutable.
+     */
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is either {@code Set<T>} or
+     * {@code Set<ListenableFuture<T>>}, where any values are contributed to the set. An example use
+     * is to provide a default empty set binding, which is otherwise not possible using
+     * {@link #SET}.
+     */
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Producer<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Producer<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
+  }
+
+  Type type() default Type.UNIQUE;
+}
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
new file mode 100644
index 000000000..6aa9ea8f0
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @ProductionComponent} prepended with
+ * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * produce an implementation named {@code DaggerMyComponent}.
+ *
+ * <p>Each {@link Produces} method that contributes to the component will be called at most once per
+ * component instance, no matter how many times that binding is used as a dependency.
+ * TODO(user): Decide on how scope works for producers.
+ *
+ * <h2>Component methods</h2>
+ *
+ * <p>Every type annotated with {@code @ProductionComponent} must contain at least one abstract
+ * component method. Component methods must represent {@linkplain Producer production}.
+ *
+ * Production methods have no arguments and return either a {@link ListenableFuture} or
+ * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
+ * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
+ * are all valid production method declarations: <pre><code>
+ *   ListenableFuture<SomeType> getSomeType();
+ *   {@literal Producer<Set<SomeType>>} getSomeTypes();
+ *   {@literal @Response ListenableFuture<Html>} getResponse();
+ * </code></pre>
+ *
+ * <h2>Exceptions</h2>
+ *
+ * <p>When a producer throws an exception, the exception will be propagated to its downstream
+ * producers in the following way: if the downstream producer injects a type {@code T}, then that
+ * downstream producer will be skipped, and the exception propagated to its downstream producers;
+ * and if the downstream producer injects a {@code Produced<T>}, then the downstream producer will
+ * be run with the exception stored in the {@code Produced<T>}.
+ *
+ * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
+ * {@code CancellationException}), then exception is handled as in
+ * {@link com.google.common.util.concurrent.Futures#transform}.
+ * <!-- TODO(user): Explain this more thoroughly, and update the javadocs of those utilities. -->
+ *
+ * @author Jesse Beder
+ */
+@Documented
+@Target(TYPE)
+@Beta
+public @interface ProductionComponent {
+  /**
+   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
+   * used to generate the component implementation.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
new file mode 100644
index 000000000..43659980b
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+
+/**
+ * An abstract {@link Producer} implementation that memoizes the result of its compute method.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public abstract class AbstractProducer<T> implements Producer<T> {
+  private volatile ListenableFuture<T> instance = null;
+
+  /** Computes this producer's future, which is then cached in {@link #get}. */
+  protected abstract ListenableFuture<T> compute();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    // double-check idiom from EJ2: Item 71
+    ListenableFuture<T> result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = compute();
+          if (result == null) {
+            throw new NullPointerException("compute returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
new file mode 100644
index 000000000..c850caa33
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FutureFallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
+import javax.inject.Provider;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utility methods for use in generated producer code.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class Producers {
+  /**
+   * Returns a future of {@link Produced} that represents the completion (either success or failure)
+   * of the given future. If the input future succeeds, then the resulting future also succeeds with
+   * a successful {@code Produced}; if the input future fails, then the resulting future succeeds
+   * with a failing {@code Produced}.
+   *
+   * <p>Cancelling the resulting future will propagate the cancellation to the input future; but
+   * cancelling the input future will trigger the resulting future to succeed with a failing
+   * {@code Produced}.
+   */
+  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // trigger one in a test.
+  public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
+    return Futures.withFallback(
+        Futures.transform(future, new Function<T, Produced<T>>() {
+          @Override public Produced<T> apply(final T value) {
+            return new Produced<T>() {
+              @Override public T get() {
+                return value;
+              }
+            };
+          }
+        }), Producers.<T>futureFallbackForProduced());
+
+  }
+
+  private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
+      new FutureFallback<Produced<Object>>() {
+    @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
+      Produced<Object> produced = new Produced<Object>() {
+        @Override public Object get() throws ExecutionException {
+          throw new ExecutionException(t);
+        }
+      };
+      return Futures.immediateFuture(produced);
+    }
+  };
+
+  @SuppressWarnings({"unchecked", "rawtypes"})  // bivariant implementation
+  private static <T> FutureFallback<Produced<T>> futureFallbackForProduced() {
+    return (FutureFallback) FUTURE_FALLBACK_FOR_PRODUCED;
+  }
+
+  /**
+   * Returns a future of a {@code Set} that contains a single element: the result of the input
+   * future.
+   */
+  public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
+    return Futures.transform(future, new Function<T, Set<T>>() {
+      @Override public Set<T> apply(T value) {
+        return ImmutableSet.of(value);
+      }
+    });
+  }
+
+  /**
+   * Submits a callable to an executor, returning the future representing the task. This mirrors
+   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
+   * {@link Executor}.
+   *
+   * @throws RejectedExecutionException if this task cannot be accepted for execution.
+   */
+  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
+    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
+    executor.execute(future);
+    return future;
+  }
+
+  /**
+   * Returns a producer that immediately executes the binding logic for the given provider every
+   * time it is called.
+   */
+  public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
+    checkNotNull(provider);
+    return new AbstractProducer<T>() {
+      @Override protected ListenableFuture<T> compute() {
+        return Futures.immediateFuture(provider.get());
+      }
+    };
+  }
+
+  private Producers() {}
+}
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
new file mode 100644
index 000000000..399dbd031
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
+ * a future {@link Set} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetProducer<T> extends AbstractProducer<Set<T>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  public static <T> Producer<Set<T>> create(
+      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+    return new SetProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final Set<Producer<Set<T>>> contributingProducers;
+
+  private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
+   * producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then this future will fail
+   * with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
+   * delegate futures fails or is canceled, this one is, too.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<T>> compute() {
+    List<ListenableFuture<Set<T>>> futureSets =
+        new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureSets.add(futureSet);
+    }
+    return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
+      @Override public Set<T> apply(List<Set<T>> sets) {
+        ImmutableSet.Builder<T> builder = ImmutableSet.builder();
+        for (Set<T> set : sets) {
+          builder.addAll(set);
+        }
+        return builder.build();
+      }
+    });
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
new file mode 100644
index 000000000..e307166f5
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link AbstractProducer}.
+ */
+@RunWith(JUnit4.class)
+public class AbstractProducerTest {
+  @Test public void get_nullPointerException() {
+    Producer<Object> producer = new AbstractProducer<Object>() {
+      @Override public ListenableFuture<Object> compute() {
+        return null;
+      }
+    };
+    try {
+      producer.get();
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void get() throws Exception {
+    Producer<Integer> producer = new AbstractProducer<Integer>() {
+      int i = 0;
+
+      @Override public ListenableFuture<Integer> compute() {
+        return Futures.immediateFuture(i++);
+      }
+    };
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
new file mode 100644
index 000000000..43564089f
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Producers}.
+ */
+@RunWith(JUnit4.class)
+public class ProducersTest {
+  @Test public void createFutureProduced_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(producedFuture.get().get()).isEqualTo("monkey");
+  }
+
+  @Test public void createFutureProduced_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(getProducedException(producedFuture.get()).getCause()).hasMessage("monkey");
+  }
+
+  @Test public void createFutureProduced_cancelPropagatesBackwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    producedFuture.cancel(false);
+    assertThat(future.isCancelled()).isTrue();
+  }
+
+  @Test public void createFutureProduced_cancelDoesNotPropagateForwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    future.cancel(false);
+    assertThat(producedFuture.isCancelled()).isFalse();
+    assertThat(getProducedException(producedFuture.get()).getCause())
+        .isInstanceOf(CancellationException.class);
+  }
+
+  private <T> ExecutionException getProducedException(Produced<T> produced) {
+    try {
+      produced.get();
+      throw new IllegalArgumentException("produced did not throw");
+    } catch (ExecutionException e) {
+      return e;
+    }
+  }
+
+  @Test public void createFutureSingletonSet_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    assertThat(setFuture.get()).containsExactly("monkey");
+  }
+
+  @Test public void createFutureSingletonSet_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    try {
+      setFuture.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test public void submitToExecutor() throws Exception {
+    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
+      @Override public Integer call() {
+        return 42;
+      }
+    }, MoreExecutors.directExecutor());
+    assertThat(future.isDone()).isTrue();
+    assertThat(future.get()).isEqualTo(42);
+  }
+
+  @Test public void producerFromProvider() throws Exception {
+    Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
+      int i = 0;
+
+      @Override public Integer get() {
+        return i++;
+      }
+    });
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
new file mode 100644
index 000000000..1f8ff7c3a
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link SetProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetProducerTest {
+  @Test public void success() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
+        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
+  }
+
+  @Test public void delegateSetNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
+        new ImmediateProducer<Set<Integer>>(null));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  @Test public void delegateElementNpe() throws Exception {
+    Producer<Set<Integer>> producer = SetProducer.create(
+        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
+        new ImmediateProducer<Set<Integer>>(
+            Collections.<Integer>singleton(null)));
+    ListenableFuture<Set<Integer>> future = producer.get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
+    }
+  }
+
+  private static final class ImmediateProducer<T> implements Producer<T> {
+    private final T value;
+
+    ImmediateProducer(T value) {
+      this.value = value;
+    }
+
+    @Override public ListenableFuture<T> get() {
+      return Futures.immediateFuture(value);
+    }
+  }
+}
diff --git a/util/generate-latest-docs.sh b/util/generate-latest-docs.sh
new file mode 100755
index 000000000..b68df0c4a
--- /dev/null
+++ b/util/generate-latest-docs.sh
@@ -0,0 +1,25 @@
+# see http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/ for details
+
+if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
+   [ "$TRAVIS_JDK_VERSION" == "oraclejdk7" ] && \
+   [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
+   [ "$TRAVIS_BRANCH" == "master" ]; then
+  echo -e "Publishing javadoc...\n"
+  mvn javadoc:aggregate -P!examples
+  TARGET="$(pwd)/target"
+
+  cd $HOME
+  git clone --quiet --branch=gh-pages https://${GH_TOKEN}@github.com/google/dagger gh-pages > /dev/null
+  
+  cd gh-pages
+  git config --global user.email "travis@travis-ci.org"
+  git config --global user.name "travis-ci"
+  git rm -rf api/latest 
+  mkdir -p api
+  mv ${TARGET}/site/apidocs api/latest
+  git add -f api/latest
+  git commit -m "Lastest javadoc on successful travis build $TRAVIS_BUILD_NUMBER auto-pushed to gh-pages"
+  git push -fq origin gh-pages > /dev/null
+
+  echo -e "Published Javadoc to gh-pages.\n"
+fi
diff --git a/util/mvn-deploy.sh b/util/mvn-deploy.sh
new file mode 100755
index 000000000..c812b1378
--- /dev/null
+++ b/util/mvn-deploy.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+if [ $# -lt 1 ]; then
+  echo "usage $0 <ssl-key> [<param> ...]"
+  exit 1;
+fi
+key=${1}
+shift
+params=${@}
+
+#validate key
+keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
+if [ "${keystatus}" != "pub" ]; then
+  echo "Could not find public key with label ${key}"
+  echo -n "Available keys from: "
+  gpg --list-keys | grep --invert-match '^sub'
+
+  exit 1
+fi
+
+mvn ${params} -P '!examples' -P sonatype-oss-release clean site:jar -Dgpg.skip=false -Dgpg.keyname=${key} deploy
diff --git a/util/publish-snapshot-on-commit.sh b/util/publish-snapshot-on-commit.sh
new file mode 100755
index 000000000..be27cb6e0
--- /dev/null
+++ b/util/publish-snapshot-on-commit.sh
@@ -0,0 +1,12 @@
+# see https://coderwall.com/p/9b_lfq
+
+if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
+   [ "$TRAVIS_JDK_VERSION" == "oraclejdk7" ] && \
+   [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
+   [ "$TRAVIS_BRANCH" == "master" ]; then
+  echo -e "Publishing maven snapshot...\n"
+
+  mvn clean source:jar deploy --settings="util/settings.xml" -DskipTests=true -Dinvoker.skip=true -Dmaven.javadoc.skip=true
+
+  echo -e "Published maven snapshot"
+fi
diff --git a/util/settings.xml b/util/settings.xml
new file mode 100644
index 000000000..91f444b22
--- /dev/null
+++ b/util/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/website/.gitignore b/website/.gitignore
deleted file mode 100644
index 2f71f5da2..000000000
--- a/website/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-_site
-_cache
diff --git a/website/_config.yml b/website/_config.yml
deleted file mode 100644
index 16ca09084..000000000
--- a/website/_config.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-auto: true
-url: "http://square.github.com/dagger/"
diff --git a/website/_layouts/default.html b/website/_layouts/default.html
deleted file mode 100644
index f0d4bb457..000000000
--- a/website/_layouts/default.html
+++ /dev/null
@@ -1,33 +0,0 @@
-<!DOCTYPE html>
-
-<html lang="en">
-<head>
-    <meta charset="utf-8">
-    <title>Dagger &#x2020; A fast dependency injector for Android and Java.</title>
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="A fast dependency injector for Android and Java." />
-    <link href="static/bootstrap.min.css" rel="stylesheet">
-    <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
-    <link href="static/prettify.css" rel="stylesheet">
-    <link href="static/app.css" rel="stylesheet">
-</head>
-<body>
-<div class="container">
-    <div class="row">
-        <div class="span4 side">
-            <h1><img src="static/logo.png" alt="Dagger"></h1>
-            <h3>A fast dependency injector for Android and Java.</h3>
-            <p><a href="https://squareup.com/"><img src="static/square.png" alt="by Square, Inc."></a></p>
-      </div>
-        <div class="offset4 span8 main"><div class="main-inner">
-
-{{ content }}
-
-            <a id="ribbon" href="https://github.com/square/dagger"><img src="static/ribbon.png" alt="Fork me on GitHub"></a>
-        </div></div>
-    </div>
-</div>
-<script src="static/prettify.js"></script>
-<script> prettyPrint(); </script>
-</body>
-</html>
diff --git a/website/index.html b/website/index.html
deleted file mode 100644
index d8957e5d3..000000000
--- a/website/index.html
+++ /dev/null
@@ -1,422 +0,0 @@
----
-layout: default
----
-
-<h3>Introduction</h3>
-
-<p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
-
-<p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
-
-<p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
-
-<p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
-
-<p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
-
-<h3>Using Dagger</h3>
-<p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/example/src/main/java/coffee">coffee example</a>.</p>
-
-<h4>Declaring Dependencies</h4>
-
-<p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
-
-<p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
-
-<pre class="prettyprint">
-class Thermosiphon implements Pump {
-  private final Heater heater;
-
-  @Inject
-  Thermosiphon(Heater heater) {
-    this.heater = heater;
-  }
-
-  ...
-}
-</pre>
-
-<p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
-
-<pre class="prettyprint">
-class CoffeeMaker {
-  @Inject Heater heater;
-  @Inject Pump pump;
-
-  ...
-}
-</pre>
-
-<p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
-
-<p>Dagger does not support method injection.</p>
-
-<h4>Satisfying Dependencies</h4>
-
-<p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
-
-<p>But <code>@Inject</code> doesn't work everywhere:</p>
-
-<ul>
-  <li>Interfaces can't be constructed.</li>
-  <li>Third-party classes can't be annotated.</li>
-  <li>Configurable objects must be configured!</li>
-</ul>
-
-<p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
-
-<p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
-
-<pre class="prettyprint">
-@Provides Heater provideHeater() {
-  return new ElectricHeater();
-}
-</pre>
-
-<p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
-
-<pre class="prettyprint">
-@Provides Pump providePump(Thermosiphon pump) {
-  return pump;
-}
-</pre>
-
-<p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
-
-<pre class="prettyprint">
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater() {
-    return new ElectricHeater();
-  }
-
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
-}
-</pre>
-
-<p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
-
-<h4>Building the Graph</h4>
-
-<p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
-
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-</pre>
-
-<p>In order to put the graph to use we need to create an <strong>entry point</strong>. This is usually the main class that starts the application. In this example, the <code>CoffeeApp</code> class serves as the entry point. We ask the graph to provide an injected instance of this type:</p>
-
-<pre class="prettyprint">
-class CoffeeApp implements Runnable {
-  @Inject CoffeeMaker coffeeMaker;
-
-  @Override public void run() {
-    coffeeMaker.brew();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
-    ...
-  }
-}
-</pre>
-
-<p>The only thing that's missing is that the entry point class <code>CoffeeApp</code> isn't included in the graph. We need to explicitly register it as an entry point in the <code>@Module</code> annotation.</p>
-
-<pre class="prettyprint">
-@Module(
-    entryPoints = CoffeeApp.class
-)
-class DripCoffeeModule {
-  ...
-}
-</pre>
-
-<p>Entry points enable the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
-
-<p>Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.</p>
-
-<pre>
-$ java -cp ... coffee.CoffeeApp
-~ ~ ~ heating ~ ~ ~
-=&gt; =&gt; pumping =&gt; =&gt;
- [_]P coffee! [_]P
-</pre>
-
-<h4>Singletons</h4>
-
-<p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
-
-<pre class="prettyprint">
-@Provides @Singleton Heater provideHeater() {
-  return new ElectricHeater();
-}
-</pre>
-
-<p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
-
-<pre class="prettyprint">
-@Singleton
-class CoffeeMaker {
-  ...
-}
-</pre>
-
-<h4>Lazy injections</h4>
-
-<p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
-
-<pre class="prettyprint">
-class GridingCoffeeMaker {
-  @Inject Lazy&lt;Grinder&gt; lazyGrinder;
-
-  public void brew() {
-    while (needsGrinding()) {
-      // Grinder created once on first call to .get() and cached.
-      lazyGrinder.get().grind();
-    }
-  }
-}
-</pre>
-
-<h4>Provider injections</h4>
-
-<p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
-
-<pre class="prettyprint">
-
-class BigCoffeeMaker {
-  @Inject Provider&lt;Filter&gt; filterProvider;
-
-  public void brew(int numberOfPots) {
-	...
-    for (int p = 0; p &lt; numberOfPots; p++) {
-      maker.addFilter(filterProvider.get()); //new filter every time.
-      maker.addCoffee(...);
-      maker.percolate();
-      ...
-    }
-  }
-}
-</pre>
-
-<p><span class="label label-inverse">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
-
-<h4>Qualifiers</h4>
-
-<p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
-
-<p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
-
-<pre class="prettyprint">
-@Qualifier
-@Documented
-@Retention(RUNTIME)
-public @interface Named {
-  String value() default "";
-}
-</pre>
-
-<p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
-
-<pre class="prettyprint">
-class ExpensiveCoffeeMaker {
-  @Inject @Named("water") Heater waterHeater;
-  @Inject @Named("hot plate") Heater hotPlateHeater;
-  ...
-}
-</pre>
-
-<p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
-
-<pre class="prettyprint">
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
-  return new ElectricHeater(70);
-}
-
-@Provides @Named("water") Heater provideWaterHeater() {
-  return new ElectricHeater(93);
-}
-</pre>
-
-<p>Dependencies may not have multiple qualifier annotations.</p>
-
-<h4>Static Injection</h4>
-
-<p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
-
-<p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
-
-<pre class="prettyprint">
-@Module(
-    staticInjections = LegacyCoffeeUtils.class
-)
-class LegacyModule {
-}
-</pre>
-
-<p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
-
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
-objectGraph.injectStatics();
-</pre>
-
-<h4>Compile-time Validation</h4>
-
-<p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
-
-<pre class="prettyprint">
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-</pre>
-
-<p>When compiling it, <code>javac</code> rejects the missing binding:</p>
-
-<pre>
-[ERROR] COMPILATION ERROR :
-[ERROR] error: No binding for java.util.concurrent.Executor
-               required by provideHeater(java.util.concurrent.Executor)
-</pre>
-
-<p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
-
-<pre class="prettyprint">
-@Module(complete = false)
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-</pre>
-
-<p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
-
-<pre class="prettyprint">
-@Module(
-    includes = {
-        DripCoffeeModule.class,
-        ExecutorModule.class
-    }
-)
-public class CoffeeAppModule {
-}
-</pre>
-
-<p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
-
-<h4>Compile-time Code Generation</h4>
-
-<p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
-
-<h4>Module overrides</h4>
-
-<p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
-
-<p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
-
-<pre class="prettyprint">
-public class CoffeeMakerTest {
-  @Inject CoffeeMaker coffeeMaker;
-  @Inject Heater heater;
-
-  @Before public void setUp() {
-    ObjectGraph.create(new TestModule()).inject(this);
-  }
-
-  @Module(
-      includes = DripCoffeeModule.class,
-      entryPoints = CoffeeMakerTest.class,
-      overrides = true
-  )
-  static class TestModule {
-    @Provides @Singleton Heater provideHeater() {
-      return Mockito.mock(Heater.class);
-    }
-  }
-
-  @Test public void testHeaterIsTurnedOnAndThenOff() {
-    Mockito.when(heater.isHot()).thenReturn(true);
-    coffeeMaker.brew();
-    Mockito.verify(heater, Mockito.times(1)).on();
-    Mockito.verify(heater, Mockito.times(1)).off();
-  }
-}
-</pre>
-
-<p>Overrides are best suited for small variations on the application:</p>
-<ul>
-  <li>Replacing the real implementation with a mock for unit tests.</li>
-  <li>Replacing LDAP authentication with fake authentication for development.</li>
-</ul>
-
-<p>For more substantial variations it's often simpler to use a different combination of modules.</p>
-
-
-<h3>Using Dagger In Your Build</h3>
-
-<p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
-
-<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as a dependency of the compiler plugin:</p>
-
-<pre class="prettyprint">
-&lt;dependencies>
-  &lt;dependency>
-    &lt;groupId>com.squareup&lt;/groupId>
-    &lt;artifactId>dagger&lt;/artifactId>
-    &lt;version>${dagger.version}&lt;/version>
-  &lt;/dependency>
-&lt;/dependencies>
-&lt;build>
-  &lt;plugins>
-    &lt;plugin>
-      &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
-      &lt;dependencies>
-        &lt;dependency>
-          &lt;groupId>com.squareup&lt;/groupId>
-          &lt;artifactId>dagger-compiler&lt;/artifactId>
-          &lt;version>${dagger.version}&lt;/version>
-        &lt;/dependency>
-      &lt;/dependencies>
-    &lt;/plugin>
-  &lt;/plugins>
-&lt;/build>
-</pre>
-
-
-
-<h3>Upgrading from Guice</h3>
-
-<p>Some notable Guice features that Dagger doesn't support:</p>
-<ul>
-  <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
-  <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
-  <li>Method injection.</li>
-  <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
-</ul>
-
-
-<h3>License</h3>
-
-<pre>
-Copyright 2012 Square, Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-</pre>
diff --git a/website/static/app.css b/website/static/app.css
deleted file mode 100644
index 3c3f53ae6..000000000
--- a/website/static/app.css
+++ /dev/null
@@ -1,99 +0,0 @@
-body {
-    background: #212121 url('debut_dark.png') fixed repeat;
-    margin-top: 40px;
-    color: #c6c6c6;
-    text-shadow: 1px 0px 1px black;
-    line-height: 20px;
-}
-
-code, pre {
-    color: #bbb;
-    background: none;
-    border: none;
-}
-pre {
-    font-size: 10px;
-}
-code {
-    white-space: nowrap;
-}
-
-.side h1 {
-    font-weight: normal;
-    font-size: 90px;
-    line-height: 90px;
-    margin-bottom: 25px;
-    color: #f0f0f0;
-}
-.side h3 {
-    font-weight: normal;
-    margin-bottom: 40px;
-    color: #aaa;
-}
-.side ul {
-    margin-bottom: 30px;
-}
-
-.main {
-    padding-top: 40px;
-    padding-bottom: 40px;
-}
-.main h3 {
-    padding-top: 40px;
-    margin-top: 0;
-    margin-bottom: 10px;
-}
-.main h4 {
-    padding-top: 30px;
-    margin-top: 0;
-    margin-bottom: 8px;
-    text-transform: uppercase;
-}
-.main h4:first-child, .main h3:first-child {
-    padding-top: 0;
-}
-.main h5 {
-    font-size: 12px;
-    margin-top: 14px;
-    margin-bottom: 4px;
-    color: #666;
-    text-transform: uppercase;
-}
-
-#ribbon img {
-    position: absolute;
-    top: 0;
-    right: 0;
-    border: 0;
-}
-
-a:link, a:visited, a:active, a:hover {
-    color: #72A4B4;
-}
-a:hover {
-    text-decoration: underline;
-}
-
-@media(min-width:768px) {
-    body {
-        margin-top: 60px;
-    }
-    .side {
-        text-align: right;
-        position: fixed;
-    }
-    .side ul {
-        margin-bottom: 60px;
-    }
-    .main {
-        padding-top: 28px;
-        padding-bottom: 100px;
-    }
-    .main-inner {
-        margin-left: 25px;
-    }
-
-    #ribbon img {
-        position: fixed;
-    }
-}
\ No newline at end of file
diff --git a/website/static/bootstrap-responsive.min.css b/website/static/bootstrap-responsive.min.css
deleted file mode 100644
index 515b2d080..000000000
--- a/website/static/bootstrap-responsive.min.css
+++ /dev/null
@@ -1,10 +0,0 @@
-/*!
- * Bootstrap Responsive v2.0.4
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.hidden{display:none;visibility:hidden}.visible-phone{display:none!important}.visible-tablet{display:none!important}.hidden-desktop{display:none!important}@media(max-width:767px){.visible-phone{display:inherit!important}.hidden-phone{display:none!important}.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}}@media(min-width:768px) and (max-width:979px){.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}}@media(max-width:480px){.nav-collapse{-webkit-transform:translate3d(0,0,0)}.page-header h1 small{display:block;line-height:18px}input[type="checkbox"],input[type="radio"]{border:1px solid #ccc}.form-horizontal .control-group>label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-right:10px;padding-left:10px}.modal{position:fixed;top:10px;right:10px;left:10px;width:auto;margin:0}.modal.fade.in{top:auto}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media(max-width:767px){body{padding-right:20px;padding-left:20px}.navbar-fixed-top,.navbar-fixed-bottom{margin-right:-20px;margin-left:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;width:auto;clear:none;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}[class*="span"],.row-fluid [class*="span"]{display:block;float:none;width:auto;margin-left:0}.input-large,.input-xlarge,.input-xxlarge,input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.input-prepend input,.input-append input,.input-prepend input[class*="span"],.input-append input[class*="span"]{display:inline-block;width:auto}}@media(min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;content:""}.row:after{clear:both}[class*="span"]{float:left;margin-left:20px}.container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:724px}.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:28px;margin-left:2.762430939%;*margin-left:2.709239449638298%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .span12{width:99.999999993%;*width:99.9468085036383%}.row-fluid .span11{width:91.436464082%;*width:91.38327259263829%}.row-fluid .span10{width:82.87292817100001%;*width:82.8197366816383%}.row-fluid .span9{width:74.30939226%;*width:74.25620077063829%}.row-fluid .span8{width:65.74585634900001%;*width:65.6926648596383%}.row-fluid .span7{width:57.182320438000005%;*width:57.129128948638304%}.row-fluid .span6{width:48.618784527%;*width:48.5655930376383%}.row-fluid .span5{width:40.055248616%;*width:40.0020571266383%}.row-fluid .span4{width:31.491712705%;*width:31.4385212156383%}.row-fluid .span3{width:22.928176794%;*width:22.874985304638297%}.row-fluid .span2{width:14.364640883%;*width:14.311449393638298%}.row-fluid .span1{width:5.801104972%;*width:5.747913482638298%}.row-fluid .offset12{margin-left:105.524861871%;*margin-left:105.41847889227658%}.row-fluid .offset12:first-child{margin-left:102.762430932%;*margin-left:102.65604795327658%}.row-fluid .offset11{margin-left:96.96132596%;*margin-left:96.85494298127658%}.row-fluid .offset11:first-child{margin-left:94.198895021%;*margin-left:94.09251204227658%}.row-fluid .offset10{margin-left:88.39779004900001%;*margin-left:88.29140707027659%}.row-fluid .offset10:first-child{margin-left:85.63535911000001%;*margin-left:85.5289761312766%}.row-fluid .offset9{margin-left:79.83425413799999%;*margin-left:79.72787115927657%}.row-fluid .offset9:first-child{margin-left:77.071823199%;*margin-left:76.96544022027658%}.row-fluid .offset8{margin-left:71.270718227%;*margin-left:71.16433524827659%}.row-fluid .offset8:first-child{margin-left:68.508287288%;*margin-left:68.40190430927659%}.row-fluid .offset7{margin-left:62.70718231600001%;*margin-left:62.600799337276605%}.row-fluid .offset7:first-child{margin-left:59.944751377%;*margin-left:59.8383683982766%}.row-fluid .offset6{margin-left:54.143646405000005%;*margin-left:54.0372634262766%}.row-fluid .offset6:first-child{margin-left:51.381215466%;*margin-left:51.2748324872766%}.row-fluid .offset5{margin-left:45.580110494%;*margin-left:45.4737275152766%}.row-fluid .offset5:first-child{margin-left:42.817679555%;*margin-left:42.711296576276595%}.row-fluid .offset4{margin-left:37.016574583%;*margin-left:36.9101916042766%}.row-fluid .offset4:first-child{margin-left:34.254143644%;*margin-left:34.1477606652766%}.row-fluid .offset3{margin-left:28.453038671999998%;*margin-left:28.346655693276595%}.row-fluid .offset3:first-child{margin-left:25.690607733%;*margin-left:25.584224754276597%}.row-fluid .offset2{margin-left:19.889502761%;*margin-left:19.783119782276597%}.row-fluid .offset2:first-child{margin-left:17.127071822%;*margin-left:17.0206888432766%}.row-fluid .offset1{margin-left:11.32596685%;*margin-left:11.219583871276598%}.row-fluid .offset1:first-child{margin-left:8.563535911%;*margin-left:8.457152932276596%}input,textarea,.uneditable-input{margin-left:0}input.span12,textarea.span12,.uneditable-input.span12{width:714px}input.span11,textarea.span11,.uneditable-input.span11{width:652px}input.span10,textarea.span10,.uneditable-input.span10{width:590px}input.span9,textarea.span9,.uneditable-input.span9{width:528px}input.span8,textarea.span8,.uneditable-input.span8{width:466px}input.span7,textarea.span7,.uneditable-input.span7{width:404px}input.span6,textarea.span6,.uneditable-input.span6{width:342px}input.span5,textarea.span5,.uneditable-input.span5{width:280px}input.span4,textarea.span4,.uneditable-input.span4{width:218px}input.span3,textarea.span3,.uneditable-input.span3{width:156px}input.span2,textarea.span2,.uneditable-input.span2{width:94px}input.span1,textarea.span1,.uneditable-input.span1{width:32px}}@media(max-width:979px){body{padding-top:0}.navbar-fixed-top,.navbar-fixed-bottom{position:static}.navbar-fixed-top{margin-bottom:18px}.navbar-fixed-bottom{margin-top:18px}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-right:10px;padding-left:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 9px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#999;text-shadow:none}.nav-collapse .nav>li>a,.nav-collapse .dropdown-menu a{padding:6px 15px;font-weight:bold;color:#999;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.nav-collapse .btn{padding:4px 10px 4px;font-weight:normal;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .nav>li>a:hover,.nav-collapse .dropdown-menu a:hover{background-color:#222}.nav-collapse.in .btn-group{padding:0;margin-top:5px}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;display:block;float:none;max-width:none;padding:0;margin:0 15px;background-color:transparent;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.nav-collapse .dropdown-menu:before,.nav-collapse .dropdown-menu:after{display:none}.nav-collapse .dropdown-menu .divider{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:9px 15px;margin:9px 0;border-top:1px solid #222;border-bottom:1px solid #222;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1)}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{height:0;overflow:hidden}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-right:10px;padding-left:10px}}
-/* Modified to remove 976px+ expansion. */
\ No newline at end of file
diff --git a/website/static/bootstrap.min.css b/website/static/bootstrap.min.css
deleted file mode 100644
index 3916580b0..000000000
--- a/website/static/bootstrap.min.css
+++ /dev/null
@@ -1,9 +0,0 @@
-/*!
- * Bootstrap v2.0.4
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:hover,a:active{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{max-width:100%;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}input[type="search"]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}body{margin:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;line-height:18px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:hover{color:#005580;text-decoration:underline}.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;content:""}.row:after{clear:both}[class*="span"]{float:left;margin-left:20px}.container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:28px;margin-left:2.127659574%;*margin-left:2.0744680846382977%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .span12{width:99.99999998999999%;*width:99.94680850063828%}.row-fluid .span11{width:91.489361693%;*width:91.4361702036383%}.row-fluid .span10{width:82.97872339599999%;*width:82.92553190663828%}.row-fluid .span9{width:74.468085099%;*width:74.4148936096383%}.row-fluid .span8{width:65.95744680199999%;*width:65.90425531263828%}.row-fluid .span7{width:57.446808505%;*width:57.3936170156383%}.row-fluid .span6{width:48.93617020799999%;*width:48.88297871863829%}.row-fluid .span5{width:40.425531911%;*width:40.3723404216383%}.row-fluid .span4{width:31.914893614%;*width:31.8617021246383%}.row-fluid .span3{width:23.404255317%;*width:23.3510638276383%}.row-fluid .span2{width:14.89361702%;*width:14.8404255306383%}.row-fluid .span1{width:6.382978723%;*width:6.329787233638298%}.row-fluid .offset12{margin-left:104.25531913799999%;*margin-left:104.14893615927657%}.row-fluid .offset12:first-child{margin-left:102.127659564%;*margin-left:102.02127658527658%}.row-fluid .offset11{margin-left:95.744680841%;*margin-left:95.63829786227659%}.row-fluid .offset11:first-child{margin-left:93.61702126700001%;*margin-left:93.5106382882766%}.row-fluid .offset10{margin-left:87.23404254399999%;*margin-left:87.12765956527657%}.row-fluid .offset10:first-child{margin-left:85.10638297%;*margin-left:84.99999999127658%}.row-fluid .offset9{margin-left:78.723404247%;*margin-left:78.61702126827659%}.row-fluid .offset9:first-child{margin-left:76.59574467300001%;*margin-left:76.4893616942766%}.row-fluid .offset8{margin-left:70.21276594999999%;*margin-left:70.10638297127657%}.row-fluid .offset8:first-child{margin-left:68.085106376%;*margin-left:67.97872339727658%}.row-fluid .offset7{margin-left:61.702127653%;*margin-left:61.595744674276595%}.row-fluid .offset7:first-child{margin-left:59.574468079%;*margin-left:59.468085100276596%}.row-fluid .offset6{margin-left:53.19148935599999%;*margin-left:53.08510637727659%}.row-fluid .offset6:first-child{margin-left:51.06382978199999%;*margin-left:50.95744680327659%}.row-fluid .offset5{margin-left:44.680851059%;*margin-left:44.574468080276596%}.row-fluid .offset5:first-child{margin-left:42.553191485%;*margin-left:42.4468085062766%}.row-fluid .offset4{margin-left:36.170212762%;*margin-left:36.063829783276596%}.row-fluid .offset4:first-child{margin-left:34.042553188%;*margin-left:33.9361702092766%}.row-fluid .offset3{margin-left:27.659574465%;*margin-left:27.553191486276596%}.row-fluid .offset3:first-child{margin-left:25.531914891%;*margin-left:25.425531912276597%}.row-fluid .offset2{margin-left:19.148936168%;*margin-left:19.042553189276596%}.row-fluid .offset2:first-child{margin-left:17.021276594%;*margin-left:16.914893615276597%}.row-fluid .offset1{margin-left:10.638297870999999%;*margin-left:10.531914892276596%}.row-fluid .offset1:first-child{margin-left:8.510638297%;*margin-left:8.404255318276597%}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:before,.container:after{display:table;content:""}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:before,.container-fluid:after{display:table;content:""}.container-fluid:after{clear:both}p{margin:0 0 9px}p small{font-size:11px;color:#999}.lead{margin-bottom:18px;font-size:20px;font-weight:200;line-height:27px}h1,h2,h3,h4,h5,h6{margin:0;font-family:inherit;font-weight:bold;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:normal;color:#999}h1{font-size:30px;line-height:36px}h1 small{font-size:18px}h2{font-size:24px;line-height:36px}h2 small{font-size:18px}h3{font-size:18px;line-height:27px}h3 small{font-size:14px}h4,h5,h6{line-height:18px}h4{font-size:14px}h4 small{font-size:12px}h5{font-size:12px}h6{font-size:11px;color:#999;text-transform:uppercase}.page-header{padding-bottom:17px;margin:18px 0;border-bottom:1px solid #eee}.page-header h1{line-height:1}ul,ol{padding:0;margin:0 0 9px 25px}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}ul{list-style:disc}ol{list-style:decimal}li{line-height:18px}ul.unstyled,ol.unstyled{margin-left:0;list-style:none}dl{margin-bottom:18px}dt,dd{line-height:18px}dt{font-weight:bold;line-height:17px}dd{margin-left:9px}.dl-horizontal dt{float:left;width:120px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:130px}hr{margin:18px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}strong{font-weight:bold}em{font-style:italic}.muted{color:#999}abbr[title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 18px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:16px;font-weight:300;line-height:22.5px}blockquote small{display:block;line-height:18px;color:#999}blockquote small:before{content:'\2014 \00A0'}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}q:before,q:after,blockquote:before,blockquote:after{content:""}address{display:block;margin-bottom:18px;font-style:normal;line-height:18px}small{font-size:100%}cite{font-style:normal}code,pre{padding:0 3px 2px;font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:12px;color:#333;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}code{padding:2px 4px;color:#d14;background-color:#f7f7f9;border:1px solid #e1e1e8}pre{display:block;padding:8.5px;margin:0 0 9px;font-size:12.025px;line-height:18px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}pre.prettyprint{margin-bottom:18px}pre code{padding:0;color:inherit;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}form{margin:0 0 18px}fieldset{padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:27px;font-size:19.5px;line-height:36px;color:#333;border:0;border-bottom:1px solid #e5e5e5}legend small{font-size:13.5px;color:#999}label,input,button,select,textarea{font-size:13px;font-weight:normal;line-height:18px}input,button,select,textarea{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}select,textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{display:inline-block;height:18px;padding:4px;margin-bottom:9px;font-size:13px;line-height:18px;color:#555;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}input,textarea{width:210px}textarea{height:auto}textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{background-color:#fff;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border linear .2s,box-shadow linear .2s;-moz-transition:border linear .2s,box-shadow linear .2s;-ms-transition:border linear .2s,box-shadow linear .2s;-o-transition:border linear .2s,box-shadow linear .2s;transition:border linear .2s,box-shadow linear .2s}textarea:focus,input[type="text"]:focus,input[type="password"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,.uneditable-input:focus{border-color:rgba(82,168,236,0.8);outline:0;outline:thin dotted \9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6)}input[type="radio"],input[type="checkbox"]{margin:3px 0;*margin-top:0;line-height:normal;cursor:pointer}input[type="image"],input[type="submit"],input[type="reset"],input[type="button"],input[type="radio"],input[type="checkbox"]{width:auto}.uneditable-textarea{width:auto;height:auto}select,input[type="file"]{height:28px;*margin-top:4px;line-height:28px}select{width:220px;border:1px solid #bbb}select[multiple],select[size]{height:auto}select:focus,input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.radio,.checkbox{min-height:18px;padding-left:18px}.radio input[type="radio"],.checkbox input[type="checkbox"]{float:left;margin-left:-18px}.controls>.radio:first-child,.controls>.checkbox:first-child{padding-top:5px}.radio.inline,.checkbox.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.radio.inline+.radio.inline,.checkbox.inline+.checkbox.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"]{float:none;margin-left:0}.input-append input[class*="span"],.input-append .uneditable-input[class*="span"],.input-prepend input[class*="span"],.input-prepend .uneditable-input[class*="span"],.row-fluid .input-prepend [class*="span"],.row-fluid .input-append [class*="span"]{display:inline-block}input,textarea,.uneditable-input{margin-left:0}input.span12,textarea.span12,.uneditable-input.span12{width:930px}input.span11,textarea.span11,.uneditable-input.span11{width:850px}input.span10,textarea.span10,.uneditable-input.span10{width:770px}input.span9,textarea.span9,.uneditable-input.span9{width:690px}input.span8,textarea.span8,.uneditable-input.span8{width:610px}input.span7,textarea.span7,.uneditable-input.span7{width:530px}input.span6,textarea.span6,.uneditable-input.span6{width:450px}input.span5,textarea.span5,.uneditable-input.span5{width:370px}input.span4,textarea.span4,.uneditable-input.span4{width:290px}input.span3,textarea.span3,.uneditable-input.span3{width:210px}input.span2,textarea.span2,.uneditable-input.span2{width:130px}input.span1,textarea.span1,.uneditable-input.span1{width:50px}input[disabled],select[disabled],textarea[disabled],input[readonly],select[readonly],textarea[readonly]{cursor:not-allowed;background-color:#eee;border-color:#ddd}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"][readonly],input[type="checkbox"][readonly]{background-color:transparent}.control-group.warning>label,.control-group.warning .help-block,.control-group.warning .help-inline{color:#c09853}.control-group.warning .checkbox,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853;border-color:#c09853}.control-group.warning .checkbox:focus,.control-group.warning .radio:focus,.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;-webkit-box-shadow:0 0 6px #dbc59e;-moz-box-shadow:0 0 6px #dbc59e;box-shadow:0 0 6px #dbc59e}.control-group.warning .input-prepend .add-on,.control-group.warning .input-append .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error>label,.control-group.error .help-block,.control-group.error .help-inline{color:#b94a48}.control-group.error .checkbox,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48;border-color:#b94a48}.control-group.error .checkbox:focus,.control-group.error .radio:focus,.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;-webkit-box-shadow:0 0 6px #d59392;-moz-box-shadow:0 0 6px #d59392;box-shadow:0 0 6px #d59392}.control-group.error .input-prepend .add-on,.control-group.error .input-append .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success>label,.control-group.success .help-block,.control-group.success .help-inline{color:#468847}.control-group.success .checkbox,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847;border-color:#468847}.control-group.success .checkbox:focus,.control-group.success .radio:focus,.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;-webkit-box-shadow:0 0 6px #7aba7b;-moz-box-shadow:0 0 6px #7aba7b;box-shadow:0 0 6px #7aba7b}.control-group.success .input-prepend .add-on,.control-group.success .input-append .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}input:focus:required:invalid,textarea:focus:required:invalid,select:focus:required:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:required:invalid:focus,textarea:focus:required:invalid:focus,select:focus:required:invalid:focus{border-color:#e9322d;-webkit-box-shadow:0 0 6px #f8b9b7;-moz-box-shadow:0 0 6px #f8b9b7;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:17px 20px 18px;margin-top:18px;margin-bottom:18px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:before,.form-actions:after{display:table;content:""}.form-actions:after{clear:both}.uneditable-input{overflow:hidden;white-space:nowrap;cursor:not-allowed;background-color:#fff;border-color:#eee;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);box-shadow:inset 0 1px 2px rgba(0,0,0,0.025)}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.help-block,.help-inline{color:#555}.help-block{display:block;margin-bottom:9px}.help-inline{display:inline-block;*display:inline;padding-left:5px;vertical-align:middle;*zoom:1}.input-prepend,.input-append{margin-bottom:5px;font-size:0}.input-prepend input,.input-append input,.input-prepend select,.input-append select,.input-prepend .uneditable-input,.input-append .uneditable-input{position:relative;margin-bottom:0;*margin-left:0;font-size:13px;vertical-align:middle;-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-prepend input:focus,.input-append input:focus,.input-prepend select:focus,.input-append select:focus,.input-prepend .uneditable-input:focus,.input-append .uneditable-input:focus{z-index:2}.input-prepend .uneditable-input,.input-append .uneditable-input{border-left-color:#ccc}.input-prepend .add-on,.input-append .add-on{display:inline-block;width:auto;height:18px;min-width:16px;padding:4px 5px;font-size:13px;font-weight:normal;line-height:18px;text-align:center;text-shadow:0 1px 0 #fff;vertical-align:middle;background-color:#eee;border:1px solid #ccc}.input-prepend .add-on,.input-append .add-on,.input-prepend .btn,.input-append .btn{margin-left:-1px;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend .active,.input-append .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-prepend .add-on:first-child,.input-prepend .btn:first-child{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-append input,.input-append select,.input-append .uneditable-input{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-append .uneditable-input{border-right-color:#ccc;border-left-color:#eee}.input-append .add-on:last-child,.input-append .btn:last-child{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-prepend.input-append input,.input-prepend.input-append select,.input-prepend.input-append .uneditable-input{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}input.search-query{padding-right:14px;padding-right:4px \9;padding-left:14px;padding-left:4px \9;margin-bottom:0;-webkit-border-radius:14px;-moz-border-radius:14px;border-radius:14px}.form-search input,.form-inline input,.form-horizontal input,.form-search textarea,.form-inline textarea,.form-horizontal textarea,.form-search select,.form-inline select,.form-horizontal select,.form-search .help-inline,.form-inline .help-inline,.form-horizontal .help-inline,.form-search .uneditable-input,.form-inline .uneditable-input,.form-horizontal .uneditable-input,.form-search .input-prepend,.form-inline .input-prepend,.form-horizontal .input-prepend,.form-search .input-append,.form-inline .input-append,.form-horizontal .input-append{display:inline-block;*display:inline;margin-bottom:0;*zoom:1}.form-search .hide,.form-inline .hide,.form-horizontal .hide{display:none}.form-search label,.form-inline label{display:inline-block}.form-search .input-append,.form-inline .input-append,.form-search .input-prepend,.form-inline .input-prepend{margin-bottom:0}.form-search .radio,.form-search .checkbox,.form-inline .radio,.form-inline .checkbox{padding-left:0;margin-bottom:0;vertical-align:middle}.form-search .radio input[type="radio"],.form-search .checkbox input[type="checkbox"],.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:9px}legend+.control-group{margin-top:18px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:18px;*zoom:1}.form-horizontal .control-group:before,.form-horizontal .control-group:after{display:table;content:""}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:140px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:160px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:160px}.form-horizontal .help-block{margin-top:9px;margin-bottom:0}.form-horizontal .form-actions{padding-left:160px}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:18px}.table th,.table td{padding:8px;line-height:18px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:bold}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child th,.table caption+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table thead:first-child tr:first-child th,.table thead:first-child tr:first-child td{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table-condensed th,.table-condensed td{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapsed;border-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.table-bordered th,.table-bordered td{border-left:1px solid #ddd}.table-bordered caption+thead tr:first-child th,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+tbody tr:first-child td,.table-bordered colgroup+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered thead:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child td{border-top:0}.table-bordered thead:first-child tr:first-child th:first-child,.table-bordered tbody:first-child tr:first-child td:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered thead:first-child tr:first-child th:last-child,.table-bordered tbody:first-child tr:first-child td:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-bordered thead:last-child tr:last-child th:first-child,.table-bordered tbody:last-child tr:last-child td:first-child{-webkit-border-radius:0 0 0 4px;-moz-border-radius:0 0 0 4px;border-radius:0 0 0 4px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.table-bordered thead:last-child tr:last-child th:last-child,.table-bordered tbody:last-child tr:last-child td:last-child{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px}.table-striped tbody tr:nth-child(odd) td,.table-striped tbody tr:nth-child(odd) th{background-color:#f9f9f9}.table tbody tr:hover td,.table tbody tr:hover th{background-color:#f5f5f5}table .span1{float:none;width:44px;margin-left:0}table .span2{float:none;width:124px;margin-left:0}table .span3{float:none;width:204px;margin-left:0}table .span4{float:none;width:284px;margin-left:0}table .span5{float:none;width:364px;margin-left:0}table .span6{float:none;width:444px;margin-left:0}table .span7{float:none;width:524px;margin-left:0}table .span8{float:none;width:604px;margin-left:0}table .span9{float:none;width:684px;margin-left:0}table .span10{float:none;width:764px;margin-left:0}table .span11{float:none;width:844px;margin-left:0}table .span12{float:none;width:924px;margin-left:0}table .span13{float:none;width:1004px;margin-left:0}table .span14{float:none;width:1084px;margin-left:0}table .span15{float:none;width:1164px;margin-left:0}table .span16{float:none;width:1244px;margin-left:0}table .span17{float:none;width:1324px;margin-left:0}table .span18{float:none;width:1404px;margin-left:0}table .span19{float:none;width:1484px;margin-left:0}table .span20{float:none;width:1564px;margin-left:0}table .span21{float:none;width:1644px;margin-left:0}table .span22{float:none;width:1724px;margin-left:0}table .span23{float:none;width:1804px;margin-left:0}table .span24{float:none;width:1884px;margin-left:0}[class^="icon-"],[class*=" icon-"]{display:inline-block;width:14px;height:14px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url("../img/glyphicons-halflings.png");background-position:14px 14px;background-repeat:no-repeat}[class^="icon-"]:last-child,[class*=" icon-"]:last-child{*margin-left:0}.icon-white{background-image:url("../img/glyphicons-halflings-white.png")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{width:16px;background-position:-216px -120px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{background-position:-384px -120px}.icon-folder-open{width:16px;background-position:-408px -120px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.dropup,.dropdown{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:"";opacity:.3;filter:alpha(opacity=30)}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown a:focus .caret,.dropdown a:hover .caret,.open .caret{opacity:1;filter:alpha(opacity=100)}.navbar .nav .open>a{color:#fff}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:1px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);*border-right-width:2px;*border-bottom-width:2px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:8px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu a{display:block;padding:3px 15px;clear:both;font-weight:normal;line-height:18px;color:#333;white-space:nowrap}.dropdown-menu li>a:hover,.dropdown-menu li>a:focus{color:#333;text-decoration:none;background-color:#eee}.dropdown-menu .active>a,.dropdown-menu .active>a:hover{color:#fff;text-decoration:none;background-color:#08c;outline:0}.dropdown-menu .disabled>a,.dropdown-menu .disabled>a:hover{color:#999}.dropdown-menu .disabled>a:hover{text-decoration:none;cursor:default;background-color:transparent}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:"\2191"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.typeahead{margin-top:2px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #eee;border:1px solid rgba(0,0,0,0.05);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-large{padding:24px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.well-small{padding:9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;-ms-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;-moz-transition:height .35s ease;-ms-transition:height .35s ease;-o-transition:height .35s ease;transition:height .35s ease}.collapse.in{height:auto}.close{float:right;font-size:20px;font-weight:bold;line-height:18px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.btn{display:inline-block;*display:inline;padding:4px 10px 4px;margin-bottom:0;*margin-left:.3em;font-size:13px;line-height:18px;*line-height:20px;color:#333;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;*background-color:#e6e6e6;background-image:-ms-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(top,#fff,#e6e6e6);background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-repeat:repeat-x;border:1px solid #ccc;*border:0;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-bottom-color:#b3b3b3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffffffff',endColorstr='#ffe6e6e6',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false);*zoom:1;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover,.btn:active,.btn.active,.btn.disabled,.btn[disabled]{background-color:#e6e6e6;*background-color:#d9d9d9}.btn:active,.btn.active{background-color:#ccc \9}.btn:first-child{*margin-left:0}.btn:hover{color:#333;text-decoration:none;background-color:#e6e6e6;*background-color:#d9d9d9;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-ms-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-color:#e6e6e6;background-color:#d9d9d9 \9;background-image:none;outline:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn.disabled,.btn[disabled]{cursor:default;background-color:#e6e6e6;background-image:none;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-large{padding:9px 14px;font-size:15px;line-height:normal;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.btn-large [class^="icon-"]{margin-top:1px}.btn-small{padding:5px 9px;font-size:11px;line-height:16px}.btn-small [class^="icon-"]{margin-top:-1px}.btn-mini{padding:2px 6px;font-size:11px;line-height:14px}.btn-primary,.btn-primary:hover,.btn-warning,.btn-warning:hover,.btn-danger,.btn-danger:hover,.btn-success,.btn-success:hover,.btn-info,.btn-info:hover,.btn-inverse,.btn-inverse:hover{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.btn-primary.active,.btn-warning.active,.btn-danger.active,.btn-success.active,.btn-info.active,.btn-inverse.active{color:rgba(255,255,255,0.75)}.btn{border-color:#ccc;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25)}.btn-primary{background-color:#0074cc;*background-color:#05c;background-image:-ms-linear-gradient(top,#08c,#05c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#05c));background-image:-webkit-linear-gradient(top,#08c,#05c);background-image:-o-linear-gradient(top,#08c,#05c);background-image:-moz-linear-gradient(top,#08c,#05c);background-image:linear-gradient(top,#08c,#05c);background-repeat:repeat-x;border-color:#05c #05c #003580;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0055cc',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-primary:hover,.btn-primary:active,.btn-primary.active,.btn-primary.disabled,.btn-primary[disabled]{background-color:#05c;*background-color:#004ab3}.btn-primary:active,.btn-primary.active{background-color:#004099 \9}.btn-warning{background-color:#faa732;*background-color:#f89406;background-image:-ms-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(top,#fbb450,#f89406);background-repeat:repeat-x;border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-warning:hover,.btn-warning:active,.btn-warning.active,.btn-warning.disabled,.btn-warning[disabled]{background-color:#f89406;*background-color:#df8505}.btn-warning:active,.btn-warning.active{background-color:#c67605 \9}.btn-danger{background-color:#da4f49;*background-color:#bd362f;background-image:-ms-linear-gradient(top,#ee5f5b,#bd362f);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#bd362f));background-image:-webkit-linear-gradient(top,#ee5f5b,#bd362f);background-image:-o-linear-gradient(top,#ee5f5b,#bd362f);background-image:-moz-linear-gradient(top,#ee5f5b,#bd362f);background-image:linear-gradient(top,#ee5f5b,#bd362f);background-repeat:repeat-x;border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffbd362f',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-danger:hover,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{background-color:#bd362f;*background-color:#a9302a}.btn-danger:active,.btn-danger.active{background-color:#942a25 \9}.btn-success{background-color:#5bb75b;*background-color:#51a351;background-image:-ms-linear-gradient(top,#62c462,#51a351);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#51a351));background-image:-webkit-linear-gradient(top,#62c462,#51a351);background-image:-o-linear-gradient(top,#62c462,#51a351);background-image:-moz-linear-gradient(top,#62c462,#51a351);background-image:linear-gradient(top,#62c462,#51a351);background-repeat:repeat-x;border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff51a351',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-success:hover,.btn-success:active,.btn-success.active,.btn-success.disabled,.btn-success[disabled]{background-color:#51a351;*background-color:#499249}.btn-success:active,.btn-success.active{background-color:#408140 \9}.btn-info{background-color:#49afcd;*background-color:#2f96b4;background-image:-ms-linear-gradient(top,#5bc0de,#2f96b4);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#2f96b4));background-image:-webkit-linear-gradient(top,#5bc0de,#2f96b4);background-image:-o-linear-gradient(top,#5bc0de,#2f96b4);background-image:-moz-linear-gradient(top,#5bc0de,#2f96b4);background-image:linear-gradient(top,#5bc0de,#2f96b4);background-repeat:repeat-x;border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff2f96b4',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-info:hover,.btn-info:active,.btn-info.active,.btn-info.disabled,.btn-info[disabled]{background-color:#2f96b4;*background-color:#2a85a0}.btn-info:active,.btn-info.active{background-color:#24748c \9}.btn-inverse{background-color:#414141;*background-color:#222;background-image:-ms-linear-gradient(top,#555,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#555),to(#222));background-image:-webkit-linear-gradient(top,#555,#222);background-image:-o-linear-gradient(top,#555,#222);background-image:-moz-linear-gradient(top,#555,#222);background-image:linear-gradient(top,#555,#222);background-repeat:repeat-x;border-color:#222 #222 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff555555',endColorstr='#ff222222',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-inverse:hover,.btn-inverse:active,.btn-inverse.active,.btn-inverse.disabled,.btn-inverse[disabled]{background-color:#222;*background-color:#151515}.btn-inverse:active,.btn-inverse.active{background-color:#080808 \9}button.btn,input[type="submit"].btn{*padding-top:2px;*padding-bottom:2px}button.btn::-moz-focus-inner,input[type="submit"].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type="submit"].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type="submit"].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type="submit"].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-group{position:relative;*margin-left:.3em;*zoom:1}.btn-group:before,.btn-group:after{display:table;content:""}.btn-group:after{clear:both}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{margin-top:9px;margin-bottom:9px}.btn-toolbar .btn-group{display:inline-block;*display:inline;*zoom:1}.btn-group>.btn{position:relative;float:left;margin-left:-1px;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group>.btn:first-child{margin-left:0;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.btn-group>.btn.large:first-child{margin-left:0;-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.btn-group>.btn:hover,.btn-group>.btn:focus,.btn-group>.btn:active,.btn-group>.btn.active{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.dropdown-toggle{*padding-top:4px;padding-right:8px;*padding-bottom:4px;padding-left:8px;-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn-group>.btn-mini.dropdown-toggle{padding-right:5px;padding-left:5px}.btn-group>.btn-small.dropdown-toggle{*padding-top:4px;*padding-bottom:4px}.btn-group>.btn-large.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#05c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:7px;margin-left:0}.btn:hover .caret,.open.btn-group .caret{opacity:1;filter:alpha(opacity=100)}.btn-mini .caret{margin-top:5px}.btn-small .caret{margin-top:6px}.btn-large .caret{margin-top:6px;border-top-width:5px;border-right-width:5px;border-left-width:5px}.dropup .btn-large .caret{border-top:0;border-bottom:5px solid #000}.btn-primary .caret,.btn-warning .caret,.btn-danger .caret,.btn-info .caret,.btn-success .caret,.btn-inverse .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:.75;filter:alpha(opacity=75)}.btn-group-vertical{display:inline-block}.btn-group-vertical .btn{display:block;float:none;width:100%;margin-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group-vertical .btn+.btn{margin-top:-1px}.btn-group-vertical .btn:first-child{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.btn-group-vertical .btn:last-child{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.btn-group-vertical .btn-large:first-child{-webkit-border-radius:6px 6px 0 0;-moz-border-radius:6px 6px 0 0;border-radius:6px 6px 0 0}.btn-group-vertical .btn-large:last-child{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.alert{padding:8px 35px 8px 14px;margin-bottom:18px;color:#c09853;text-shadow:0 1px 0 rgba(255,255,255,0.5);background-color:#fcf8e3;border:1px solid #fbeed5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.alert .close{position:relative;top:-2px;right:-21px;line-height:18px}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-danger,.alert-error{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}.alert-info{color:#3a87ad;background-color:#d9edf7;border-color:#bce8f1}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}.nav{margin-bottom:18px;margin-left:0;list-style:none}.nav>li>a{display:block}.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>.pull-right{float:right}.nav .nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:bold;line-height:18px;color:#999;text-shadow:0 1px 0 rgba(255,255,255,0.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-right:15px;padding-left:15px;margin-bottom:0}.nav-list>li>a,.nav-list .nav-header{margin-right:-15px;margin-left:-15px;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:hover{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.2);background-color:#08c}.nav-list [class^="icon-"]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:8px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-tabs,.nav-pills{*zoom:1}.nav-tabs:before,.nav-pills:before,.nav-tabs:after,.nav-pills:after{display:table;content:""}.nav-tabs:after,.nav-pills:after{clear:both}.nav-tabs>li,.nav-pills>li{float:left}.nav-tabs>li>a,.nav-pills>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:18px;border:1px solid transparent;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:hover{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs.nav-stacked>li:last-child>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.nav-tabs.nav-stacked>li>a:hover{z-index:2;border-color:#ddd}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.nav .dropdown-toggle .caret{margin-top:6px;border-top-color:#08c;border-bottom-color:#08c}.nav .dropdown-toggle:hover .caret{border-top-color:#005580;border-bottom-color:#005580}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav>.dropdown.active>a:hover{color:#fff;cursor:pointer}.nav-tabs .open .dropdown-toggle,.nav-pills .open .dropdown-toggle,.nav>li.dropdown.open.active>a:hover{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open .caret,.nav li.dropdown.open.active .caret,.nav li.dropdown.open a:hover .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:hover{border-color:#999}.tabbable{*zoom:1}.tabbable:before,.tabbable:after{display:table;content:""}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-right>.nav-tabs,.tabs-left>.nav-tabs{border-bottom:0}.tab-content>.tab-pane,.pill-content>.pill-pane{display:none}.tab-content>.active,.pill-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:hover{border-top-color:#ddd;border-bottom-color:transparent}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:hover{border-color:transparent #ddd #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:hover{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:hover{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:hover{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:hover{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:hover{text-decoration:none;cursor:default;background-color:transparent}.navbar{*position:relative;*z-index:2;margin-bottom:18px;overflow:visible}.navbar-inner{min-height:40px;padding-right:20px;padding-left:20px;background-color:#2c2c2c;background-image:-moz-linear-gradient(top,#333,#222);background-image:-ms-linear-gradient(top,#333,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#333),to(#222));background-image:-webkit-linear-gradient(top,#333,#222);background-image:-o-linear-gradient(top,#333,#222);background-image:linear-gradient(top,#333,#222);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff333333',endColorstr='#ff222222',GradientType=0);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1);box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1)}.navbar .container{width:auto}.nav-collapse.collapse{height:auto}.navbar{color:#999}.navbar .brand:hover{text-decoration:none}.navbar .brand{display:block;float:left;padding:8px 20px 12px;margin-left:-20px;font-size:20px;font-weight:200;line-height:1;color:#999}.navbar .navbar-text{margin-bottom:0;line-height:40px}.navbar .navbar-link{color:#999}.navbar .navbar-link:hover{color:#fff}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn{margin:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:before,.navbar-form:after{display:table;content:""}.navbar-form:after{clear:both}.navbar-form input,.navbar-form select,.navbar-form .radio,.navbar-form .checkbox{margin-top:5px}.navbar-form input,.navbar-form select{display:inline-block;margin-bottom:0}.navbar-form input[type="image"],.navbar-form input[type="checkbox"],.navbar-form input[type="radio"]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:6px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:6px;margin-bottom:0}.navbar-search .search-query{padding:4px 9px;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;font-weight:normal;line-height:1;color:#fff;background-color:#626262;border:1px solid #151515;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-webkit-transition:none;-moz-transition:none;-ms-transition:none;-o-transition:none;transition:none}.navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-search .search-query:focus,.navbar-search .search-query.focused{padding:5px 10px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;outline:0;-webkit-box-shadow:0 0 3px rgba(0,0,0,0.15);-moz-box-shadow:0 0 3px rgba(0,0,0,0.15);box-shadow:0 0 3px rgba(0,0,0,0.15)}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding-right:0;padding-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-bottom{bottom:0}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:9px 12px 11px;line-height:19px;color:#999;text-decoration:none;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .btn{display:inline-block;padding:4px 10px 4px;margin:5px 5px 6px;line-height:18px}.navbar .btn-group{padding:5px 5px 6px;margin:0}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{color:#fff;text-decoration:none;background-color:transparent}.navbar .nav .active>a,.navbar .nav .active>a:hover,.navbar .nav .active>a:focus{color:#fff;text-decoration:none;background-color:#222}.navbar .divider-vertical{width:1px;height:40px;margin:0 9px;overflow:hidden;background-color:#222;border-right:1px solid #333}.navbar .nav.pull-right{margin-right:0;margin-left:10px}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-right:5px;margin-left:5px;background-color:#1f1f1f;*background-color:#151515;background-image:-ms-linear-gradient(top,#262626,#151515);background-image:-webkit-gradient(linear,0 0,0 100%,from(#262626),to(#151515));background-image:-webkit-linear-gradient(top,#262626,#151515);background-image:-o-linear-gradient(top,#262626,#151515);background-image:linear-gradient(top,#262626,#151515);background-image:-moz-linear-gradient(top,#262626,#151515);background-repeat:repeat-x;border-color:#151515 #151515 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff262626',endColorstr='#ff151515',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075)}.navbar .btn-navbar:hover,.navbar .btn-navbar:active,.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar[disabled]{background-color:#151515;*background-color:#080808}.navbar .btn-navbar:active,.navbar .btn-navbar.active{background-color:#000 \9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,0.25);-moz-box-shadow:0 1px 0 rgba(0,0,0,0.25);box-shadow:0 1px 0 rgba(0,0,0,0.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .dropdown-menu:before{position:absolute;top:-7px;left:9px;display:inline-block;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-left:7px solid transparent;border-bottom-color:rgba(0,0,0,0.2);content:''}.navbar .dropdown-menu:after{position:absolute;top:-6px;left:10px;display:inline-block;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent;content:''}.navbar-fixed-bottom .dropdown-menu:before{top:auto;bottom:-7px;border-top:7px solid #ccc;border-bottom:0;border-top-color:rgba(0,0,0,0.2)}.navbar-fixed-bottom .dropdown-menu:after{top:auto;bottom:-6px;border-top:6px solid #fff;border-bottom:0}.navbar .nav li.dropdown .dropdown-toggle .caret,.navbar .nav li.dropdown.open .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar .nav li.dropdown.active .caret{opacity:1;filter:alpha(opacity=100)}.navbar .nav li.dropdown.open>.dropdown-toggle,.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle{background-color:transparent}.navbar .nav li.dropdown.active>.dropdown-toggle:focus,.navbar .nav li.dropdown.active>.dropdown-toggle:hover{color:#fff}.navbar .pull-right .dropdown-menu,.navbar .dropdown-menu.pull-right{right:0;left:auto}.navbar .pull-right .dropdown-menu:before,.navbar .dropdown-menu.pull-right:before{right:12px;left:auto}.navbar .pull-right .dropdown-menu:after,.navbar .dropdown-menu.pull-right:after{right:13px;left:auto}.navbar-subnav{height:36px}.navbar-subnav .navbar-inner{min-height:36px;padding:0;background-color:#f5f5f5;background-image:-moz-linear-gradient(top,#f9f9f9,#eee);background-image:-ms-linear-gradient(top,#f9f9f9,#eee);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f9f9f9),to(#eee));background-image:-webkit-linear-gradient(top,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#f9f9f9,#eee);background-image:linear-gradient(top,#f9f9f9,#eee);background-repeat:repeat-x;border:1px solid #e5e5e5;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#ffeeeeee',GradientType=0);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.navbar-subnav .nav>li>a{color:#08c;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.navbar-subnav .nav>li>a:hover{color:#005580}.navbar-subnav .nav li.dropdown .dropdown-toggle .caret,.navbar-subnav .nav li.dropdown.open .caret{border-top-color:#08c;border-bottom-color:#08c}.navbar-subnav .nav .open>a{color:#005580}.breadcrumb{padding:7px 14px;margin:0 0 18px;list-style:none;background-color:#fbfbfb;background-image:-moz-linear-gradient(top,#fff,#f5f5f5);background-image:-ms-linear-gradient(top,#fff,#f5f5f5);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#f5f5f5));background-image:-webkit-linear-gradient(top,#fff,#f5f5f5);background-image:-o-linear-gradient(top,#fff,#f5f5f5);background-image:linear-gradient(top,#fff,#f5f5f5);background-repeat:repeat-x;border:1px solid #ddd;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffffffff',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.breadcrumb li{display:inline-block;*display:inline;text-shadow:0 1px 0 #fff;*zoom:1}.breadcrumb .divider{padding:0 5px;color:#999}.breadcrumb .active a{color:#333}.pagination{height:36px;margin:18px 0}.pagination ul{display:inline-block;*display:inline;margin-bottom:0;margin-left:0;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;*zoom:1;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.pagination li{display:inline}.pagination a,.pagination span{float:left;padding:0 14px;line-height:34px;text-decoration:none;border:1px solid #ddd;border-left-width:0}.pagination a:hover,.pagination .active a,.pagination .active span{background-color:#f5f5f5}.pagination .active a,.pagination .active span{color:#999;cursor:default}.pagination .disabled span,.pagination .disabled a,.pagination .disabled a:hover{color:#999;cursor:default;background-color:transparent}.pagination li:first-child a,.pagination li:first-child span{border-left-width:1px;-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.pagination li:last-child a,.pagination li:last-child span{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pager{margin-bottom:18px;margin-left:0;text-align:center;list-style:none;*zoom:1}.pager:before,.pager:after{display:table;content:""}.pager:after{clear:both}.pager li{display:inline}.pager a{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.pager a:hover{text-decoration:none;background-color:#f5f5f5}.pager .next a{float:right}.pager .previous a{float:left}.pager .disabled a,.pager .disabled a:hover{color:#999;cursor:default;background-color:#fff}.modal-open .dropdown-menu{z-index:2050}.modal-open .dropdown.open{*z-index:2050}.modal-open .popover{z-index:2060}.modal-open .tooltip{z-index:2070}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:50%;left:50%;z-index:1050;width:560px;margin:-250px 0 0 -280px;overflow:auto;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,0.3);*border:1px solid #999;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.modal.fade{top:-25%;-webkit-transition:opacity .3s linear,top .3s ease-out;-moz-transition:opacity .3s linear,top .3s ease-out;-ms-transition:opacity .3s linear,top .3s ease-out;-o-transition:opacity .3s linear,top .3s ease-out;transition:opacity .3s linear,top .3s ease-out}.modal.fade.in{top:50%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-body{max-height:400px;padding:15px;overflow-y:auto}.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;margin-bottom:0;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px;*zoom:1;-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.modal-footer:before,.modal-footer:after{display:table;content:""}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.tooltip{position:absolute;z-index:1020;display:block;padding:5px;font-size:11px;opacity:0;filter:alpha(opacity=0);visibility:visible}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{margin-top:-2px}.tooltip.right{margin-left:2px}.tooltip.bottom{margin-top:2px}.tooltip.left{margin-left:-2px}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-top:5px solid #000;border-right:5px solid transparent;border-left:5px solid transparent}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-top:5px solid transparent;border-bottom:5px solid transparent;border-left:5px solid #000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-right:5px solid transparent;border-bottom:5px solid #000;border-left:5px solid transparent}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-top:5px solid transparent;border-right:5px solid #000;border-bottom:5px solid transparent}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;padding:5px}.popover.top{margin-top:-5px}.popover.right{margin-left:5px}.popover.bottom{margin-top:5px}.popover.left{margin-left:-5px}.popover.top .arrow{bottom:0;left:50%;margin-left:-5px;border-top:5px solid #000;border-right:5px solid transparent;border-left:5px solid transparent}.popover.right .arrow{top:50%;left:0;margin-top:-5px;border-top:5px solid transparent;border-right:5px solid #000;border-bottom:5px solid transparent}.popover.bottom .arrow{top:0;left:50%;margin-left:-5px;border-right:5px solid transparent;border-bottom:5px solid #000;border-left:5px solid transparent}.popover.left .arrow{top:50%;right:0;margin-top:-5px;border-top:5px solid transparent;border-bottom:5px solid transparent;border-left:5px solid #000}.popover .arrow{position:absolute;width:0;height:0}.popover-inner{width:280px;padding:3px;overflow:hidden;background:#000;background:rgba(0,0,0,0.8);-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3)}.popover-title{padding:9px 15px;line-height:1;background-color:#f5f5f5;border-bottom:1px solid #eee;-webkit-border-radius:3px 3px 0 0;-moz-border-radius:3px 3px 0 0;border-radius:3px 3px 0 0}.popover-content{padding:14px;background-color:#fff;-webkit-border-radius:0 0 3px 3px;-moz-border-radius:0 0 3px 3px;border-radius:0 0 3px 3px;-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.popover-content p,.popover-content ul,.popover-content ol{margin-bottom:0}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:before,.thumbnails:after{display:table;content:""}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:18px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:1;border:1px solid #ddd;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:0 1px 1px rgba(0,0,0,0.075);box-shadow:0 1px 1px rgba(0,0,0,0.075)}a.thumbnail:hover{border-color:#08c;-webkit-box-shadow:0 1px 4px rgba(0,105,214,0.25);-moz-box-shadow:0 1px 4px rgba(0,105,214,0.25);box-shadow:0 1px 4px rgba(0,105,214,0.25)}.thumbnail>img{display:block;max-width:100%;margin-right:auto;margin-left:auto}.thumbnail .caption{padding:9px}.label,.badge{font-size:10.998px;font-weight:bold;line-height:14px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);white-space:nowrap;vertical-align:baseline;background-color:#999}.label{padding:1px 4px 2px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.badge{padding:1px 9px 2px;-webkit-border-radius:9px;-moz-border-radius:9px;border-radius:9px}a.label:hover,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.label-important,.badge-important{background-color:#b94a48}.label-important[href],.badge-important[href]{background-color:#953b39}.label-warning,.badge-warning{background-color:#f89406}.label-warning[href],.badge-warning[href]{background-color:#c67605}.label-success,.badge-success{background-color:#468847}.label-success[href],.badge-success[href]{background-color:#356635}.label-info,.badge-info{background-color:#3a87ad}.label-info[href],.badge-info[href]{background-color:#2d6987}.label-inverse,.badge-inverse{background-color:#333}.label-inverse[href],.badge-inverse[href]{background-color:#1a1a1a}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-moz-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-ms-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:0 0}to{background-position:40px 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:18px;margin-bottom:18px;overflow:hidden;background-color:#f7f7f7;background-image:-moz-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-ms-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f5f5f5),to(#f9f9f9));background-image:-webkit-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-o-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:linear-gradient(top,#f5f5f5,#f9f9f9);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress .bar{width:0;height:18px;font-size:12px;color:#fff;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e90d2;background-image:-moz-linear-gradient(top,#149bdf,#0480be);background-image:-webkit-gradient(linear,0 0,0 100%,from(#149bdf),to(#0480be));background-image:-webkit-linear-gradient(top,#149bdf,#0480be);background-image:-o-linear-gradient(top,#149bdf,#0480be);background-image:linear-gradient(top,#149bdf,#0480be);background-image:-ms-linear-gradient(top,#149bdf,#0480be);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;-webkit-transition:width .6s ease;-moz-transition:width .6s ease;-ms-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-striped .bar{background-color:#149bdf;background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;-moz-background-size:40px 40px;-o-background-size:40px 40px;background-size:40px 40px}.progress.active .bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-moz-animation:progress-bar-stripes 2s linear infinite;-ms-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar{background-color:#dd514c;background-image:-moz-linear-gradient(top,#ee5f5b,#c43c35);background-image:-ms-linear-gradient(top,#ee5f5b,#c43c35);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#c43c35));background-image:-webkit-linear-gradient(top,#ee5f5b,#c43c35);background-image:-o-linear-gradient(top,#ee5f5b,#c43c35);background-image:linear-gradient(top,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffc43c35',GradientType=0)}.progress-danger.progress-striped .bar{background-color:#ee5f5b;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-success .bar{background-color:#5eb95e;background-image:-moz-linear-gradient(top,#62c462,#57a957);background-image:-ms-linear-gradient(top,#62c462,#57a957);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#57a957));background-image:-webkit-linear-gradient(top,#62c462,#57a957);background-image:-o-linear-gradient(top,#62c462,#57a957);background-image:linear-gradient(top,#62c462,#57a957);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff57a957',GradientType=0)}.progress-success.progress-striped .bar{background-color:#62c462;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-info .bar{background-color:#4bb1cf;background-image:-moz-linear-gradient(top,#5bc0de,#339bb9);background-image:-ms-linear-gradient(top,#5bc0de,#339bb9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#339bb9));background-image:-webkit-linear-gradient(top,#5bc0de,#339bb9);background-image:-o-linear-gradient(top,#5bc0de,#339bb9);background-image:linear-gradient(top,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff339bb9',GradientType=0)}.progress-info.progress-striped .bar{background-color:#5bc0de;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-warning .bar{background-color:#faa732;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-ms-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(top,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0)}.progress-warning.progress-striped .bar{background-color:#fbb450;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.accordion{margin-bottom:18px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:18px;line-height:1}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel .item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-moz-transition:.6s ease-in-out left;-ms-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel .item>img{display:block;line-height:1}.carousel .active,.carousel .next,.carousel .prev{display:block}.carousel .active{left:0}.carousel .next,.carousel .prev{position:absolute;top:0;width:100%}.carousel .next{left:100%}.carousel .prev{left:-100%}.carousel .next.left,.carousel .prev.right{left:0}.carousel .active.left{left:-100%}.carousel .active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;-webkit-border-radius:23px;-moz-border-radius:23px;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{right:15px;left:auto}.carousel-control:hover{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-caption{position:absolute;right:0;bottom:0;left:0;padding:10px 15px 5px;background:#333;background:rgba(0,0,0,0.75)}.carousel-caption h4,.carousel-caption p{color:#fff}.hero-unit{padding:60px;margin-bottom:30px;background-color:#eee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;letter-spacing:-1px;color:inherit}.hero-unit p{font-size:18px;font-weight:200;line-height:27px;color:inherit}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}
diff --git a/website/static/debut_dark.png b/website/static/debut_dark.png
deleted file mode 100644
index 17a4d6b42..000000000
Binary files a/website/static/debut_dark.png and /dev/null differ
diff --git a/website/static/logo.png b/website/static/logo.png
deleted file mode 100644
index e2bd44d02..000000000
Binary files a/website/static/logo.png and /dev/null differ
diff --git a/website/static/logo.psd b/website/static/logo.psd
deleted file mode 100644
index 22284816a..000000000
Binary files a/website/static/logo.psd and /dev/null differ
diff --git a/website/static/prettify.css b/website/static/prettify.css
deleted file mode 100644
index 093f2f958..000000000
--- a/website/static/prettify.css
+++ /dev/null
@@ -1,47 +0,0 @@
-/*.com { color: #93a1a1; }
-.lit { color: #195f91; }
-.pun, .opn, .clo { color: #93a1a1; }
-.fun { color: #dc322f; }
-.str, .atv { color: #edd400; }
-.kwd, .linenums, .tag { color: #1e347b; }
-.typ, .atn, .dec, .var { color: teal; }
-.pln { color: #48484c; }*/
-
-pre .str, code .str { color: #c6c6c6; } /* string  - white */
-pre .kwd, code .kwd { color: #E28964; } /* keyword - dark pink */
-pre .com, code .com { color: #AEAEAE; font-style: italic; } /* comment - gray */
-pre .typ, code .typ { color: #89bdff; } /* type - light blue */
-pre .lit, code .lit { color: #3387CC; } /* literal - blue */
-pre .pun, code .pun { color: #c6c6c6; } /* punctuation - white */
-pre .pln, code .pln { color: #c6c6c6; } /* plaintext - white */
-pre .tag, code .tag { color: #89bdff; } /* html/xml tag    - light blue */
-pre .atn, code .atn { color: #bdb76b; } /* html/xml attribute name  - khaki */
-pre .atv, code .atv { color: #65B042; } /* html/xml attribute value - green */
-pre .dec, code .dec { color: #3387CC; } /* decimal - blue */
-
-
-.prettyprint {
-  padding: 8px;
-  background-color: #212121;
-  background-color: rgba(31, 31, 31, 0.25);
-  border: 0;
-  text-shadow: none;
-  font-size: 12px;
-}
-.prettyprint.linenums {
-  -webkit-box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
-     -moz-box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
-          box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
-}
-
-/* Specify class=linenums on a pre to get line numbering */
-ol.linenums {
-  margin: 0 0 0 33px; /* IE indents via margin-left */
-}
-ol.linenums li {
-  padding-left: 12px;
-  color: #bebec5;
-  line-height: 18px;
-  text-shadow: 0 1px 0 #fff;
-}
-
diff --git a/website/static/prettify.js b/website/static/prettify.js
deleted file mode 100644
index eef5ad7e6..000000000
--- a/website/static/prettify.js
+++ /dev/null
@@ -1,28 +0,0 @@
-var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
-(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
-[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
-f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
-(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
-{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
-t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
-"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
-l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
-q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
-q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
-"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
-a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
-for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
-m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
-a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
-j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
-"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
-H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
-J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
-I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
-["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
-/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
-["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
-hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
-!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
-250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
-PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
diff --git a/website/static/ribbon.png b/website/static/ribbon.png
deleted file mode 100644
index 8fe3a7e1f..000000000
Binary files a/website/static/ribbon.png and /dev/null differ
diff --git a/website/static/square.png b/website/static/square.png
deleted file mode 100644
index bc1caf95e..000000000
Binary files a/website/static/square.png and /dev/null differ
