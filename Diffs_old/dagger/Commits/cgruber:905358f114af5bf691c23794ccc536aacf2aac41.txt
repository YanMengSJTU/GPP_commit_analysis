diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
new file mode 100644
index 000000000..039d0fe55
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class Request {
+  private final String name;
+
+  @Inject
+  Request() {
+    this.name = "Request";
+  }
+
+  String name() {
+    return this.name;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
new file mode 100644
index 000000000..7a46e5b0e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+final class Response {
+  private final String data;
+
+  Response(String data) {
+    this.data = data;
+  }
+
+  String data() {
+    return this.data;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
new file mode 100644
index 000000000..bda53eb56
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ResponseProducerModule {
+  @Produces ListenableFuture<String> greeting() {
+    return Futures.immediateFuture("Hello");
+  }
+
+  @Produces Response response(String greeting, Request request) {
+    return new Response(greeting + ", " + request.name() + "!");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
new file mode 100644
index 000000000..583cd50f0
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = ResponseProducerModule.class)
+interface SimpleComponent {
+  ListenableFuture<Response> response();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
new file mode 100644
index 000000000..de0ea89bd
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SimpleTest {
+  @Test public void testSimpleComponent() throws Exception {
+    SimpleComponent simpleComponent = Dagger_SimpleComponent
+        .builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(simpleComponent).isNotNull();
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 49a5e470f..362a21dfc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -45,9 +45,9 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 8ca6fe9f3..4fe1a30bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,7 @@
 import java.lang.annotation.Annotation;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.Executor;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -97,6 +98,11 @@
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
+  /**
+   * The element representing {@link Executor}, if it should be a dependency of this component.
+   */
+  abstract Optional<TypeElement> executorDependency();
+
   /**
    * An optional annotation constraining the scope of this component.
    */
@@ -160,6 +166,11 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         }
       }
 
+      Optional<TypeElement> executorDependency =
+          kind.equals(Kind.PRODUCTION_COMPONENT)
+              ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
+              : Optional.absent();
+
       ImmutableSet<ExecutableElement> unimplementedMethods =
           getUnimplementedMethods(elements, componentDefinitionType);
 
@@ -186,6 +197,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentDefinitionType,
           componentDependencyTypes,
           dependencyMethodIndex.build(),
+          executorDependency,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 7792db003..d67f1cc0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,6 +24,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -57,6 +58,9 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.List;
@@ -85,10 +89,16 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.ProductionBinding.Kind.COMPONENT_PRODUCTION;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
@@ -178,8 +188,10 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
             Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
+                Sets.union(
+                    input.transitiveModules().keySet(),
+                    input.componentDescriptor().dependencies()),
+                input.componentDescriptor().executorDependency().asSet()),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -547,6 +559,7 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
           case PRODUCED:
           case PRODUCER:
           case PROVIDER:
+          case FUTURE:
             interfaceMethod.body().addSnippet("return %s;",
                 frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
                     interfaceRequest.kind()));
@@ -579,65 +592,94 @@ private void initializeFrameworkTypes(BindingGraph input,
         Snippet memberSelectSnippet = memberSelectSnippets.get(bindingKey);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            @SuppressWarnings("unchecked")  // checked during validation
-            ImmutableSet<ProvisionBinding> bindings =
-                (ImmutableSet<ProvisionBinding>) input.resolvedBindings()
-                    .get(bindingKey)
-                    .contributionBindings();
+            ImmutableSet<? extends ContributionBinding> bindings =
+                input.resolvedBindings().get(bindingKey).contributionBindings();
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
-                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                for (ProvisionBinding provisionBinding : bindings) {
-                  if (multibindingContributionSnippets.containsKey(provisionBinding)) {
-                    Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        snippet,
-                        initializeFactoryForBinding(provisionBinding,
-                            input.componentDescriptor().dependencyMethodIndex(),
-                            componentContributionFields,
-                            memberSelectSnippets));
-                    parameterSnippets.add(snippet);
-                  } else if (parentMultibindingContributionSnippets.containsKey(provisionBinding)) {
-                    parameterSnippets.add(
-                        parentMultibindingContributionSnippets.get(provisionBinding));
-                  } else {
-                    throw new IllegalStateException();
+                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
+                    .isEmpty()) {
+                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
+                  ImmutableSet<ProvisionBinding> provisionBindings =
+                      (ImmutableSet<ProvisionBinding>) bindings;
+                  ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+                  for (ProvisionBinding provisionBinding : provisionBindings) {
+                    if (multibindingContributionSnippets.containsKey(provisionBinding)) {
+                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          snippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields,
+                              memberSelectSnippets));
+                      parameterSnippets.add(snippet);
+                    } else if (parentMultibindingContributionSnippets
+                        .containsKey(provisionBinding)) {
+                      parameterSnippets.add(
+                          parentMultibindingContributionSnippets.get(provisionBinding));
+                    } else {
+                      throw new IllegalStateException();
+                    }
                   }
+                  Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                      ClassName.fromClass(SetFactory.class),
+                      Snippet.makeParametersSnippet(parameterSnippets.build()));
+                  initializeMethod.body().addSnippet("this.%s = %s;",
+                      memberSelectSnippet, initializeSetSnippet);
+                } else {
+                  // TODO(user): Implement producer set bindings.
+                  throw new IllegalStateException("producer set bindings not implemented yet");
                 }
-                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                    ClassName.fromClass(SetFactory.class),
-                    Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
-                for (ProvisionBinding provisionBinding : bindings) {
-                  if (!isNonProviderMap(provisionBinding)) {
-                    initializeMethod.body().addSnippet("this.%s = %s;",
+                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
+                    .isEmpty()) {
+                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
+                  ImmutableSet<ProvisionBinding> provisionBindings =
+                      (ImmutableSet<ProvisionBinding>) bindings;
+                  for (ProvisionBinding provisionBinding : provisionBindings) {
+                    if (!isNonProviderMap(provisionBinding)) {
+                      initializeMethod.body().addSnippet("this.%s = %s;",
                         multibindingContributionSnippets.get(provisionBinding),
-                        initializeFactoryForBinding(provisionBinding,
-                            input.componentDescriptor().dependencyMethodIndex(),
-                            componentContributionFields,
-                            memberSelectSnippets));
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields,
+                              memberSelectSnippets));
+                    }
                   }
-                }
-                if (!bindings.isEmpty()) {
-                  Snippet initializeMapSnippet = initializeMapBinding(
-                      memberSelectSnippets, multibindingContributionSnippets, bindings);
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet, initializeMapSnippet);
+                  if (!provisionBindings.isEmpty()) {
+                    Snippet initializeMapSnippet = initializeMapBinding(
+                        memberSelectSnippets, multibindingContributionSnippets, provisionBindings);
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet, initializeMapSnippet);
+                  }
+                } else {
+                  // TODO(user): Implement producer map bindings.
+                  throw new IllegalStateException("producer map bindings not implemented yet");
                 }
                 break;
               case UNIQUE:
-                ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-                if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                    || binding.scope().isPresent()) {
+                ContributionBinding binding = Iterables.getOnlyElement(bindings);
+                if (binding instanceof ProvisionBinding) {
+                  ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                  if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                      || provisionBinding.scope().isPresent()) {
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet,
+                        initializeFactoryForProvisionBinding(provisionBinding,
+                            input.componentDescriptor().dependencyMethodIndex(),
+                            componentContributionFields, memberSelectSnippets));
+                  }
+                } else if (binding instanceof ProductionBinding) {
+                  ProductionBinding productionBinding = (ProductionBinding) binding;
                   initializeMethod.body().addSnippet("this.%s = %s;",
                       memberSelectSnippet,
-                      initializeFactoryForBinding(binding,
+                      initializeFactoryForProductionBinding(productionBinding,
+                          input,
                           input.componentDescriptor().dependencyMethodIndex(),
                           componentContributionFields, memberSelectSnippets));
+                } else {
+                  throw new IllegalStateException();
                 }
                 break;
               default:
@@ -695,6 +737,22 @@ private static boolean isSytheticProvisionBinding(ContributionBinding contributi
             .bindingKind().equals(SYNTHETIC_PROVISON));
   }
 
+  private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+          if (binding instanceof ProductionBinding) {
+            return Producer.class;
+          }
+        }
+        return Provider.class;
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
   private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
     switch (bindingKey.kind()) {
@@ -706,13 +764,13 @@ private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolv
           case SET:
           case MAP:
             return FrameworkField.createWithTypeFromKey(
-                Provider.class,
+                frameworkClassForResolvedBindings(resolvedBindings),
                 bindingKey,
                 KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
           case UNIQUE:
             ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
             return FrameworkField.createWithTypeFromKey(
-                Provider.class,
+                frameworkClassForResolvedBindings(resolvedBindings),
                 bindingKey,
                 binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
                   @Override
@@ -746,7 +804,7 @@ public String visitType(TypeElement e, Void p) {
     }
   }
 
-  private Snippet initializeFactoryForBinding(ProvisionBinding binding,
+  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
@@ -824,6 +882,41 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
     }
   }
 
+  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
+      BindingGraph bindingGraph,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
+      Map<TypeElement, FieldWriter> contributionFields,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+    switch (binding.bindingKind()) {
+      case COMPONENT_PRODUCTION:
+        return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  @Override public %2$s get() {",
+            "    return %3$s.%4$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Producer.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString());
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+        parameters.add(Snippet.format(contributionFields.get(
+            bindingGraph.componentDescriptor().executorDependency().get()).name()));
+        parameters.addAll(getProducerDependencyParameters(
+            bindingGraph, binding.dependencies(), memberSelectSnippets));
+
+        return Snippet.format("new %s(%s)",
+            factoryNameForProductionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
+
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
@@ -851,8 +944,45 @@ private static Snippet initializeMembersInjectorForBinding(
       Iterable<DependencyRequest> dependencies,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (BindingKey keys : SourceFiles.indexDependenciesByUnresolvedKey(dependencies).values()) {
-      parameters.add(memberSelectSnippets.get(keys));
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return BindingKey.forDependencyRequest(request);
+            }
+          })
+          .toSet());
+      parameters.add(memberSelectSnippets.get(key));
+    }
+    return parameters.build();
+  }
+
+  private static List<Snippet> getProducerDependencyParameters(
+      BindingGraph bindingGraph,
+      Iterable<DependencyRequest> dependencies,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return BindingKey.forDependencyRequest(request);
+            }
+          }));
+      ResolvedBindings resolvedBindings = bindingGraph.resolvedBindings().get(key);
+      Class<?> frameworkClass =
+          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
+      if (frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
+          && frameworkClass.equals(Producer.class)) {
+        parameters.add(Snippet.format(
+            "%s.producerFromProvider(%s)",
+            ClassName.fromClass(Producers.class),
+            memberSelectSnippets.get(key)));
+      } else {
+        parameters.add(memberSelectSnippets.get(key));
+      }
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 4ec2b3461..167b59fd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -171,7 +171,8 @@ public SourceVersion getSupportedSourceVersion() {
             productionComponentValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
-            bindingGraphFactory));
+            bindingGraphFactory,
+            componentGenerator));
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 3821cfd75..1657754c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -169,7 +169,7 @@ private static void addIncludesFromSuperclasses(Types types, TypeElement element
       ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
     // Also add the superclass to the queue, in case any @Module definitions were on that.
     TypeMirror superclass = element.getSuperclass();
-    while(!types.isSameType(objectType, superclass)
+    while (!types.isSameType(objectType, superclass)
         && superclass.getKind().equals(TypeKind.DECLARED)) {
       element = MoreElements.asType(types.asElement(superclass));
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index c0deb49b2..1dc48fc8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -15,10 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
 import dagger.MembersInjector;
 import dagger.producers.Producer;
 import javax.inject.Provider;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+
 /**
  * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
  * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
@@ -29,6 +34,27 @@
 abstract class DependencyRequestMapper {
   abstract Class<?> getFrameworkClass(DependencyRequest request);
 
+  /**
+   * Returns the framework class to use for a collection of requests of the same {@link BindingKey}.
+   * This allows factories to only take a single argument for multiple requests of the same key.
+   */
+  Class<?> getFrameworkClass(Iterable<DependencyRequest> requests) {
+    ImmutableSet<Class<?>> classes = FluentIterable.from(requests)
+        .transform(new Function<DependencyRequest, Class<?>>() {
+          @Override public Class<?> apply(DependencyRequest request) {
+            return getFrameworkClass(request);
+          }
+        })
+        .toSet();
+    if (classes.size() == 1) {
+      return getOnlyElement(classes);
+    } else if (classes.equals(ImmutableSet.of(Producer.class, Provider.class))) {
+      return Provider.class;
+    } else {
+      throw new IllegalStateException("Bad set of framework classes: " + classes);
+    }
+  }
+
   private static final class MapperForProvider extends DependencyRequestMapper {
     @Override public Class<?> getFrameworkClass(DependencyRequest request) {
       switch (request.kind()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 8a5815a9c..205a724b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -122,7 +122,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         // since we'll be implementing an erased version of it.
         if (!typeParameters.isEmpty()) {
           factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
-          providedTypeName = ((ParameterizedTypeName)providedTypeName).type();
+          providedTypeName = ((ParameterizedTypeName) providedTypeName).type();
         }
         break;
       case CLASS_CONSTRUCTOR:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index 94f1e330b..187cecd73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -38,18 +38,21 @@
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
 
   ProductionComponentProcessingStep(
       Messager messager,
       ProductionComponentValidator componentValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory) {
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
   }
 
   @Override
@@ -73,6 +76,13 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
         ValidationReport<BindingGraph> graphReport =
             bindingGraphValidator.validate(bindingGraph);
         graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index dcfc93101..62e034181 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -21,7 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -40,7 +39,6 @@
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Utilities for generating files.
@@ -69,7 +67,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
 
   /**
    * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
-   * to resolved keys.  This is used when generating component's initialize()
+   * to requests.  This is used when generating component's initialize()
    * methods (and in members injectors) in order to instantiate dependent
    * providers.  Consider a generic type of {@code Foo<T>} with a constructor
    * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
@@ -78,10 +76,13 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * pass two providers.  Naively (if we just referenced by resolved BindingKey),
    * we would have passed a single {@code aProvider}.
    */
-  static ImmutableMap<BindingKey, BindingKey> indexDependenciesByUnresolvedKey(
+  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
+  // binding keys and framework classes that it needs.
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
       Iterable<? extends DependencyRequest> dependencies) {
-    // We expect some duplicates while building, so not using ImmutableMap
-    Map<BindingKey, BindingKey> map = Maps.newLinkedHashMap();
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
+            DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       BindingKey resolved = BindingKey.forDependencyRequest(dependency);
       // To get the proper unresolved type, we have to extract the proper type from the
@@ -90,17 +91,9 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
       BindingKey unresolved =
           BindingKey.create(resolved.kind(), resolved.key().withType(unresolvedType));
-      BindingKey existingEntry = map.get(unresolved);
-      if (existingEntry == null) {
-        map.put(unresolved, resolved);
-      } else {
-        // If the entry exists in the map, it *must* be with the same resolved
-        // value.  Otherwise we have an unresolved key mapping to two different
-        // resolved keys!
-        checkState(existingEntry.equals(resolved));
-      }
+      dependenciesByKeyBuilder.put(unresolved, dependency);
     }
-    return ImmutableMap.copyOf(map);
+    return dependenciesByKeyBuilder.build();
   }
 
   /**
@@ -155,7 +148,8 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
+        bindingFields.put(bindingKey,
+            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
       } else {
         // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
@@ -180,6 +174,7 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
             frameworkTypeMemberSelect);
       case INSTANCE:
+      case FUTURE:
         return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case PRODUCER:
@@ -220,7 +215,7 @@ static TypeName parameterizedFactoryNameForProvisionBinding(
           if (bindingName instanceof ParameterizedTypeName) {
             parameters = ((ParameterizedTypeName) bindingName).parameters();
           }
-          break; 
+          break;
         case PROVISION:
           // For provision bindings, we parameterize creation on the types of
           // the module, not the types of the binding.
@@ -250,7 +245,7 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
         throw new AssertionError();
     }
   }
-  
+
   /**
    * Returns the members injector's name parameterized with the binding's parameters (if necessary).
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ed29f0036..a57b94749 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -83,4 +83,143 @@
         .failsToCompile()
         .withErrorContaining("is not annotated with @Module or @ProducerModule");
   }
+
+  @Test public void simpleComponent() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static final class C {",
+        "    @Inject C() {}",
+        "  }",
+        "",
+        "  interface A {}",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static final class BModule {",
+        "    @Provides B b(C c) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class AModule {",
+        "    @Produces ListenableFuture<A> a(B b) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestClass_SimpleComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestClass.A;",
+        "import test.TestClass.AModule;",
+        "import test.TestClass.B;",
+        "import test.TestClass.BModule;",
+        "import test.TestClass.SimpleComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestClass_SimpleComponent implements SimpleComponent {",
+        "  private final AModule aModule;",
+        "  private final BModule bModule;",
+        "  private final Executor executor;",
+        "  private Provider<B> bProvider;",
+        "  private Producer<A> aProducer;",
+        "",
+        "  private Dagger_TestClass_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.aModule = builder.aModule;",
+        "    this.bModule = builder.bModule;",
+        "    this.executor = builder.executor;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.bProvider = TestClass$BModule$$BFactory.create(",
+        "        bModule, TestClass$C$$Factory.create());",
+        "    this.aProducer = new TestClass$AModule$$AFactory(",
+        "        aModule, executor, Producers.producerFromProvider(bProvider));",
+        "  }",
+        "",
+        "  @Override",
+        "  public ListenableFuture<A> a() {",
+        "    return aProducer.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AModule aModule;",
+        "    private BModule bModule;",
+        "    private Executor executor;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      if (aModule == null) {",
+        "        this.aModule = new AModule();",
+        "      }",
+        "      if (bModule == null) {",
+        "        this.bModule = new BModule();",
+        "      }",
+        "      if (executor == null) {",
+        "        throw new IllegalStateException(\"executor must be set\");",
+        "      }",
+        "      return new Dagger_TestClass_SimpleComponent(this);",
+        "    }",
+        "",
+        "    public Builder aModule(AModule aModule) {",
+        "      if (aModule == null) {",
+        "        throw new NullPointerException(\"aModule\");",
+        "      }",
+        "      this.aModule = aModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder bModule(BModule bModule) {",
+        "      if (bModule == null) {",
+        "        throw new NullPointerException(\"bModule\");",
+        "      }",
+        "      this.bModule = bModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder executor(Executor executor) {",
+        "      if (executor == null) {",
+        "        throw new NullPointerException(\"executor\");",
+        "      }",
+        "      this.executor = executor;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
