diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
index 6ffe1e07d..bd49a2459 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
@@ -17,6 +17,13 @@
 
 import dagger.Component;
 
+/**
+ * A component that indirectly depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced
+ * types are generated, but {@link NeedsFactory} depends on the generated
+ * {@link NeedsFactory_SomethingFactory}.
+ *
+ */
 @Component
 interface ComponentDependsOnGeneratedCode {
   NeedsFactory needsFactory();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
index f7460c989..6cbf6af8d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -17,6 +17,11 @@
 
 import dagger.Component;
 
+/**
+ * A component whose supertype depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}.
+ *
+ */
 @Component
 interface ComponentSupertypeDependsOnGeneratedCode
     extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
index 0562ad610..ccf5fe1c7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -19,6 +19,11 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 
+/**
+ * Component with a long enough cycle such that the initialization of a provider happens in a
+ * separate {@code initialize} method from the one where it is used as a delegated factory.
+ *
+ */
 // Each nested class's constructor has an intentionally unused parameter.
 @SuppressWarnings("unused")
 final class LongCycle {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
index 0310df6ef..f26e3ad0b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
@@ -21,6 +21,9 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+/**
+ * @see <a href="http://b/19435358">Bug 19435358</a>
+ */
 @RunWith(JUnit4.class)
 public class DependsOnGeneratedCodeTest {
   @Test public void testComponentDependsOnGeneratedCode() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index 99ca1cd44..a86931922 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -100,6 +100,13 @@ public void testParentWithoutProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -132,6 +139,13 @@ public void testParentWithoutProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithProvision
                 .childWithProvision()
@@ -172,6 +186,13 @@ public void testParentWithProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -203,6 +224,13 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
@@ -229,6 +257,13 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 233ab5511..cddc1aea7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -755,6 +755,7 @@ boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
               Resolver.this,
               bindingKey);
           // Don't recur infinitely if there are valid cycles in the dependency graph.
+          // http://b/23032377
           if (!cycleChecker.add(bindingKey)) {
             return false;
           }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9dfe0a6c6..23dc40ff6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2054,6 +2054,7 @@ public void subcomponentOmitsInheritedBindings() {
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
+
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -2090,6 +2091,7 @@ public void componentImplicitlyDependsOnGeneratedType() {
         .and()
         .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
   }
+
   @Test
   public void componentSupertypeDependsOnGeneratedType() {
     JavaFileObject componentFile =
