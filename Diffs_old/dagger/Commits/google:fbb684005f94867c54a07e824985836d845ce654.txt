diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
new file mode 100644
index 000000000..0b330a1f9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This tests that @Module.includes are traversed for supertypes of a module.
+ */
+final class ModuleIncludesCollectedFromModuleSuperclasses {
+  @Component(modules = TopLevelModule.class)
+  interface C {
+    Foo<String> foo();
+    int includedInTopLevelModule();
+    String includedFromModuleInheritance();
+  }
+
+  @Module(includes = IncludedTopLevel.class)
+  static class TopLevelModule extends FooModule<String> {}
+
+  static class Foo<T> {}
+
+  @Module(includes = IncludedFromModuleInheritance.class)
+  abstract static class FooModule<T> extends FooCreator {
+    @Provides Foo<T> fooOfT() {
+      return createFoo();
+    }
+  }
+
+  static class FooCreator {
+    <T> Foo<T> createFoo() {
+      return new Foo<T>();
+    }
+  }
+
+  @Module
+  static class IncludedTopLevel {
+    @Provides int i() {
+      return 123;
+    }
+  }
+
+  @Module
+  static class IncludedFromModuleInheritance {
+    @Provides String inheritedProvision() {
+      return "inherited";
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..8a04944ab
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class SubcomponentFromModuleAndFactoryMethod {
+  @Subcomponent
+  interface Sub {
+    @Subcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @Module(subcomponents = Sub.class)
+  class ModuleWithSubcomponent {}
+
+  @Component(modules = ModuleWithSubcomponent.class)
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
new file mode 100644
index 000000000..9c7ba3111
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Inject;
+
+/** Supporting types for {@link ModuleWithSubcomponentsTest}. */
+@Component(modules = UsesModuleSubcomponents.ModuleWithSubcomponents.class)
+public interface UsesModuleSubcomponents {
+  UsesChild usesChild();
+
+  Set<String> strings();
+
+  @Module(subcomponents = Child.class, includes = AlsoIncludesSubcomponents.class)
+  class ModuleWithSubcomponents {
+    @Provides
+    @IntoSet
+    static String provideStringInParent() {
+      return "from parent";
+    }
+  }
+
+  @Module(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @Subcomponent(modules = ChildModule.class)
+  interface Child {
+    Set<String> strings();
+
+    @Subcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @Module
+  class ChildModule {
+    @Provides
+    @IntoSet
+    static String provideStringInChild() {
+      return "from child";
+    }
+  }
+
+  class UsesChild {
+    Set<String> strings;
+
+    @Inject
+    UsesChild(Child.Builder childBuilder) {
+      this.strings = childBuilder.build().strings();
+    }
+  }
+
+  @Module(includes = ModuleWithSubcomponents.class)
+  class OnlyIncludesModuleWithSubcomponents {}
+
+  @Component(modules = OnlyIncludesModuleWithSubcomponents.class)
+  interface ParentIncludesSubcomponentTransitively extends UsesModuleSubcomponents {}
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
new file mode 100644
index 000000000..3126f13f3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.pruning;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@link SubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is a direct
+ * child of the top level component, but is only requested within its sibling, not directly from its
+ * parent.
+ */
+@Component(modules = ParentDoesntUseSubcomponent.ParentModule.class)
+interface ParentDoesntUseSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @Subcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+  }
+
+  @Subcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+
+    @FromChildA
+    Set<Class<?>> componentHierarchyFromChildA();
+  }
+
+  @Module(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ParentDoesntUseSubcomponent.class;
+    }
+  }
+
+  @Module
+  class ChildAModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @Module
+  class ChildBModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildB.class;
+    }
+
+    @Provides
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) {
+      return childABuilder.build().componentHierarchy();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..31844a5ed
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface OtherSubcomponentWithRepeatedModule extends SubcomponentWithRepeatedModule {
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    OtherSubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
index 2b6950462..e7829a025 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -20,5 +20,5 @@
 
 @Subcomponent
 interface SubcomponentWithoutRepeatedModule {
-  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+  OtherSubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..34dbf8825
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.subcomponent.UsesModuleSubcomponents.ParentIncludesSubcomponentTransitively;
+
+/** Tests for {@link Module#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() {
+    UsesModuleSubcomponents parent = DaggerUsesModuleSubcomponents.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() {
+    ParentIncludesSubcomponentTransitively parent =
+        DaggerUsesModuleSubcomponents_ParentIncludesSubcomponentTransitively.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..fb856a73d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildA;
+import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildB;
+
+/**
+ * Tests for {@link Subcomponent}s which are included with {@link Module#subcomponents()} but not
+ * used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class SubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() {
+    ParentDoesntUseSubcomponent parent = DaggerParentDoesntUseSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
index de8de4b97..e4b21c1ba 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
@@ -68,7 +68,7 @@ public void repeatedModuleBuilderThrowsInSubcomponent() {
   public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
     SubcomponentWithoutRepeatedModule childComponent =
         parentComponent.newChildComponentWithoutRepeatedModule();
-    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+    OtherSubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
         childComponent.newGrandchildBuilder();
     try {
       grandchildComponentBuilder.repeatedModule(new RepeatedModule());
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
new file mode 100644
index 000000000..7c0c02f73
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+
+final class ModuleSubcomponentsInterop {
+  @Component(modules = ProvisionTestModule.class)
+  interface ProvisionParent {
+    ProductionChild.Builder productionChild();
+  }
+
+  @Module(subcomponents = ProductionChild.class)
+  static class ProvisionTestModule {}
+
+  @ProductionSubcomponent
+  interface ProductionChild {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ProductionChild build();
+    }
+  }
+
+  @ProductionComponent(modules = ProductionTestModule.class)
+  interface ProductionParent {
+    ProvisionChild.Builder provisionBuilder();
+  }
+
+  @ProducerModule(subcomponents = ProvisionChild.class)
+  static class ProductionTestModule {}
+
+  @Subcomponent
+  interface ProvisionChild {
+    @Subcomponent.Builder
+    interface Builder {
+      ProvisionChild build();
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..c9c067aba
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import producerstest.ExecutorModule;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class ProductionSubcomponentFromModuleAndFactoryMethod {
+  @ProductionSubcomponent
+  interface Sub {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @ProducerModule(subcomponents = Sub.class)
+  static class ModuleWithSubcomponent {}
+
+  @ProductionComponent(modules = {ModuleWithSubcomponent.class, ExecutorModule.class})
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
new file mode 100644
index 000000000..07502ffeb
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+import producerstest.ExecutorModule;
+
+/** Supporting types for {@link ProducerModuleWithSubcomponentsTest}. */
+@ProductionComponent(
+  modules = UsesProducerModuleSubcomponents.ProducerModuleWithSubcomponents.class
+)
+public interface UsesProducerModuleSubcomponents {
+
+  ListenableFuture<Set<String>> strings();
+
+  @FromChild
+  ListenableFuture<Set<String>> stringsFromChild();
+
+  @ProducerModule(
+    subcomponents = Child.class,
+    includes = {AlsoIncludesSubcomponents.class, ExecutorModule.class}
+  )
+  class ProducerModuleWithSubcomponents {
+    @Produces
+    @IntoSet
+    static String produceStringInParent() {
+      return "from parent";
+    }
+
+    @Produces
+    @FromChild
+    static Set<String> stringsFromChild(Child.Builder childBuilder) throws Exception {
+      return childBuilder.build().strings().get();
+    }
+  }
+
+  @ProducerModule(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @ProductionSubcomponent(modules = ChildModule.class)
+  interface Child {
+    ListenableFuture<Set<String>> strings();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @ProducerModule
+  class ChildModule {
+    @Produces
+    @IntoSet
+    static String produceStringInChild() {
+      return "from child";
+    }
+  }
+
+  @Qualifier
+  @interface FromChild {}
+
+  @ProducerModule(includes = ProducerModuleWithSubcomponents.class)
+  class OnlyIncludesProducerModuleWithSubcomponents {}
+
+  @ProductionComponent(modules = OnlyIncludesProducerModuleWithSubcomponents.class)
+  interface ParentIncludesProductionSubcomponentTransitively
+      extends UsesProducerModuleSubcomponents {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
new file mode 100644
index 000000000..d16b1d063
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent.pruning;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@link ProductionSubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is
+ * a direct child of the top level component, but is only requested within its sibling, not directly
+ * from its parent.
+ */
+@ProductionComponent(
+  modules = {
+    ParentDoesntUseProductionSubcomponent.ParentModule.class,
+    producerstest.ExecutorModule.class
+  }
+)
+interface ParentDoesntUseProductionSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @ProductionSubcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+  }
+
+  @ProductionSubcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+
+    @FromChildA
+    ListenableFuture<Set<Class<?>>> componentHierarchyFromChildA();
+  }
+
+  @ProducerModule(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ParentDoesntUseProductionSubcomponent.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildAModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildBModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildB.class;
+    }
+
+    @Produces
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) throws Exception {
+      return childABuilder.build().componentHierarchy().get();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..24d43e5b6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.producers.ProducerModule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.UsesProducerModuleSubcomponents.ParentIncludesProductionSubcomponentTransitively;
+
+/** Tests for {@link ProducerModule#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ProducerModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() throws Exception {
+    UsesProducerModuleSubcomponents parent = DaggerUsesProducerModuleSubcomponents.create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() throws Exception {
+    ParentIncludesProductionSubcomponentTransitively parent =
+        DaggerUsesProducerModuleSubcomponents_ParentIncludesProductionSubcomponentTransitively
+            .create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..c579fb171
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionSubcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildA;
+import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildB;
+
+/**
+ * Tests for {@link ProductionSubcomponent}s which are included with {@link
+ * ProducerModule#subcomponents()} but not used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class ProductionSubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() throws Exception {
+    ParentDoesntUseProductionSubcomponent parent =
+        DaggerParentDoesntUseProductionSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index c0ea93968..4af116af3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -770,9 +770,14 @@ private void implementInterfaceMethods() {
   }
 
   private void addSubcomponents() {
-    for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+    for (BindingGraph subgraph : graph.subgraphs()) {
+      ComponentMethodDescriptor componentMethodDescriptor =
+          graph.componentDescriptor()
+              .subcomponentsByFactoryMethod()
+              .inverse()
+              .get(subgraph.componentDescriptor());
       SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
+          new SubcomponentWriter(this, Optional.fromNullable(componentMethodDescriptor), subgraph);
       component.addType(subcomponent.write().build());
     }
   }
@@ -1028,17 +1033,22 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         }
 
       case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            subcomponentNames.get(
+                graph.componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
         return CodeBlock.of(
             Joiner.on('\n')
                 .join(
                     "new $1T<$2T>() {",
                     "  @Override public $2T get() {",
-                    "    return $3L();",
+                    "    return new $3LBuilder();",
                     "  }",
                     "}"),
             /* 1 */ FACTORY,
             /* 2 */ bindingKeyTypeName,
-            /* 3 */ binding.bindingElement().get().getSimpleName());
+            /* 3 */ subcomponentName);
 
       case INJECTION:
       case PROVISION:
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index b88c7cbec..d2aece6d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -17,11 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
@@ -35,10 +41,14 @@
 
   @Override
   public String format(BindingDeclaration bindingDeclaration) {
+    if (bindingDeclaration instanceof SubcomponentDeclaration) {
+      return formatSubcomponentDeclaration((SubcomponentDeclaration) bindingDeclaration);
+    }
     checkArgument(
         bindingDeclaration.bindingElement().isPresent(),
         "Cannot format bindings without source elements: %s",
         bindingDeclaration);
+
     Element bindingElement = bindingDeclaration.bindingElement().get();
     switch (bindingElement.asType().getKind()) {
       case EXECUTABLE:
@@ -51,4 +61,32 @@ public String format(BindingDeclaration bindingDeclaration) {
         throw new IllegalArgumentException("Formatting unsupported for element: " + bindingElement);
     }
   }
+
+  private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponentDeclaration) {
+    ImmutableList<TypeMirror> moduleSubcomponents =
+        getModuleSubcomponents(subcomponentDeclaration.moduleAnnotation());
+    int index =
+        Iterables.indexOf(
+            moduleSubcomponents,
+            MoreTypes.equivalence()
+                .equivalentTo(subcomponentDeclaration.subcomponentType().asType()));
+    StringBuilder annotationValue = new StringBuilder();
+    if (moduleSubcomponents.size() != 1) {
+      annotationValue.append("{");
+    }
+    annotationValue.append(
+        formatArgumentInList(
+            index,
+            moduleSubcomponents.size(),
+            subcomponentDeclaration.subcomponentType().getQualifiedName() + ".class"));
+    if (moduleSubcomponents.size() != 1) {
+      annotationValue.append("}");
+    }
+
+    return String.format(
+        "@%s(subcomponents = %s) for %s",
+        simpleName(subcomponentDeclaration.moduleAnnotation()),
+        annotationValue,
+        subcomponentDeclaration.contributingModule().get());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 42774c387..23c9e94a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -26,9 +26,6 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingType.isOfType;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
@@ -61,6 +58,7 @@
 import dagger.Reusable;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ContributionBinding.Kind;
 import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -72,7 +70,7 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
+import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
@@ -93,7 +91,7 @@
 abstract class BindingGraph {
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
-  abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
+  abstract ImmutableSet<BindingGraph> subgraphs();
 
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
@@ -115,7 +113,7 @@
       new TreeTraverser<BindingGraph>() {
         @Override
         public Iterable<BindingGraph> children(BindingGraph node) {
-          return node.subgraphs().values();
+          return node.subgraphs();
         }
       };
 
@@ -151,18 +149,17 @@
    * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
    */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
-    return SUBGRAPH_TRAVERSER
-        .preOrderTraversal(this)
-        .transform(
-            new Function<BindingGraph, ComponentDescriptor>() {
-              @Override
-              public ComponentDescriptor apply(BindingGraph graph) {
-                return graph.componentDescriptor();
-              }
-            })
-        .toSet();
+    return SUBGRAPH_TRAVERSER.preOrderTraversal(this).transform(COMPONENT_DESCRIPTOR).toSet();
   }
 
+  static final Function<BindingGraph, ComponentDescriptor> COMPONENT_DESCRIPTOR =
+      new Function<BindingGraph, ComponentDescriptor>() {
+        @Override
+        public ComponentDescriptor apply(BindingGraph graph) {
+          return graph.componentDescriptor();
+        }
+      };
+
   ImmutableSet<TypeElement> availableDependencies() {
     return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
         .filter(not(hasModifiers(ABSTRACT)))
@@ -227,34 +224,40 @@ private BindingGraph create(
         }
       }
 
-      // Bindings for subcomponent builders.
-      for (ComponentMethodDescriptor subcomponentMethodDescriptor :
-          Iterables.filter(
-              componentDescriptor.subcomponents().keySet(),
-              isOfKind(SUBCOMPONENT_BUILDER, PRODUCTION_SUBCOMPONENT_BUILDER))) {
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.forSubcomponentBuilderMethod(
-                subcomponentMethodDescriptor.methodElement(),
-                componentDescriptor.componentDefinitionType()));
+      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor>
+          componentMethodAndSubcomponent :
+              componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {
+        ComponentMethodDescriptor componentMethod = componentMethodAndSubcomponent.getKey();
+        ComponentDescriptor subcomponentDescriptor = componentMethodAndSubcomponent.getValue();
+        if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.forSubcomponentBuilderMethod(
+                  componentMethod.methodElement(),
+                  componentDescriptor.componentDefinitionType()));
+        }
       }
 
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
+          ImmutableSet.builder();
 
       // Collect transitive module bindings and multibinding declarations.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
         multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
+        subcomponentDeclarations.addAll(moduleDescriptor.subcomponentDeclarations());
         delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());
         optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
       }
 
-      Resolver requestResolver =
+      final Resolver requestResolver =
           new Resolver(
               parentResolver,
               componentDescriptor,
               indexByKey(explicitBindingsBuilder.build()),
               indexByKey(multibindingDeclarations.build()),
+              indexByKey(subcomponentDeclarations.build()),
               indexByKey(delegatesBuilder.build()),
               indexByKey(optionalsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
@@ -264,13 +267,18 @@ private BindingGraph create(
         }
       }
 
-      ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
-          ImmutableMap.builder();
-      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-          componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(
-            subcomponentEntry.getKey().methodElement(),
-            create(Optional.of(requestResolver), subcomponentEntry.getValue()));
+      // Resolve all bindings for subcomponents, creating subgraphs for all subcomponents that have
+      // been detected during binding resolution. If a binding for a subcomponent is never resolved,
+      // no BindingGraph will be created for it and no implementation will be generated. This is
+      // done in a queue since resolving one subcomponent might resolve a key for a subcomponent
+      // from a parent graph. This is done until no more new subcomponents are resolved.
+      Set<ComponentDescriptor> resolvedSubcomponents = new HashSet<>();
+      ImmutableSet.Builder<BindingGraph> subgraphs = ImmutableSet.builder();
+      for (ComponentDescriptor subcomponent :
+          Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
+        if (resolvedSubcomponents.add(subcomponent)) {
+          subgraphs.add(create(Optional.of(requestResolver), subcomponent));
+        }
       }
 
       for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
@@ -284,7 +292,7 @@ private BindingGraph create(
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build(),
+          subgraphs.build(),
           requestResolver.getOwnedModules());
     }
 
@@ -295,6 +303,7 @@ private BindingGraph create(
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
+      final ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
       final ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
@@ -304,12 +313,14 @@ private BindingGraph create(
           CacheBuilder.newBuilder().build();
       final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().build();
+      final Queue<ComponentDescriptor> subcomponentsToResolve = new ArrayDeque<>();
 
       Resolver(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
           ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations,
+          ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations,
           ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations,
           ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations) {
         this.parentResolver = checkNotNull(parentResolver);
@@ -317,6 +328,7 @@ private BindingGraph create(
         this.explicitBindings = checkNotNull(explicitBindings);
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         this.multibindingDeclarations = checkNotNull(multibindingDeclarations);
+        this.subcomponentDeclarations = checkNotNull(subcomponentDeclarations);
         this.delegateDeclarations = checkNotNull(delegateDeclarations);
         this.optionalBindingDeclarations = checkNotNull(optionalBindingDeclarations);
         this.resolvedBindings = Maps.newLinkedHashMap();
@@ -324,6 +336,7 @@ private BindingGraph create(
             multibindingContributionsByMultibindingKey(explicitBindingsSet);
         this.delegateMultibindingDeclarations =
             multibindingContributionsByMultibindingKey(delegateDeclarations.values());
+        subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());
       }
 
       /**
@@ -362,6 +375,8 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
+            ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarationsBuilder =
+                ImmutableSet.builder();
             ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarationsBuilder =
                 ImmutableSet.builder();
 
@@ -369,6 +384,7 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
               contributionBindings.addAll(getExplicitBindings(key));
               multibindingContributionsBuilder.addAll(getExplicitMultibindings(key));
               multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
+              subcomponentDeclarationsBuilder.addAll(getSubcomponentDeclarations(key));
               optionalBindingDeclarationsBuilder.addAll(getOptionalBindingDeclarations(key));
             }
 
@@ -376,6 +392,8 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 multibindingContributionsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
+            ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations =
+                subcomponentDeclarationsBuilder.build();
             ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
                 optionalBindingDeclarationsBuilder.build();
 
@@ -384,6 +402,12 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 syntheticMultibinding(
                         requestKey, multibindingContributions, multibindingDeclarations)
                     .asSet());
+            Optional<ProvisionBinding> subcomponentBuilderBinding =
+                syntheticSubcomponentBuilderBinding(subcomponentDeclarations);
+            if (subcomponentBuilderBinding.isPresent()) {
+              contributionBindings.add(subcomponentBuilderBinding.get());
+              addSubcomponentToOwningResolver(subcomponentBuilderBinding.get());
+            }
             contributionBindings.addAll(
                 syntheticOptionalBinding(requestKey, optionalBindingDeclarations).asSet());
 
@@ -400,6 +424,7 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 indexBindingsByOwningComponent(
                     bindingKey, ImmutableSet.copyOf(contributionBindings)),
                 multibindingDeclarations,
+                subcomponentDeclarations,
                 optionalBindingDeclarations);
 
           case MEMBERS_INJECTION:
@@ -416,6 +441,20 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
         }
       }
 
+      /**
+       * When a binding is resolved for a {@link SubcomponentDeclaration}, adds corresponding
+       * {@link ComponentDescriptor subcomponent} to a queue in the owning component's resolver.
+       * The queue will be used to detect which subcomponents need to be resolved.
+       */
+      private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilderBinding) {
+        checkArgument(subcomponentBuilderBinding.bindingKind().equals(Kind.SUBCOMPONENT_BUILDER));
+        Resolver owningResolver = getOwningResolver(subcomponentBuilderBinding).get();
+
+        TypeElement builderType = MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());
+        owningResolver.subcomponentsToResolve.add(
+            owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
+      }
+
       private Iterable<Key> keysMatchingRequest(Key requestKey) {
         return ImmutableSet.<Key>builder()
             .add(requestKey)
@@ -539,6 +578,14 @@ private boolean multibindingsRequireProduction(
         return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
       }
 
+      private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
+          ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+        return subcomponentDeclarations.isEmpty()
+            ? Optional.<ProvisionBinding>absent()
+            : Optional.of(
+            provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
+      }
+
       /**
        * Returns a synthetic binding for {@code @Qualifier Optional<Type>} if there are any {@code
        * optionalBindingDeclarations}.
@@ -670,7 +717,8 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
         }
 
         for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitBindingsSet.contains(binding)) {
+          if (requestResolver.explicitBindingsSet.contains(binding)
+              || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
             return Optional.of(requestResolver);
           }
         }
@@ -757,6 +805,18 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
         return multibindingDeclarations.build();
       }
 
+      /**
+       * Returns the {@link SubcomponentDeclaration}s that match the {@code key} from this and all
+       * ancestor resolvers.
+       */
+      private ImmutableSet<SubcomponentDeclaration> getSubcomponentDeclarations(Key key) {
+        ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          subcomponentDeclarations.addAll(resolver.subcomponentDeclarations.get(key));
+        }
+        return subcomponentDeclarations.build();
+      }
       /**
        * Returns the {@link OptionalBindingDeclaration}s that match the {@code key} from this and
        * all ancestor resolvers.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 501abccde..d44498a05 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -29,11 +29,8 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
-import static com.google.common.collect.Maps.filterKeys;
 import static dagger.internal.codegen.BindingDeclaration.HAS_BINDING_ELEMENT;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
@@ -93,7 +90,6 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.Kind;
-import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -252,12 +248,15 @@ int size() {
     final BindingGraph subject;
     final ValidationReport.Builder<TypeElement> reportBuilder;
     final Optional<Validation> parent;
+    final ImmutableMap<ComponentDescriptor, BindingGraph> subgraphsByComponentDescriptor;
 
     Validation(BindingGraph subject, Optional<Validation> parent) {
       this.subject = subject;
       this.reportBuilder =
           ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
       this.parent = parent;
+      this.subgraphsByComponentDescriptor =
+          Maps.uniqueIndex(subject.subgraphs(), BindingGraph.COMPONENT_DESCRIPTOR);
     }
 
     Validation(BindingGraph topLevelGraph) {
@@ -287,15 +286,12 @@ void validateSubgraph() {
       }
 
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
-          filterKeys(
-                  subject.componentDescriptor().subcomponents(),
-                  isOfKind(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT))
-              .entrySet()) {
+          subject.componentDescriptor().subcomponentsByFactoryMethod().entrySet()) {
         validateSubcomponentFactoryMethod(
-            entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
+            entry.getKey().methodElement(), subgraphsByComponentDescriptor.get(entry.getValue()));
       }
 
-      for (BindingGraph subgraph : subject.subgraphs().values()) {
+      for (BindingGraph subgraph : subject.subgraphs()) {
         Validation subgraphValidation = new Validation(subgraph, Optional.of(this));
         subgraphValidation.validateSubgraph();
         reportBuilder.addSubreport(subgraphValidation.buildReport());
@@ -303,8 +299,7 @@ void validateSubgraph() {
     }
 
     private void validateSubcomponentFactoryMethod(
-        ExecutableElement factoryMethod, TypeElement subcomponentType) {
-      BindingGraph subgraph = subject.subgraphs().get(factoryMethod);
+        ExecutableElement factoryMethod, BindingGraph subgraph) {
       FluentIterable<TypeElement> missingModules =
           FluentIterable.from(subgraph.componentRequirements())
               .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
@@ -320,7 +315,7 @@ public boolean apply(TypeElement moduleType) {
             String.format(
                 "%s requires modules which have no visible default constructors. "
                     + "Add the following modules as parameters to this method: %s",
-                subcomponentType.getQualifiedName(),
+                subgraph.componentDescriptor().componentDefinitionType().getQualifiedName(),
                 Joiner.on(", ").join(missingModules.toSet())),
             factoryMethod);
       }
@@ -496,6 +491,8 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           ImmutableSetMultimap.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
+          ImmutableSet.builder();
       ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarations =
           ImmutableSet.builder();
 
@@ -504,6 +501,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
 
       for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
         multibindingDeclarations.addAll(queued.multibindingDeclarations());
+        subcomponentDeclarations.addAll(queued.subcomponentDeclarations());
         optionalBindingDeclarations.addAll(queued.optionalBindingDeclarations());
         for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
             queued.allContributionBindings().entries()) {
@@ -523,6 +521,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           resolvedBinding.owningComponent(),
           contributions.build(),
           multibindingDeclarations.build(),
+          subcomponentDeclarations.build(),
           optionalBindingDeclarations.build());
     }
 
@@ -728,10 +727,9 @@ private void validateComponentHierarchy(
             message.toString(),
             compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
             rootComponent,
-            getAnnotationMirror(rootComponent, Component.class).get());
+            getComponentAnnotation(rootComponent).get());
       } else {
-        Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
+        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(componentType);
         if (componentAnnotation.isPresent()) {
           componentStack.push(componentType);
 
@@ -879,9 +877,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
               message.toString(),
               compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
               rootComponent,
-              getAnnotationMirror(rootComponent, Component.class)
-                  .or(getAnnotationMirror(rootComponent, ProductionComponent.class))
-                  .get());
+              getComponentAnnotation(rootComponent).get());
         }
         scopedDependencyStack.pop();
       } else {
@@ -1084,10 +1080,12 @@ private void reportDuplicateBindings(DependencyPath path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineContributionsWithoutBindingElements(resolvedBindings).contributionBindings();
+      ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBindings);
+      ImmutableSet<ContributionBinding> duplicateBindings = inlined.contributionBindings();
+      Set<BindingDeclaration> conflictingDeclarations =
+          Sets.union(duplicateBindings, inlined.subcomponentDeclarations());
       bindingDeclarationFormatter.formatIndentedList(
-          builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
+          builder, conflictingDeclarations, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
index 70df6d483..36db21ab6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -18,8 +18,10 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 
 import java.util.Iterator;
+import javax.lang.model.element.Element;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -48,9 +50,16 @@ static String name(Binding binding) {
     type.accept(
         new SimpleTypeVisitor6<Void, StringBuilder>() {
           @Override
-          public Void visitDeclared(DeclaredType t, StringBuilder builder) {
-            builder.append(t.asElement().getSimpleName());
-            Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+          public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
+            Element element = declaredType.asElement();
+            if (isSubcomponentBuilder(element)) {
+              // Most Subcomponent builders are named "Builder", so add their associated
+              // Subcomponent type so that they're not all "builderProvider{N}"
+              builder.append(element.getEnclosingElement().getSimpleName());
+            }
+            builder.append(element.getSimpleName());
+            Iterator<? extends TypeMirror> argumentIterator =
+                declaredType.getTypeArguments().iterator();
             if (argumentIterator.hasNext()) {
               builder.append("Of");
               TypeMirror first = argumentIterator.next();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 401c64751..7b649b1d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -24,6 +24,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -35,12 +37,12 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Lazy;
@@ -57,6 +59,7 @@
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -240,13 +243,7 @@ boolean isProducer() {
    * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
    * are declared in parent components.
    */
-  ImmutableSet<ModuleDescriptor> transitiveModules() {
-    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
-    for (ModuleDescriptor module : modules()) {
-      addTransitiveModules(transitiveModules, module);
-    }
-    return ImmutableSet.copyOf(transitiveModules);
-  }
+  abstract ImmutableSet<ModuleDescriptor> transitiveModules();
 
   ImmutableSet<TypeElement> transitiveModuleTypes() {
     return FluentIterable.from(transitiveModules())
@@ -254,15 +251,22 @@ boolean isProducer() {
         .toSet();
   }
 
-  @CanIgnoreReturnValue
-  private static Set<ModuleDescriptor> addTransitiveModules(
+  private static ImmutableSet<ModuleDescriptor> transitiveModules(
+      Iterable<ModuleDescriptor> topLevelModules) {
+    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
+    for (ModuleDescriptor module : topLevelModules) {
+      addTransitiveModules(transitiveModules, module);
+    }
+    return ImmutableSet.copyOf(transitiveModules);
+  }
+
+  private static void addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
       for (ModuleDescriptor includedModule : module.includedModules()) {
         addTransitiveModules(transitiveModules, includedModule);
       }
     }
-    return transitiveModules;
   }
 
   /**
@@ -277,7 +281,73 @@ boolean isProducer() {
    */
   abstract ImmutableSet<Scope> scopes();
 
-  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
+  /**
+   * All {@link Subcomponent}s which are direct children of this component. This includes
+   * subcomponents installed from {@link Module#subcomponents()} as well as subcomponent {@linkplain
+   * #subcomponentsByFactoryMethod() factory methods} and {@linkplain
+   * #subcomponentsByBuilderMethod() builder methods}.
+   */
+  ImmutableSet<ComponentDescriptor> subcomponents() {
+    return ImmutableSet.<ComponentDescriptor>builder()
+        .addAll(subcomponentsByFactoryMethod().values())
+        .addAll(subcomponentsByBuilderMethod().values())
+        .addAll(subcomponentsFromModules())
+        .build();
+  }
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a {@linkplain
+   * Module#subcomponents() module's subcomponents}.
+   */
+  abstract ImmutableSet<ComponentDescriptor> subcomponentsFromModules();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
+   * factory method.
+   */
+  abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
+      subcomponentsByFactoryMethod();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
+   * builder method.
+   */
+  abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
+    subcomponentsByBuilderMethod();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by an entry point
+   * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}
+   * and {@link #subcomponentsByBuilderMethod().
+   */
+  ImmutableSet<ComponentDescriptor> subcomponentsFromEntryPoints() {
+    return ImmutableSet.<ComponentDescriptor>builder()
+        .addAll(subcomponentsByFactoryMethod().values())
+        .addAll(subcomponentsByBuilderMethod().values())
+        .build();
+  }
+
+  // TODO(ronshapiro): convert this to use @Memoized
+  private ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType;
+
+  ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
+    if (subcomponentsByBuilderType == null) {
+      subcomponentsByBuilderType = computeSubcomponentsByBuilderType();
+    }
+    return subcomponentsByBuilderType;
+  }
+
+  private ImmutableBiMap<TypeElement, ComponentDescriptor> computeSubcomponentsByBuilderType() {
+    ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
+        ImmutableBiMap.builder();
+    for (ComponentDescriptor subcomponent : subcomponents()) {
+      if (subcomponent.builderSpec().isPresent()) {
+        subcomponentsByBuilderType.put(
+            subcomponent.builderSpec().get().builderDefinitionType(), subcomponent);
+      }
+    }
+    return subcomponentsByBuilderType.build();
+  }
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
@@ -327,6 +397,13 @@ static ComponentMethodDescriptor forSubcomponent(
         ComponentMethodKind kind, ExecutableElement methodElement) {
       return create(kind, Optional.<DependencyRequest>absent(), methodElement);
     }
+
+    static ComponentMethodDescriptor forSubcomponentBuilder(
+        ComponentMethodKind kind,
+        DependencyRequest dependencyRequestForBuilder,
+        ExecutableElement methodElement) {
+      return create(kind, Optional.of(dependencyRequestForBuilder), methodElement);
+    }
   }
 
   enum ComponentMethodKind {
@@ -338,6 +415,10 @@ static ComponentMethodDescriptor forSubcomponent(
     PRODUCTION_SUBCOMPONENT,
     PRODUCTION_SUBCOMPONENT_BUILDER;
 
+    boolean isSubcomponentKind() {
+      return this == SUBCOMPONENT || this == PRODUCTION_SUBCOMPONENT;
+    }
+
     /**
      * Returns the component kind associated with this component method, if it exists. Otherwise,
      * throws.
@@ -417,27 +498,40 @@ private ComponentDescriptor create(
         }
       }
 
-      ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
-      for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
-        modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
+      ImmutableSet.Builder<ModuleDescriptor> modulesBuilder = ImmutableSet.builder();
+      for (TypeMirror componentModulesType : getComponentModules(componentMirror)) {
+        modulesBuilder.add(
+            moduleDescriptorFactory.create(MoreTypes.asTypeElement(componentModulesType)));
       }
       if (kind.equals(Kind.PRODUCTION_COMPONENT)
           || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
               && parentKind.isPresent()
               && (parentKind.get().equals(Kind.COMPONENT)
                   || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
-        modules.add(descriptorForMonitoringModule(componentDefinitionType));
-        modules.add(descriptorForProductionExecutorModule(componentDefinitionType));
+        modulesBuilder.add(descriptorForMonitoringModule(componentDefinitionType));
+        modulesBuilder.add(descriptorForProductionExecutorModule(componentDefinitionType));
+      }
+      ImmutableSet<ModuleDescriptor> modules = modulesBuilder.build();
+      ImmutableSet<ModuleDescriptor> transitiveModules = transitiveModules(modules);
+      ImmutableSet.Builder<ComponentDescriptor> subcomponentsFromModules = ImmutableSet.builder();
+      for (ModuleDescriptor module : transitiveModules) {
+        for (SubcomponentDeclaration subcomponentDeclaration : module.subcomponentDeclarations()) {
+          TypeElement subcomponent = subcomponentDeclaration.subcomponentType();
+          subcomponentsFromModules.add(
+              create(
+                  subcomponent, Kind.forAnnotatedElement(subcomponent).get(), Optional.of(kind)));
+        }
       }
-
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
-          ImmutableMap.builder();
+      ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
+          subcomponentsByFactoryMethod = ImmutableBiMap.builder();
+      ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
+          subcomponentsByBuilderMethod = ImmutableBiMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
             MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
@@ -447,7 +541,7 @@ private ComponentDescriptor create(
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
           case PRODUCTION_SUBCOMPONENT:
-            subcomponentDescriptors.put(
+            subcomponentsByFactoryMethod.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
@@ -456,7 +550,7 @@ private ComponentDescriptor create(
             break;
           case SUBCOMPONENT_BUILDER:
           case PRODUCTION_SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(
+            subcomponentsByBuilderMethod.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(
@@ -485,10 +579,13 @@ private ComponentDescriptor create(
           componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
-          modules.build(),
+          modules,
+          transitiveModules,
           dependencyMethodIndex.build(),
           scopes,
-          subcomponentDescriptors.build(),
+          subcomponentsFromModules.build(),
+          subcomponentsByFactoryMethod.build(),
+          subcomponentsByBuilderMethod.build(),
           componentMethodsBuilder.build(),
           builderSpec);
     }
@@ -512,21 +609,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
               dependencyRequestFactory.forComponentMembersInjectionMethod(
                   componentMethod, resolvedComponentMethod));
         } else if (!getQualifier(componentMethod).isPresent()) {
-          if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.SUBCOMPONENT, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
+          Element returnTypeElement = MoreTypes.asElement(returnType);
+          if (isSubcomponent(returnTypeElement)) {
             return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
+                isAnnotationPresent(returnTypeElement, Subcomponent.class)
+                    ? ComponentMethodKind.SUBCOMPONENT
+                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,
+                componentMethod);
+          } else if (isSubcomponentBuilder(returnTypeElement)) {
+            DependencyRequest dependencyRequest =
+                dependencyRequestFactory.forComponentProvisionMethod(
+                    componentMethod, resolvedComponentMethod);
+            return ComponentMethodDescriptor.forSubcomponentBuilder(
+                isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)
+                    ? ComponentMethodKind.SUBCOMPONENT_BUILDER
+                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER,
+                dependencyRequest,
+                componentMethod);
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 217c5008b..91c9f5a73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -45,40 +45,24 @@
     ValidationReport.Builder<TypeElement> reportBuilder =
         ValidationReport.about(componentDescriptor.componentDefinitionType());
     for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-        componentDescriptor.subcomponents().entrySet()) {
+        componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
       ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
       ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
       // validate the way that we create subcomponents
-      switch (subcomponentMethodDescriptor.kind()) {
-        case SUBCOMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          for (VariableElement factoryMethodParameter :
-              subcomponentMethodDescriptor.methodElement().getParameters()) {
-            TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
-            TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
-            if (originatingComponent != null) {
-              /* Factory method tries to pass a module that is already present in the parent.
-               * This is an error. */
-              reportBuilder.addError(
-                  String.format(
-                      "%s is present in %s. A subcomponent cannot use an instance of a "
-                          + "module that differs from its parent.",
-                      moduleType.getSimpleName(),
-                      originatingComponent.getQualifiedName()),
-                  factoryMethodParameter);
-            }
-          }
-          break;
-          
-        case SUBCOMPONENT_BUILDER:
-        case PRODUCTION_SUBCOMPONENT_BUILDER:
-          /* A subcomponent builder allows you to pass a module that is already present in the
-           * parent.  This can't be an error because it might be valid in _other_ components. Don't
-           * bother warning, because there's nothing to do except suppress the warning. */
-          break;
-          
-        default:
-          throw new AssertionError();
+      for (VariableElement factoryMethodParameter :
+          subcomponentMethodDescriptor.methodElement().getParameters()) {
+        TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
+        TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+        if (originatingComponent != null) {
+          /* Factory method tries to pass a module that is already present in the parent.
+           * This is an error. */
+          reportBuilder.addError(
+              String.format(
+                  "%s is present in %s. A subcomponent cannot use an instance of a "
+                      + "module that differs from its parent.",
+                  moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
+              factoryMethodParameter);
+        }
       }
       reportBuilder.addSubreport(
           validateSubcomponentMethods(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 8d85797a4..9ca87cf2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -124,6 +124,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
         new MultibindingDeclaration.Factory(elements, types, keyFactory);
+    SubcomponentDeclaration.Factory subcomponentDeclarationFactory =
+        new SubcomponentDeclaration.Factory(keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
@@ -150,6 +152,7 @@ public SourceVersion getSupportedSourceVersion() {
             productionBindingFactory,
             multibindingDeclarationFactory,
             bindingDelegateDeclarationFactory,
+            subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 199c4a4bd..bee627f5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -37,7 +37,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
@@ -157,7 +157,7 @@ public ComponentValidationReport validate(final TypeElement subject,
     // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
     // it can return a logical method multiple times (including overrides, etc.)
     List<? extends Element> members = elements.getAllMembers(subject);
-    Multimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
+    SetMultimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
     for (ExecutableElement method : ElementFilter.methodsIn(members)) {
       if (method.getModifiers().contains(ABSTRACT)) {
         ExecutableType resolvedMethod =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index d1091550b..5c91e2ace 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -18,7 +18,10 @@
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -31,7 +34,10 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Module;
+import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
@@ -45,7 +51,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -59,6 +64,35 @@
  */
 final class ConfigurationAnnotations {
 
+  static Optional<AnnotationMirror> getComponentAnnotation(TypeElement component) {
+    return getAnnotationMirror(component, Component.class)
+        .or(getAnnotationMirror(component, ProductionComponent.class));
+  }
+
+  static Optional<AnnotationMirror> getSubcomponentAnnotation(TypeElement subcomponent) {
+    return getAnnotationMirror(subcomponent, Subcomponent.class)
+        .or(getAnnotationMirror(subcomponent, ProductionSubcomponent.class));
+  }
+
+  static boolean isSubcomponent(Element element) {
+    return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
+  }
+
+  static Optional<TypeElement> getSubcomponentBuilder(TypeElement subcomponent) {
+    checkArgument(isSubcomponent(subcomponent));
+    for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
+      if (isSubcomponentBuilder(nestedType)) {
+        return Optional.of(nestedType);
+      }
+    }
+    return Optional.absent();
+  }
+
+  static boolean isSubcomponentBuilder(Element element) {
+    return isAnyAnnotationPresent(
+        element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  }
+
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
@@ -73,6 +107,11 @@
     return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
+  static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
+    return getAnnotationMirror(moduleElement, Module.class)
+        .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+  }
+
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
@@ -80,6 +119,13 @@
     return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
+  private static final String SUBCOMPONENTS_ATTRIBUTE = "subcomponents";
+
+  static ImmutableList<TypeMirror> getModuleSubcomponents(AnnotationMirror moduleAnnotation) {
+    checkNotNull(moduleAnnotation);
+    return convertClassArrayToListOfTypes(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);
+  }
+
   private static final String INJECTS_ATTRIBUTE = "injects";
 
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
@@ -156,7 +202,7 @@ public TypeMirror apply(AnnotationValue typeValue) {
           throw new IllegalArgumentException(elementName + " is not an array: " + o);
         }
       };
-      
+
   /**
    * Returns the value named {@code elementName} from {@code annotation}, which must be a member
    * that contains a single type.
@@ -195,8 +241,7 @@ protected TypeMirror defaultAction(Object o, Void p) {
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class)
-          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+      Optional<AnnotationMirror> moduleMirror = getModuleAnnotation(moduleElement);
       if (moduleMirror.isPresent()) {
         ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
         moduleDependenciesBuilder.addAll(
@@ -221,7 +266,7 @@ protected TypeMirror defaultAction(Object o, Void p) {
   static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
       final Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
-    for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
+    for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, annotation)) {
         builders.add(MoreTypes.asDeclared(element.asType()));
       }
@@ -237,8 +282,7 @@ private static void addIncludesFromSuperclasses(Types types, TypeElement element
     while (!types.isSameType(objectType, superclass)
         && superclass.getKind().equals(TypeKind.DECLARED)) {
       element = MoreElements.asType(types.asElement(superclass));
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
-          .or(getAnnotationMirror(element, ProducerModule.class));
+      Optional<AnnotationMirror> moduleMirror = getModuleAnnotation(element);
       if (moduleMirror.isPresent()) {
         builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 990b52931..6c809dfd4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -33,6 +33,7 @@
 import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
 import dagger.internal.codegen.BindingGraphValidator.ResolvedRequest;
 import dagger.producers.Produces;
+import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -152,14 +153,11 @@ public String visitVariableAsParameter(
                 ExecutableElement methodOrConstructor =
                     asExecutable(variable.getEnclosingElement());
                 appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-                int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
-                if (parameterIndex > 0) {
-                  builder.append("…, ");
-                }
-                builder.append(variable.getSimpleName());
-                if (parameterIndex < methodOrConstructor.getParameters().size() - 1) {
-                  builder.append(", …");
-                }
+                List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
+                int parameterIndex = parameters.indexOf(variable);
+                builder.append(
+                    formatArgumentInList(
+                        parameterIndex, parameters.size(), variable.getSimpleName()));
                 builder.append(')');
                 return builder.toString();
               }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 73bb5d026..bf709f292 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,6 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -23,6 +27,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -504,6 +509,33 @@ private MultibindingsMessages() {}
     private MultibindsMessages() {}
   }
 
+  static class ModuleMessages {
+    static String moduleSubcomponentsIncludesBuilder(TypeElement moduleSubcomponentsAttribute) {
+      TypeElement subcomponentType =
+          MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
+      return String.format(
+          "%s is a @%s.Builder. Did you mean to use %s?",
+          moduleSubcomponentsAttribute.getQualifiedName(),
+          simpleName(getSubcomponentAnnotation(subcomponentType).get()),
+          subcomponentType.getQualifiedName());
+    }
+
+    static String moduleSubcomponentsIncludesNonSubcomponent(
+        TypeElement moduleSubcomponentsAttribute) {
+      return moduleSubcomponentsAttribute.getQualifiedName()
+          + " is not a @Subcomponent or @ProductionSubcomponent";
+    }
+
+    static String moduleSubcomponentsDoesntHaveBuilder(
+        TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
+      return String.format(
+          "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
+          subcomponent.getQualifiedName(),
+          simpleName(getSubcomponentAnnotation(subcomponent).get()),
+          simpleName(moduleAnnotation));
+    }
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 714b63f5f..da3cb4789 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkElementIndex;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 import com.google.common.base.Function;
@@ -85,4 +86,17 @@ private void appendIndent(StringBuilder builder, int indentLevel) {
       builder.append(INDENT);
     }
   }
+
+  protected String formatArgumentInList(int index, int size, CharSequence name) {
+    checkElementIndex(index, size);
+    StringBuilder builder = new StringBuilder();
+    if (index > 0) {
+      builder.append("…, ");
+    }
+    builder.append(name);
+    if (index < size - 1) {
+      builder.append(", …");
+    }
+    return builder.toString();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f5cbaf179..dd37e9c07 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -347,6 +347,14 @@ Key forSubcomponentBuilderMethod(
       return forMethod(subcomponentBuilderMethod, returnType);
     }
 
+    Key forSubcomponentBuilder(TypeMirror builderType) {
+      checkNotNull(builderType);
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(builderType),
+          Optional.<MultibindingContributionIdentifier>absent());
+    }
+
     Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
       return forBindingMethod(method, contributingModule, Optional.of(getProviderElement()));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index 384154809..8f86422b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -40,7 +40,7 @@
       BindingGraph graph = graphsToTry.removeLast();
       ResolvedBindings bindings = graph.resolvedBindings().get(key);
       if ((bindings == null) || bindings.bindings().isEmpty()) {
-        graphsToTry.addAll(graph.subgraphs().values());
+        graphsToTry.addAll(graph.subgraphs());
       } else {
         resolutions.add("A binding with matching key exists in component: "
             + graph.componentDescriptor().componentDefinitionType().getQualifiedName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index ca6100794..d50fa054a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -19,8 +19,8 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
@@ -72,6 +72,9 @@
   /** The multibinding declarations contained in this module. */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
+  /** The {@link Module#subcomponents() subcomponent declarations} contained in this module. */
+  abstract ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations();
+
   /** The {@link Binds} method declarations that define delegate bindings. */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
@@ -118,6 +121,10 @@
       this.includesTypes = includesTypes;
     }
 
+    Optional<AnnotationMirror> getModuleAnnotationMirror(TypeElement element) {
+      return getAnnotationMirror(element, moduleAnnotation);
+    }
+
     Class<? extends Annotation> moduleAnnotation() {
       return moduleAnnotation;
     }
@@ -137,6 +144,7 @@
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
     private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
+    private final SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
     private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
 
     Factory(
@@ -145,20 +153,18 @@
         ProductionBinding.Factory productionBindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
         DelegateDeclaration.Factory bindingDelegateDeclarationFactory,
+        SubcomponentDeclaration.Factory subcomponentDeclarationFactory,
         OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
       this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
+      this.subcomponentDeclarationFactory = subcomponentDeclarationFactory;
       this.optionalBindingDeclarationFactory = optionalBindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      checkState(getModuleAnnotation(moduleElement).isPresent(),
-          "%s did not have an AnnotationMirror for @Module",
-          moduleElement.getQualifiedName());
-
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
@@ -199,15 +205,11 @@ ModuleDescriptor create(TypeElement moduleElement) {
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
+          subcomponentDeclarationFactory.forModule(moduleElement),
           delegates.build(),
           optionalDeclarations.build());
     }
 
-    private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
-      return getAnnotationMirror(moduleElement, Module.class)
-          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
-    }
-
     @CanIgnoreReturnValue
     private Set<ModuleDescriptor> collectIncludedModules(
         Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 41ce7a874..ea58b7013 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -23,10 +23,15 @@
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsDoesntHaveBuilder;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesBuilder;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesNonSubcomponent;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
@@ -35,6 +40,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.common.Visibility;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -47,8 +53,10 @@
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
+import dagger.Subcomponent;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.EnumSet;
@@ -74,6 +82,11 @@
  * @since 2.0
  */
 final class ModuleValidator {
+  private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_TYPES =
+      ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);
+  private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_BUILDER_TYPES =
+      ImmutableSet.of(Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+
   private final Types types;
   private final Elements elements;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -121,11 +134,60 @@
     }
     validateModifiers(subject, builder);
     validateReferencedModules(subject, moduleKind, builder);
+    validateReferencedSubcomponents(subject, moduleKind, builder);
 
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
+  private void validateReferencedSubcomponents(
+      final TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
+      final ValidationReport.Builder<TypeElement> builder) {
+    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotationMirror(subject).get();
+    // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
+    for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
+      subcomponentAttribute.accept(
+          new SimpleTypeVisitor6<Void, Void>(){
+            @Override
+            protected Void defaultAction(TypeMirror e, Void aVoid) {
+              builder.addError(e + " is not a valid subcomponent type", subject, moduleAnnotation);
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
+              TypeElement attributeType = MoreTypes.asTypeElement(declaredType);
+              if (isAnyAnnotationPresent(attributeType, SUBCOMPONENT_TYPES)) {
+                validateSubcomponentHasBuilder(attributeType, moduleAnnotation, builder);
+              } else {
+                builder.addError(
+                    isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)
+                        ? moduleSubcomponentsIncludesBuilder(attributeType)
+                        : moduleSubcomponentsIncludesNonSubcomponent(attributeType),
+                    attributeType,
+                    moduleAnnotation);
+              }
+
+              return null;
+            }
+          }, null);
+    }
+  }
+
+  private void validateSubcomponentHasBuilder(
+      TypeElement subcomponentAttribute,
+      AnnotationMirror moduleAnnotation,
+      ValidationReport.Builder<TypeElement> builder) {
+    if (getSubcomponentBuilder(subcomponentAttribute).isPresent()) {
+      return;
+    }
+    builder.addError(
+        moduleSubcomponentsDoesntHaveBuilder(subcomponentAttribute, moduleAnnotation),
+        subcomponentAttribute,
+        moduleAnnotation);
+  }
+
   enum ModuleMethodKind {
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
@@ -174,7 +236,7 @@ private void validateReferencedModules(
       ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
+    AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
     ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
     validateReferencedModules(subject, builder, includes, ImmutableSet.of(moduleKind));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
index ce211e687..29f41748d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -20,6 +20,7 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Name;
 
 /**
  * A utility class for working with {@link AnnotationMirror} instances, similar to {@link
@@ -50,4 +51,8 @@ private MoreAnnotationMirrors() {}
         ? Optional.of(wrappedOptional.get().get())
         : Optional.<AnnotationMirror>absent();
   }
+
+  static Name simpleName(AnnotationMirror annotationMirror) {
+    return annotationMirror.getAnnotationType().asElement().getSimpleName();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 2f4bdfba1..b6e459ab9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -278,6 +278,16 @@ ProvisionBinding forSubcomponentBuilderMethod(
           .build();
     }
 
+    ProvisionBinding syntheticSubcomponentBuilder(
+        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+      SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(subcomponentDeclaration.key())
+          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .build();
+    }
+
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 2182a0437..d146fe5d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -82,7 +82,13 @@ public Key key() {
    * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
    */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
-  
+
+  /**
+   * The subcomponent declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations();
+
   /**
    * The optional binding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is
    * not {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
@@ -127,10 +133,13 @@ Binding binding() {
   }
 
   /**
-   * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
+   * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, or
+   * {@link #subcomponentDeclarations()}.
    */
   boolean isEmpty() {
-    return bindings().isEmpty() && multibindingDeclarations().isEmpty();
+    return bindings().isEmpty()
+        && multibindingDeclarations().isEmpty()
+        && subcomponentDeclarations().isEmpty();
   }
 
   /**
@@ -201,6 +210,7 @@ static ResolvedBindings forContributionBindings(
       ComponentDescriptor owningComponent,
       Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
       Iterable<MultibindingDeclaration> multibindings,
+      Iterable<SubcomponentDeclaration> subcomponentDeclarations,
       Iterable<OptionalBindingDeclaration> optionalBindingDeclarations) {
     checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
@@ -209,6 +219,7 @@ static ResolvedBindings forContributionBindings(
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
         ImmutableSet.copyOf(multibindings),
+        ImmutableSet.copyOf(subcomponentDeclarations),
         ImmutableSet.copyOf(optionalBindingDeclarations));
   }
   
@@ -226,6 +237,7 @@ static ResolvedBindings forMembersInjectionBinding(
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
         ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<SubcomponentDeclaration>of(),
         ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
@@ -239,6 +251,7 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
         ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<SubcomponentDeclaration>of(),
         ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
@@ -253,6 +266,7 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
         allContributionBindings(),
         allMembersInjectionBindings(),
         multibindingDeclarations(),
+        subcomponentDeclarations(),
         optionalBindingDeclarations());
   }
 
@@ -275,15 +289,16 @@ ContributionBinding contributionBinding() {
   }
 
   /**
-   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} but no
-   * {@link #bindings()}, returns {@link BindingType#PROVISION}.
+   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} or {@link
+   * #subcomponentDeclarations()} but no {@link #bindings()}, returns {@link BindingType#PROVISION}.
    *
    * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
   @Override
   public BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", bindingKey());
-    if (bindings().isEmpty() && !multibindingDeclarations().isEmpty()) {
+    if (bindings().isEmpty()
+        && (!multibindingDeclarations().isEmpty() || !subcomponentDeclarations().isEmpty())) {
       // Only multibinding declarations, so assume provision.
       return BindingType.PROVISION;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
new file mode 100644
index 000000000..bdf24222f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A declaration for a subcomponent that is included in a module via {@link
+ * dagger.Module#subcomponents()}.
+ */
+@AutoValue
+abstract class SubcomponentDeclaration extends BindingDeclaration {
+  /**
+   * Key for the {@link dagger.Subcomponent.Builder} or {@link
+   * dagger.producers.ProductionSubcomponent.Builder} of {@link #subcomponentType()}.
+   */
+  @Override
+  public abstract Key key();
+
+  /**
+   * The type element that defines the {@link dagger.Subcomponent} or {@link
+   * dagger.producers.ProductionSubcomponent} for this declaration.
+   */
+  abstract TypeElement subcomponentType();
+
+  abstract AnnotationMirror moduleAnnotation();
+
+  static class Factory {
+    private final Key.Factory keyFactory;
+
+    public Factory(Key.Factory keyFactory) {
+      this.keyFactory = keyFactory;
+    }
+
+    ImmutableSet<SubcomponentDeclaration> forModule(TypeElement module) {
+      ImmutableSet.Builder<SubcomponentDeclaration> declarations = ImmutableSet.builder();
+      AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
+      ExecutableElement subcomponentAttribute =
+          getAnnotationElementAndValue(moduleAnnotation, "subcomponents").getKey();
+      for (TypeElement subcomponent :
+          MoreTypes.asTypeElements(getModuleSubcomponents(moduleAnnotation))) {
+        declarations.add(
+            new AutoValue_SubcomponentDeclaration(
+                Optional.<Element>of(subcomponentAttribute),
+                Optional.of(module),
+                keyFactory.forSubcomponentBuilder(
+                    getSubcomponentBuilder(subcomponent).get().asType()),
+                subcomponent,
+                moduleAnnotation));
+      }
+      return declarations.build();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index af5007271..5c87ab4d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.difference;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -40,11 +41,10 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.DependencyRequest.Kind;
 import java.util.List;
 import java.util.Set;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ExecutableType;
@@ -56,11 +56,16 @@
 final class SubcomponentWriter extends AbstractComponentWriter {
 
   private final AbstractComponentWriter parent;
-  private final ExecutableElement subcomponentFactoryMethod;
 
-  public SubcomponentWriter(
+  /**
+   * The parent's factory method to create this subcomponent, or {@link Optional#absent()} if the
+   * subcomponent was added via {@link dagger.Module#subcomponents()}.
+   */
+  private final Optional<ComponentMethodDescriptor> subcomponentFactoryMethod;
+
+  SubcomponentWriter(
       AbstractComponentWriter parent,
-      ExecutableElement subcomponentFactoryMethod,
+      Optional<ComponentMethodDescriptor> subcomponentFactoryMethod,
       BindingGraph subgraph) {
     super(
         parent.types,
@@ -101,10 +106,15 @@ protected MemberSelect getMemberSelect(BindingKey key) {
   }
 
   private ExecutableType resolvedSubcomponentFactoryMethod() {
+    checkState(
+        subcomponentFactoryMethod.isPresent(),
+        "%s does not have a factory method for %s",
+        parent.componentDefinitionType(),
+        componentDefinitionType());
     return MoreTypes.asExecutable(
         types.asMemberOf(
             MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
-            subcomponentFactoryMethod));
+            subcomponentFactoryMethod.get().methodElement()));
   }
 
   @Override
@@ -147,20 +157,19 @@ protected void addBuilderClass(TypeSpec builder) {
 
   @Override
   protected void addFactoryMethods() {
+    if (!subcomponentFactoryMethod.isPresent()
+        || !subcomponentFactoryMethod.get().kind().isSubcomponentKind()) {
+      // subcomponent builder methods are implemented in
+      // AbstractComponentWriter.implementInterfaceMethods
+      return;
+    }
     MethodSpec.Builder componentMethod =
-        methodBuilder(subcomponentFactoryMethod.getSimpleName().toString())
+        methodBuilder(subcomponentFactoryMethod.get().methodElement().getSimpleName().toString())
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class);
-    if (graph.componentDescriptor().builderSpec().isPresent()) {
-      BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
-      componentMethod
-          .returns(ClassName.get(spec.builderDefinitionType()))
-          .addStatement("return new $T()", builderName.get());
-    } else {
-      ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
-      componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
-      writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
-    }
+    ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
+    componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
+    writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
     parent.component.addMethod(componentMethod.build());
   }
 
@@ -172,7 +181,8 @@ protected TypeSpec optionalFactoryClass(Optional<Kind> optionalValueKind) {
   private void writeSubcomponentWithoutBuilder(
       MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {
     ImmutableList.Builder<CodeBlock> subcomponentConstructorParameters = ImmutableList.builder();
-    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends VariableElement> params =
+        subcomponentFactoryMethod.get().methodElement().getParameters();
     List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
     for (int i = 0; i < params.size(); i++) {
       VariableElement moduleVariable = params.get(i);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 234b1f528..2637f4196 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -30,6 +30,7 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
@@ -189,6 +190,15 @@ static boolean isAnyAnnotationPresent(
     return false;
   }
 
+  @SafeVarargs
+  static boolean isAnyAnnotationPresent(
+      Element element,
+      Class<? extends Annotation> first,
+      Class<? extends Annotation>... otherAnnotations) {
+    return isAnnotationPresent(element, first)
+        || isAnyAnnotationPresent(element, ImmutableList.copyOf(otherAnnotations));
+  }
+
   /**
    * The elements in {@code elements} that are annotated with an annotation of type
    * {@code annotation}.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index be07f2366..98049a7f4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static java.util.Arrays.asList;
@@ -1027,7 +1028,101 @@ public void subcomponentOmitsInheritedBindings() {
         .generatesSources(expected);
   }
 
-  @Test public void testDefaultPackage() {
+  @Test
+  public void subcomponentNotGeneratedIfNotUsedInGraph() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  String notSubcomponent();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Child.class)",
+            "class ParentModule {",
+            "  @Provides static String notSubcomponent() { return new String(); }",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+
+    JavaFileObject generatedComponentWithoutSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String notSubcomponent() {",
+            "    return ParentModule_NotSubcomponentFactory.create().get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    assertThat(component, module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponentWithoutSubcomponent);
+  }
+
+  @Test
+  public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
         "import javax.inject.Inject;",
@@ -2389,6 +2484,102 @@ public void attemptToInjectWildcardGenerics() {
   }
 
   @Test
+  public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = Pruned.class)",
+            "class TestModule {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface Parent {}");
+
+    JavaFileObject prunedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Pruned",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Pruned {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Pruned build();",
+            "  }",
+            "",
+            "  Foo foo();",
+            "}");
+    JavaFileObject generated =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testModule(TestModule testModule) {",
+            "      Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    assertThat(foo, module, component, prunedSubcomponent)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generated);
+  }
+
   public void invalidComponentDependencies() {
     JavaFileObject testComponent =
         JavaFileObjects.forSourceLines(
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
new file mode 100644
index 000000000..9d52862d9
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+@RunWith(Parameterized.class)
+public final class ModuleValidatorTest {
+
+  @Parameterized.Parameters
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {{ModuleType.MODULE}, {ModuleType.PRODUCER_MODULE}});
+  }
+
+  private enum ModuleType {
+    MODULE(Module.class),
+    PRODUCER_MODULE(ProducerModule.class),
+    ;
+
+    private final Class<? extends Annotation> annotation;
+
+    ModuleType(Class<? extends Annotation> annotation) {
+      this.annotation = annotation;
+    }
+
+    String annotationWithSubcomponent(String subcomponent) {
+      return String.format("@%s(subcomponents = %s)", annotation.getSimpleName(), subcomponent);
+    }
+
+    String importStatement() {
+      return String.format("import %s;", annotation.getName());
+    }
+
+    String simpleName() {
+      return annotation.getSimpleName();
+    }
+  }
+
+  private final ModuleType moduleType;
+
+  public ModuleValidatorTest(ModuleType moduleType) {
+    this.moduleType = moduleType;
+  }
+
+  @Test
+  public void moduleSubcomponents_notASubcomponent() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NotASubcomponent.class"),
+            "class TestModule {}");
+    JavaFileObject notASubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
+    assertThat(module, notASubcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface Sub {",
+            "  @ProductionSubcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
+                + "with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
+                + "when used with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponentsAreTypes() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = int.class)",
+            "class TestModule {}");
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("int is not a valid subcomponent type")
+        .in(module)
+        .onLine(5);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index da8e013b8..9c011f882 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -876,12 +878,19 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "test.DaggerC",
             "package test;",
             "",
+            "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
+            "",
+            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
+            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
+            "",
             "  private DaggerC(Builder builder) {",
             "    assert builder != null;",
+            "    initialize(builder);",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -892,14 +901,33 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "    return builder().build();",
             "  }",
             "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.fooBuilderProvider = ",
+            "        new Factory<C.Foo.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Foo.Sub.Builder get() {",
+            "            return new Foo_SubBuilder();",
+            "          }",
+            "        };",
+            "",
+            "    this.barBuilderProvider = ",
+            "        new Factory<C.Bar.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Bar.Sub.Builder get() {",
+            "            return new Bar_SubBuilder();",
+            "          }",
+            "        };",
+            "  }",
+            "",
             "  @Override",
             "  public C.Foo.Sub.Builder fooBuilder() {",
-            "    return new Foo_SubBuilder();",
+            "    return fooBuilderProvider.get();",
             "  }",
             "",
             "  @Override",
             "  public C.Bar.Sub.Builder barBuilder() {",
-            "    return new Bar_SubBuilder();",
+            "    return barBuilderProvider.get();",
             "  }",
             "",
             "  public static final class Builder {",
@@ -944,4 +972,60 @@ public void subcomponentBuilderNamesShouldNotConflict() {
         .and()
         .generatesSources(componentGeneratedFile);
   }
+
+  @Test
+  public void duplicateBindingWithSubcomponentDeclaration() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Sub.class)",
+            "class TestModule {",
+            "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
+            "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
+            "    return builder.toString();",
+            "  }",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface C {",
+            "  Object dependsOnBuilder();",
+            "}");
+
+    assertThat(module, component, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Sub.Builder is bound multiple times:")
+        .and()
+        .withErrorContaining(
+            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
+        .and()
+        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
+  }
 }
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 0ebf9b941..ad88f0e81 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -16,6 +16,7 @@
 
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -34,4 +35,12 @@
    * to the object graph.
    */
   Class<?>[] includes() default {};
+
+  /**
+   * Any {@link Subcomponent}- or {@link dagger.producers.ProductionSubcomponent}-annotated classes
+   * which should be children of the component in which this module is installed. A subcomponent may
+   * be listed in more than one module in a component.
+   */
+  @Beta
+  Class<?>[] subcomponents() default {};
 }
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
index ae23c2ef4..b55be724c 100644
--- a/producers/src/main/java/dagger/producers/ProducerModule.java
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -41,4 +41,11 @@
    * inclusions recursively, are all contributed to the object graph.
    */
   Class<?>[] includes() default {};
+
+  /**
+   * Any {@link dagger.Subcomponent}- or {@link ProductionSubcomponent}-annotated classes which
+   * should be children of the component in which this module is installed. A subcomponent may be
+   * listed in more than one module in a component.
+   */
+  Class<?>[] subcomponents() default {};
 }
