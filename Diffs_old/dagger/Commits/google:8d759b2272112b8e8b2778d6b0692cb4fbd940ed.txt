diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index a580a1388..ea2135494 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -83,6 +83,13 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapFactory<K, V>, and change all framework fields to be
+    // of that type so we don't need an unsafe cast
+    public Builder<K, V> putAll(Provider<Map<K, V>> mapFactory) {
+      map.putAll(((MapFactory<K, V>) mapFactory).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProviderFactory}. */
     public MapFactory<K, V> build() {
       return new MapFactory<>(map);
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index 0a5c115e6..950ad6417 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -68,6 +68,13 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapProviderFactory<K, V>, and change all framework fields
+    // to be of that type so we don't need an unsafe cast
+    public Builder<K, V> putAll(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+      map.putAll(((MapProviderFactory<K, V>) mapProviderFactory).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProviderFactory}. */
     public MapProviderFactory<K, V> build() {
       return new MapProviderFactory<>(map);
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
index a3d9b3220..618b1bd9d 100644
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/BindingMethodImplementation.java
@@ -19,8 +19,10 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.RequestKinds.requestType;
 
+import com.google.common.base.Supplier;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
 import javax.lang.model.type.TypeMirror;
 
@@ -45,19 +47,30 @@
     this.types = checkNotNull(types);
   }
 
+  /** The method's body. */
+  final CodeBlock body() {
+    return implementation(bindingExpression.getDependencyExpression(componentName)::codeBlock);
+  }
+
+  /** The method's body if this method is a component method. */
+  final CodeBlock bodyForComponentMethod(
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
+    return implementation(
+        bindingExpression
+            .getDependencyExpressionForComponentMethod(componentMethod, component)::codeBlock);
+  }
+
   /**
    * Returns the method body, which contains zero or more statements (including semicolons).
    *
    * <p>If the implementation has a non-void return type, the body will also include the {@code
    * return} statement.
+   *
+   * @param simpleBindingExpression the expression to retrieve an instance of this binding without
+   *     the wrapping method.
    */
-  CodeBlock body() {
-    return CodeBlock.of("return $L;", simpleBindingExpression());
-  }
-
-  /** Returns the code for the binding expression. */
-  protected final CodeBlock simpleBindingExpression() {
-    return bindingExpression.getDependencyExpression(componentName).codeBlock();
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+    return CodeBlock.of("return $L;", simpleBindingExpression.get());
   }
 
   /** Returns the return type for the dependency request. */
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 391418364..f05d0d041 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -118,7 +118,8 @@ private ComponentBindingExpressions(
             this,
             graph,
             componentImplementation,
-            compilerOptions);
+            compilerOptions,
+            types);
   }
 
   /**
@@ -281,8 +282,7 @@ BindingExpression createBindingExpression(
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
    */
-  private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings) {
+  private BindingExpression frameworkInstanceBindingExpression(ResolvedBindings resolvedBindings) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
     Optional<MemberSelect> staticMethod =
         useStaticFactoryCreation(resolvedBindings.contributionBinding())
@@ -663,7 +663,8 @@ BindingExpression wrapInMethod(
                     methodImplementation,
                     componentImplementation,
                     componentMethod,
-                    matchingModifiableBindingMethod))
+                    matchingModifiableBindingMethod,
+                    types))
         .orElseGet(
             () ->
                 new PrivateMethodBindingExpression(
@@ -671,7 +672,8 @@ BindingExpression wrapInMethod(
                     request,
                     methodImplementation,
                     componentImplementation,
-                    matchingModifiableBindingMethod));
+                    matchingModifiableBindingMethod,
+                    types));
   }
 
   private BindingMethodImplementation methodImplementation(
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 03478613b..a52ee83b9 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -156,7 +157,9 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
   private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
-  private final SetMultimap<Key, DependencyRequest> contributionsByMultibinding =
+  // TODO(b/117833324): can this just be a Set instead of a SetMultimap? The values should be
+  // implicit
+  private final SetMultimap<BindingRequest, DependencyRequest> multibindingContributionsMade =
       HashMultimap.create();
   private ImmutableList<ParameterSpec> constructorParameters;
 
@@ -481,12 +484,13 @@ void claimMethodName(CharSequence name) {
    * to know whether a contribution has been made by a superclass implementation. This is only
    * relevant for ahead-of-time subcomponents.
    */
-  void registerImplementedMultibinding(ContributionBinding multibinding) {
+  void registerImplementedMultibinding(
+      ContributionBinding multibinding, BindingRequest bindingRequest) {
     checkArgument(multibinding.isSyntheticMultibinding());
     // We register a multibinding as implemented each time we request the multibinding expression,
     // so only modify the set of contributions once.
-    if (!contributionsByMultibinding.containsKey(multibinding.key())) {
-      contributionsByMultibinding.putAll(multibinding.key(), multibinding.dependencies());
+    if (!multibindingContributionsMade.containsKey(bindingRequest)) {
+      multibindingContributionsMade.putAll(bindingRequest, multibinding.dependencies());
     }
   }
 
@@ -494,9 +498,9 @@ void registerImplementedMultibinding(ContributionBinding multibinding) {
    * Returns the set of multibinding contributions associated with all superclass implementations of
    * a multibinding.
    */
-  ImmutableSet<DependencyRequest> superclassContributionsMade(Key key) {
+  ImmutableSet<DependencyRequest> superclassContributionsMade(BindingRequest bindingRequest) {
     return superclassImplementation
-        .map(s -> s.getAllMultibindingContributions(key))
+        .map(s -> s.getAllMultibindingContributions(bindingRequest))
         .orElse(ImmutableSet.of());
   }
 
@@ -504,11 +508,11 @@ void registerImplementedMultibinding(ContributionBinding multibinding) {
    * Returns the set of multibinding contributions associated with all implementations of a
    * multibinding.
    */
-  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(Key key) {
-    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
-    if (contributionsByMultibinding.containsKey(key)) {
-      contributionsBuilder.addAll(contributionsByMultibinding.get(key));
-    }
-    return contributionsBuilder.addAll(superclassContributionsMade(key)).build();
+  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(
+      BindingRequest bindingRequest) {
+    return ImmutableSet.copyOf(
+        Sets.union(
+            multibindingContributionsMade.get(bindingRequest),
+            superclassContributionsMade(bindingRequest)));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 5d3db3bf8..2067aa730 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -39,8 +39,9 @@
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
       ComponentMethodDescriptor componentMethod,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      DaggerTypes types) {
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.componentMethod = checkNotNull(componentMethod);
@@ -59,7 +60,7 @@ protected CodeBlock getComponentMethodImplementation(
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
     return componentMethod.equals(this.componentMethod) && component.equals(componentImplementation)
-        ? methodImplementation.body()
+        ? methodImplementation.bodyForComponentMethod(componentMethod, component)
         : super.getComponentMethodImplementation(componentMethod, component);
   }
 
diff --git a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
index ea8a40f60..f5b892725 100644
--- a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
@@ -50,7 +50,7 @@
   }
 
   @Override
-  CodeBlock body() {
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
     String fieldExpression = fieldName.get().equals("local") ? "this.local" : fieldName.get();
     return CodeBlock.builder()
         .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
@@ -58,7 +58,7 @@ CodeBlock body() {
         .beginControlFlow("synchronized (local)")
         .addStatement("local = $L", fieldExpression)
         .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
-        .addStatement("local = $L", simpleBindingExpression())
+        .addStatement("local = $L", simpleBindingExpression.get())
         .addStatement("$1L = $2T.reentrantCheck($1L, local)", fieldExpression, DoubleCheck.class)
         .endControlFlow()
         .endControlFlow()
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 4ea660726..0fff44b87 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -70,7 +70,10 @@ public CodeBlock creationExpression() {
     ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
     builder.add("builder($L)", frameworkDependencies.size());
 
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+    superContributions()
+        .ifPresent(superContributions -> builder.add(".putAll($L)", superContributions));
+
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesToImplement()) {
       ContributionBinding contributionBinding =
           graph.contributionBindings().get(frameworkDependency.key()).contributionBinding();
       builder.add(
@@ -80,6 +83,8 @@ public CodeBlock creationExpression() {
     }
     builder.add(".build()");
 
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
+
     return builder.build();
   }
 }
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 9ba6a66a7..461da98ec 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -21,6 +21,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
 
@@ -30,14 +31,17 @@
   private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
   private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
+  private final ProducerEntryPointView producerEntryPointView;
 
   protected MethodBindingExpression(
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      DaggerTypes types) {
     this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.matchingModifiableBindingMethod = checkNotNull(matchingModifiableBindingMethod);
+    this.producerEntryPointView = new ProducerEntryPointView(types);
   }
 
   @Override
@@ -65,6 +69,15 @@ final CodeBlock getModifiableBindingMethodImplementation(
     return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
   }
 
+  @Override
+  Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor componentMethod,
+      ComponentImplementation component) {
+    return producerEntryPointView
+        .getProducerEntryPointField(this, componentMethod, component)
+        .orElseGet(
+            () -> super.getDependencyExpressionForComponentMethod(componentMethod, component));
+  }
+
   /** Adds the method to the component (if necessary) the first time it's called. */
   protected abstract void addMethod();
 
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 27bfd2fd7..5b7338127 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -38,18 +38,21 @@
   private final BindingGraph graph;
   private final ComponentImplementation componentImplementation;
   private final CompilerOptions compilerOptions;
+  private final DaggerTypes types;
 
   ModifiableBindingExpressions(
       Optional<ModifiableBindingExpressions> parent,
       ComponentBindingExpressions bindingExpressions,
       BindingGraph graph,
       ComponentImplementation componentImplementation,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      DaggerTypes types) {
     this.parent = parent;
     this.bindingExpressions = bindingExpressions;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
     this.compilerOptions = compilerOptions;
+    this.types = types;
   }
 
   /**
@@ -258,8 +261,7 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
         return ModifiableBindingType.OPTIONAL;
       }
 
-      if (resolvedBindings.bindingType().equals(BindingType.PROVISION)
-          && binding.isSyntheticMultibinding()) {
+      if (binding.isSyntheticMultibinding()) {
         return ModifiableBindingType.MULTIBINDING;
       }
 
@@ -299,8 +301,45 @@ private boolean shouldModifyKnownBinding(ModifiableBindingMethod modifiableBindi
    * Returns true if the current binding graph can, and should, modify a binding by overriding a
    * modifiable binding method.
    */
+  // TODO(b/72748365): should this be called shouldModifyRequest() or shouldModifyBindingRequest()?
   private boolean shouldModifyBinding(
       ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    if (request.requestKind().isPresent()) {
+      switch (request.requestKind().get()) {
+        case FUTURE:
+          // Futures are always requested by a Producer.get() call, so if the binding is modifiable,
+          // the producer will be wrapped in a modifiable method and the future can refer to that
+          // method; even if the producer binding is modified, getModifiableProducer().get() will
+          // never need to be modified. Furthermore, because cancellation is treated by wrapped
+          // producers, and those producers point to the modifiable producer wrapper methods, we
+          // never need or want to change the access of these wrapped producers for entry
+          // methods
+          return false;
+
+        case LAZY:
+        case PROVIDER_OF_LAZY:
+          // Lazy and ProviderOfLazy are always created from a Provider, and therefore this request
+          // never needs to be modifiable. It will refer (via DoubleCheck.lazy() or
+          // ProviderOfLazy.create()) to the modifiable method and not the framework instance.
+          return false;
+
+        case MEMBERS_INJECTION:
+        case PRODUCED:
+          // MEMBERS_INJECTION has a completely different code path for binding expressions, and
+          // PRODUCED requests are only requestable in @Produces methods, which are hidden from
+          // generated components inside Producer factories
+          throw new AssertionError(request);
+
+        case INSTANCE:
+        case PROVIDER:
+        case PRODUCER:
+          // These may be modifiable, so run through the regular logic. They're spelled out
+          // explicitly so that ErrorProne will detect if a new enum value is created and missing
+          // from this list.
+          break;
+      }
+    }
+
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     switch (modifiableBindingType) {
       case GENERATED_INSTANCE:
@@ -322,7 +361,7 @@ private boolean shouldModifyBinding(
       case MULTIBINDING:
         // Only modify a multibinding if there are new contributions.
         return !componentImplementation
-            .superclassContributionsMade(request.key())
+            .superclassContributionsMade(request)
             .containsAll(resolvedBindings.contributionBinding().dependencies());
       case INJECTION:
         return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
@@ -385,7 +424,8 @@ private boolean resolvedInThisComponent(BindingRequest request) {
               methodImplementation,
               componentImplementation,
               matchingModifiableBindingMethod,
-              newModifiableBindingWillBeFinalized(modifiableBindingType, request)));
+              newModifiableBindingWillBeFinalized(modifiableBindingType, request),
+              types));
     }
     return Optional.empty();
   }
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index 9ec01875b..54dd3d7ad 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -47,8 +47,9 @@
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      boolean bindingFinalized) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
+      boolean bindingFinalized,
+      DaggerTypes types) {
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
index acbf70be0..34a19ab02 100644
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -43,7 +43,7 @@
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression expression = buildDependencyExpression(requestingClass);
-    componentImplementation.registerImplementedMultibinding(binding);
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
     return expression;
   }
 
@@ -62,8 +62,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
    */
   protected SetView<DependencyRequest> getNewContributions(
       ImmutableSet<DependencyRequest> dependencies) {
-    return Sets.difference(
-        dependencies, componentImplementation.superclassContributionsMade(binding.key()));
+    return Sets.difference(dependencies, superclassContributions());
   }
 
   /**
@@ -74,16 +73,21 @@ Expression getDependencyExpression(ClassName requestingClass) {
   protected Optional<CodeBlock> superMethodCall() {
     if (componentImplementation.superclassImplementation().isPresent()) {
       Optional<ModifiableBindingMethod> method =
-          componentImplementation.getModifiableBindingMethod(
-              bindingRequest(binding.key(), RequestKind.INSTANCE));
+          componentImplementation.getModifiableBindingMethod(bindingRequest());
       if (method.isPresent()) {
-        ImmutableSet<DependencyRequest> superclassContributions =
-            componentImplementation.superclassContributionsMade(binding.key());
-        if (!superclassContributions.isEmpty()) {
+        if (!superclassContributions().isEmpty()) {
           return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
         }
       }
     }
     return Optional.empty();
   }
+
+  private BindingRequest bindingRequest() {
+    return BindingRequest.bindingRequest(binding.key(), RequestKind.INSTANCE);
+  }
+
+  private ImmutableSet<DependencyRequest> superclassContributions() {
+    return componentImplementation.superclassContributionsMade(bindingRequest());
+  }
 }
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
index d80e60516..e01d8d17a 100644
--- a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -17,9 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.Key;
+import java.util.Optional;
 
 /** An abstract factory creation expression for multibindings. */
 abstract class MultibindingFactoryCreationExpression
@@ -50,6 +55,25 @@ protected final CodeBlock multibindingDependencyExpression(
         : expression;
   }
 
+  protected final ImmutableSet<FrameworkDependency> frameworkDependenciesToImplement() {
+    ImmutableSet<Key> alreadyImplementedKeys =
+        componentImplementation.superclassContributionsMade(bindingRequest()).stream()
+            .map(dependency -> dependency.key())
+            .collect(toImmutableSet());
+    return binding.frameworkDependencies().stream()
+        .filter(frameworkDependency -> !alreadyImplementedKeys.contains(frameworkDependency.key()))
+        .collect(toImmutableSet());
+  }
+
+  protected Optional<CodeBlock> superContributions() {
+    if (frameworkDependenciesToImplement().size() == binding.frameworkDependencies().size()) {
+      return Optional.empty();
+    }
+    ModifiableBindingMethod superMethod =
+        componentImplementation.getModifiableBindingMethod(bindingRequest()).get();
+    return Optional.of(CodeBlock.of("super.$N()", superMethod.methodSpec().name));
+  }
+
   /** The binding request for this framework instance. */
   protected final BindingRequest bindingRequest() {
     return BindingRequest.bindingRequest(
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 29cba7ee6..4fb43ec8f 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -43,8 +43,9 @@
       BindingRequest request,
       BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
-    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      DaggerTypes types) {
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod, types);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
index 4f2194f9c..5c7dd0165 100644
--- a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -26,7 +26,6 @@
 final class ProducerNodeInstanceBindingExpression extends FrameworkInstanceBindingExpression {
   /** The component defining this binding. */
   private final ComponentImplementation componentImplementation;
-
   private final Key key;
   private final ProducerEntryPointView producerEntryPointView;
 
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 7c7d01ff7..5eb3d4005 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -21,10 +21,12 @@
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.producers.Produced;
+import java.util.Optional;
 
 /** A factory creation expression for a multibound set. */
 final class SetFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
+  private final ComponentImplementation componentImplementation;
   private final BindingGraph graph;
   private final ContributionBinding binding;
 
@@ -35,6 +37,7 @@
       BindingGraph graph) {
     super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.graph = checkNotNull(graph);
   }
 
@@ -49,32 +52,49 @@ public CodeBlock creationExpression() {
               ? setType.unwrappedElementType(Produced.class)
               : setType.elementType());
     }
+
     int individualProviders = 0;
     int setProviders = 0;
     CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+    String methodNameSuffix =
+        binding.bindingType().equals(BindingType.PROVISION) ? "Provider" : "Producer";
+
+    Optional<CodeBlock> superContributions = superContributions();
+    if (superContributions.isPresent()) {
+      // TODO(b/117833324): consider decomposing the Provider<Set<Provider>> and adding the
+      // individual contributions separately from the collection contributions
+      builderMethodCalls.add(".addCollection$N($L)", methodNameSuffix, superContributions.get());
+      setProviders++;
+    }
+
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesToImplement()) {
       ContributionType contributionType =
           graph.contributionBindings().get(frameworkDependency.key()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      String methodNamePrefix;
       switch (contributionType) {
         case SET:
           individualProviders++;
-          methodName = "add" + methodNameSuffix;
+          methodNamePrefix = "add";
           break;
         case SET_VALUES:
           setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
+          methodNamePrefix = "addCollection";
           break;
         default:
           throw new AssertionError(frameworkDependency + " is not a set multibinding");
       }
 
       builderMethodCalls.add(
-          ".$L($L)", methodName, multibindingDependencyExpression(frameworkDependency));
+          ".$N$N($L)",
+          methodNamePrefix,
+          methodNameSuffix,
+          multibindingDependencyExpression(frameworkDependency));
     }
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
+
+    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
+
     return builder.add(".build()").build();
   }
 }
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
index ca8a2e2a3..289aa2ce8 100644
--- a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
@@ -55,7 +55,7 @@
   }
 
   @Override
-  CodeBlock body() {
+  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
     String fieldExpression = field.get().name.equals("local") ? "this.local" : field.get().name;
 
     CodeBlock.Builder builder = CodeBlock.builder()
@@ -68,7 +68,7 @@ CodeBlock body() {
     }
 
     return builder
-        .addStatement("local = $L", simpleBindingExpression())
+        .addStatement("local = $L", simpleBindingExpression.get())
         .addStatement("$N = ($T) local", fieldExpression, returnType())
         .endControlFlow()
         .addStatement("return ($T) local", returnType())
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 9aa3937c8..2eda7f3f7 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -39,10 +39,10 @@
  * methods.
  */
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Map<K, Producer<V>> mapOfProducers;
+  private final Map<K, Producer<V>> contributingMap;
 
-  private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
-    this.mapOfProducers = mapOfProducers;
+  private MapOfProducedProducer(Map<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
   }
 
   @Override
@@ -50,7 +50,7 @@ private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
     return Futures.transform(
         Futures.allAsList(
             Iterables.transform(
-                mapOfProducers.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                contributingMap.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
         new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
           public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
@@ -122,5 +122,13 @@ private Builder(int size) {
       mapBuilder.put(key, producerFromProvider(providerOfValue));
       return this;
     }
+
+    // TODO(b/118630627): make this accept MapOfProducedProducer<K, V>, and change all framework
+    // fields to be of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, Produced<V>>> mapOfProducedProducer) {
+      mapBuilder.putAll(((MapOfProducedProducer<K, V>) mapOfProducedProducer).contributingMap);
+      return this;
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index f7bf195bf..ce6a7949f 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -75,6 +75,14 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapOfProducerProducer<K, V>, and change all framework
+    // fields to be of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, Producer<V>>> mapProducerProducer) {
+      mapBuilder.putAll(((MapOfProducerProducer<K, V>) mapProducerProducer).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapOfProducerProducer}. */
     public MapOfProducerProducer<K, V> build() {
       return new MapOfProducerProducer<>(mapBuilder.build());
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index cf0fb416c..9cc000b40 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -37,10 +37,10 @@
  * {@code Map<K, V>} which is populated by calls to the delegate {@link Producer#get} methods.
  */
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final ImmutableMap<K, Producer<V>> mapOfProducers;
+  private final ImmutableMap<K, Producer<V>> contributingMap;
 
-  private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
-    this.mapOfProducers = mapOfProducers;
+  private MapProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
   }
 
   /** Returns a new {@link Builder}. */
@@ -72,6 +72,14 @@ private Builder(int size) {
       return this;
     }
 
+    // TODO(b/118630627): make this accept MapProducer<K, V>, and change all framework fields to be
+    // of that type so we don't need an unsafe cast
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    public Builder<K, V> putAll(Producer<Map<K, V>> mapProducer) {
+      mapBuilder.putAll(((MapProducer<K, V>) mapProducer).contributingMap);
+      return this;
+    }
+
     /** Returns a new {@link MapProducer}. */
     public MapProducer<K, V> build() {
       return new MapProducer<>(mapBuilder.build());
@@ -81,7 +89,7 @@ private Builder(int size) {
   @Override
   protected ListenableFuture<Map<K, V>> compute() {
     final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
-    for (final Entry<K, Producer<V>> entry : mapOfProducers.entrySet()) {
+    for (final Entry<K, Producer<V>> entry : contributingMap.entrySet()) {
       listOfEntries.add(
           Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
             @Override
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index f2582c473..dcf66263c 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -27,6 +27,7 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -2089,6 +2090,298 @@ public void setMultibindings_newSubclass() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> instance() {",
+            "    return ImmutableSet.<Multibound>of(",
+            "        LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Set<Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Set<Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
+            "",
+            "    protected LeafImpl() { ",
+            "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.setOfMultiboundProvider =",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    public Provider<Set<Multibound>> getSetOfMultiboundProvider() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getSetOfMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
+            "",
+            "  protected DaggerLeaf() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.setOfInEachSubcomponentProvider =",
+            "        SetFactory.<InEachSubcomponent>builder(2, 0)",
+            "            .addProvider(LeafModule_ProvideInLeafFactory.create())",
+            "            .addProvider(LeafModule_ProvideAnotherInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "    return setOfInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
+            "",
+            "    protected LeafImpl() {",
+            "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "    this.setOfInEachSubcomponentProvider =",
+            "        SetFactory.<InEachSubcomponent>builder(0, 2)",
+            "            .addCollectionProvider(super.contributionsInEachSubcomponent())",
+            "            .addCollectionProvider(AncestorModule_ProvideInAncestorFactory.create())",
+            "            .build();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "      return setOfInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
   @Test
   public void mapMultibindings_contributionsInLeaf() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -2369,9 +2662,9 @@ public void mapMultibindings_contributionsInLeafAndAncestor() {
   }
 
   @Test
-  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
+  public void mapMultibindings_contributionsInLeafAndAncestor_frameworkInstance() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
             "test.Leaf",
@@ -2379,10 +2672,11 @@ public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
             "",
             "import dagger.Subcomponent;",
             "import java.util.Map;",
+            "import javax.inject.Provider;",
             "",
             "@Subcomponent(modules = LeafModule.class)",
             "interface Leaf {",
-            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "  Provider<Map<String, InEachSubcomponent>> contributionsInEachSubcomponent();",
             "}"),
         JavaFileObjects.forSourceLines(
             "test.LeafModule",
@@ -2399,8 +2693,8 @@ public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
             "  @Provides",
             "  @IntoMap",
             "  @StringKey(\"leafmodule\")",
-            "  static InLeafAndGrandAncestor provideInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
             "  }",
             "}"));
     JavaFileObject generatedLeaf =
@@ -2408,17 +2702,168 @@ public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
             "test.DaggerLeaf",
             "package test;",
             "",
-            "import com.google.common.collect.ImmutableMap;",
+            "import dagger.internal.MapFactory;",
             "import java.util.Map;",
             IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
+            "  private Provider<Map<String, InEachSubcomponent>> ",
+            "    mapOfStringAndInEachSubcomponentProvider;",
             "",
-            "  @Override",
-            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
+            "  protected DaggerLeaf() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.mapOfStringAndInEachSubcomponentProvider =",
+            "        MapFactory.<String, InEachSubcomponent>builder(1)",
+            "            .put(\"leafmodule\", LeafModule_ProvideInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Map<String, InEachSubcomponent>> ",
+            "      contributionsInEachSubcomponent() {",
+            "    return mapOfStringAndInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<String, InEachSubcomponent>> ",
+            "      mapOfStringAndInEachSubcomponentProvider;",
+            "",
+            "    protected LeafImpl() { ",
+            "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.mapOfStringAndInEachSubcomponentProvider =",
+            "          MapFactory.<String, InEachSubcomponent>builder(2)",
+            "              .putAll(super.contributionsInEachSubcomponent())",
+            "              .put(\"ancestormodule\",",
+            "                  AncestorModule_ProvideInAncestorFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Map<String, InEachSubcomponent>> ",
+            "        contributionsInEachSubcomponent() {",
+            "      return mapOfStringAndInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
             "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
             "  }",
             "}");
@@ -2430,69 +2875,695 @@ public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Ancestor",
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandancestormodule\")",
+            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public Map<String, InLeafAndGrandAncestor>",
+            "          contributionsInLeafAndGrandAncestor() {",
+            "        return",
+            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
+            "                .put(\"grandancestormodule\",",
+            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "                        .proxyProvideInGrandAncestor())",
+            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
+            "                .build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return Collections.<String, InEachSubcomponent>singletonMap(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<Integer, Multibound> instance() {",
+            "    return ImmutableMap.<Integer, Multibound>of(",
+            "        111, LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Map<Integer, Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Map<Integer, Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
+            "",
+            "    protected LeafImpl() { ",
+            "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.mapOfIntegerAndMultiboundProvider =",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    public Provider<Map<Integer, Multibound>> ",
+            "        getMapOfIntegerAndMultiboundProvider() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getMapOfIntegerAndMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> set() {",
+            "    return ImmutableSet.<Multibound>of();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Set<Multibound> set() {",
+            "      return ImmutableSet.<Multibound>of(",
+            "          AncestorModule_FromAncestorFactory.proxyFromAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<Multibound>> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Provider<Set<Multibound>> set() {",
+            "    return SetFactory.<Multibound>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
+            "",
+            "    protected LeafImpl() {",
+            "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.setOfMultiboundProvider =",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(AncestorModule_FromAncestorFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<Multibound>> set() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_map() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
             "package test;",
             "",
             "import dagger.Subcomponent;",
+            "import java.util.Map;",
             "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> map();",
             "}"));
-    JavaFileObject generatedAncestor =
+    JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
+            "test.DaggerLeaf",
             "package test;",
             "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
             "",
-            "  public abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() { super(); }",
+            "  @Override",
+            "  public Map<Integer, Multibound> map() {",
+            "    return ImmutableMap.<Integer, Multibound>of();",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
+            "test.Ancestor",
             "package test;",
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
             "}"),
         JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
+            "test.AncestorModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
             "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
             "",
             "@Module",
-            "class GrandAncestorModule {",
+            "class AncestorModule {",
             "  @Provides",
             "  @IntoMap",
-            "  @StringKey(\"grandancestormodule\")",
-            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
-            "    return new InLeafAndGrandAncestor();",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
             "  }",
             "}"));
-    JavaFileObject generatedGrandAncestor =
+    JavaFileObject generatedAncestor =
         JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
+            "test.DaggerAncestor",
             "package test;",
             "",
             "import com.google.common.collect.ImmutableMap;",
@@ -2500,91 +3571,76 @@ public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  public abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() { super(); }",
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
             "",
-            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() { super(); }",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
             "",
-            "      @Override",
-            "      public Map<String, InLeafAndGrandAncestor>",
-            "          contributionsInLeafAndGrandAncestor() {",
-            "        return",
-            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
-            "                .put(\"grandancestormodule\",",
-            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
-            "                        .proxyProvideInGrandAncestor())",
-            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
-            "                .build();",
-            "      }",
+            "    @Override",
+            "    public Map<Integer, Multibound> map() {",
+            "      return ImmutableMap.<Integer, Multibound>of(",
+            "          111, AncestorModule_FromAncestorFactory.proxyFromAncestor());",
             "    }",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
   }
 
   @Test
-  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
+  public void emptyMultibinds_map_frameworkInstance() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    createAncillaryClasses(filesToCompile, "Multibound");
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
-            "test.Leaf",
+            "test.LeafModule",
             "package test;",
             "",
-            "import dagger.Subcomponent;",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
             "import java.util.Map;",
             "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
             "}"),
         JavaFileObjects.forSourceLines(
-            "test.LeafModule",
+            "test.Leaf",
             "package test;",
             "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
+            "import dagger.Subcomponent;",
             "import java.util.Map;",
+            "import javax.inject.Provider;",
             "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Map<Integer, Multibound>> map();",
             "}"));
     JavaFileObject generatedLeaf =
         JavaFileObjects.forSourceLines(
             "test.DaggerLeaf",
             "package test;",
             "",
-            "import java.util.Collections;",
-            "import java.util.Map",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
             IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
             "",
             "  @Override",
-            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return Collections.<String, InEachSubcomponent>singletonMap(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  public Provider<Map<Integer, Multibound>> map() {",
+            "    return MapFactory.<Integer, Multibound>emptyMapProvider();",
             "  }",
             "}");
-    Compilation compilation = compileWithoutGuava(filesToCompile.build());
+    Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerLeaf")
@@ -2607,17 +3663,16 @@ public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
             "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
             "",
             "@Module",
             "class AncestorModule {",
             "  @Provides",
             "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
             "  }",
             "}"));
     JavaFileObject generatedAncestor =
@@ -2625,30 +3680,38 @@ public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
             "test.DaggerAncestor",
             "package test;",
             "",
-            "import dagger.internal.MapBuilder;",
+            "import dagger.internal.MapFactory;",
             "import java.util.Map;",
             IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
             "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
+            "",
             "    protected LeafImpl() {",
             "      super();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.mapOfIntegerAndMultiboundProvider =",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, AncestorModule_FromAncestorFactory.create())",
+            "              .build();",
             "    }",
             "",
             "    @Override",
-            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
-            "          .put(\"ancestormodule\",",
-            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
-            "          .putAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
+            "    public Provider<Map<Integer, Multibound>> map() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
             "    }",
             "  }",
             "}");
-    compilation = compileWithoutGuava(filesToCompile.build());
+    compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
@@ -3229,9 +4292,10 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    this.setOfResponseProducer =",
             // TODO(b/72748365): This initialization should be encapsulated in a method to be
             // modified.
-            "        SetProducer.<Response>builder(1, 0).addProducer(responseProducer).build();",
+            "        SetProducer.<Response>builder(1, 0)",
+            "            .addProducer(responseProducer).build();",
             "    this.responsesEntryPoint =",
-            "        Producers.entryPointViewOf(setOfResponseProducer, this);",
+            "        Producers.entryPointViewOf(getSetOfResponseProducer(), this);",
             "  }",
             "",
             "  @Override",
@@ -3246,9 +4310,13 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "",
             "  public abstract Producer<ResponseDependency> getResponseDependencyProducer();",
             "",
+            "  public Producer<Set<Response>> getSetOfResponseProducer() {",
+            "    return setOfResponseProducer;",
+            "  }",
+            "",
             "  @Override",
             "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(setOfResponseProducer, mayInterruptIfRunning);",
+            "    Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
             "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
             "  }",
             "",
@@ -3288,7 +4356,11 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "import dagger.producers.ProductionComponent;",
             "",
             "@ProductionComponent(",
-            "    modules = {ResponseDependencyProducerModule.class, ExecutorModule.class})",
+            "  modules = {",
+            "      ExecutorModule.class,",
+            "      ResponseDependencyProducerModule.class,",
+            "      RootMultibindingModule.class,",
+            "  })",
             "interface Root {",
             "  Leaf.Builder leaf();",
             "}"),
@@ -3307,6 +4379,22 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  static ListenableFuture<ResponseDependency> responseDependency() {",
             "    return Futures.immediateFuture(new ResponseDependency());",
             "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.RootMultibindingModule",
+            "package test;",
+            "",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class RootMultibindingModule {",
+            "  @Produces",
+            "  @IntoSet",
+            "  static Response response() {",
+            "    return new Response();",
+            "  }",
             "}"));
     JavaFileObject generatedRoot =
         JavaFileObjects.forSourceLines(
@@ -3319,7 +4407,9 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.CancellationListener;",
             "import dagger.producers.internal.Producers;",
+            "import dagger.producers.internal.SetProducer;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.Set;",
             "import java.util.concurrent.Executor;",
             IMPORT_GENERATED_ANNOTATION,
             "import javax.inject.Provider;",
@@ -3337,6 +4427,8 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  private ResponseDependencyProducerModule_ResponseDependencyFactory",
             "      responseDependencyProducer;",
             "",
+            "  private RootMultibindingModule_ResponseFactory responseProducer;",
+            "",
             "  private DaggerRoot(Builder builder) {",
             "    initialize(builder);",
             "  }",
@@ -3364,6 +4456,9 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    this.responseDependencyProducer =",
             "        ResponseDependencyProducerModule_ResponseDependencyFactory.create(",
             "            productionImplementationExecutorProvider, monitorProvider);",
+            "    this.responseProducer =",
+            "        RootMultibindingModule_ResponseFactory.create(",
+            "            productionImplementationExecutorProvider, monitorProvider);",
             "  }",
             "",
             "  @Override",
@@ -3373,6 +4468,7 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "",
             "  @Override",
             "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
             "    Producers.cancel(responseDependencyProducer, mayInterruptIfRunning);",
             "  }",
             "",
@@ -3388,6 +4484,12 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "      return new DaggerRoot(this);",
             "    }",
             "",
+            // TODO(b/72748365): define a builder so these methods can be omitted
+            "    public Builder executorModule(ExecutorModule executorModule) {",
+            "      this.executorModule = Preconditions.checkNotNull(executorModule);",
+            "      return this;",
+            "    }",
+            "",
             "    @Deprecated",
             "    public Builder responseDependencyProducerModule(",
             "        ResponseDependencyProducerModule responseDependencyProducerModule) {",
@@ -3395,8 +4497,10 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "      return this;",
             "    }",
             "",
-            "    public Builder executorModule(ExecutorModule executorModule) {",
-            "      this.executorModule = Preconditions.checkNotNull(executorModule);",
+            "    @Deprecated",
+            "    public Builder rootMultibindingModule(",
+            "        RootMultibindingModule rootMultibindingModule) {",
+            "      Preconditions.checkNotNull(rootMultibindingModule);",
             "      return this;",
             "    }",
             "  }",
@@ -3409,8 +4513,20 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  }",
             "",
             "  public final class LeafImpl extends DaggerLeaf implements CancellationListener {",
+            "    private Producer<Set<Response>> setOfResponseProducer;",
+            "",
             "    private LeafImpl(LeafBuilder builder) {",
             "      super(builder);",
+            "      initialize(builder);",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize(final LeafBuilder builder) {",
+            "      this.setOfResponseProducer =",
+            "          SetProducer.<Response>builder(1, 1)",
+            "              .addCollectionProducer(super.getSetOfResponseProducer())",
+            "              .addProducer(DaggerRoot.this.responseProducer)",
+            "              .build());",
             "    }",
             "",
             "    @Override",
@@ -3428,6 +4544,19 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    public Producer<ResponseDependency> getResponseDependencyProducer() {",
             "      return DaggerRoot.this.responseDependencyProducer;",
             "    }",
+            "",
+            "    @Override",
+            "    public Producer<Set<Response>> getSetOfResponseProducer() {",
+            "      return setOfResponseProducer;",
+            "    }",
+            "",
+            "    @Override",
+            "    public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+            "      super.onProducerFutureCancelled(mayInterruptIfRunning);",
+            // TODO(b/72748365): This call should ideally be omitted since the same key has already
+            // been canceled in the super invocation
+            "      Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
+            "    }",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
@@ -3437,6 +4566,108 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
         .hasSourceEquivalentTo(generatedRoot);
   }
 
+  @Ignore // TODO(b/72748365): see if we can get this to work.
+  @Test
+  public void lazyOfModifiableBinding() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Lazy<MissingInLeaf> lazy();",
+            "  Provider<Lazy<MissingInLeaf>> providerOfLazy();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.ProviderOfLazy;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  public abstract Provider<MissingInLeaf> missingInLeafProvider();",
+            "",
+            "  @Override",
+            "  public final Lazy<MissingInLeaf> lazy() {",
+            "    return DoubleCheck.lazy(missingInLeafProvider());",
+            "  }",
+            "",
+            "  @Override",
+            "  public final Provider<Lazy<MissingInLeaf>> providerOfLazy() {",
+            "    return ProviderOfLazy.create(missingInLeafProvider());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public abstract Provider<MissingInLeaf> missingInLeafProvider() {",
+            "      return AncestorModule_SatisfiedInAncestorFactory.create();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 8bb8e0395..4f0154d91 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -925,9 +925,9 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "}")
                 .addLinesIn(
                     FAST_INIT_MODE,
-                    "  private volatile Provider<Object> bindStringProvider;",
-                    "  private volatile Object object = new MemoizedSentinel();",
                     "  private volatile String string;",
+                    "  private volatile Object object = new MemoizedSentinel();",
+                    "  private volatile Provider<Object> bindStringProvider;",
                     "",
                     "  private String getString() {",
                     "    Object local = string;",
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index 26df21a09..9c9838bfd 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -187,8 +187,8 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerSimpleComponent implements SimpleComponent {",
-                "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "  private volatile Object scopedType = new MemoizedSentinel();",
+                "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "",
                 "  private DaggerSimpleComponent(Builder builder) {}",
                 "",
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 546aa0517..2bc70bc9b 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -130,10 +130,10 @@ public void mapBindingsWithEnumKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<PathEnum, Provider<Handler>>>",
-                "      mapOfPathEnumAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<PathEnum, Provider<Handler>>>",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
@@ -536,10 +536,10 @@ public void mapBindingsWithStringKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<String, Provider<Handler>>>",
-                "      mapOfStringAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<String, Provider<Handler>>>",
+                "      mapOfStringAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
@@ -735,10 +735,10 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<Map<WrappedClassKey, Provider<Handler>>>",
-                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
                 "  private volatile Provider<Handler> provideAdminHandlerProvider;",
                 "  private volatile Provider<Handler> provideLoginHandlerProvider;",
+                "  private volatile Provider<Map<WrappedClassKey, Provider<Handler>>>",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 0da590d58..f0e9b4f94 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -238,11 +238,11 @@ public void simpleComponent() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
                 "    implements TestClass.SimpleComponent, CancellationListener {",
-                "  private volatile Provider<Executor> productionImplementationExecutorProvider;",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
-                "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
+                "  private volatile Provider<Executor> productionImplementationExecutorProvider;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
+                "  private volatile Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
                 "  private Producer<TestClass.A> aEntryPoint;",
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index dd213798a..cfd4706ee 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -335,8 +335,8 @@ public void scopedBinds() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  private volatile Provider<CharSequence> cProvider;",
                 "  private volatile Object charSequence = new MemoizedSentinel();",
+                "  private volatile Provider<CharSequence> cProvider;",
                 "",
                 "  private CharSequence getCharSequence() {",
                 "    Object local = charSequence;",
