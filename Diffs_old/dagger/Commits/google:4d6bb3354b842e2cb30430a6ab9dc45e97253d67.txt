diff --git a/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java
new file mode 100644
index 000000000..f5a72095c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Ascii;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import java.lang.annotation.Annotation;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+import static com.google.auto.common.SuperficialValidation.validateElement;
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.ElementKind.PACKAGE;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+/**
+ * An abstract {@link Processor} implementation that ensures that top-level {@link Element}
+ * instances are well-formed before attempting to perform processing on any of their children. In
+ * the event that they are not, the element will be enqueued for processing in a subsequent round.
+ * This ensures that processors will avoid many common pitfalls like {@link ErrorType} instances,
+ * {@link ClassCastException}s and badly coerced types.
+ *
+ * <p>The primary disadvantage to this processor is that any {@link Element} that forms a circular
+ * dependency with a type generated by a subclass of this processor will never compile because the
+ * given {@link Element} will never be fully complete. All such compilations will fail with an error
+ * message on the offending type that describes the issue.
+ *
+ * <p>Subclasses should put their processing logic in {@link ProcessingStep} implementations. The
+ * steps are passed to the processor by returning them in the {@link #initSteps()} method - access
+ * the {@link ProcessingEnvironment} using {@link #processingEnv}. Finally, any logic that needs to
+ * happen once per round can be specified by overriding {@link #postProcess()}.
+ *
+ * @author Gregory Kick
+ */
+abstract class BasicAnnotationProcessor extends AbstractProcessor {
+  /*
+   * It's unfortunate that we have to track types and packages separately, but since there are two
+   * different methods to look them up in Elements, we end up with a lot of parallel logic. :(
+   * Packages declared (and annotated) in package-info.java are tracked as deferred packages while
+   * all other elements are tracked via the top-level type.
+   */
+  private final Set<String> deferredPackageNames = Sets.newLinkedHashSet();
+  private final Set<String> deferredTypeNames = Sets.newLinkedHashSet();
+  private final String processorName = getClass().getCanonicalName();
+
+  private Elements elements;
+  private Messager messager;
+  private ImmutableList<? extends ProcessingStep> steps;
+
+  @Override
+  public final synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+    this.elements = processingEnv.getElementUtils();
+    this.messager = processingEnv.getMessager();
+    this.steps = ImmutableList.copyOf(initSteps());
+  }
+
+  /**
+   * The mechanism by which {@linkplain ProcessingStep processing steps} are associated with the
+   * processor. #processinEnv is guaranteed to be set when this method is invoked.
+   */
+  protected abstract Iterable<? extends ProcessingStep> initSteps();
+
+  /** An optional hook for logic to be executed at the end of each round. */
+  protected void postProcess() {}
+
+  private ImmutableSet<? extends Class<? extends Annotation>> getSupportedAnnotationClasses() {
+    checkState(steps != null);
+    ImmutableSet.Builder<Class<? extends Annotation>> builder = ImmutableSet.builder();
+    for (ProcessingStep step : steps) {
+      builder.addAll(step.annotations());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public final ImmutableSet<String> getSupportedAnnotationTypes() {
+    ImmutableSet.Builder<String> builder = ImmutableSet.builder();
+    for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
+      builder.add(annotationClass.getCanonicalName());
+    }
+    return builder.build();
+  }
+
+  private static final String INVALID_ELEMENT_MESSAGE_FORMAT = "%s was unable to process %s"
+      + " because all of its dependencies could not be resolved. Check for compilation errors or a"
+      + " circular dependency with generated code.";
+
+  @Override
+  public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    checkState(elements != null);
+    checkState(messager != null);
+    checkState(steps != null);
+
+    // First, collect all of the deferred elements and clear out the state from the previous rounds
+    ImmutableMap.Builder<String, Optional<? extends Element>> deferredElementsBuilder =
+        ImmutableMap.builder();
+    for (String deferredTypeName : deferredTypeNames) {
+      deferredElementsBuilder.put(deferredTypeName,
+          Optional.fromNullable(elements.getTypeElement(deferredTypeName)));
+    }
+    for (String deferredPackageName : deferredPackageNames) {
+      deferredElementsBuilder.put(deferredPackageName,
+          Optional.fromNullable(elements.getPackageElement(deferredPackageName)));
+    }
+    ImmutableMap<String, Optional<? extends Element>> deferredElements =
+        deferredElementsBuilder.build();
+
+    deferredTypeNames.clear();
+    deferredPackageNames.clear();
+
+    // If this is the last round, report all of the missing elements
+    if (roundEnv.processingOver()) {
+      reportMissingElements(deferredElements);
+      return false;
+    }
+
+    // For all of the elements that were deferred, find the annotated elements therein.  If we don't
+    // find any, something is messed up and we just defer them again.
+    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>
+        deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();
+    for (Entry<String, Optional<? extends Element>> deferredTypeElementEntry :
+        deferredElements.entrySet()) {
+      Optional<? extends Element> deferredElement = deferredTypeElementEntry.getValue();
+      if (deferredElement.isPresent()) {
+        findAnnotatedElements(deferredElement.get(), getSupportedAnnotationClasses(),
+            deferredElementsByAnnotationBuilder);
+      } else {
+        deferredTypeNames.add(deferredTypeElementEntry.getKey());
+      }
+    }
+
+    ImmutableSetMultimap<Class<? extends Annotation>, Element> deferredElementsByAnnotation =
+        deferredElementsByAnnotationBuilder.build();
+
+    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> elementsByAnnotationBuilder =
+        ImmutableSetMultimap.builder();
+
+    Set<String> validPackageNames = Sets.newLinkedHashSet();
+    Set<String> validTypeNames = Sets.newLinkedHashSet();
+
+    // Look at the elements we've found and the new elements from this round and validate them.
+    for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
+      for (Element annotatedElement : Sets.union(
+          roundEnv.getElementsAnnotatedWith(annotationClass),
+          deferredElementsByAnnotation.get(annotationClass))) {
+        if (annotatedElement.getKind().equals(PACKAGE)) {
+          PackageElement annotatedPackageElement = (PackageElement) annotatedElement;
+          String annotatedPackageName = annotatedPackageElement.getQualifiedName().toString();
+          boolean validPackage = validPackageNames.contains(annotatedPackageName)
+              || (!deferredPackageNames.contains(annotatedPackageName)
+                  && validateElement(annotatedPackageElement));
+          if (validPackage) {
+            elementsByAnnotationBuilder.put(annotationClass, annotatedPackageElement);
+            validPackageNames.add(annotatedPackageName);
+          } else {
+            deferredPackageNames.add(annotatedPackageName);
+          }
+        } else {
+          TypeElement enclosingType = getEnclosingType(annotatedElement);
+          String enclosingTypeName = enclosingType.getQualifiedName().toString();
+          boolean validEnclosingType = validTypeNames.contains(enclosingTypeName)
+              || (!deferredTypeNames.contains(enclosingTypeName)
+                  && validateElement(enclosingType));
+          if (validEnclosingType) {
+            elementsByAnnotationBuilder.put(annotationClass, annotatedElement);
+            validTypeNames.add(enclosingTypeName);
+          } else {
+            deferredTypeNames.add(enclosingTypeName);
+          }
+        }
+      }
+    }
+
+    ImmutableSetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation =
+        elementsByAnnotationBuilder.build();
+
+    // Finally, process the valid elements
+    for (ProcessingStep step : steps) {
+      SetMultimap<Class<? extends Annotation>, Element> filteredMap =
+          Multimaps.filterKeys(elementsByAnnotation, Predicates.in(step.annotations()));
+      if (!filteredMap.isEmpty()) {
+        step.process(filteredMap);
+      }
+    }
+
+    postProcess();
+
+    return false;
+  }
+
+  private void reportMissingElements(
+      Map<String, ? extends Optional<? extends Element>> missingElements) {
+    for (Entry<String, ? extends Optional<? extends Element>> missingElementEntry :
+        missingElements.entrySet()) {
+      Optional<? extends Element> missingElement = missingElementEntry.getValue();
+      if (missingElement.isPresent()) {
+        processingEnv.getMessager().printMessage(ERROR,
+            String.format(INVALID_ELEMENT_MESSAGE_FORMAT, processorName,
+                "this " + Ascii.toLowerCase(missingElement.get().getKind().name())),
+                missingElement.get());
+      } else {
+        processingEnv.getMessager().printMessage(ERROR,
+            String.format(INVALID_ELEMENT_MESSAGE_FORMAT, processorName,
+                missingElementEntry.getKey()));
+      }
+    }
+  }
+
+  private static void findAnnotatedElements(Element element,
+      ImmutableSet<? extends Class<? extends Annotation>> annotationClasses,
+      ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> builder) {
+    for (Element enclosedElement : element.getEnclosedElements()) {
+      findAnnotatedElements(enclosedElement, annotationClasses, builder);
+    }
+    for (Class<? extends Annotation> annotationClass : annotationClasses) {
+      if (MoreElements.isAnnotationPresent(element, annotationClass)) {
+        builder.put(annotationClass, element);
+      }
+    }
+  }
+
+  private static TypeElement getEnclosingType(Element element) {
+    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override protected TypeElement defaultAction(Element e, Void p) {
+        return e.getEnclosingElement().accept(this, p);
+      }
+
+      @Override public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+
+      @Override public TypeElement visitPackage(PackageElement e, Void p) {
+        throw new IllegalArgumentException();
+      }
+    }, null);
+  }
+
+  /**
+   * The unit of processing logic that runs under the guarantee that all elements are complete and
+   * well-formed.
+   */
+  interface ProcessingStep {
+    /** The set of annotation types processed by this step. */
+    Set<? extends Class<? extends Annotation>> annotations();
+
+    /**
+     * The implementation of processing logic for the step. It is guaranteed that the keys in
+     * {@code elementsByAnnotation} will be a subset of the set returned by {@link #annotations()}.
+     */
+    void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 067194867..99724987b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,12 +16,13 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -31,7 +32,7 @@
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep implements ProcessingStep {
+final class ComponentProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final BindingGraphValidator bindingGraphValidator;
@@ -55,33 +56,34 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    Set<? extends Element> componentElements = roundEnv.getElementsAnnotatedWith(Component.class);
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
 
     for (Element element : componentElements) {
-      if (SuperficialValidation.validateElement(element)) {
-        TypeElement componentTypeElement = MoreElements.asType(element);
-        ValidationReport<TypeElement> componentReport =
-            componentValidator.validate(componentTypeElement);
-        componentReport.printMessagesTo(messager);
-        if (componentReport.isClean()) {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.create(componentTypeElement);
-          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-          ValidationReport<BindingGraph> graphReport =
-              bindingGraphValidator.validate(bindingGraph);
-          graphReport.printMessagesTo(messager);
-          if (graphReport.isClean()) {
-            try {
-              componentGenerator.generate(bindingGraph);
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
-            }
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> componentReport =
+          componentValidator.validate(componentTypeElement);
+      componentReport.printMessagesTo(messager);
+      if (componentReport.isClean()) {
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.create(componentTypeElement);
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport =
+            bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
       }
     }
-
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 195797429..0b1f208cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,8 +18,6 @@
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Component;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.BindingGraphValidator.ScopeCycleValidation;
@@ -27,15 +25,11 @@
 import dagger.producers.Produces;
 import java.util.Map;
 import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -51,22 +45,9 @@
  * @since 2.0
  */
 @AutoService(Processor.class)
-public final class ComponentProcessor extends AbstractProcessor {
-  private ImmutableList<ProcessingStep> processingSteps;
+public final class ComponentProcessor extends BasicAnnotationProcessor {
   private InjectBindingRegistry injectBindingRegistry;
 
-  @Override
-  public Set<String> getSupportedAnnotationTypes() {
-    return ImmutableSet.of(
-        Component.class.getName(),
-        Inject.class.getName(),
-        Module.class.getName(),
-        Provides.class.getName(),
-        MapKey.class.getName(),
-        ProducerModule.class.getName(),
-        Produces.class.getName());
-  }
-
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
@@ -78,9 +59,7 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
   @Override
-  public synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
-
+  protected Iterable<ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -130,7 +109,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
         injectBindingRegistry, disableInterComponentScopeValidation(processingEnv));
 
-    this.processingSteps = ImmutableList.<ProcessingStep>of(
+    return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
             mapKeyValidator,
@@ -165,16 +144,12 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    for (ProcessingStep processingStep : processingSteps) {
-      processingStep.process(annotations, roundEnv);
-    }
+  protected void postProcess() {
     try {
       injectBindingRegistry.generateSourcesForRequiredBindings();
     } catch (SourceFileGenerationException e) {
       e.printMessageTo(processingEnv.getMessager());
     }
-    return false;
   }
 
   private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 587df5bc7..532b01d40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,11 +16,11 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -35,7 +35,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectProcessingStep implements ProcessingStep {
+final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final InjectConstructorValidator constructorValidator;
   private final InjectFieldValidator fieldValidator;
@@ -61,60 +61,63 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Inject.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     // TODO(gak): instead, we should collect reports by type and check later
     final ImmutableSet.Builder<TypeElement> membersInjectedTypes = ImmutableSet.builder();
 
-    for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
-      if (SuperficialValidation.validateElement(injectElement)) {
-        injectElement.accept(
-            new ElementKindVisitor6<Void, Void>() {
-              @Override
-              public Void visitExecutableAsConstructor(
-                  ExecutableElement constructorElement, Void v) {
-                ValidationReport<ExecutableElement> report =
-                    constructorValidator.validate(constructorElement);
+    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
+      injectElement.accept(
+          new ElementKindVisitor6<Void, Void>() {
+            @Override
+            public Void visitExecutableAsConstructor(
+                ExecutableElement constructorElement, Void v) {
+              ValidationReport<ExecutableElement> report =
+                  constructorValidator.validate(constructorElement);
 
-                report.printMessagesTo(messager);
+              report.printMessagesTo(messager);
 
-                if (report.isClean()) {
-                  provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
-                }
-
-                return null;
+              if (report.isClean()) {
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
               }
 
-              @Override
-              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-                ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
+              return null;
+            }
 
-                report.printMessagesTo(messager);
+            @Override
+            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
-                if (report.isClean()) {
-                  membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
-                }
+              report.printMessagesTo(messager);
 
-                return null;
+              if (report.isClean()) {
+                membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
               }
 
-              @Override
-              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-                ValidationReport<ExecutableElement> report =
-                    methodValidator.validate(methodElement);
+              return null;
+            }
 
-                report.printMessagesTo(messager);
+            @Override
+            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+              ValidationReport<ExecutableElement> report =
+                  methodValidator.validate(methodElement);
 
-                if (report.isClean()) {
-                  membersInjectedTypes.add(
-                      MoreElements.asType(methodElement.getEnclosingElement()));
-                }
+              report.printMessagesTo(messager);
 
-                return null;
+              if (report.isClean()) {
+                membersInjectedTypes.add(
+                    MoreElements.asType(methodElement.getEnclosingElement()));
               }
-            }, null);
-      }
+
+              return null;
+            }
+          }, null);
     }
 
     for (TypeElement injectedType : membersInjectedTypes.build()) {
@@ -125,7 +128,5 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     for (ProvisionBinding binding : provisions.build()) {
       injectBindingRegistry.registerBinding(binding);
     }
-
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 94513a31e..6d830d9a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -15,13 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.SuperficialValidation;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
@@ -30,40 +30,39 @@
  * @author Chenying Hou
  * @since 2.0
  */
-public class MapKeyProcessingStep implements ProcessingStep {
+public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final MapKeyValidator mapKeyValidator;
   private final MapKeyGenerator mapKeyGenerator;
 
-  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator, MapKeyGenerator mapKeyGenerator) {
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator,
+      MapKeyGenerator mapKeyGenerator) {
     this.messager = messager;
     this.mapKeyValidator = mapKeyValidator;
     this.mapKeyGenerator = mapKeyGenerator;
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    if (!roundEnv.getElementsAnnotatedWith(MapKey.class).isEmpty()) {
-      // for each element annotated with @mapKey, validate it and auto generate key creator file for
-      // any unwrapped key
-      for (Element element : roundEnv.getElementsAnnotatedWith(MapKey.class)) {
-        if (SuperficialValidation.validateElement(element)) {
-          ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
-          mapKeyReport.printMessagesTo(messager);
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(MapKey.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.get(MapKey.class)) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+      mapKeyReport.printMessagesTo(messager);
 
-          if (mapKeyReport.isClean()) {
-            MapKey mapkey = element.getAnnotation(MapKey.class);
-            if (!mapkey.unwrapValue()) {
-              try {
-                mapKeyGenerator.generate(element);
-              } catch (SourceFileGenerationException e) {
-                e.printMessageTo(messager);
-              }
-            }
+      if (mapKeyReport.isClean()) {
+        MapKey mapkey = element.getAnnotation(MapKey.class);
+        if (!mapkey.unwrapValue()) {
+          try {
+            mapKeyGenerator.generate(element);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
       }
     }
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 0dca93377..f0f45042a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -16,17 +16,17 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Module;
 import dagger.Provides;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -42,7 +42,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ModuleProcessingStep implements ProcessingStep {
+final class ModuleProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProvidesMethodValidator providesMethodValidator;
@@ -64,10 +64,15 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Module.class, Provides.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
     ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : roundEnv.getElementsAnnotatedWith(Provides.class)) {
+    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
       if (providesElement.getKind().equals(METHOD)) {
         ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
         ValidationReport<ExecutableElement> methodReport =
@@ -82,49 +87,46 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
     // process each module
     for (Element moduleElement :
-        Sets.difference(roundEnv.getElementsAnnotatedWith(Module.class), processedModuleElements)) {
-      if (SuperficialValidation.validateElement(moduleElement)) {
-        ValidationReport<TypeElement> report =
-            moduleValidator.validate(MoreElements.asType(moduleElement));
-        report.printMessagesTo(messager);
+        Sets.difference(elementsByAnnotation.get(Module.class), processedModuleElements)) {
+      ValidationReport<TypeElement> report =
+          moduleValidator.validate(MoreElements.asType(moduleElement));
+      report.printMessagesTo(messager);
 
-        if (report.isClean()) {
-          ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
-              ImmutableSet.builder();
-          List<ExecutableElement> moduleMethods =
-              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
-          for (ExecutableElement methodElement : moduleMethods) {
-            if (isAnnotationPresent(methodElement, Provides.class)) {
-              moduleProvidesMethodsBuilder.add(methodElement);
-            }
+      if (report.isClean()) {
+        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+            ImmutableSet.builder();
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+        for (ExecutableElement methodElement : moduleMethods) {
+          if (isAnnotationPresent(methodElement, Provides.class)) {
+            moduleProvidesMethodsBuilder.add(methodElement);
           }
-          ImmutableSet<ExecutableElement> moduleProvidesMethods =
-              moduleProvidesMethodsBuilder.build();
+        }
+        ImmutableSet<ExecutableElement> moduleProvidesMethods =
+            moduleProvidesMethodsBuilder.build();
 
-          if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
-            // all of the provides methods in this module are valid!
-            // time to generate some factories!
-            ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
-                .transform(new Function<ExecutableElement, ProvisionBinding>() {
-                  @Override
-                  public ProvisionBinding apply(ExecutableElement providesMethod) {
-                    return provisionBindingFactory.forProvidesMethod(providesMethod);
-                  }
-                })
-                .toSet();
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+          // all of the provides methods in this module are valid!
+          // time to generate some factories!
+          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+              .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                @Override
+                public ProvisionBinding apply(ExecutableElement providesMethod) {
+                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                }
+              })
+              .toSet();
 
-            try {
-              for (ProvisionBinding binding : bindings) {
-                factoryGenerator.generate(binding);
-              }
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
+          try {
+            for (ProvisionBinding binding : bindings) {
+              factoryGenerator.generate(binding);
             }
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
-        processedModuleElements.add(moduleElement);
       }
+      processedModuleElements.add(moduleElement);
     }
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
deleted file mode 100644
index 14d7751d6..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import java.util.Set;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.TypeElement;
-
-/**
- * This represents work to be done in an annotation processor that must run with other steps due to
- * shared state between them or a particular execution order.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-interface ProcessingStep {
-  boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 1da33ec94..28c361121 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -20,13 +20,15 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.internal.codegen.BasicAnnotationProcessor.ProcessingStep;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -64,10 +66,15 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Produces.class, ProducerModule.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all produces methods
     ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
-    for (Element producesElement : roundEnv.getElementsAnnotatedWith(Produces.class)) {
+    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
       if (producesElement.getKind().equals(METHOD)) {
         ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
         ValidationReport<ExecutableElement> methodReport =
@@ -82,7 +89,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
     // process each module
     for (Element moduleElement :
-        Sets.difference(roundEnv.getElementsAnnotatedWith(ProducerModule.class),
+        Sets.difference(elementsByAnnotation.get(ProducerModule.class),
             processedModuleElements)) {
       if (SuperficialValidation.validateElement(moduleElement)) {
         ValidationReport<TypeElement> report =
@@ -127,6 +134,5 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
         processedModuleElements.add(moduleElement);
       }
     }
-    return false;
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java
new file mode 100644
index 000000000..0d840ecb7
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Set;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.tools.JavaFileObject;
+import javax.tools.StandardLocation;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class BasicAnnotationProcessorTest {
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface RequiresGeneratedCode {}
+
+  /** Asserts that the code generated by {@link GeneratesCode} and its processor is present.  */
+  public static class RequiresGeneratedCodeProcessor extends BasicAnnotationProcessor {
+    boolean processed = false;
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return SourceVersion.latestSupported();
+    }
+
+    @Override
+    protected Iterable<? extends ProcessingStep> initSteps() {
+      return ImmutableSet.of(new ProcessingStep() {
+        @Override
+        public void process(
+            SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+          processed = true;
+          try {
+            processingEnv.getFiler()
+                .getResource(StandardLocation.SOURCE_OUTPUT, "test", "SomeGeneratedClass");
+          } catch (IOException e) {
+            throw new AssertionError(e);
+          }
+        }
+
+        @Override
+        public Set<? extends Class<? extends Annotation>> annotations() {
+          return ImmutableSet.of(RequiresGeneratedCode.class);
+        }
+      });
+    }
+  }
+
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface GeneratesCode {}
+
+  /** Generates a class called {@code test.SomeGeneratedClass}. */
+  public static class GeneratesCodeProcessor extends BasicAnnotationProcessor {
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return SourceVersion.latestSupported();
+    }
+
+    @Override
+    protected Iterable<? extends ProcessingStep> initSteps() {
+      return ImmutableSet.of(new ProcessingStep() {
+        @Override
+        public void process(
+            SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+          for (Element element : elementsByAnnotation.values()) {
+            try {
+              generateClass(element);
+            } catch (IOException e) {
+              throw new RuntimeException(e);
+            }
+          }
+        }
+
+        @Override
+        public Set<? extends Class<? extends Annotation>> annotations() {
+          return ImmutableSet.of(GeneratesCode.class);
+        }
+      });
+    }
+
+    private void generateClass(Element sourceType) throws IOException {
+      JavaFileObject source =
+          processingEnv.getFiler().createSourceFile("test.SomeGeneratedClass", sourceType);
+      PrintWriter writer = new PrintWriter(source.openWriter());
+      writer.println("package test;");
+      writer.println("public class SomeGeneratedClass {}");
+      writer.close();
+    }
+  }
+
+  @Test public void properlyDefersProcessing_typeElement() {
+    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
+        "package test;",
+        "",
+        "@" + RequiresGeneratedCode.class.getCanonicalName(),
+        "public class ClassA {",
+        "  SomeGeneratedClass sgc;",
+        "}");
+    JavaFileObject classBFileObject = JavaFileObjects.forSourceLines("test.ClassB",
+        "package test;",
+        "",
+        "@" + GeneratesCode.class.getCanonicalName(),
+        "public class ClassB {}");
+    RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor =
+        new RequiresGeneratedCodeProcessor();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(classAFileObject, classBFileObject))
+        .processedWith(requiresGeneratedCodeProcessor, new GeneratesCodeProcessor())
+        .compilesWithoutError();
+    assertThat(requiresGeneratedCodeProcessor.processed).isTrue();
+  }
+
+  @Retention(RetentionPolicy.SOURCE)
+  public @interface ReferencesAClass {
+    Class<?> value();
+  }
+
+  @Test public void properlyDefersProcessing_packageElement() {
+    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
+        "package test;",
+        "",
+        "@" + GeneratesCode.class.getCanonicalName(),
+        "public class ClassA {",
+        "}");
+    JavaFileObject packageFileObject = JavaFileObjects.forSourceLines("test.package-info",
+        "@" + RequiresGeneratedCode.class.getCanonicalName(),
+        "@" + ReferencesAClass.class.getCanonicalName() + "(SomeGeneratedClass.class)",
+        "package test;");
+    RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor =
+        new RequiresGeneratedCodeProcessor();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(classAFileObject, packageFileObject))
+        .processedWith(requiresGeneratedCodeProcessor, new GeneratesCodeProcessor())
+        .compilesWithoutError();
+    assertThat(requiresGeneratedCodeProcessor.processed).isTrue();
+  }
+
+  @Test public void reportsMissingType() {
+    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
+        "package test;",
+        "",
+        "@" + RequiresGeneratedCode.class.getCanonicalName(),
+        "public class ClassA {",
+        "  SomeGeneratedClass bar;",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(classAFileObject))
+        .processedWith(new RequiresGeneratedCodeProcessor())
+        .failsToCompile()
+        .withErrorContaining(RequiresGeneratedCodeProcessor.class.getCanonicalName())
+        .in(classAFileObject).onLine(4);
+  }
+}
