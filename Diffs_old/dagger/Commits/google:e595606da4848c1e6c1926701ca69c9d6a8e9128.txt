diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
index 255f28c3a..4be51ed7b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 
 /**
- * A simple component that demonstrates both static an non-static provides methods.
+ * A simple component that demonstrates both static and non-static provides methods.
  */
 @Component(modules = {AllStaticModule.class, SomeStaticModule.class})
 interface StaticTestComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
new file mode 100644
index 000000000..d778fc5c5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+
+/**
+ * A simple component that demonstrates both static and non-static provides methods with a builder.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponentWithBuilder extends StaticTestComponent {
+  @Component.Builder
+  interface Builder {
+    Builder allStaticModule(AllStaticModule allStaticModule);
+    Builder someStaticModule(SomeStaticModule someStaticModule);
+    StaticTestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
index 3fb1c2e96..397259403 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -19,16 +19,31 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class StaticProvidesTest {
-  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+  @Parameters
+  public static Collection<Object[]> components() {
+    return Arrays.asList(new Object[][] {
+        {DaggerStaticTestComponent.create()},
+        {DaggerStaticTestComponentWithBuilder.builder().build()},
+        {DaggerStaticTestComponentWithBuilder.builder()
+          .allStaticModule(new AllStaticModule())
+          .someStaticModule(new SomeStaticModule())
+          .build()}});
+  }
+
+  @Parameter
+  public StaticTestComponent component;
 
   @Test public void setMultibinding() {
     assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 13212fd2f..e0425c925 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -111,6 +111,7 @@
 import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
 import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
 import static dagger.internal.codegen.writer.Snippet.nullCheck;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -286,6 +287,31 @@ protected void addBuilder() {
       builderWriter.addModifiers(PUBLIC);
     }
 
+    builderFields = addBuilderFields(builderWriter);
+    addBuildMethod(builderWriter, builderSpec);
+    addBuilderMethods(builderWriter, builderSpec);
+
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+  }
+
+  /**
+   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
+   * requirements}. Regardless of builder spec, there is always one field per requirement.
+   */
+  private ImmutableMap<TypeElement, FieldWriter> addBuilderFields(ClassWriter builderWriter) {
+    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
+    for (TypeElement contributionElement : graph.componentRequirements()) {
+      String contributionName = simpleVariableName(contributionElement);
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
+      builderFieldsBuilder.put(contributionElement, builderField);
+    }
+    return builderFieldsBuilder.build();
+  }
+
+  /** Adds the build method to the builder. */
+  private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> builderSpec) {
     MethodWriter buildMethod;
     if (builderSpec.isPresent()) {
       ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
@@ -301,103 +327,95 @@ protected void addBuilder() {
     }
     buildMethod.addModifiers(PUBLIC);
 
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
-
-    builderFields = addBuilderMethods(builderWriter, builderSpec, buildMethod);
-    buildMethod.body().addSnippet("return new %s(this);", name);
-  }
-
-  private ImmutableMap<TypeElement, FieldWriter> addBuilderMethods(
-      ClassWriter builderWriter, Optional<BuilderSpec> builderSpec, MethodWriter buildMethod) {
-    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
-    ImmutableSet<TypeElement> componentRequirements = graph.componentRequirements();
-
-    for (TypeElement contributionElement : componentRequirements) {
-      String contributionName = simpleVariableName(contributionElement);
-      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
-      builderField.addModifiers(PRIVATE);
-      builderFieldsBuilder.put(contributionElement, builderField);
-      if (componentCanMakeNewInstances(contributionElement)) {
-        buildMethod
-            .body()
-            .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet(
-                "  this.%s = new %s();",
+    for (Map.Entry<TypeElement, FieldWriter> builderFieldEntry : builderFields.entrySet()) {
+      FieldWriter builderField = builderFieldEntry.getValue();
+      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
+        buildMethod.body()
+            .addSnippet("if (%1$s == null) { this.%1$s = new %2$s(); }",
                 builderField.name(),
-                ClassName.fromTypeElement(contributionElement))
-            .addSnippet("}");
+                builderField.type());
       } else {
-        buildMethod
-            .body()
-            .addSnippet("if (%s == null) {", builderField.name())
+        buildMethod.body()
             .addSnippet(
-                "  throw new IllegalStateException(\"%s must be set\");", builderField.name())
-            .addSnippet("}");
-      }
-
-      MethodWriter builderMethod;
-      if (builderSpec.isPresent()) {
-        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
-        if (method == null) { // no method in the API, nothing to write out.
-          continue;
-        }
-        builderMethod = addBuilderMethodFromSpec(builderWriter, method);
-      } else {
-        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
-      }
-      // TODO(gak): Mirror the API's visibility.
-      // (Makes no difference to the user since this class is private,
-      //  but makes generated code prettier.)
-      builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod
-          .body()
-          .addSnippet(nullCheck(contributionName))
-          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
-      if (!builderMethod.returnType().equals(VoidName.VOID)) {
-        builderMethod.body().addSnippet("return this;");
+                "if (%s == null) { throw new %s(%s.class.getCanonicalName() + \" must be set\"); }",
+                builderField.name(),
+                ClassName.fromClass(IllegalStateException.class),
+                builderField.type());
       }
     }
 
+    buildMethod.body().addSnippet("return new %s(this);", name);
+  }
+
+  /**
+   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
+   * present, it will tailor the methods to match the spec.
+   */
+  private void addBuilderMethods(
+      ClassWriter builderWriter,
+      Optional<BuilderSpec> builderSpec) {
     if (builderSpec.isPresent()) {
-      /* We know that the graph is properly formed because it passed validation, so all
-       * component requirements that are in the builder spec but _not_ owned by the component must
-       * be inherited. */
-      for (TypeElement inheritedRequirement :
-          Sets.difference(builderSpec.get().methodMap().keySet(), componentRequirements)) {
-        MethodWriter builderMethod =
-            addBuilderMethodFromSpec(
-                builderWriter, builderSpec.get().methodMap().get(inheritedRequirement));
-        builderMethod.addModifiers(PUBLIC);
-        builderMethod.addParameter(inheritedRequirement, simpleVariableName(inheritedRequirement));
-        builderMethod
-            .body()
-            .addSnippet(
-                "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
-                ClassName.fromClass(UnsupportedOperationException.class),
-                ClassName.fromClass(String.class),
-                StringLiteral.forValue(
-                    "%s cannot be set because it is inherited from the enclosing component"),
-                ClassName.fromTypeElement(inheritedRequirement));
+      for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+          builderSpec.get().methodMap().entrySet()) {
+        TypeElement builderMethodType = builderMethodEntry.getKey();
+        ExecutableElement specMethod = builderMethodEntry.getValue();
+        MethodWriter builderMethod = addBuilderMethodFromSpec(builderWriter, specMethod);
+        String parameterName =
+            Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName().toString();
+        builderMethod.addParameter(builderMethodType, parameterName);
+        builderMethod.body().addSnippet(nullCheck(parameterName));
+        if (graph.componentRequirements().contains(builderMethodType)) {
+          // required type
+          builderMethod.body().addSnippet("this.%s = %s;",
+              builderFields.get(builderMethodType).name(),
+              parameterName);
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
+          // owned, but not required
+          builderMethod.body()
+              .addSnippet("// This module is declared, but not used in the component. "
+                  + "This method is a no-op");
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else {
+          // neither owned nor required, so it must be an inherited module
+          builderMethod
+              .body()
+              .addSnippet(
+                  "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
+                  ClassName.fromClass(UnsupportedOperationException.class),
+                  ClassName.fromClass(String.class),
+                  StringLiteral.forValue(
+                      "%s cannot be set because it is inherited from the enclosing component"),
+                  ClassName.fromTypeElement(builderMethodType));
+        }
       }
     } else {
-      for (TypeElement ownedButNotRequired :
-          Sets.difference(graph.ownedModuleTypes(), componentRequirements)) {
-        String contributionName = simpleVariableName(ownedButNotRequired);
-        MethodWriter builderMethod =
-            builderWriter.addMethod(builderWriter, contributionName);
+      for (TypeElement componentRequirement : graph.availableDependencies()) {
+        String componentRequirementName = simpleVariableName(componentRequirement);
+        MethodWriter builderMethod = builderWriter.addMethod(
+            builderWriter.name(),
+            componentRequirementName);
         builderMethod.addModifiers(PUBLIC);
-        builderMethod.annotate(Deprecated.class);
-        builderMethod.addParameter(ownedButNotRequired, contributionName);
-        builderMethod.body()
-            .addSnippet("// This module is declared, but not used in the component. "
-                + "This method is a no-op")
-            .addSnippet(nullCheck(contributionName))
-            .addSnippet("return this;");
+        builderMethod.addParameter(componentRequirement, componentRequirementName);
+        builderMethod.body().addSnippet(nullCheck(componentRequirementName));
+        if (graph.componentRequirements().contains(componentRequirement)) {
+          builderMethod.body()
+              .addSnippet("this.%s = %s;",
+                  builderFields.get(componentRequirement).name(),
+                  componentRequirementName);
+        } else {
+          builderMethod.annotate(Deprecated.class);
+        }
+        builderMethod.body().addSnippet("return this;");
       }
     }
-    return builderFieldsBuilder.build();
+  }
+
+  private void addBuilderMethodReturnStatementForSpec(
+      ExecutableElement specMethod, MethodWriter builderMethod) {
+    if (!specMethod.getReturnType().getKind().equals(VOID)) {
+      builderMethod.body().addSnippet("return this;");
+    }
   }
 
   private MethodWriter addBuilderMethodFromSpec(
@@ -412,6 +430,7 @@ private MethodWriter addBuilderMethodFromSpec(
             ? builderWriter.addMethod(returnType, methodName)
             : builderWriter.addMethod(builderWriter, methodName);
     builderMethod.annotate(Override.class);
+    builderMethod.addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
     return builderMethod;
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index b23f831a5..2d11f60f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -111,11 +111,11 @@ public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors)
   }
 
   public static Snippet nullCheck(Object thingToCheck) {
-    return format("if (%s == null) { throw new NullPointerException();} ", thingToCheck);
+    return format("if (%s == null) { throw new NullPointerException(); } ", thingToCheck);
   }
 
   public static Snippet nullCheck(Object thingToCheck, String message) {
-    return format("if (%s == null) { throw new NullPointerException(%s);} ",
+    return format("if (%s == null) { throw new NullPointerException(%s); } ",
         thingToCheck,
         StringLiteral.forValue(message));
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 187712abb..20bafff65 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -227,7 +227,7 @@ public void testIgnoresModulesNotInApi() {
         "",
         "  @Component.Builder",
         "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule);",
+        "    Builder testModule1(TestModule1 testModule1);",
         "    TestComponent build();",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 66c79d08f..94e48e2c8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1336,7 +1336,8 @@ public void generatedModuleInSubcomponent() {
         "",
         "    public BComponent build() {",
         "      if (aComponent == null) {",
-        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+        "            + \" must be set\");",
         "      }",
         "      return new DaggerBComponent(this);",
         "    }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index e30b5d864..92bbb752c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -184,24 +184,25 @@
         "        this.aModule = new AModule();",
         "      }",
         "      if (executor == null) {",
-        "        throw new IllegalStateException(\"executor must be set\");",
+        "        throw new IllegalStateException(Executor.class.getCanonicalName()",
+        "            + \" must be set\");",
         "      }",
         "      return new DaggerTestClass_SimpleComponent(this);",
         "    }",
         "",
-        "    public Builder bModule(BModule bModule) {",
-        "      if (bModule == null) {",
+        "    public Builder aModule(AModule aModule) {",
+        "      if (aModule == null) {",
         "        throw new NullPointerException();",
         "      }",
-        "      this.bModule = bModule;",
+        "      this.aModule = aModule;",
         "      return this;",
         "    }",
         "",
-        "    public Builder aModule(AModule aModule) {",
-        "      if (aModule == null) {",
+        "    public Builder bModule(BModule bModule) {",
+        "      if (bModule == null) {",
         "        throw new NullPointerException();",
         "      }",
-        "      this.aModule = aModule;",
+        "      this.bModule = bModule;",
         "      return this;",
         "    }",
         "",
