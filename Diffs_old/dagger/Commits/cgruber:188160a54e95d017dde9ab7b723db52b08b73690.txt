diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index dd86b9223..1e3a11dfb 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -50,6 +50,7 @@
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.inject.Provider;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.type.TypeMirror;
 
 /** A central repository of code expressions used to access any binding available to a component. */
@@ -66,6 +67,7 @@
   private final OptionalFactories optionalFactories;
   private final DaggerTypes types;
   private final DaggerElements elements;
+  private final SourceVersion sourceVersion;
   private final CompilerOptions compilerOptions;
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
@@ -81,6 +83,7 @@
       OptionalFactories optionalFactories,
       DaggerTypes types,
       DaggerElements elements,
+      SourceVersion sourceVersion,
       @GenerationCompilerOptions CompilerOptions compilerOptions) {
     this.parent = parent;
     this.graph = graph;
@@ -89,6 +92,7 @@
     this.optionalFactories = checkNotNull(optionalFactories);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
+    this.sourceVersion = checkNotNull(sourceVersion);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
         new MembersInjectionMethods(componentImplementation, this, graph, elements, types);
@@ -425,7 +429,7 @@ private BindingExpression provisionBindingExpression(
         return producerFromProviderBindingExpression(resolvedBindings);
 
       case FUTURE:
-        return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
+        return new ImmediateFutureBindingExpression(resolvedBindings, this, types, sourceVersion);
 
       case MEMBERS_INJECTION:
         throw new IllegalArgumentException();
@@ -568,7 +572,8 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
                 resolvedBindings, componentImplementation, graph, this, types, elements));
 
       case OPTIONAL:
-        return Optional.of(new OptionalBindingExpression(resolvedBindings, this, types));
+        return Optional.of(
+            new OptionalBindingExpression(resolvedBindings, this, types, sourceVersion));
 
       case BOUND_INSTANCE:
         return Optional.of(
@@ -587,7 +592,8 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
                 membersInjectionMethods,
                 componentRequirementExpressions,
                 types,
-                elements));
+                elements,
+                sourceVersion));
 
       case MEMBERS_INJECTOR:
         return Optional.empty();
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
index d4e082021..9519bc1c8 100644
--- a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -25,19 +25,23 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import javax.lang.model.SourceVersion;
 
 final class ImmediateFutureBindingExpression extends BindingExpression {
 
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
+  private final SourceVersion sourceVersion;
   private final Key key;
 
   ImmediateFutureBindingExpression(
       ResolvedBindings resolvedBindings,
       ComponentBindingExpressions componentBindingExpressions,
-      DaggerTypes types) {
+      DaggerTypes types,
+      SourceVersion sourceVersion) {
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
+    this.sourceVersion = checkNotNull(sourceVersion);
     this.key = resolvedBindings.key();
   }
 
@@ -52,14 +56,16 @@ private CodeBlock instanceExpression(ClassName requestingClass) {
     Expression expression =
         componentBindingExpressions.getDependencyExpression(
             bindingRequest(key, RequestKind.INSTANCE), requestingClass);
-    // Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
-    // cast.
-    //
-    // For example, javac7 cannot detect that Futures.immediateFuture(ImmutableSet.of("T"))
-    // can safely be assigned to ListenableFuture<Set<T>>.
-    if (!types.isSameType(expression.type(), key.type())) {
-      return CodeBlock.of(
-          "($T) $L", types.accessibleType(key.type(), requestingClass), expression.codeBlock());
+    if (sourceVersion.compareTo(SourceVersion.RELEASE_7) <= 0) {
+      // Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
+      // cast.
+      //
+      // For example, javac7 cannot detect that Futures.immediateFuture(ImmutableSet.of("T"))
+      // can safely be assigned to ListenableFuture<Set<T>>.
+      if (!types.isSameType(expression.type(), key.type())) {
+        return CodeBlock.of(
+            "($T) $L", types.accessibleType(key.type(), requestingClass), expression.codeBlock());
+      }
     }
     return expression.codeBlock();
   }
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 1ec9f45a4..9537b6808 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -25,22 +25,26 @@
 import dagger.internal.codegen.OptionalType.OptionalKind;
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
 
 /** A binding expression for optional bindings. */
 final class OptionalBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
+  private final SourceVersion sourceVersion;
 
   @Inject
   OptionalBindingExpression(
       ResolvedBindings resolvedBindings,
       ComponentBindingExpressions componentBindingExpressions,
-      DaggerTypes types) {
+      DaggerTypes types,
+      SourceVersion sourceVersion) {
     super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
+    this.sourceVersion = sourceVersion;
   }
 
   @Override
@@ -48,14 +52,16 @@ Expression getDependencyExpression(ClassName requestingClass) {
     OptionalType optionalType = OptionalType.from(binding.key());
     OptionalKind optionalKind = optionalType.kind();
     if (binding.dependencies().isEmpty()) {
-      // When compiling with -source 7, javac's type inference isn't strong enough to detect
-      // Futures.immediateFuture(Optional.absent()) for keys that aren't Object. It also has issues
-      // when used as an argument to some members injection proxy methods (see
-      // https://github.com/google/dagger/issues/916)
-      if (isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
-        return Expression.create(
-            binding.key().type(),
-            optionalKind.parameterizedAbsentValueExpression(optionalType));
+      if (sourceVersion.compareTo(SourceVersion.RELEASE_7) <= 0) {
+        // When compiling with -source 7, javac's type inference isn't strong enough to detect
+        // Futures.immediateFuture(Optional.absent()) for keys that aren't Object. It also has
+        // issues
+        // when used as an argument to some members injection proxy methods (see
+        // https://github.com/google/dagger/issues/916)
+        if (isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
+          return Expression.create(
+              binding.key().type(), optionalKind.parameterizedAbsentValueExpression(optionalType));
+        }
       }
       return Expression.create(binding.key().type(), optionalKind.absentValueExpression());
     }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 3bd908fe0..51510e3b2 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -34,6 +34,7 @@
 import dagger.model.DependencyRequest;
 import java.util.Optional;
 import java.util.function.Function;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -51,6 +52,7 @@
   private final ComponentRequirementExpressions componentRequirementExpressions;
   private final DaggerTypes types;
   private final DaggerElements elements;
+  private final SourceVersion sourceVersion;
 
   SimpleMethodBindingExpression(
       ResolvedBindings resolvedBindings,
@@ -59,7 +61,8 @@
       MembersInjectionMethods membersInjectionMethods,
       ComponentRequirementExpressions componentRequirementExpressions,
       DaggerTypes types,
-      DaggerElements elements) {
+      DaggerElements elements,
+      SourceVersion sourceVersion) {
     super(resolvedBindings);
     this.compilerOptions = compilerOptions;
     this.provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
@@ -72,6 +75,7 @@
     this.componentRequirementExpressions = componentRequirementExpressions;
     this.types = types;
     this.elements = elements;
+    this.sourceVersion = sourceVersion;
   }
 
   @Override
@@ -151,14 +155,15 @@ private Expression injectMembers(CodeBlock instance) {
     if (provisionBinding.injectionSites().isEmpty()) {
       return Expression.create(simpleMethodReturnType(), instance);
     }
-    // Java 7 type inference can't figure out that instance in
-    // injectParameterized(Parameterized_Factory.newParameterized()) is Parameterized<T> and not
-    // Parameterized<Object>
-    if (!MoreTypes.asDeclared(provisionBinding.key().type()).getTypeArguments().isEmpty()) {
-      TypeName keyType = TypeName.get(provisionBinding.key().type());
-      instance = CodeBlock.of("($T) ($T) $L", keyType, rawTypeName(keyType), instance);
+    if (sourceVersion.compareTo(SourceVersion.RELEASE_7) <= 0) {
+      // Java 7 type inference can't figure out that instance in
+      // injectParameterized(Parameterized_Factory.newParameterized()) is Parameterized<T> and not
+      // Parameterized<Object>
+      if (!MoreTypes.asDeclared(provisionBinding.key().type()).getTypeArguments().isEmpty()) {
+        TypeName keyType = TypeName.get(provisionBinding.key().type());
+        instance = CodeBlock.of("($T) ($T) $L", keyType, rawTypeName(keyType), instance);
+      }
     }
-
     MethodSpec membersInjectionMethod = membersInjectionMethods.getOrCreate(provisionBinding.key());
     TypeMirror returnType =
         membersInjectionMethod.returnType.equals(TypeName.OBJECT)
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 4b51fe2c2..f8770c457 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ObjectArrays;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -1098,7 +1099,11 @@ public void optionalBindings_satisfiedInAncestor() {
             "    return Optional.<SatisfiedInAncestor>empty();",
             "  }",
             "}");
-    Compilation compilation = compile(filesToCompile.build());
+    Compilation compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerLeaf")
@@ -1154,7 +1159,11 @@ public void optionalBindings_satisfiedInAncestor() {
             "",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
@@ -1208,7 +1217,11 @@ public void optionalBindings_satisfiedInGrandAncestor() {
             "    return Optional.<SatisfiedInGrandAncestor>empty();",
             "  }",
             "}");
-    Compilation compilation = compile(filesToCompile.build());
+    Compilation compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerLeaf")
@@ -1242,7 +1255,11 @@ public void optionalBindings_satisfiedInGrandAncestor() {
             "    protected LeafImpl() {}",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
@@ -1302,7 +1319,11 @@ public void optionalBindings_satisfiedInGrandAncestor() {
             "    }",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerGreatAncestor")
@@ -1371,7 +1392,11 @@ public void optionalBindings_nonComponentMethodDependencySatisfiedInAncestor() {
             "    return Optional.<SatisfiedInAncestor>empty();",
             "  }",
             "}");
-    Compilation compilation = compile(filesToCompile.build());
+    Compilation compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerLeaf")
@@ -1426,7 +1451,11 @@ public void optionalBindings_nonComponentMethodDependencySatisfiedInAncestor() {
             "    }",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
@@ -1515,7 +1544,11 @@ public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
             "    }",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerAncestor")
@@ -1575,7 +1608,11 @@ public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
             "    }",
             "  }",
             "}");
-    compilation = compile(filesToCompile.build());
+    compilation =
+        compile(
+            filesToCompile.build()
+            , CompilerMode.JAVA7
+            );
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerGrandAncestor")
@@ -5598,7 +5635,10 @@ private void createSimplePackagePrivateClasses(
     }
   }
 
-  private static Compilation compile(Iterable<JavaFileObject> files) {
-    return compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE).compile(files);
+  private static Compilation compile(Iterable<JavaFileObject> files, CompilerMode... modes) {
+    return compilerWithOptions(
+            ObjectArrays.concat(
+                new CompilerMode[] {AHEAD_OF_TIME_SUBCOMPONENTS_MODE}, modes, CompilerMode.class))
+        .compile(files);
   }
 }
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index 4dcc21548..bd46bf99f 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -23,7 +23,8 @@
 enum CompilerMode {
   DEFAULT_MODE,
   FAST_INIT_MODE("-Adagger.fastInit=enabled"),
-  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled");
+  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled"),
+  JAVA7("-source", "7", "-target", "7");
 
   /** Returns the compiler modes as a list of parameters for parameterized tests */
   static final ImmutableList<Object[]> TEST_PARAMETERS =
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 5b0ab6f6f..b8b63c03d 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -19,6 +19,7 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
+import static dagger.internal.codegen.Compilers.compilerWithOptions;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -194,7 +195,7 @@ public void mapBindings() {
                 DEFAULT_MODE, //
                 "        0, MapModule_ProvideIntFactory.create());")
             .addLinesIn(
-                FAST_INIT_MODE,
+                FAST_INIT_MODE, //
                 "        0, getProvideIntProvider());")
             .addLines(
                 "  }",
@@ -534,8 +535,10 @@ public void productionComponents() {
             "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
     Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
+        compilerWithOptions(
+                compilerMode
+                , CompilerMode.JAVA7
+                )
             .compile(mapModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 2803b217c..731873550 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -19,7 +19,7 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.Compilers.compilerWithOptions;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.testing.compile.Compilation;
@@ -71,7 +71,7 @@ public void inlinedOptionalBindings() {
             "",
             "public class Maybe {",
             "  @Module",
-            "  public interface MaybeModule {",
+            "  public static class MaybeModule {",
             "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
             "  }",
             "}");
@@ -135,10 +135,10 @@ public void inlinedOptionalBindings() {
                 "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
                 "    return Optional.of(ProviderOfLazy.create(")
             .addLinesIn(
-                DEFAULT_MODE,
+                DEFAULT_MODE, //
                 "        Maybe_MaybeModule_ProvideMaybeFactory.create()));")
             .addLinesIn(
-                FAST_INIT_MODE,
+                FAST_INIT_MODE, //
                 "        getMaybeProvider()));")
             .addLines(
                 "  }",
@@ -176,8 +176,10 @@ public void inlinedOptionalBindings() {
                 "}")
             .build();
     Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
+        compilerWithOptions(
+                compilerMode
+                , CompilerMode.JAVA7
+                )
             .compile(module, maybe, definitelyNot, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -212,7 +214,7 @@ public void requestForFuture() {
             "",
             "public class Maybe {",
             "  @Module",
-            "  public interface MaybeModule {",
+            "  public static class MaybeModule {",
             "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
             "  }",
             "}");
@@ -268,8 +270,10 @@ public void requestForFuture() {
             "}");
 
     Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
+        compilerWithOptions(
+                compilerMode
+                , CompilerMode.JAVA7
+                )
             .compile(module, maybe, definitelyNot, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
