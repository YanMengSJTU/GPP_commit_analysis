diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 73d4ee6a3..ef1708fa9 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -43,7 +43,16 @@ public T get() {
       synchronized (this) {
         result = instance;
         if (result == UNINITIALIZED) {
-          instance = result = provider.get();
+          result = provider.get();
+          /* Get the current instance and test to see if the call to provider.get() has resulted
+           * in a recursive call.  If it returns the same instance, we'll allow it, but if the
+           * instances differ, throw. */
+          Object currentInstance = instance;
+          if (currentInstance != UNINITIALIZED && currentInstance != result) {
+            throw new IllegalStateException("Scoped provider was invoked recursively returning "
+                + "different results: " + currentInstance + " & " + result);
+          }
+          instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
            * can make it eligible for GC. */
           provider = null;
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 280dccf25..077c50807 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -126,4 +127,58 @@ public Object get() {
       return new Object();
     }
   }
+
+  @Test public void reentranceWithoutCondition_throwsStackOverflow() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+      @Override
+      public Object get() {
+        return doubleCheckReference.get().get();
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    try {
+      doubleCheck.get();
+      fail();
+    } catch (StackOverflowError expected) {}
+  }
+
+  @Test public void reentranceReturningSameInstance() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    final AtomicInteger invocationCount = new AtomicInteger();
+    final Object object = new Object();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+     @Override
+      public Object get() {
+         if (invocationCount.incrementAndGet() == 1) {
+          doubleCheckReference.get().get();
+        }
+        return object;
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    assertThat(doubleCheck.get()).isSameAs(object);
+  }
+
+  @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    final AtomicInteger invocationCount = new AtomicInteger();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+     @Override
+      public Object get() {
+        if (invocationCount.incrementAndGet() == 1) {
+          doubleCheckReference.get().get();
+        }
+        return new Object();
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    try {
+      doubleCheck.get();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
 }
