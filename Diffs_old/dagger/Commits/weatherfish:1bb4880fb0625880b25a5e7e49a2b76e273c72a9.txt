diff --git a/.travis.yml b/.travis.yml
index 49ca80a24..34622aca9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,7 +13,7 @@ addons:
     packages:
       - oracle-java8-installer
       - libstdc++-4.9-dev # https://github.com/nodegit/nodegit/issues/853
-      - bazel=0.4.3
+      - bazel=0.4.4
 
 jdk:
   - &jdk_for_publishing oraclejdk8
@@ -22,13 +22,12 @@ android:
   components:
     - tools
     - tools # Duplicated as per https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
-    - build-tools-25.0.0
+    - build-tools-25.0.2
     - android-25
     - platform-tools
     - extra-android-m2repository
 
 before_install:
-  - echo "ANDROID_HOME = \"$ANDROID_HOME\"" > WORKSPACE.user.bzl
   - sudo rm -f /etc/mavenrc
   - wget http://www.us.apache.org/dist/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz
   - tar -zxvf apache-maven-3.1.1-bin.tar.gz
@@ -38,7 +37,6 @@ before_install:
   - mvn --version
 
 install:
-  - bazel build //...
   - mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
 script:
@@ -64,3 +62,4 @@ branches:
 cache:
   directories:
     - $HOME/.m2
+    - $HOME/.cache/bazel
diff --git a/BUILD b/BUILD
index b77025b94..6f926f057 100644
--- a/BUILD
+++ b/BUILD
@@ -21,8 +21,8 @@ package_group(
 
 py_test(
     name = "maven_sha1_test",
-    srcs = ["tools/maven_sha1_test.py"],
-    data = [":WORKSPACE"],
+    srcs = ["maven_sha1_test.py"],
+    data = ["WORKSPACE"],
 )
 
 java_library(
@@ -38,3 +38,46 @@ java_library(
         "//producers",
     ],
 )
+
+load("//tools:jarjar.bzl", "jarjar_library")
+
+genrule(
+    name = "rules_file",
+    outs = ["rules_file.txt"],
+    cmd = "echo \"rule com.google.auto.common.** dagger.shaded.auto.common.@1\" > $@",
+)
+
+jarjar_library(
+    name = "shaded_compiler",
+    rules_file = ":rules_file.txt",
+    deps = [
+        "//compiler",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+# coalesced javadocs used for the gh-pages site
+javadoc_library(
+    name = "user-docs",
+    srcs = [
+        "//core/src/main/java/dagger:javadoc-srcs",
+        "//java/dagger/android:android-srcs",
+        "//producers:producers-srcs",
+    ],
+    android_api_level = 25,
+    # TODO(ronshapiro): figure out how to specify the version number for release builds
+    doctitle = "Dagger Dependency Injection API",
+    exclude_packages = [
+        "dagger.internal",
+        "dagger.producers.internal",
+        "dagger.producers.monitoring.internal",
+    ],
+    root_packages = ["dagger"],
+    deps = [
+        "//core/src/main/java/dagger:core",
+        "//java/dagger/android",
+        "//producers",
+    ],
+)
diff --git a/WORKSPACE b/WORKSPACE
index de425d11f..89481ad45 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -12,16 +12,10 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-# Every user should create a WORKSPACE.user.bzl file and declare the path to their $ANDROID_HOME
-# directory. If you don't want to compile //android, you can remove the android related targets in
-# the WORKSPACE
-load("/WORKSPACE.user", "ANDROID_HOME")
-
 android_sdk_repository(
     name = "androidsdk",
     api_level = 25,
     build_tools_version = "25.0.2",
-    path = ANDROID_HOME,
 )
 
 bind(
@@ -30,7 +24,7 @@ bind(
 )
 
 maven_jar(
-    name = "javax_annotations_jsr250_api",
+    name = "javax_annotation_jsr250_api",
     artifact = "javax.annotation:jsr250-api:1.0",
     sha1 = "5025422767732a1ab45d93abfea846513d742dcf",
 )
@@ -73,8 +67,8 @@ maven_jar(
 
 maven_jar(
     name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:1.2",
-    sha1 = "c897dff7c217667d797bc9bf9d54416e776e9917",
+    artifact = "com.google.googlejavaformat:google-java-format:1.3",
+    sha1 = "949e85e75b3160ce1446aa99d806d5b509631b02",
 )
 
 maven_jar(
@@ -154,3 +148,7 @@ maven_jar(
     artifact = "com.squareup:javapoet:1.7.0",
     sha1 = "4fdcf1fc27c1a8f55d1109df986c923152f07759",
 )
+
+load("//tools:jarjar.bzl", "jarjar_deps")
+
+jarjar_deps()
diff --git a/android/pom.xml b/android/pom.xml
deleted file mode 100644
index 3bd1e34f3..000000000
--- a/android/pom.xml
+++ /dev/null
@@ -1,79 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2016 The Dagger Authors.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.google.dagger</groupId>
-    <artifactId>dagger-parent</artifactId>
-    <version>HEAD-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>dagger-android</artifactId>
-  <name>Dagger for Android</name>
-
-  <packaging>aar</packaging>
-
-  <properties>
-    <java.version>1.6</java.version>
-  </properties>
-
-  <repositories>
-    <repository>
-      <id>android-support</id>
-      <url>file://${env.ANDROID_HOME}/extras/android/m2repository</url>
-    </repository>
-  </repositories>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.dagger</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.android.support</groupId>
-      <artifactId>support-v4</artifactId>
-      <type>aar</type>
-    </dependency>
-    <dependency>
-      <groupId>com.android.support</groupId>
-      <artifactId>support-annotations</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>com.simpligility.maven.plugins</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-        <extensions>true</extensions>
-        <configuration>
-          <sdk>
-            <platform>${android.latest.version}</platform>
-            <path>${env.ANDROID_HOME}</path>
-          </sdk>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/BUILD b/compiler/BUILD
index 08c111641..5297ac105 100644
--- a/compiler/BUILD
+++ b/compiler/BUILD
@@ -51,6 +51,15 @@ java_library(
     ],
 )
 
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "compiler-javadoc",
+    srcs = COMPILER_SRCS,
+    root_packages = ["dagger.internal.codegen"],
+    deps = [":compiler"],
+)
+
 java_plugin(
     name = "component-codegen",
     generates_api = 1,
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
index 34c460763..ab0288e64 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
@@ -124,6 +124,24 @@ static Object provide789ForMap() {
     return "789-string";
   }
 
+  @Binds
+  @SomeQualifier
+  abstract int primitiveToPrimitive(int intValue);
+
+  @Binds
+  @IntoSet
+  abstract int intValueIntoSet(int intValue);
+
+  @Binds
+  @IntoMap
+  @IntKey(10)
+  abstract int intValueIntoMap(int intValue);
+
+  @Provides
+  static int intValue() {
+    return 100;
+  }
+
   @Binds
   @IntoMap
   @IntKey(123)
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
index bada4b164..9379dff12 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
@@ -51,4 +51,10 @@
   Map<Integer, Provider<Object>> integerProviderOfObjectMap();
 
   @SomeQualifier Map<Integer, Object> qualifiedIntegerObjectMap();
+
+  @SomeQualifier int uniquePrimitive();
+
+  Set<Integer> primitiveSet();
+
+  Map<Integer, Integer> primitiveValueMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
new file mode 100644
index 000000000..be522f5fa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface BuildMethodCovariantReturn {
+
+  @Component.Builder
+  interface Builder {
+    Object build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
new file mode 100644
index 000000000..a02ddf75a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+interface BuildMethodCovariantReturnInherited {
+  @Component
+  interface Simple {
+    interface BuilderSupertype {
+      Object build();
+    }
+
+    @Component.Builder
+    interface Builder extends BuilderSupertype {}
+  }
+
+  interface ComponentSupertype {}
+
+  @Component
+  interface GenericBuilderType extends ComponentSupertype {
+    interface GenericBuilderSupertype<T> {
+      T build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<ComponentSupertype> {}
+  }
+
+  interface ParameterizedComponentSupertype<T> {}
+
+  @Component
+  interface GenericComponentSupertypeAndBuilderSupertype
+      extends ParameterizedComponentSupertype<Object> {
+
+    interface GenericBuilderSupertype<T> {
+      ParameterizedComponentSupertype<T> build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<Object> {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
index 2341e1ade..5835b361e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
@@ -63,5 +63,8 @@ public void multibindings() {
     assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo("789-string");
 
     assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);
+
+    assertThat(component.primitiveSet()).containsExactly(100);
+    assertThat(component.primitiveValueMap()).containsExactly(10, 100);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 82c67e381..e6e42c142 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *  http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 0a7828496..795a5e185 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -49,7 +49,6 @@
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
 import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
@@ -1128,13 +1127,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
-                      "new $1T<$2T>() {",
+                      "new $1L<$2T>() {",
                       "  private final $5T $6L = $3L;",
                       "  $4L@Override public $2T get() {",
                       "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ FACTORY,
+              // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+              // conflict with anyone that has Factory as an inner type of a component (like
+              // AndroidInjector.Factory
+              /* 1 */ "dagger.internal.Factory",
               /* 2 */ bindingKeyTypeName,
               /* 3 */ getComponentContributionExpression(
                   ComponentRequirement.forDependency(dependencyType.asType())),
@@ -1153,12 +1155,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         return CodeBlock.of(
             Joiner.on('\n')
                 .join(
-                    "new $1T<$2T>() {",
+                    "new $1L<$2T>() {",
                     "  @Override public $2T get() {",
                     "    return new $3LBuilder();",
                     "  }",
                     "}"),
-            /* 1 */ FACTORY,
+            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+            // conflict with dagger.android.ActivityInjector.Factory
+            /* 1 */ "dagger.internal.Factory",
             /* 2 */ bindingKeyTypeName,
             /* 3 */ subcomponentName);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 3108e8a25..780963820 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -73,7 +73,7 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
     List<? extends VariableElement> parameters = method.getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = method.getReturnType();
+      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       switch (contributionType) {
@@ -152,4 +152,11 @@ private TypeElement mapElement() {
   private TypeMirror unboundedWildcard() {
     return types.getWildcardType(null, null);
   }
+
+  private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
+    if (maybePrimitive.getKind().isPrimitive()) {
+      return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
+    }
+    return maybePrimitive;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index edad7b733..72df34e5c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -23,9 +23,15 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ValidationReport.Builder;
 import java.lang.annotation.Annotation;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -45,6 +51,7 @@
  * @author sameb@google.com (Sam Berlin)
  */
 class BuilderValidator {
+
   private final Elements elements;
   private final Types types;
 
@@ -102,20 +109,34 @@
     }
 
     ExecutableElement buildMethod = null;
-    for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
       if (method.getParameters().size() == 0) {
         // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSameType(returnType, componentElement.asType())) {
+        if (types.isSubtype(componentElement.asType(), returnType)) {
+          validateBuildMethodReturnType(
+              builder,
+              // since types.isSubtype() passed, componentElement cannot be a PackageElement
+              MoreElements.asType(componentElement),
+              msgs,
+              method,
+              returnType);
           if (buildMethod != null) {
             // If we found more than one build-like method, fail.
-            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+            error(
+                builder,
+                method,
+                msgs.twoBuildMethods(),
+                msgs.inheritedTwoBuildMethods(),
                 buildMethod);
           }
         } else {
-          error(builder, method, msgs.buildMustReturnComponentType(),
+          error(
+              builder,
+              method,
+              msgs.buildMustReturnComponentType(),
               msgs.inheritedBuildMustReturnComponentType());
         }
         // We set the buildMethod regardless of the return type to reduce error spam.
@@ -151,6 +172,25 @@
     return builder.build();
   }
 
+  private void validateBuildMethodReturnType(
+      ValidationReport.Builder<TypeElement> builder,
+      TypeElement componentElement,
+      ComponentBuilderMessages msgs,
+      ExecutableElement method,
+      TypeMirror returnType) {
+    if (types.isSameType(componentElement.asType(), returnType)) {
+      return;
+    }
+    ImmutableSet<ExecutableElement> methodsOnlyInComponent =
+        methodsOnlyInComponent(componentElement);
+    if (!methodsOnlyInComponent.isEmpty()) {
+      builder.addWarning(
+          msgs.buildMethodReturnsSupertypeWithMissingMethods(
+              componentElement, builder.getSubject(), returnType, method, methodsOnlyInComponent),
+          method);
+    }
+  }
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -169,7 +209,7 @@
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(
+  private static void error(
       ValidationReport.Builder<TypeElement> builder,
       ExecutableElement method,
       String enclosedError,
@@ -178,10 +218,37 @@ private void error(
     if (method.getEnclosingElement().equals(builder.getSubject())) {
       builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
-      Object[] newArgs = new Object[extraArgs.length + 1];
-      newArgs[0] = method;
-      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs));
+      builder.addError(String.format(inheritedError, append(extraArgs, method)));
     }
   }
+
+  /** @see #error(Builder, ExecutableElement, String, String, Object...) */
+  private static void warning(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedWarning,
+      String inheritedWarning,
+      Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addWarning(String.format(enclosedWarning, extraArgs), method);
+    } else {
+      builder.addWarning(String.format(inheritedWarning, append(extraArgs, method)), method);
+    }
+  }
+
+  private static Object[] append(Object[] initial, Object additional) {
+    Object[] newArray = Arrays.copyOf(initial, initial.length + 1);
+    newArray[initial.length] = additional;
+    return newArray;
+  }
+
+  /**
+   * Returns all methods defind in {@code componentType} which are not inherited from a supertype.
+   */
+  private ImmutableSet<ExecutableElement> methodsOnlyInComponent(TypeElement componentType) {
+    // TODO(ronshapiro): Ideally this shouldn't return methods which are redeclared from a
+    // supertype, but do not change the return type. We don't have a good/simple way of checking
+    // that, and it doesn't seem likely, so the warning won't be too bad.
+    return ImmutableSet.copyOf(methodsIn(componentType.getEnclosedElements()));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 7156cc4cd..41a023488 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,9 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.TypeNames.rawTypeName;
 import static java.util.stream.StreamSupport.stream;
 
+import com.google.auto.common.MoreElements;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.TypeName;
@@ -141,7 +144,11 @@ static CodeBlock stringLiteral(String toWrap) {
   /** Returns a javadoc {@literal @link} tag that poins to the given {@link ExecutableElement}. */
   static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
     CodeBlock.Builder builder =
-        CodeBlock.builder().add("{@link $T#", executableElement.getEnclosingElement());
+        CodeBlock.builder()
+            .add(
+                "{@link $T#",
+                rawTypeName(
+                    ClassName.get(MoreElements.asType(executableElement.getEnclosingElement()))));
     switch (executableElement.getKind()) {
       case METHOD:
         builder.add("$L", executableElement.getSimpleName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 86f4a48ba..2a58dcecb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -521,7 +521,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(elements, types, componentDefinitionType);
+          getUnimplementedMethods(componentDefinitionType, types, elements);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -667,7 +667,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
       ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 67ffa5e5e..577362213 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -182,7 +182,7 @@ protected void addFactoryMethods() {
           methodBuilder("create")
               .returns(componentDefinitionTypeName())
               .addModifiers(PUBLIC, STATIC)
-              .addStatement("return builder().$L()", buildMethodName)
+              .addStatement("return new Builder().$L()", buildMethodName)
               .build());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
index f88dcdecc..8c8e0952f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -49,7 +49,7 @@
 final class DaggerElements {
 
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, Types types, TypeElement type) {
+      TypeElement type, Types types, Elements elements) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 9e398c4a6..0168e112a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -23,12 +23,14 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
@@ -486,13 +488,12 @@ final String inheritedTwoBuildMethods() {
 
     final String buildMustReturnComponentType() {
       return process(
-          "@Component.Builder methods that have no arguments must return the @Component type");
+          "@Component.Builder methods that have no arguments must return the @Component type or a "
+              + "supertype of the @Component");
     }
 
     final String inheritedBuildMustReturnComponentType() {
-      return process(
-          "@Component.Builder methods that have no arguments must return the @Component type"
-          + " Inherited method: %s");
+      return process(buildMustReturnComponentType() + ". Inherited method: %s");
     }
 
     final String methodsMustTakeOneArg() {
@@ -522,6 +523,23 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
       return process(
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
+
+    final String buildMethodReturnsSupertypeWithMissingMethods(
+        TypeElement component,
+        TypeElement componentBuilder,
+        TypeMirror returnType,
+        ExecutableElement buildMethod,
+        Set<ExecutableElement> additionalMethods) {
+      return String.format(
+          "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
+              + "order to provide type-safe access to these methods, override %2$s() to return "
+              + "%4$s",
+          componentBuilder.getQualifiedName(),
+          buildMethod.getSimpleName(),
+          returnType,
+          component.getQualifiedName(),
+          Joiner.on(", ").join(additionalMethods));
+    }
   }
 
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 9a2343ad9..f5af32957 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -17,11 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -37,29 +40,33 @@
 
   @Test
   public void testEmptyBuilder() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
+    JavaFileObject injectableTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.SomeInjectableType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class SomeInjectableType {",
+            "  @Inject SomeInjectableType() {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  SomeInjectableType someInjectableType();",
+            "",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
             "test.DaggerSimpleComponent",
@@ -78,7 +85,7 @@ public void testEmptyBuilder() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -93,254 +100,278 @@ public void testEmptyBuilder() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testUsesBuildAndSetterNames() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides String string() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder setTestModule(TestModule testModule);",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().create();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    @Override",
-        "    public TestComponent create() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder setTestModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder setTestModule(TestModule testModule);",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().create();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    @Override",
+            "    public TestComponent create() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder setTestModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testIgnoresModulesNotInApi() {
-    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule1 {",
-        "  @Provides String string() { return null; }",
-        "}");
-    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule2 {",
-        "  @Provides Integer integer() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule1.class, TestModule2.class})",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule1);",
-        "    TestComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "  private Provider<Integer> integerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer integer() {",
-        "    return integerProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule1 testModule1;",
-        "    private TestModule2 testModule2;",
-        "",
-        "    @Override",
-        "    public TestComponent build() {",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule1();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new TestModule2();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder testModule1(TestModule1 testModule1) {",
-        "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject module1 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule1",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule1 {",
+            "  @Provides String string() { return null; }",
+            "}");
+    JavaFileObject module2 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule2",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule2 {",
+            "  @Provides Integer integer() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule1.class, TestModule2.class})",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder testModule1(TestModule1 testModule1);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "  private Provider<Integer> integerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer integer() {",
+            "    return integerProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule1 testModule1;",
+            "    private TestModule2 testModule2;",
+            "",
+            "    @Override",
+            "    public TestComponent build() {",
+            "      if (testModule1 == null) {",
+            "        this.testModule1 = new TestModule1();",
+            "      }",
+            "      if (testModule2 == null) {",
+            "        this.testModule2 = new TestModule2();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder testModule1(TestModule1 testModule1) {",
+            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module1, module2, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder2 {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder2 {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .withErrorContaining(
+            String.format(
+                MSGS.moreThanOne(),
+                "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
 
   @Test
   public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder<T> {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder<T> {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.generics())
@@ -349,14 +380,17 @@ public void testBuilderGenericsFails() {
 
   @Test
   public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component.Builder",
-        "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
+    JavaFileObject builder =
+        JavaFileObjects.forSourceLines(
+            "test.Builder",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component.Builder",
+            "interface Builder {}");
+    assertAbout(javaSource())
+        .that(builder)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeInComponent())
@@ -365,18 +399,21 @@ public void testBuilderNotInComponentFails() {
 
   @Test
   public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.missingBuildMethod())
@@ -385,18 +422,21 @@ public void testBuilderMissingBuildMethodFails() {
 
   @Test
   public void testPrivateBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  private interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  private interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.isPrivate())
@@ -405,18 +445,21 @@ public void testPrivateBuilderFails() {
 
   @Test
   public void testNonStaticBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  abstract class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  abstract class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeStatic())
@@ -425,18 +468,21 @@ public void testNonStaticBuilderFails() {
 
   @Test
   public void testNonAbstractBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeAbstract());
@@ -444,20 +490,23 @@ public void testNonAbstractBuilderFails() {
 
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -466,21 +515,24 @@ public void testBuilderOneCxtorWithArgsFails() {
 
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder() {}",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -489,18 +541,21 @@ public void testBuilderMoreThanOneCxtorFails() {
 
   @Test
   public void testBuilderEnumFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  enum Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  enum Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeClassOrInterface())
@@ -509,250 +564,289 @@ public void testBuilderEnumFails() {
 
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    String build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(componentFile).onLine(10);
+        .in(componentFile)
+        .onLine(10);
   }
 
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    String build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(componentFile).onLine(13);
+        .withErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .in(componentFile)
+        .onLine(13);
   }
 
   @Test
   public void testTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
-            .in(componentFile).onLine(14);
+        .withErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    Builder set(String s, Integer i);",
-        "    Builder set(Number n, Double d);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    Builder set(String s, Integer i);",
+            "    Builder set(Number n, Double d);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(11)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(12);
+        .in(componentFile)
+        .onLine(11)
+        .and()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+        .in(componentFile)
+        .onLine(12);
   }
 
   @Test
   public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    Builder set1(String s, Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    Builder set1(String s, Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(componentFile).onLine(14);
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(componentFile).onLine(14);
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testGenericsOnSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(14);
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
@@ -892,61 +986,71 @@ public void testExtraSettersFails() {
 
   @Test
   public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
-        "           dependencies = OtherComponent.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface OtherComponent {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  TestModule(String unused) {}",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject module2File =
+        JavaFileObjects.forSourceLines(
+            "test.Test2Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test2Module {",
+            "  @Provides Integer i() { return null; }",
+            "}");
+    JavaFileObject module3File =
+        JavaFileObjects.forSourceLines(
+            "test.Test3Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test3Module {",
+            "  Test3Module(String unused) {}",
+            "  @Provides Double d() { return null; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+            "           dependencies = OtherComponent.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject otherComponent =
+        JavaFileObjects.forSourceLines(
+            "test.OtherComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface OtherComponent {}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
         .processedWith(new ComponentProcessor())
@@ -954,8 +1058,174 @@ public void testMissingSettersFail() {
         .withErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(),
-                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
-            .in(componentFile).onLine(12);
+            String.format(
+                MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+        .in(componentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(component)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index b095819e5..74e1b9e57 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -269,7 +269,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -353,7 +353,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -436,7 +436,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static OuterType.SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -538,7 +538,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -656,7 +656,7 @@ public void componentWithAbstractModule() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -776,7 +776,7 @@ public void componentWithAbstractModule() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -986,7 +986,7 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1119,7 +1119,7 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -1242,7 +1242,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1350,7 +1350,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1431,7 +1431,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1512,7 +1512,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1590,7 +1590,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1665,7 +1665,6 @@ public void testDefaultPackage() {
             "test.DaggerBComponent",
             "package test;",
             "",
-            "import dagger.internal.Factory;",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
@@ -1686,7 +1685,7 @@ public void testDefaultPackage() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new Factory<A>() {",
+            "    this.aProvider = new dagger.internal.Factory<A>() {",
             "      private final AComponent aComponent = builder.aComponent;",
             "      @Override public A get() {",
             "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
@@ -1793,7 +1792,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1918,7 +1917,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -2018,7 +2017,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -2107,7 +2106,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -2313,7 +2312,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "  }",
          "",
          "  public static SimpleComponent create() {",
-         "    return builder().build();",
+         "    return new Builder().build();",
          "  }",
          "",
          "  @SuppressWarnings(\"unchecked\")",
@@ -2588,7 +2587,7 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index b57fcb3a1..4f2932e41 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -105,7 +105,7 @@
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -236,7 +236,7 @@
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 46ffa2f60..5c4f98214 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -137,7 +137,7 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -290,7 +290,7 @@ public void mapBindingsWithStringKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -452,7 +452,7 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -620,7 +620,7 @@ public void mapBindingsWithNonProviderValue() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -735,7 +735,7 @@ public void injectMapWithoutMapBinding() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index a271187ef..62fe2fdb6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -235,7 +235,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -410,7 +410,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 34ee72c2f..35337fce5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -88,7 +88,7 @@ public void parentClass_noInjectedMembers() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -178,7 +178,7 @@ public void parentClass_injectedMembersInSupertype() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1a1bb6474..561795632 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -236,7 +236,7 @@ public void simpleComponent() {
             "  }",
             "",
             "  public static TestClass.SimpleComponent create() {",
-            "    return builder().build()",
+            "    return new Builder().build()",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 01389933f..f4cb9ed51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -17,11 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -421,7 +424,7 @@ public void testInheritedTwoBuildMethodsFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
             .in(childComponentFile).onLine(13);
   }
 
@@ -839,4 +842,169 @@ public void testMissingSettersFail() {
             String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
             .in(childComponentFile).onLine(11);
   }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(subcomponent)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index fb3a38873..976864df8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -371,7 +371,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "  }",
             "",
             "  public static ParentComponent create() {  ",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -528,7 +528,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -635,7 +635,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -733,7 +733,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -812,7 +812,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -881,7 +881,6 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "test.DaggerC",
             "package test;",
             "",
-            "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -901,13 +900,13 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
             "    this.fooBuilderProvider = ",
-            "        new Factory<C.Foo.Sub.Builder>() {",
+            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
             "          @Override",
             "          public C.Foo.Sub.Builder get() {",
             "            return new Foo_SubBuilder();",
@@ -915,7 +914,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "        };",
             "",
             "    this.barBuilderProvider = ",
-            "        new Factory<C.Bar.Sub.Builder>() {",
+            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
             "          @Override",
             "          public C.Bar.Sub.Builder get() {",
             "            return new Bar_SubBuilder();",
@@ -990,7 +989,7 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "class TestModule {",
             "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
             "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
-            "    return builder.toString();",
+            "    return new Builder().toString();",
             "  }",
             "}");
 
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index da1eca604..67beb03dd 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -93,7 +93,7 @@
           "  }",
           "",
           "  public static PrimitiveComponent create() {",
-          "    return builder().build();",
+          "    return new Builder().build();",
           "  }",
           "",
           "  @SuppressWarnings(\"unchecked\")",
diff --git a/core/src/main/java/dagger/BUILD b/core/src/main/java/dagger/BUILD
index bf28e6584..f4e27d2ef 100644
--- a/core/src/main/java/dagger/BUILD
+++ b/core/src/main/java/dagger/BUILD
@@ -31,3 +31,18 @@ java_library(
     exports = ["//third_party:jsr330_inject"],
     deps = ["//third_party:jsr330_inject"],
 )
+
+filegroup(
+    name = "javadoc-srcs",
+    srcs = glob(["**/*"]),
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "core-javadoc",
+    srcs = [":javadoc-srcs"],
+    exclude_packages = ["dagger.internal"],
+    root_packages = ["dagger"],
+    deps = ["//third_party:jsr330_inject"],
+)
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 04630d8b1..e4a074b40 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -51,7 +51,8 @@ public T get() {
           Object currentInstance = instance;
           if (currentInstance != UNINITIALIZED && currentInstance != result) {
             throw new IllegalStateException("Scoped provider was invoked recursively returning "
-                + "different results: " + currentInstance + " & " + result);
+                + "different results: " + currentInstance + " & " + result + ". This is likely "
+                + "due to a circular dependency.");
           }
           instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
index 7ac5026cc..99e180530 100644
--- a/core/src/main/java/dagger/internal/Preconditions.java
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -50,6 +50,36 @@
     return reference;
   }
 
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the check fail. The
+   *     message is formed by replacing the single {@code %s} placeholder in the template with
+   *     {@code errorMessageArg}.
+   * @param errorMessageArg the argument to be substituted into the message template. Converted to a
+   *     string using {@link String#valueOf(Object)}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   * @throws IllegalArgumentException if {@code errorMessageTemplate} doesn't contain exactly one
+   *     "%s"
+   */
+  public static <T> T checkNotNull(
+      T reference, String errorMessageTemplate, Object errorMessageArg) {
+    if (reference == null) {
+      // Poor-persons version of String.format, which is not GWT-compatible
+      if (!errorMessageTemplate.contains("%s")) {
+        throw new IllegalArgumentException("errorMessageTemplate has no format specifiers");
+      }
+      if (errorMessageTemplate.indexOf("%s") != errorMessageTemplate.lastIndexOf("%s")) {
+        throw new IllegalArgumentException(
+            "errorMessageTemplate has more than one format specifier");
+      }
+      throw new NullPointerException(
+          errorMessageTemplate.replaceFirst("%s", String.valueOf(errorMessageArg)));
+    }
+    return reference;
+  }
+
   private Preconditions() {}
 }
-
diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/android/ActivityKey.java
new file mode 100644
index 000000000..2fe7aeeee
--- /dev/null
+++ b/java/dagger/android/ActivityKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Activity;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ActivityKey {
+  Class<? extends Activity> value();
+}
diff --git a/java/dagger/android/AndroidInjection.java b/java/dagger/android/AndroidInjection.java
new file mode 100644
index 000000000..2a6554565
--- /dev/null
+++ b/java/dagger/android/AndroidInjection.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import android.util.Log;
+import dagger.internal.Beta;
+
+/** Injects core Android types. */
+@Beta
+public final class AndroidInjection {
+  private static final String TAG = "dagger.android";
+
+  /**
+   * Injects {@code activity} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasDispatchingActivityInjector}, or if no {@code AndroidInjector.Factory<Activity, ?>} is
+   *     bound for {@code activity}.
+   */
+  public static void inject(Activity activity) {
+    checkNotNull(activity, "activity");
+    Application application = activity.getApplication();
+    if (!(application instanceof HasDispatchingActivityInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingActivityInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<Activity> activityInjector =
+        ((HasDispatchingActivityInjector) application).activityInjector();
+    checkNotNull(
+        activityInjector,
+        "%s.activityInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    activityInjector.inject(activity);
+  }
+
+  /**
+   * Injects {@code fragment} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
+   *     for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingFragmentInjector hasDispatchingFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingFragmentInjector.fragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.fragmentInjector() returned null",
+        hasDispatchingFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingFragmentInjector) {
+        return (HasDispatchingFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidInjection() {}
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
new file mode 100644
index 000000000..3910a0421
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.Module;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Contains bindings to ensure the usability of {@code dagger.android} framework classes. This
+ * module should be installed in the component that is used to inject the {@link
+ * android.app.Application} class.
+ */
+@Beta
+@Module
+public abstract class AndroidInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactories();
+
+  private AndroidInjectionModule() {}
+}
diff --git a/java/dagger/android/AndroidInjector.java b/java/dagger/android/AndroidInjector.java
new file mode 100644
index 000000000..3e05de68a
--- /dev/null
+++ b/java/dagger/android/AndroidInjector.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import dagger.BindsInstance;
+import dagger.internal.Beta;
+
+/**
+ * Performs members-injection for a concrete subtype of a <a
+ * href="https://developer.android.com/guide/components/index.html">core Android type</a> (e.g.,
+ * {@link android.app.Activity} or {@link android.app.Fragment}).
+ *
+ * <p>Commonly implemented by {@link dagger.Subcomponent}-annotated types whose {@link
+ * dagger.Subcomponent.Builder} extends {@link Builder}.
+ *
+ * @param <T> a concrete subtype of a core Android type
+ * @see AndroidInjection
+ * @see DispatchingAndroidInjector
+ */
+@Beta
+public interface AndroidInjector<T> {
+
+  /** Injects the members of {@code instance}. */
+  void inject(T instance);
+
+  /**
+   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  interface Factory<T> {
+    /**
+     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
+     * that will be passed to {@link #inject(Object)}.
+     */
+    AndroidInjector<T> create(T instance);
+  }
+
+  /**
+   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
+   * Factory}.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  abstract class Builder<T> implements AndroidInjector.Factory<T> {
+    @Override
+    public final AndroidInjector<T> create(T instance) {
+      seedInstance(instance);
+      return build();
+    }
+
+    /**
+     * Provides {@code instance} to be used in the binding graph of the built {@link
+     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
+     * overridden to provide any modules which need a reference to the activity.
+     *
+     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
+     */
+    @BindsInstance
+    public abstract void seedInstance(T instance);
+
+    /** Returns a newly-constructed {@link AndroidInjector}. */
+    public abstract AndroidInjector<T> build();
+  }
+}
diff --git a/android/src/main/AndroidManifest.xml b/java/dagger/android/AndroidManifest.xml
similarity index 91%
rename from android/src/main/AndroidManifest.xml
rename to java/dagger/android/AndroidManifest.xml
index 8acac7a8f..fcd14263c 100644
--- a/android/src/main/AndroidManifest.xml
+++ b/java/dagger/android/AndroidManifest.xml
@@ -15,5 +15,5 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="dagger.android">
-  <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="24" />
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="24" />
 </manifest>
diff --git a/android/src/main/java/dagger/android/AndroidMemorySensitiveReferenceManager.java b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
similarity index 100%
rename from android/src/main/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
rename to java/dagger/android/AndroidMemorySensitiveReferenceManager.java
diff --git a/android/src/main/java/dagger/android/BUILD b/java/dagger/android/BUILD
similarity index 70%
rename from android/src/main/java/dagger/android/BUILD
rename to java/dagger/android/BUILD
index 70060f8d4..ffa55adf0 100644
--- a/android/src/main/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -25,13 +25,30 @@ load(
     "PRE_JAVA_8_INFERENCE_OPTS",
 )
 
+filegroup(
+    name = "android-srcs",
+    srcs = glob(["*.java"]),
+)
+
 android_library(
     name = "android",
-    srcs = glob(["*.java"]),
+    srcs = [":android-srcs"],
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    manifest = "AndroidManifest.xml",
     deps = [
         "//:dagger_with_compiler",
         "//third_party:auto_value",
-        "@androidsdk//com.android.support:support-annotations-24.2.0",
+        "@androidsdk//com.android.support:support-annotations-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
     ],
 )
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "android-javadoc",
+    srcs = [":android-srcs"],
+    android_api_level = 25,
+    root_packages = ["dagger.android"],
+    deps = [":android"],
+)
diff --git a/java/dagger/android/DaggerActivity.java b/java/dagger/android/DaggerActivity.java
new file mode 100644
index 000000000..d9f68911d
--- /dev/null
+++ b/java/dagger/android/DaggerActivity.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.os.Bundle;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link Activity} that injects its members in {@link #onCreate(Bundle)} and can be used to
+ * inject {@link Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerActivity extends Activity implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DaggerFragment.java b/java/dagger/android/DaggerFragment.java
new file mode 100644
index 000000000..d48438231
--- /dev/null
+++ b/java/dagger/android/DaggerFragment.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import android.content.Context;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
new file mode 100644
index 000000000..b22f6ecd4
--- /dev/null
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.internal.Beta;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Performs members-injection on instances of core Android types (e.g. {@link Activity}, {@link
+ * Fragment}) that are constructed by the Android framework and not by Dagger. This class relies on
+ * an injected mapping from each concrete class to an {@link AndroidInjector.Factory} for an {@link
+ * AndroidInjector} of that class. Each concrete class must have its own entry in the map, even if
+ * it extends another class which is already present in the map. Calls {@link Object#getClass()} on
+ * the instance in order to find the appropriate {@link AndroidInjector.Factory}.
+ *
+ * @param <T> the core Android type to be injected
+ */
+@Beta
+public final class DispatchingAndroidInjector<T> {
+  private static final String NO_SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%s>";
+  private static final String SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
+          + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
+
+  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
+      injectorFactories;
+
+  @Inject
+  DispatchingAndroidInjector(
+      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
+    this.injectorFactories = injectorFactories;
+  }
+
+  /**
+   * Attempts to perform members-injection on {@code instance}, returning {@code true} if
+   * successful, {@code false} otherwise.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   */
+  public boolean maybeInject(T instance) {
+    Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
+        injectorFactories.get(instance.getClass());
+    if (factoryProvider == null) {
+      return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    AndroidInjector.Factory<T> factory = (AndroidInjector.Factory<T>) factoryProvider.get();
+    try {
+      AndroidInjector<T> injector =
+          checkNotNull(
+              factory.create(instance),
+              "%s.create(I) should not return null.",
+              factory.getClass().getCanonicalName());
+
+      injector.inject(instance);
+      return true;
+    } catch (ClassCastException e) {
+      throw new InvalidInjectorBindingException(
+          String.format(
+              "%s does not implement AndroidInjector.Factory<%s>",
+              factory.getClass().getCanonicalName(), instance.getClass().getCanonicalName()),
+          e);
+    }
+  }
+
+  /**
+   * Performs members-injection on {@code instance}.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   * @throws IllegalArgumentException if no {@link AndroidInjector.Factory} is bound for {@code
+   *     instance}
+   */
+  public void inject(T instance) {
+    boolean wasInjected = maybeInject(instance);
+    if (!wasInjected) {
+      throw new IllegalArgumentException(errorMessageSuggestions(instance));
+    }
+  }
+
+  /**
+   * Exception thrown if an incorrect binding is made for a {@link AndroidInjector.Factory}. If you
+   * see this exception, make sure the value in your {@code @ActivityKey(YourActivity.class)} or
+   * {@code @FragmentKey(YourFragment.class)} matches the type argument of the injector factory.
+   */
+  @Beta
+  public static final class InvalidInjectorBindingException extends RuntimeException {
+    InvalidInjectorBindingException(String message, ClassCastException cause) {
+      super(message, cause);
+    }
+  }
+
+  /** Returns an error message with the class names that are supertypes of {@code instance}. */
+  private String errorMessageSuggestions(T instance) {
+    List<String> suggestions = new ArrayList<String>();
+    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
+      if (activityClass.isInstance(instance)) {
+        suggestions.add(activityClass.getCanonicalName());
+      }
+    }
+    Collections.sort(suggestions);
+
+    return String.format(
+        suggestions.isEmpty() ? NO_SUPERTYPES_BOUND_FORMAT : SUPERTYPES_BOUND_FORMAT,
+        instance.getClass().getCanonicalName(),
+        suggestions);
+  }
+}
diff --git a/java/dagger/android/FragmentKey.java b/java/dagger/android/FragmentKey.java
new file mode 100644
index 000000000..5f27e3f01
--- /dev/null
+++ b/java/dagger/android/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/HasDispatchingActivityInjector.java b/java/dagger/android/HasDispatchingActivityInjector.java
new file mode 100644
index 000000000..680139d89
--- /dev/null
+++ b/java/dagger/android/HasDispatchingActivityInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+@Beta
+public interface HasDispatchingActivityInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+  DispatchingAndroidInjector<Activity> activityInjector();
+}
diff --git a/java/dagger/android/HasDispatchingFragmentInjector.java b/java/dagger/android/HasDispatchingFragmentInjector.java
new file mode 100644
index 000000000..f7d223a76
--- /dev/null
+++ b/java/dagger/android/HasDispatchingFragmentInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> fragmentInjector();
+}
diff --git a/android/src/main/java/dagger/android/OnTrimMemoryValue.java b/java/dagger/android/OnTrimMemoryValue.java
similarity index 100%
rename from android/src/main/java/dagger/android/OnTrimMemoryValue.java
rename to java/dagger/android/OnTrimMemoryValue.java
diff --git a/android/src/main/java/dagger/android/ReleaseReferencesAt.java b/java/dagger/android/ReleaseReferencesAt.java
similarity index 100%
rename from android/src/main/java/dagger/android/ReleaseReferencesAt.java
rename to java/dagger/android/ReleaseReferencesAt.java
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
new file mode 100644
index 000000000..4b8240ff8
--- /dev/null
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Binds;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.FragmentKey;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Validates the correctness of {@link ActivityKey}, {@link FragmentKey} and {@link
+ * dagger.android.support.FragmentKey} methods.
+ */
+final class AndroidMapKeyValidator implements ProcessingStep {
+
+  private static final ImmutableBiMap<Class<? extends Annotation>, String>
+      ANNOTATIONS_AND_FRAMEWORK_TYPES =
+          ImmutableBiMap.of(
+              ActivityKey.class, "android.app.Activity",
+              FragmentKey.class, "android.app.Fragment",
+              dagger.android.support.FragmentKey.class, "android.support.v4.app.Fragment");
+  private static final String LINK_TO_DOCS = "google.github.io/dagger/android";
+
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+
+  AndroidMapKeyValidator(Elements elements, Types types, Messager messager) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ANNOTATIONS_AND_FRAMEWORK_TYPES.keySet();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    elementsByAnnotation.forEach(
+        (annotation, element) -> validateMethod(annotation, MoreElements.asExecutable(element)));
+    return ImmutableSet.of();
+  }
+
+  private void validateMethod(Class<? extends Annotation> annotation, ExecutableElement method) {
+    if (!getAnnotatedAnnotations(method, Qualifier.class).isEmpty()) {
+      return;
+    }
+
+    TypeMirror returnType = method.getReturnType();
+    if (!types.isAssignable(types.erasure(returnType), factoryElement().asType())) {
+      // if returnType is not related to AndroidInjector.Factory, ignore the method
+      return;
+    }
+
+    DeclaredType intendedReturnType =
+        injectorFactoryOf(types.getWildcardType(androidTypeForMapKey(annotation), null));
+    if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format(
+              "@%s methods should bind %s, not %s. See %s",
+              annotation.getCanonicalName(), intendedReturnType, returnType, LINK_TO_DOCS),
+          method);
+    }
+
+    // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
+    // in javac, so do a basic check for valid form
+    if (isAnnotationPresent(method, Binds.class) && method.getParameters().size() == 1) {
+      validateMapKeyMatchesBindsParameter(annotation, method);
+    }
+  }
+
+  /**
+   * A valid @Binds method could bind an {@link AndroidInjector.Factory} for one type, while giving
+   * it a map key of a different type. The return type and parameter type would pass typical @Binds
+   * validation, but the map lookup in {@link dagger.android.DispatchingAndroidInjector} would
+   * retrieve the wrong injector factory.
+   *
+   * <pre>{@code
+   * {@literal @Binds}
+   * {@literal @IntoMap}
+   * {@literal @ActivityKey(GreenActivity.class)}
+   * abstract AndroidInjector.Factory<? extends Activity> bindBlueActivity(
+   *     BlueActivityComponent.Builder builder);
+   * }</pre>
+   */
+  private void validateMapKeyMatchesBindsParameter(
+      Class<? extends Annotation> annotation, ExecutableElement method) {
+    TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          method,
+          annotationMirror);
+    }
+  }
+
+  private DeclaredType androidTypeForMapKey(Class<? extends Annotation> annotation) {
+    return types.getDeclaredType(
+        elements.getTypeElement(ANNOTATIONS_AND_FRAMEWORK_TYPES.get(annotation)));
+  }
+
+  /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
+  private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
+    return types.getDeclaredType(factoryElement(), implementationType);
+  }
+
+  private TypeElement factoryElement() {
+    return elements.getTypeElement(AndroidInjector.Factory.class.getCanonicalName());
+  }
+}
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
new file mode 100644
index 000000000..b69bb4e2e
--- /dev/null
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+
+/**
+ * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
+ * {@code dagger.android} code.
+ */
+@AutoService(Processor.class)
+public final class AndroidProcessor extends BasicAnnotationProcessor {
+  @Override
+  protected Iterable<? extends ProcessingStep> initSteps() {
+    return ImmutableList.of(
+        new AndroidMapKeyValidator(
+            processingEnv.getElementUtils(),
+            processingEnv.getTypeUtils(),
+            processingEnv.getMessager()));
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+}
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
new file mode 100644
index 000000000..12ba1e1f9
--- /dev/null
+++ b/java/dagger/android/processor/BUILD
@@ -0,0 +1,53 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Public Dagger API for Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+)
+
+# https://github.com/bazelbuild/bazel/issues/2517
+java_import(
+    name = "dagger_android_import_hack",
+    jars = [
+        "//java/dagger/android:libandroid.jar",
+        "//java/dagger/android/support:libsupport.jar",
+    ],
+)
+
+java_library(
+    name = "processor",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        ":dagger_android_import_hack",
+        "//core",
+        "//third_party:auto_common",
+        "//third_party:auto_service",
+        "//third_party:auto_value",
+        "//third_party:guava",
+    ],
+)
+
+java_plugin(
+    name = "plugin",
+    processor_class = "dagger.android.processor.AndroidProcessor",
+    deps = [":processor"],
+)
diff --git a/java/dagger/android/support/AndroidManifest.xml b/java/dagger/android/support/AndroidManifest.xml
new file mode 100644
index 000000000..fc31038b6
--- /dev/null
+++ b/java/dagger/android/support/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support">
+
+  <uses-sdk
+    android:minSdkVersion="14"
+    android:targetSdkVersion="24"/>
+</manifest>
diff --git a/java/dagger/android/support/AndroidSupportInjection.java b/java/dagger/android/support/AndroidSupportInjection.java
new file mode 100644
index 000000000..64e3537e2
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjection.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Injects core Android types from support libraries. */
+@Beta
+public final class AndroidSupportInjection {
+  private static final String TAG = "dagger.android.support";
+
+  /**
+   * Injects {@code fragment} if an associated {@link dagger.android.AndroidInjector.Factory}
+   * implementation can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingSupportFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingSupportFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingSupportFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingSupportFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
+   *     for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingSupportFragmentInjector hasDispatchingSupportFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingSupportFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingSupportFragmentInjector.supportFragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.supportFragmentInjector() returned null",
+        hasDispatchingSupportFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingSupportFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingSupportFragmentInjector) {
+        return (HasDispatchingSupportFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingSupportFragmentInjector) {
+      return (HasDispatchingSupportFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingSupportFragmentInjector) {
+      return (HasDispatchingSupportFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidSupportInjection() {}
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
new file mode 100644
index 000000000..6349afb67
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.Module;
+import dagger.android.AndroidInjectionModule;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Configures bindings to ensure the usability of {@code dagger.android} and {@code
+ * dagger.android.support} framework classes. This module should be installed in the root-most
+ * component which will use these types.
+ */
+@Beta
+@Module(includes = AndroidInjectionModule.class)
+public abstract class AndroidSupportInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactories();
+
+  private AndroidSupportInjectionModule() {}
+}
diff --git a/android/src/it/functional-tests/src/main/java/test/android/BUILD b/java/dagger/android/support/BUILD
similarity index 59%
rename from android/src/it/functional-tests/src/main/java/test/android/BUILD
rename to java/dagger/android/support/BUILD
index 9675854e3..07f5656f8 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/BUILD
+++ b/java/dagger/android/support/BUILD
@@ -11,29 +11,24 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-
+#
 # Description:
-#   Functional test code for Dagger-Android
+#   Public Dagger API for Android that interacts with the Android support libraries
 
 package(default_visibility = ["//:src"])
 
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-    "JAVA_6_SOURCE_LEVEL",
-)
+load("//:build_defs.bzl", "JAVA_6_SOURCE_LEVEL", "PRE_JAVA_8_INFERENCE_OPTS")
 
-# Sample code to be tested in functional tests.
 android_library(
-    name = "android",
-    testonly = 1,
+    name = "support",
     srcs = glob(["*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
-    # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
-    # used without a Guava and jsr305 deps.
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL,
+    manifest = "AndroidManifest.xml",
     deps = [
         "//:dagger_with_compiler",
-        "//android",
+        "//java/dagger/android",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-annotations-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
     ],
 )
diff --git a/java/dagger/android/support/DaggerAppCompatActivity.java b/java/dagger/android/support/DaggerAppCompatActivity.java
new file mode 100644
index 000000000..12d6e421b
--- /dev/null
+++ b/java/dagger/android/support/DaggerAppCompatActivity.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v7.app.AppCompatActivity;
+import dagger.android.AndroidInjection;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingFragmentInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link AppCompatActivity} that injects its members in {@link #onCreate(Bundle)} and can be
+ * used to inject {@code Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerAppCompatActivity extends AppCompatActivity
+    implements HasDispatchingFragmentInjector, HasDispatchingSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> supportFragmentInjector;
+  @Inject DispatchingAndroidInjector<android.app.Fragment> frameworkFragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    AndroidInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+    return supportFragmentInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<android.app.Fragment> fragmentInjector() {
+    return frameworkFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/DaggerFragment.java b/java/dagger/android/support/DaggerFragment.java
new file mode 100644
index 000000000..40ce16fde
--- /dev/null
+++ b/java/dagger/android/support/DaggerFragment.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements
+    HasDispatchingSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    AndroidSupportInjection.inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
new file mode 100644
index 000000000..a5ecda4d7
--- /dev/null
+++ b/java/dagger/android/support/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.support.v4.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java b/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java
new file mode 100644
index 000000000..088854468
--- /dev/null
+++ b/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingSupportFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> supportFragmentInjector();
+}
diff --git a/javatests/dagger/android/AndroidInjectionTest.java b/javatests/dagger/android/AndroidInjectionTest.java
new file mode 100644
index 000000000..43fb06242
--- /dev/null
+++ b/javatests/dagger/android/AndroidInjectionTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import com.google.common.collect.ImmutableMap;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.AndroidInjector.Factory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.FragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidInjectionTest {
+
+  // Most positive tests are performed in javatests/dagger/android/support/functional, but
+  // Robolectric's support for framework fragments is lacking, so we supplement those tests here:
+  public static class InjectableFragment extends Fragment {
+    String tag;
+  }
+
+  private static DispatchingAndroidInjector<Fragment> dispatchingFragmentInjector(String tag) {
+    return new DispatchingAndroidInjector<>(
+        ImmutableMap.of(
+            InjectableFragment.class,
+            () ->
+                new Factory<InjectableFragment>() {
+                  @Override
+                  public AndroidInjector<InjectableFragment> create(InjectableFragment fragment) {
+                    return f -> f.tag = tag;
+                  }
+                }));
+  }
+
+  public static class ApplicationInjectsFragment extends Application
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by app");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByApplication() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by app");
+  }
+
+  public static class ActivityInjectsFragment extends Activity
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by activity");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByActivity() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by activity");
+  }
+
+  public static class ParentFragmentInjectsChildFragment extends Fragment
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by parent fragment");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByParentFragment() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    ParentFragmentInjectsChildFragment parentFragment = new ParentFragmentInjectsChildFragment();
+    InjectableFragment childFragment = new InjectableFragment();
+
+    activity.getFragmentManager().beginTransaction().add(parentFragment, "tag").commit();
+    parentFragment
+        .getChildFragmentManager()
+        .beginTransaction()
+        .add(childFragment, "child-tag")
+        .commit();
+    AndroidInjection.inject(childFragment);
+
+    assertThat(childFragment.tag).isEqualTo("injected by parent fragment");
+  }
+
+  @Test
+  public void injectActivity_applicationDoesntImplementHasDispatchingActivityInjector() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("Application does not implement dagger.android.HasDispatchingActivityInjector");
+    }
+  }
+
+  @Test
+  public void injectFragment_hasDispatchingFragmentInjectorNotFound() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingActivityInjector, HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Activity> activityInjector() {
+      return null;
+    }
+
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingAndroidInjector_returnsNull() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("activityInjector() returned null");
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("fragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectActivity_nullInput() {
+    try {
+      AndroidInjection.inject((Activity) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("activity");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidInjection.inject((Fragment) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/android/src/it/functional-tests/src/test/java/test/android/BUILD b/javatests/dagger/android/BUILD
similarity index 71%
rename from android/src/it/functional-tests/src/test/java/test/android/BUILD
rename to javatests/dagger/android/BUILD
index 13beefb8d..cf47d8be9 100644
--- a/android/src/it/functional-tests/src/test/java/test/android/BUILD
+++ b/javatests/dagger/android/BUILD
@@ -11,30 +11,24 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-
+#
 # Description:
-#   Functional test code for Dagger-Android
+#   Tests for Dagger's Android integrations
 
 package(default_visibility = ["//:src"])
 
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
 load("//:test_defs.bzl", "GenRobolectricTests")
 
 GenRobolectricTests(
     name = "android_tests",
     srcs = glob(["*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
-        "//android/src/it/functional-tests/src/main/java/test/android",
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
         "//third_party:guava",
-        "//third_party:guava_testlib",
         "//third_party:junit",
         "//third_party:truth",
     ],
 )
-
-test_suite(name = "AllTests")
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
new file mode 100644
index 000000000..2d1e6132c
--- /dev/null
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class DispatchingAndroidInjectorTest {
+  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
+
+  @Before
+  public void setup() {
+    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
+        injectorFactories = new HashMap<>();
+    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
+    injectorFactories.put(ReturnsNullActivity.class, () -> null);
+    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
+    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  }
+
+  @Test
+  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+    FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+  }
+
+  @Test
+  public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+  }
+
+  @Test
+  public void throwsIfFactoryCreateReturnsNull() {
+    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      fail("Expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void throwsIfClassMismatched() {
+    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      fail("Expected InvalidInjectorBindingException");
+    } catch (InvalidInjectorBindingException expected) {
+    }
+  }
+
+  static class FooActivity extends Activity {}
+
+  static class BarActivity extends Activity {}
+
+  static class ReturnsNullActivity extends Activity {}
+
+  static class WrongActivity extends Activity {}
+
+  static class FooInjector implements AndroidInjector<FooActivity> {
+    @Override
+    public void inject(FooActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<FooActivity> {
+      @Override
+      public AndroidInjector<FooActivity> create(FooActivity activity) {
+        return new FooInjector();
+      }
+    }
+  }
+}
diff --git a/android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
similarity index 97%
rename from android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java
rename to javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
index 348376243..076de40fc 100644
--- a/android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java
+++ b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static com.google.common.truth.Truth.assertThat;
-import static test.android.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
+import static dagger.android.functional.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.testing.GcFinalization;
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
new file mode 100644
index 000000000..fdad2858f
--- /dev/null
+++ b/javatests/dagger/android/functional/BUILD
@@ -0,0 +1,54 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+# Sample code to be tested in functional tests.
+android_library(
+    name = "code_under_test",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
+        # used without a Guava and jsr305 deps.
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+    ],
+)
+
+GenRobolectricTests(
+    name = "android_functional_tests",
+    srcs = glob(["*Test.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        ":code_under_test",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/android/src/it/functional-tests/src/main/java/test/android/InScope.java b/javatests/dagger/android/functional/InScope.java
similarity index 95%
rename from android/src/it/functional-tests/src/main/java/test/android/InScope.java
rename to javatests/dagger/android/functional/InScope.java
index 6054add97..295ee069c 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/InScope.java
+++ b/javatests/dagger/android/functional/InScope.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import java.lang.annotation.Annotation;
 import javax.inject.Qualifier;
diff --git a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java b/javatests/dagger/android/functional/ReleaseWhenModerate.java
similarity index 97%
rename from android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java
rename to javatests/dagger/android/functional/ReleaseWhenModerate.java
index b5b100251..c8971b42d 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java
+++ b/javatests/dagger/android/functional/ReleaseWhenModerate.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
 import static java.lang.annotation.ElementType.METHOD;
diff --git a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
similarity index 97%
rename from android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java
rename to javatests/dagger/android/functional/ReleaseWhenUiHidden.java
index b3dfd17aa..ca22db44a 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java
+++ b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
 import static java.lang.annotation.ElementType.METHOD;
diff --git a/android/src/it/functional-tests/src/main/java/test/android/TestComponent.java b/javatests/dagger/android/functional/TestComponent.java
similarity index 96%
rename from android/src/it/functional-tests/src/main/java/test/android/TestComponent.java
rename to javatests/dagger/android/functional/TestComponent.java
index c46420d07..03d40755b 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/TestComponent.java
+++ b/javatests/dagger/android/functional/TestComponent.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import dagger.Component;
 import dagger.android.AndroidMemorySensitiveReferenceManager;
diff --git a/android/src/it/functional-tests/src/main/java/test/android/TestModule.java b/javatests/dagger/android/functional/TestModule.java
similarity index 96%
rename from android/src/it/functional-tests/src/main/java/test/android/TestModule.java
rename to javatests/dagger/android/functional/TestModule.java
index 7d7c59e6c..dd3adaa0b 100644
--- a/android/src/it/functional-tests/src/main/java/test/android/TestModule.java
+++ b/javatests/dagger/android/functional/TestModule.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package test.android;
+package dagger.android.functional;
 
 import dagger.Module;
 import dagger.Provides;
diff --git a/javatests/dagger/android/support/AndroidSupportInjectionTest.java b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
new file mode 100644
index 000000000..87593af4c
--- /dev/null
+++ b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.support.v4.SupportFragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidSupportInjectionTest {
+  @Test
+  public void injectFragment_simpleApplication() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingSupportFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("supportFragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidSupportInjection.inject(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
new file mode 100644
index 000000000..c194709bf
--- /dev/null
+++ b/javatests/dagger/android/support/BUILD
@@ -0,0 +1,37 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android and Support library integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android-support-tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
new file mode 100644
index 000000000..2813ccce5
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.FragmentKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class AllControllersAreDirectChildrenOfApplication extends Application
+    implements HasDispatchingActivityInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerAllControllersAreDirectChildrenOfApplication_ApplicationComponent.create().inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Component(
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent {
+    void inject(AllControllersAreDirectChildrenOfApplication application);
+
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ParentFragmentSubcomponent.class,
+        ChildFragmentSubcomponent.class
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestParentFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+          ParentFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestChildFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+          ChildFragmentSubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+    }
+
+    @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+    interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+      @Module
+      abstract class ParentFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ParentFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+    }
+
+    @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+    interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+      @Module
+      abstract class ChildFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ChildFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
new file mode 100644
index 000000000..1ace8cb8f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support.functional">
+
+  <application android:theme="@style/Theme.AppCompat">
+    <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
+  </application>
+</manifest>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
new file mode 100644
index 000000000..ee7a3050f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -0,0 +1,52 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+android_library(
+    name = "functional",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    manifest = "AndroidManifest.xml",
+    resource_files = glob(["res/**"]),
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
+
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "functional_tests",
+    srcs = glob(["*Test.java"]),
+    deps = [
+        ":functional",
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
new file mode 100644
index 000000000..6b7c44bd4
--- /dev/null
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.FragmentKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class ComponentStructureFollowsControllerStructureApplication extends Application
+    implements HasDispatchingActivityInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerComponentStructureFollowsControllerStructureApplication_ApplicationComponent.create()
+        .inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Component(
+      modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent {
+    void inject(ComponentStructureFollowsControllerStructureApplication application);
+
+    @Module(subcomponents = ActivitySubcomponent.class)
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module(subcomponents = ParentFragmentSubcomponent.class)
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+
+        @Binds
+        @IntoMap
+        @FragmentKey(TestParentFragment.class)
+        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+            ParentFragmentSubcomponent.Builder builder);
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+
+      @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+      interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+        @Module(subcomponents = ChildFragmentSubcomponent.class)
+        abstract class ParentFragmentModule {
+          @Provides
+          @IntoSet
+          static Class<?> addToComponentHierarchy() {
+            return ParentFragmentSubcomponent.class;
+          }
+
+          @Binds
+          @IntoMap
+          @FragmentKey(TestChildFragment.class)
+          abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+              ChildFragmentSubcomponent.Builder builder);
+        }
+
+        @Subcomponent.Builder
+        abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+
+        @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+        interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+          @Module
+          abstract class ChildFragmentModule {
+            @Provides
+            @IntoSet
+            static Class<?> addToComponentHierarchy() {
+              return ChildFragmentSubcomponent.class;
+            }
+          }
+
+          @Subcomponent.Builder
+          abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
new file mode 100644
index 000000000..0aa42c9c1
--- /dev/null
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.robolectric.RobolectricTestRunner;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+public class InjectorsTest {
+  private static final String MANIFEST =
+      "//javatests/dagger/android/support/functional"
+          + ":functional/AndroidManifest.xml";
+  private TestActivity activity;
+  private TestParentFragment parentFragment;
+  private TestChildFragment childFragment;
+
+  @Before
+  public void setUp() {
+    activity = Robolectric.setupActivity(TestActivity.class);
+    parentFragment =
+        (TestParentFragment)
+            activity.getSupportFragmentManager().findFragmentByTag("parent-fragment");
+    childFragment =
+        (TestChildFragment)
+            parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+  }
+
+  @Test
+  @Config(
+    manifest = MANIFEST,
+    application = ComponentStructureFollowsControllerStructureApplication.class
+  )
+  public void componentStructureFollowsControllerStructure() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
+  }
+
+  @Test
+  @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
+  public void AllControllersAreDirectChildrenOfApplication() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ActivitySubcomponent
+                .class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ChildFragmentSubcomponent.class);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestActivity.java b/javatests/dagger/android/support/functional/TestActivity.java
new file mode 100644
index 000000000..c4fda4293
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivity.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.os.Bundle;
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestActivity extends DaggerAppCompatActivity {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    setContentView(R.layout.activity_layout);
+
+    getSupportFragmentManager()
+        .beginTransaction()
+        .add(new TestParentFragment(), "parent-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestChildFragment.java b/javatests/dagger/android/support/functional/TestChildFragment.java
new file mode 100644
index 000000000..781c57809
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestChildFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestChildFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestParentFragment.java b/javatests/dagger/android/support/functional/TestParentFragment.java
new file mode 100644
index 000000000..6d2d6f47d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestParentFragment.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Context;
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestParentFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    getChildFragmentManager()
+        .beginTransaction()
+        .add(new TestChildFragment(), "child-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/res/layout/activity_layout.xml b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
new file mode 100644
index 000000000..d886d971d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
@@ -0,0 +1,21 @@
+<!--
+  ~ Copyright (C) 2016 The Dagger Authors.
+  ~
+  ~  Licensed under the Apache License, Version 2.0 (the "License");
+  ~  you may not use this file except in compliance with the License.
+  ~  You may obtain a copy of the License at
+  ~
+  ~  http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an "AS IS" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
diff --git a/tools/maven_sha1_test.py b/maven_sha1_test.py
similarity index 100%
rename from tools/maven_sha1_test.py
rename to maven_sha1_test.py
diff --git a/pom.xml b/pom.xml
index b8db19aec..8c7a198f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -32,7 +32,6 @@
   <url>https://github.com/google/dagger</url>
 
   <modules>
-    <module>android</module>
     <module>compiler</module>
     <module>core</module>
     <module>gwt</module>
@@ -106,7 +105,7 @@
       <dependency>
         <groupId>com.google.googlejavaformat</groupId>
         <artifactId>google-java-format</artifactId>
-        <version>1.2</version>
+        <version>1.3</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
@@ -158,23 +157,6 @@
         <artifactId>javapoet</artifactId>
         <version>1.7.0</version>
       </dependency>
-
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>4.1.1.4</version>
-      </dependency>
-      <dependency>
-        <groupId>com.android.support</groupId>
-        <artifactId>support-v4</artifactId>
-        <version>${android.support.version}</version>
-        <type>aar</type>
-      </dependency>
-      <dependency>
-        <groupId>com.android.support</groupId>
-        <artifactId>support-annotations</artifactId>
-        <version>${android.support.version}</version>
-      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -226,12 +208,6 @@
           <additionalparam>-Xdoclint:html,reference,syntax</additionalparam>
         </configuration>
       </plugin>
-
-      <plugin>
-        <groupId>com.simpligility.maven.plugins</groupId>
-        <artifactId>android-maven-plugin</artifactId>
-        <version>4.4.3</version>
-      </plugin>
     </plugins>
   </build>
 
@@ -247,7 +223,6 @@
         <activeByDefault>true</activeByDefault>
       </activation>
       <modules>
-        <module>android</module>
         <module>core</module>
         <module>compiler</module>
         <module>gwt</module>
diff --git a/producers/BUILD b/producers/BUILD
index df23036ab..dbc72cc7b 100644
--- a/producers/BUILD
+++ b/producers/BUILD
@@ -26,9 +26,14 @@ load(
     "PRE_JAVA_8_INFERENCE_OPTS",
 )
 
+filegroup(
+    name = "producers-srcs",
+    srcs = glob(["src/main/java/**/*.java"]),
+)
+
 java_library(
     name = "producers",
-    srcs = glob(["src/main/java/**/*.java"]),
+    srcs = [":producers-srcs"],
     javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     plugins = [
         # TODO(cgruber): Enable Beta checker.
@@ -46,6 +51,19 @@ java_library(
     ],
 )
 
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "producers-javadoc",
+    srcs = [":producers-srcs"],
+    exclude_packages = [
+        "dagger.producers.internal",
+        "dagger.producers.monitoring.internal",
+    ],
+    root_packages = ["dagger.producers"],
+    deps = [":producers"],
+)
+
 load("//:test_defs.bzl", "GenJavaTests")
 
 GenJavaTests(
diff --git a/test_defs.bzl b/test_defs.bzl
index 20ae62146..bd81669a9 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -44,7 +44,10 @@ def _GenTests(
 
   for test_file in test_files:
     test_name = test_file.replace(".java", "")
-    test_class = (PACKAGE_NAME + "/" + test_name).rpartition("src/test/java/")[2].replace("/",".")
+    prefix_path = "src/test/java/"
+    if PACKAGE_NAME.find("javatests/") != -1:
+      prefix_path = "javatests/"
+    test_class = (PACKAGE_NAME + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
     test_rule_type(
         name = test_name,
         deps = test_deps,
diff --git a/third_party/BUILD b/third_party/BUILD
index 7aa46968c..28353652d 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -16,7 +16,7 @@ package(default_visibility = ["//visibility:public"])
 
 java_library(
     name = "jsr_250",
-    exports = ["@javax_annotations_jsr250_api//jar"],
+    exports = ["@javax_annotation_jsr250_api//jar"],
 )
 
 java_library(
diff --git a/tools/AndroidManifest.xml b/tools/AndroidManifest.xml
new file mode 100644
index 000000000..b18621a3e
--- /dev/null
+++ b/tools/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<!-- A dummy AndroidManifest.xml to be used for generating Javadoc when Android sources are used -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="dummy">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/tools/BUILD b/tools/BUILD
new file mode 100644
index 000000000..8ea1fc720
--- /dev/null
+++ b/tools/BUILD
@@ -0,0 +1,71 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tools for Dagger
+
+package(default_visibility = ["//:src"])
+
+sh_library(
+    name = "javadoc_library_impl",
+    srcs = ["javadoc_library_impl.sh"],
+)
+
+sh_binary(
+    name = "jarjar_library_impl",
+    srcs = ["jarjar_library_impl.sh"],
+)
+
+sh_test(
+    name = "jarjar_library_impl_test",
+    srcs = ["jarjar_library_impl_test.sh"],
+    args = ["$(JAVABASE)"],
+    data = [
+        ":jarjar_deploy.jar",
+        ":jarjar_library_impl",
+        "//tools/testdata:bar",
+        "//tools/testdata:bar_with_dupe_file",
+        "//tools/testdata:foo",
+        "//tools/testdata:foo_with_dupe_file",
+        "@local_jdk//:bin/jar",
+        "@local_jdk//:bin/java",
+        "@local_jdk//:jre",
+    ],
+)
+
+java_binary(
+    name = "jarjar",
+    main_class = "org.pantsbuild.jarjar.Main",
+    runtime_deps = [
+        "@javax_annotation_jsr250_api//jar",
+        "@javax_enterprise_cdi_api//jar",
+        "@javax_inject_javax_inject//jar",
+        "@org_apache_ant_ant//jar",
+        "@org_apache_ant_ant_launcher//jar",
+        "@org_apache_maven_maven_artifact//jar",
+        "@org_apache_maven_maven_model//jar",
+        "@org_apache_maven_maven_plugin_api//jar",
+        "@org_codehaus_plexus_plexus_classworlds//jar",
+        "@org_codehaus_plexus_plexus_component_annotations//jar",
+        "@org_codehaus_plexus_plexus_utils//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_inject//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_plexus//jar",
+        "@org_ow2_asm_asm//jar",
+        "@org_ow2_asm_asm_commons//jar",
+        "@org_ow2_asm_asm_tree//jar",
+        "@org_pantsbuild_jarjar//jar",
+    ],
+)
+
+exports_files(["AndroidManifest.xml"])
diff --git a/tools/jarjar.bzl b/tools/jarjar.bzl
new file mode 100644
index 000000000..17e1aed31
--- /dev/null
+++ b/tools/jarjar.bzl
@@ -0,0 +1,140 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def jarjar_deps():
+  """
+  Deps that are necessary to build jarjar_binary() but aren't used in the regular build process for
+  Dagger, so they are organized separately from the workspace file.
+  """
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_utils",
+      artifact = "org.codehaus.plexus:plexus-utils:3.0.20",
+      sha1 = "e121ed37af8ee3928952f6d8a303de24e019aab0",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_plexus",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.0",
+      sha1 = "3f53953a998d03b9b0f7d5098f63119e434af0ef",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant_launcher",
+      artifact = "org.apache.ant:ant-launcher:1.9.6",
+      sha1 = "d75dd4c39ba06401f20e7afffb861d268baec6bc",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_plugin_api",
+      artifact = "org.apache.maven:maven-plugin-api:3.3.3",
+      sha1 = "3b78a7e40707be313c4d5449ba514c9747e1c731",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_inject",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.inject:0.3.0",
+      sha1 = "6c25adce9ca9af097728ed57834e8807e3b6e2b5",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm",
+      artifact = "org.ow2.asm:asm:5.0.4",
+      sha1 = "0da08b8cce7bbf903602a25a3a163ae252435795",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_tree",
+      artifact = "org.ow2.asm:asm-tree:5.0.4",
+      sha1 = "396ce0c07ba2b481f25a70195c7c94922f0d1b0b",
+  )
+
+  native.maven_jar(
+      name = "javax_enterprise_cdi_api",
+      artifact = "javax.enterprise:cdi-api:1.0",
+      sha1 = "44c453f60909dfc223552ace63e05c694215156b",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_commons",
+      artifact = "org.ow2.asm:asm-commons:5.0.4",
+      sha1 = "5a556786086c23cd689a0328f8519db93821c04c",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_model",
+      artifact = "org.apache.maven:maven-model:3.3.3",
+      sha1 = "73ba535c2e3a1381aeab131598010b3a723d4b47",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_artifact",
+      artifact = "org.apache.maven:maven-artifact:3.3.3",
+      sha1 = "d9f439dfef726e54eebb390ff38dd27356901528",
+  )
+
+  native.maven_jar(
+      name = "org_pantsbuild_jarjar",
+      artifact = "org.pantsbuild:jarjar:1.6.3",
+      sha1 = "cf54d4b142f5409c394095181c8d308a81869622",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_classworlds",
+      artifact = "org.codehaus.plexus:plexus-classworlds:2.5.2",
+      sha1 = "4abb111bfdace5b8167db4c0ef74644f3f88f142",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant",
+      artifact = "org.apache.ant:ant:1.9.6",
+      sha1 = "80e2063b01bab3c79c2d84e4ed5e73868394c85a",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_component_annotations",
+      artifact = "org.codehaus.plexus:plexus-component-annotations:1.5.5",
+      sha1 = "c72f2660d0cbed24246ddb55d7fdc4f7374d2078",
+  )
+
+def jarjar_library(name, deps, rules_file):
+  """
+  Combines `deps` into one jar file named <name>.jar and jarjar with the rules specified in
+  `rules_file`.
+
+  See: https://github.com/pantsbuild/jarjar
+  """
+  native.genrule(
+      name = name,
+      srcs = deps + [
+          rules_file,
+          "//tools:jarjar_deploy.jar",
+      ],
+      tools = [
+          "//tools:jarjar_library_impl",
+          "@local_jdk//:bin/jar",
+          "@local_jdk//:bin/java",
+          "@local_jdk//:jre",
+      ],
+      outs = [name + ".jar"],
+      cmd = """
+      export JAVA_HOME=$(JAVABASE)
+      $(location //tools:jarjar_library_impl) $@ "{deps}" {rules} \
+        $(location //tools:jarjar_deploy.jar) \
+        $$(readlink $(location @local_jdk//:bin/jar)) \
+        $$(readlink $(location @local_jdk//:bin/java)) \
+        $(@D)
+      """.format(
+          deps=" ".join(["$(location %s)" % dep for dep in deps]),
+          rules="$(location %s)" % rules_file),
+  )
diff --git a/tools/jarjar_library_impl.sh b/tools/jarjar_library_impl.sh
new file mode 100755
index 000000000..357628d14
--- /dev/null
+++ b/tools/jarjar_library_impl.sh
@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+if [[ ! $JAVA_HOME =~ ^/ ]]; then
+  JAVA_HOME=$(readlink -f $JAVA_HOME)
+fi
+
+OUT=$1
+DEPS=$2
+RULES_FILE=$3
+JARJAR=$4
+JAR_BINARY=$5
+JAVA_BINARY=$6
+TMPDIR=$7/combined
+
+mkdir -p $TMPDIR
+for dep in $DEPS; do
+  unzip -B $dep -d $TMPDIR
+done
+pushd $TMPDIR
+
+# Concatenate similar files in META-INF/services
+for file in META-INF/services/*; do
+  original=$(echo $file | sed s/"~[0-9]*$"//)
+  if [[ "$file" != "$original" ]]; then
+    cat $file >> $original
+    rm $file
+  fi
+done
+
+rm META-INF/MANIFEST.MF*
+rm -rf META-INF/maven/
+duplicate_files=$(find * -type f -regex ".*~[0-9]*$")
+if [[ -n "$duplicate_files" ]]; then
+  echo "Error: duplicate files in merged jar: $duplicate_files"
+  exit 1
+fi
+$JAR_BINARY cvf combined.jar *
+
+popd
+
+$JAVA_BINARY -jar $JARJAR process $RULES_FILE $TMPDIR/combined.jar $OUT
+rm -rf $TMPDIR
diff --git a/tools/jarjar_library_impl_test.sh b/tools/jarjar_library_impl_test.sh
new file mode 100755
index 000000000..edc65d44c
--- /dev/null
+++ b/tools/jarjar_library_impl_test.sh
@@ -0,0 +1,60 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+export JAVA_HOME=$(readlink -f $1)
+
+set -eu
+
+JAR_BINARY="$(readlink external/local_jdk/bin/jar)"
+JAVA_BINARY="$(readlink external/local_jdk/bin/java)"
+
+report_bad_output() {
+  $JAR_BINARY tf output.jar
+  echo $1
+  exit 1
+}
+
+ROOT=$TEST_SRCDIR/$TEST_WORKSPACE
+
+cd $TEST_TMPDIR
+
+echo "rule foo.** baz.@1" > rules_file
+
+$ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo.jar $ROOT/tools/testdata/libbar.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."
+if $JAR_BINARY  tf output.jar | grep -F -q foo/Foo.class; then
+  report_bad_output "Expected foo/Foo.class to be renamed to baz/Foo.class"
+elif ! $JAR_BINARY tf output.jar | grep -F -q baz/Foo.class; then
+  report_bad_output "Expected baz/Foo.class to be in the output jar"
+fi
+
+if $ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo_with_dupe_file.jar $ROOT/tools/testdata/libbar_with_dupe_file.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."; then
+  report_bad_output 'Expected duplicate file "dupe"'
+fi
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
new file mode 100644
index 000000000..4331f9a17
--- /dev/null
+++ b/tools/javadoc.bzl
@@ -0,0 +1,107 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def _check_non_empty(value, name):
+  if not value:
+    fail("%s must be non-empty" % name)
+
+def javadoc_library(
+    name,
+    srcs = [],
+    deps = [],
+    root_packages = [],
+    exclude_packages = [],
+    android_api_level = None,
+    doctitle = None):
+  """
+  Generates a Javadoc jar $GENDIR/path/to/target/<name>.jar.
+
+  Arguments:
+    srcs: source files to process
+    deps: targets that contain references to other types referenced in Javadoc. This can be the
+        java_library/android_library target(s) for the same sources
+    root_packages: Java packages to include in generated Javadoc. Any subpackages not listed in
+        exclude_packages will be included as well
+    exclude_packages: Java packages to exclude from generated Javadoc
+    android_api_level: If Android APIs are used, the API level to compile against to generate
+        Javadoc
+    doctitle: title for Javadoc's index.html. See javadoc -doctitle
+  """
+  _check_non_empty(srcs, "srcs")
+  _check_non_empty(root_packages, "root_packages")
+
+  exclude_packages_option = ""
+  if exclude_packages:
+    exclude_packages_option = "-exclude " + ":".join(exclude_packages)
+
+  deploy_jar_name = name + "_deploy_jar_for_javadoc"
+  deploy_jar_label = ":%s_deploy.jar" % deploy_jar_name
+
+  genrule_srcs = srcs + deps + [
+      deploy_jar_label,
+      "//tools:javadoc_library_impl"
+  ]
+
+  bootclasspath_option = ""
+  if android_api_level:
+    native.android_binary(
+        name = deploy_jar_name,
+        deps = deps,
+        manifest = "//tools:AndroidManifest.xml",
+        custom_package = "dummy",
+        tags = ["manual"],
+    )
+    android_jar = "@androidsdk//:platforms/android-%s/android.jar" % android_api_level
+    genrule_srcs.append(android_jar)
+    bootclasspath_option = "-bootclasspath $(location %s)" % android_jar
+  else:
+    native.java_binary(
+        name = deploy_jar_name,
+        runtime_deps = deps,
+        main_class = "dummy",
+        tags = ["manual"],
+    )
+
+  doctitle_option = ""
+  if doctitle:
+    doctitle_option = "-doctitle \"%s\"" % doctitle
+
+  external_javadoc_links = [
+      "https://docs.oracle.com/javase/8/docs/api/",
+      "https://developer.android.com/reference/",
+      "https://google.github.io/guava/releases/21.0/api/docs/",
+      "https://docs.oracle.com/javaee/7/api/"
+  ]
+
+  linkoffline_options = ' '.join(
+      ["-linkoffline {0} {0}".format(url) for url in external_javadoc_links])
+
+  native.genrule(
+      name = name,
+      srcs = genrule_srcs,
+      outs = [name + ".jar"],
+      tools = ["@local_jdk//:bin/javadoc", "@local_jdk//:bin/jar"],
+      cmd = """
+$(location //tools:javadoc_library_impl) \
+  "$(location @local_jdk//:bin/javadoc)" "$(location @local_jdk//:bin/jar)" "$@" \
+  "{include_packages}" "{exclude_packages}" "$(location {deploy_jar})" "{bootclasspath}" \
+  "{linkoffline}" "{doctitle}" "$(@D)"
+      """.format(
+          deploy_jar=deploy_jar_label,
+          include_packages=":".join(root_packages),
+          exclude_packages=exclude_packages_option,
+          bootclasspath=bootclasspath_option,
+          doctitle=doctitle_option,
+          linkoffline=linkoffline_options)
+  )
diff --git a/tools/javadoc_library_impl.sh b/tools/javadoc_library_impl.sh
new file mode 100755
index 000000000..2990e614b
--- /dev/null
+++ b/tools/javadoc_library_impl.sh
@@ -0,0 +1,47 @@
+#!/usr/bin/env sh
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+JAVADOC_BINARY=$1
+JAR_BINARY=$2
+OUTPUT=$3
+INCLUDE_PACKAGES=$4
+EXCLUDE_PACKAGES=$5
+DEPLOY_JAR=$6
+BOOTCLASSPATH=$7
+LINKOFFLINE=$8
+DOCTITLE=$9
+TEMPDIR=$10/tmp
+
+mkdir -p $TEMPDIR
+
+$JAVADOC_BINARY \
+  -sourcepath $(find * -type d -regex ".*java" -print0 | tr '\0' :) \
+  $INCLUDE_PACKAGES \
+  -use \
+  -subpackages $INCLUDE_PACKAGES \
+  -encoding UTF8 \
+  $EXCLUDE_PACKAGES \
+  -classpath $DEPLOY_JAR \
+  $BOOTCLASSPATH \
+  $LINKOFFLINE \
+  -notimestamp \
+  $DOCTITLE \
+  -bottom "Copyright &copy; 2012–2017 The Dagger Authors. All rights reserved." \
+  -d $TEMPDIR
+
+$JAR_BINARY cvf $OUTPUT -C $TEMPDIR $TEMPDIR/*
+rm -rf $TEMPDIR
+
diff --git a/android/BUILD b/tools/testdata/BUILD
similarity index 55%
rename from android/BUILD
rename to tools/testdata/BUILD
index 6c0714ec9..b994ff545 100644
--- a/android/BUILD
+++ b/tools/testdata/BUILD
@@ -13,13 +13,32 @@
 # limitations under the License.
 
 # Description:
-#   Public Dagger API for Android
+#   Tools for Dagger
 
 package(default_visibility = ["//:src"])
 
-android_library(
-    name = "android",
-    exports = [
-        "//android/src/main/java/dagger/android",
-    ],
+java_library(
+    name = "foo",
+    srcs = ["Foo.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "foo_with_dupe_file",
+    srcs = ["Foo.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar",
+    srcs = ["Bar.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar_with_dupe_file",
+    srcs = ["Bar.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
 )
diff --git a/tools/testdata/Bar.java b/tools/testdata/Bar.java
new file mode 100644
index 000000000..e040e39fd
--- /dev/null
+++ b/tools/testdata/Bar.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package bar;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Bar {}
diff --git a/tools/testdata/Foo.java b/tools/testdata/Foo.java
new file mode 100644
index 000000000..f2305c83a
--- /dev/null
+++ b/tools/testdata/Foo.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package foo;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Foo {}
diff --git a/tools/testdata/dupe b/tools/testdata/dupe
new file mode 100644
index 000000000..b68619fc0
--- /dev/null
+++ b/tools/testdata/dupe
@@ -0,0 +1 @@
+duped data file
