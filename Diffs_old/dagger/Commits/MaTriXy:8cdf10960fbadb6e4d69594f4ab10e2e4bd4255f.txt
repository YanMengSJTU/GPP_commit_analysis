diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 000000000..53601b25d
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/dagger"
+JDK="oraclejdk7" # Dagger integration tests fail on JDK 8 :(
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 000000000..91f444b22
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.travis.yml b/.travis.yml
index 2420f9823..b8ca0754d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,26 +1,37 @@
-language: java
+language: android
+
+android:
+  components:
+    - build-tools-20.0.0
+    - android-16
+  licenses:
+    - android-sdk-license-5be876d5
 
 jdk:
   - oraclejdk7
-  - openjdk7 
-
-before_install:
-  - sudo apt-get update -qq
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
-  - echo "Installing android SDK into ${PWD}/android-sdk-linux"
-  - tar -xzf android-sdk_r21.0.1-linux.tgz
-  - export ANDROID_HOME=${PWD}/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  - android update sdk --filter platform-tools,android-16 --no-ui --force
+  # - oraclejdk8 Dagger integration tests fail with JDK 8 :(
 
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-script: mvn verify 
+script: mvn verify
 
-notifications:
-  email: false
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "MhR0Wr+bSbdyO6a6CM2MVHLwmFZoi8ZWWncMCNSi8/xdRoykpC1HkwJjQK+HJv7j3VNbVTPNJ/yTpzJsL4JV9aTF/S28mka8GmHSmQSeQzTuNMqnE30GDbhS3S73azGHvC9/wjh1mAA0Gz/zUX/rzCYvDVZ/DmK1HppomN+P32A="
+    - secure: "fnHK/ei7tdcUDlQZcXWVPRgXoIFv6h0TWSzz4spgNtFlYqa47Qr4HQOLyEpWRqZHjgfR5eXD+CCI049Z73cg5oVOp1krV0aGX/wHc5lDMJuCrBZ/YoWZnDygiPzM4CvrpxRE7DjqzC0InVdbEbuECiFsI2WotLdQ6efgaxjpZCk="
 
 branches:
   except:
     - gh-pages
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b2e20e941..40dc58db7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,35 @@
 Change Log
 ==========
 
+Version 1.2.2 *(2014-07-21)*
+----------------------------
+
+ * Update JavaWriter to 2.5.0. This fixes incorrectly compressing fully-qualified class names
+   in child packages of `java.lang` (e.g., `java.lang.ref.WeakReference`).
+
+
+Version 1.2.1 *(2014-02-16)*
+----------------------------
+
+ * Restore Java 5 compatibility.
+ * New: Improve performance of `.plus()` with large volumes of set bindings.
+ * Fix: Do not mask underlying exception message from binding problems when constructing a graph.
+
+
+Version 1.2.0 *(2013-12-13)*
+----------------------------
+
+ * Numerous performance improvements in both the compiler and runtime.
+   * Use more efficient `String` concatenation.
+   * Module adapters are now stateless.
+   * Use read/write locks over global locks.
+   * Reflective constructor invocation is now cached with `Class.newInstance`.
+   * Avoid re-linking all bindings when calling `.plus()`.
+ * Set bindings are now unioned when calling `.plus()`.
+ * Fix: Tolerate missing type information during compilation by deferring writing
+   module adapters.
+
+
 Version 1.1.0 *(2013-08-05)*
 ----------------------------
 
diff --git a/README.md b/README.md
index 290c7162e..02f4072a9 100644
--- a/README.md
+++ b/README.md
@@ -36,7 +36,9 @@ dependency:
 ```
 
 You can also find downloadable .jars on Maven Central. You'll need
-[Dagger][dl-dagger], [JavaWriter][dl-javawriter], and [javax.inject][dl-inject].
+[Dagger][dl-dagger], [JavaPoet][dl-javapoet], and [javax.inject][dl-inject].
+
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
 
 
@@ -61,5 +63,6 @@ License
 
  [1]: http://square.github.com/dagger/
  [dl-dagger]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.dagger%22%20a%3A%22dagger%22
- [dl-javawriter]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javawriter%22
+ [dl-javapoet]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javapoet%22
  [dl-inject]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22javax.inject%22%20a%3A%22javax.inject%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/checkstyle.xml b/checkstyle.xml
index 7dfd69c8c..6c0b11e3d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,134 +1,135 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-    <!--module name="NewlineAtEndOfFile"/-->
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
-
-    <!-- Trailing spaces -->
-    <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
-    </module>
-
-    <!-- Space after 'for' and 'if' -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*(for|if)[^ ]"/>
-        <property name="message" value="Space needed before opening parenthesis."/>
-    </module>
-
-    <!-- For each spacing -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-        <property name="message" value="Space needed around ':' character."/>
-    </module>
-
-    <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <!--module name="JavadocMethod"/-->
-        <!--module name="JavadocType"/-->
-        <!--module name="JavadocVariable"/-->
-        <!--module name="JavadocStyle"/-->
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <!--<module name="ConstantName"/>-->
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-            <property name="max" value="100"/>
-        </module>
-        <module name="MethodLength">
-            <property name="max" value="200"/>
-        </module>
-            
-        <!--module name="ParameterNumber"/-->
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!--module name="ModifierOrder"/-->
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <!--module name="AvoidNestedBlocks"/-->
-        <!--module name="EmptyBlock"/-->
-        <module name="LeftCurly"/>
-        <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="EmptyStatement"/>
-        <!--<module name="EqualsAvoidNull"/>-->
-        <module name="EqualsHashCode"/>
-        <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
-        <!--<module name="InnerAssignment"/>-->
-        <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <!--module name="DesignForExtension"/-->
-        <!--module name="FinalClass"/-->
-        <!--module name="HideUtilityClassConstructor"/-->
-        <!--module name="InterfaceIsType"/-->
-        <!--module name="VisibilityModifier"/-->
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <!--module name="ArrayTypeStyle"/-->
-        <!--module name="FinalParameters"/-->
-        <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
-    </module>
-</module>
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <!--module name="NewlineAtEndOfFile"/-->
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <!--module name="JavadocStyle"/-->
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!--<module name="ConstantName"/>-->
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports">
+            <property name="processJavadoc" value="true"/>
+        </module>
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="100"/>
+        </module>
+        <module name="MethodLength">
+            <property name="max" value="200"/>
+        </module>
+            
+        <!--module name="ParameterNumber"/-->
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!--module name="ModifierOrder"/-->
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <!--module name="AvoidNestedBlocks"/-->
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--module name="NeedBraces"/-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--<module name="InnerAssignment"/>-->
+        <!--module name="MagicNumber"/-->
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--module name="FinalClass"/-->
+        <!--module name="HideUtilityClassConstructor"/-->
+        <!--module name="InterfaceIsType"/-->
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <!--module name="ArrayTypeStyle"/-->
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
diff --git a/compiler/pom.xml b/compiler/pom.xml
index e9a329299..88100674b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -39,7 +39,11 @@
     </dependency>
     <dependency>
       <groupId>com.squareup</groupId>
-      <artifactId>javawriter</artifactId>
+      <artifactId>javapoet</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
     </dependency>
 
     <dependency>
@@ -62,13 +66,11 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.1</version>
       <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
-      <version>0.13</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
@@ -127,6 +129,24 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
index c525ea3f3..33c73aa39 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
@@ -15,6 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+
 /**
  * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
  * and {@code ModuleAdapterProcessor}.
@@ -23,46 +26,46 @@
   static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
   static final String MEMBERS_INJECT_METHOD = ""
       + "Injects any {@code @Inject} annotated fields in the given instance,\n"
-      + "satisfying the contract for {@code Provider<%s>}.";
+      + "satisfying the contract for {@code Provider<$T>}.\n";
   static final String GET_METHOD = ""
       + "Returns the fully provisioned instance satisfying the contract for\n"
-      + "{@code Provider<%s>}.";
+      + "{@code Provider<$T>}.\n";
   static final String GET_DEPENDENCIES_METHOD = ""
       + "Used internally obtain dependency information, such as for cyclical\n"
-      + "graph detection.";
+      + "graph detection.\n";
   static final String ATTACH_METHOD = ""
       + "Used internally to link bindings/providers together at run time\n"
-      + "according to their dependency graph.";
+      + "according to their dependency graph.\n";
   static final String STATIC_INJECT_METHOD = ""
       + "Performs the injections of dependencies into static fields when requested by\n"
-      + "the {@code dagger.ObjectGraph}.";
+      + "the {@code $T}.\n";
   static final String MODULE_TYPE = ""
       + "A manager of modules and provides adapters allowing for proper linking and\n"
-      + "instance provision of types served by {@code @Provides} methods.";
+      + "instance provision of types served by {@code @$T} methods.\n";
   static final String STATIC_INJECTION_TYPE = ""
-      + "A manager for {@code %s}'s injections into static fields.";
+      + "A manager for {@code $T}'s injections into static fields.\n";
 
   /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String bindingTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
-    StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binding<").append(type).append(">} implementation which satisfies\n");
-    sb.append("Dagger's infrastructure requirements including:");
+  static CodeBlock bindingTypeDocs(
+      TypeName type, boolean abstrakt, boolean members, boolean dependent) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("A {@code Binding<$T>} implementation which satisfies\n", type)
+        .add("Dagger's infrastructure requirements including:\n");
     if (dependent) {
-      sb.append("\n\n");
-      sb.append("Owning the dependency links between {@code " + type + "} and its\n");
-      sb.append("dependencies.");
+      result.add("\n")
+          .add("Owning the dependency links between {@code $T} and its\n", type)
+          .add("dependencies.\n");
     }
     if (!abstrakt) {
-      sb.append("\n\n");
-      sb.append("Being a {@code Provider<" + type + ">} and handling creation and\n");
-      sb.append("preparation of object instances.");
+      result.add("\n")
+          .add("Being a {@code Provider<$T>} and handling creation and\n", type)
+          .add("preparation of object instances.\n");
     }
     if (members) {
-      sb.append("\n\n");
-      sb.append("Being a {@code MembersInjector<" + type + ">} and handling injection\n");
-      sb.append("of annotated fields.");
+      result.add("\n")
+          .add("Being a {@code MembersInjector<$T>} and handling injection\n", type)
+          .add("of annotated fields.\n");
     }
-    return sb.toString();
+    return result.build();
   }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index 8fd401af1..c3cd022d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -54,7 +54,7 @@ public GraphAnalysisLoader(ProcessingEnvironment processingEnv) {
     return GraphAnalysisInjectBinding.create(type, mustHaveInjections);
   }
 
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
     throw new UnsupportedOperationException();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index cb2d34f19..d009f75da 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -19,9 +19,12 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Binding.InvalidBindingException;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -55,16 +58,20 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.Util.className;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.methodName;
+import static java.util.Arrays.asList;
 
 /**
  * Performs full graph analysis on a module.
  */
 @SupportedAnnotationTypes("dagger.Module")
 public final class GraphAnalysisProcessor extends AbstractProcessor {
+  private static final Set<String> ERROR_NAMES_TO_PROPAGATE = new LinkedHashSet<String>(asList(
+      "com.sun.tools.javac.code.Symbol$CompletionFailure"));
+
   private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
 
   @Override public SourceVersion getSupportedSourceVersion() {
@@ -95,9 +102,14 @@
     }
 
     for (Element element : modules) {
-      Map<String, Object> annotation = getAnnotation(Module.class, element);
-      TypeElement moduleType = (TypeElement) element;
+      Map<String, Object> annotation = null;
+      try {
+        annotation = getAnnotation(Module.class, element);
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // skip this element. An up-stream compiler error is in play.
+      }
 
+      TypeElement moduleType = (TypeElement) element;
       if (annotation == null) {
         error("Missing @Module annotation.", moduleType);
         continue;
@@ -114,7 +126,11 @@
           error("Graph validation failed: " + e.getMessage(), elements().getTypeElement(e.type));
           continue;
         } catch (RuntimeException e) {
-          error("Graph validation failed: " + e.getMessage(), moduleType);
+          if (ERROR_NAMES_TO_PROPAGATE.contains(e.getClass().getName())) {
+            throw e;
+          }
+          error("Unknown error " + e.getClass().getName() + " thrown by javac in graph validation: "
+              + e.getMessage(), moduleType);
           continue;
         }
         try {
@@ -158,19 +174,30 @@ private void error(String message, Element element) {
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
     synchronized (linker) {
-      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
+      BindingsGroup baseBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          return super.put(key, value);
+        }
+      };
+      BindingsGroup overrideBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          throw new IllegalStateException("Module overrides cannot contribute set bindings.");
+        }
+      };
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
         boolean library = (Boolean) annotation.get("library");
-        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
+        BindingsGroup addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
+        Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
         for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
           TypeMirror injectableType = (TypeMirror) injectableTypeObject;
+          String providerKey = GeneratorKeys.get(injectableType);
+          injectsProvisionKeys.add(providerKey);
           String key = isInterface(injectableType)
-              ? GeneratorKeys.get(injectableType)
+              ? providerKey
               : GeneratorKeys.rawMembersKey(injectableType);
           linker.requestBinding(key, module.getQualifiedName().toString(),
               getClass().getClassLoader(), false, true);
@@ -191,9 +218,9 @@ private void error(String message, Element element) {
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          Binding binding = new ProviderMethodBinding(key, providerMethod, library);
+          ProvidesBinding<?> binding = new ProviderMethodBinding(key, providerMethod, library);
 
-          Binding previous = addTo.get(key);
+          Binding<?> previous = addTo.get(key);
           if (previous != null) {
             if ((provides.type() == SET || provides.type() == SET_VALUES)
                 && previous instanceof SetBinding) {
@@ -210,7 +237,14 @@ private void error(String message, Element element) {
 
           switch (provides.type()) {
             case UNIQUE:
-              addTo.put(key, binding);
+              if (injectsProvisionKeys.contains(binding.provideKey)) {
+                binding.setDependedOn(true);
+              }
+              try {
+                addTo.contributeProvidesBinding(key, binding);
+              } catch (IllegalStateException ise) {
+                throw new ModuleValidationException(ise.getMessage(), providerMethod);
+              }
               break;
 
             case SET:
@@ -244,11 +278,6 @@ private Elements elements() {
     return processingEnv.getElementUtils();
   }
 
-  private String shortMethodName(ExecutableElement method) {
-    return method.getEnclosingElement().getSimpleName().toString()
-        + "." + method.getSimpleName() + "()";
-  }
-
   void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = getAnnotation(Module.class, module);
@@ -297,12 +326,13 @@ void collectIncludesRecursively(
     }
   }
 
-  static class ProviderMethodBinding extends Binding<Object> {
+  static class ProviderMethodBinding extends ProvidesBinding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, methodName(method));
+      super(provideKey, method.getAnnotation(Singleton.class) != null,
+          className(method), method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
@@ -328,6 +358,11 @@ protected ProviderMethodBinding(String provideKey, ExecutableElement method, boo
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       Collections.addAll(get, parameters);
     }
+
+    @Override public String toString() {
+      return "ProvidesBinding[key=" + provideKey
+          + " method=" + moduleClass + "." + method.getSimpleName() + "()";
+    }
   }
 
   void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
@@ -343,9 +378,9 @@ void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws I
   }
 
   static class ModuleValidationException extends IllegalStateException {
-    final TypeElement source;
+    final Element source;
 
-    public ModuleValidationException(String message, TypeElement source) {
+    public ModuleValidationException(String message, Element source) {
       super(message);
       this.source = source;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index a9a90fe8e..a0fe29ce7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -17,11 +17,13 @@
 
 import dagger.internal.Binding;
 import java.io.IOException;
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -49,7 +51,7 @@ public void write(Map<String, Binding<?>> bindings, GraphVizWriter writer) throw
     for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
       Binding<?> sourceBinding = entry.getKey();
       String sourceName = entry.getValue();
-      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
+      Set<Binding<?>> dependencies = new TreeSet<Binding<?>>(new BindingComparator());
       sourceBinding.getDependencies(dependencies, dependencies);
       for (Binding<?> targetBinding : dependencies) {
         String targetName = namesIndex.get(targetBinding);
@@ -122,4 +124,16 @@ String shortName(String key) {
 
     return result.toString();
   }
+
+  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
+  private static class BindingComparator implements Comparator<Binding<?>> {
+    @Override
+    public int compare(Binding<?> left, Binding<?> right) {
+      return getStringForBinding(left).compareTo(getStringForBinding(right));
+    }
+
+    private String getStringForBinding(Binding<?> binding) {
+      return binding == null ? "" : binding.toString();
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
index d149d167e..fcfd25202 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.CodeBlock;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
@@ -128,7 +128,11 @@ private String nodeName(String name) throws IOException {
   }
 
   private String literal(String raw) {
-    return raw.matches("\\w+") ? raw : JavaWriter.stringLiteral(raw);
+    if (raw.matches("\\w+")) return raw;
+    return CodeBlock.builder()
+        .add("$S", raw)
+        .build()
+        .toString();
   }
 
   private void indent() throws IOException {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index dca009de6..e06002e1c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -16,16 +16,20 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.MembersInjector;
+import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -45,17 +49,18 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
 
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.Util.SET_OF_BINDINGS;
 import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.bindingOf;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getApplicationSupertype;
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
+import static dagger.internal.codegen.Util.injectableType;
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -239,12 +244,10 @@ private InjectedClass createInjectedClass(String injectedClassName) {
   private void generateInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
     String packageName = getPackage(type).getQualifiedName().toString();
-    String strippedTypeName =
-        strippedTypeName(type.getQualifiedName().toString(), packageName);
     TypeMirror supertype = getApplicationSupertype(type);
-    String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    ClassName injectedClassName = ClassName.get(type);
+    ClassName adapterClassName = adapterName(injectedClassName, INJECT_ADAPTER_SUFFIX);
+
     boolean isAbstract = type.getModifiers().contains(ABSTRACT);
     boolean injectMembers = !fields.isEmpty() || supertype != null;
     boolean disambiguateFields = !fields.isEmpty()
@@ -253,252 +256,226 @@ private void generateInjectAdapter(TypeElement type, ExecutableElement construct
     boolean dependent = injectMembers
         || ((constructor != null) && !constructor.getParameters().isEmpty());
 
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(packageName);
-    writer.emitImports(findImports(dependent, injectMembers, constructor != null));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(Binding.class, strippedTypeName),
-        implementedInterfaces(strippedTypeName, injectMembers, constructor != null));
-    writeMemberBindingsFields(writer, fields, disambiguateFields);
+    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addModifiers(PUBLIC, FINAL)
+        .superclass(ParameterizedTypeName.get(ClassName.get(Binding.class), injectedClassName))
+        .addJavadoc("$L", bindingTypeDocs(injectableType(type.asType()), isAbstract,
+            injectMembers, dependent).toString());
+
+    if (constructor != null) {
+      result.addSuperinterface(ParameterizedTypeName.get(
+          ClassName.get(Provider.class), injectedClassName));
+    }
+    if (injectMembers) {
+      result.addSuperinterface(ParameterizedTypeName.get(
+          ClassName.get(MembersInjector.class), injectedClassName));
+    }
+
+    for (Element field : fields) {
+      result.addField(memberBindingField(disambiguateFields, field));
+    }
     if (constructor != null) {
-      writeParameterBindingsFields(writer, constructor, disambiguateFields);
-     }
+      for (VariableElement parameter : constructor.getParameters()) {
+        result.addField(parameterBindingField(disambiguateFields, parameter));
+      }
+    }
     if (supertype != null) {
-      writeSupertypeInjectorField(writer, supertype);
+      result.addField(supertypeBindingField(supertype));
     }
-    writer.emitEmptyLine();
-    writeInjectAdapterConstructor(writer, constructor, type, strippedTypeName, adapterName);
+
+    result.addMethod(writeInjectAdapterConstructor(constructor, type, injectedClassName));
     if (dependent) {
-      writeAttachMethod(writer, constructor, fields, disambiguateFields, strippedTypeName,
-          supertype, true);
-      writeGetDependenciesMethod(writer, constructor, fields, disambiguateFields, supertype, true);
+      result.addMethod(attachMethod(
+          constructor, fields, disambiguateFields, injectedClassName, supertype, true));
+      result.addMethod(getDependenciesMethod(
+          constructor, fields, disambiguateFields, supertype, true));
     }
     if (constructor != null) {
-      writeGetMethod(writer, constructor, disambiguateFields, injectMembers, strippedTypeName);
+      result.addMethod(
+          getMethod(constructor, disambiguateFields, injectMembers, injectedClassName));
     }
     if (injectMembers) {
-      writeMembersInjectMethod(writer, fields, disambiguateFields, strippedTypeName, supertype);
+      result.addMethod(
+          membersInjectMethod(fields, disambiguateFields, injectedClassName, supertype));
     }
-    writer.endType();
-    writer.close();
+
+    JavaFile javaFile = JavaFile.builder(packageName, result.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+    javaFile.writeTo(processingEnv.getFiler());
   }
 
   /**
    * Write a companion class for {@code type} that extends {@link StaticInjection}.
    */
   private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
-    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(Arrays.asList(
-        StaticInjection.class.getName(),
-        Binding.class.getName(),
-        Linker.class.getName()));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(
-        adapterName, "class", EnumSet.of(PUBLIC, FINAL), StaticInjection.class.getSimpleName());
-    writeMemberBindingsFields(writer, fields, false);
-    writer.emitEmptyLine();
-    writeAttachMethod(writer, null, fields, false, typeName, null, true);
-    writeStaticInjectMethod(writer, fields, typeName);
-    writer.endType();
-    writer.close();
-  }
-
-  private void writeMemberBindingsFields(
-      JavaWriter writer, List<Element> fields, boolean disambiguateFields) throws IOException {
+    ClassName typeName = ClassName.get(type);
+    ClassName adapterClassName = adapterName(ClassName.get(type), STATIC_INJECTION_SUFFIX);
+
+    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type)
+        .addModifiers(PUBLIC, FINAL)
+        .superclass(StaticInjection.class);
     for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
-          fieldName(disambiguateFields, field), EnumSet.of(PRIVATE));
+      result.addField(memberBindingField(false, field));
     }
+    result.addMethod(attachMethod(null, fields, false, typeName, null, true));
+    result.addMethod(staticInjectMethod(fields, typeName));
+
+    String packageName = getPackage(type).getQualifiedName().toString();
+    JavaFile javaFile = JavaFile.builder(packageName, result.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+    javaFile.writeTo(processingEnv.getFiler());
   }
 
-  private void writeParameterBindingsFields(
-      JavaWriter writer, ExecutableElement constructor, boolean disambiguateFields)
-      throws IOException {
-    for (VariableElement parameter : constructor.getParameters()) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          typeToString(parameter.asType())),
-          parameterName(disambiguateFields, parameter), EnumSet.of(PRIVATE));
-    }
+  private FieldSpec memberBindingField(boolean disambiguateFields, Element field) {
+    return FieldSpec.builder(bindingOf(field.asType()), fieldName(disambiguateFields, field),
+        PRIVATE).build();
+  }
+
+  private FieldSpec parameterBindingField(boolean disambiguateFields, VariableElement parameter) {
+    return FieldSpec.builder(bindingOf(parameter.asType()),
+        parameterName(disambiguateFields, parameter), PRIVATE).build();
   }
 
-  private void writeSupertypeInjectorField(JavaWriter writer, TypeMirror supertype)
-      throws IOException {
-    writer.emitField(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype",
-        EnumSet.of(PRIVATE));
+  private FieldSpec supertypeBindingField(TypeMirror supertype) {
+    return FieldSpec.builder(bindingOf(supertype), "supertype", PRIVATE).build();
   }
 
-  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
-      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
+  private MethodSpec writeInjectAdapterConstructor(ExecutableElement constructor, TypeElement type,
+      ClassName strippedTypeName) {
     String key = (constructor != null)
-        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
+        ? GeneratorKeys.get(type.asType())
         : null;
-    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
+    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
     boolean singleton = type.getAnnotation(Singleton.class) != null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
-    writer.endMethod();
-    writer.emitEmptyLine();
+
+    return MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addStatement("super($S, $S, $N, $T.class)",
+            key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName)
+        .build();
   }
 
-  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
-      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
+  private MethodSpec attachMethod(ExecutableElement constructor,
+      List<Element> fields, boolean disambiguateFields, ClassName typeName, TypeMirror supertype,
       boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
+    MethodSpec.Builder result = MethodSpec.methodBuilder("attach")
+        .addJavadoc(AdapterJavadocs.ATTACH_METHOD)
+        .addModifiers(PUBLIC)
+        .addParameter(Linker.class, "linker");
+
     if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
+      result.addAnnotation(Override.class);
     }
-    writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-    writer.beginMethod(
-        "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
+    result.addAnnotation(Util.UNCHECKED);
     if (constructor != null) {
       for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-            parameterName(disambiguateFields, parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(GeneratorKeys.get(parameter)), typeName);
+        result.addStatement(
+            "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
+            parameterName(disambiguateFields, parameter), bindingOf(parameter.asType()),
+            GeneratorKeys.get(parameter), typeName);
       }
     }
     for (Element field : fields) {
-      writer.emitStatement(
-          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-          fieldName(disambiguateFields, field),
-          writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
+      result.addStatement(
+          "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
+          fieldName(disambiguateFields, field), bindingOf(field.asType()),
+          GeneratorKeys.get((VariableElement) field), typeName);
     }
     if (supertype != null) {
-      writer.emitStatement(
-          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
+      result.addStatement(
+          "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader()"
               + ", false, true)",
           "supertype",
-          writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
-          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)), typeName);
+          bindingOf(supertype),
+          GeneratorKeys.rawMembersKey(supertype), typeName);
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
+  private MethodSpec getDependenciesMethod(ExecutableElement constructor,
       List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
       boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
+    MethodSpec.Builder result = MethodSpec.methodBuilder("getDependencies")
+        .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+        .addModifiers(PUBLIC)
+        .addParameter(SET_OF_BINDINGS, "getBindings")
+        .addParameter(SET_OF_BINDINGS, "injectMembersBindings");
+
     if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
+      result.addAnnotation(Override.class);
     }
-    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
-        setOfBindings, "injectMembersBindings");
     if (constructor != null) {
       for (Element parameter : constructor.getParameters()) {
-        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
+        result.addStatement("getBindings.add($N)", parameterName(disambiguateFields, parameter));
       }
     }
     for (Element field : fields) {
-      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
+      result.addStatement("injectMembersBindings.add($N)", fieldName(disambiguateFields, field));
     }
     if (supertype != null) {
-      writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
+      result.addStatement("injectMembersBindings.add($N)", "supertype");
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
-      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
-    StringBuilder newInstance = new StringBuilder();
-    newInstance.append(strippedTypeName).append(" result = new ");
-    newInstance.append(strippedTypeName).append('(');
+  private MethodSpec getMethod(ExecutableElement constructor, boolean disambiguateFields,
+      boolean injectMembers, ClassName injectedClassName) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("get")
+        .addJavadoc(AdapterJavadocs.GET_METHOD, injectedClassName)
+        .addAnnotation(Override.class)
+        .returns(injectedClassName)
+        .addModifiers(PUBLIC);
+
+    result.addCode("$T result = new $T(", injectedClassName, injectedClassName);
     boolean first = true;
     for (VariableElement parameter : constructor.getParameters()) {
-      if (!first) newInstance.append(", ");
+      if (!first) result.addCode(", ");
       else first = false;
-      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
+      result.addCode("$N.get()", parameterName(disambiguateFields, parameter));
     }
-    newInstance.append(')');
-    writer.emitStatement(newInstance.toString());
+    result.addCode(");\n");
     if (injectMembers) {
-      writer.emitStatement("injectMembers(result)");
+      result.addStatement("injectMembers(result)");
     }
-    writer.emitStatement("return result");
-    writer.endMethod();
-    writer.emitEmptyLine();
+    result.addStatement("return result");
+    return result.build();
   }
 
-  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
-      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
+  private MethodSpec membersInjectMethod(List<Element> fields, boolean disambiguateFields,
+      ClassName injectedClassName, TypeMirror supertype) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("injectMembers")
+        .addJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, injectedClassName)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC)
+        .addParameter(injectedClassName, "object");
     for (Element field : fields) {
-      writer.emitStatement("object.%s = %s.get()",
+      result.addStatement("object.$N = $N.get()",
           field.getSimpleName(),
           fieldName(disambiguateFields, field));
     }
     if (supertype != null) {
-      writer.emitStatement("supertype.injectMembers(object)");
+      result.addStatement("supertype.injectMembers(object)");
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
-      throws IOException {
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "inject", EnumSet.of(PUBLIC));
+  private MethodSpec staticInjectMethod(List<Element> fields, ClassName typeName) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("inject")
+        .addJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD, ObjectGraph.class)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC);
     for (Element field : fields) {
-      writer.emitStatement("%s.%s = %s.get()",
-          writer.compressType(typeName),
+      result.addStatement("$T.$N = $N.get()",
+          typeName,
           field.getSimpleName().toString(),
           fieldName(false, field));
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  private Set<String> findImports(boolean dependent, boolean injectMembers, boolean isProvider) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    if (dependent) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-    }
-    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
-    if (isProvider) imports.add(Provider.class.getCanonicalName());
-    return imports;
-  }
-
-  private String[] implementedInterfaces(
-      String strippedTypeName, boolean hasFields, boolean isProvider) {
-    List<String> interfaces = new ArrayList<String>();
-    if (isProvider) {
-      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
-    }
-    if (hasFields) {
-      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
-    }
-    return interfaces.toArray(new String[interfaces.size()]);
-  }
-
-  private String strippedTypeName(String type, String packageName) {
-    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
+    return result.build();
   }
 
   private String fieldName(boolean disambiguateFields, Element field) {
@@ -527,5 +504,4 @@ private void error(String msg, Element element) {
       this.fields = fields;
     }
   }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index a5ca6a5ab..e83a1e90c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,18 +15,26 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -47,20 +55,18 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.ARRAY_OF_CLASS;
+import static dagger.internal.codegen.Util.bindingOf;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
@@ -77,10 +83,11 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
+  private static final List<String> INVALID_RETURN_TYPES =
+      Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
+
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
-  private static final String BINDINGS_MAP = JavaWriter.type(
-      Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
 
   @Override public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
@@ -92,19 +99,23 @@
       String typeName = i.next();
       TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
       List<ExecutableElement> providesTypes = remainingTypes.get(typeName);
+
       try {
         // Attempt to get the annotation. If types are missing, this will throw
-        // IllegalStateException.
+        // CodeGenerationIncompleteException.
         Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
-        try {
-          generateModuleAdapter(type, parsedAnnotation, providesTypes);
-        } catch (IOException e) {
-          error("Code gen failed: " + e, type);
+        if (parsedAnnotation == null) {
+          error(type + " has @Provides methods but no @Module annotation", type);
+          continue;
         }
-        i.remove();
-      } catch (IllegalStateException e) {
-        // a dependent type was not defined, we'll catch it on another pass
+        JavaFile javaFile = generateModuleAdapter(type, parsedAnnotation, providesTypes);
+        javaFile.writeTo(processingEnv.getFiler());
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // A dependent type was not defined, we'll try to catch it on another pass.
+      } catch (IOException e) {
+        error("Code gen failed: " + e, type);
       }
+      i.remove();
     }
     if (env.processingOver() && remainingTypes.size() > 0) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
@@ -163,14 +174,17 @@ private void error(String msg, Element element) {
 
       // Invalidate return types.
       TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
-      for (String invalidTypeName : Arrays.asList(Provider.class.getCanonicalName(),
-          Lazy.class.getCanonicalName())) {
-        TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
-        if (invalidTypeElement != null && types.isSameType(returnType,
-            types.erasure(invalidTypeElement.asType()))) {
-          error(String.format("@Provides method must not return %s directly: %s.%s",
-              invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
-          continue provides; // Skip to next provides method.
+      if (!returnType.getKind().equals(TypeKind.ERROR)) {
+        // Validate if we have a type to validate (a type yet to be generated by other
+        // processors is not "invalid" in this way, so ignore).
+        for (String invalidTypeName : INVALID_RETURN_TYPES) {
+          TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
+          if (invalidTypeElement != null && types.isSameType(returnType,
+              types.erasure(invalidTypeElement.asType()))) {
+            error(String.format("@Provides method must not return %s directly: %s.%s",
+                invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
+            continue provides; // Skip to next provides method.
+          }
         }
       }
 
@@ -195,7 +209,7 @@ private void error(String msg, Element element) {
       TypeElement moduleType = (TypeElement) module;
 
       // Verify that all modules do not extend from non-Object types.
-      if (!moduleType.getSuperclass().equals(objectType)) {
+      if (!types.isSameType(moduleType.getSuperclass(), objectType)) {
         error("Modules must not extend from other classes: " + elementToString(module), module);
       }
 
@@ -216,181 +230,154 @@ private void error(String msg, Element element) {
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
    */
-  private void generateModuleAdapter(TypeElement type, Map<String, Object> module,
-      List<ExecutableElement> providerMethods) throws IOException {
-    if (module == null) {
-      error(type + " has @Provides methods but no @Module annotation", type);
-      return;
-    }
-
+  private JavaFile generateModuleAdapter(TypeElement type,
+      Map<String, Object> module, List<ExecutableElement> providerMethods) {
     Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] injects = (Object[]) module.get("injects");
     Object[] includes = (Object[]) module.get("includes");
-
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
     boolean library = (Boolean) module.get("library");
 
-    String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    boolean multibindings = checkForMultibindings(providerMethods);
-    boolean providerMethodDependencies = checkForDependencies(providerMethods);
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(
-        findImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
-
-    String typeName = type.getQualifiedName().toString();
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.MODULE_TYPE);
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(ModuleAdapter.class, typeName));
-
-    StringBuilder injectsField = new StringBuilder().append("{ ");
-    for (Object injectableType : injects) {
-      TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = isInterface(typeMirror)
-          ? GeneratorKeys.get(typeMirror)
-          : GeneratorKeys.rawMembersKey(typeMirror);
-      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
-    }
-    injectsField.append("}");
-    writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        injectsField.toString());
-
-    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
-    for (Object staticInjection : staticInjections) {
-      TypeMirror typeMirror = (TypeMirror) staticInjection;
-      staticInjectionsField.append(typeToString(typeMirror)).append(".class, ");
-    }
-    staticInjectionsField.append("}");
-    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        staticInjectionsField.toString());
-
-    StringBuilder includesField = new StringBuilder().append("{ ");
-    for (Object include : includes) {
-      if (!(include instanceof TypeMirror)) {
-        // TODO(tbroyer): pass annotation information
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value: " + include + " in includes of " + type, type);
-        continue;
-      }
-      TypeMirror typeMirror = (TypeMirror) include;
-      includesField.append(typeToString(typeMirror)).append(".class, ");
-    }
-    includesField.append("}");
-    writer.emitField(
-        "Class<?>[]", "INCLUDES", EnumSet.of(PRIVATE, STATIC, FINAL), includesField.toString());
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
-    writer.emitStatement("super(INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
-    writer.endMethod();
+    ClassName moduleClassName = ClassName.get(type);
+    ClassName adapterClassName = Util.adapterName(moduleClassName, MODULE_ADAPTER_SUFFIX);
+
+    TypeSpec.Builder adapterBuilder = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addJavadoc(AdapterJavadocs.MODULE_TYPE, Provides.class)
+        .superclass(ParameterizedTypeName.get(ClassName.get(ModuleAdapter.class), moduleClassName))
+        .addModifiers(PUBLIC, FINAL);
+
+    adapterBuilder.addField(FieldSpec.builder(String[].class, "INJECTS")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", injectsInitializer(injects))
+        .build());
+    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "STATIC_INJECTIONS")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", staticInjectionsInitializer(staticInjections))
+        .build());
+    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "INCLUDES")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", includesInitializer(type, includes))
+        .build());
+    adapterBuilder.addMethod(MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addStatement("super($T.class, INJECTS, STATIC_INJECTIONS, $L /*overrides*/, "
+                + "INCLUDES, $L /*complete*/, $L /*library*/)",
+            type.asType(), overrides, complete, library)
+        .build());
 
     ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
-      writer.emitEmptyLine();
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", EnumSet.of(PUBLIC));
-      writer.emitStatement("return new %s()", typeName);
-      writer.endMethod();
+      adapterBuilder.addMethod(MethodSpec.methodBuilder("newModule")
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .returns(moduleClassName)
+          .addStatement("return new $T()", type.asType())
+          .build());
     }
-    // caches
-    Map<ExecutableElement, String> methodToClassName
-        = new LinkedHashMap<ExecutableElement, String>();
+
+    // Caches.
+    Map<ExecutableElement, ClassName> methodToClassName
+        = new LinkedHashMap<ExecutableElement, ClassName>();
     Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
 
     if (!providerMethods.isEmpty()) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map");
+      MethodSpec.Builder getBindings = MethodSpec.methodBuilder("getBindings")
+          .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .addParameter(BindingsGroup.class, "bindings")
+          .addParameter(moduleClassName, "module");
 
       for (ExecutableElement providerMethod : providerMethods) {
         Provides provides = providerMethod.getAnnotation(Provides.class);
         switch (provides.type()) {
           case UNIQUE: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            getBindings.addStatement("bindings.contributeProvidesBinding($S, new $T(module))",
+                GeneratorKeys.get(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
             break;
           }
           case SET: {
-            String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            getBindings.addStatement("$T.add(bindings, $S, new $T(module))",
+                SetBinding.class,
+                GeneratorKeys.getSetKey(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
             break;
           }
           case SET_VALUES: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            getBindings.addStatement("$T.add(bindings, $S, new $T(module))",
+                SetBinding.class,
+                GeneratorKeys.get(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
             break;
           }
           default:
             throw new AssertionError("Unknown @Provides type " + provides.type());
         }
       }
-      writer.endMethod();
+      adapterBuilder.addMethod(getBindings.build());
     }
 
     for (ExecutableElement providerMethod : providerMethods) {
-      generateProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId,
-          library);
+      adapterBuilder.addType(generateProvidesAdapter(moduleClassName, adapterClassName,
+          providerMethod, methodToClassName, methodNameToNextId, library));
     }
 
-    writer.endType();
-    writer.close();
+    return JavaFile.builder(adapterClassName.packageName(), adapterBuilder.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
   }
 
-  private Set<String> findImports(boolean multibindings, boolean providers, boolean dependencies) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(ModuleAdapter.class.getCanonicalName());
-    if (providers) {
-      imports.add(Binding.class.getCanonicalName());
-      imports.add(Map.class.getCanonicalName());
-      imports.add(Provider.class.getCanonicalName());
-    }
-    if (dependencies) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-    }
-    if (multibindings) {
-      imports.add(SetBinding.class.getCanonicalName());
+  private CodeBlock injectsInitializer(Object[] injects) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("{ ");
+    for (Object injectableType : injects) {
+      TypeMirror typeMirror = (TypeMirror) injectableType;
+      String key = isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
+      result.add("$S, ", key);
     }
-    return imports;
+    result.add("}");
+    return result.build();
   }
 
-  private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      if (!element.getParameters().isEmpty()) {
-        return true;
-      }
+  private CodeBlock staticInjectionsInitializer(Object[] staticInjections) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("{ ");
+    for (Object staticInjection : staticInjections) {
+      result.add("$T.class, ", staticInjection);
     }
-    return false;
+    result.add("}");
+    return result.build();
   }
 
-  private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      Provides.Type providesType = element.getAnnotation(Provides.class).type();
-      if (providesType == SET || providesType == SET_VALUES) {
-        return true;
+  private CodeBlock includesInitializer(TypeElement type, Object[] includes) {
+    CodeBlock.Builder result = CodeBlock.builder();
+    result.add("{ ");
+    for (Object include : includes) {
+      if (!(include instanceof TypeMirror)) {
+        // TODO(tbroyer): pass annotation information
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
+            "Unexpected value: " + include + " in includes of " + type, type);
+        continue;
       }
+      TypeMirror typeMirror = (TypeMirror) include;
+      result.add("$T.class, ", typeMirror);
     }
-    return false;
+    result.add("}");
+    return result.build();
   }
 
-  private String bindingClassName(ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
+  private ClassName bindingClassName(ClassName adapterName, ExecutableElement providerMethod,
+      Map<ExecutableElement, ClassName> methodToClassName,
       Map<String, AtomicInteger> methodNameToNextId) {
-    String className = methodToClassName.get(providerMethod);
+    ClassName className = methodToClassName.get(providerMethod);
     if (className != null) return className;
 
     String methodName = providerMethod.getSimpleName().toString();
@@ -404,92 +391,93 @@ private String bindingClassName(ExecutableElement providerMethod,
     }
     String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
         + methodName.substring(1);
-    className = uppercaseMethodName + "ProvidesAdapter" + suffix;
+    className = adapterName.nestedClass(uppercaseMethodName + "ProvidesAdapter" + suffix);
     methodToClassName.put(providerMethod, className);
     return className;
   }
 
-  private void generateProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId, boolean library)
-      throws IOException {
+  private TypeSpec generateProvidesAdapter(ClassName moduleClassName, ClassName adapterName,
+      ExecutableElement providerMethod, Map<ExecutableElement, ClassName> methodToClassName,
+      Map<String, AtomicInteger> methodNameToNextId, boolean library) {
     String methodName = providerMethod.getSimpleName().toString();
-    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
-    String className =
-        bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
-    String returnType = typeToString(providerMethod.getReturnType());
+    TypeMirror moduleType = providerMethod.getEnclosingElement().asType();
+    ClassName className = bindingClassName(
+        adapterName, providerMethod, methodToClassName, methodNameToNextId);
+    TypeName returnType = Util.injectableType(providerMethod.getReturnType());
     List<? extends VariableElement> parameters = providerMethod.getParameters();
     boolean dependent = !parameters.isEmpty();
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
-    writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(Binding.class, returnType),
-        JavaWriter.type(Provider.class, returnType));
-    writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
+    TypeSpec.Builder result = TypeSpec.classBuilder(className.simpleName())
+        .addJavadoc("$L", bindingTypeDocs(returnType, false, false, dependent))
+        .addModifiers(PUBLIC, STATIC, FINAL)
+        .superclass(ParameterizedTypeName.get(ClassName.get(ProvidesBinding.class), returnType))
+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Provider.class), returnType));
+
+    result.addField(moduleClassName, "module", PRIVATE, FINAL);
     for (Element parameter : parameters) {
-      TypeMirror parameterType = parameter.asType();
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(parameterType)),
-          parameterName(parameter), EnumSet.of(PRIVATE));
+      result.addField(bindingOf(parameter.asType()), parameterName(parameter), PRIVATE);
     }
 
-    writer.emitEmptyLine();
-    writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
-    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    String membersKey = null;
-    writer.emitStatement("super(%s, %s, %s, %s)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
-    writer.emitStatement("this.module = module");
-    writer.emitStatement("setLibrary(%s)", library);
-    writer.endMethod();
+    String key = GeneratorKeys.get(providerMethod);
+    result.addMethod(MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addParameter(moduleClassName, "module")
+        .addStatement("super($S, $L, $S, $S)",
+            key,
+            (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+            typeToString(moduleType),
+            methodName)
+        .addStatement("this.module = module")
+        .addStatement("setLibrary($L)", library)
+        .build());
 
     if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod(
-          "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
+      MethodSpec.Builder attachBuilder = MethodSpec.methodBuilder("attach")
+          .addJavadoc(AdapterJavadocs.ATTACH_METHOD)
+          .addAnnotation(Override.class)
+          .addAnnotation(Util.UNCHECKED)
+          .addModifiers(PUBLIC)
+          .addParameter(Linker.class, "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
+        attachBuilder.addStatement(
+            "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
             parameterName(parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(parameterKey),
-            writer.compressType(moduleType));
+            bindingOf(parameter.asType()),
+            parameterKey,
+            moduleClassName);
       }
-      writer.endMethod();
-
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
-          "getBindings", setOfBindings, "injectMembersBindings");
+      result.addMethod(attachBuilder.build());
+
+      MethodSpec.Builder getDependenciesBuilder = MethodSpec.methodBuilder("getDependencies")
+          .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .addParameter(Util.SET_OF_BINDINGS, "getBindings")
+          .addParameter(Util.SET_OF_BINDINGS, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+        getDependenciesBuilder.addStatement("getBindings.add($N)", parameterName(parameter));
       }
-      writer.endMethod();
+      result.addMethod(getDependenciesBuilder.build());
     }
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, returnType);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(returnType, "get", EnumSet.of(PUBLIC));
-    StringBuilder args = new StringBuilder();
+    MethodSpec.Builder getBuilder = MethodSpec.methodBuilder("get")
+        .addJavadoc(AdapterJavadocs.GET_METHOD, returnType)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC)
+        .returns(returnType)
+        .addCode("return module.$N(", methodName);
     boolean first = true;
     for (Element parameter : parameters) {
-      if (!first) args.append(", ");
-      else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
+      if (!first) getBuilder.addCode(", ");
+      getBuilder.addCode("$N.get()", parameterName(parameter));
+      first = false;
     }
-    writer.emitStatement("return module.%s(%s)", methodName, args.toString());
-    writer.endMethod();
+    getBuilder.addCode(");\n");
+    result.addMethod(getBuilder.build());
 
-    writer.endType();
+    return result.build();
   }
 
   private String parameterName(Element parameter) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0826adf2f..b432093bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,12 +16,21 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ArrayTypeName;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.WildcardTypeName;
+import dagger.internal.Binding;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -44,6 +53,20 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
+  // Binding<?>.
+  public static final TypeName BINDING_OF_ANY = ParameterizedTypeName.get(
+      ClassName.get(Binding.class), WildcardTypeName.subtypeOf(Object.class));
+  // Set<Binding<?>>.
+  public static final TypeName SET_OF_BINDINGS = ParameterizedTypeName.get(
+      ClassName.get(Set.class), BINDING_OF_ANY);
+  // Class<?>[].
+  public static final TypeName ARRAY_OF_CLASS = ArrayTypeName.of(ParameterizedTypeName.get(
+      ClassName.get(Class.class), WildcardTypeName.subtypeOf(Object.class)));
+  // @SuppressWarnings("unchecked")
+  public static final AnnotationSpec UNCHECKED = AnnotationSpec.builder(SuppressWarnings.class)
+      .addMember("value", "$S", "unchecked")
+      .build();
+
   private Util() {
   }
 
@@ -64,12 +87,10 @@ public static TypeMirror getApplicationSupertype(TypeElement type) {
     return Keys.isPlatformType(supertype.toString()) ? null : supertype;
   }
 
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
+  /** Returns a class name to complement {@code type}. */
+  public static ClassName adapterName(ClassName type, String suffix) {
+    return ClassName.get(type.packageName(),
+        Joiner.on('$').join(type.simpleNames()) + suffix);
   }
 
   /** Returns a string for {@code type}. Primitive types are always boxed. */
@@ -119,7 +140,7 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
         return null;
       }
       @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
+        result.append(box((PrimitiveType) type));
         return null;
       }
       @Override public Void visitArray(ArrayType arrayType, Void v) {
@@ -137,10 +158,17 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
         return null;
       }
       @Override public Void visitError(ErrorType errorType, Void v) {
-        // There's already an error but it may not have been reported (most likely
-        // a missing import). If we throw an UnsupportedOperationException here
-        // we'll obscure the real error, so just continue.
-        result.append("error");
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+        // TODO(cgruber): Figure out a strategy for non-FQCN cases.
+        result.append(errorType.toString());
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
@@ -150,19 +178,57 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
     }, null);
   }
 
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR
-      = new SimpleAnnotationValueVisitor6<Object, Void>() {
-    @Override protected Object defaultAction(Object o, Void v) {
-      return o;
-    }
-    @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-      Object[] result = new Object[values.size()];
-      for (int i = 0; i < values.size(); i++) {
-        result[i] = values.get(i).accept(this, null);
+  /** Returns a string for {@code type}. Primitive types are always boxed. */
+  public static TypeName injectableType(TypeMirror type) {
+    return type.accept(new SimpleTypeVisitor6<TypeName, Void>() {
+      @Override public TypeName visitPrimitive(PrimitiveType primitiveType, Void v) {
+        return box(primitiveType);
       }
-      return result;
-    }
-  };
+
+      @Override public TypeName visitError(ErrorType errorType, Void v) {
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+
+        return ClassName.bestGuess(errorType.toString());
+      }
+
+      @Override protected TypeName defaultAction(TypeMirror typeMirror, Void v) {
+        return TypeName.get(typeMirror);
+      }
+    }, null);
+  }
+
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
+      new SimpleAnnotationValueVisitor6<Object, Void>() {
+        @Override public Object visitString(String s, Void p) {
+          if ("<error>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
+          } else if ("<any>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
+          }
+          return s;
+        }
+        @Override public Object visitType(TypeMirror t, Void p) {
+          return t;
+        }
+        @Override protected Object defaultAction(Object o, Void v) {
+          return o;
+        }
+        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+          Object[] result = new Object[values.size()];
+          for (int i = 0; i < values.size(); i++) {
+            result[i] = values.get(i).accept(this, null);
+          }
+          return result;
+        }
+      };
 
   /**
    * Returns the annotation on {@code element} formatted as a Map. This returns
@@ -196,7 +262,6 @@ public static void typeToString(final TypeMirror type, final StringBuilder resul
       }
       return result;
     }
-
     return null; // Annotation not found.
   }
 
@@ -249,26 +314,26 @@ static void rawTypeToString(StringBuilder result, TypeElement type,
     }
   }
 
-  private static Class<?> box(PrimitiveType primitiveType) {
+  private static TypeName box(PrimitiveType primitiveType) {
     switch (primitiveType.getKind()) {
       case BYTE:
-        return Byte.class;
+        return ClassName.get(Byte.class);
       case SHORT:
-        return Short.class;
+        return ClassName.get(Short.class);
       case INT:
-        return Integer.class;
+        return ClassName.get(Integer.class);
       case LONG:
-        return Long.class;
+        return ClassName.get(Long.class);
       case FLOAT:
-        return Float.class;
+        return ClassName.get(Float.class);
       case DOUBLE:
-        return Double.class;
+        return ClassName.get(Double.class);
       case BOOLEAN:
-        return Boolean.class;
+        return ClassName.get(Boolean.class);
       case CHAR:
-        return Character.class;
+        return ClassName.get(Character.class);
       case VOID:
-        return Void.class;
+        return ClassName.get(Void.class);
       default:
         throw new AssertionError();
     }
@@ -305,13 +370,12 @@ public static boolean isCallableConstructor(ExecutableElement constructor) {
         || type.getModifiers().contains(Modifier.STATIC);
   }
 
+
   /**
-   * Returns a user-presentable string like {@code
-   * coffee.CoffeeModule#provideHeater()}.
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
    */
-  public static String methodName(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
-        + "." + method.getSimpleName() + "()";
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
   }
 
   public static boolean isInterface(TypeMirror typeMirror) {
@@ -327,4 +391,19 @@ static boolean isStatic(Element element) {
     }
     return false;
   }
+
+  static ParameterizedTypeName bindingOf(TypeMirror type) {
+    return ParameterizedTypeName.get(ClassName.get(Binding.class), injectableType(type));
+  }
+
+  /**
+   * An exception thrown when a type is not extant (returns as an error type),
+   * usually as a result of another processor not having yet generated its types upon
+   * which a dagger-annotated type depends.
+   */
+  final static class CodeGenerationIncompleteException extends IllegalStateException {
+    public CodeGenerationIncompleteException(String s) {
+      super(s);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
index 3bbac71c2..578bdb3b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
@@ -18,6 +18,7 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
@@ -64,16 +65,20 @@
     Map<Element, Element> parametersToTheirMethods = new LinkedHashMap<Element, Element>();
     getAllElements(env, allElements, parametersToTheirMethods);
     for (Element element : allElements) {
+      try {
         validateProvides(element);
-        validateScoping(element);
-        validateQualifiers(element, parametersToTheirMethods);
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // Upstream compiler issue in play. Ignore this element.
+      }
+      validateScoping(element);
+      validateQualifiers(element, parametersToTheirMethods);
     }
     return false;
   }
 
   private void validateProvides(Element element) {
     if (element.getAnnotation(Provides.class) != null
-        && element.getEnclosingElement().getAnnotation(Module.class) == null) {
+        && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
       error("@Provides methods must be declared in modules: " + elementToString(element), element);
     }
   }
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 9030479cc..fb2e566b9 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -36,28 +36,33 @@
         "class Basic {",
         "  static class A { @Inject A() { } }",
         "  @Module(injects = A.class)",
-        "  static class CyclicModule { }",
+        "  static class AModule { }",
         "}"));
 
     JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
+        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
             "import dagger.internal.ModuleAdapter;",
-            "public final class Basic$CyclicModule$$ModuleAdapter",
-            "    extends ModuleAdapter<Basic.CyclicModule> {",
+            "import java.lang.Class;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "public final class Basic$AModule$$ModuleAdapter",
+            "    extends ModuleAdapter<Basic.AModule> {",
             "  private static final String[] INJECTS = {\"members/Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
-            "  public Basic$CyclicModule$$ModuleAdapter() {",
-            "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+            "  public Basic$AModule$$ModuleAdapter() {",
+            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "      true, false);",
             "  }",
-            "  @Override public Basic.CyclicModule newModule() {",
-            "    return new Basic.CyclicModule();",
+            "  @Override public Basic.AModule newModule() {",
+            "    return new Basic.AModule();",
             "  }",
             "}"));
 
     JavaFileObject expectedInjectAdapter =
         JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
+            "import java.lang.Override;",
             "import javax.inject.Provider;",
             "public final class Basic$A$$InjectAdapter",
             "    extends Binding<Basic.A> implements Provider<Basic.A> {",
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
new file mode 100644
index 000000000..add10ec02
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class ModuleAdapterGenerationTest {
+  /**
+   * Shows current behavior for a {@link dagger.Provides provides method}
+   * used to supply an injected ctor parameter.
+   *
+   * <ul>
+   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
+   *   {@code get}</li>
+   *   <li>On {@code getBindings}, the above is newed up and linked to its type
+   *   key.
+   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
+   *   referenced in {@code getDependencies} and set on {@code attach}</li>
+   *   <li>On {@code get}, the injected constructor is called with the value of
+   *   {@link dagger.internal.Binding#get}</li>
+   * </ul>
+   */
+  @Test public void providerForCtorInjection() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  @Module(injects = { A.class, String.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.BindingsGroup;",
+        "import dagger.internal.ModuleAdapter;",
+        "import dagger.internal.ProvidesBinding;",
+        "import java.lang.Class;",
+        "import java.lang.Override;",
+        "import java.lang.String;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter",
+        "    extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // for ctor
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // name is added to dependencies
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // adds ctor param
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
+
+  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  static class B { @Inject String name; }",
+        "  @Module(injects = { A.class, String.class, B.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.BindingsGroup;",
+        "import dagger.internal.ModuleAdapter;",
+        "import dagger.internal.ProvidesBinding;",
+        "import java.lang.Class;",
+        "import java.lang.Override;",
+        "import java.lang.String;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapterA =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // For Constructor.
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
+            "    return result;",
+            "  }",
+            "}"));
+
+    JavaFileObject expectedInjectAdapterB =
+        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$B$$InjectAdapter",
+            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
+            "  private Binding<String> name;", // For field.
+            "  public Field$B$$InjectAdapter() {",
+            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    injectMembersBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.B get() {",
+            "    Field.B result = new Field.B();",
+            "    injectMembers(result);",
+            "    return result;",
+            "  }",
+            "  @Override public void injectMembers(Field.B object) {",
+            "    object.name = name.get();", // Inject field.
+            "  }",
+            "}"));
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
+  }
+
+
+  @Test public void providesHasParameterNamedModule() {
+    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class A { @Inject A(){ }}"));
+    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class B { @Inject B(){ }}"));
+
+    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "@Module(injects = B.class)",
+        "class BModule { @Provides B b(A module) { return new B(); }}"));
+
+    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
new file mode 100644
index 000000000..fe4d0eeed
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
@@ -0,0 +1,76 @@
+/**
+ * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class FailureModeErrorsTest {
+
+  @Module
+  static class CompleteModule {}
+
+  static class ArrayFoo {
+    @Inject ArrayFoo(String[] ignored) {}
+  }
+
+  @Module(injects = ArrayFoo.class, complete = false)
+  static class ArrayFooModule {}
+
+  @Test public void failOnMissingModule_arrayorgenerics() {
+    // Generics here are crazy to try to test for, but this code path is legit regardless.
+    try {
+      ObjectGraph.create(new CompleteModule(), new ArrayFooModule()).get(ArrayFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "java.lang.String[] is a generic class or an array and can only be bound with "
+          + "concrete type parameter(s) in a @Provides method. required by class "
+          + "dagger.tests.integration.operation.FailureModeErrorsTest$ArrayFoo");
+    }
+  }
+
+  @Qualifier @interface MyFoo {}
+
+  static class QualifyingFoo {
+    @Inject QualifyingFoo(@MyFoo String ignored) {}
+  }
+
+  @Module(injects = QualifyingFoo.class, complete = false)
+  static class QualifyingFooModule {}
+
+  @Test public void failOnMissingModule_qualified() {
+    try {
+      ObjectGraph.create(new CompleteModule(), new QualifyingFooModule()).get(QualifyingFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "@dagger.tests.integration.operation.FailureModeErrorsTest$MyFoo()/java.lang.String "
+          + "is a @Qualifier-annotated type and must be bound by a @Provides method. required by "
+          + "class dagger.tests.integration.operation.FailureModeErrorsTest$QualifyingFoo");
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index adeea2a75..5f7451c6b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.operation;
 
 import dagger.Module;
 import dagger.ObjectGraph;
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
new file mode 100644
index 000000000..994c7800b
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class SimpleInjectionTest {
+  static abstract class AbstractFoo {
+    @Inject String blah;
+  }
+
+  static class Foo extends AbstractFoo { }
+
+  @Module(injects = Foo.class)
+  static class FooModule {
+    @Provides String string() { return "blah"; }
+  }
+
+  @Module(injects = Foo.class)
+  static class ProvidingFooModule {
+    @Provides String string() { return "blah"; }
+    @Provides Foo foo(String blah) {
+      Foo foo = new Foo();
+      foo.blah = blah;
+      return foo;
+    }
+  }
+
+  @Test public void memberInject_WithoutProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(FooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void membersInject_WithProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void get_WithProvidesMethod() {
+    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  static class Bar { }
+
+  @Module(injects = Bar.class)
+  static class BarModule {
+  }
+
+  @Test public void membersInject_WithNonInjectable() {
+    Bar bar = new Bar();
+    ObjectGraph.create(BarModule.class).inject(bar);
+  }
+
+  @Module(injects = Bar.class)
+  static class ProvidingBarModule {
+    @Provides public Bar bar() { return new Bar(); }
+  }
+
+  @Test public void membersInject_WithProvidedNonInjectable() {
+    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
+    ASSERT.that(bar).isNotNull();
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index a18762d52..153bf9df4 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -52,9 +52,7 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
+        .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(17);
   }
 
   @Test public void cyclicDepsWithProvidesMethods() {
@@ -76,10 +74,7 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+        .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(9);
   }
 
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
new file mode 100644
index 000000000..ad8ca1745
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
@@ -0,0 +1,211 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.validation;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.collect.Iterables.concat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+/**
+ * Tests that the annotation processor(s) will properly handle the case where
+ * code they are processing and depending on is generated by other processors
+ * in the environment, and so the types they need may not exist yet.
+ */
+@RunWith(JUnit4.class)
+public class GeneratedTypesNotReadyTest {
+  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
+      "package myPackage;",
+      "public interface Foo {}"
+  ));
+  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+      "import javax.inject.Inject;",
+      "import myPackage.Foo;",
+      "class Main {",
+      "  @Inject Foo f;",
+      "}"));
+
+  @Test public void withstandsMissingTypeReferencedInInjects() {
+    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, main, module))
+        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
+        .compilesWithoutError();
+  }
+
+  @Test public void withstandsMissingTypeReferencedInsideModule() {
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class Main {",
+        "  @Inject myPackage.FooImpl f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides myPackage.FooImpl provideFoo() {",
+        "    return new myPackage.FooImpl();",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class Main {",
+        "  @Inject myPackage.FooImpl2<String> f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
+        "    return new myPackage.FooImpl2<String>();",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(new FooImplGenerator())
+        .compilesWithoutError();
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .failsToCompile()
+        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
+  }
+
+  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import myPackage.FooImpl;",
+        "class Main {",
+        "  @Inject FooImpl f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(new FooImplGenerator())
+        .compilesWithoutError();
+  }
+
+  @SupportedAnnotationTypes("*")
+  private final class FooImplGenerator extends AbstractProcessor {
+    boolean written = false;
+    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
+      if (!written) {
+        try {
+          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
+          Writer writer = sourceFile.openWriter();
+          writer.write(Joiner.on("\n").join(
+              "package myPackage;",
+              "import javax.inject.Inject;",
+              "public final class FooImpl implements Foo {",
+              "  @Inject public FooImpl() { }",
+              "}"));
+          writer.close();
+          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
+          writer = sourceFile.openWriter();
+          writer.write(Joiner.on("\n").join(
+              "package myPackage;",
+              "import javax.inject.Inject;",
+              "public final class FooImpl2<T> implements Foo {",
+              "  @Inject public FooImpl2() { }",
+              "}"));
+          writer.close();
+          written = true;
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+      return false;
+    }
+
+    @Override public SourceVersion getSupportedSourceVersion() {
+      return SourceVersion.latestSupported();
+    }
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index 7a368a3b1..edc8816a4 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -18,12 +18,14 @@
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
@@ -32,7 +34,6 @@
   @Test public void unusedProviderMethodsPassOnLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = true)",
@@ -48,7 +49,6 @@
   @Test public void unusedProviderMethodsFailOnNonLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = false)",
@@ -58,9 +58,44 @@
         "  }",
         "}"));
     ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("Graph validation failed:").in(source).onLine(6).and()
-        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(6).and()
-        .withErrorContaining("1. TestModule.string()").in(source).onLine(6).and()
-        .withErrorContaining("Set library=true in your module").in(source).onLine(6);
+        .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
+        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
+        .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
+        .withErrorContaining("Set library=true in your module").in(source).onLine(5);
   }
+
+  @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+  @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
 }
diff --git a/core/pom.xml b/core/pom.xml
index c5e94d005..c61aeb7ea 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -47,6 +47,24 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.8</version><!-- 1.9+ requires JDK7 -->
+        <executions>
+          <execution>
+            <id>sniff-api</id>
+            <goals><goal>check</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java15</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 1e28f4fd6..893a54390 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -28,8 +28,10 @@
 public @interface Module {
   /**
    * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get} and
-   * the types of instances passed {@link ObjectGraph#inject}.
+   * inject. This includes both classes passed to {@link ObjectGraph#get},
+   * the types of instances passed {@link ObjectGraph#inject} and
+   * {@link javax.inject.Inject} annotated classes that need to be scoped to the
+   * resulting object graphs.
    *
    * <p>It is an error to call {@link ObjectGraph#get} or {@link
    * ObjectGraph#inject} with a type that isn't listed in the {@code injects}
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1fe64b407..a1736d2b8 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -17,19 +17,22 @@
 package dagger;
 
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.Modules;
 import dagger.internal.ProblemDetector;
+import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
-import dagger.internal.UniqueMap;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
-
-import static dagger.internal.Modules.getAllModuleAdapters;
+import java.util.Map.Entry;
 
 
 /**
@@ -131,60 +134,71 @@ static ObjectGraph createWith(Loader loader, Object... modules) {
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
+  // TODO(cgruber): Move this internal implementation of ObjectGraph into the internal package.
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
+    private final Loader plugin;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
-    private final Loader plugin;
+    private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> injectableTypes) {
-      if (linker == null) throw new NullPointerException("linker");
-      if (plugin == null) throw new NullPointerException("plugin");
-      if (staticInjections == null) throw new NullPointerException("staticInjections");
-      if (injectableTypes == null) throw new NullPointerException("injectableTypes");
+        Map<String, Class<?>> injectableTypes,
+        List<SetBinding<?>> setBindings) {
 
       this.base = base;
-      this.linker = linker;
-      this.plugin = plugin;
-      this.staticInjections = staticInjections;
-      this.injectableTypes = injectableTypes;
+      this.linker = checkNotNull(linker, "linker");
+      this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
+      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
+      this.setBindings = checkNotNull(setBindings, "setBindings");
+    }
+
+    private static <T> T checkNotNull(T object, String label) {
+      if (object == null) throw new NullPointerException(label);
+      return object;
     }
 
     private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
+      StandardBindings baseBindings =
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+      BindingsGroup overrideBindings = new OverridesBindings();
 
-      // Extract bindings in the 'base' and 'overrides' set. Within each set no
-      // duplicates are permitted.
-      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
-      for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (String key : moduleAdapter.injectableTypes) {
-          injectableTypes.put(key, moduleAdapter.getModule().getClass());
+      Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
+      for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
+        ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
+        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
+        }
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
-        for (Class<?> c : moduleAdapter.staticInjections) {
-          staticInjections.put(c, null);
+        try {
+          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          moduleAdapter.getBindings(addTo, loadedModule.getValue());
+        } catch (IllegalArgumentException e) {
+          throw new IllegalArgumentException(
+              moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
         }
-        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-        moduleAdapter.getBindings(addTo);
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-          new ThrowingErrorHandler());
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
+      return new DaggerObjectGraph(
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
     }
 
-
     @Override public ObjectGraph plus(Object... modules) {
       linkEverything();
       return makeGraph(this, plugin, modules);
@@ -217,10 +231,17 @@ private void linkInjectableTypes() {
      * Links all bindings, injectable types and static injections.
      */
     private Map<String, Binding<?>> linkEverything() {
+      Map<String, Binding<?>> bindings = linker.fullyLinkedBindings();
+      if (bindings != null) {
+        return bindings;
+      }
       synchronized (linker) {
+        if ((bindings = linker.fullyLinkedBindings()) != null) {
+          return bindings;
+        }
         linkStaticInjections();
         linkInjectableTypes();
-        return linker.linkAll();
+        return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
       }
     }
 
@@ -292,4 +313,45 @@ private void linkInjectableTypes() {
       }
     }
   }
+
+
+  /**
+   * A BindingsGroup which fails when existing values are clobbered and sets aside
+   * {@link SetBinding}.
+   */
+  private static final class StandardBindings extends BindingsGroup {
+    private final List<SetBinding<?>> setBindings;
+
+    public StandardBindings() {
+      setBindings = new ArrayList<SetBinding<?>>();
+    }
+
+    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+    }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      setBindings.add(value);
+      return super.put(key, value);
+    }
+  }
+
+  /**
+   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
+   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
+   * bindings.
+   */
+  private static final class OverridesBindings extends BindingsGroup {
+    OverridesBindings() { }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+    }
+  }
 }
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
new file mode 100644
index 000000000..690b6d9e5
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -0,0 +1,607 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ *
+ * Adapted from https://android.googlesource.com/platform/libcore/+
+ *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
+ */
+package dagger.internal;
+
+import java.lang.reflect.Array;
+import java.util.AbstractCollection;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * Resizable-array implementation of the {@link Queue} interface.  Array
+ * queues have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link LinkedList} when used as a queue.
+ *
+ * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
+ * {@link #iterator iterator.remove()}, and the bulk operations, all of which
+ * run in linear time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the queue is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+public class ArrayQueue<E> extends AbstractCollection<E>
+                           implements Queue<E>, Cloneable, java.io.Serializable {
+    /**
+     * The array in which the elements of the queue are stored.
+     * The capacity of the queue is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * queue elements are always null.
+     */
+    private transient Object[] elements;
+
+    /**
+     * The index of the element at the head of the queue (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the queue is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the queue (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created queue.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+        }
+        elements = new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this queue.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        // assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, queue too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayQueue() {
+        elements = new Object[16];
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the queue
+     */
+    public ArrayQueue(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a queue containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * queue.)
+     *
+     * @param c the collection whose elements are to be placed into the queue
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayQueue(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * <p>This method is equivalent to {@link #offer}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean add(E e) {
+        if (e == null)
+            throw new NullPointerException("e == null");
+        elements[tail] = e;
+        if ((tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E remove() {
+        E x = poll();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue
+     * (in other words, the first element of this queue), or returns
+     * <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E poll() {
+        int h = head;
+        @SuppressWarnings("unchecked") E result = (E) elements[h];
+        // Element is null if queue empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E element() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue, or returns <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E peek() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        // elements[head] is null if queue empty
+        return result;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        //checkInvariants();
+        final Object[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this queue.
+     *
+     * @return the number of elements in this queue
+     */
+    @Override
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains no elements.
+     *
+     * @return <tt>true</tt> if this queue contains no elements
+     */
+    @Override
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this queue.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be queueued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this queue
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new QueueIterator();
+    }
+
+
+    private class QueueIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        @Override
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        @Override
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this queue contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this queue
+     * @return <tt>true</tt> if this queue contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this queue.
+     * If the queue does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this queue contained the specified element
+     * (or equivalently, if this queue changed as a result of the call).
+     *
+     * @param o element to be removed from this queue, if present
+     * @return <tt>true</tt> if this queue contained the specified element
+     */
+    @Override
+    public boolean remove(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes all of the elements from this queue.
+     * The queue will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this queue.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this queue
+     */
+    @Override
+    public Object[] toArray() {
+        return toArray(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the queue fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this queue.
+     *
+     * <p>If this queue fits in the specified array with room to spare
+     * (i.e., the array has more elements than this queue), the element in
+     * the array immediately following the end of the queue is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
+     * The following code can be used to dump the queue into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the queue are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this queue
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this queue
+     * @throws NullPointerException if the specified array is null
+     */
+    @Override
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+            a = (T[]) java.lang.reflect.Array.newInstance(
+                    a.getClass().getComponentType(), size);
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Returns a copy of this queue.
+     *
+     * @return a copy of this queue
+     */
+    @Override
+    public ArrayQueue<E> clone() {
+        try {
+            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
+            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
+                elements.length);
+            System.arraycopy(elements, 0, newElements, 0, elements.length);
+            result.elements = newElements;
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+    /**
+     * Serialize this queue.
+     *
+     * @serialData The current size (<tt>int</tt>) of the queue,
+     * followed by all of its elements (each an object reference) in
+     * first-to-last order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+
+        // Write out size
+        s.writeInt(size());
+
+        // Write out elements in order.
+        int mask = elements.length - 1;
+        for (int i = head; i != tail; i = (i + 1) & mask)
+            s.writeObject(elements[i]);
+    }
+
+    /**
+     * Deserialize this queue.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+
+        // Read in size and allocate array
+        int size = s.readInt();
+        allocateElements(size);
+        head = 0;
+        tail = size;
+
+        // Read in all elements in the proper order.
+        for (int i = 0; i < size; i++)
+            elements[i] = s.readObject();
+    }
+}
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
new file mode 100644
index 000000000..861f7de86
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
+ * the initial set of bindings for a graph (from provides methods).
+ */
+public abstract class BindingsGroup {
+  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
+
+  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+
+  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
+    return put(key, value);
+  }
+
+  protected Binding<?> put(String key, Binding<?> value) {
+    Binding<?> clobbered = bindings.put(key, value);
+    if (clobbered != null) {
+      bindings.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+
+  public Binding<?> get(String key) {
+    return bindings.get(key);
+  }
+
+  public final Set<Entry<String, Binding<?>>> entrySet() {
+    return bindings.entrySet();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + bindings.toString();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 1c274519f..a9fb26031 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -30,24 +30,36 @@
  * reflective equivalent.
  */
 public final class FailoverLoader extends Loader {
+  /*
+   * Note that String.concat is used throughout this code because it is the most efficient way to
+   * concatenate _two_ strings.  javac uses StringBuilder for the + operator and it has proven to
+   * be wasteful in terms of both CPU and memory allocated.
+   */
+
+  private final Memoizer<Class<?>, ModuleAdapter<?>> loadedAdapters =
+      new Memoizer<Class<?>, ModuleAdapter<?>>() {
+        @Override protected ModuleAdapter<?> create(Class<?> type) {
+          ModuleAdapter<?> result =
+              instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
+          if (result == null) {
+            throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+                + "Please ensure that code generation was run for this module.");
+          }
+          return result;
+        }
+      };
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result =
-        instantiate(type.getName() + MODULE_ADAPTER_SUFFIX, type.getClassLoader());
-    if (result == null) {
-      throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
-          + "Please ensure that code generation was run for this module.");
-    }
-    result.module = (instance != null) ? instance : result.newModule();
-    return result;
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return (ModuleAdapter<T>) loadedAdapters.get(type);
   }
 
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    Binding<?> result = instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+    Binding<?> result = instantiate(className.concat(INJECT_ADAPTER_SUFFIX), classLoader);
     if (result != null) {
       return result; // Found loadable adapter, returning it.
     }
@@ -64,7 +76,7 @@
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
     StaticInjection result = instantiate(
-          injectedClass.getName() + STATIC_INJECTION_SUFFIX, injectedClass.getClassLoader());
+          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
     if (result != null) {
       return result;
     }
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index da7eeb206..fb65cc67b 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */
@@ -46,12 +46,12 @@
   private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
   private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
 
-  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
-      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
-    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
-      return annotationType.isAnnotationPresent(Qualifier.class);
-    }
-  };
+  private static final Memoizer<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION =
+      new Memoizer<Class<? extends Annotation>, Boolean>() {
+        @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+          return annotationType.isAnnotationPresent(Qualifier.class);
+        }
+      };
 
   Keys() {
   }
@@ -61,14 +61,14 @@ public static String get(Type type) {
     return get(type, null);
   }
 
-
   /** Returns a key for the members of {@code type}. */
   public static String getMembersKey(Class<?> key) {
-    return "members/" + get(key);
+    // for classes key.getName() is equivalent to get(key)
+    return "members/".concat(key.getName());
   }
 
   /** Returns a key for {@code type} annotated by {@code annotation}. */
-  public static String get(Type type, Annotation annotation) {
+  private static String get(Type type, Annotation annotation) {
     type = boxIfPrimitive(type);
     if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {
       return ((Class<?>) type).getName();
@@ -233,11 +233,6 @@ private static boolean substringStartsWith(String string, int offset, String sub
     return string.regionMatches(offset, substring, 0, substring.length());
   }
 
-  /** Returns true if {@code key} is a binding that supports members injection. */
-  public static boolean isMembersInjection(String key) {
-    return key.startsWith("members/");
-  }
-
   /** Returns true if {@code key} has a qualifier annotation. */
   public static boolean isAnnotated(String key) {
     return key.startsWith("@");
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 86edaf545..e9cf9f4b6 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -17,8 +17,8 @@
 
 import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
@@ -38,7 +38,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
+  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
@@ -49,6 +49,14 @@
   /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
+  /**
+   * An unmodifiable map containing all of the bindings available in this linker, fully linked.
+   * This will be null if the bindings are not yet fully linked. It provides both a signal
+   * of completion of the {@link #linkAll()} method, as well as a place to reference the final,
+   * fully linked map of bindings.
+   */
+  private volatile Map<String, Binding<?>> linkedBindings = null;
+
   private final Loader plugin;
 
   private final ErrorHandler errorHandler;
@@ -66,37 +74,60 @@ public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
    * Adds all bindings in {@code toInstall}. The caller must call either {@link
    * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
    * bindings can be used.
+   *
+   * This method may only be called before {@link #linkAll()}. Subsequent calls to
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
    */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(BindingsGroup toInstall) {
+    if (linkedBindings != null) {
+      throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
+    }
     for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
       bindings.put(entry.getKey(), scope(entry.getValue()));
     }
   }
 
   /**
-   * Links requested bindings and installed bindings, plus all of their
-   * transitive dependencies. This creates JIT bindings as necessary to fill in
-   * the gaps.
+   * Links all known bindings (whether requested or installed), plus all of their
+   * transitive dependencies. This loads injectable types' bindings as necessary to fill in
+   * the gaps.  If this method has returned successfully at least once, all further
+   * work is short-circuited.
    *
-   * @return all bindings known by this linker, which will all be linked.
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public Map<String, Binding<?>> linkAll() {
+    assertLockHeld();
+    if (linkedBindings != null) {
+      return linkedBindings;
+    }
     for (Binding<?> binding : bindings.values()) {
       if (!binding.isLinked()) {
         toLink.add(binding);
       }
     }
-    linkRequested();
-    return bindings;
+    linkRequested(); // This method throws if bindings are not resolvable/linkable.
+    linkedBindings = Collections.unmodifiableMap(bindings);
+    return linkedBindings;
+  }
+
+  /**
+   * Returns the map of all bindings available to this {@link Linker}, if and only if
+   * {@link #linkAll()} has successfully returned at least once, otherwise it returns null;
+   */
+  public Map<String, Binding<?>> fullyLinkedBindings() {
+    return linkedBindings;
   }
 
   /**
    * Links all requested bindings plus their transitive dependencies. This
    * creates JIT bindings as necessary to fill in the gaps.
+   *
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public void linkRequested() {
     assertLockHeld();
-
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
@@ -107,18 +138,18 @@ public void linkRequested() {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding =
-              createJitBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
-          jitBinding.setLibrary(binding.library());
-          jitBinding.setDependedOn(binding.dependedOn());
+          Binding<?> resolvedBinding =
+              createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
+          resolvedBinding.setLibrary(binding.library());
+          resolvedBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
-          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
+          if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) {
             throw new IllegalStateException("Unable to create binding for " + key);
           }
           // Enqueue the JIT binding so its own dependencies can be linked.
-          Binding<?> scopedJitBinding = scope(jitBinding);
-          toLink.add(scopedJitBinding);
-          putBinding(scopedJitBinding);
+          Binding<?> scopedBinding = scope(resolvedBinding);
+          toLink.add(scopedBinding);
+          putBinding(scopedBinding);
         } catch (InvalidBindingException e) {
           addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
           bindings.put(key, Binding.UNRESOLVED);
@@ -164,16 +195,17 @@ private void assertLockHeld() {
   }
 
   /**
-   * Creates a just-in-time binding for the key in {@code deferred}. The type of binding
+   * Returns a binding for the key in {@code deferred}. The type of binding
    * to be created depends on the key's type:
    * <ul>
    *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
    *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
    *       {@code Blah} respectively.
-   *   <li>Injections of other types will use the injectable constructors of those classes.
+   *   <li>Injections of raw types will use the injectable constructors of those classes.
+   *   <li>Any other injection types require @Provides bindings and will error out.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, ClassLoader classLoader,
+  private Binding<?> createBinding(String key, Object requiredBy, ClassLoader classLoader,
       boolean mustHaveInjections) {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
@@ -185,12 +217,19 @@ private void assertLockHeld() {
     }
 
     String className = Keys.getClassName(key);
-    if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> binding =
-          plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
-      if (binding != null) {
-        return binding;
-      }
+    if (className == null) {
+      throw new InvalidBindingException(key,
+          "is a generic class or an array and can only be bound with concrete type parameter(s) "
+          + "in a @Provides method.");
+    }
+    if (Keys.isAnnotated(key)) {
+      throw new InvalidBindingException(key,
+          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
+    }
+    Binding<?> binding =
+        plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+    if (binding != null) {
+      return binding;
     }
     throw new InvalidBindingException(className, "could not be bound with key " + key);
   }
@@ -280,10 +319,9 @@ private void assertLockHeld() {
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton()) {
-      return binding;
+    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+      return binding; // Default scoped binding or already a scoped binding.
     }
-    if (binding instanceof SingletonBinding) throw new AssertionError();
     return new SingletonBinding<T>(binding);
   }
 
@@ -418,11 +456,17 @@ private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requ
       this.classLoader = classLoader;
       this.mustHaveInjections = mustHaveInjections;
     }
+
     @Override public void injectMembers(Object t) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+
+    @Override public String toString() {
+      return "DeferredBinding[deferredKey=" + deferredKey + "]";
+    }
   }
 }
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index e5bcb08c0..35b5e6775 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -16,8 +16,8 @@
  */
 package dagger.internal;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.AccessibleObject;
+
 
 /**
  * Provides a point of configuration of the basic resolving functions within Dagger, namely
@@ -25,21 +25,20 @@
  * provide all resolution methods
  */
 public abstract class Loader {
-
-  private final LruCache<ClassLoader, LruCache<String, Class<?>>> caches =
-      new LruCache<ClassLoader, LruCache<String, Class<?>>>(Integer.MAX_VALUE) {
-    @Override protected LruCache<String, Class<?>> create(final ClassLoader classLoader) {
-      return new LruCache<String, Class<?>>(Integer.MAX_VALUE) {
-        @Override protected Class<?> create(String className) {
-          try {
-            return classLoader.loadClass(className);
-          } catch (ClassNotFoundException e) {
-            return Void.class; // Cache the failure (negative case).
-          }
+  private final Memoizer<ClassLoader, Memoizer<String, Class<?>>> caches =
+      new Memoizer<ClassLoader, Memoizer<String, Class<?>>>() {
+        @Override protected Memoizer<String, Class<?>> create(final ClassLoader classLoader) {
+          return new Memoizer<String, Class<?>>() {
+            @Override protected Class<?> create(String className) {
+              try {
+                return classLoader.loadClass(className);
+              } catch (ClassNotFoundException e) {
+                return Void.class; // Cache the failure (negative case).
+              }
+            }
+          };
         }
       };
-    }
-  };
 
   /**
    * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
@@ -49,10 +48,10 @@
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
-   * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
+   * Returns a module adapter for {@code moduleClass} or throws a {@code TypeNotPresentException} if
    * none can be found.
    */
-  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
+  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
 
   /**
    * Returns the static injection for {@code injectedClass}.
@@ -72,7 +71,8 @@
   }
 
   /**
-   * Instantiates a class using its default constructor and the given {@link ClassLoader}.
+   * Instantiates a class using its default constructor and the given {@link ClassLoader}. This
+   * method does not attempt to {@linkplain AccessibleObject#setAccessible set accessibility}.
    */
   protected <T> T instantiate(String name, ClassLoader classLoader) {
     try {
@@ -80,17 +80,13 @@
       if (generatedClass == Void.class) {
         return null;
       }
-      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (T) constructor.newInstance();
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("No default constructor found on " + name, e);
+      @SuppressWarnings("unchecked")
+      T instance = (T) generatedClass.newInstance();
+      return instance;
     } catch (InstantiationException e) {
       throw new RuntimeException("Failed to initialize " + name, e);
     } catch (IllegalAccessException e) {
       throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException("Error while initializing " + name, e.getCause());
     }
   }
 
diff --git a/core/src/main/java/dagger/internal/LruCache.java b/core/src/main/java/dagger/internal/LruCache.java
deleted file mode 100644
index 6ca506247..000000000
--- a/core/src/main/java/dagger/internal/LruCache.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Private copy of {@code android.util.LruCache}.
- */
-class LruCache<K, V> {
-  private final LinkedHashMap<K, V> map;
-
-  /** Size of this cache in units. Not necessarily the number of elements. */
-  private int size;
-  private int maxSize;
-
-  private int putCount;
-  private int createCount;
-  private int evictionCount;
-  private int hitCount;
-  private int missCount;
-
-  /**
-   * @param maxSize for caches that do not override {@link #sizeOf}, this is
-   *     the maximum number of entries in the cache. For all other caches,
-   *     this is the maximum sum of the sizes of the entries in this cache.
-   */
-  public LruCache(int maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    this.maxSize = maxSize;
-    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
-  }
-
-  /**
-   * Returns the value for {@code key} if it exists in the cache or can be
-   * created by {@code #create}. If a value was returned, it is moved to the
-   * head of the queue. This returns null if a value is not cached and cannot
-   * be created.
-   */
-  public final V get(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V mapValue;
-    synchronized (this) {
-      mapValue = map.get(key);
-      if (mapValue != null) {
-        hitCount++;
-        return mapValue;
-      }
-      missCount++;
-    }
-
-    /*
-    * Attempt to create a value. This may take a long time, and the map
-    * may be different when create() returns. If a conflicting value was
-    * added to the map while create() was working, we leave that value in
-    * the map and release the created value.
-    */
-
-    V createdValue = create(key);
-    if (createdValue == null) {
-      return null;
-    }
-
-    synchronized (this) {
-      createCount++;
-      mapValue = map.put(key, createdValue);
-
-      if (mapValue != null) {
-        // There was a conflict so undo that last put
-        map.put(key, mapValue);
-      } else {
-        size += safeSizeOf(key, createdValue);
-      }
-    }
-
-    if (mapValue != null) {
-      entryRemoved(false, key, createdValue, mapValue);
-      return mapValue;
-    } else {
-      trimToSize(maxSize);
-      return createdValue;
-    }
-  }
-
-  /**
-   * Caches {@code value} for {@code key}. The value is moved to the head of
-   * the queue.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V put(K key, V value) {
-    if (key == null || value == null) {
-      throw new NullPointerException("key == null || value == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      putCount++;
-      size += safeSizeOf(key, value);
-      previous = map.put(key, value);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, value);
-    }
-
-    trimToSize(maxSize);
-    return previous;
-  }
-
-  /**
-   * @param maxSize the maximum size of the cache before returning. May be -1
-   *     to evict even 0-sized elements.
-   */
-  private void trimToSize(int maxSize) {
-    while (true) {
-      K key;
-      V value;
-      synchronized (this) {
-        if (size < 0 || (map.isEmpty() && size != 0)) {
-          throw new IllegalStateException(getClass().getName()
-              + ".sizeOf() is reporting inconsistent results!");
-        }
-
-        if (size <= maxSize || map.isEmpty()) {
-          break;
-        }
-
-        Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
-        key = toEvict.getKey();
-        value = toEvict.getValue();
-        map.remove(key);
-        size -= safeSizeOf(key, value);
-        evictionCount++;
-      }
-
-      entryRemoved(true, key, value, null);
-    }
-  }
-
-  /**
-   * Removes the entry for {@code key} if it exists.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V remove(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      previous = map.remove(key);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, null);
-    }
-
-    return previous;
-  }
-
-  /**
-   * Called for entries that have been evicted or removed. This method is
-   * invoked when a value is evicted to make space, removed by a call to
-   * {@link #remove}, or replaced by a call to {@link #put}. The default
-   * implementation does nothing.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * @param evicted true if the entry is being removed to make space, false
-   *     if the removal was caused by a {@link #put} or {@link #remove}.
-   * @param newValue the new value for {@code key}, if it exists. If non-null,
-   *     this removal was caused by a {@link #put}. Otherwise it was caused by
-   *     an eviction or a {@link #remove}.
-   */
-  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
-  }
-
-  /**
-   * Called after a cache miss to compute a value for the corresponding key.
-   * Returns the computed value or null if no value can be computed. The
-   * default implementation returns null.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * <p>If a value for {@code key} exists in the cache when this method
-   * returns, the created value will be released with {@link #entryRemoved}
-   * and discarded. This can occur when multiple threads request the same key
-   * at the same time (causing multiple values to be created), or when one
-   * thread calls {@link #put} while another is creating a value for the same
-   * key.
-   */
-  protected V create(K key) {
-    return null;
-  }
-
-  private int safeSizeOf(K key, V value) {
-    int result = sizeOf(key, value);
-    if (result < 0) {
-      throw new IllegalStateException("Negative size: " + key + "=" + value);
-    }
-    return result;
-  }
-
-  /**
-   * Returns the size of the entry for {@code key} and {@code value} in
-   * user-defined units.  The default implementation returns 1 so that size
-   * is the number of entries and max size is the maximum number of entries.
-   *
-   * <p>An entry's size must not change while it is in the cache.
-   */
-  protected int sizeOf(K key, V value) {
-    return 1;
-  }
-
-  /**
-   * Clear the cache, calling {@link #entryRemoved} on each removed entry.
-   */
-  public final void evictAll() {
-    trimToSize(-1); // -1 will evict 0-sized elements
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the number
-   * of entries in the cache. For all other caches, this returns the sum of
-   * the sizes of the entries in this cache.
-   */
-  public synchronized final int size() {
-    return size;
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the maximum
-   * number of entries in the cache. For all other caches, this returns the
-   * maximum sum of the sizes of the entries in this cache.
-   */
-  public synchronized final int maxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned a value.
-   */
-  public synchronized final int hitCount() {
-    return hitCount;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned null or required a new
-   * value to be created.
-   */
-  public synchronized final int missCount() {
-    return missCount;
-  }
-
-  /**
-   * Returns the number of times {@link #create(Object)} returned a value.
-   */
-  public synchronized final int createCount() {
-    return createCount;
-  }
-
-  /**
-   * Returns the number of times {@link #put} was called.
-   */
-  public synchronized final int putCount() {
-    return putCount;
-  }
-
-  /**
-   * Returns the number of values that have been evicted.
-   */
-  public synchronized final int evictionCount() {
-    return evictionCount;
-  }
-
-  /**
-   * Returns a copy of the current contents of the cache, ordered from least
-   * recently accessed to most recently accessed.
-   */
-  public synchronized final Map<K, V> snapshot() {
-    return new LinkedHashMap<K, V>(map);
-  }
-
-  @Override public synchronized final String toString() {
-    int accesses = hitCount + missCount;
-    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
-    return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
-        maxSize, hitCount, missCount, hitPercent);
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
new file mode 100644
index 000000000..04cdc104c
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Memoizer.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Represents an operation to be
+ */
+abstract class Memoizer<K, V> {
+  private final Map<K, V> map;
+  private final Lock readLock;
+  private final Lock writeLock;
+
+  public Memoizer() {
+    this.map = new LinkedHashMap<K, V>();
+    ReadWriteLock lock = new ReentrantReadWriteLock();
+    this.readLock = lock.readLock();
+    this.writeLock = lock.writeLock();
+  }
+
+  public final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    // check to see if we already have a value
+    readLock.lock();
+    try {
+      V value = map.get(key);
+      if (value != null) {
+        return value;
+      }
+    } finally {
+      readLock.unlock();
+    }
+
+    // create a new value.  this may race and we might create more than one instance, but that's ok
+    V newValue = create(key);
+    if (newValue == null) {
+      throw new NullPointerException("create returned null");
+    }
+
+    // write the new value and return it
+    writeLock.lock();
+    try {
+      map.put(key, newValue);
+      return newValue;
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+  protected abstract V create(K key);
+
+  @Override public final String toString() {
+    readLock.lock();
+    try {
+      return map.toString();
+    } finally {
+      readLock.unlock();
+    }
+  }
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index ab255ce21..2986ad66a 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,22 +17,22 @@
 package dagger.internal;
 
 
-import java.util.Map;
-
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
+  public final Class<T> moduleClass;
   public final String[] injectableTypes;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
   public final boolean library;
-  protected T module;
 
-  protected ModuleAdapter(String[] injectableTypes, Class<?>[] staticInjections, boolean overrides,
-      Class<?>[] includes, boolean complete, boolean library) {
+  protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
+      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
+      boolean library) {
+    this.moduleClass = moduleClass;
     this.injectableTypes = injectableTypes;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
@@ -45,7 +45,8 @@ protected ModuleAdapter(String[] injectableTypes, Class<?>[] staticInjections, b
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map) {
+  @SuppressWarnings("unused")
+  public void getBindings(BindingsGroup map, T module) {
     // no-op;
   }
 
@@ -57,7 +58,20 @@ protected T newModule() {
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  @Override
+  public final boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof ModuleAdapter<?>) {
+      ModuleAdapter<?> that = (ModuleAdapter<?>) obj;
+      return this.moduleClass.equals(that.moduleClass);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public final int hashCode() {
+    return moduleClass.hashCode();
   }
 }
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index ef994cd31..8b269f57f 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -31,35 +31,38 @@ private Modules() { }
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
-      Object[] seedModules) {
-    // Create a module adapter for each seed module.
-    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
-    int s = 0;
-    for (Object module : seedModules) {
-      if (module instanceof Class) {
-        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
+  public static Map<ModuleAdapter<?>, Object> loadModules(Loader loader,
+      Object[] seedModulesOrClasses) {
+    Map<ModuleAdapter<?>, Object> seedAdapters =
+        new LinkedHashMap<ModuleAdapter<?>, Object>(seedModulesOrClasses.length);
+    for (int i = 0; i < seedModulesOrClasses.length; i++) {
+      if (seedModulesOrClasses[i] instanceof Class<?>) {
+        ModuleAdapter<?> adapter = loader.getModuleAdapter((Class<?>) seedModulesOrClasses[i]);
+        seedAdapters.put(adapter, adapter.newModule());
       } else {
-        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+        ModuleAdapter<?> adapter = loader.getModuleAdapter(seedModulesOrClasses[i].getClass());
+        seedAdapters.put(adapter, seedModulesOrClasses[i]);
       }
     }
 
-    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
-        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
-    }
+    Map<ModuleAdapter<?>, Object> result =
+        new LinkedHashMap<ModuleAdapter<?>, Object>(seedAdapters);
 
-    // Next add adapters for the modules that we need to construct. This creates
-    // instances of modules as necessary.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
+    // Next collect included modules
+    Map<Class<?>, ModuleAdapter<?>> transitiveInclusions =
+        new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+    for (ModuleAdapter<?> adapter : seedAdapters.keySet()) {
+      collectIncludedModulesRecursively(loader, adapter, transitiveInclusions);
     }
-
-    return adaptersByModuleType;
+    // and create them if necessary
+    for (ModuleAdapter<?> dependency : transitiveInclusions.values()) {
+      if (!result.containsKey(dependency)) {
+        result.put(dependency, dependency.newModule());
+      }
+    }
+    return result;
   }
 
   /**
@@ -70,7 +73,7 @@ private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapt
       Map<Class<?>, ModuleAdapter<?>> result) {
     for (Class<?> include : adapter.includes) {
       if (!result.containsKey(include)) {
-        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
+        ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
         result.put(include, includedModuleAdapter);
         collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
       }
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
new file mode 100644
index 000000000..2e6f98922
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@code Binding<T>} which delegates to a module method.
+ */
+public abstract class ProvidesBinding<T> extends Binding<T> {
+  protected final String moduleClass;
+
+  protected final String methodName;
+
+  /**
+   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
+   * this binding should be scoped, and the requiredBy object for traceability.
+   */
+  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
+    // Set requiredBy as fullMethodName to preserve older debugging meaning.
+    super(key, null, singleton, moduleClass + "." + methodName + "()");
+    this.moduleClass = moduleClass;
+    this.methodName = methodName;
+  }
+
+  /**
+   * A provides binding is responsible for implementing storage of the module instance, and
+   * delegation to that module instance's method.
+   */
+  @Override
+  public abstract T get();
+
+  @Override public String toString() {
+    return getClass().getName() + "[key=" + provideKey
+        + " method=" + moduleClass + "." + methodName + "()" + "]";
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9b94c78f1..af3729061 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -16,9 +16,10 @@
  */
 package dagger.internal;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
-import java.util.Map;
+import java.util.List;
 import java.util.Set;
 
 /**
@@ -28,25 +29,60 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
+    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
   @SuppressWarnings("unchecked")
-  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+  private static <T> SetBinding<T> prepareSetBinding(
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      setBinding = (SetBinding) previous;
+      setBinding = (SetBinding<T>) previous;
+      setBinding.setLibrary(setBinding.library() && binding.library());
+      return setBinding;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
-      bindings.put(setKey, setBinding);
+      setBinding.setLibrary(binding.library());
+      bindings.contributeSetBinding(setKey, setBinding);
+      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
-    setBinding.contributors.add(Linker.scope(binding));
   }
 
-  private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
+  /**
+   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final SetBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
 
+  /**
+   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
+  }
+
+  /**
+   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
+   * original {@code SetBinding}.
+   */
+  public SetBinding(SetBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
+    this.setLibrary(original.library());
+    this.setDependedOn(original.dependedOn());
+    contributors = new ArrayList<Binding<?>>();
   }
 
   @Override public void attach(Linker linker) {
@@ -55,30 +91,55 @@ public SetBinding(String key, Object requiredBy) {
     }
   }
 
+  public int size() {
+    int size = 0;
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
   @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
-    Set<T> result = new LinkedHashSet<T>(contributors.size());
-    for (Binding<?> contributor : contributors) {
-      Object contribution = contributor.get(); // Let runtime exceptions through.
-      if (contributor.provideKey.equals(provideKey)) {
-        result.addAll((Set<T>) contribution);
-      } else {
-        result.add((T) contribution);
+    List<T> result = new ArrayList<T>();
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        Binding<?> contributor = setBinding.contributors.get(i);
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
       }
     }
-    return Collections.unmodifiableSet(result);
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
   }
 
   @Override public void getDependencies(
       Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    getBindings.addAll(contributors);
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a Set binding");
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
   }
 
   @Override public String toString() {
-    return "SetBinding" + contributors;
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("SetBinding[");
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(setBinding.contributors.get(i));
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
   }
 }
diff --git a/core/src/main/java/dagger/internal/UniqueMap.java b/core/src/main/java/dagger/internal/UniqueMap.java
deleted file mode 100644
index 04a42a718..000000000
--- a/core/src/main/java/dagger/internal/UniqueMap.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * A map that fails when existing values are clobbered.
- */
-public class UniqueMap<K, V> extends LinkedHashMap<K, V> {
-  @Override public V put(K key, V value) {
-    V clobbered = super.put(key, value);
-    if (clobbered != null) {
-      super.put(key, clobbered); // Put things back as they were.
-      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
-    }
-    return null;
-  }
-  @Override public void putAll(Map<? extends K, ? extends V> map) {
-    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
-      put(entry.getKey(), entry.getValue());
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
new file mode 100644
index 000000000..2a629536c
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.TestingLoader;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static dagger.Provides.Type.SET;
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class ExtensionWithSetBindingsTest {
+  private static final AtomicInteger counter = new AtomicInteger(0);
+
+  @Singleton
+  static class RealSingleton {
+    @Inject Set<Integer> ints;
+  }
+
+  @Singleton
+  static class Main {
+    @Inject Set<Integer> ints;
+  }
+
+  @Module(injects = RealSingleton.class)
+  static class RootModule {
+    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
+  }
+
+  @Module(addsTo = RootModule.class, injects = Main.class )
+  static class ExtensionModule {
+    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
+  }
+
+  @Module
+  static class EmptyModule {
+  }
+
+  @Module(library = true)
+  static class DuplicateModule {
+    @Provides @Singleton String provideFoo() { return "foo"; }
+    @Provides @Singleton String provideBar() { return "bar"; }
+  }
+
+  @Test public void basicInjectionWithExtension() {
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
+    RealSingleton rs = root.get(RealSingleton.class);
+    assertThat(rs.ints).containsOnly(0, 1);
+
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    Main main = extension.get(Main.class);
+    assertThat(main.ints).containsOnly(0, 1, 2, 3);
+
+    // Second time around.
+    ObjectGraph extension2 = root.plus(new ExtensionModule());
+    Main main2 = extension2.get(Main.class);
+    assertThat(main2.ints).containsOnly(0, 1, 4, 5);
+  }
+
+  @Module(includes = ExtensionModule.class, overrides = true)
+  static class TestModule {
+    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
+  }
+
+  @Test public void basicInjectionWithExtensionAndOverrides() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertEquals("TestModule: Module overrides cannot contribute set bindings.", e.getMessage());
+    }
+  }
+
+  @Test public void duplicateBindingsInSecondaryModule() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new EmptyModule(), new DuplicateModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertTrue(e.getMessage().startsWith("DuplicateModule: Duplicate"));
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ece39029b..ef5b275fe 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -868,10 +868,10 @@ BoundTwoWays provideBoundTwoWays() {
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, injects =C.class)
+  @Module(complete = false, injects = C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
+  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 3960157a4..6a029060a 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -38,6 +38,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
 public final class SetBindingTest {
@@ -208,6 +209,22 @@ public void doStuff() {
     assertThat(logoutput.get()).contains("NullPointerException");
   }
 
+  @Test public void duplicateValuesContributed() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET) String provideString1() { return "a"; }
+      @Provides(type=SET) String provideString2() { return "a"; }
+      @Provides(type=SET) String provideString3() { return "b"; }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.strings).containsOnly("a", "b");
+  }
+
   @Test public void validateSetBinding() {
     class TestEntryPoint {
       @Inject Set<String> strings;
@@ -239,6 +256,55 @@ public void doStuff() {
     graph.validate();
   }
 
+  @Test public void validateLibraryModules() {
+    class TestEntryPoint {}
+
+    @Module(library = true)
+    class SetModule {
+      @Provides(type = SET)
+      public String provideString() {
+        return "";
+      }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = SetModule.class)
+    class TestModule {}
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
+        new TestModule(), new SetModule());
+    graph.validate();
+  }
+
+  @Test public void validateLibraryModules_nonLibraryContributors() {
+    class TestEntryPoint {}
+
+    @Module(library = true)
+    class SetModule1 {
+      @Provides(type = SET)
+      public String provideString() {
+        return "a";
+      }
+    }
+
+    @Module
+    class SetModule2 {
+      @Provides(type = SET)
+      public String provideString() {
+        return "b";
+      }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = { SetModule1.class, SetModule2.class })
+    class TestModule {}
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
+        new TestModule(), new SetModule1(), new SetModule2());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
+
   static class Logger {
     @Inject Set<LogSink> loggers;
     public void log(String text, Throwable error) {
diff --git a/core/src/test/java/dagger/internal/SingletonBindingTest.java b/core/src/test/java/dagger/internal/SingletonBindingTest.java
index 8c6154cfd..515a2eb7a 100644
--- a/core/src/test/java/dagger/internal/SingletonBindingTest.java
+++ b/core/src/test/java/dagger/internal/SingletonBindingTest.java
@@ -1,76 +1,76 @@
-/**
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class SingletonBindingTest {
-  private Binding<String> wrappedBinding;
-  private Binding<String> singletonBinding;
-
-  @Before public void setUp() {
-    wrappedBinding = new StringBinding();
-    singletonBinding = Linker.scope(wrappedBinding);
-  }
-
-  @Test public void testSingletonBindingIsSingleton() {
-    assertThat(singletonBinding.isSingleton()).isTrue();
-  }
-
-  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
-  @Test public void testSingletonBindingDelegatesSetLinked() {
-    singletonBinding.setLinked();
-    assertThat(wrappedBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsLinked() {
-    wrappedBinding.setLinked();
-    assertThat(singletonBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetVisiting() {
-    singletonBinding.setVisiting(true);
-    assertThat(wrappedBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsVisiting() {
-    wrappedBinding.setVisiting(true);
-    assertThat(singletonBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetCycleFree() {
-    singletonBinding.setCycleFree(true);
-    assertThat(wrappedBinding.isCycleFree()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsCycleFree() {
-    wrappedBinding.setCycleFree(true);
-    assertThat(singletonBinding.isCycleFree()).isTrue();
-  }
-
-  private static class StringBinding extends Binding<String> {
-    private StringBinding() {
-      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
-    }
-
-  }
-}
+/**
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class SingletonBindingTest {
+  private Binding<String> wrappedBinding;
+  private Binding<String> singletonBinding;
+
+  @Before public void setUp() {
+    wrappedBinding = new StringBinding();
+    singletonBinding = Linker.scope(wrappedBinding);
+  }
+
+  @Test public void testSingletonBindingIsSingleton() {
+    assertThat(singletonBinding.isSingleton()).isTrue();
+  }
+
+  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
+  @Test public void testSingletonBindingDelegatesSetLinked() {
+    singletonBinding.setLinked();
+    assertThat(wrappedBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsLinked() {
+    wrappedBinding.setLinked();
+    assertThat(singletonBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetVisiting() {
+    singletonBinding.setVisiting(true);
+    assertThat(wrappedBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsVisiting() {
+    wrappedBinding.setVisiting(true);
+    assertThat(singletonBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetCycleFree() {
+    singletonBinding.setCycleFree(true);
+    assertThat(wrappedBinding.isCycleFree()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsCycleFree() {
+    wrappedBinding.setCycleFree(true);
+    assertThat(singletonBinding.isCycleFree()).isTrue();
+  }
+
+  private static class StringBinding extends Binding<String> {
+    private StringBinding() {
+      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
+    }
+
+  }
+}
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index a135d0110..b364cde05 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -25,9 +25,8 @@
  */
 public final class TestingLoader extends Loader {
 
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
     ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
-    adapter.module = (instance != null) ? instance : adapter.newModule();
     return adapter;
   }
 
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 2819a5e55..b5d54f095 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -24,24 +24,21 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
 //TODO: Reduce the complexity of this and/or replace with a mock or fake.
 public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
-  final Class<?> moduleClass;
-
-  public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
+  public TestingModuleAdapter(Class<M> moduleClass, Module annotation) {
     super(
+        moduleClass,
         injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
         annotation.complete(),
         annotation.library());
-    this.moduleClass = moduleClass;
   }
 
   private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
@@ -55,7 +52,7 @@ public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
     return result;
   }
 
-  @Override public void getBindings(Map<String, Binding<?>> bindings) {
+  @Override public void getBindings(BindingsGroup bindings, M module) {
     for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
@@ -82,15 +79,15 @@ public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
           String key = Keys.get(genericReturnType, method.getAnnotations(), method);
           switch (provides.type()) {
             case UNIQUE:
-              handleBindings(bindings, method, key, library);
+              handleBindings(bindings, module, method, key, library);
               break;
             case SET:
               String setKey = Keys.getSetKey(method.getGenericReturnType(),
                   method.getAnnotations(), method);
-              handleSetBindings(bindings, method, setKey, key, library);
+              handleSetBindings(bindings, module, method, setKey, key, library);
               break;
             case SET_VALUES:
-              handleSetBindings(bindings, method, key, key, library);
+              handleSetBindings(bindings, module, method, key, key, library);
               break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
@@ -100,14 +97,17 @@ public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
     }
   }
 
-  private void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
       boolean library) {
-    bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String setKey,
-      String providerKey, boolean library) {
-    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, providerKey, module, library));
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
+      String setKey, String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey,
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
   }
 
   @Override public M newModule() {
@@ -128,10 +128,14 @@ private void handleSetBindings(Map<String, Binding<?>> bindings, Method method,
     }
   }
 
+  @Override public String toString() {
+    return "TestingModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
   /**
    * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
-  public static <M> ModuleAdapter<M> create(Class<? extends M> moduleClass) {
+  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
     Module annotation = moduleClass.getAnnotation(Module.class);
     if (annotation == null) {
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
@@ -146,14 +150,14 @@ private void handleSetBindings(Map<String, Binding<?>> bindings, Method method,
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
-    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
-      super(key, null, method.isAnnotationPresent(Singleton.class),
-          moduleClass.getName() + "." + method.getName() + "()");
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
@@ -196,9 +200,5 @@ public ProviderMethodBinding(Method method, String key, Object instance, boolean
     @Override public void injectMembers(T t) {
       throw new AssertionError("Provides method bindings are not MembersInjectors");
     }
-
-    @Override public String toString() {
-      return method.toString();
-    }
   }
 }
diff --git a/deploy_website.sh b/deploy_website.sh
index 1fde1bd57..2f609c959 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -31,7 +31,7 @@ rm -rf *
 cp -R ../website/* .
 
 # Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
 mkdir javadoc
 unzip javadoc.zip -d javadoc
 rm javadoc.zip
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 87a3dc3ab..9b239b0bd 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
@@ -54,7 +54,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-activity-graphs/AndroidManifest.xml
rename to examples/android-activity-graphs/src/main/AndroidManifest.xml
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 465d66d5d..6fd695ce4 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -25,7 +25,7 @@
 
 /**
  * This module represents objects which exist only for the scope of a single activity. We can
- * safely create singletons using the activity instance because ths entire object graph will only
+ * safely create singletons using the activity instance because the entire object graph will only
  * ever exist inside of that activity.
  */
 @Module(
@@ -33,7 +33,7 @@
         HomeActivity.class,
         HomeFragment.class
     },
-    complete = false,
+    addsTo = AndroidModule.class,
     library = true
 )
 public class ActivityModule {
diff --git a/examples/android-activity-graphs/res/values/strings.xml b/examples/android-activity-graphs/src/main/res/values/strings.xml
similarity index 100%
rename from examples/android-activity-graphs/res/values/strings.xml
rename to examples/android-activity-graphs/src/main/res/values/strings.xml
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 593ccdc3a..0cc0591ec 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
@@ -50,7 +50,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-simple/AndroidManifest.xml
rename to examples/android-simple/src/main/AndroidManifest.xml
diff --git a/examples/android-simple/res/values/strings.xml b/examples/android-simple/src/main/res/values/strings.xml
similarity index 100%
rename from examples/android-simple/res/values/strings.xml
rename to examples/android-simple/src/main/res/values/strings.xml
diff --git a/examples/pom.xml b/examples/pom.xml
index 909721bbd..a0fe83be5 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
@@ -68,9 +68,9 @@
     <pluginManagement>
       <plugins>
         <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <groupId>com.simpligility.maven.plugins</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.6.0</version>
+          <version>4.1.1</version>
           <configuration>
             <sdk>
               <platform>16</platform>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index f6d31bbd5..54ba98e1c 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
@@ -38,5 +38,16 @@
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/examples/simple/src/test/java/coffee/CoffeeMakerTest.java b/examples/simple/src/test/java/coffee/CoffeeMakerTest.java
new file mode 100644
index 000000000..310a188a1
--- /dev/null
+++ b/examples/simple/src/test/java/coffee/CoffeeMakerTest.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package coffee;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+public class CoffeeMakerTest {
+  @Inject CoffeeMaker coffeeMaker;
+  @Inject Heater heater;
+
+  @Before public void setUp() {
+    ObjectGraph.create(new TestModule()).inject(this);
+  }
+
+  @Module(
+      includes = DripCoffeeModule.class,
+      injects = CoffeeMakerTest.class,
+      overrides = true
+  )
+  static class TestModule {
+    @Provides @Singleton Heater provideHeater() {
+      return Mockito.mock(Heater.class);
+    }
+  }
+
+  @Test public void testHeaterIsTurnedOnAndThenOff() {
+    Mockito.when(heater.isHot()).thenReturn(true);
+    coffeeMaker.brew();
+    Mockito.verify(heater, Mockito.times(1)).on();
+    Mockito.verify(heater, Mockito.times(1)).off();
+  }
+}
diff --git a/pom.xml b/pom.xml
index ec9fa18f2..7d08bede2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,9 +26,9 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.1.1-SNAPSHOT</version>
+  <version>1.2.3-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
-  <description>A JSR-330 dependency injector for Android and Java.</description>
+  <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
 
   <modules>
@@ -43,11 +43,15 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.1.1</javawriter.version>
+    <javapoet.version>1.0.0</javapoet.version>
+    <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
     <fest.version>1.4</fest.version>
+    <truth.version>0.13</truth.version>
+    <compile-testing.version>0.4</compile-testing.version>
+    <mockito.version>1.10.19</mockito.version>
   </properties>
 
   <scm>
@@ -83,8 +87,13 @@
       </dependency>
       <dependency>
         <groupId>com.squareup</groupId>
-        <artifactId>javawriter</artifactId>
-        <version>${javawriter.version}</version>
+        <artifactId>javapoet</artifactId>
+        <version>${javapoet.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
@@ -96,6 +105,21 @@
         <artifactId>fest-assert</artifactId>
         <version>${fest.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.testing.compile</groupId>
+        <artifactId>compile-testing</artifactId>
+        <version>${compile-testing.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.truth0</groupId>
+        <artifactId>truth</artifactId>
+        <version>${truth.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.mockito</groupId>
+        <artifactId>mockito-core</artifactId>
+        <version>${mockito.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -132,7 +156,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.3.2</version>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
diff --git a/website/index.html b/website/index.html
index 7d8b0d47c..8406b471a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -391,7 +391,7 @@ <h4>Module overrides</h4>
             <p>For more substantial variations it's often simpler to use a different combination of modules.</p>
 
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="https://search.maven.org/remote_content?g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
             <p>You will need to include the Dagger JAR in your application's runtime.  In order to activate code generation you will need to include the compiler JAR in your build at compile time.</p>
             <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/dagger">available on GitHub</a>.</p>
 
@@ -451,7 +451,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="javadoc/index.html">Javadoc</a></li>
                 <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+ Community</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/dagger?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -475,7 +475,7 @@ <h3 id="license">License</h3>
 
         // Spy on scroll position for real-time updating of current section.
         $('body').scrollspy();
-        
+
         // Use smooth-scroll for internal links.
         $('a').smoothScroll();
 
