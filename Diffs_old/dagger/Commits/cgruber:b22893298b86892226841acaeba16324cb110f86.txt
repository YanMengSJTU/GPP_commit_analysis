diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 45eebb087..1d71e9a75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1,10 +1,12 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -13,13 +15,17 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
 import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.LinkedList;
 import java.util.Set;
+import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -30,19 +36,29 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 
 public class BindingGraphValidator implements Validator<BindingGraph> {
+
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
+  private final ScopeCycleValidation disableInterComponentScopeCycles;
 
-  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry) {
+  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry,
+      ScopeCycleValidation disableInterComponentScopeCycles) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
+    this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
   }
 
   @Override
@@ -52,6 +68,7 @@
     ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
+    validateDependencyScopes(subject, reportBuilder);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
       ResolvedBindings resolvedBinding = resolvedBindings.get(
@@ -92,6 +109,142 @@ boolean visitResolvedBinding(
     return reportBuilder.build();
   }
 
+  /**
+   * Validates that among the dependencies are at most one scoped dependency,
+   * that there are no cycles within the scoping chain, and that singleton
+   * components have no scoped dependencies.
+   */
+  private void validateDependencyScopes(BindingGraph subject,
+      Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor descriptor = subject.componentDescriptor();
+    Optional<AnnotationMirror> scope = subject.componentDescriptor().scope();
+    ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
+    if (scope.isPresent()) {
+      // Dagger 1.x scope compatibility requires this be suppress-able.
+      if (disableInterComponentScopeCycles.diagnosticKind().isPresent()
+          && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+        // Singleton is a special-case representing the longest lifetime, and therefore
+        // @Singleton components may not depend on scoped components
+        if (!scopedDependencies.isEmpty()) {
+          StringBuilder message = new StringBuilder(
+              "This @Singleton component cannot depend on scoped components:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          reportBuilder.addItem(message.toString(),
+              disableInterComponentScopeCycles.diagnosticKind().get(),
+              descriptor.componentDefinitionType(),
+              descriptor.componentAnnotation());
+        }
+      } else if (scopedDependencies.size() > 1) {
+        // Scoped components may depend on at most one scoped component.
+        StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+            .append(' ')
+            .append(descriptor.componentDefinitionType().getQualifiedName())
+            .append(" depends on more than one scoped component:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      } else {
+        // Dagger 1.x scope compatibility requires this be suppress-able.
+        if (!disableInterComponentScopeCycles.equals(ScopeCycleValidation.NONE)) {
+          validateScopeHierarchy(descriptor.componentDefinitionType(),
+              descriptor.componentDefinitionType(),
+              reportBuilder,
+              new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+              new ArrayDeque<TypeElement>());
+        }
+      }
+    } else {
+      // Scopeless components may not depend on scoped components.
+      if (!scopedDependencies.isEmpty()) {
+        StringBuilder message =
+            new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
+                .append(" (unscoped) cannot depend on scoped components:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      }
+    }
+  }
+
+  /**
+   * Append and format a list of indented component types (with their scope annotations)
+   */
+  private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
+    for (TypeElement scopedComponent : types) {
+      message.append(INDENT);
+      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      if (scope.isPresent()) {
+        message.append(ErrorMessages.format(scope.get())).append(' ');
+      }
+      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
+          .append('\n');
+    }
+  }
+
+  /**
+   * Returns a set of type elements containing only those found in the input set that have
+   * a scoping annotation.
+   */
+  private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+    return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
+      @Override public boolean apply(TypeElement input) {
+        return getScopeAnnotation(input).isPresent();
+      }
+    }).toSet();
+  }
+
+  /**
+   * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
+   * components are in a hierarchical relationship terminating with Singleton.
+   *
+   * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
+   * themselves, since a component's presence within its own dependency path implies a cyclical
+   * relationship between scopes.
+   */
+  private void validateScopeHierarchy(TypeElement rootComponent,
+      TypeElement componentType,
+      Builder<BindingGraph> reportBuilder,
+      Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+      Deque<TypeElement> scopedDependencyStack) {
+    Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+    if (scope.isPresent()) {
+      Equivalence.Wrapper<AnnotationMirror> wrappedScope =
+          AnnotationMirrors.equivalence().wrap(scope.get());
+      if (scopeStack.contains(wrappedScope)) {
+        scopedDependencyStack.push(componentType);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (disableInterComponentScopeCycles.diagnosticKind().isPresent()) {
+          reportBuilder.addItem(message.toString(),
+              disableInterComponentScopeCycles.diagnosticKind().get(),
+              rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+              MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation.get())));
+          if (scopedDependencies.size() == 1) {
+            // empty can be ignored (base-case), and > 1 is a different error reported separately.
+            scopeStack.push(wrappedScope);
+            scopedDependencyStack.push(componentType);
+            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                reportBuilder, scopeStack, scopedDependencyStack);
+            scopedDependencyStack.pop();
+            scopeStack.pop();
+          }
+        } // else: we skip component dependencies which are not components
+      }
+    }
+  }
+
   /**
    * Validates that the scope (if any) of this component are compatible with the scopes of the
    * bindings available in this component
@@ -311,4 +464,30 @@ private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> reques
     abstract boolean visitResolvedBinding(
         Deque<DependencyRequest> requestPath, ResolvedBindings binding);
   }
+
+  /**
+   * {@code -Adagger.disableInterComponentScopeValidation=none} will suppress validation of
+   * scoping relationships between dagger {@code @Component} interfaces. This is a migration
+   * tool to permit easier migration from Dagger 1.x which used {@code @Singleton} for scoped
+   * graphs in any lifetime.
+   *
+   * <p>The value can be (case-insensitively) set to any of {@code ERROR}, {@code WARNING},
+   * or {@code NONE} and defaults to {@code ERROR}.
+   */
+  enum ScopeCycleValidation {
+    ERROR,
+    WARNING,
+    NONE;
+
+    Optional<Diagnostic.Kind> diagnosticKind() {
+      switch (this) {
+        case ERROR:
+          return Optional.of(Diagnostic.Kind.ERROR);
+        case WARNING:
+          return Optional.of(Diagnostic.Kind.WARNING);
+        default:
+          return Optional.absent();
+      }
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index f5f49ffd2..195797429 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -22,8 +22,10 @@
 import dagger.MapKey;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.BindingGraphValidator.ScopeCycleValidation;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
@@ -37,6 +39,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -68,6 +72,11 @@ public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
   }
 
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY);
+  }
+
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
@@ -118,9 +127,8 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         provisionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
-        injectBindingRegistry);
+        injectBindingRegistry, disableInterComponentScopeValidation(processingEnv));
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
@@ -168,4 +176,24 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     }
     return false;
   }
+
+  private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
+      "dagger.disableInterComponentScopeValidation";
+
+  private static ScopeCycleValidation disableInterComponentScopeValidation(
+      ProcessingEnvironment processingEnv) {
+    Map<String, String> options = processingEnv.getOptions();
+    if(options.containsKey(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY)) {
+      try {
+        return ScopeCycleValidation.valueOf(
+            options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY).toUpperCase());
+      } catch (IllegalArgumentException e) {
+        processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
+            + DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY
+            + " may only have the values ERROR, WARNING, or NONE (case insensitive) "
+            + " found: " + options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY));
+      }
+    }
+    return ScopeCycleValidation.ERROR;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index a93a11027..6f1be009f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,6 +21,7 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
 
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -39,7 +40,15 @@
   abstract ImmutableSet<Item> items();
 
   boolean isClean() {
-    return items().isEmpty();
+    for (Item item : items()) {
+      switch (item.kind()) {
+        case ERROR:
+          return false;
+        default:
+          break;
+      }
+    }
+    return true;
   }
 
   void printMessagesTo(Messager messager) {
@@ -51,15 +60,16 @@ void printMessagesTo(Messager messager) {
   @AutoValue
   static abstract class Item implements PrintableErrorMessage {
     abstract String message();
+    abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
 
     @Override
     public void printMessageTo(Messager messager) {
       if (annotation().isPresent()) {
-        messager.printMessage(ERROR, message(), element(), annotation().get());
+        messager.printMessage(kind(), message(), element(), annotation().get());
       } else {
-        messager.printMessage(ERROR, message(), element());
+        messager.printMessage(kind(), message(), element());
       }
     }
   }
@@ -81,13 +91,28 @@ T getSubject() {
     }
 
     Builder<T> addItem(String message, Element element) {
-      items.add(new AutoValue_ValidationReport_Item(message, element,
-          Optional.<AnnotationMirror>absent()));
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
       return this;
     }
 
     Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
-      items.add(new AutoValue_ValidationReport_Item(message, element, Optional.of(annotation)));
+      addItem(message, ERROR, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
+      addItem(message, kind, element, Optional.of(annotation));
+      return this;
+    }
+
+    private Builder<T> addItem(String message, Kind kind, Element element,
+        Optional<AnnotationMirror> annotation) {
+      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));
       return this;
     }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
new file mode 100644
index 000000000..da0c2b06c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class GraphValidationScopingTest {
+  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @Singleton String string() { return \"a string\"; }",
+        "  @Provides long integer() { return 0L; }",
+        "  @Provides float floatingPoint() { return 0.0f; }",
+        "}");
+    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
+        + "      @Provides @Singleton String test.ScopedModule.string()\n"
+        + "      @Singleton class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope",
+        "@interface PerTest {}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "@PerTest", // incompatible scope
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
+        "  @Provides long integer() { return 0L; }", // unscoped - valid
+        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+        "}");
+    String errorMessage = "test.MyComponent scoped with @Singleton "
+        + "may not reference bindings with different scopes:\n"
+        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
+        + "      @test.PerTest class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
+    // If a scoped component will have dependencies, they must only include, at most, a single
+    // scoped component
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  static class A { @Inject A() {} }",
+        "  static class B { @Inject B() {} }",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject singletonScopedA = JavaFileObjects.forSourceLines("test.SingletonComponentA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentA {",
+        "  SimpleType.A type();",
+        "}");
+    JavaFileObject singletonScopedB = JavaFileObjects.forSourceLines("test.SingletonComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentB {",
+        "  SimpleType.B type();",
+        "}");
+    JavaFileObject scopeless = JavaFileObjects.forSourceLines("test.ScopelessComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface ScopelessComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
+        "interface SimpleScopedComponent {",
+        "  SimpleType.A type();",
+        "}");
+    String errorMessage =
+        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
+        + "      @Singleton test.SingletonComponentA\n"
+        + "      @Singleton test.SingletonComponentB";
+    assert_().about(javaSources())
+        .that(
+            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopedComponent = JavaFileObjects.forSourceLines("test.ScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface ScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject unscopedComponent = JavaFileObjects.forSourceLines("test.UnscopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(dependencies = ScopedComponent.class)",
+        "interface UnscopedComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
+        + "      @Singleton test.ScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, scopedComponent, unscopedComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
+    // Singleton must be the widest lifetime of present scopes.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component",
+        "interface SimpleScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject singletonScoped = JavaFileObjects.forSourceLines("test.SingletonComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(dependencies = SimpleScopedComponent.class)",
+        "interface SingletonComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "This @Singleton component cannot depend on scoped components:\n"
+        + "      @test.SimpleScope test.SimpleScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, simpleScope, simpleScoped, singletonScoped))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentScopeAncestryMustNotCycle() {
+    // The dependency relationship of components is necessarily from shorter lifetimes to
+    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
+    // scopes on components such that they cycle.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopeA = JavaFileObjects.forSourceLines("test.ScopeA",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeA {}");
+    JavaFileObject scopeB = JavaFileObjects.forSourceLines("test.ScopeB",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeB {}");
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component",
+        "interface ComponentLong {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeB",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
+        + "      @test.ScopeA test.ComponentLong\n"
+        + "      @test.ScopeB test.ComponentMedium\n"
+        + "      @test.ScopeA test.ComponentShort";
+    assert_().about(javaSources())
+        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ee3507709..07999f55a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -508,98 +508,4 @@
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
-
-  @Test public void componentWithoutScopeIncludesScopedBindings() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @Singleton String string() { return \"a string\"; }",
-        "  @Provides long integer() { return 0L; }",
-        "  @Provides float floatingPoint() { return 0.0f; }",
-        "}");
-    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-        + "      @Provides @Singleton String test.ScopedModule.string()\n"
-        + "      @Singleton class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope",
-        "@interface PerTest {}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "@PerTest", // incompatible scope
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
-        "  @Provides long integer() { return 0L; }", // unscoped - valid
-        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
-        "}");
-    String errorMessage = "test.MyComponent scoped with @Singleton "
-        + "may not reference bindings with different scopes:\n"
-        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-        + "      @test.PerTest class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
-  }
 }
