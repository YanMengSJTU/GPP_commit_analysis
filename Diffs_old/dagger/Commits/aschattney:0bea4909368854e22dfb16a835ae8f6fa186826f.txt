diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index f5eeaeb89..3d0a11f7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -653,7 +653,7 @@ private FieldSpec addFrameworkField(
                 ? contributionBindingField.type().rawType
                 : contributionBindingField.type(),
             contributionBindingField.name());
-    contributionField.addModifiers(PRIVATE);
+    //contributionField.addModifiers(PRIVATE);
     if (useRawType) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
@@ -837,6 +837,21 @@ private void implementInterfaceMethods() {
               }
               // fall through
             default:
+
+              final MemberSelect memberSelect = memberSelects.get(BindingKey.membersInjection(interfaceRequest.key()));
+              if (memberSelect != null) {
+                final CodeBlock expressionFor = memberSelect.getExpressionFor(name);
+                final Optional<String> variableName = interfaceRequest.overriddenVariableName();
+                String name = variableName.isPresent() ? variableName.get() : "obj";
+                interfaceMethod.addStatement("$T $L = $L", ClassName.get(interfaceRequest.key().type()), name, codeBlock);
+                interfaceMethod.addStatement("$L.injectMembers($L)", expressionFor, name);
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.addStatement("return $L", name);
+                }
+              }else {
+                interfaceMethod.addStatement("return $L", codeBlock);
+              }
+
               /*CodeBlock.Builder builder = CodeBlock.builder();
               final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
               if (supportsTestDelegate) {
@@ -845,7 +860,6 @@ private void implementInterfaceMethods() {
                         .add("return $L.get($L)", CodeBlock.of(fieldName), codeBlock)
                         .nextControlFlow("else");
               }*/
-              interfaceMethod.addStatement("return $L", codeBlock);
               /*if (supportsTestDelegate) {
                 builder.endControlFlow();
               }*/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
index 6bbec4609..de999e8d2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
@@ -9,6 +9,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import java.util.*;
+import java.util.stream.Collectors;
 
 import static dagger.internal.codegen.Util.*;
 
@@ -51,8 +52,20 @@ ClassName nameGeneratedType(DI input) {
         builder.addField(TYPENAME_INJECTOR, FIELDNAME_INJECTOR, Modifier.PRIVATE);
 
         for (TypeElement component : components) {
-            final SpecComponentInfo componentInfo = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory);
-            final List<MethodSpec.Builder> methodBuilders = componentInfo.getMethods();
+            final List<SpecComponentInfo> infos = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory);
+            final List<MethodSpec.Builder> methodBuilders = infos.stream()
+                    .flatMap(info -> info.getMethods().stream())
+                    .collect(Collectors.toList());
+            List<String> methodNames = new ArrayList<>();
+            final Iterator<MethodSpec.Builder> it = methodBuilders.iterator();
+            while(it.hasNext()) {
+                final String name = it.next().build().name;
+                if (!methodNames.contains(name)) {
+                    methodNames.add(name);
+                }else {
+                    it.remove();
+                }
+            }
             for (MethodSpec.Builder methodBuilder : methodBuilders) {
                 List<CodeBlock> blocks = new ArrayList<>();
                 blocks.add(CODEBLOCK_RETURN_BUILDER);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
index 5dccd9f8b..d786b58b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -4,6 +4,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
+import dagger.Trigger;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -11,6 +12,7 @@
 import javax.lang.model.element.TypeElement;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
 
@@ -24,84 +26,97 @@
     protected final BindingGraph bindingGraph;
     protected List<ComponentInfo> infos = new ArrayList<>();
 
-    public static SpecComponentInfo forSpec(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    public static List<SpecComponentInfo> forSpec(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+                .stream()
+                .distinct()
+                .collect(Collectors.toList());
     }
 
-    public static GeneratorComponentInfo forGenerator(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    public static List<GeneratorComponentInfo> forGenerator(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+                .stream()
+                .distinct()
+                .collect(Collectors.toList());
     }
 
-    public static TriggerComponentInfo forTrigger(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    public static List<TriggerComponentInfo> forTrigger(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+                .stream()
+                .distinct()
+                .collect(Collectors.toList());
     }
 
-    private static TriggerComponentInfo createTriggerComponentInfo(TypeElement component,
-                                                         ComponentDescriptor.Factory componentDescriptorFactory,
-                                                         BindingGraph.Factory bindingGraphFactory) {
+    private static List<TriggerComponentInfo> createTriggerComponentInfo(TypeElement component,
+                                                            ComponentDescriptor.Factory componentDescriptorFactory,
+                                                            BindingGraph.Factory bindingGraphFactory) {
+        List<TriggerComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
         final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
         final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph);
+        infos.add(componentInfo);
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            componentInfo.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph));
-            createTriggerSubcomponentInfo(subGraph, componentInfo, bindingGraphFactory);
+            infos.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph));
+            infos.addAll(createTriggerSubcomponentInfo(subGraph));
         }
-        return componentInfo;
+        return infos;
     }
 
-    private static void createTriggerSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentMethodOverrider, BindingGraph.Factory factory) {
+    private static List<TriggerComponentInfo> createTriggerSubcomponentInfo(BindingGraph bindingGraph) {
+        List<TriggerComponentInfo> infos = new ArrayList<>();
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
             ComponentDescriptor subcomponentDescriptor = subGraph.componentDescriptor();
-            final ComponentInfo componentInfo =
+            final TriggerComponentInfo componentInfo =
                     new TriggerComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, subGraph);
-            componentMethodOverrider.add(componentInfo);
-            createTriggerSubcomponentInfo(subGraph, componentInfo, factory);
+            infos.add(componentInfo);
+            infos.addAll(createTriggerSubcomponentInfo(subGraph));
         }
+        return infos;
     }
 
-    private static SpecComponentInfo createSpecComponentInfo(TypeElement component,
+    private static List<SpecComponentInfo> createSpecComponentInfo(TypeElement component,
                                                          ComponentDescriptor.Factory componentDescriptorFactory,
                                                          BindingGraph.Factory bindingGraphFactory) {
+        List<SpecComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
         final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
-        final SpecComponentInfo componentMethodOverrider = new SpecComponentInfo(component, descriptor, bindingGraph);
-        createSpecSubcomponentInfo(descriptor, bindingGraphFactory, componentMethodOverrider);
-        return componentMethodOverrider;
-    }
-
-    private static void createSpecSubcomponentInfo(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory, SpecComponentInfo componentMethodOverrider) {
-        final ImmutableSet<ComponentDescriptor> subcomponents = descriptor.subcomponents();
-        for (ComponentDescriptor subcomponentDescriptor : subcomponents) {
-            final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
-            final SpecComponentInfo subcomponentOverrider =
-                    new SpecComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, bindingGraph);
-            componentMethodOverrider.add(subcomponentOverrider);
-            createSpecSubcomponentInfo(subcomponentDescriptor, bindingGraphFactory, subcomponentOverrider);
+        infos.add(new SpecComponentInfo(component, descriptor, bindingGraph));
+        for (BindingGraph graph : bindingGraph.subgraphs()) {
+            infos.addAll(createSpecSubcomponentInfo(graph.componentDescriptor(), graph));
+        }
+        return infos;
+    }
+
+    private static List<SpecComponentInfo> createSpecSubcomponentInfo(ComponentDescriptor descriptor, BindingGraph graph) {
+        List<SpecComponentInfo> infos = new ArrayList<>();
+        final SpecComponentInfo info = new SpecComponentInfo(descriptor.componentDefinitionType(), descriptor, graph);
+        infos.add(info);
+        for (BindingGraph subgraph : graph.subgraphs()) {
+            infos.addAll(createSpecSubcomponentInfo(subgraph.componentDescriptor(), subgraph));
         }
+        return infos;
     }
 
-    private static GeneratorComponentInfo createGeneratorComponentInfo(TypeElement component,
+    private static List<GeneratorComponentInfo> createGeneratorComponentInfo(TypeElement component,
                                                      ComponentDescriptor.Factory componentDescriptorFactory,
                                                      BindingGraph.Factory bindingGraphFactory) {
+        List<GeneratorComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
         final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
-        final GeneratorComponentInfo componentInfo = new GeneratorComponentInfo(component, descriptor, bindingGraph);
+        infos.add(new GeneratorComponentInfo(component, descriptor, bindingGraph));
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
-            componentInfo.add(new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph));
-            createGeneratorSubcomponentInfo(subGraph, componentInfo);
+            infos.addAll(createGeneratorSubcomponentInfo(subGraph.componentDescriptor(), subGraph));
         }
-        return componentInfo;
+        return infos;
     }
 
-    private static void createGeneratorSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentInfo) {
+    private static List<GeneratorComponentInfo> createGeneratorSubcomponentInfo(ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        List<GeneratorComponentInfo> infos = new ArrayList<>();
+        infos.add(new GeneratorComponentInfo(descriptor.componentDefinitionType(), descriptor, bindingGraph));
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
-            final ComponentInfo subcomponentInfo =
-                    new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph);
-            componentInfo.add(subcomponentInfo);
-            createGeneratorSubcomponentInfo(subGraph, subcomponentInfo);
+            infos.addAll(createGeneratorSubcomponentInfo(subGraph.componentDescriptor(), subGraph));
         }
+        return infos;
     }
 
     protected ComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
@@ -114,10 +129,14 @@ public void add(ComponentInfo info) {
         this.infos.add(info);
     }
 
-    public void process(TypeSpec.Builder builder) {
+    protected abstract String getId();
+
+    public List<String> process(TypeSpec.Builder builder) {
+        List<String> ids = new ArrayList<>();
         for (ComponentInfo info : infos) {
-            info.process(builder);
+            ids.addAll(info.process(builder));
         }
+        return ids;
     }
 
     public TypeElement getComponent() {
@@ -169,4 +188,17 @@ protected ClassName getBuilderClassName(TypeElement component) {
         }
         return builderClassName;
     }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof ComponentInfo)) {
+            return false;
+        }
+        return obj.getClass().equals(getClass()) && ((ComponentInfo) obj).getId().equals(getId());
+    }
+
+    @Override
+    public int hashCode() {
+        return getId().hashCode();
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 9a35fff15..edfc16645 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -20,7 +20,6 @@
     private BindingGraph.Factory factory;
     private ClassName appClass;
     private TestRegistry testRegistry;
-    private boolean hasGenerated = false;
 
     private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName appClass, TestRegistry testRegistry) {
         super(filer, elements);
@@ -60,7 +59,6 @@ private ClassName getClassName(BindingGraph input) {
         }else {
             final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
             addDecoratorType(builder, daggerBuilderClassName, builderClassName, delegateRequirements, componentName);
-            hasGenerated = true;
             return Optional.of(builder);
         }
     }
@@ -137,10 +135,6 @@ public ClassName getAccessorTypeName(ClassName app, String componentName) {
         return app.nestedClass(componentName + "Accessor");
     }
 
-    public boolean hasBeenGenerated() {
-        return this.hasGenerated;
-    }
-
     public static class Factory {
 
         private final Filer filer;
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
index ba9782b26..3590bb2f5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
@@ -1,5 +1,6 @@
 package dagger.internal.codegen;
 
+import java.util.List;
 import java.util.Optional;
 
 import com.squareup.javapoet.*;
@@ -46,8 +47,8 @@ ClassName nameGeneratedType(DI input) {
                 .build());
         builder.addField(appType, APP_FIELDNAME, Modifier.PRIVATE);
         for (TypeElement typeElement : input.getComponents()) {
-            final GeneratorComponentInfo info = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
-            info.process(builder);
+            final List<GeneratorComponentInfo> infos = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
+            infos.forEach(info -> info.process(builder));
         }
 
         final String st =
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
index e8ced1ccd..855f79b41 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -39,14 +39,10 @@ ClassName nameGeneratedType(Set<TypeElement> input) {
         final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(generatedTypeName)
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
 
-        final List<ComponentInfo> info = input
-                .stream()
-                .map(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory))
-                .collect(Collectors.toList());
-
-        for (ComponentInfo componentInfo : info) {
-            componentInfo.process(builder);
-        }
+        input.stream()
+                .flatMap(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory).stream())
+                .collect(Collectors.toList())
+                .forEach(info -> info.process(builder));
 
         builder.addMethod(MethodSpec.methodBuilder(METHOD_NAME_GET_INJECTOR)
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
index da59ef2b5..639b58515 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -18,10 +18,19 @@ protected GeneratorComponentInfo(TypeElement component, ComponentDescriptor desc
     }
 
     @Override
-    public void process(TypeSpec.Builder builder) {
-        super.process(builder);
+    protected String getId() {
+        return simpleVariableName(component);
+    }
+
+    @Override
+    public List<String> process(TypeSpec.Builder builder) {
+        List<String> ids = super.process(builder);
+
+        if (ids.contains(getId())) {
+            return ids;
+        }
 
-        final String name = simpleVariableName(component);
+        String name = getId();
         final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(name)
                 .addModifiers(Modifier.PUBLIC);
 
@@ -41,7 +50,7 @@ public void process(TypeSpec.Builder builder) {
                 if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
                         hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate()))
                         || requirement.kind() != ComponentRequirement.Kind.MODULE) {
-                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), requirement.variableName()).build());
                 }
             }
         } else {
@@ -74,7 +83,7 @@ public void process(TypeSpec.Builder builder) {
                 if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
                         hasNotOnlyNoArgConstructor) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
                     moduleConstructorStatements.add(CodeBlock.of(".$L($L)",
-                            methodName, simpleVariableName(typeElement)));
+                            methodName, requirement.variableName()));
                 }else if (requirement.kind() == ComponentRequirement.Kind.MODULE && !hasNotOnlyNoArgConstructor) {
                     moduleConstructorStatements.add(CodeBlock.of(".$L(new $T())",
                             methodName, ClassName.get(requirement.typeElement())));
@@ -107,6 +116,8 @@ public void process(TypeSpec.Builder builder) {
         }
 
         builder.addMethod(methodBuilder.build());
+        ids.add(name);
+        return ids;
     }
 
     private CodeBlock getBuilderInitStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 3b95225af..3f504d23f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -1,16 +1,20 @@
 package dagger.internal.codegen;
 
 import java.util.Optional;
+
 import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.*;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 import java.io.IOException;
 import java.util.*;
+import java.util.stream.Stream;
+
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.Util.distinctByKey;
 
-class InjectorGenerator extends SourceFileGenerator<DI>{
+class InjectorGenerator extends SourceFileGenerator<DI> {
 
     private static final String METHOD_NAME_PREFIX = "decorate";
 
@@ -47,50 +51,55 @@ ClassName nameGeneratedType(DI input) {
         builder.superclass(ClassName.get(appClass));
         createDecoratorClasses(builder, components, appClass);
         for (TypeElement component : components) {
-            final TriggerComponentInfo componentInfo =
+            final List<TriggerComponentInfo> infos =
                     ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory);
-            componentInfo.process(builder);
+            infos.forEach(info -> info.process(builder));
         }
 
         return Optional.of(builder);
     }
 
     private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> components, TypeElement appClass) {
-        for (TypeElement component : components) {
-            ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
-            final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            createDecoratorClass(builder, bindingGraph, appClass);
-        }
-    }
-
-    private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph bindingGraph, TypeElement appClass) {
         final ClassName appClassName = ClassName.get(appClass);
         ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
         final Decorator decorator = decoratorFactory.create(testAppClassName);
+
+        components.stream()
+                .map(componentDescriptorFactory::forComponent)
+                .map(bindingGraphFactory::create)
+                .flatMap(this::flatMapAllSubgraphs)
+                .filter(bindingGraph -> bindingGraph.componentDescriptor() != null && !bindingGraph.delegateRequirements().isEmpty())
+                .filter(distinctByKey(graph -> simpleVariableName(graph.componentDescriptor().componentDefinitionType())))
+                .forEach(graph -> createDecoratorClass(builder, graph, decorator, testAppClassName));
+
+    }
+
+    private Stream<BindingGraph> flatMapAllSubgraphs(BindingGraph graph) {
+        return Stream.concat(
+                Stream.of(graph),
+                graph.subgraphs().stream().flatMap(this::flatMapAllSubgraphs));
+    }
+
+    private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph bindingGraph, Decorator decorator, ClassName testAppClassName) {
         try {
             decorator.generate(bindingGraph);
-            if (decorator.hasBeenGenerated()) {
-                final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
-                final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
-                final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, componentName);
-                final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
-                final String methodName =  METHOD_NAME_PREFIX + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
-                final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
-                final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
-                builder.addField(field);
-                builder.addMethod(MethodSpec.methodBuilder(methodName)
-                        .addModifiers(Modifier.PUBLIC)
-                        .returns(accessorName)
-                        .addStatement("return this.$L", fieldName)
-                        .build());
-                builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
-            }
+            final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
+            final String componentName = bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+            final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, componentName);
+            final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
+            final String methodName = METHOD_NAME_PREFIX + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
+            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
+            final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
+            builder.addField(field);
+            builder.addMethod(MethodSpec.methodBuilder(methodName)
+                    .addModifiers(Modifier.PUBLIC)
+                    .returns(accessorName)
+                    .addStatement("return this.$L", fieldName)
+                    .build());
+            builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
         } catch (SourceFileGenerationException e) {
             throw new IllegalStateException("Exception while generating decorator: " + e);
         }
-        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            createDecoratorClass(builder, subGraph, appClass);
-        }
     }
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
index ee9657618..e4c70b75d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
@@ -19,15 +19,26 @@ protected SpecComponentInfo(TypeElement component, ComponentDescriptor descripto
     }
 
     @Override
-    public void process(TypeSpec.Builder builder) {
-        super.process(builder);
+    protected String getId() {
+        return simpleVariableName(component);
+    }
+
+    @Override
+    public List<String> process(TypeSpec.Builder builder) {
+        List<String> ids = super.process(builder);
+        if (ids.contains(getId())) {
+            return ids;
+        }
         final MethodSpec.Builder methodBuilder = buildMethod();
         methodBuilder.addModifiers(Modifier.ABSTRACT);
-        builder.addMethod(methodBuilder.build());
+        MethodSpec method = methodBuilder.build();
+        builder.addMethod(method);
+        ids.add(getId());
+        return ids;
     }
 
     private MethodSpec.Builder buildMethod() {
-        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(simpleVariableName(component))
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(getId())
                 .addModifiers(Modifier.PUBLIC);
 
         ClassName builderClassName = getBuilderClassName(component);
@@ -45,7 +56,7 @@ public void process(TypeSpec.Builder builder) {
     public List<MethodSpec.Builder> getMethods() {
         List<MethodSpec.Builder> methodSpecs = new ArrayList<>();
         for (ComponentInfo info : infos) {
-            methodSpecs.addAll(((SpecComponentInfo)info).getMethods());
+            methodSpecs.addAll(((SpecComponentInfo) info).getMethods());
         }
         methodSpecs.add(buildMethod());
         return methodSpecs;
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index e224a303a..6899ca6d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -6,6 +6,8 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 
+import java.util.List;
+
 import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
 import static dagger.internal.codegen.Util.lowerCaseFirstLetter;
 
@@ -23,15 +25,14 @@ protected TriggerComponentInfo(TypeElement typeElement, ComponentDescriptor desc
     }
 
     @Override
-    public void process(TypeSpec.Builder builder) {
-        super.process(builder);
+    public List<String> process(TypeSpec.Builder builder) {
+        List<String> ids = super.process(builder);
 
-        if (noActionRequired()) {
-            return;
+        if (noActionRequired(ids)) {
+            return ids;
         }
 
-        final TypeElement component = descriptor.componentDefinitionType();
-        String methodName = simpleVariableName(component);
+        String methodName = getId();
         final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                 .addAnnotation(Override.class)
                 .addModifiers(Modifier.PUBLIC);
@@ -43,14 +44,21 @@ public void process(TypeSpec.Builder builder) {
         final String decoratorName = getDecoratorFieldName(component);
         methodBuilder.addStatement("return this.$L.$L(super.$L(builder))", decoratorName, METHODNAME_DECORATE, methodName);
         builder.addMethod(methodBuilder.build());
+        ids.add(methodName);
+        return ids;
     }
 
     protected String getDecoratorFieldName(TypeElement component) {
         return lowerCaseFirstLetter(component.getSimpleName().toString()) + DECORATOR;
     }
 
-    protected boolean noActionRequired() {
-        return bindingGraph.delegateRequirements().isEmpty();
+    protected boolean noActionRequired(List<String> ids) {
+        return bindingGraph.delegateRequirements().isEmpty() || ids.contains(getId());
+    }
+
+    @Override
+    protected String getId() {
+        return simpleVariableName(descriptor.componentDefinitionType());
     }
 
     protected ParameterSpec getBuilderParameterSpec(ClassName builderClassName) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index d01fe8832..16422a565 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -42,6 +42,9 @@
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
 import dagger.producers.Produces;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Predicate;
 import java.util.stream.Collector;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -562,6 +565,11 @@ public static ClassName getDaggerComponentClassName(Element component) {
         return getDaggerComponentClassName(ClassName.bestGuess(typeToString(component.asType())));
     }
 
+    public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
+        Map<Object,Boolean> seen = new ConcurrentHashMap<>();
+        return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
+    }
+
     public static final String METHOD_NAME_GET_INJECTOR = "getInjector";
     public static final ClassName TYPENAME_INJECTOR = ClassName.bestGuess("injector.Injector");
     public static final String SIMPLE_NAME_INJECTOR_APPLICATION = "DaggerApplication";
diff --git a/core/src/main/java/dagger/di/ActivityComponent.java b/core/src/main/java/dagger/di/ActivityComponent.java
new file mode 100644
index 000000000..9bd16f62a
--- /dev/null
+++ b/core/src/main/java/dagger/di/ActivityComponent.java
@@ -0,0 +1,3 @@
+package dagger.di;
+
+public interface ActivityComponent<A> extends BaseComponent<A> {}
diff --git a/core/src/main/java/dagger/di/ActivityComponentBuilder.java b/core/src/main/java/dagger/di/ActivityComponentBuilder.java
new file mode 100644
index 000000000..6c12c40a1
--- /dev/null
+++ b/core/src/main/java/dagger/di/ActivityComponentBuilder.java
@@ -0,0 +1,3 @@
+package dagger.di;
+
+public interface ActivityComponentBuilder<C extends ActivityComponent> extends BaseComponentBuilder<C> {}
diff --git a/core/src/main/java/dagger/di/BaseComponent.java b/core/src/main/java/dagger/di/BaseComponent.java
new file mode 100644
index 000000000..4ba15ad43
--- /dev/null
+++ b/core/src/main/java/dagger/di/BaseComponent.java
@@ -0,0 +1,5 @@
+package dagger.di;
+
+import dagger.MembersInjector;
+
+public interface BaseComponent<A> extends MembersInjector<A> {}
diff --git a/core/src/main/java/dagger/di/BaseComponentBuilder.java b/core/src/main/java/dagger/di/BaseComponentBuilder.java
new file mode 100644
index 000000000..88e7bdbf6
--- /dev/null
+++ b/core/src/main/java/dagger/di/BaseComponentBuilder.java
@@ -0,0 +1,5 @@
+package dagger.di;
+
+public interface BaseComponentBuilder<C extends BaseComponent> {
+    C build();
+}
diff --git a/core/src/main/java/dagger/di/ComponentBuilder.java b/core/src/main/java/dagger/di/ComponentBuilder.java
new file mode 100644
index 000000000..c199b6feb
--- /dev/null
+++ b/core/src/main/java/dagger/di/ComponentBuilder.java
@@ -0,0 +1,28 @@
+package dagger.di;
+
+import java.util.Map;
+
+import javax.inject.Provider;
+
+public class ComponentBuilder<P> {
+
+    private final Map<Class<?>, Provider<P>> builders;
+
+    public ComponentBuilder(Map<Class<?>, Provider<P>> builders) {
+        this.builders = builders;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
+                                                                                             A injectable,
+                                                                                             Config<A, C, T> config) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = config.configure(builder);
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public interface Config<A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> {
+        C configure(T builder);
+    }
+
+}
diff --git a/core/src/main/java/dagger/di/FragmentComponent.java b/core/src/main/java/dagger/di/FragmentComponent.java
new file mode 100644
index 000000000..aa1def100
--- /dev/null
+++ b/core/src/main/java/dagger/di/FragmentComponent.java
@@ -0,0 +1,3 @@
+package dagger.di;
+
+public interface FragmentComponent<F> extends BaseComponent<F> {}
diff --git a/core/src/main/java/dagger/di/FragmentComponentBuilder.java b/core/src/main/java/dagger/di/FragmentComponentBuilder.java
new file mode 100644
index 000000000..46db086ee
--- /dev/null
+++ b/core/src/main/java/dagger/di/FragmentComponentBuilder.java
@@ -0,0 +1,3 @@
+package dagger.di;
+
+public interface FragmentComponentBuilder<C extends FragmentComponent> extends BaseComponentBuilder<C>{}
