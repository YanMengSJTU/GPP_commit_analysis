diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
similarity index 57%
rename from compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
rename to compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index f5aa2baa5..3b4cb81e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,10 +15,24 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.Collections2;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
@@ -26,7 +40,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Factory;
 import dagger.MembersInjector;
@@ -40,17 +53,10 @@
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNames;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -59,19 +65,35 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorFactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final ProviderTypeRepository providerTypeRepository;
 
-  InjectConstructorFactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  FactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
     super(filer);
     this.providerTypeRepository = providerTypeRepository;
   }
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    TypeElement providedElement = binding.enclosingType();
-    ClassName providedClassName = ClassName.fromTypeElement(providedElement);
-    return providedClassName.peerNamed(providedClassName.simpleName() + "$$Factory");
+    TypeElement enclosingTypeElement = binding.enclosingType();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    String factoryPrefix = binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+      @Override protected String defaultAction(Element e, Void p) {
+        throw new IllegalStateException();
+      }
+
+      @Override
+      public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+        return "";
+      }
+
+      @Override
+      public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, e.getSimpleName().toString());
+      }
+    }, null);
+    return enclosingClassName.peerNamed(
+        enclosingClassName.simpleName() + "$$" + factoryPrefix + "Factory");
   }
 
   @Override
@@ -87,21 +109,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding binding)
       throws IOException {
-    ClassName providedClassName = ClassName.fromTypeElement(binding.enclosingType());
+    TypeMirror providedType = binding.providedKey().type();
+    String providedTypeString = Util.typeToString(providedType);
 
     writer.emitPackage(factoryClassName.packageName());
 
-    List<ClassName> importsBuilder = new ArrayList<ClassName>();
-    importsBuilder.addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()));
-    importsBuilder.add(ClassName.fromClass(Factory.class));
-    importsBuilder.add(ClassName.fromClass(Generated.class));
-    if (binding.requiresMemberInjection()) {
-      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
-    }
-    ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
-        .transform(Functions.toStringFunction())
-        .toSortedSet(Ordering.natural());
-    writer.emitImports(imports).emitEmptyLine();
+    writeImports(writer, factoryClassName, binding, providedType);
 
     writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
         .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
@@ -112,51 +125,65 @@ void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding bindi
 
     ImmutableMap.Builder<String, String> variableMapBuilder =
         new ImmutableMap.Builder<String, String>();
+    if (binding.bindingElement().getKind().equals(METHOD)) {
+      variableMapBuilder.put("module", binding.enclosingType().getQualifiedName().toString());
+    }
     if (binding.requiresMemberInjection()) {
-      variableMapBuilder.put("membersInjector",
-          type(MembersInjector.class, providedClassName.simpleName()));
+      variableMapBuilder.put("membersInjector", type(MembersInjector.class, providedTypeString));
     }
     ImmutableMap<String, String> variableMap = variableMapBuilder
         .putAll(providersAsVariableMap(providerNames))
         .build();
 
     if (binding.requiresMemberInjection()) {
-      writeMembersInjectorField(writer, providedClassName);
+      writeMembersInjectorField(writer, providedTypeString);
+    }
+    if (binding.bindingElement().getKind().equals(METHOD)) {
+      writeModuleField(writer, binding.enclosingType());
     }
     writeProviderFields(writer, providerNames);
 
     writeConstructor(writer, variableMap);
 
-    writer.emitAnnotation(Override.class)
-        .beginMethod(providedClassName.simpleName(), "get", EnumSet.of(PUBLIC));
-    String parameterString =
-        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
-            .transform(new Function<DependencyRequest, String>() {
-              @Override public String apply(DependencyRequest input) {
-                return providerUsageStatement(providerNames.get(input.key()), input.kind());
-              }
-            }));
-    if (binding.requiresMemberInjection()) {
-      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
-          providedClassName.simpleName(), parameterString);
-      writer.emitStatement("membersInjector.injectMembers(instance)");
-      writer.emitStatement("return instance");
-    } else {
-      writer.emitStatement("return new %s(%s)", providedClassName.simpleName(), parameterString);
-    }
-    writer.endMethod().emitEmptyLine();
+    writeGetMethod(writer, binding, providedTypeString, providerNames);
 
-    writeToString(writer, providedClassName);
+    // TODO(gak): write a sensible toString
 
     writer.endType();
   }
 
-  private void writeMembersInjectorField(JavaWriter writer, ClassName providedClassName)
+  private void writeImports(JavaWriter writer, ClassName factoryClassName, ProvisionBinding binding,
+      TypeMirror providedType) throws IOException {
+    ImmutableSortedSet.Builder<ClassName> importsBuilder =
+        ImmutableSortedSet.<ClassName>naturalOrder()
+            .addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()))
+            .add(ClassName.fromClass(Factory.class))
+            .add(ClassName.fromClass(Generated.class));
+    if (binding.requiresMemberInjection()) {
+      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
+    }
+    for (TypeElement referencedProvidedType : Mirrors.referencedTypes(providedType)) {
+      ClassName className = ClassName.fromTypeElement(referencedProvidedType);
+      if (!className.packageName().equals("java.lang")
+          && !className.packageName().equals(factoryClassName.packageName()))
+      importsBuilder.add(className);
+    }
+
+    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
+        .emitEmptyLine();
+  }
+
+  private void writeMembersInjectorField(JavaWriter writer, String providedTypeString)
       throws IOException {
-    writer.emitField(type(MembersInjector.class, providedClassName.fullyQualifiedName()),
+    writer.emitField(type(MembersInjector.class, providedTypeString),
         "membersInjector", EnumSet.of(PRIVATE, FINAL));
   }
 
+  private void writeModuleField(JavaWriter writer, TypeElement moduleType) throws IOException {
+    writer.emitField(moduleType.getQualifiedName().toString(), "module",
+        EnumSet.of(PRIVATE, FINAL));
+  }
+
   private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
       throws IOException {
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
@@ -171,22 +198,43 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
 
   private void writeConstructor(JavaWriter writer, Map<String, String> variableMap)
       throws IOException {
-    writer.beginConstructor(EnumSet.of(PUBLIC),
-        flattenVariableMap(variableMap),
-        ImmutableList.<String>of());
-    for (String variableName : variableMap.keySet()) {
-      writer.emitStatement("assert %s != null", variableName);
-      writer.emitStatement("this.%1$s = %1$s", variableName);
+    if (!variableMap.isEmpty()) {
+      writer.beginConstructor(EnumSet.of(PUBLIC),
+          flattenVariableMap(variableMap),
+          ImmutableList.<String>of());
+      for (String variableName : variableMap.keySet()) {
+        writer.emitStatement("assert %s != null", variableName);
+        writer.emitStatement("this.%1$s = %1$s", variableName);
+      }
+      writer.endConstructor().emitEmptyLine();
     }
-    writer.endConstructor().emitEmptyLine();
   }
 
-  private void writeToString(JavaWriter writer, ClassName providedClassName) throws IOException {
+  private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
+      String providedTypeString, final ImmutableBiMap<Key, String> providerNames)
+          throws IOException {
     writer.emitAnnotation(Override.class)
-        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
-        .emitStatement("return \"%s<%s>\"",
-            Factory.class.getSimpleName(), providedClassName.simpleName())
-        .endMethod();
+        .beginMethod(providedTypeString, "get", EnumSet.of(PUBLIC));
+    String parameterString =
+        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+            .transform(new Function<DependencyRequest, String>() {
+              @Override public String apply(DependencyRequest input) {
+                return providerUsageStatement(providerNames.get(input.key()), input.kind());
+              }
+            }));
+    if (binding.bindingElement().getKind().equals(METHOD)) {
+      writer.emitStatement("return module.%s(%s)",
+          binding.bindingElement().getSimpleName(), parameterString);
+    } else if (binding.requiresMemberInjection()) {
+      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
+          writer.compressType(providedTypeString), parameterString);
+      writer.emitStatement("membersInjector.injectMembers(instance)");
+      writer.emitStatement("return instance");
+    } else {
+      writer.emitStatement("return new %s(%s)",
+          writer.compressType(providedTypeString), parameterString);
+    }
+    writer.endMethod().emitEmptyLine();
   }
 
   private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 3a6f970ba..94b89a828 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -54,7 +54,7 @@
   private InjectFieldValidator fieldValidator;
   private InjectMethodValidator methodValidator;
   private ProvisionBinding.Factory provisionBindingFactory;
-  private InjectConstructorFactoryGenerator factoryWriter;
+  private FactoryGenerator factoryWriter;
   private MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private MembersInjectorGenerator membersInjectorWriter;
 
@@ -74,7 +74,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
     this.provisionBindingFactory =
         new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
-    this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
+    this.factoryWriter = new FactoryGenerator(filer, providerTypeRepository);
     this.membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(dependencyRequestFactory);
     this.membersInjectorWriter = new MembersInjectorGenerator(filer, providerTypeRepository);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4555454c..bd9238e98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -173,8 +173,6 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
     }
     writer.endMethod();
 
-    writeToString(writer, injectedClassName);
-
     writer.endType();
   }
 
@@ -202,14 +200,6 @@ private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> pro
     writer.endConstructor().emitEmptyLine();
   }
 
-  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
-    writer.emitAnnotation(Override.class)
-        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
-        .emitStatement("return \"%s<%s>\"",
-            MembersInjector.class.getSimpleName(), injectedClassName.simpleName())
-        .endMethod();
-  }
-
   private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
     return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
       @Override public String apply(Key key) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java
new file mode 100644
index 000000000..8d341e8ea
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessor.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the {@link Module}
+ * (and {@link Provides}) annotation.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): fold this into the inject processor when we start writing components
+public final class ModuleProcessor extends AbstractProcessor {
+  private Messager messager;
+  private ModuleValidator moduleValidator;
+  private ProvidesMethodValidator providesMethodValidator;
+  private ProvisionBinding.Factory provisionBindingFactory;
+  private FactoryGenerator moduleFactoriesGenerator;
+
+  @Override
+  public synchronized void init(ProcessingEnvironment processingEnv) {
+    super.init(processingEnv);
+    this.messager = processingEnv.getMessager();
+    this.moduleValidator = new ModuleValidator();
+    Elements elements = processingEnv.getElementUtils();
+    this.providesMethodValidator = new ProvidesMethodValidator(elements);
+    Types types = processingEnv.getTypeUtils();
+    this.provisionBindingFactory = new ProvisionBinding.Factory(
+        new Key.Factory(types, elements),
+        new DependencyRequest.Factory(elements, types));
+    this.moduleFactoriesGenerator = new FactoryGenerator(processingEnv.getFiler(),
+        new ProviderTypeRepository(elements, types));
+  }
+
+  @Override
+  public Set<String> getSupportedAnnotationTypes() {
+    return ImmutableSet.of(Module.class.getName(), Provides.class.getName());
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    // first, check and collect all provides methods
+    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
+    for (Element providesElement : roundEnv.getElementsAnnotatedWith(Provides.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
+    ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
+
+    // process each module
+    for (Element moduleElement : roundEnv.getElementsAnnotatedWith(Module.class)) {
+      ValidationReport<TypeElement> report =
+          moduleValidator.validate(ElementUtil.asTypeElement(moduleElement));
+      report.printMessagesTo(messager);
+
+      if (report.isClean()) {
+        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+            ImmutableSet.builder();
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+        for (ExecutableElement methodElement : moduleMethods) {
+          if (methodElement.getAnnotation(Provides.class) != null) {
+            moduleProvidesMethodsBuilder.add(methodElement);
+          }
+        }
+        ImmutableSet<ExecutableElement> moduleProvidesMethods =
+            moduleProvidesMethodsBuilder.build();
+
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+          // all of the provides methods in this module are valid!
+          // time to generate some factories!
+          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+              .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                @Override
+                public ProvisionBinding apply(ExecutableElement providesMethod) {
+                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                }
+              })
+              .toSet();
+
+          try {
+            for (ProvisionBinding binding : bindings) {
+              moduleFactoriesGenerator.generate(binding);
+            }
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
+      }
+    }
+
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
new file mode 100644
index 000000000..c34dea47b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Module;
+
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link Validator} for {@link Module}s.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ModuleValidator implements Validator<TypeElement> {
+  @Override
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    // TODO(gak): port the module validation
+    return builder.build();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index dc23b0bfd..d88c5512d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -311,10 +311,6 @@
         "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
         "    instance.stringProvider = stringProvider;",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<FieldInjection>\";",
-        "  }",
         "}");
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
         .compilesWithoutError()
@@ -365,10 +361,6 @@
         "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
         "        stringProvider);",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<MethodInjection>\";",
-        "  }",
         "}");
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
         .compilesWithoutError()
@@ -421,10 +413,6 @@
         "    instance.setString(stringAndSProvider.get());",
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<MixedMemberInjection>\";",
-        "  }",
         "}");
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
         .compilesWithoutError()
@@ -462,10 +450,6 @@
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(sProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"Factory<InjectConstructor>\";",
-        "  }",
         "}");
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
         .compilesWithoutError()
@@ -512,10 +496,6 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"Factory<AllInjections>\";",
-        "  }",
         "}");
     JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
         "test.AllInjections$$MembersInjector",
@@ -543,10 +523,6 @@
         "    instance.s = sProvider.get();",
         "    instance.s(sProvider.get());",
         "  }",
-        "",
-        "  @Override public String toString() {",
-        "    return \"MembersInjector<AllInjections>\";",
-        "  }",
         "}");
     ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
similarity index 55%
rename from compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
rename to compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index fda6afd03..7e7fa7503 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
@@ -27,20 +28,9 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
 import static org.truth0.Truth.ASSERT;
 
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 
-import dagger.Provides;
-
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 import javax.tools.JavaFileObject;
 
 import org.junit.Test;
@@ -48,8 +38,11 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public class ProvidesMethodValidatorTest {
-  @Test public void validate_notInModule() {
+public class ModuleProcessorTest {
+  // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
+  // for @Inject
+
+  @Test public void providesMethodNotInModule() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -61,12 +54,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
   }
 
-  @Test public void validate_abstract() {
+  @Test public void providesMethodAbstract() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -78,12 +71,12 @@
         "  @Provides abstract String provideString();",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
   }
 
-  @Test public void validate_private() {
+  @Test public void providesMethodPrivate() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -97,12 +90,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_PRIVATE);
   }
 
-  @Test public void validate_static() {
+  @Test public void providesMethodStatic() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -116,12 +109,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_STATIC);
   }
 
-  @Test public void validate_void() {
+  @Test public void providesMethodReturnVoid() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -133,12 +126,12 @@
         "  @Provides void provideNothing() {}",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
   }
 
-  @Test public void validate_typeParameter() {
+  @Test public void providesMethodWithTypeParameter() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -152,12 +145,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
   }
 
-  @Test public void validate_setValuesWildcard() {
+  @Test public void providesMethodSetValuesWildcard() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -175,12 +168,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
   }
 
-  @Test public void validate_setValuesRawSet() {
+  @Test public void providesMethodSetValuesRawSet() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -198,12 +191,12 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
   }
 
-  @Test public void validate_setValuesNotASet() {
+  @Test public void providesMethodSetValuesNotASet() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -221,33 +214,120 @@
         "  }",
         "}");
     ASSERT.about(javaSource()).that(moduleFile)
-        .processedWith(validationProcessor())
+        .processedWith(new ModuleProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
   }
 
-  private Processor validationProcessor() {
-    return new AbstractProcessor() {
-      ProvidesMethodValidator validator;
-
-      @Override
-      public synchronized void init(ProcessingEnvironment processingEnv) {
-        super.init(processingEnv);
-        this.validator = new ProvidesMethodValidator(processingEnv.getElementUtils());
-      }
-
-      @Override public Set<String> getSupportedAnnotationTypes() {
-        return ImmutableSet.of(Provides.class.getName());
-      }
-
-      @Override
-      public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-        for (ExecutableElement element
-            : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(Provides.class))) {
-          validator.validate(element).printMessagesTo(processingEnv.getMessager());
-        }
-        return false;
-      }
-    };
+  @Test public void singleProvidesMethodNoArgs() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ModuleProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines("test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines("test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test public void multipleProvidesMethods() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Arrays;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides List<Object> provideObjects(@QualifierA Object a, @QualifierB Object b) {",
+        "    return Arrays.asList(a, b);",
+        "  }",
+        "",
+        "  @Provides @QualifierA Object provideAObject() {",
+        "    return new Object();",
+        "  }",
+        "",
+        "  @Provides @QualifierB Object provideBObject() {",
+        "    return new Object();",
+        "  }",
+        "}");
+    JavaFileObject listFactoryFile = JavaFileObjects.forSourceLines(
+        "TestModule$$ProvideObjectsFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
+        "  private final TestModule module;",
+        "  private final Provider<Object> aProvider;",
+        "  private final Provider<Object> bProvider;",
+        "",
+        "  public TestModule$$ProvideObjectsFactory(TestModule module,",
+        "       Provider<Object> aProvider, Provider<Object> bProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override public List<Object> get() {",
+        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ModuleProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listFactoryFile);
   }
 }
