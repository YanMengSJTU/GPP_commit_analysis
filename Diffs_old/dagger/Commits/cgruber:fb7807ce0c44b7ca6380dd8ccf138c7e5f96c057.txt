diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 742675168..484d6554a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -135,6 +135,9 @@
   static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
       "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
 
+  static final String REQUIRES_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Provides-annotated method.";
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
index 801db36d9..0b564e059 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -38,19 +38,24 @@
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -328,10 +333,31 @@ private void resolveRequest(DependencyRequest request,
       DependencyRequest rootRequest, Deque<DependencyRequest> dependencyPath) {
     Optional<ProvisionBinding> binding = bindingRegistry.getOrFindProvisionBinding(key);
     if (!binding.isPresent()) {
-      TypeElement type = (TypeElement) types.asElement(key.type());
-      StringBuilder errorMessage = new StringBuilder(
-          String.format(ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT,
-              type.getQualifiedName()));
+      TypeMirror type = key.type();
+      Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
+      boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
+        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+          return true;
+        }
+
+        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+          // Note - this logic is also in InjectConstructorValidator but is woven into errors.
+          TypeElement typeElement = MoreElements.asType(type.asElement());
+          if (typeElement.getTypeParameters().isEmpty()
+              && typeElement.getKind().equals(ElementKind.CLASS)
+              && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
+            return false;
+          }
+          return true;
+        }
+      }, null);
+      StringBuilder errorMessage = new StringBuilder();
+      if(requiresProvidesMethod) {
+        errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
+      } else {
+        errorMessage.append(
+            String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
+      }
       if (!bindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites().isEmpty()) {
         errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
       }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ad2e70f38..d25fa9d4f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -55,10 +55,59 @@
     assert_().about(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.Bar cannot be provided without an @Inject constructor")
+        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
             .in(component).onLine(7);
   }
 
+  @Test public void componentProvisionWithNoDependencyChain() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(10);
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.A cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(15);
+  }
+
   @Test public void membersInjectWithoutProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
@@ -171,8 +220,8 @@
         "    C injectC(C c);",
         "  }",
         "}");
-    String errorText = "test.TestClass.A cannot be provided without "
-        + "an @Inject constructor or from an @Provides-annotated method.\n";
+    String errorText =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.\n";
     String firstError = errorText
         + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
         + "          [parameter: test.TestClass.DImpl impl]\n"
@@ -193,4 +242,4 @@
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
-}
\ No newline at end of file
+}
