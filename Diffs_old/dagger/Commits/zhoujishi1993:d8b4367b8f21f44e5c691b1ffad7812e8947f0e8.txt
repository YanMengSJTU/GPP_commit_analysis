diff --git a/java/dagger/EncryptConstant.java b/java/dagger/EncryptConstant.java
new file mode 100644
index 000000000..93014460f
--- /dev/null
+++ b/java/dagger/EncryptConstant.java
@@ -0,0 +1,12 @@
+package dagger;
+
+public class EncryptConstant {
+    public static final String AES = "AES";
+    public static final String DES = "DES";
+
+    public static final String CBC = "CBC";
+    public static final String ECB = "ECB";
+
+    public static final String PKCS5PADDING = "PKCS5PADDING";
+
+}
diff --git a/java/dagger/HelloWorld.java b/java/dagger/HelloWorld.java
new file mode 100644
index 000000000..b678b2f80
--- /dev/null
+++ b/java/dagger/HelloWorld.java
@@ -0,0 +1,20 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * a Hello world annotation
+ * @author zhoujishi
+ * @since 2.0
+ */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
+@Target(TYPE)
+@Documented
+public @interface HelloWorld {
+    String value();
+}
diff --git a/java/dagger/SecureDagger_Foo.java b/java/dagger/SecureDagger_Foo.java
new file mode 100644
index 000000000..bc6b6337b
--- /dev/null
+++ b/java/dagger/SecureDagger_Foo.java
@@ -0,0 +1,76 @@
+package dagger;
+
+
+import javax.crypto.*;
+import javax.crypto.spec.IvParameterSpec;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.util.Base64;
+
+public class SecureDagger_Foo {
+    private SecretKey secretKey;
+    private IvParameterSpec ivParameterSpec;
+    private String algorithms;
+    private Cipher cipher;
+    private static volatile SecureDagger_Foo instance;
+    private static Object syn = new Object();
+
+    private SecureDagger_Foo(){
+        try{
+            SecureRandom secureRandom = new SecureRandom();
+            this.ivParameterSpec = new IvParameterSpec(secureRandom.generateSeed(16));
+            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
+            keyGenerator.init(128);
+            this.secretKey =  keyGenerator.generateKey();
+            this.algorithms = "AES/CBC/PKCS5Padding";
+            this.cipher = Cipher.getInstance(algorithms);
+        }catch (NoSuchAlgorithmException | NoSuchPaddingException e){
+            e.printStackTrace();
+        }
+    }
+
+    public String encrypt(String input){
+        try {
+            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
+            return Base64.getEncoder().encodeToString(cipher.doFinal(input.getBytes()));
+        } catch (InvalidAlgorithmParameterException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public String decrypt(String input){
+        try{
+            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);
+            return new String(cipher.doFinal(Base64.getDecoder().decode(input.getBytes())));
+        }catch (InvalidAlgorithmParameterException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public SecretKey getSecretKey() {
+        return secretKey;
+    }
+
+    public IvParameterSpec getIvParameterSpec() {
+        return ivParameterSpec;
+    }
+
+    public String getAlgorithms() {
+        return algorithms;
+    }
+
+    public static SecureDagger_Foo getInstance(){
+        if(instance == null){
+            synchronized (syn){
+                if(instance == null){
+                    instance = new SecureDagger_Foo();
+                }
+            }
+        }
+        return instance;
+    }
+}
diff --git a/java/dagger/SymEncrypt.java b/java/dagger/SymEncrypt.java
new file mode 100644
index 000000000..5917c8c7c
--- /dev/null
+++ b/java/dagger/SymEncrypt.java
@@ -0,0 +1,18 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface SymEncrypt {
+    String algorithm() default EncryptConstant.AES;
+    String blockMode() default EncryptConstant.CBC;
+    String paddingMode() default EncryptConstant.PKCS5PADDING;
+    int keySize() default 128;
+}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e891f2288..20b4ac6af 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -126,6 +126,7 @@ java_library(
         "FrameworkDependency.java",
         "FrameworkField.java",  # Used by SourceFiles
         "FrameworkType.java",
+        "HelloWorldPara.java",
         "InjectBindingRegistry.java",
         "KeyFactory.java",
         "MapKeys.java",
@@ -139,6 +140,7 @@ java_library(
         "Scope.java",
         "SourceFiles.java",  # Consider splitting this up?
         "SubcomponentDeclaration.java",
+        "SymEncPara.java",
     ],
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
@@ -205,6 +207,7 @@ java_library(
         "FrameworkInstanceBindingExpression.java",
         "GeneratedComponentModel.java",
         "GwtCompatibility.java",
+        "HelloWorldGenerator.java",
         "InjectionMethods.java",
         "MapBindingExpression.java",
         "MemberSelect.java",
@@ -228,6 +231,7 @@ java_library(
         "SubcomponentBuilderBindingExpression.java",
         "SubcomponentNames.java",
         "SubcomponentWriter.java",
+        "SymEncGenerator.java",
         "UnwrappedMapKeyGenerator.java",
     ],
     plugins = CODEGEN_PLUGINS,
@@ -246,11 +250,13 @@ java_library(
         "ComponentHjarProcessingStep.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
+        "HelloWorldProcessingStep.java",
         "InjectBindingRegistryImpl.java",
         "InjectProcessingStep.java",
         "MapKeyProcessingStep.java",
         "ModuleProcessingStep.java",
         "ProductionExecutorModuleProcessingStep.java",
+        "SymEncProssingStep.java",
     ],
     plugins = CODEGEN_PLUGINS,
     deps = CODEGEN_DEPS + [
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index a078f1b45..f55be7188 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+
 import java.util.ServiceLoader;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -225,6 +226,11 @@ public SourceVersion getSupportedSourceVersion() {
                 bindingGraphFactory,
                 componentGenerator,
                 bindingGraphPlugins);
+
+    HelloWorldGenerator helloWorldGenerator = new HelloWorldGenerator(filer, elements);
+
+    SymEncGenerator symEncGenerator = new SymEncGenerator(filer, types, elements);
+
     return ImmutableList.of(
         new MapKeyProcessingStep(
             messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
@@ -245,7 +251,9 @@ public SourceVersion getSupportedSourceVersion() {
             productionBindingFactory,
             producerFactoryGenerator),
         componentProcessingStep,
-        new BindingMethodProcessingStep(messager, anyBindingMethodValidator));
+        new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
+        new HelloWorldProcessingStep(helloWorldGenerator, messager),
+            new SymEncProssingStep(symEncGenerator, messager));
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/HelloWorldGenerator.java b/java/dagger/internal/codegen/HelloWorldGenerator.java
new file mode 100644
index 000000000..9a0c1b387
--- /dev/null
+++ b/java/dagger/internal/codegen/HelloWorldGenerator.java
@@ -0,0 +1,55 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.util.Optional;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+
+
+/**
+ * a hello world generator
+ * @author zhoujishi
+ * @since 2.0
+ */
+public class HelloWorldGenerator extends SourceFileGenerator<HelloWorldPara>{
+
+
+    public HelloWorldGenerator(Filer filer, Elements elements) {
+        super(filer, elements);
+    }
+
+    //return the class name of generated type
+    @Override
+    ClassName nameGeneratedType(HelloWorldPara input) {
+        ClassName enclosingClassName = ClassName.get(input.typeElement());
+        return enclosingClassName
+                .topLevelClassName()
+                .peerClass(
+                        "HelloWorld");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(HelloWorldPara input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, HelloWorldPara input) {
+        TypeSpec.Builder builder = classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
+        MethodSpec.Builder methodBuilder = methodBuilder("HelloWorld").addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+        methodBuilder.addCode(CodeBlock.of("System.out.println(\"Hello World " + input.para() + "\");"));
+        builder.addMethod(methodBuilder.build());
+        return Optional.of(builder);
+    }
+
+}
diff --git a/java/dagger/internal/codegen/HelloWorldPara.java b/java/dagger/internal/codegen/HelloWorldPara.java
new file mode 100644
index 000000000..b6c4f5892
--- /dev/null
+++ b/java/dagger/internal/codegen/HelloWorldPara.java
@@ -0,0 +1,26 @@
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+
+import javax.lang.model.element.TypeElement;
+
+@AutoValue
+public abstract class HelloWorldPara {
+    static Builder builder(){
+        return new AutoValue_HelloWorldPara.Builder();
+    }
+
+    abstract String para();
+
+    abstract TypeElement typeElement();
+
+    @AutoValue.Builder
+    abstract static class Builder{
+        abstract Builder setPara(String para);
+
+        abstract Builder setTypeElement(TypeElement typeElement);
+
+        abstract HelloWorldPara build();
+    }
+}
diff --git a/java/dagger/internal/codegen/HelloWorldProcessingStep.java b/java/dagger/internal/codegen/HelloWorldProcessingStep.java
new file mode 100644
index 000000000..e68688a22
--- /dev/null
+++ b/java/dagger/internal/codegen/HelloWorldProcessingStep.java
@@ -0,0 +1,65 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.HelloWorld;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.*;
+import java.lang.annotation.Annotation;
+import java.util.Map;
+import java.util.Set;
+
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * a hello world generation step
+ * @author zhoujishi
+ * @since 2.0
+ */
+
+public class HelloWorldProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+
+    private HelloWorldGenerator generator;
+    private Messager messager;
+
+    public HelloWorldProcessingStep(HelloWorldGenerator generator, Messager messager) {
+        this.generator = generator;
+        this.messager = messager;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(HelloWorld.class);
+    }
+
+    @Override
+    public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+
+//        for(Map.Entry<Class<? extends Annotation>, Element> elementByAnnotation : elementsByAnnotation.entries()){
+//
+//        }
+        for(TypeElement typeElement: typesIn(elementsByAnnotation.values())){
+            try{
+
+                Optional<AnnotationMirror> mirror = MoreElements.getAnnotationMirror(typeElement, HelloWorld.class);
+                if(mirror.isPresent()){
+                    for(Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry: mirror.get().getElementValues().entrySet()){
+                        String para = (String)entry.getValue().getValue();
+                        HelloWorldPara helloWorldPara = HelloWorldPara.builder().setTypeElement(typeElement).setPara(para).build();
+                        generator.generate(helloWorldPara);
+                    }
+                }
+//                generator.generate(typeElement);
+            }catch(SourceFileGenerationException e){
+                e.printMessageTo(messager);
+            }
+
+        }
+        return ImmutableSet.of();
+    }
+}
diff --git a/java/dagger/internal/codegen/SymEncGenerator.java b/java/dagger/internal/codegen/SymEncGenerator.java
new file mode 100644
index 000000000..69c5db458
--- /dev/null
+++ b/java/dagger/internal/codegen/SymEncGenerator.java
@@ -0,0 +1,276 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.util.Elements;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static java.util.Arrays.stream;
+
+public class SymEncGenerator extends SourceFileGenerator<SymEncPara> {
+    public static final String PREFIX = "SecureDagger_";
+
+    private DaggerTypes types;
+
+    public SymEncGenerator(Filer filer, DaggerTypes types, Elements elements) {
+        super(filer, elements);
+        this.types = types;
+    }
+
+    @Override
+    ClassName nameGeneratedType(SymEncPara input) {
+        ClassName enclosingClassName = ClassName.get(input.typeElement());
+
+        return enclosingClassName.topLevelClassName().peerClass(PREFIX + input.className());
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(SymEncPara input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, SymEncPara input) {
+        TypeSpec.Builder builder = classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
+        writeField(builder, input);
+        writeConstructors(builder, input);
+        writeMethods(builder, input);
+        return Optional.of(builder);
+    }
+
+
+    private void writeField(TypeSpec.Builder builder, SymEncPara input){
+        addField(builder, "javax.crypto", "SecretKey", "secretKey", Modifier.PRIVATE);
+        addField(builder, "javax.crypto.spec", "IvParameterSpec", "ivParameterSpec", Modifier.PRIVATE);
+        addField(builder, "java.lang", "String", "algorithms", Modifier.PRIVATE);
+        addField(builder, "javax.crypto", "Cipher", "cipher", Modifier.PRIVATE);
+        builder.addField(FieldSpec.builder(nameGeneratedType(input), "instance", Modifier.PRIVATE, Modifier.STATIC, Modifier.VOLATILE).build());
+        builder.addField(FieldSpec.builder(ClassName.get("java.lang", "Object"), "syn").addModifiers(Modifier.PRIVATE,Modifier.STATIC).initializer(makeNewBlock(CodeBlock.of("$L", ClassName.get("java.lang", "Object")), Optional.empty())).build());
+    }
+
+    private void addField(TypeSpec.Builder builder, String packageName, String simpleName, String fieldName, Modifier... modifiers){
+        builder.addField(FieldSpec.builder(ClassName.get(packageName, simpleName), fieldName).addModifiers(modifiers).build());
+    }
+
+
+    private void writeConstructors(TypeSpec.Builder builder, SymEncPara input){
+        MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(Modifier.PRIVATE);
+        CodeBlock.Builder tryBuilder = CodeBlock.builder();
+        ClassName secureRandomClass = ClassName.get("java.security", "SecureRandom");
+        addStatement(tryBuilder, makeAssignBlock(secureRandomClass, "secureRandom", makeNewBlock(CodeBlock.of("$T", secureRandomClass), Optional.empty())));
+        addStatement(tryBuilder, makeAssignThisBlock("ivParameterSpec", makeNewBlock(CodeBlock.of("$T", ClassName.get("javax.crypto.spec", "IvParameterSpec")), Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "secureRandom"), "generateSeed", Optional.of(CodeBlock.of("16")))))));
+        addStatement(tryBuilder, makeAssignBlock(ClassName.get("javax.crypto", "KeyGenerator"),"keyGenerator", makeInvokeCodeBlock(CodeBlock.of("$L", "KeyGenerator"), "getInstance", Optional.of(CodeBlock.of("\"AES\"")))));
+        addStatement(tryBuilder, makeInvokeCodeBlock(CodeBlock.of("$L","keyGenerator"), "init", Optional.of(CodeBlock.of("128"))));
+        addStatement(tryBuilder, makeAssignThisBlock("secretKey", makeInvokeCodeBlock(CodeBlock.of("$L", "keyGenerator"), "generateKey", Optional.empty())));
+        //This line may have bugs because of $L
+        addStatement(tryBuilder, makeAssignThisBlock( "algorithms", CodeBlock.of("\"AES/CBC/PKCS5Padding\"")));
+        addStatement(tryBuilder, makeAssignThisBlock("cipher", makeInvokeCodeBlock(CodeBlock.of("$L", "Cipher"), "getInstance", Optional.of(CodeBlock.of("algorithms")))));
+
+
+
+        constructorBuilder.addCode(makeTryCatchBlock(tryBuilder.build(), getDefaultCatchBlock(), ClassName.get("java.security", "NoSuchAlgorithmException"), ClassName.get("javax.crypto", "NoSuchPaddingException")));
+
+        builder.addMethod(constructorBuilder.build());
+    }
+
+    //get the default catch block
+    private CodeBlock getDefaultCatchBlock(){
+        CodeBlock.Builder catchBuilder = CodeBlock.builder();
+        addStatement(catchBuilder, makeInvokeCodeBlock(CodeBlock.of("$L", "e"), "printStackTrace", Optional.empty()));
+        return catchBuilder.build();
+    }
+
+    private void addStatement(CodeBlock.Builder builder, CodeBlock codeBlock){
+        builder.add("$[");
+        builder.add(codeBlock);
+        builder.add(";\n$]");
+    }
+
+    /**
+     *make an assignBlock based on typeName, varName and assignBlock, the assignBlock may be a constant, new block or method invoke block
+     */
+    private CodeBlock makeAssignBlock(TypeName typeName, String varName, CodeBlock assignBlock){
+        return CodeBlock.of("$1T $2L = $3L", typeName, CodeBlock.of(varName), assignBlock);
+    }
+
+    /**
+     * make block like
+     * new String(),
+     */
+    private CodeBlock makeNewBlock(CodeBlock typeName, Optional<CodeBlock> parameterBlock){
+        CodeBlock.Builder builder = CodeBlock.builder();
+        if(parameterBlock.isPresent()){
+            builder.add("new $1L($2L)", typeName, parameterBlock.get());
+        }else{
+            builder.add("new $1L()", typeName);
+        }
+        return builder.build();
+    }
+
+    /**
+     * make block like
+     * this.name = name, the assign block may be new block or method invoke block
+     */
+    private CodeBlock makeAssignThisBlock(String fieldName, CodeBlock assignBlock){
+        return CodeBlock.of("this.$1N = $2L", fieldName, assignBlock);
+    }
+
+    //TODO verify the usage of static and nonstatic method call
+//    private CodeBlock makeInvokeCodeBlock(String instance, String method, Optional<CodeBlock> parameterBlock){
+//        CodeBlock.Builder builder = CodeBlock.builder();
+//        if(parameterBlock.isPresent()){
+//            builder.add("$1L.$2L($3L)", instance, method, parameterBlock.get());
+//        }else{
+//            builder.add("$1L.$2L()", instance, method);
+//        }
+//        return builder.build();
+//    }
+
+
+    /**
+     * make invoke block like a.b(), notice that a may be an invoke block, instance or static type
+     */
+    //TODO notice that many method invocation use code block as their only parameter, we need a more convenient way to transfer single element to CodeBlock
+    private CodeBlock makeInvokeCodeBlock(CodeBlock instance, String method, Optional<CodeBlock> parameterBlock){
+        CodeBlock.Builder builder = CodeBlock.builder();
+        if(parameterBlock.isPresent()){
+            builder.add("$1L.$2L($3L)", instance, method, parameterBlock.get());
+        }else{
+            builder.add("$1L.$2L()", instance, method);
+        }
+        return builder.build();
+    }
+
+//    private CodeBlock makeInvokeCodeBlock(TypeName typeName, String method, Optional<CodeBlock> parameterBlock){
+//        CodeBlock.Builder builder = CodeBlock.builder();
+//        if(parameterBlock.isPresent()){
+//            builder.add("$1T.$2L($3L)", typeName, method, parameterBlock.get());
+//        }else{
+//            builder.add("$1T.$2L()", typeName, method);
+//        }
+//        return builder.build();
+//    }
+
+    /**
+     * connect the parameter of method invocation into a block, the parameters may not be string
+     */
+
+    //TODO change the parameters from String list to code block list, the parameter may also be an invoke block
+    private CodeBlock makeParametersCodeBlock(LinkedList<String> parameters){
+        return CodeBlocks.makeParametersCodeBlock(parameters.stream().map(para -> CodeBlock.of("$L", para)).collect(Collectors.toList()));
+    }
+
+
+    private CodeBlock makeTryCatchBlock(CodeBlock tryStatement, CodeBlock catchStatement, TypeName... exception){
+       return CodeBlock.builder().beginControlFlow("try").add(tryStatement).nextControlFlow("catch($L $L)",
+               formatCatchParaCodeBlock(exception), CodeBlock.of("e")).add(catchStatement).endControlFlow().build();
+    }
+
+    private CodeBlock formatCatchParaCodeBlock(TypeName... parameters){
+        List<CodeBlock> list = stream(parameters).map(parameter -> CodeBlock.of("$T", parameter)).collect(Collectors.toList());
+        return list.stream().collect(CodeBlocks.joiningCodeBlocks("|"));
+    }
+
+    private void writeMethods(TypeSpec.Builder builder, SymEncPara input){
+        addEncMethod(builder, input);
+        addDecMethod(builder,input);
+        addGetMethods(builder, input);
+    }
+
+
+    private void addEncMethod(TypeSpec.Builder builder, SymEncPara input){
+        MethodSpec.Builder encMethodBuilder = MethodSpec.methodBuilder("encrypt").addModifiers(Modifier.PUBLIC).returns(ClassName.get("java.lang","String"));
+        encMethodBuilder.addParameter(ClassName.get("java.lang","String"), "input");
+        CodeBlock.Builder tryBuilder = CodeBlock.builder();
+        LinkedList<String> cipherInitPara = new LinkedList<>();
+        cipherInitPara.add("Cipher.ENCRYPT_MODE");
+        cipherInitPara.add("secretKey");
+        cipherInitPara.add("ivParameterSpec");
+        addStatement(tryBuilder, makeInvokeCodeBlock(CodeBlock.of("$L", "cipher"), "init", Optional.of(makeParametersCodeBlock(cipherInitPara))));
+        tryBuilder.addStatement("return $L", makeInvokeCodeBlock(makeInvokeCodeBlock(CodeBlock.of("$T", ClassName.get("java.util", "Base64")), "getEncoder", Optional.empty()), "encodeToString",
+                Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "cipher"), "doFinal", Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "input"), "getBytes", Optional.empty()))))));
+        encMethodBuilder.addCode(makeTryCatchBlock(tryBuilder.build(), getDefaultCatchBlock(), ClassName.get("java.security", "InvalidAlgorithmParameterException"),
+                ClassName.get("java.security", "InvalidKeyException"),ClassName.get("javax.crypto", "BadPaddingException"),
+                ClassName.get("javax.crypto", "IllegalBlockSizeException")));
+        encMethodBuilder.addCode("return null;");
+        builder.addMethod(encMethodBuilder.build());
+    }
+
+    private void addDecMethod(TypeSpec.Builder builder, SymEncPara input){
+        MethodSpec.Builder decMethodBuilder = MethodSpec.methodBuilder("decrypt").addModifiers(Modifier.PUBLIC).returns(ClassName.get("java.lang","String"));
+        decMethodBuilder.addParameter(ClassName.get("java.lang", "String"), "input");
+        CodeBlock.Builder tryBuilder = CodeBlock.builder();
+        LinkedList<String> cipherInitPara = new LinkedList<>();
+        cipherInitPara.add("Cipher.DECRYPT_MODE");
+        cipherInitPara.add("secretKey");
+        cipherInitPara.add("ivParameterSpec");
+        addStatement(tryBuilder, makeInvokeCodeBlock(CodeBlock.of("cipher"), "init", Optional.of(makeParametersCodeBlock(cipherInitPara))));
+        tryBuilder.addStatement("return $L", makeNewBlock(CodeBlock.of("$T", ClassName.get("java.lang","String")), Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "cipher"), "doFinal",
+                Optional.of(makeInvokeCodeBlock(makeInvokeCodeBlock(CodeBlock.of("$T", ClassName.get("java.util", "Base64")), "getDecoder", Optional.empty()), "decode",
+                        Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "input"),"getBytes", Optional.empty()))))))));
+        decMethodBuilder.addCode(makeTryCatchBlock(tryBuilder.build(), getDefaultCatchBlock(), ClassName.get("java.security", "InvalidAlgorithmParameterException"),
+                ClassName.get("java.security", "InvalidKeyException"),ClassName.get("javax.crypto", "BadPaddingException"),
+                ClassName.get("javax.crypto", "IllegalBlockSizeException")));
+        decMethodBuilder.addCode("return null;");
+        builder.addMethod(decMethodBuilder.build());
+    }
+
+    private void addGetMethods(TypeSpec.Builder builder, SymEncPara input){
+        MethodSpec.Builder getKey = MethodSpec.methodBuilder("getSecretKey").returns(ClassName.get("javax.crypto", "SecretKey")).addModifiers(Modifier.PUBLIC);
+        getKey.addStatement("return $L", CodeBlock.of("secretKey"));
+        builder.addMethod(getKey.build());
+
+        MethodSpec.Builder getIvPara = MethodSpec.methodBuilder("getIvParameterSpec").returns(ClassName.get("javax.crypto.spec", "IvParameterSpec")).addModifiers(Modifier.PUBLIC);
+        getIvPara.addStatement("return $L", CodeBlock.of("ivParameterSpec"));
+        builder.addMethod(getIvPara.build());
+
+        MethodSpec.Builder getAlgorithms = MethodSpec.methodBuilder("getAlgorithms").returns(ClassName.get("java.lang", "String")).addModifiers(Modifier.PUBLIC);
+        getAlgorithms.addStatement("return $L", CodeBlock.of("algorithms"));
+        builder.addMethod(getAlgorithms.build());
+
+
+        addGetInstance(builder, input);
+    }
+
+
+    private void addGetInstance(TypeSpec.Builder builder, SymEncPara input){
+        MethodSpec.Builder getInstance = MethodSpec.methodBuilder("getInstance").returns(nameGeneratedType(input)).addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+        CodeBlock.Builder bodyBuilder = CodeBlock.builder();
+        bodyBuilder.add(makeIfBlock(CodeBlock.of("instance == null"), makeSynchronizedBLock(CodeBlock.of("syn"), makeIfBlock(CodeBlock.of("instance == null"),
+                CodeBlock.builder().add(CodeBlock.of("instance = $L;", makeNewBlock(CodeBlock.of("$L", nameGeneratedType(input)) , Optional.empty()))).build(), Optional.empty())), Optional.empty()));
+        addStatement(bodyBuilder, CodeBlock.of("$L", "return instance"));
+        getInstance.addCode(bodyBuilder.build());
+
+        builder.addMethod(getInstance.build());
+    }
+
+    private CodeBlock makeIfBlock(CodeBlock condition,  CodeBlock ifBlock, Optional<CodeBlock> elseBlock){
+        CodeBlock.Builder builder = CodeBlock.builder();
+        builder.beginControlFlow("if($L)", condition);
+        builder.add(ifBlock);
+        if(elseBlock.isPresent()){
+            builder.nextControlFlow("else");
+            addStatement(builder, elseBlock.get());
+            builder.endControlFlow();
+        }else{
+            builder.endControlFlow();
+        }
+        return builder.build();
+    }
+
+    private CodeBlock makeSynchronizedBLock(CodeBlock obj, CodeBlock body){
+        CodeBlock.Builder builder = CodeBlock.builder();
+        builder.beginControlFlow("synchronized($L)", obj);
+        builder.add(body);
+        builder.endControlFlow();
+        return builder.build();
+    }
+}
diff --git a/java/dagger/internal/codegen/SymEncPara.java b/java/dagger/internal/codegen/SymEncPara.java
new file mode 100644
index 000000000..a37cf7692
--- /dev/null
+++ b/java/dagger/internal/codegen/SymEncPara.java
@@ -0,0 +1,25 @@
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+import javax.lang.model.element.TypeElement;
+
+@AutoValue
+public abstract class SymEncPara {
+    static Builder builder(){
+        return new AutoValue_SymEncPara.Builder();
+    }
+
+    abstract TypeElement typeElement();
+
+    abstract String className();
+
+    @AutoValue.Builder
+    abstract static class Builder{
+        abstract Builder setTypeElement(TypeElement typeElement);
+
+        abstract Builder setClassName(String className);
+
+        abstract SymEncPara build();
+    }
+}
diff --git a/java/dagger/internal/codegen/SymEncProssingStep.java b/java/dagger/internal/codegen/SymEncProssingStep.java
new file mode 100644
index 000000000..8978d288f
--- /dev/null
+++ b/java/dagger/internal/codegen/SymEncProssingStep.java
@@ -0,0 +1,46 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.ClassName;
+import dagger.SymEncrypt;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+public class SymEncProssingStep implements BasicAnnotationProcessor.ProcessingStep  {
+
+    SymEncGenerator generator;
+    Messager messager;
+
+    public SymEncProssingStep(SymEncGenerator generator, Messager messager) {
+        this.generator = generator;
+        this.messager = messager;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(SymEncrypt.class);
+    }
+
+    @Override
+    public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+
+        for(TypeElement typeElement: typesIn(elementsByAnnotation.values())){
+            try{
+                SymEncPara para = SymEncPara.builder().setClassName(ClassName.get(typeElement).simpleName()).setTypeElement(typeElement).build();
+                generator.generate(para);
+            }catch(SourceFileGenerationException e){
+                e.printMessageTo(messager);
+            }
+
+        }
+        return ImmutableSet.of();
+    }
+}
