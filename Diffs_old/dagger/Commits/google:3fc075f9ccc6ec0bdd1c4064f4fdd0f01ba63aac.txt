diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index 2588d6157..c2f4c5842 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -17,21 +17,27 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -121,6 +127,17 @@
     values.putAll(annotation.getElementValues());
     return values.values();
   }
-
+  
+  static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
+      final Class<? extends Annotation> annotationType) {
+    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
+    return FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override public boolean apply(AnnotationMirror input) {
+            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
+          }
+        })
+        .toSet();
+  }
   private AnnotationMirrors() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index d1aae3aee..9e53eb70b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -32,8 +32,10 @@
 import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
+import dagger.internal.MapProviderFactory;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.codegen.ProvisionBinding.BindingsType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -53,13 +55,18 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
@@ -74,7 +81,6 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
-
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -108,7 +114,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
   }
 
   @Override
-  JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
+  JavaWriter write(ClassName componentName, ComponentDescriptor input) {
     ClassName componentDefinitionTypeName =
         ClassName.fromTypeElement(input.componentDefinitionType());
 
@@ -237,22 +243,54 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       Key key = frameworkKey.key();
       if (frameworkKey.frameworkClass().equals(Provider.class)) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
-        if (ProvisionBinding.isSetBindingCollection(bindings)) {
-          ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
-          for (ProvisionBinding binding : bindings) {
-            setFactoryParameters.add(initializeFactoryForBinding(
-                binding, componentContributionFields, providerFields, membersInjectorFields));
-          }
-          constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
-              providerFields.get(key).name(),
-              ClassName.fromClass(SetFactory.class),
-              Snippet.makeParametersSnippet(setFactoryParameters.build()));
-        } else {
-          ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-          constructorWriter.body().addSnippet("this.%s = %s;",
-              providerFields.get(key).name(),
-              initializeFactoryForBinding(
+        BindingsType bindingsType = ProvisionBinding.getBindingsType(bindings);
+        switch (bindingsType) {
+          case SETBINDING:
+            ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
+            for (ProvisionBinding binding : bindings) {
+              setFactoryParameters.add(initializeFactoryForBinding(
                   binding, componentContributionFields, providerFields, membersInjectorFields));
+            }
+            constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
+                providerFields.get(key).name(), ClassName.fromClass(SetFactory.class),
+                Snippet.makeParametersSnippet(setFactoryParameters.build()));
+            break;
+          case MAPBINDING:
+            if (bindings.iterator().hasNext()) {
+              ProvisionBinding firstBinding = bindings.iterator().next();
+              DeclaredType declaredMapType =
+                  Util.getDeclaredTypeOfMap(firstBinding.providedKey().type());
+              TypeMirror mapKeyType = Util.getKeyTypeOfMap(declaredMapType);
+              TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+              constructorWriter.body().addSnippet("this.%s = %s.<%s, %s>builder(%d)",
+                  providerNames.get(key),
+                  ClassName.fromClass(MapProviderFactory.class),
+                  TypeNames.forTypeMirror(mapKeyType),
+                  TypeNames.forTypeMirror(mapValueType),
+                  bindings.size());
+            }
+
+            for (ProvisionBinding binding : bindings) {
+              AnnotationMirror mapKeyAnnotationMirror =
+                  Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
+              Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+                  mapKeyAnnotationMirror.getElementValues();
+              constructorWriter.body().addSnippet("    .put(%s, %s)",
+                  Iterables.getOnlyElement(map.entrySet()).getValue(), 
+                  initializeFactoryForBinding(
+                      binding, componentContributionFields, providerFields, membersInjectorFields));
+            }
+            constructorWriter.body().addSnippet("    .build();");
+            break;
+          case SINGULARBINDING:
+            ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+            constructorWriter.body().addSnippet("this.%s = %s;",
+                providerFields.get(key).name(), 
+                initializeFactoryForBinding(
+                    binding, componentContributionFields, providerFields, membersInjectorFields));
+            break;
+          default:
+            throw new IllegalStateException();
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
         constructorWriter.body().addSnippet("this.%s = %s;",
@@ -285,7 +323,6 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           interfaceMethod.body().addSnippet("return %s;", parameterName);
         }
       } else {
-        // look up the provider in the Key->field map and invoke.  Done.
         interfaceMethod.body().addSnippet("return %s;",
             frameworkTypeUsageStatement(providerFields.get(interfaceRequest.key()).name(),
                 interfaceRequest.kind()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a13950504..1342cc859 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -74,6 +74,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ModuleValidator moduleValidator = new ModuleValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -96,6 +97,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentGenerator(filer, keyFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
+        new MapKeyProcessingStep(
+            messager,
+            mapKeyValidator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 1449649e7..0cec6d033 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -16,15 +16,17 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import dagger.Component;
+import dagger.MapKey;
 import dagger.Module;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
-
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -67,6 +69,10 @@
     checkNotNull(moduleAnnotation);
     return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
   }
+  
+  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
+  }
 
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 8331d0094..104fb4956 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -105,9 +105,34 @@
 
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
+  
+  static final String PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY =
+      "@Provides methods of non map type cannot declare a map key";
+  
+  static final String PROVIDES_METHOD_WITH_NO_MAP_KEY =
+      "@Provides methods of type map must declare a map key";
+
+  static final String PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY =
+      "@Provides methods may not have more than one @MapKey-marked annotation";
+
+  static final String PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY =
+      "@Provides methods only support String and Enum key types";
 
   static final String PROVIDES_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @Provides method with the same name in a single module";
+  
+  static final String UNWRAP_MAPKEY =
+      "unwrapValue = true is not yet supported";
+  
+  /* collection binding errors */
+  static final String NON_SETBINDING =
+      "more than one binding present including at least a set binding and a non-set binding";
+
+  static final String NON_MAPBINDING =
+      "more than one binding present including at least a map binding and a non-map binding";
+
+  static final String INVALID_COLLECTIONBINDING =
+      "more than one binding present, but found an invalid binding";
 
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index e8d821d74..8e5c70d9e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.Lists;
 import dagger.Factory;
 import dagger.MembersInjector;
+import dagger.Provides.Type;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -39,6 +40,7 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
 
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
@@ -77,7 +79,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeName providedTypeName = TypeNames.forTypeMirror(binding.providedKey().type());
+    TypeMirror keyType = binding.provisionType().equals(Type.MAP) ? Util.getValueTypeOfMap(
+        Util.getDeclaredTypeOfMap(binding.providedKey().type()))
+        : binding.providedKey().type();
+    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
     ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
@@ -87,7 +92,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
         ClassName.fromClass(Factory.class),
         providedTypeName));
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(binding.providedKey().type(), "get");
+    MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
@@ -146,6 +151,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
     if (binding.bindingKind().equals(PROVISION)) {
       switch (binding.provisionType()) {
         case UNIQUE:
+        case MAP: 
         case SET_VALUES:
           getMethodWriter.body().addSnippet("return module.%s(%s);",
               binding.bindingElement().getSimpleName(), parametersSnippet);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index c1769865e..ec57fe1be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -16,17 +16,12 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import java.lang.annotation.Annotation;
-import java.util.List;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -65,23 +60,11 @@
   }
 
   static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
-    return getAnnotatedAnnotations(element, Qualifier.class);
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
-    return getAnnotatedAnnotations(element, Scope.class);
-  }
-
-  private static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
-          }
-        })
-        .toSet();
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
   }
 
   private InjectionAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index e52e337e5..e7087ed13 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -21,8 +21,11 @@
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
+import com.google.common.collect.Iterables;
 import dagger.Provides;
+import java.util.Map;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -36,6 +39,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -107,6 +111,14 @@ private TypeElement getSetElement() {
       return elements.getTypeElement(Set.class.getCanonicalName());
     }
 
+    private TypeElement getMapElement() {
+      return elements.getTypeElement(Map.class.getCanonicalName());
+    }
+
+    private TypeElement getProviderElement() {
+      return elements.getTypeElement(Provider.class.getCanonicalName());
+    }
+
     Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
@@ -128,6 +140,13 @@ Key forProvidesMethod(ExecutableElement e) {
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
           return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKey = Iterables.getOnlyElement(getMapKeys(e));
+          TypeElement keyTypeElement = Util.getKeyTypeElement(mapKey, elements);
+          TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(mapType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
new file mode 100644
index 000000000..69a5fafd1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * The annotation processor responsible for validating the mapKey annotation
+ *
+ *
+ * TODO(user): auto-generate implementation of annotations marked with &#064MapKey where necessary.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+public class MapKeyProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MapKeyValidator mapKeyValidator;
+
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator) {
+    this.messager = messager;
+    this.mapKeyValidator = mapKeyValidator;
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    // check the map key annotation field is valid
+    if (!roundEnv.getElementsAnnotatedWith(MapKey.class).isEmpty()) {
+      Set<? extends Element> mapKeyAnnotateds = roundEnv.getElementsAnnotatedWith(MapKey.class);
+      for (Element element : mapKeyAnnotateds) {
+        ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+        mapKeyReport.printMessagesTo(messager);
+      }
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
new file mode 100644
index 000000000..ae03651bf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import javax.lang.model.element.Element;
+
+import static dagger.internal.codegen.ErrorMessages.UNWRAP_MAPKEY;
+
+/**
+ * A {@link Validator} for {@link MapKey} Annotation.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyValidator implements Validator<Element>  {
+  @Override
+  public ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder =
+        ValidationReport.Builder.about(element);
+    MapKey mapkey = element.getAnnotation(MapKey.class);
+    if (mapkey.unwrapValue()) {
+      builder.addItem(UNWRAP_MAPKEY, element);
+    }
+    return builder.build();
+  }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index bd83613cf..77eeb7179 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,10 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
 import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -31,15 +33,20 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -77,7 +84,7 @@ private TypeElement getSetElement() {
       builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
           providesMethodElement);
     }
-
+    
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
       builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
     }
@@ -99,12 +106,39 @@ private TypeElement getSetElement() {
     if (returnTypeKind.equals(VOID)) {
       builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
     }
+  
+    // check mapkey is right
+    if (!providesAnnotation.type().equals(Provides.Type.MAP) 
+        && (getMapKeys(providesMethodElement) != null
+            && getMapKeys(providesMethodElement).size() > 0)) {
+      builder.addItem(PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY, providesMethodElement);
+    }
 
     switch (providesAnnotation.type()) {
       case UNIQUE: // fall through
       case SET:
         validateKeyType(builder, returnType);
         break;
+      case MAP:
+        validateKeyType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(providesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(PROVIDES_METHOD_WITH_NO_MAP_KEY, providesMethodElement);
+            break;
+          case 1:
+            AnnotationMirror mapKeyAnnotationMirror = Iterables.getOnlyElement(annotationMirrors); 
+            TypeElement keyTypeElement = Util.getKeyTypeElement(mapKeyAnnotationMirror, elements);
+            if (keyTypeElement == null) {
+              builder.addItem(PROVIDES_METHOD_WITH_UNSUPPORTED_MAP_KEY, providesMethodElement);
+            }
+            break;
+          default:
+            builder.addItem(PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY, providesMethodElement);
+            break;
+        }
+        break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
           builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 0d02cb879..e887055d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -19,6 +19,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
@@ -36,12 +37,16 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static dagger.internal.codegen.ErrorMessages.NON_SETBINDING;
+import static dagger.internal.codegen.ErrorMessages.NON_MAPBINDING;
+import static dagger.internal.codegen.ErrorMessages.INVALID_COLLECTIONBINDING;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -82,26 +87,67 @@
   abstract Optional<DependencyRequest> memberInjectionRequest();
 
   private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
-
+  private static ImmutableSet<Provides.Type> MAP_BINDING_TYPES = immutableEnumSet(MAP);
+  
+  
+  static enum BindingsType {
+    /** Represents set bindings. */
+    SETBINDING, 
+    /** Represents map bindings. */
+    MAPBINDING, 
+    /** Represents a valid non-collection binding. */
+    SINGULARBINDING,
+  }
+  
   /**
-   * Returns {@code true} if the given bindings are all contributors to a set binding.
+   * Returns {@code BindingsType} for bindings, which can be {@code SETBINDING} if the given
+   * bindings are all contributors to a set binding. Returns {@code MAPBINDING} if the given
+   * bindings are all contributors to a map binding. Returns {@code NONCOLLECTIONBINDING} if the
+   * given bindings is not a collection.
    *
-   * @throws IllegalArgumentException if some of the bindings are set bindings and some are not.
+   * @throws IllegalArgumentException if some of the bindings are map bindings or set bindings and
+   *         some are not.
+   * @throws IllegalArgumentException if the bindings in the collection are not supported in Dagger
+   *         (Not set bindings or map Bindings).
    */
-  static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
+  static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
     checkNotNull(bindings);
-    Iterator<ProvisionBinding> iterator = bindings.iterator();
-    checkArgument(iterator.hasNext(), "no bindings");
-    boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
-    while (iterator.hasNext()) {
-      checkArgument(setBinding,
-          "more than one binding present, but found a non-set binding");
-      checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
-          "more than one binding present, but found a non-set binding");
+    switch (Iterables.size(bindings)) {
+      case 0:
+        throw new IllegalArgumentException("no bindings");
+      case 1:
+        if (SET_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
+          return BindingsType.SETBINDING;
+        } else if (MAP_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
+          return BindingsType.MAPBINDING;
+        }
+        return BindingsType.SINGULARBINDING;
+      default:
+        Iterator<ProvisionBinding> iterator = bindings.iterator();
+        boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
+        if (setBinding) {
+          while (iterator.hasNext()) {
+            checkArgument(setBinding, NON_SETBINDING);
+            checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
+                NON_SETBINDING);
+          }
+          return BindingsType.SETBINDING;
+        }
+
+        iterator = bindings.iterator();
+        boolean mapBinding = MAP_BINDING_TYPES.contains(iterator.next().provisionType());
+        if (mapBinding) {
+          while (iterator.hasNext()) {
+            checkArgument(mapBinding, NON_MAPBINDING);
+            checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
+                NON_MAPBINDING);
+          }
+          return BindingsType.MAPBINDING;
+        }
+        throw new IllegalStateException(INVALID_COLLECTIONBINDING);
     }
-    return setBinding;
   }
-
+  
   static final class Factory {
     private final Elements elements;
     private final Types types;
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 1863d7b57..773f2b3bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -32,7 +32,9 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.ProvisionBinding.BindingsType;
 import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.Snippet;
 import java.util.Collection;
 import java.util.Iterator;
@@ -184,31 +186,40 @@
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
-      final String name;
-      if (ProvisionBinding.isSetBindingCollection(bindingsForKey)) {
-        name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
-      } else {
-        ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-        name = binding.bindingElement().accept(
-            new ElementKindVisitor6<String, Void>() {
-              @Override
-              public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                return e.getEnclosingElement().accept(this, null);
-              }
+      BindingsType bindingsType = ProvisionBinding.getBindingsType(bindingsForKey);
+      switch (bindingsType) {
+        case SETBINDING:
+          providerNames.put(entry.getKey(),
+              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
+          break;
+        case MAPBINDING:
+          providerNames.put(entry.getKey(),
+              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
+          break;
+        case SINGULARBINDING:
+          ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+          providerNames.put(entry.getKey(),
+              binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                @Override
+                public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                  return e.getEnclosingElement().accept(this, null);
+                }
 
-              @Override
-              public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                return e.getSimpleName().toString();
-              }
+                @Override
+                public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                  return e.getSimpleName().toString();
+                }
 
-              @Override
-              public String visitType(TypeElement e, Void p) {
-                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                    e.getSimpleName().toString());
-              }
-            }, null) + "Provider";
+                @Override
+                public String visitType(TypeElement e, Void p) {
+                  return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                      e.getSimpleName().toString());
+                }
+              }, null) + "Provider");
+          break;
+        default:
+          throw new IllegalStateException();
       }
-      providerNames.put(entry.getKey(), name);
     }
     Ordering<Entry<?, String>> entryValueOrdering =
         Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1dbe27ba3..84df3dfb1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,6 +16,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.Iterables;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -31,6 +32,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
@@ -38,9 +40,9 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
-
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -382,4 +384,73 @@ public CodeGenerationIncompleteException(String s) {
       super(s);
     }
   }
+
+  /**
+   * returns the value type for a {@link Map} type like Map<K, Provider<V>>}.
+   */
+  public static TypeMirror getValueTypeOfMap(DeclaredType declaredMapType) {
+    List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
+    DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
+    List<? extends TypeMirror> mapValueArgs = declaredValueType.getTypeArguments();
+    return mapValueArgs.get(0);
+  }
+
+  /**
+   * returns the key type for a {@link Map} type like Map<K, Provider<V>>}
+   */
+  public static TypeMirror getKeyTypeOfMap(DeclaredType declaredMapType) {
+    List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
+    return mapArgs.get(0);
+  }
+
+  /**
+   * returns the key's {@link TypeElement} for a {@link Map} given the {@link AnnotationMirror} of
+   * the key..
+   */
+  public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
+    // TODO(user) Support literals other than String and Enum
+    AnnotationValueVisitor<TypeElement, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
+          @Override
+          public TypeElement visitEnumConstant(VariableElement c, Void p) {
+            return (TypeElement) c.getEnclosingElement();
+          }
+
+          @Override
+          public TypeElement visitString(String s, Void p) {
+            return elements.getTypeElement(String.class.getCanonicalName());
+          }
+
+          @Override
+          protected TypeElement defaultAction(Object o, Void v) {
+            throw new IllegalStateException();
+          }
+        };
+    TypeElement keyTypeElement =
+        Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
+    if (keyTypeElement == null) {
+      throw new IllegalStateException("Non-supported key type for map binding "
+          + Iterables.getOnlyElement(map.entrySet()).getValue());
+    }
+    return keyTypeElement;
+  }
+
+  /**
+   * validate map is a DelcaredType and the element associated with it is "java.util.Map" and return
+   * the DeclaredType for map.
+   */
+  public static DeclaredType getDeclaredTypeOfMap(TypeMirror map) {
+    // check whether map is a DeclaredType
+    if (!(map instanceof DeclaredType)) {
+      throw new IllegalStateException();
+    }
+    // check whether the element associate with this DeclaredType is a map
+    DeclaredType declaredMapType = (DeclaredType) map;
+    if (!((TypeElement) declaredMapType.asElement()).getQualifiedName().contentEquals(
+        "java.util.Map")) {
+      throw new IllegalStateException();
+    }
+    return declaredMapType;
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
new file mode 100644
index 000000000..40aac4517
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class MapBindingComponentProcessorTest {
+
+  @Test
+  public void mapBindingsWithEnumKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "    return new AdminHandler(); ",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "    return new LoginHandler(); ",
+                "  }",
+                "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler", 
+        "package test;", 
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects
+            .forSourceLines("test.Dagger_TestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+                "public final class Dagger_TestComponent implements TestComponent {",
+                "  private final MapModuleOne mapModuleOne;",
+                "  private final MapModuleTwo mapModuleTwo;",
+                "  private final Provider<Map<PathEnum, Provider<Handler>>> ",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
+                "",
+                "  private Dagger_TestComponent(Builder builder) {",
+                "    assert builder != null;",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfPathEnumAndProviderOfHandlerProvider = ",
+                "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+                "            .put(PathEnum.ADMIN, ",
+                "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+                "            .put(PathEnum.LOGIN, ",
+                "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+                "            .build();",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+                "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new Dagger_TestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      if (mapModuleOne == null) {",
+                "        throw new NullPointerException(\"mapModuleOne\");",
+                "      }",
+                "      this.mapModuleOne = mapModuleOne;",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      if (mapModuleTwo == null) {",
+                "        throw new NullPointerException(\"mapModuleTwo\");",
+                "      }",
+                "      this.mapModuleTwo = mapModuleTwo;",
+                "      return this;",
+                "    }",
+                "  }",
+                "}",
+                "");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile, 
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface StringKey {",
+        "  String value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;", 
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<String, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects
+            .forSourceLines("test.Dagger_TestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+                "public final class Dagger_TestComponent implements TestComponent {",
+                "  private final MapModuleOne mapModuleOne;",
+                "  private final MapModuleTwo mapModuleTwo;",
+                "  private final Provider<Map<String, Provider<Handler>>> ",
+                "      mapOfStringAndProviderOfHandlerProvider;",
+                "",
+                "",
+                "  private Dagger_TestComponent(Builder builder) {",
+                "    assert builder != null;",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfStringAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<java.lang.String, Handler>builder(2)",
+                "            .put(\"Admin\", ",
+                "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+                "            .put(\"Login\", ",
+                "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+                "            .build();",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<Handler>> dispatcher() {",
+                "    return mapOfStringAndProviderOfHandlerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new Dagger_TestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      if (mapModuleOne == null) {",
+                "        throw new NullPointerException(\"mapModuleOne\");",
+                "      }",
+                "      this.mapModuleOne = mapModuleOne;",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      if (mapModuleTwo == null) {",
+                "        throw new NullPointerException(\"mapModuleTwo\");",
+                "      }",
+                "      this.mapModuleTwo = mapModuleTwo;",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            stringKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
new file mode 100644
index 000000000..9401b04c9
--- /dev/null
+++ b/core/src/main/java/dagger/MapKey.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * It enables to define customized key type annotation for map binding by annotating an annotation
+ * of a {@code Map}'s key type. The defined key type annotation can be later applied to the
+ * key of the {@code Map}. Currently {@code String} and {@code enum} key types
+ * are supported for map binding.
+ *
+ * <h2>Example</h2> For example, if you want to define a key type annotation called StringKey, you
+ * can define it the following way:
+ *
+ * <pre><code>
+ * &#64;MapKey(unwrapValue = false)
+ * &#64;Retention(RUNTIME)
+ * public &#64;interface StringKey {
+ *   String value();
+ * }
+ *</code></pre>
+ */
+@Documented
+@Target(ANNOTATION_TYPE)
+@Retention(RUNTIME)
+public @interface MapKey {
+  /**
+   * if {@code unwrapValue} is true, then the whole annotation will be the type and annotation
+   * instances will be the keys. If {@code unwrapValue} is false, the value() type of key type
+   * annotation will be the key type for mapbinding and the value instances will be the keys.
+   * Currently only support {@code unwrapValue} to be false.
+   */
+  boolean unwrapValue();
+}
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index edcb27b64..df4ad904d 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -53,7 +53,15 @@
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
      */
-    SET_VALUES;
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
   }
 
   Type type() default Type.UNIQUE;
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
new file mode 100644
index 000000000..5cc62c312
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+    this.contributingMap = Collections.unmodifiableMap(contributingMap);
+  }
+
+  /**
+   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, Provider<V>> get() {
+    return this.contributingMap;
+  }
+
+  /**
+   * A builder to help build the {@link MapProviderFactory}
+   */
+  public static class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(user): consider which way to initialize mapBuilder is better
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /**
+     * Returns a new {@link MapProviderFactory}
+     */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<K, V>(this.mapBuilder);
+    }
+
+    /**
+     * Associate k with providerOfValue in {@code Builder}
+     */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      if (key == null) {
+        throw new NullPointerException("The key is null");
+      }
+      if (providerOfValue == null) {
+        throw new NullPointerException("The provider of the value is null");
+      }
+
+      this.mapBuilder.put(key, providerOfValue);
+      return this;
+    }
+
+    private static <K, V> LinkedHashMap<K, Provider<V>> newLinkedHashMapWithExpectedSize(
+        int expectedSize) {
+      if (expectedSize < 0) {
+        throw new IllegalArgumentException("The expected size of map cannot be negative.");
+      }
+      int initialCapacity = (expectedSize < 3) ? expectedSize + 1
+          : (expectedSize < (1 << (Integer.SIZE - 2))) ? expectedSize + expectedSize / 3
+              : Integer.MAX_VALUE;
+      return new LinkedHashMap<K, Provider<V>>(initialCapacity);
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
new file mode 100644
index 000000000..71408713a
--- /dev/null
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.truth0.Truth.ASSERT;
+
+import dagger.Factory;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class MapProviderFactoryTest {
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullKey() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put(null, incrementingIntegerProvider(1));
+  }
+
+  @Test
+  public void nullValue() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put("Hello", null);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Provider<Integer> p1 = incrementingIntegerProvider(10);
+    Provider<Integer> p2 = incrementingIntegerProvider(20);
+    Provider<Integer> p3 = incrementingIntegerProvider(30);
+    Provider<Integer> p4 = incrementingIntegerProvider(40);
+    Provider<Integer> p5 = incrementingIntegerProvider(50);
+
+    Factory<Map<String, Provider<Integer>>> factory = MapProviderFactory
+        .<String, Integer>builder(4)
+        .put("two", p2)
+        .put("one", p1)
+        .put("three", p3)
+        .put("one", p5)
+        .put("four", p4)
+        .build();
+
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    expectedMap.put("two", p2);
+    expectedMap.put("one", p1);
+    expectedMap.put("three", p3);
+    expectedMap.put("one", p5);
+    expectedMap.put("four", p4);
+    ASSERT.that(factory.get().entrySet()).iteratesAs(expectedMap.entrySet());
+  }
+
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Integer>() {
+      @Override
+      public Integer get() {
+        return value.getAndIncrement();
+      }
+    };
+  }
+}
