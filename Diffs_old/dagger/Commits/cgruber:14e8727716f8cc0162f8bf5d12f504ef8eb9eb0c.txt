diff --git a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 8c0a3ad7e..67698909e 100644
--- a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
+++ b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -48,7 +48,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
@@ -81,7 +80,7 @@
 class AnnotationCreatorGenerator extends SourceFileGenerator<TypeElement> {
 
   @Inject
-  AnnotationCreatorGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
+  AnnotationCreatorGenerator(Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
   }
 
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index 386e29a78..46e8b7560 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -48,7 +48,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
 
 /**
  * An abstract type for classes representing a Dagger binding. Particularly, contains the {@link
@@ -266,7 +265,8 @@ static DependencyAssociation create(
   }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
-  static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
+  static boolean hasNonDefaultTypeParameters(
+      TypeElement element, TypeMirror type, DaggerTypes types) {
     // If the element has no type parameters, nothing can be wrong.
     if (element.getTypeParameters().isEmpty()) {
       return false;
diff --git a/java/dagger/internal/codegen/BindingGraphPlugins.java b/java/dagger/internal/codegen/BindingGraphPlugins.java
index 9b2a38b8c..d565afbf4 100644
--- a/java/dagger/internal/codegen/BindingGraphPlugins.java
+++ b/java/dagger/internal/codegen/BindingGraphPlugins.java
@@ -37,8 +37,6 @@
 import javax.annotation.processing.Filer;
 import javax.inject.Qualifier;
 import javax.inject.Singleton;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
 /** The set of SPI and validation plugins. */
@@ -52,16 +50,16 @@
 
   private final ImmutableSet<BindingGraphPlugin> plugins;
   private final Filer filer;
-  private final Types types;
-  private final Elements elements;
+  private final DaggerTypes types;
+  private final DaggerElements elements;
   private final Map<String, String> processingOptions;
   private final DiagnosticReporterFactory diagnosticReporterFactory;
 
   BindingGraphPlugins(
       Iterable<BindingGraphPlugin> plugins,
       Filer filer,
-      Types types,
-      Elements elements,
+      DaggerTypes types,
+      DaggerElements elements,
       Map<String, String> processingOptions,
       DiagnosticReporterFactory diagnosticReporterFactory) {
     this.plugins = ImmutableSet.copyOf(plugins);
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 48c28b79e..06721e0d7 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -25,8 +25,6 @@
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.inject.Singleton;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** Binds the set of {@link BindingGraphPlugin}s used to implement Dagger validation. */
 @Module
@@ -89,8 +87,8 @@ BindingGraphPlugin provisionDependencyOnProducerBinding(
   static BindingGraphPlugins validationPlugins(
       @Validation Set<BindingGraphPlugin> validationPlugins,
       Filer filer,
-      Types types,
-      Elements elements,
+      DaggerTypes types,
+      DaggerElements elements,
       @ProcessingOptions Map<String, String> processingOptions,
       DiagnosticReporterFactory diagnosticReporterFactory) {
     return new BindingGraphPlugins(
@@ -103,8 +101,8 @@ static BindingGraphPlugins validationPlugins(
   static BindingGraphPlugins moduleValidationPlugins(
       @Validation Set<BindingGraphPlugin> validationPlugins,
       Filer filer,
-      Types types,
-      Elements elements,
+      DaggerTypes types,
+      DaggerElements elements,
       @ProcessingOptions Map<String, String> processingOptions,
       DiagnosticReporterFactory diagnosticReporterFactory,
       CompilerOptions compilerOptions) {
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 779a5800c..f55005f27 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -49,13 +49,12 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /** A validator for methods that represent binding declarations. */
 abstract class BindingMethodValidator {
 
   private final DaggerElements elements;
-  private final Types types;
+  private final DaggerTypes types;
   private final DependencyRequestValidator dependencyRequestValidator;
   private final Class<? extends Annotation> methodAnnotation;
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
@@ -73,7 +72,7 @@
    */
   protected BindingMethodValidator(
       DaggerElements elements,
-      Types types,
+      DaggerTypes types,
       DependencyRequestValidator dependencyRequestValidator,
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
@@ -100,7 +99,7 @@ protected BindingMethodValidator(
    */
   protected BindingMethodValidator(
       DaggerElements elements,
-      Types types,
+      DaggerTypes types,
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
       DependencyRequestValidator dependencyRequestValidator,
@@ -491,8 +490,7 @@ protected String errorMessage(BindingMethodValidator validator) {
      */
     protected void checkThrows(
         BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
-      TypeMirror exceptionSupertype =
-          validator.elements.getTypeElement(superclass.getCanonicalName()).asType();
+      TypeMirror exceptionSupertype = validator.elements.getTypeElement(superclass).asType();
       TypeMirror errorType = validator.elements.getTypeElement(Error.class).asType();
       for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
         if (!validator.types.isSubtype(thrownType, exceptionSupertype)
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index a9b15d135..dd7083fe5 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -29,18 +29,19 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * A validator for {@link Binds} methods.
  */
 final class BindsMethodValidator extends BindingMethodValidator {
-  private final Types types;
+  private final DaggerTypes types;
   private final BindsTypeChecker bindsTypeChecker;
 
   @Inject
   BindsMethodValidator(
-      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index c12dd78d7..39ff80122 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -34,16 +34,17 @@
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /** A validator for {@link BindsOptionalOf} methods. */
 final class BindsOptionalOfMethodValidator extends BindingMethodValidator {
 
-  private final Types types;
+  private final DaggerTypes types;
 
   @Inject
   BindsOptionalOfMethodValidator(
-      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
diff --git a/java/dagger/internal/codegen/BindsTypeChecker.java b/java/dagger/internal/codegen/BindsTypeChecker.java
index 4e48810e1..77fd1bff7 100644
--- a/java/dagger/internal/codegen/BindsTypeChecker.java
+++ b/java/dagger/internal/codegen/BindsTypeChecker.java
@@ -29,7 +29,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * Checks the assignability of one type to another, given a {@link ContributionType} context. This
@@ -38,11 +37,11 @@
  * right-hand-side in generated code might be an erased type due to accessibility.
  */
 final class BindsTypeChecker {
-  private final Types types;
+  private final DaggerTypes types;
   private final DaggerElements elements;
 
   @Inject
-  BindsTypeChecker(Types types, DaggerElements elements) {
+  BindsTypeChecker(DaggerTypes types, DaggerElements elements) {
     this.types = types;
     this.elements = elements;
   }
diff --git a/java/dagger/internal/codegen/ComponentCreatorValidator.java b/java/dagger/internal/codegen/ComponentCreatorValidator.java
index d939c9fd7..a61926bc7 100644
--- a/java/dagger/internal/codegen/ComponentCreatorValidator.java
+++ b/java/dagger/internal/codegen/ComponentCreatorValidator.java
@@ -42,16 +42,15 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Types;
 
 /** Validates {@link dagger.Component.Builder} annotations. */
 class ComponentCreatorValidator {
 
   private final DaggerElements elements;
-  private final Types types;
+  private final DaggerTypes types;
 
   @Inject
-  ComponentCreatorValidator(DaggerElements elements, Types types) {
+  ComponentCreatorValidator(DaggerElements elements, DaggerTypes types) {
     this.elements = elements;
     this.types = types;
   }
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index 780c21d2f..b0ea96da8 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -59,7 +59,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /**
  * Reports errors in the component hierarchy.
@@ -74,7 +73,7 @@
 // TODO(dpb): Combine with ComponentHierarchyValidator.
 final class ComponentDescriptorValidator {
 
-  private final Elements elements;
+  private final DaggerElements elements;
   private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -82,7 +81,7 @@
 
   @Inject
   ComponentDescriptorValidator(
-      Elements elements,
+      DaggerElements elements,
       DaggerTypes types,
       CompilerOptions compilerOptions,
       MethodSignatureFormatter methodSignatureFormatter,
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 5ff1bbadb..7f8f31757 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -56,8 +56,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * A processing step that emits the API of a generated component, without any actual implementation.
@@ -73,9 +71,9 @@
  * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
 final class ComponentHjarProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
-  private final Elements elements;
   private final SourceVersion sourceVersion;
-  private final Types types;
+  private final DaggerElements elements;
+  private final DaggerTypes types;
   private final Filer filer;
   private final Messager messager;
   private final ComponentValidator componentValidator;
@@ -83,16 +81,16 @@
 
   @Inject
   ComponentHjarProcessingStep(
-      Elements elements,
       SourceVersion sourceVersion,
-      Types types,
+      DaggerElements elements,
+      DaggerTypes types,
       Filer filer,
       Messager messager,
       ComponentValidator componentValidator,
       Factory componentDescriptorFactory) {
     super(MoreElements::asType);
-    this.elements = elements;
     this.sourceVersion = sourceVersion;
+    this.elements = elements;
     this.types = types;
     this.filer = filer;
     this.messager = messager;
@@ -122,7 +120,7 @@ protected void process(
   }
 
   private final class EmptyComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
-    EmptyComponentGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
+    EmptyComponentGenerator(Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
       super(filer, elements, sourceVersion);
     }
 
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 7047d9bbd..69c9ea9d4 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -40,8 +40,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A type that a component needs an instance of. */
 @AutoValue
@@ -114,7 +112,7 @@ TypeElement typeElement() {
   abstract Optional<NullPolicy> overrideNullPolicy();
 
   /** The requirement's null policy. */
-  NullPolicy nullPolicy(Elements elements, Types types) {
+  NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
     if (overrideNullPolicy().isPresent()) {
       return overrideNullPolicy().get();
     }
@@ -131,10 +129,10 @@ NullPolicy nullPolicy(Elements elements, Types types) {
   }
 
   /**
-   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order
-   * to be used within a component.
+   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order to
+   * be used within a component.
    */
-  boolean requiresAPassedInstance(Elements elements, Types types) {
+  boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
     if (isBoundInstance()) {
       // A user has explicitly defined in their component builder they will provide an instance.
       return true;
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 70cdd46cc..328eca7eb 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -72,7 +72,6 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
 
 /**
  * Performs superficial validation of the contract of the {@link Component} and {@link
@@ -80,7 +79,7 @@
  */
 final class ComponentValidator {
   private final DaggerElements elements;
-  private final Types types;
+  private final DaggerTypes types;
   private final ModuleValidator moduleValidator;
   private final ComponentCreatorValidator creatorValidator;
   private final DependencyRequestValidator dependencyRequestValidator;
@@ -91,7 +90,7 @@
   @Inject
   ComponentValidator(
       DaggerElements elements,
-      Types types,
+      DaggerTypes types,
       ModuleValidator moduleValidator,
       ComponentCreatorValidator creatorValidator,
       DependencyRequestValidator dependencyRequestValidator,
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 275f52e9f..a7af3a7e3 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -53,7 +53,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
@@ -174,7 +173,7 @@ static boolean isSubcomponentCreator(Element element) {
    */
   @Deprecated
   static ImmutableSet<TypeElement> getTransitiveModules(
-      Types types, DaggerElements elements, Iterable<TypeElement> seedModules) {
+      DaggerTypes types, DaggerElements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class).asType();
     Queue<TypeElement> moduleQueue = new ArrayDeque<>();
     Iterables.addAll(moduleQueue, seedModules);
@@ -216,8 +215,11 @@ static boolean isSubcomponentCreator(Element element) {
   }
 
   /** Traverses includes from superclasses and adds them into the builder. */
-  private static void addIncludesFromSuperclasses(Types types, TypeElement element,
-      ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
+  private static void addIncludesFromSuperclasses(
+      DaggerTypes types,
+      TypeElement element,
+      ImmutableSet.Builder<TypeElement> builder,
+      TypeMirror objectType) {
     // Also add the superclass to the queue, in case any @Module definitions were on that.
     TypeMirror superclass = element.getSuperclass();
     while (!types.isSameType(objectType, superclass)
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 9313a7247..fb6a12b74 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.graph.Traverser;
+import com.squareup.javapoet.ClassName;
 import dagger.Reusable;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
@@ -105,6 +106,11 @@ public TypeElement getTypeElement(CharSequence name) {
     return elements.getTypeElement(name);
   }
 
+  /** Returns the type element for a class name. */
+  TypeElement getTypeElement(ClassName className) {
+    return getTypeElement(className.withoutAnnotations().toString());
+  }
+
   /**
    * Returns a useful string form for an element.
    *
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index e0947c14e..28d1ce43a 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -118,7 +118,7 @@ private TypeMirror unwrapTypeOrDefault(TypeMirror type, TypeMirror defaultType)
    * Set.class}, this will return {@code Set<List<Number>>}.
    */
   DeclaredType wrapType(TypeMirror type, Class<?> wrappingClass) {
-    return types.getDeclaredType(elements.getTypeElement(wrappingClass.getCanonicalName()), type);
+    return types.getDeclaredType(elements.getTypeElement(wrappingClass), type);
   }
 
   /**
@@ -134,7 +134,7 @@ DeclaredType wrapType(TypeMirror type, Class<?> wrappingClass) {
    */
   DeclaredType rewrapType(TypeMirror type, Class<?> wrappingClass) {
     List<? extends TypeMirror> typeArguments = MoreTypes.asDeclared(type).getTypeArguments();
-    TypeElement wrappingType = elements.getTypeElement(wrappingClass.getCanonicalName());
+    TypeElement wrappingType = elements.getTypeElement(wrappingClass);
     switch (typeArguments.size()) {
       case 0:
         return getDeclaredType(wrappingType);
diff --git a/java/dagger/internal/codegen/DelegateDeclaration.java b/java/dagger/internal/codegen/DelegateDeclaration.java
index d0ae32b67..2536fb329 100644
--- a/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -35,7 +35,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.util.Types;
 
 /**
  * The declaration for a delegate binding established by a {@link Binds} method.
@@ -47,12 +46,15 @@
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   static final class Factory {
-    private final Types types;
+    private final DaggerTypes types;
     private final KeyFactory keyFactory;
     private final DependencyRequestFactory dependencyRequestFactory;
 
     @Inject
-    Factory(Types types, KeyFactory keyFactory, DependencyRequestFactory dependencyRequestFactory) {
+    Factory(
+        DaggerTypes types,
+        KeyFactory keyFactory,
+        DependencyRequestFactory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index b0247e4ef..dab24fb89 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -49,7 +49,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic.Kind;
 
 /**
@@ -60,7 +59,7 @@
  */
 @Singleton
 final class InjectBindingRegistryImpl implements InjectBindingRegistry {
-  private final Elements elements;
+  private final DaggerElements elements;
   private final DaggerTypes types;
   private final Messager messager;
   private final InjectValidator injectValidator;
@@ -128,7 +127,7 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.unresolved().isPresent()
-          && elements.getTypeElement(factoryName.toString()) == null
+          && elements.getTypeElement(factoryName) == null
           && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
     }
@@ -155,7 +154,7 @@ private void tryToCacheBinding(B binding) {
 
   @Inject
   InjectBindingRegistryImpl(
-      Elements elements,
+      DaggerElements elements,
       DaggerTypes types,
       Messager messager,
       InjectValidator injectValidator,
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 2c83f3730..949d0c570 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -43,7 +43,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
@@ -52,7 +51,7 @@
  * that contain them.
  */
 final class InjectValidator {
-  private final Types types;
+  private final DaggerTypes types;
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
   private final DependencyRequestValidator dependencyRequestValidator;
@@ -60,7 +59,7 @@
 
   @Inject
   InjectValidator(
-      Types types,
+      DaggerTypes types,
       DaggerElements elements,
       DependencyRequestValidator dependencyRequestValidator,
       CompilerOptions compilerOptions) {
@@ -68,7 +67,7 @@
   }
 
   private InjectValidator(
-      Types types,
+      DaggerTypes types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
       DependencyRequestValidator dependencyRequestValidator,
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
index 8ba514335..dbce62d14 100644
--- a/java/dagger/internal/codegen/InjectionMethods.java
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -54,7 +54,6 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /** Convenience methods for creating and invoking {@link InjectionMethod}s. */
 final class InjectionMethods {
@@ -270,7 +269,7 @@ static CodeBlock invokeAll(
         ClassName generatedTypeName,
         CodeBlock instanceCodeBlock,
         TypeMirror instanceType,
-        Types types,
+        DaggerTypes types,
         Function<DependencyRequest, CodeBlock> dependencyUsage,
         DaggerElements elements) {
       return injectionSites
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index b53fda139..b5bea1c41 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -25,7 +25,6 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.ProcessingEnvironmentModule.ElementsModule;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -38,7 +37,7 @@
  * A module that provides a {@link BindingGraphFactory} and {@link ComponentDescriptor.Factory} for
  * use in {@code javac} plugins. Requires a binding for the {@code javac} {@link Context}.
  */
-@Module(includes = {InjectBindingRegistryModule.class, ElementsModule.class})
+@Module(includes = InjectBindingRegistryModule.class)
 abstract class JavacPluginModule {
   @Provides
   static CompilerOptions compilerOptions() {
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 2ff8957e2..633c30604 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -72,21 +72,17 @@
     this.elements = checkNotNull(elements);
   }
 
-  private TypeElement getClassElement(Class<?> cls) {
-    return elements.getTypeElement(cls.getCanonicalName());
-  }
-
   private TypeMirror boxPrimitives(TypeMirror type) {
     return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
   }
 
   private DeclaredType setOf(TypeMirror elementType) {
-    return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));
+    return types.getDeclaredType(elements.getTypeElement(Set.class), boxPrimitives(elementType));
   }
 
   private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
     return types.getDeclaredType(
-        getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
+        elements.getTypeElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
   }
 
   /** Returns {@code Map<KeyType, FrameworkType<ValueType>>}. */
@@ -124,12 +120,12 @@ Key forSubcomponentCreator(TypeMirror creatorType) {
 
   Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
     return forBindingMethod(
-        method, contributingModule, Optional.of(getClassElement(Provider.class)));
+        method, contributingModule, Optional.of(elements.getTypeElement(Provider.class)));
   }
 
   Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
     return forBindingMethod(
-        method, contributingModule, Optional.of(getClassElement(Producer.class)));
+        method, contributingModule, Optional.of(elements.getTypeElement(Producer.class)));
   }
 
   /** Returns the key bound by a {@link Binds} method. */
@@ -155,7 +151,7 @@ private Key forBindingMethod(
     ContributionType contributionType = ContributionType.fromBindingMethod(method);
     TypeMirror returnType = methodType.getReturnType();
     if (frameworkType.isPresent()
-        && frameworkType.get().equals(getClassElement(Producer.class))
+        && frameworkType.get().equals(elements.getTypeElement(Producer.class))
         && isType(returnType)) {
       if (isFutureType(methodType.getReturnType())) {
         returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
@@ -165,7 +161,7 @@ private Key forBindingMethod(
         if (isFutureType(setType.elementType())) {
           returnType =
               types.getDeclaredType(
-                  getClassElement(Set.class), types.unwrapType(setType.elementType()));
+                  elements.getTypeElement(Set.class), types.unwrapType(setType.elementType()));
         }
       }
     }
@@ -257,19 +253,19 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
   }
 
   Key forProductionExecutor() {
-    return Key.builder(getClassElement(Executor.class).asType())
-        .qualifier(SimpleAnnotationMirror.of(getClassElement(Production.class)))
+    return Key.builder(elements.getTypeElement(Executor.class).asType())
+        .qualifier(SimpleAnnotationMirror.of(elements.getTypeElement(Production.class)))
         .build();
   }
 
   Key forProductionImplementationExecutor() {
-    return Key.builder(getClassElement(Executor.class).asType())
-        .qualifier(SimpleAnnotationMirror.of(getClassElement(ProductionImplementation.class)))
+    return Key.builder(elements.getTypeElement(Executor.class).asType())
+        .qualifier(SimpleAnnotationMirror.of(elements.getTypeElement(ProductionImplementation.class)))
         .build();
   }
 
   Key forProductionComponentMonitor() {
-    return Key.builder(getClassElement(ProductionComponentMonitor.class).asType()).build();
+    return Key.builder(elements.getTypeElement(ProductionComponentMonitor.class).asType()).build();
   }
 
   /**
@@ -336,8 +332,7 @@ Key unwrapMapValueType(Key key) {
    */
   private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     checkArgument(
-        FrameworkTypes.isFrameworkType(
-            elements.getTypeElement(newWrappingClass.getName()).asType()));
+        FrameworkTypes.isFrameworkType(elements.getTypeElement(newWrappingClass).asType()));
     return wrapMapKey(key, newWrappingClass).get();
   }
 
@@ -357,7 +352,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     if (MapType.isMap(possibleMapKey)) {
       MapType mapType = MapType.from(possibleMapKey);
       if (!mapType.isRawType() && mapType.valuesAreTypeOf(currentWrappingClass)) {
-        TypeElement wrappingElement = getClassElement(newWrappingClass);
+        TypeElement wrappingElement = elements.getTypeElement(newWrappingClass);
         if (wrappingElement == null) {
           // This target might not be compiled with Producers, so wrappingClass might not have an
           // associated element.
@@ -384,7 +379,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     if (MapType.isMap(possibleMapKey)) {
       MapType mapType = MapType.from(possibleMapKey);
       if (!mapType.isRawType() && !mapType.valuesAreTypeOf(wrappingClass)) {
-        TypeElement wrappingElement = getClassElement(wrappingClass);
+        TypeElement wrappingElement = elements.getTypeElement(wrappingClass);
         if (wrappingElement == null) {
           // This target might not be compiled with Producers, so wrappingClass might not have an
           // associated element.
diff --git a/java/dagger/internal/codegen/Keys.java b/java/dagger/internal/codegen/Keys.java
index 8c85ac2d4..274d24408 100644
--- a/java/dagger/internal/codegen/Keys.java
+++ b/java/dagger/internal/codegen/Keys.java
@@ -28,7 +28,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
 
 /** Utility methods related to {@link Key}s. */
 final class Keys {
@@ -42,7 +41,7 @@ static boolean isValidMembersInjectionKey(Key key) {
    * Returns {@code true} if this is valid as an implicit key (that is, if it's valid for a
    * just-in-time binding by discovering an {@code @Inject} constructor).
    */
-  static boolean isValidImplicitProvisionKey(Key key, Types types) {
+  static boolean isValidImplicitProvisionKey(Key key, DaggerTypes types) {
     return isValidImplicitProvisionKey(key.qualifier(), key.type(), types);
   }
 
@@ -52,7 +51,7 @@ static boolean isValidImplicitProvisionKey(Key key, Types types) {
    * constructor).
    */
   static boolean isValidImplicitProvisionKey(
-      Optional<? extends AnnotationMirror> qualifier, TypeMirror type, final Types types) {
+      Optional<? extends AnnotationMirror> qualifier, TypeMirror type, final DaggerTypes types) {
     // Qualifiers disqualify implicit provisioning.
     if (qualifier.isPresent()) {
       return false;
diff --git a/java/dagger/internal/codegen/MapKeyProcessingStep.java b/java/dagger/internal/codegen/MapKeyProcessingStep.java
index ff541c2e9..6e5dc1012 100644
--- a/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -31,7 +31,6 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Types;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
@@ -39,7 +38,7 @@
  */
 public class MapKeyProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
-  private final Types types;
+  private final DaggerTypes types;
   private final MapKeyValidator mapKeyValidator;
   private final AnnotationCreatorGenerator annotationCreatorGenerator;
   private final UnwrappedMapKeyGenerator unwrappedMapKeyGenerator;
@@ -47,7 +46,7 @@
   @Inject
   MapKeyProcessingStep(
       Messager messager,
-      Types types,
+      DaggerTypes types,
       MapKeyValidator mapKeyValidator,
       AnnotationCreatorGenerator annotationCreatorGenerator,
       UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {
diff --git a/java/dagger/internal/codegen/MapKeyValidator.java b/java/dagger/internal/codegen/MapKeyValidator.java
index e9027ba10..dfc0b07b8 100644
--- a/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/java/dagger/internal/codegen/MapKeyValidator.java
@@ -25,17 +25,16 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.util.Elements;
 
 /**
  * A validator for {@link MapKey} annotations.
  */
 // TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
 final class MapKeyValidator {
-  private final Elements elements;
+  private final DaggerElements elements;
 
   @Inject
-  MapKeyValidator(Elements elements) {
+  MapKeyValidator(DaggerElements elements) {
     this.elements = elements;
   }
 
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index af0e98ea1..48fb1e694 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -48,7 +48,6 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
 
 /**
  * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.
@@ -91,7 +90,7 @@
         : Optional.empty();
   }
 
-  static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, Types types) {
+  static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, DaggerTypes types) {
     return unwrapValue(mapKeyAnnotation).isPresent()
         ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
         : mapKeyAnnotation.getAnnotationType();
@@ -106,7 +105,7 @@ static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, Types types) {
    * @throws NoSuchElementException if the annotation has no members
    */
   static DeclaredType getUnwrappedMapKeyType(
-      final DeclaredType mapKeyAnnotationType, final Types types) {
+      final DeclaredType mapKeyAnnotationType, final DaggerTypes types) {
     checkArgument(
         MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
         "%s is not an annotation type",
@@ -193,8 +192,8 @@ private static CodeBlock directMapKeyExpression(
   }
 
   /**
-   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types,
-   * DaggerElements)} is generated.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding,
+   * DaggerTypes, DaggerElements)} is generated.
    */
   static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
@@ -207,7 +206,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * accessible.
    */
   static Optional<MethodSpec> mapKeyFactoryMethod(
-      ContributionBinding binding, Types types, DaggerElements elements) {
+      ContributionBinding binding, DaggerTypes types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
diff --git a/java/dagger/internal/codegen/MethodSignature.java b/java/dagger/internal/codegen/MethodSignature.java
index c44453651..75f25e6ad 100644
--- a/java/dagger/internal/codegen/MethodSignature.java
+++ b/java/dagger/internal/codegen/MethodSignature.java
@@ -27,7 +27,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 @AutoValue
 abstract class MethodSignature {
@@ -39,7 +38,7 @@
   abstract ImmutableList<? extends Equivalence.Wrapper<? extends TypeMirror>> thrownTypes();
 
   static MethodSignature forComponentMethod(
-      ComponentMethodDescriptor componentMethod, DeclaredType componentType, Types types) {
+      ComponentMethodDescriptor componentMethod, DeclaredType componentType, DaggerTypes types) {
     ExecutableType methodType =
         MoreTypes.asExecutable(types.asMemberOf(componentType, componentMethod.methodElement()));
     return new AutoValue_MethodSignature(
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index ad79fa5af..28eb614fa 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -33,16 +33,15 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * Formats the signature of an {@link ExecutableElement} suitable for use in error messages.
  */
 final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
-  private final Types types;
+  private final DaggerTypes types;
 
   @Inject
-  MethodSignatureFormatter(Types types) {
+  MethodSignatureFormatter(DaggerTypes types) {
     this.types = types;
   }
 
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 6f115656d..2477627f9 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -82,7 +82,6 @@
 import javax.lang.model.util.SimpleAnnotationValueVisitor8;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor8;
-import javax.lang.model.util.Types;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
@@ -108,7 +107,7 @@
     ANDROID_PROCESSOR = Optional.ofNullable(clazz);
   }
 
-  private final Types types;
+  private final DaggerTypes types;
   private final DaggerElements elements;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -123,7 +122,7 @@
 
   @Inject
   ModuleValidator(
-      Types types,
+      DaggerTypes types,
       DaggerElements elements,
       AnyBindingMethodValidator anyBindingMethodValidator,
       MethodSignatureFormatter methodSignatureFormatter,
diff --git a/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 74502620a..9aa87b3e1 100644
--- a/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -41,13 +41,12 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
 
 /** Generates a monitoring module for use with production components. */
 final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
 
   @Inject
-  MonitoringModuleGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
+  MonitoringModuleGenerator(Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
   }
 
diff --git a/java/dagger/internal/codegen/MultibindingDeclaration.java b/java/dagger/internal/codegen/MultibindingDeclaration.java
index a642b1d73..cd50017e8 100644
--- a/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -33,7 +33,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * A declaration that a multibinding with a certain key is available to be injected in a component
@@ -61,11 +60,11 @@
    * A factory for {@link MultibindingDeclaration}s.
    */
   static final class Factory {
-    private final Types types;
+    private final DaggerTypes types;
     private final KeyFactory keyFactory;
 
     @Inject
-    Factory(Types types, KeyFactory keyFactory) {
+    Factory(DaggerTypes types, KeyFactory keyFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
     }
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 8e8765d08..28f94538d 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -29,7 +29,6 @@
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /** A validator for {@link Multibinds} methods. */
 class MultibindsMethodValidator extends BindingMethodValidator {
@@ -37,7 +36,9 @@
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   @Inject
   MultibindsMethodValidator(
-      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 682978522..f3820600c 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -25,13 +25,12 @@
 import dagger.internal.codegen.OptionalType.OptionalKind;
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
-import javax.lang.model.util.Types;
 
 /** A binding expression for optional bindings. */
 final class OptionalBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final Types types;
+  private final DaggerTypes types;
 
   @Inject
   OptionalBindingExpression(
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
index 9bb0873d0..fb4efb793 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -19,21 +19,18 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.googlejavaformat.java.filer.FormattingFiler;
-import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.Reusable;
-import dagger.internal.codegen.ProcessingEnvironmentModule.ElementsModule;
 import java.util.Map;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 /** Bindings that depend on the {@link ProcessingEnvironment}. */
-@Module(includes = ElementsModule.class)
+@Module
 final class ProcessingEnvironmentModule {
 
   private final ProcessingEnvironment processingEnvironment;
@@ -82,10 +79,4 @@ DaggerElements daggerElements() {
   CompilerOptions compilerOptions() {
     return CompilerOptions.create(processingEnvironment);
   }
-
-  @Module
-  interface ElementsModule {
-    @Binds
-    Elements elements(DaggerElements daggerElements);
-  }
 }
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 4d3df446a..e80c1d657 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -70,7 +70,6 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -82,7 +81,7 @@
   @Inject
   ProducerFactoryGenerator(
       Filer filer,
-      Elements elements,
+      DaggerElements elements,
       SourceVersion sourceVersion,
       CompilerOptions compilerOptions,
       KeyFactory keyFactory) {
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 5a043da4c..66400a52b 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -33,7 +33,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * A validator for {@link Produces} methods.
@@ -42,7 +41,9 @@
 
   @Inject
   ProducesMethodValidator(
-      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index c4d409f14..ea8efbefd 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -27,7 +27,6 @@
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.Types;
 
 /**
  * A validator for {@link Provides} methods.
@@ -38,7 +37,9 @@
 
   @Inject
   ProvidesMethodValidator(
-      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
diff --git a/java/dagger/internal/codegen/Scopes.java b/java/dagger/internal/codegen/Scopes.java
index 4bbb06d34..e188f9b55 100644
--- a/java/dagger/internal/codegen/Scopes.java
+++ b/java/dagger/internal/codegen/Scopes.java
@@ -29,7 +29,6 @@
 import javax.inject.Singleton;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
 
 /** Common names and convenience methods for {@link Scope}s. */
 final class Scopes {
@@ -41,17 +40,18 @@ static Scope scope(TypeElement scopeType) {
   }
 
   /** Returns a representation for {@link ProductionScope @ProductionScope} scope. */
-  static Scope productionScope(Elements elements) {
+  static Scope productionScope(DaggerElements elements) {
     return scope(elements, ProductionScope.class);
   }
 
   /** Returns a representation for {@link Singleton @Singleton} scope. */
-  static Scope singletonScope(Elements elements) {
+  static Scope singletonScope(DaggerElements elements) {
     return scope(elements, Singleton.class);
   }
 
-  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
-    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
+  private static Scope scope(
+      DaggerElements elements, Class<? extends Annotation> scopeAnnotationClass) {
+    return scope(elements.getTypeElement(scopeAnnotationClass));
   }
 
   /**
diff --git a/java/dagger/internal/codegen/SourceFileGenerator.java b/java/dagger/internal/codegen/SourceFileGenerator.java
index 2409987a2..747acf611 100644
--- a/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -29,7 +29,6 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
@@ -42,10 +41,10 @@
   private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
 
   private final Filer filer;
-  private final Elements elements;
+  private final DaggerElements elements;
   private final SourceVersion sourceVersion;
 
-  SourceFileGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
+  SourceFileGenerator(Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
     this.filer = checkNotNull(filer);
     this.elements = checkNotNull(elements);
     this.sourceVersion = checkNotNull(sourceVersion);
diff --git a/java/dagger/internal/codegen/SpiModule.java b/java/dagger/internal/codegen/SpiModule.java
index debf3df98..f36f508c9 100644
--- a/java/dagger/internal/codegen/SpiModule.java
+++ b/java/dagger/internal/codegen/SpiModule.java
@@ -26,8 +26,6 @@
 import java.util.ServiceLoader;
 import javax.annotation.processing.Filer;
 import javax.inject.Singleton;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** Contains the bindings for {@link BindingGraphPlugins} from external SPI providers. */
 @Module
@@ -39,8 +37,8 @@ private SpiModule() {}
   static BindingGraphPlugins spiPlugins(
       @TestingPlugins Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins,
       Filer filer,
-      Types types,
-      Elements elements,
+      DaggerTypes types,
+      DaggerElements elements,
       @ProcessingOptions Map<String, String> processingOptions,
       DiagnosticReporterFactory diagnosticReporterFactory) {
     return new BindingGraphPlugins(
diff --git a/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java b/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
index ac1f761f4..9f7e40cca 100644
--- a/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
+++ b/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
@@ -22,7 +22,6 @@
 import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
 
 /**
  * Generates classes that create annotation instances for an unwrapped {@link MapKey} annotation
@@ -56,7 +55,7 @@
 final class UnwrappedMapKeyGenerator extends AnnotationCreatorGenerator {
 
   @Inject
-  UnwrappedMapKeyGenerator(Filer filer, Elements elements, SourceVersion sourceVersion) {
+  UnwrappedMapKeyGenerator(Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
   }
 
diff --git a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 224967faf..16db6cfe3 100644
--- a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -26,7 +26,6 @@
 import javax.inject.Singleton;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,10 +52,12 @@ String foo(
   }
 
   @Test public void methodSignatureTest() {
-    Elements elements = compilationRule.getElements();
-    TypeElement inner = elements.getTypeElement(InnerClass.class.getCanonicalName());
+    DaggerElements elements =
+        new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
+    DaggerTypes types = new DaggerTypes(compilationRule.getTypes(), elements);
+    TypeElement inner = elements.getTypeElement(InnerClass.class);
     ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
-    String formatted = new MethodSignatureFormatter(compilationRule.getTypes()).format(method);
+    String formatted = new MethodSignatureFormatter(types).format(method);
     // This is gross, but it turns out that annotation order is not guaranteed when getting
     // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
     // less brittle.
