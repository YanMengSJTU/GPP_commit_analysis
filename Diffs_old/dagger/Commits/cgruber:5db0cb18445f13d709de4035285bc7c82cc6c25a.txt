diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
new file mode 100644
index 000000000..99d6627e6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/** A {@link Validator} for methods that represent binding declarations. */
+abstract class BindingMethodValidator extends Validator<ExecutableElement> {
+
+  private final Elements elements;
+  private final Types types;
+  private final Class<? extends Annotation> methodAnnotation;
+  private final ImmutableList<Class<? extends Annotation>> enclosingElementAnnotations;
+  private final Abstractness abstractness;
+  private final ExceptionSuperclass exceptionSuperclass;
+
+  /**
+   * Creates a validator object.
+   *
+   * @param methodAnnotation the annotation on a method that identifies it as a binding method
+   * @param enclosingElementAnnotation the method must be declared in a class or interface annotated
+   *     with this annotation
+   */
+  protected BindingMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Class<? extends Annotation> enclosingElementAnnotation,
+      Abstractness abstractness,
+      ExceptionSuperclass exceptionSuperclass) {
+    this(
+        elements,
+        types,
+        methodAnnotation,
+        ImmutableList.of(enclosingElementAnnotation),
+        abstractness,
+        exceptionSuperclass);
+  }
+
+  /**
+   * Creates a validator object.
+   *
+   * @param methodAnnotation the annotation on a method that identifies it as a binding method
+   * @param enclosingElementAnnotations the method must be declared in a class or interface
+   *     annotated with one of these annotations
+   */
+  protected BindingMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      Abstractness abstractness,
+      ExceptionSuperclass exceptionSuperclass) {
+    this.elements = elements;
+    this.types = types;
+    this.methodAnnotation = methodAnnotation;
+    this.enclosingElementAnnotations =
+        ImmutableList.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
+    this.abstractness = abstractness;
+    this.exceptionSuperclass = exceptionSuperclass;
+  }
+
+  @Override
+  public final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
+    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(method);
+    checkMethod(builder);
+    return builder.build();
+  }
+
+  /** Checks the method for validity. Adds errors to {@code builder}. */
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    checkEnclosingElement(builder);
+    checkTypeParameters(builder);
+    checkNotPrivate(builder);
+    checkAbstractness(builder);
+    checkReturnType(builder);
+    checkThrows(builder);
+    checkQualifiers(builder);
+    checkMapKeys(builder);
+    checkMultibindings(builder);
+  }
+
+  /**
+   * Adds an error if the method is not declared in a class or interface annotated with one of the
+   * {@link #enclosingElementAnnotations}.
+   */
+  private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!isAnyAnnotationPresent(
+        builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
+      builder.addError(
+          formatErrorMessage(
+              BINDING_METHOD_NOT_IN_MODULE,
+              FluentIterable.from(enclosingElementAnnotations)
+                  .transform(
+                      new Function<Class<?>, String>() {
+                        @Override
+                        public String apply(Class<?> clazz) {
+                          return clazz.getSimpleName();
+                        }
+                      })
+                  .join(Joiner.on(" or @"))));
+    }
+  }
+
+  /** Adds an error if the method is generic. */
+  private void checkTypeParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getTypeParameters().isEmpty()) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    }
+  }
+
+  /** Adds an error if the method is private. */
+  private void checkNotPrivate(ValidationReport.Builder<ExecutableElement> builder) {
+    if (builder.getSubject().getModifiers().contains(PRIVATE)) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    }
+  }
+
+  /** Adds an error if the method is abstract but must not be, or is not and must be. */
+  private void checkAbstractness(ValidationReport.Builder<ExecutableElement> builder) {
+    boolean isAbstract = builder.getSubject().getModifiers().contains(ABSTRACT);
+    switch (abstractness) {
+      case MUST_BE_ABSTRACT:
+        if (!isAbstract) {
+          builder.addError(formatErrorMessage(BINDING_METHOD_NOT_ABSTRACT));
+        }
+        break;
+
+      case MUST_BE_CONCRETE:
+        if (isAbstract) {
+          builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Adds an error if the return type is not appropriate for the method.
+   *
+   * <p>Adds an error if the method doesn't return a primitive, array, declared type, or type
+   * variable.
+   *
+   * <p>If the method is not a multibinding contribution, adds an error if it returns a framework
+   * type.
+   *
+   * <p>If the method is a {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}
+   * contribution, adds an error if the method doesn't return a {@code Set<T>} for some {@code T}
+   */
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    switch (ContributionType.fromBindingMethod(builder.getSubject())) {
+      case UNIQUE:
+        /* Validate that a unique binding is not attempting to bind a framework type. This
+         * validation is only appropriate for unique bindings because multibindings may collect
+         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+        checkFrameworkType(builder);
+        // fall through
+
+      case SET:
+      case MAP:
+        checkKeyType(builder, builder.getSubject().getReturnType());
+        break;
+
+      case SET_VALUES:
+        checkSetValuesType(builder);
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
+   */
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
+    TypeKind kind = keyType.getKind();
+    if (kind.equals(VOID)) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    } else if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      builder.addError(badReturnTypeMessage());
+    }
+  }
+
+  /** The error message when a non-{@code void} binding method returns a bad type. */
+  protected String badReturnTypeMessage() {
+    return formatErrorMessage(BINDING_METHOD_RETURN_TYPE);
+  }
+
+  /**
+   * Adds an error if an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
+   * doesn't return a {@code Set<T>} for a reasonable {@code T}.
+   */
+  // TODO(gak): should we allow "covariant return" for set values?
+  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
+    checkSetValuesType(builder, builder.getSubject().getReturnType());
+  }
+
+  /** Adds an error if {@code type} is not a a {@code Set<T>} for a reasonable {@code T}. */
+  protected final void checkSetValuesType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror type) {
+    if (!SetType.isSet(type)) {
+      builder.addError(badSetValuesTypeMessage());
+    } else {
+      SetType setType = SetType.from(type);
+      if (setType.isRawType()) {
+        builder.addError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+      } else {
+        checkKeyType(builder, setType.elementType());
+      }
+    }
+  }
+
+  /**
+   * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
+   * subtype of {@link Exception}.
+   */
+  private void checkThrows(ValidationReport.Builder<ExecutableElement> builder) {
+    exceptionSuperclass.checkThrows(this, builder);
+  }
+
+  /** Adds an error if the method has more than one {@linkplain Qualifier qualifier} annotation. */
+  protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, builder.getSubject(), qualifier);
+      }
+    }
+  }
+
+  /**
+   * Adds an error if an {@link IntoMap @IntoMap} or {@code MAP} method doesn't have exactly one
+   * {@link MapKey @MapKey} annotation, or if a method that is neither {@link IntoMap @IntoMap} nor
+   * {@code MAP} has any.
+   */
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
+    if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
+      switch (mapKeys.size()) {
+        case 0:
+          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY));
+          break;
+        case 1:
+          break;
+        default:
+          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY));
+          break;
+      }
+    } else if (!mapKeys.isEmpty()) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY));
+    }
+  }
+
+  /**
+   * Adds errors if the method has more than one {@linkplain MultibindingAnnotations multibinding
+   * annotation} or if it has a multibinding annotation and its {@link Provides} or {@link Produces}
+   * annotation has a {@code type} parameter.
+   */
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<AnnotationMirror> multibindingAnnotations =
+        MultibindingAnnotations.forMethod(builder.getSubject());
+    if (multibindingAnnotations.size() > 1) {
+      for (AnnotationMirror annotation : multibindingAnnotations) {
+        builder.addError(
+            formatErrorMessage(MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD),
+            builder.getSubject(),
+            annotation);
+      }
+    }
+
+    AnnotationMirror bindingAnnotationMirror =
+        getAnnotationMirror(builder.getSubject(), methodAnnotation).get();
+    boolean usesProvidesType = false;
+    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+      usesProvidesType |= member.getSimpleName().contentEquals("type");
+    }
+    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+      builder.addError(
+          formatErrorMessage(MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM),
+          builder.getSubject());
+    }
+  }
+
+  /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
+  protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
+    if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
+      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+    }
+  }
+
+  /**
+   * Formats an error message whose first {@code %s} parameter should be replaced with the simple
+   * name of the method annotation.
+   */
+  protected String formatErrorMessage(String format, Object... otherParameters) {
+    return otherParameters.length == 0
+        ? String.format(format, methodAnnotation.getSimpleName())
+        : String.format(
+            format, Lists.asList(methodAnnotation.getSimpleName(), otherParameters).toArray());
+  }
+
+  /**
+   * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
+   * returns a bad type.
+   */
+  protected String badSetValuesTypeMessage() {
+    return formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  /** An abstract/concrete restriction on methods. */
+  protected enum Abstractness {
+    MUST_BE_ABSTRACT,
+    MUST_BE_CONCRETE
+  }
+
+  /**
+   * The exception class that all {@code throws}-declared throwables must extend, other than
+   * {@link Error}.
+   */
+  protected enum ExceptionSuperclass {
+    /** Methods may not declare any throwable types. */
+    NONE {
+      @Override
+      protected void checkThrows(
+          BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
+        if (!builder.getSubject().getThrownTypes().isEmpty()) {
+          builder.addError(validator.formatErrorMessage(BINDING_METHOD_THROWS_ANY));
+          return;
+        }
+      }
+    },
+
+    /** Methods may throw checked or unchecked exceptions or errors. */
+    EXCEPTION(Exception.class, BINDING_METHOD_THROWS),
+
+    /** Methods may throw unchecked exceptions or errors. */
+    RUNTIME_EXCEPTION(RuntimeException.class, BINDING_METHOD_THROWS_CHECKED),
+    ;
+
+    private final Class<? extends Exception> superclass;
+    private final String errorMessage;
+
+    private ExceptionSuperclass() {
+      this(null, null);
+    }
+
+    private ExceptionSuperclass(Class<? extends Exception> superclass, String errorMessage) {
+      this.superclass = superclass;
+      this.errorMessage = errorMessage;
+    }
+
+    /**
+     * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
+     * subtype of {@link Exception}.
+     *
+     * <p>This method is overridden in {@link #NONE}.
+     */
+    protected void checkThrows(
+        BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
+      TypeMirror exceptionSupertype =
+          validator.elements.getTypeElement(superclass.getCanonicalName()).asType();
+      TypeMirror errorType =
+          validator.elements.getTypeElement(Error.class.getCanonicalName()).asType();
+      for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
+        if (!validator.types.isSubtype(thrownType, exceptionSupertype)
+            && !validator.types.isSubtype(thrownType, errorType)) {
+          builder.addError(validator.formatErrorMessage(errorMessage));
+          break;
+        }
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 20e2f7998..4af09accf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -15,113 +15,70 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.ImmutableList;
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_NOT_ABSTRACT;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static dagger.internal.codegen.Validation.validateReturnType;
-import static dagger.internal.codegen.Validation.validateUncheckedThrows;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Binds} methods.
+ * A validator for {@link Binds} methods.
  */
-final class BindsMethodValidator {
-  private final Elements elements;
+final class BindsMethodValidator extends BindingMethodValidator {
   private final Types types;
-  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>>
-      validationCache;
 
   BindsMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
+    super(
+        elements,
+        types,
+        Binds.class,
+        ImmutableList.of(Module.class, ProducerModule.class),
+        MUST_BE_ABSTRACT,
+        RUNTIME_EXCEPTION);
     this.types = checkNotNull(types);
-    this.validationCache = CacheBuilder.newBuilder().build(new ValidationLoader());
   }
 
-  private final class ValidationLoader
-      extends CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>> {
-    @Override
-    public ValidationReport<ExecutableElement> load(ExecutableElement bindsMethodElement) {
-      ValidationReport.Builder<ExecutableElement> builder =
-          ValidationReport.about(bindsMethodElement);
-
-      checkArgument(isAnnotationPresent(bindsMethodElement, Binds.class));
-
-      Element enclosingElement = bindsMethodElement.getEnclosingElement();
-      if (!isAnnotationPresent(enclosingElement, Module.class)
-          && !isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-        builder.addError(
-            formatErrorMessage(
-                BINDING_METHOD_NOT_IN_MODULE,
-                String.format(
-                    // the first @ is in the format string
-                    "%s or @%s",
-                    Module.class.getSimpleName(),
-                    ProducerModule.class.getSimpleName())),
-            bindsMethodElement);
-      }
-
-      if (!bindsMethodElement.getTypeParameters().isEmpty()) {
-        builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), bindsMethodElement);
-      }
-
-      Set<Modifier> modifiers = bindsMethodElement.getModifiers();
-      if (!modifiers.contains(ABSTRACT)) {
-        builder.addError(formatErrorMessage(BINDS_METHOD_NOT_ABSTRACT), bindsMethodElement);
-      }
-      TypeMirror returnType = bindsMethodElement.getReturnType();
-      validateReturnType(Binds.class, builder, returnType);
-
-      List<? extends VariableElement> parameters = bindsMethodElement.getParameters();
-      if (parameters.size() == 1) {
-        VariableElement parameter = Iterables.getOnlyElement(parameters);
-        if (!types.isAssignable(parameter.asType(), returnType)) {
-          builder.addError(
-              formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
-        }
-      } else {
-        builder.addError(
-            formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
-      }
-
-      validateUncheckedThrows(elements, types, bindsMethodElement, Binds.class, builder);
-
-      validateMethodQualifiers(builder, bindsMethodElement);
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkParameters(builder);
+  }
 
-      return builder.build();
-    }
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    checkFrameworkType(builder);
+    checkKeyType(builder, builder.getSubject().getReturnType());
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement bindsMethodElement) {
-    return validationCache.getUnchecked(bindsMethodElement);
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
   }
 
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Binds.class.getSimpleName());
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
   }
 
-  private String formatErrorMessage(String msg, String parameter) {
-    return String.format(msg, Binds.class.getSimpleName(), parameter);
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    List<? extends VariableElement> parameters = builder.getSubject().getParameters();
+    if (parameters.size() == 1) {
+      VariableElement parameter = getOnlyElement(parameters);
+      if (!types.isAssignable(parameter.asType(), builder.getSubject().getReturnType())) {
+        builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      }
+    } else {
+      builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index fb9515486..e50bc2018 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -198,7 +198,7 @@ private void error(
       Object[] newArgs = new Object[extraArgs.length + 1];
       newArgs[0] = method;
       System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs), builder.getSubject());
+      builder.addError(String.format(inheritedError, newArgs));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CachingValidator.java b/compiler/src/main/java/dagger/internal/codegen/CachingValidator.java
new file mode 100644
index 000000000..fe5aaf180
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CachingValidator.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import javax.lang.model.element.Element;
+
+/** A decorator for {@link Validator}s that caches validation reports. */
+final class CachingValidator<T extends Element> extends Validator<T> {
+
+  private final LoadingCache<T, ValidationReport<T>> cache;
+
+  /** A {@link Validator} that caches validation reports from {@code validator}. */
+  static <T extends Element> CachingValidator<T> caching(Validator<T> validator) {
+    return new CachingValidator<T>(validator);
+  }
+
+  private CachingValidator(final Validator<T> validator) {
+    this.cache =
+        CacheBuilder.newBuilder()
+            .build(
+                new CacheLoader<T, ValidationReport<T>>() {
+                  @Override
+                  public ValidationReport<T> load(T key) {
+                    return validator.validate(key);
+                  }
+                });
+  }
+
+  @Override
+  public ValidationReport<T> validate(T element) {
+    return cache.getUnchecked(element);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 13a0b908b..588d2cde9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,6 +23,7 @@
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.lang.model.SourceVersion;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -81,12 +82,20 @@ public SourceVersion getSupportedSourceVersion() {
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
-    BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
+    Validator<ExecutableElement> bindsMethodValidator =
+        CachingValidator.caching(new BindsMethodValidator(elements, types));
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
+    MultibindingsMethodValidator multibindingsMethodValidator =
+        new MultibindingsMethodValidator(elements, types);
     MultibindingsValidator multibindingsValidator =
-        new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
+        new MultibindingsValidator(
+            elements,
+            keyFactory,
+            keyFormatter,
+            methodSignatureFormatter,
+            multibindingsMethodValidator);
 
     this.factoryGenerator =
         new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index b5966695a..98c363560 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -26,7 +26,6 @@
 import javax.lang.model.element.ExecutableElement;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
@@ -95,9 +94,6 @@ private static ContributionType forProductionType(Produces.Type productionType)
    * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
    */
   static ContributionType fromBindingMethod(ExecutableElement method) {
-    checkArgument(
-        isAnnotationPresent(method, Provides.class)
-            || isAnnotationPresent(method, Produces.class));
     if (isAnnotationPresent(method, IntoMap.class)) {
       return ContributionType.MAP;
     } else if (isAnnotationPresent(method, IntoSet.class)) {
@@ -111,7 +107,7 @@ static ContributionType fromBindingMethod(ExecutableElement method) {
     } else if (isAnnotationPresent(method, Produces.class)) {
       return forProductionType(method.getAnnotation(Produces.class).type());
     } else {
-      throw new AssertionError();
+      return ContributionType.UNIQUE;
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 6e695e9c8..04f8372cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -124,8 +124,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "@Reusable cannot be applied to components or subcomponents.";
 
   static final String BINDING_METHOD_RETURN_TYPE =
-      "@%s methods must either return a primitive, an array, a type variable, or a declared"
-          + " type.";
+      "@%s methods must return a primitive, an array, a type variable, or a declared type.";
 
   static final String BINDING_METHOD_THROWS_CHECKED =
       "@%s methods may only throw unchecked exceptions";
@@ -134,8 +133,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "@Nullable on @Produces methods does not do anything.";
 
   static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must either return a primitive, an array, a type variable, or a declared"
-          + " type, or a ListenableFuture of one of those types.";
+      "@Produces methods must return a primitive, an array, a type variable, or a declared type, "
+          + "or a ListenableFuture of one of those types.";
 
   static final String PRODUCES_METHOD_RAW_FUTURE =
       "@Produces methods cannot return a raw ListenableFuture.";
@@ -143,14 +142,16 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_SET_VALUES_RAW_SET =
       "@%s methods of type set values cannot return a raw Set";
 
-  static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
-      "@Provides methods of type set values must return a Set";
+  static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
+      "@%s methods of type set values must return a Set";
 
   static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
       "@Produces methods of type set values must return a Set or ListenableFuture of Set";
 
-  static final String PRODUCES_METHOD_THROWS =
-      "@Produces methods may only throw unchecked exceptions or exceptions subclassing Exception";
+  static final String BINDING_METHOD_THROWS =
+      "@%s methods may only throw unchecked exceptions or exceptions subclassing Exception";
+
+  static final String BINDING_METHOD_THROWS_ANY = "@%s methods may not throw";
 
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
@@ -160,7 +161,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BINDS_METHOD_NOT_ABSTRACT = "@Binds methods must be abstract";
+  static final String BINDING_METHOD_NOT_ABSTRACT = "@%s methods must be abstract";
 
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 4e095b944..5bfee0f54 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -35,7 +35,7 @@
 import javax.lang.model.util.ElementFilter;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Module}
@@ -47,8 +47,8 @@
 final class ModuleProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
-  private final ProvidesMethodValidator providesMethodValidator;
-  private final BindsMethodValidator bindsMethodValidator;
+  private final Validator<ExecutableElement> providesMethodValidator;
+  private final Validator<ExecutableElement> bindsMethodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -56,9 +56,9 @@
   ModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      ProvidesMethodValidator providesMethodValidator,
+      Validator<ExecutableElement> providesMethodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      BindsMethodValidator bindsMethodValidator,
+      Validator<ExecutableElement> bindsMethodValidator,
       FactoryGenerator factoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
@@ -78,10 +78,12 @@
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
     ImmutableSet<ExecutableElement> validProvidesMethods =
-        validateProvidesMethods(elementsByAnnotation);
+        providesMethodValidator.validate(
+            messager, methodsIn(elementsByAnnotation.get(Provides.class)));
 
     // second, check and collect all bind methods
-    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
+    ImmutableSet<ExecutableElement> validBindsMethods =
+        bindsMethodValidator.validate(messager, methodsIn(elementsByAnnotation.get(Binds.class)));
 
     // process each module
     for (Element moduleElement :
@@ -140,41 +142,4 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
     }
     return ImmutableSet.of();
   }
-
-  /* TODO(gak): Add an interface for Validators and combine these two methods and the ones in
-   * ProducerModuleProcessingStep */
-
-  private ImmutableSet<ExecutableElement> validateBindsMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
-      if (bindElement.getKind().equals(METHOD)) {
-        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
-        ValidationReport<ExecutableElement> methodReport =
-            bindsMethodValidator.validate(bindsMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validBindsMethodsBuilder.add(bindsMethodElement);
-        }
-      }
-    }
-    return validBindsMethodsBuilder.build();
-  }
-
-  private ImmutableSet<ExecutableElement> validateProvidesMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
-      if (providesElement.getKind().equals(METHOD)) {
-        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            providesMethodValidator.validate(providesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProvidesMethodsBuilder.add(providesMethodElement);
-        }
-      }
-    }
-    return validProvidesMethodsBuilder.build();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
new file mode 100644
index 000000000..ab8edc773
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import dagger.Multibindings;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
+
+/** A {@link Validator} for methods in {@link Multibindings @Multibindings} interfaces. */
+final class MultibindingsMethodValidator extends BindingMethodValidator {
+
+  MultibindingsMethodValidator(Elements elements, Types types) {
+    super(
+        elements,
+        types,
+        Multibindings.class,
+        Multibindings.class,
+        MUST_BE_ABSTRACT,
+        ExceptionSuperclass.NONE);
+  }
+
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    // TODO(dpb): Why not do the rest of the checks?
+    checkReturnType(builder);
+    checkQualifiers(builder);
+  }
+
+  @Override
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!isPlainMap(builder.getSubject().getReturnType())
+        && !isPlainSet(builder.getSubject().getReturnType())) {
+      builder.addError(METHOD_MUST_RETURN_MAP_OR_SET);
+    }
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !isFrameworkType(mapType.valueType());
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !isFrameworkType(setType.elementType());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index d68e1dec3..5834c983a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -15,35 +15,25 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Collection;
 import java.util.Map;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.TOO_MANY_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 
 /**
@@ -56,16 +46,19 @@
   private final KeyFormatter keyFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final TypeElement objectElement;
+  private final MultibindingsMethodValidator multibindingsMethodValidator;
 
   MultibindingsValidator(
       Elements elements,
       Key.Factory keyFactory,
       KeyFormatter keyFormatter,
-      MethodSignatureFormatter methodSignatureFormatter) {
+      MethodSignatureFormatter methodSignatureFormatter,
+      MultibindingsMethodValidator multibindingsMethodValidator) {
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.keyFormatter = keyFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.multibindingsMethodValidator = multibindingsMethodValidator;
     this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
   }
 
@@ -93,18 +86,12 @@
       if (method.getEnclosingElement().equals(objectElement)) {
         continue;
       }
-      if (!isPlainMap(method.getReturnType()) && !isPlainSet(method.getReturnType())) {
-        validation.addError(METHOD_MUST_RETURN_MAP_OR_SET, method);
-        continue;
-      }
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(method);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          validation.addError(TOO_MANY_QUALIFIERS, method, qualifier);
-        }
-        continue;
-      }
-      if (bindingType.isPresent()) {
+      
+      ValidationReport<ExecutableElement> methodReport =
+          multibindingsMethodValidator.validate(method);
+      validation.addItems(methodReport.items());
+
+      if (methodReport.isClean() && bindingType.isPresent()) {
         methodsByKey.put(
             keyFactory.forMultibindingsMethod(
                 bindingType.get(), asExecutable(method.asType()), method),
@@ -138,28 +125,4 @@ private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableE
       return Optional.<BindingType>absent();
     }
   }
-
-  private boolean isPlainMap(TypeMirror returnType) {
-    if (!MapType.isMap(returnType)) {
-      return false;
-    }
-    MapType mapType = MapType.from(returnType);
-    return !mapType.isRawType()
-        && MoreTypes.isType(mapType.valueType()) // No wildcards.
-        && !mapType.valuesAreTypeOf(Provider.class)
-        && !mapType.valuesAreTypeOf(Producer.class)
-        && !mapType.valuesAreTypeOf(Produced.class);
-  }
-
-  private boolean isPlainSet(TypeMirror returnType) {
-    if (!SetType.isSet(returnType)) {
-      return false;
-    }
-    SetType setType = SetType.from(returnType);
-    return !setType.isRawType()
-        && MoreTypes.isType(setType.elementType()) // No wildcards.
-        && !setType.elementsAreTypeOf(Provider.class)
-        && !setType.elementsAreTypeOf(Producer.class)
-        && !setType.elementsAreTypeOf(Produced.class);
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index fa8a8227d..28c8b1759 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -36,7 +36,7 @@
 import javax.lang.model.util.ElementFilter;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the
@@ -48,8 +48,8 @@
 final class ProducerModuleProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
-  private final ProducesMethodValidator producesMethodValidator;
-  private final BindsMethodValidator bindsMethodValidator;
+  private final Validator<ExecutableElement> producesMethodValidator;
+  private final Validator<ExecutableElement> bindsMethodValidator;
   private final ProductionBinding.Factory productionBindingFactory;
   private final ProducerFactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -57,8 +57,8 @@
   ProducerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      ProducesMethodValidator producesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
+      Validator<ExecutableElement> producesMethodValidator,
+      Validator<ExecutableElement> bindsMethodValidator,
       ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator factoryGenerator) {
     this.messager = messager;
@@ -79,10 +79,12 @@
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all produces methods
     ImmutableSet<ExecutableElement> validProducesMethods =
-        validateProducesMethods(elementsByAnnotation);
+        producesMethodValidator.validate(
+            messager, methodsIn(elementsByAnnotation.get(Produces.class)));
 
     // second, check and collect all bind methods
-    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
+    ImmutableSet<ExecutableElement> validBindsMethods =
+        bindsMethodValidator.validate(messager, methodsIn(elementsByAnnotation.get(Binds.class)));
 
     // process each module
     for (Element moduleElement :
@@ -144,38 +146,4 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
     }
     return ImmutableSet.of();
   }
-
-  private ImmutableSet<ExecutableElement> validateProducesMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
-    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
-      if (producesElement.getKind().equals(METHOD)) {
-        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            producesMethodValidator.validate(producesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProducesMethodsBuilder.add(producesMethodElement);
-        }
-      }
-    }
-    return validProducesMethodsBuilder.build();
-  }
-
-  private ImmutableSet<ExecutableElement> validateBindsMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
-    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
-      if (bindElement.getKind().equals(METHOD)) {
-        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
-        ValidationReport<ExecutableElement> methodReport =
-            bindsMethodValidator.validate(bindsMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validBindsMethodsBuilder.add(bindsMethodElement);
-        }
-      }
-    }
-    return validBindsMethodsBuilder.build();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 15b7a9619..497be53d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -16,212 +16,104 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
+import com.google.common.base.Optional;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.ProvidesMethodValidator.validateMapKey;
-import static dagger.internal.codegen.ProvidesMethodValidator.validateMultibindingSpecifiers;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Produces} methods.
+ * A validator for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
 // TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
-final class ProducesMethodValidator {
-  private final Elements elements;
-  private final Types types;
+final class ProducesMethodValidator extends BindingMethodValidator {
 
   ProducesMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
+    super(elements, types, Produces.class, ProducerModule.class, MUST_BE_CONCRETE, EXCEPTION);
   }
-
-  private TypeElement getSetElement() {
-    return elements.getTypeElement(Set.class.getCanonicalName());
+  
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkNullable(builder);
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.about(producesMethodElement);
-
-    Element enclosingElement = producesMethodElement.getEnclosingElement();
-    if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-      builder.addError(
-          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), producesMethodElement);
-    }
-
-    if (!producesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
-    }
-
-    Set<Modifier> modifiers = producesMethodElement.getModifiers();
-    if (modifiers.contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
-    }
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
-    }
-
-    if (ConfigurationAnnotations.getNullableType(producesMethodElement).isPresent()) {
-      // TODO(beder): Make this an error.
-      builder.addWarning(PRODUCES_METHOD_NULLABLE, producesMethodElement);
-    }
-
-    TypeMirror returnType = producesMethodElement.getReturnType();
-    TypeKind returnTypeKind = returnType.getKind();
-    if (returnTypeKind.equals(VOID)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
-    }
-
-    if (FrameworkTypes.isFrameworkType(returnType)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES), producesMethodElement);
-    }
-
-    TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, exceptionType) && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(PRODUCES_METHOD_THROWS, producesMethodElement);
-        break;
-      }
-    }
-
-    ContributionType contributionType = ContributionType.fromBindingMethod(producesMethodElement);
-    validateMapKey(builder, producesMethodElement, contributionType, Produces.class);
-
-    validateMultibindingSpecifiers(builder, producesMethodElement, Produces.class);
-
-    validateMethodQualifiers(builder, producesMethodElement);
-
-    switch (contributionType) {
-      case UNIQUE:
-      case SET:
-        validateSingleReturnType(builder, returnType);
-        break;
-      case MAP:
-        validateSingleReturnType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
-        switch (mapKeys.size()) {
-          case 0:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
-            break;
-          case 1:
-            break;
-          default:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
-            break;
-        }
-        break;
-      case SET_VALUES:
-        if (returnTypeKind.equals(DECLARED)
-            && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-          DeclaredType declaredReturnType = MoreTypes.asDeclared(returnType);
-          if (!declaredReturnType.getTypeArguments().isEmpty()) {
-            validateSetType(builder, Iterables.getOnlyElement(
-                declaredReturnType.getTypeArguments()));
-          }
-        } else {
-          validateSetType(builder, returnType);
-        }
-        break;
-      default:
-        throw new AssertionError();
+  /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
+  // TODO(beder): Make this an error.
+  private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
+    if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
+      builder.addWarning(PRODUCES_METHOD_NULLABLE);
     }
-
-    return builder.build();
   }
 
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Produces.class.getSimpleName());
+  @Override
+  protected String badReturnTypeMessage() {
+    return formatErrorMessage(PRODUCES_METHOD_RETURN_TYPE);
   }
 
-  private String formatModuleErrorMessage(String msg) {
-    return String.format(msg, Produces.class.getSimpleName(), ProducerModule.class.getSimpleName());
+  /**
+   * {@inheritDoc}
+   *
+   * <p>Allows {@code keyType} to be a {@link ListenableFuture} of an otherwise-valid key type.
+   */
+  @Override
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror keyType) {
+    Optional<TypeMirror> typeToCheck = unwrapListenableFuture(reportBuilder, keyType);
+    if (typeToCheck.isPresent()) {
+      super.checkKeyType(reportBuilder, typeToCheck.get());
+    }
   }
 
-  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addError(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+  /**
+   * {@inheritDoc}
+   *
+   * <p>Allows an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method to return a
+   * {@link ListenableFuture} of a {@link Set} as well.
+   */
+  @Override
+  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
+    Optional<TypeMirror> typeToCheck =
+        unwrapListenableFuture(builder, builder.getSubject().getReturnType());
+    if (typeToCheck.isPresent()) {
+      checkSetValuesType(builder, typeToCheck.get());
     }
   }
 
-  private void validateSingleReturnType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+  @Override
+  protected String badSetValuesTypeMessage() {
+    return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+  }
+
+  private Optional<TypeMirror> unwrapListenableFuture(
+      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror type) {
+    if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
+        return Optional.absent();
       } else {
-        validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+        return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
       }
-    } else {
-      validateKeyType(reportBuilder, type);
-    }
-  }
-
-  private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    if (!type.getKind().equals(DECLARED)) {
-      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
-      return;
-    }
-
-    // TODO(gak): should we allow "covariant return" for set values?
-    DeclaredType declaredType = MoreTypes.asDeclared(type);
-    if (!declaredType.asElement().equals(getSetElement())) {
-      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
-    } else if (declaredType.getTypeArguments().isEmpty()) {
-      reportBuilder.addError(
-          formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), reportBuilder.getSubject());
-    } else {
-      validateSingleReturnType(reportBuilder,
-          Iterables.getOnlyElement(declaredType.getTypeArguments()));
     }
+    return Optional.of(type);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index c435c3427..4de6fd673 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,221 +15,41 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.Validation.validateMethodQualifiers;
-import static dagger.internal.codegen.Validation.validateReturnType;
-import static dagger.internal.codegen.Validation.validateUncheckedThrows;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@linkplain ValidationReport validator} for {@link Provides} methods.
+ * A validator for {@link Provides} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ProvidesMethodValidator {
-  private final Elements elements;
-  private final Types types;
+final class ProvidesMethodValidator extends BindingMethodValidator {
 
   ProvidesMethodValidator(Elements elements, Types types) {
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
+    super(elements, types, Provides.class, Module.class, MUST_BE_CONCRETE, RUNTIME_EXCEPTION);
   }
 
-  private TypeElement getSetElement() {
-    return elements.getTypeElement(Set.class.getCanonicalName());
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkDependsOnProducers(builder);
   }
 
-  ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.about(providesMethodElement);
-
-    Element enclosingElement = providesMethodElement.getEnclosingElement();
-    if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addError(
-          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), providesMethodElement);
-    }
-
-    if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), providesMethodElement);
-    }
-
-    Set<Modifier> modifiers = providesMethodElement.getModifiers();
-    if (modifiers.contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), providesMethodElement);
-    }
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
-    }
-
-    TypeMirror returnType = providesMethodElement.getReturnType();
-    TypeKind returnTypeKind = returnType.getKind();
-    if (returnTypeKind.equals(VOID)) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
-    }
-
-    validateUncheckedThrows(elements, types, providesMethodElement, Provides.class, builder);
-
-    for (VariableElement parameter : providesMethodElement.getParameters()) {
+  /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
+  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
     }
-
-    ContributionType contributionType = ContributionType.fromBindingMethod(providesMethodElement);
-
-    validateMapKey(builder, providesMethodElement, contributionType, Provides.class);
-
-    validateMethodQualifiers(builder, providesMethodElement);
-
-    validateMultibindingSpecifiers(builder, providesMethodElement, Provides.class);
-    switch (contributionType) {
-      case UNIQUE:
-        /* Validate that a unique binding is not attempting to bind a framework type. This
-         * validation is only appropriate for unique bindings because multibindings may collect
-         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
-        if (FrameworkTypes.isFrameworkType(returnType)) {
-          builder.addError(
-              formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES),
-              providesMethodElement);
-        }
-        // fall through
-      case SET:
-        validateReturnType(Provides.class, builder, returnType);
-        break;
-      case MAP:
-        validateReturnType(Provides.class, builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
-        switch (mapKeys.size()) {
-          case 0:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
-            break;
-          case 1:
-            break;
-          default:
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
-            break;
-        }
-        break;
-      case SET_VALUES:
-        if (!returnTypeKind.equals(DECLARED)) {
-          builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
-        } else {
-          DeclaredType declaredReturnType = (DeclaredType) returnType;
-          // TODO(gak): should we allow "covariant return" for set values?
-          if (!declaredReturnType.asElement().equals(getSetElement())) {
-            builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
-          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addError(
-                formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
-          } else {
-            validateReturnType(
-                Provides.class,
-                builder,
-                Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
-          }
-        }
-        break;
-      default:
-        throw new AssertionError();
-    }
-
-    return builder.build();
-  }
-
-  /** Validate that methods for map multibindings have a {@code @MapKey} annotation. */
-  static void validateMapKey(
-      ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement method,
-      ContributionType contributionType,
-      Class<? extends Annotation> bindingAnnotation) {
-    if (!contributionType.equals(ContributionType.MAP) && !getMapKeys(method).isEmpty()) {
-      builder.addError(
-          String.format(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, bindingAnnotation.getSimpleName()),
-          method);
-    }
-  }
-
-  /**
-   * Validate that at most one multibinding annotation is used, and not in conflict with {@link
-   * Provides#type()}.
-   */
-  static void validateMultibindingSpecifiers(
-      ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement method,
-      Class<? extends Annotation> bindingAnnotation) {
-    ImmutableSet<AnnotationMirror> multibindingAnnotations =
-        MultibindingAnnotations.forMethod(method);
-    if (multibindingAnnotations.size() > 1) {
-      for (AnnotationMirror annotation : multibindingAnnotations) {
-        builder.addError(
-            String.format(
-                MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD, bindingAnnotation.getSimpleName()),
-            method,
-            annotation);
-      }
-    }
-
-    AnnotationMirror bindingAnnotationMirror = getAnnotationMirror(method, bindingAnnotation).get();
-    boolean usesProvidesType = false;
-    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
-      usesProvidesType |= member.getSimpleName().contentEquals("type");
-    }
-    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
-      builder.addError(
-          String.format(
-              MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM,
-              bindingAnnotation.getSimpleName()),
-          method);
-    }
-  }
-
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, Provides.class.getSimpleName());
-  }
-
-  private static String formatModuleErrorMessage(String msg) {
-    return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 606a088c3..0769bd77d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -170,5 +170,22 @@ public TypeElement visitType(TypeElement e, Void p) {
         }
       };
 
+      
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+   * as any of that of {@code annotationClasses}.
+   */
+  // TODO(dpb): Move to MoreElements.
+  static boolean isAnyAnnotationPresent(
+      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+    for (Class<? extends Annotation> annotation : annotationClasses) {
+      if (isAnnotationPresent(element, annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validation.java b/compiler/src/main/java/dagger/internal/codegen/Validation.java
deleted file mode 100644
index 4a2c659b8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/Validation.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import java.lang.annotation.Annotation;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-
-final class Validation {
-
-  private Validation() {}
-
-  /** Validates that the given method only throws unchecked exceptions. */
-  static void validateUncheckedThrows(
-      Elements elements,
-      Types types,
-      ExecutableElement methodElement,
-      Class<? extends Annotation> methodAnnotation,
-      ValidationReport.Builder<ExecutableElement> builder) {
-    TypeMirror runtimeExceptionType =
-        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, runtimeExceptionType)
-          && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(
-            String.format(BINDING_METHOD_THROWS_CHECKED, methodAnnotation.getSimpleName()),
-            methodElement);
-        break;
-      }
-    }
-  }
-
-  /** Validates that the return type of a binding method is an acceptable kind. */
-  static void validateReturnType(
-      Class<? extends Annotation> methodAnnotation,
-      ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror returnType) {
-    TypeKind kind = returnType.getKind();
-    if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      reportBuilder.addError(
-          String.format(BINDING_METHOD_RETURN_TYPE, methodAnnotation.getSimpleName()),
-          reportBuilder.getSubject());
-    }
-  }
-
-  /** Validates that a Provides, Produces or Bind method doesn't have multiple qualifiers. */
-  static void validateMethodQualifiers(
-      ValidationReport.Builder<ExecutableElement> builder, ExecutableElement methodElement) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
-      }
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
new file mode 100644
index 000000000..835e4e851
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validator.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/** An object that produces a {@link ValidationReport} for an element. */
+abstract class Validator<T extends Element> {
+  /** Returns a {@link ValidationReport} for {@code element}. */
+  abstract ValidationReport<T> validate(T element);
+
+  /** Prints validation reports to {@code messager}, and returns valid elements. */
+  final ImmutableSet<T> validate(Messager messager, Iterable<? extends T> elements) {
+    ImmutableSet.Builder<T> validElements = ImmutableSet.builder();
+    for (T element : elements) {
+      ValidationReport<T> elementReport = validate(element);
+      elementReport.printMessagesTo(messager);
+      if (elementReport.isClean()) {
+        validElements.add(element);
+      }
+    }
+    return validElements.build();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index df2a92978..82dd4236f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -36,11 +36,11 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -252,10 +252,11 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
   }
 
   @Test public void modulesWithTypeParamsMustBeAbstract() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 91c908c73..30f30055f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -286,13 +286,11 @@ public void badMethods() {
         .in(testModule)
         .onLine(26)
         .and()
-        .withErrorContaining(
-            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .withErrorContaining("Cannot use more than one @Qualifier")
         .in(testModule)
         .onLine(27)
         .and()
-        .withErrorContaining(
-            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .withErrorContaining("Cannot use more than one @Qualifier")
         .in(testModule)
         .onLine(28);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 5973a7bb3..3caf3f6e3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -33,12 +33,12 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -396,7 +396,7 @@ public void producesMethodThrowsThrowable() {
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_THROWS)
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS))
         .in(moduleFile)
         .onLine(8);
   }
