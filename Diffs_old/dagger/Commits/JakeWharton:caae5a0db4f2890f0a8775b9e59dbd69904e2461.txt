diff --git a/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java b/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java
index d6e320959..426ae6e53 100644
--- a/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java
+++ b/reflect/reflect/src/main/java/dagger/reflect/DaggerReflect.java
@@ -4,6 +4,9 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
@@ -63,7 +66,7 @@
         Annotation qualifier = findQualifier(annotations);
         Key key = Key.of(qualifier, returnType);
 
-        Binding<?> binding;
+        Binding<Object> binding;
         if (hasAnnotation(annotations, Provides.class)) {
           binding = new ProvidesBinding(method);
         } else if (hasAnnotation(annotations, Binds.class)) {
@@ -71,7 +74,17 @@
         } else {
           throw notImplemented("Method " + method);
         }
-        graphBuilder.addBinding(key, binding);
+
+        if (hasAnnotation(annotations, IntoSet.class)) {
+          graphBuilder.addSetBinding(Key.setOf(key), binding);
+        } else if (hasAnnotation(annotations, ElementsIntoSet.class)) {
+          throw notImplemented("@ElementsIntoSet");
+        } else if (hasAnnotation(annotations, IntoMap.class)) {
+          // TODO find map key annotation, get value, create map Key, call addMapBinding
+          throw notImplemented("@IntoMap");
+        } else {
+          graphBuilder.addBinding(key, binding);
+        }
       }
     }
 
diff --git a/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java b/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java
index 59744a291..78ccc9300 100644
--- a/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java
+++ b/reflect/reflect/src/main/java/dagger/reflect/InstanceGraph.java
@@ -3,7 +3,9 @@
 import dagger.Lazy;
 import dagger.internal.DoubleCheck;
 import java.lang.annotation.Annotation;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.inject.Provider;
@@ -15,12 +17,12 @@
   final @Nullable Annotation scope;
 
   private InstanceGraph(
-      Map<Key, Binding<?>> bindings,
+      ConcurrentHashMap<Key, Binding<?>> bindings,
       @Nullable InstanceGraph parent,
       @Nullable Annotation scope) {
     this.scope = scope;
     this.parent = parent;
-    this.bindings = new ConcurrentHashMap<Key, Binding<?>>(bindings);
+    this.bindings = bindings;
   }
 
   private Binding<?> getBinding(Key key) {
@@ -58,6 +60,10 @@ Object getInstance(Key key) {
 
   static final class Builder {
     private final Map<Key, Binding<?>> bindings = new LinkedHashMap<Key, Binding<?>>();
+    private final Map<Key, List<Binding<Object>>> setBindings =
+        new LinkedHashMap<Key, List<Binding<Object>>>();
+    private final Map<Key, Map<Object, Binding<Object>>> mapBindings =
+        new LinkedHashMap<Key, Map<Object, Binding<Object>>>();
     private @Nullable InstanceGraph parent;
     private @Nullable Annotation scope;
 
@@ -77,18 +83,71 @@ Builder parent(@Nullable InstanceGraph parent) {
       return this;
     }
 
-    Builder addBinding(Key key, Binding<?> binding) {
-      Binding<?> replaced = bindings.put(key, binding);
-      if (replaced != null) {
-        throw new IllegalStateException(
-            "Duplicate binding for " + key + ": " + replaced + " and " + binding);
+    Builder addBinding(Key key, Binding<Object> binding) {
+      checkedPut(bindings, key, binding);
+      return this;
+    }
+
+    Builder addSetBinding(Key key, Binding<Object> binding) {
+      // TODO validate key is a Set?
+
+      List<Binding<Object>> bindings = setBindings.get(key);
+      if (bindings == null) {
+        bindings = new ArrayList<Binding<Object>>();
+        setBindings.put(key, bindings);
       }
+      bindings.add(binding);
+      return this;
+    }
+
+    Builder addMapBinding(Key key, Object mapKey, Binding<Object> binding) {
+      // TODO validate key is a Map?
+
+      Map<Object, Binding<Object>> bindings = mapBindings.get(key);
+      if (bindings == null) {
+        bindings = new LinkedHashMap<Object, Binding<Object>>();
+        mapBindings.put(key, bindings);
+      }
+      bindings.put(mapKey, binding);
       return this;
     }
 
     InstanceGraph build() {
-      // TODO traverse scope hierarchy and validate?
+      if (scope != null) {
+        InstanceGraph check = parent;
+        while (check != null) {
+          if (parent.scope == null) {
+            throw new IllegalStateException("Scoped graph cannot depend on an unscoped one");
+          }
+          if (parent.scope.equals(scope)) {
+            throw new IllegalStateException("Scope " + scope + " found in parent graph chain");
+          }
+          check = check.parent;
+        }
+      }
+
+      ConcurrentHashMap<Key, Binding<?>> bindings =
+          new ConcurrentHashMap<Key, Binding<?>>(this.bindings);
+
+      // TODO get set bindings from parents and merge
+      for (Map.Entry<Key, List<Binding<Object>>> entry : setBindings.entrySet()) {
+        checkedPut(bindings, entry.getKey(), new SetBinding<Object>(entry.getValue()));
+      }
+
+      // TODO get map bindings from parents and merge
+      for (Map.Entry<Key, Map<Object, Binding<Object>>> entry : mapBindings.entrySet()) {
+        checkedPut(bindings, entry.getKey(), new MapBinding<Object, Object>(entry.getValue()));
+      }
+
       return new InstanceGraph(bindings, parent, scope);
     }
+
+    private static <T> void checkedPut(Map<Key, T> bindings, Key key, T binding) {
+      T replaced = bindings.put(key, binding);
+      if (replaced != null) {
+        throw new IllegalStateException(
+            "Duplicate value for key " + key + ": " + replaced + " and " + binding);
+      }
+    }
   }
 }
diff --git a/reflect/reflect/src/main/java/dagger/reflect/Key.java b/reflect/reflect/src/main/java/dagger/reflect/Key.java
index a759c1f06..8eac4db35 100644
--- a/reflect/reflect/src/main/java/dagger/reflect/Key.java
+++ b/reflect/reflect/src/main/java/dagger/reflect/Key.java
@@ -1,9 +1,12 @@
 package dagger.reflect;
 
 import com.google.auto.value.AutoValue;
+import dagger.reflect.TypeUtil.ParameterizedTypeImpl;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.Set;
 import org.jetbrains.annotations.Nullable;
 
 /** A type and optional qualifier. */
@@ -19,6 +22,11 @@ static Key of(@Nullable Annotation qualifier, Type type) {
     return new AutoValue_Key(qualifier, type);
   }
 
+  static Key setOf(Key key) {
+    Type setType = new ParameterizedTypeImpl(null, Set.class, key.type());
+    return new AutoValue_Key(key.qualifer(), setType);
+  }
+
   abstract @Nullable Annotation qualifer();
   abstract Type type();
 }
diff --git a/reflect/reflect/src/main/java/dagger/reflect/MapBinding.java b/reflect/reflect/src/main/java/dagger/reflect/MapBinding.java
new file mode 100644
index 000000000..8c60ec156
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/MapBinding.java
@@ -0,0 +1,58 @@
+package dagger.reflect;
+
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import org.jetbrains.annotations.Nullable;
+
+import static java.util.Collections.unmodifiableMap;
+
+final class MapBinding<K, V> extends Binding<Map<K, V>> {
+  private final List<Map.Entry<K, Binding<V>>> bindingEntries;
+  private int[] requestCounts;
+
+  MapBinding(Map<K, Binding<V>> bindings) {
+    bindingEntries = new ArrayList<Map.Entry<K, Binding<V>>>(bindings.entrySet());
+  }
+
+  @Override protected Request[] initialize(@Nullable Annotation scope) {
+    int bindingCount = bindingEntries.size();
+    Request[][] bindingRequestArrays = new Request[bindingCount][];
+    int[] requestCounts = new int[bindingCount];
+    int count = 0;
+    for (int i = 0; i < bindingCount; i++) {
+      Map.Entry<K, Binding<V>> bindingEntry = bindingEntries.get(i);
+      Request[] bindingRequests = bindingEntry.getValue().initialize(scope);
+      bindingRequestArrays[i] = bindingRequests;
+      requestCounts[i] = bindingRequests.length;
+      count += bindingRequests.length;
+    }
+
+    Request[] requests = new Request[count];
+    for (int i = 0, start = 0; i < bindingCount; i++) {
+      Request[] bindingRequests = bindingRequestArrays[i];
+      System.arraycopy(bindingRequests, 0, requests, start, bindingRequests.length);
+      start += bindingRequests.length;
+    }
+
+    this.requestCounts = requestCounts;
+    return requests;
+  }
+
+  @Override protected Map<K, V> resolve(Object[] dependencies) {
+    int contributionCount = bindingEntries.size();
+    Map<K, V> values = new LinkedHashMap<K, V>(contributionCount);
+    for (int i = 0, start = 0; i < contributionCount; i++) {
+      int dependencyCount = requestCounts[i];
+      Object[] dependencySubset = new Object[dependencyCount];
+      System.arraycopy(dependencies, start, dependencySubset, 0, dependencyCount);
+
+      Map.Entry<K, Binding<V>> bindingEntry = bindingEntries.get(i);
+      values.put(bindingEntry.getKey(), bindingEntry.getValue().resolve(dependencySubset));
+      start += dependencyCount;
+    }
+    return unmodifiableMap(values);
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/SetBinding.java b/reflect/reflect/src/main/java/dagger/reflect/SetBinding.java
new file mode 100644
index 000000000..039a67249
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/SetBinding.java
@@ -0,0 +1,56 @@
+package dagger.reflect;
+
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import org.jetbrains.annotations.Nullable;
+
+import static java.util.Collections.unmodifiableSet;
+
+final class SetBinding<T> extends Binding<Set<T>> {
+  private final List<Binding<T>> bindings;
+  private int[] requestCounts;
+
+  SetBinding(List<Binding<T>> bindings) {
+    this.bindings = new ArrayList<Binding<T>>(bindings);
+  }
+
+  @Override protected Request[] initialize(@Nullable Annotation scope) {
+    int bindingCount = bindings.size();
+    Request[][] bindingRequestArrays = new Request[bindingCount][];
+    int[] requestCounts = new int[bindingCount];
+    int count = 0;
+    for (int i = 0; i < bindingCount; i++) {
+      Request[] bindingRequests = bindings.get(i).initialize(scope);
+      bindingRequestArrays[i] = bindingRequests;
+      requestCounts[i] = bindingRequests.length;
+      count += bindingRequests.length;
+    }
+
+    Request[] requests = new Request[count];
+    for (int i = 0, start = 0; i < bindingCount; i++) {
+      Request[] bindingRequests = bindingRequestArrays[i];
+      System.arraycopy(bindingRequests, 0, requests, start, bindingRequests.length);
+      start += bindingRequests.length;
+    }
+
+    this.requestCounts = requestCounts;
+    return requests;
+  }
+
+  @Override protected Set<T> resolve(Object[] dependencies) {
+    int contributionCount = bindings.size();
+    Set<T> values = new LinkedHashSet<T>(contributionCount);
+    for (int i = 0, start = 0; i < contributionCount; i++) {
+      int dependencyCount = requestCounts[i];
+      Object[] dependencySubset = new Object[dependencyCount];
+      System.arraycopy(dependencies, start, dependencySubset, 0, dependencyCount);
+
+      values.add(bindings.get(i).resolve(dependencySubset));
+      start += dependencyCount;
+    }
+    return unmodifiableSet(values);
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/TypeUtil.java b/reflect/reflect/src/main/java/dagger/reflect/TypeUtil.java
new file mode 100644
index 000000000..1236064d5
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/TypeUtil.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.reflect;
+
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import org.jetbrains.annotations.Nullable;
+
+final class TypeUtil {
+  private static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
+
+  private TypeUtil() {
+  }
+
+  /**
+   * Returns a type that is functionally equal but not necessarily equal according to {@link
+   * Object#equals(Object) Object.equals()}.
+   */
+  static Type canonicalize(Type type) {
+    if (type instanceof Class) {
+      Class<?> c = (Class<?>) type;
+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;
+
+    } else if (type instanceof ParameterizedType) {
+      if (type instanceof ParameterizedTypeImpl) return type;
+      ParameterizedType p = (ParameterizedType) type;
+      return new ParameterizedTypeImpl(p.getOwnerType(),
+          p.getRawType(), p.getActualTypeArguments());
+
+    } else if (type instanceof GenericArrayType) {
+      if (type instanceof GenericArrayTypeImpl) return type;
+      GenericArrayType g = (GenericArrayType) type;
+      return new GenericArrayTypeImpl(g.getGenericComponentType());
+
+    } else if (type instanceof WildcardType) {
+      if (type instanceof WildcardTypeImpl) return type;
+      WildcardType w = (WildcardType) type;
+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());
+
+    } else {
+      return type; // This type is unsupported!
+    }
+  }
+
+  static int hashCodeOrZero(@Nullable Object o) {
+    return o != null ? o.hashCode() : 0;
+  }
+
+  static String typeToString(Type type) {
+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();
+  }
+
+  static void checkNotPrimitive(Type type) {
+    if ((type instanceof Class<?>) && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException("Unexpected primitive " + type + ". Use the boxed type.");
+    }
+  }
+
+  static final class ParameterizedTypeImpl implements ParameterizedType {
+    private final @Nullable Type ownerType;
+    private final Type rawType;
+    final Type[] typeArguments;
+
+    ParameterizedTypeImpl(@Nullable Type ownerType, Type rawType, Type... typeArguments) {
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>) {
+        Class<?> enclosingClass = ((Class<?>) rawType).getEnclosingClass();
+        if (ownerType != null) {
+          if (enclosingClass == null || Types.getRawType(ownerType) != enclosingClass) {
+            throw new IllegalArgumentException(
+                "unexpected owner type for " + rawType + ": " + ownerType);
+          }
+        } else if (enclosingClass != null) {
+          throw new IllegalArgumentException(
+              "unexpected owner type for " + rawType + ": null");
+        }
+      }
+
+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);
+      this.rawType = canonicalize(rawType);
+      this.typeArguments = typeArguments.clone();
+      for (int t = 0; t < this.typeArguments.length; t++) {
+        if (this.typeArguments[t] == null) throw new NullPointerException();
+        checkNotPrimitive(this.typeArguments[t]);
+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);
+      }
+    }
+
+    @Override public Type[] getActualTypeArguments() {
+      return typeArguments.clone();
+    }
+
+    @Override public Type getRawType() {
+      return rawType;
+    }
+
+    @Override public @Nullable Type getOwnerType() {
+      return ownerType;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof ParameterizedType
+          && Types.equals(this, (ParameterizedType) other);
+    }
+
+    @Override public int hashCode() {
+      return Arrays.hashCode(typeArguments)
+          ^ rawType.hashCode()
+          ^ hashCodeOrZero(ownerType);
+    }
+
+    @Override public String toString() {
+      StringBuilder result = new StringBuilder(30 * (typeArguments.length + 1));
+      result.append(typeToString(rawType));
+
+      if (typeArguments.length == 0) {
+        return result.toString();
+      }
+
+      result.append("<").append(typeToString(typeArguments[0]));
+      for (int i = 1; i < typeArguments.length; i++) {
+        result.append(", ").append(typeToString(typeArguments[i]));
+      }
+      return result.append(">").toString();
+    }
+  }
+
+  static final class GenericArrayTypeImpl implements GenericArrayType {
+    private final Type componentType;
+
+    GenericArrayTypeImpl(Type componentType) {
+      this.componentType = canonicalize(componentType);
+    }
+
+    @Override public Type getGenericComponentType() {
+      return componentType;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof GenericArrayType
+          && Types.equals(this, (GenericArrayType) o);
+    }
+
+    @Override public int hashCode() {
+      return componentType.hashCode();
+    }
+
+    @Override public String toString() {
+      return typeToString(componentType) + "[]";
+    }
+  }
+
+  /**
+   * The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only
+   * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
+   * bound must be Object.class.
+   */
+  static final class WildcardTypeImpl implements WildcardType {
+    private final Type upperBound;
+    private final @Nullable Type lowerBound;
+
+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
+      if (lowerBounds.length > 1) throw new IllegalArgumentException();
+      if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+      if (lowerBounds.length == 1) {
+        if (lowerBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(lowerBounds[0]);
+        if (upperBounds[0] != Object.class) throw new IllegalArgumentException();
+        this.lowerBound = canonicalize(lowerBounds[0]);
+        this.upperBound = Object.class;
+
+      } else {
+        if (upperBounds[0] == null) throw new NullPointerException();
+        checkNotPrimitive(upperBounds[0]);
+        this.lowerBound = null;
+        this.upperBound = canonicalize(upperBounds[0]);
+      }
+    }
+
+    @Override public Type[] getUpperBounds() {
+      return new Type[] { upperBound };
+    }
+
+    @Override public Type[] getLowerBounds() {
+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof WildcardType
+          && Types.equals(this, (WildcardType) other);
+    }
+
+    @Override public int hashCode() {
+      // This equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds()).
+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)
+          ^ (31 + upperBound.hashCode());
+    }
+
+    @Override public String toString() {
+      if (lowerBound != null) {
+        return "? super " + typeToString(lowerBound);
+      } else if (upperBound == Object.class) {
+        return "?";
+      } else {
+        return "? extends " + typeToString(upperBound);
+      }
+    }
+  }
+}
diff --git a/reflect/reflect/src/main/java/dagger/reflect/Types.java b/reflect/reflect/src/main/java/dagger/reflect/Types.java
new file mode 100644
index 000000000..2ce97ed6c
--- /dev/null
+++ b/reflect/reflect/src/main/java/dagger/reflect/Types.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.reflect;
+
+import dagger.reflect.TypeUtil.ParameterizedTypeImpl;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import org.jetbrains.annotations.Nullable;
+
+final class Types {
+  private Types() {
+  }
+
+  static Class<?> getRawType(Type type) {
+    if (type instanceof Class<?>) {
+      // type is a normal class.
+      return (Class<?>) type;
+
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+
+      // I'm not exactly sure why getRawType() returns Type instead of Class. Neal isn't either but
+      // suspects some pathological case related to nested classes exists.
+      Type rawType = parameterizedType.getRawType();
+      return (Class<?>) rawType;
+
+    } else if (type instanceof GenericArrayType) {
+      Type componentType = ((GenericArrayType) type).getGenericComponentType();
+      return Array.newInstance(getRawType(componentType), 0).getClass();
+
+    } else if (type instanceof TypeVariable) {
+      // We could use the variable's bounds, but that won't work if there are multiple. having a raw
+      // type that's more general than necessary is okay.
+      return Object.class;
+
+    } else if (type instanceof WildcardType) {
+      return getRawType(((WildcardType) type).getUpperBounds()[0]);
+
+    } else {
+      String className = type == null ? "null" : type.getClass().getName();
+      throw new IllegalArgumentException("Expected a Class, ParameterizedType, or "
+          + "GenericArrayType, but <" + type + "> is of type " + className);
+    }
+  }
+
+  /** Returns true if {@code a} and {@code b} are equal. */
+  static boolean equals(@Nullable Type a, @Nullable Type b) {
+    if (a == b) {
+      return true; // Also handles (a == null && b == null).
+
+    } else if (a instanceof Class) {
+      if (b instanceof GenericArrayType) {
+        return equals(((Class) a).getComponentType(),
+            ((GenericArrayType) b).getGenericComponentType());
+      }
+      return a.equals(b); // Class already specifies equals().
+
+    } else if (a instanceof ParameterizedType) {
+      if (!(b instanceof ParameterizedType)) return false;
+      ParameterizedType pa = (ParameterizedType) a;
+      ParameterizedType pb = (ParameterizedType) b;
+      Type[] aTypeArguments = pa instanceof ParameterizedTypeImpl
+          ? ((ParameterizedTypeImpl) pa).typeArguments
+          : pa.getActualTypeArguments();
+      Type[] bTypeArguments = pb instanceof ParameterizedTypeImpl
+          ? ((ParameterizedTypeImpl) pb).typeArguments
+          : pb.getActualTypeArguments();
+      return equals(pa.getOwnerType(), pb.getOwnerType())
+          && pa.getRawType().equals(pb.getRawType())
+          && Arrays.equals(aTypeArguments, bTypeArguments);
+
+    } else if (a instanceof GenericArrayType) {
+      if (b instanceof Class) {
+        return equals(((Class) b).getComponentType(),
+            ((GenericArrayType) a).getGenericComponentType());
+      }
+      if (!(b instanceof GenericArrayType)) return false;
+      GenericArrayType ga = (GenericArrayType) a;
+      GenericArrayType gb = (GenericArrayType) b;
+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());
+
+    } else if (a instanceof WildcardType) {
+      if (!(b instanceof WildcardType)) return false;
+      WildcardType wa = (WildcardType) a;
+      WildcardType wb = (WildcardType) b;
+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())
+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());
+
+    } else if (a instanceof TypeVariable) {
+      if (!(b instanceof TypeVariable)) return false;
+      TypeVariable<?> va = (TypeVariable<?>) a;
+      TypeVariable<?> vb = (TypeVariable<?>) b;
+      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+          && va.getName().equals(vb.getName());
+
+    } else {
+      // This isn't a supported type.
+      return false;
+    }
+  }
+}
diff --git a/reflect/reflect/src/test/java/dagger/DaggerTest.java b/reflect/reflect/src/test/java/dagger/DaggerTest.java
index 2e065b433..09b366180 100644
--- a/reflect/reflect/src/test/java/dagger/DaggerTest.java
+++ b/reflect/reflect/src/test/java/dagger/DaggerTest.java
@@ -21,4 +21,9 @@
     TestComponent component = frontend.create(TestComponent.class);
     assertThat(component.hello()).isEqualTo("Hello, world!");
   }
+
+  @Test public void set() {
+    TestComponent component = frontend.create(TestComponent.class);
+    assertThat(component.strings()).containsExactly("Hello", "world");
+  }
 }
diff --git a/reflect/reflect/src/test/java/dagger/TestComponent.java b/reflect/reflect/src/test/java/dagger/TestComponent.java
index d428b838d..f0cea2c11 100644
--- a/reflect/reflect/src/test/java/dagger/TestComponent.java
+++ b/reflect/reflect/src/test/java/dagger/TestComponent.java
@@ -1,6 +1,8 @@
 package dagger;
 
+import dagger.multibindings.IntoSet;
 import java.lang.annotation.Retention;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
@@ -10,6 +12,7 @@
 @Component(modules = TestModule.class)
 interface TestComponent {
   CharSequence hello();
+  Set<String> strings();
 }
 
 @Module
@@ -18,10 +21,16 @@
     return greeting.get();
   }
 
+  @Provides @IntoSet static String provideGreetingIntoSet(@Greeting String string) {
+    return string;
+  }
+
   @Provides static @Target String provideTargetString() {
     return "world";
   }
 
+  @Binds @IntoSet abstract String bindTargetStringIntoSet(@Target String target);
+
   @Provides static @Exclamation String provideExclaimationString() {
     return "!";
   }
