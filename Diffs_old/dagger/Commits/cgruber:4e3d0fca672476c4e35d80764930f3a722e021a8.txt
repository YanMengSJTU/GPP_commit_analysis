diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index d1edfebc0..814314114 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -76,5 +76,35 @@
   static final String INJECT_INTO_PRIVATE_CLASS =
       "Dagger does not support injection into private classes";
 
+  /*
+   * Configuration errors
+   *
+   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
+   * etc.)
+   */
+  static final String PROVIDES_METHOD_RETURN_TYPE =
+      "@Provides methods must either return a primitive, an array or a declared type.";
+
+  static final String PROVIDES_METHOD_SET_VALUES_RAW_SET =
+      "@Provides methods of type set values cannot return a raw Set";
+
+  static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
+      "@Provides methods of type set values must return a Set";
+
+  static final String PROVIDES_METHOD_MUST_RETURN_A_VALUE =
+      "@Provides methods must return a value (not void).";
+
+  static final String PROVIDES_METHOD_ABSTRACT = "@Provides methods cannot be abstract";
+
+  static final String PROVIDES_METHOD_STATIC = "@Provides methods cannot be static";
+
+  static final String PROVIDES_METHOD_PRIVATE = "@Provides methods cannot be private";
+
+  static final String PROVIDES_METHOD_TYPE_PARAMETER =
+      "@Provides methods may not have type parameters.";
+
+  static final String PROVIDES_METHOD_NOT_IN_MODULE =
+      "@Provides methods can only be present within a @Module";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
new file mode 100644
index 000000000..c2ea00fa3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+
+/**
+ * A {@link Validator} for {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectConstructorValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(constructorElement);
+    if (constructorElement.getModifiers().contains(PRIVATE)) {
+      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+    }
+
+    for (VariableElement parameter : constructorElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+        }
+      }
+    }
+
+    TypeElement enclosingElement =
+        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
+
+    if (typeModifiers.contains(PRIVATE)) {
+      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+    }
+
+    if (typeModifiers.contains(ABSTRACT)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+    }
+
+    if (!enclosingElement.getTypeParameters().isEmpty()) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
+    }
+
+    if (enclosingElement.getNestingKind().isNested()
+        && !typeModifiers.contains(STATIC)) {
+      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+    }
+
+    // This is computationally expensive, but probably preferable to a giant index
+    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
+        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
+            .filter(new Predicate<ExecutableElement>() {
+              @Override public boolean apply(ExecutableElement input) {
+                return input.getAnnotation(Inject.class) != null;
+              }
+            });
+
+    if (injectConstructors.size() > 1) {
+      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
+    if (scopes.size() > 1) {
+      for (AnnotationMirror scope : scopes) {
+        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
new file mode 100644
index 000000000..a2cc10f30
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A {@link Validator} for {@link Inject} fields.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectFieldValidator implements Validator<VariableElement> {
+  @Override
+  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder =
+        ValidationReport.Builder.about(fieldElement);
+    Set<Modifier> modifiers = fieldElement.getModifiers();
+    if (modifiers.contains(FINAL)) {
+      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+    }
+
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
new file mode 100644
index 000000000..2fc0dbd18
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableSet;
+
+import java.util.Set;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A {@link Validator} for {@link Inject} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectMethodValidator implements Validator<ExecutableElement> {
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(methodElement);
+    Set<Modifier> modifiers = methodElement.getModifiers();
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+    }
+
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+    }
+
+    if (!methodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+    }
+
+    for (VariableElement parameter : methodElement.getParameters()) {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        }
+      }
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 4edbc6c2b..3a6f970ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,35 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static javax.lang.model.SourceVersion.RELEASE_6;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.base.Function;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 
-import java.lang.annotation.Annotation;
 import java.util.Collection;
-import java.util.List;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -53,15 +32,10 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
-import javax.inject.Qualifier;
-import javax.inject.Scope;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -76,6 +50,9 @@
 @SupportedSourceVersion(RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private Messager messager;
+  private InjectConstructorValidator constructorValidator;
+  private InjectFieldValidator fieldValidator;
+  private InjectMethodValidator methodValidator;
   private ProvisionBinding.Factory provisionBindingFactory;
   private InjectConstructorFactoryGenerator factoryWriter;
   private MembersInjectionBinding.Factory membersInjectionBindingFactory;
@@ -85,13 +62,18 @@
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     this.messager = processingEnv.getMessager();
+    this.constructorValidator = new InjectConstructorValidator();
+    this.fieldValidator = new InjectFieldValidator();
+    this.methodValidator = new InjectMethodValidator();
     Filer filer = processingEnv.getFiler();
     Elements elements = processingEnv.getElementUtils();
     Types types = processingEnv.getTypeUtils();
+    Key.Factory keyFactory = new Key.Factory(types, elements);
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, types);
     ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
-    this.provisionBindingFactory = new ProvisionBinding.Factory(dependencyRequestFactory);
+    this.provisionBindingFactory =
+        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
     this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
     this.membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(dependencyRequestFactory);
@@ -115,7 +97,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             @Override
             public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
               ValidationReport<ExecutableElement> report =
-                  validateInjectConstructor(constructorElement);
+                  constructorValidator.validate(constructorElement);
 
               report.printMessagesTo(messager);
 
@@ -128,7 +110,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructorElement, V
 
             @Override
             public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              ValidationReport<VariableElement> report = validateInjectField(fieldElement);
+              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
               report.printMessagesTo(messager);
 
@@ -142,7 +124,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
 
             @Override
             public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report = validateInjectMethod(methodElement);
+              ValidationReport<ExecutableElement> report = methodValidator.validate(methodElement);
 
               report.printMessagesTo(messager);
 
@@ -182,136 +164,4 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
 
     return false;
   }
-
-  private ValidationReport<ExecutableElement> validateInjectConstructor(
-      ExecutableElement constructorElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(constructorElement);
-    if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
-    }
-
-    for (VariableElement parameter : constructorElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
-        }
-      }
-    }
-
-    TypeElement enclosingElement =
-        ElementUtil.asTypeElement(constructorElement.getEnclosingElement());
-    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
-
-    if (typeModifiers.contains(PRIVATE)) {
-      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
-    }
-
-    if (typeModifiers.contains(ABSTRACT)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
-    }
-
-    if (!enclosingElement.getTypeParameters().isEmpty()) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
-    }
-
-    if (enclosingElement.getNestingKind().isNested()
-        && !typeModifiers.contains(STATIC)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
-    }
-
-    // This is computationally expensive, but probably preferable to a giant index
-    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
-        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
-            .filter(new Predicate<ExecutableElement>() {
-              @Override public boolean apply(ExecutableElement input) {
-                return input.getAnnotation(Inject.class) != null;
-              }
-            });
-
-    if (injectConstructors.size() > 1) {
-      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
-    }
-
-    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
-    if (scopes.size() > 1) {
-      for (AnnotationMirror scope : scopes) {
-        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ValidationReport<ExecutableElement> validateInjectMethod(
-      ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(methodElement);
-    Set<Modifier> modifiers = methodElement.getModifiers();
-    if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
-    }
-
-    if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
-    }
-
-    for (VariableElement parameter : methodElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
-        }
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ValidationReport<VariableElement> validateInjectField(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder =
-        ValidationReport.Builder.about(fieldElement);
-    Set<Modifier> modifiers = fieldElement.getModifiers();
-    if (modifiers.contains(FINAL)) {
-      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
-    }
-
-    if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
-    }
-
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
-      }
-    }
-
-    return builder.build();
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
-    return getAnnotatedAnnotations(element, Qualifier.class);
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
-    return getAnnotatedAnnotations(element, Scope.class);
-  }
-
-  private ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
-          }
-        })
-        .toSet();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index e0184bf7b..0237f7142 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -16,14 +16,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
 
 import java.lang.annotation.Annotation;
-import java.util.Iterator;
 import java.util.List;
 
 import javax.inject.Qualifier;
@@ -40,33 +39,50 @@
 final class InjectionAnnotations {
   static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
     checkNotNull(e);
-    return getAnnotatedAnnotation(e, Scope.class);
+    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(e);
+    switch (scopeAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(scopeAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Scope annotation");
+    }
   }
 
   static Optional<AnnotationMirror> getQualifier(Element e) {
     checkNotNull(e);
-    return getAnnotatedAnnotation(e, Qualifier.class);
+    ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
+    switch (qualifierAnnotations.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
+      default:
+        throw new IllegalArgumentException(
+            e + " was annotated with more than one @Scope annotation");
+    }
+  }
+
+  static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
+    return getAnnotatedAnnotations(element, Qualifier.class);
   }
 
-  private static Optional<AnnotationMirror> getAnnotatedAnnotation(Element e,
+  static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
+    return getAnnotatedAnnotations(element, Scope.class);
+  }
+
+  private static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
       final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
-    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
+    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
+    return FluentIterable.from(annotations)
         .filter(new Predicate<AnnotationMirror>() {
-          @Override
-          public boolean apply(AnnotationMirror input) {
+          @Override public boolean apply(AnnotationMirror input) {
             return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
           }
         })
-        .iterator();
-    if (qualifiers.hasNext()) {
-      AnnotationMirror qualifier = qualifiers.next();
-      checkState(!qualifiers.hasNext(),
-          "More than one " + annotationType.getName() + " was present.");
-      return Optional.of(qualifier);
-    } else {
-      return Optional.absent();
-    }
+        .toSet();
   }
 
   private InjectionAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 740ca59f3..2e2ff9aa1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,6 +20,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -28,10 +29,17 @@
 
 import dagger.Provides;
 
+import java.util.Set;
+
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
@@ -62,8 +70,6 @@ public String toString() {
         .toString();
   }
 
-  // TODO(gak): normalize boxed types
-
   static Key create(TypeMirror type) {
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
@@ -72,27 +78,64 @@ static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
   }
 
-  // TODO(gak): decide whether to address set bindings here or someplace else
-  static Key forProvidesMethod(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(METHOD));
-    checkArgument(e.getAnnotation(Provides.class) != null);
-    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
-  }
+  static final class Factory {
+    private final Types types;
+    private final Elements elements;
 
-  static Key forComponentMethod(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(METHOD));
-    checkArgument(e.getParameters().isEmpty());
-    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
-  }
+    Factory(Types types, Elements elements) {
+      this.types = checkNotNull(types);
+      this.elements = checkNotNull(elements);
+    }
 
-  static Key forInjectConstructor(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(CONSTRUCTOR));
-    checkArgument(!getQualifier(e).isPresent());
-    // Must use the enclosing element.  The return type is void for constructors(?!)
-    TypeMirror type = e.getEnclosingElement().asType();
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+    private TypeMirror normalize(TypeMirror type) {
+      TypeKind kind = type.getKind();
+      return kind.isPrimitive() ? types.getPrimitiveType(kind) : type;
+    }
+
+    private TypeElement getSetElement() {
+      return elements.getTypeElement(Set.class.getCanonicalName());
+    }
+
+    Key forProvidesMethod(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      Provides providesAnnotation = e.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
+      TypeMirror returnType = normalize(e.getReturnType());
+      Optional<AnnotationMirror> qualifier = getQualifier(e);
+      switch (providesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(setType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(returnType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    Key forComponentMethod(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      checkArgument(e.getParameters().isEmpty());
+      return new AutoValue_Key(getQualifier(e),
+          Mirrors.equivalence().wrap(normalize(e.getReturnType())));
+    }
+
+    Key forInjectConstructor(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(CONSTRUCTOR));
+      checkArgument(!getQualifier(e).isPresent());
+      // Must use the enclosing element.  The return type is void for constructors(?!)
+      TypeMirror type = e.getEnclosingElement().asType();
+      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+          Mirrors.equivalence().wrap(type));
+    }
   }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
new file mode 100644
index 000000000..ce03114cb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.Iterables;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A {@link Validator} for {@link Provides} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProvidesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(providesMethodElement);
+
+    Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
+    checkArgument(providesAnnotation != null);
+
+    Element enclosingElement = providesMethodElement.getEnclosingElement();
+    if (enclosingElement.getAnnotation(Module.class) == null) {
+      builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
+          providesMethodElement);
+    }
+
+    if (!providesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
+    }
+
+    Set<Modifier> modifiers = providesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(PROVIDES_METHOD_PRIVATE, providesMethodElement);
+    }
+    if (modifiers.contains(STATIC)) {
+      // TODO(gak): why not?
+      builder.addItem(PROVIDES_METHOD_STATIC, providesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(PROVIDES_METHOD_ABSTRACT, providesMethodElement);
+    }
+
+    TypeMirror returnType = providesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
+    }
+
+    switch (providesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateKeyType(builder, returnType);
+        break;
+      case SET_VALUES:
+        if (!returnTypeKind.equals(DECLARED)) {
+          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+        } else {
+          DeclaredType declaredReturnType = (DeclaredType) returnType;
+          // TODO(gak): should we allow "covariant return" for set values?
+          if (!declaredReturnType.asElement().equals(getSetElement())) {
+            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
+            builder.addItem(PROVIDES_METHOD_SET_VALUES_RAW_SET, providesMethodElement);
+          } else {
+            validateKeyType(builder,
+                Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index ba2760043..329fcbd79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.Provides.Type.UNIQUE;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
@@ -54,10 +55,18 @@
   /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
   abstract boolean requiresMemberInjection();
 
+  /**
+   * Returns {@code true} if this binding contributes to a single logical binding. I.e. multiple
+   * bindings are allowed for the same {@link Key}.
+   */
+  abstract boolean contributingBinding();
+
   static final class Factory {
+    private final Key.Factory keyFactory;
     private final DependencyRequest.Factory keyRequestFactory;
 
-    Factory(DependencyRequest.Factory keyRequestFactory) {
+    Factory(Key.Factory keyFactory, DependencyRequest.Factory keyRequestFactory) {
+      this.keyFactory = keyFactory;
       this.keyRequestFactory = keyRequestFactory;
     }
 
@@ -65,14 +74,15 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(constructorElement.getAnnotation(Inject.class) != null);
-      Key key = Key.forInjectConstructor(constructorElement);
+      Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
       return new AutoValue_ProvisionBinding(constructorElement,
           keyRequestFactory.forVariables(constructorElement.getParameters()),
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           requiresMemeberInjection(
-              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())));
+              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())),
+          false);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -90,13 +100,15 @@ private static boolean requiresMemeberInjection(TypeElement type) {
 
     ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkNotNull(providesMethod);
-      checkArgument(providesMethod.getKind().equals(CONSTRUCTOR));
-      checkArgument(providesMethod.getAnnotation(Provides.class) != null);
+      checkArgument(providesMethod.getKind().equals(METHOD));
+      Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
       return new AutoValue_ProvisionBinding(providesMethod,
           keyRequestFactory.forVariables(providesMethod.getParameters()),
-          Key.forProvidesMethod(providesMethod),
+          keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false);
+          false,
+          !providesAnnotation.type().equals(UNIQUE));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index a337fc83c..7f0d5e795 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -77,6 +77,10 @@ private Builder(T subject) {
       this.subject = subject;
     }
 
+    T getSubject() {
+      return subject;
+    }
+
     Builder<T> addItem(String message, Element element) {
       items.add(new AutoValue_ValidationReport_Item(message, element,
           Optional.<AnnotationMirror>absent()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
new file mode 100644
index 000000000..615f863c0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validator.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Validates a given subject and produces a {@link ValidationReport} containing the result.
+ *
+ * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
+ */
+interface Validator<T> {
+  ValidationReport<T> validate(T subject);
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 040b6bf32..3b1d41ae6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static org.truth0.Truth.ASSERT;
 
 import com.google.common.collect.Iterables;
@@ -23,18 +25,23 @@
 import dagger.Module;
 import dagger.Provides;
 
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import java.util.Set;
 
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 /**
  * Tests {@link Key}.
@@ -43,12 +50,19 @@
 public class KeyTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
+  private Key.Factory keyFactory;
+
+  @Before public void setUp() {
+    this.keyFactory = new Key.Factory(compilationRule.getTypes(), compilationRule.getElements());
+  }
+
   @Test public void forInjectConstructor() {
     TypeElement typeElement =
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    ASSERT.that(Key.forInjectConstructor(constructor)).isEqualTo(Key.create(typeElement.asType()));
+    ASSERT.that(keyFactory.forInjectConstructor(constructor))
+        .isEqualTo(Key.create(typeElement.asType()));
   }
 
   static final class InjectedClass {
@@ -63,7 +77,7 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    ASSERT.that(Key.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
+    ASSERT.that(keyFactory.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
   }
 
   @Module(library = true)
@@ -82,7 +96,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = Key.forProvidesMethod(providesMethod);
+    Key key = keyFactory.forProvidesMethod(providesMethod);
     ASSERT.that(Mirrors.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(Mirrors.equivalence().wrap(qualifierElement.asType()));
     ASSERT.that(key.wrappedType()).isEqualTo(Mirrors.equivalence().wrap(stringType));
@@ -97,4 +111,30 @@
 
   @Qualifier
   @interface TestQualifier {}
+
+  @Test public void forProvidesMethod_sets() {
+    Elements elements = compilationRule.getElements();
+    Types types = compilationRule.getTypes();
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement providesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
+          .isEqualTo(Key.create(setOfStringsType));
+    }
+  }
+
+  @Module(library = true)
+  static final class SetProvidesMethodsModule {
+    @Provides(type = SET) String provideString() {
+      return null;
+    }
+
+    @Provides(type = SET_VALUES) Set<String> provideStrings() {
+      return null;
+    }
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
new file mode 100644
index 000000000..fda6afd03
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProvidesMethodValidatorTest.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.tools.JavaFileObject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ProvidesMethodValidatorTest {
+  @Test public void validate_notInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
+  }
+
+  @Test public void validate_abstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "abstract class TestModule {",
+        "  @Provides abstract String provideString();",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
+  }
+
+  @Test public void validate_private() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides private String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
+  }
+
+  @Test public void validate_static() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides static String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_STATIC);
+  }
+
+  @Test public void validate_void() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides void provideNothing() {}",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
+  }
+
+  @Test public void validate_typeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides <T> String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
+  }
+
+  @Test public void validate_setValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void validate_setValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
+  }
+
+  @Test public void validate_setValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(validationProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  private Processor validationProcessor() {
+    return new AbstractProcessor() {
+      ProvidesMethodValidator validator;
+
+      @Override
+      public synchronized void init(ProcessingEnvironment processingEnv) {
+        super.init(processingEnv);
+        this.validator = new ProvidesMethodValidator(processingEnv.getElementUtils());
+      }
+
+      @Override public Set<String> getSupportedAnnotationTypes() {
+        return ImmutableSet.of(Provides.class.getName());
+      }
+
+      @Override
+      public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        for (ExecutableElement element
+            : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(Provides.class))) {
+          validator.validate(element).printMessagesTo(processingEnv.getMessager());
+        }
+        return false;
+      }
+    };
+  }
+}
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
new file mode 100644
index 000000000..fc04dd606
--- /dev/null
+++ b/core/src/main/java/dagger/Component.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @Component} prepended with
+ * {@code DaggerComponent_}.  For example, {@code @Component interface MyComponent {...}} will
+ * produce an implementation named {@code DaggerComponent_MyComponent}.
+ *
+ * <h2>Component methods
+ *
+ * <p>Every type annotated with {@code @Component} must contain at least one abstract component
+ * method. Component methods must either represent {@linkplain Provider provision} or
+ * {@linkplain MembersInjector member injection}.
+ *
+ * Provision methods have no arguments and return an {@link Inject injected} or
+ * {@link Provides provided} type.  Each may have a {@link Qualifier} annotation as well. The
+ * following are all valid provision method declarations: <pre>   {@code
+ *   SomeType getSomeType();
+ *   Set<SomeType> getSomeTypes();
+ *   @PortNumber int getPortNumber();
+ *   }</pre>
+ *
+ * Member injection methods take a single parameter and optionally return that same type. The
+ * following are all valid member injection method declarations: <pre>   {@code
+ *   void injectSomeType(SomeType someType);
+ *   SomeType injectAndReturnSomeType(SomeType someType);
+ *   }</pre>
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): add missing spec for @Scope
+// TODO(gak): add missing spec for component dependencies
+public @interface Component {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * component implementation.
+   */
+  Class<?>[] modules() default {};
+}
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index a1736d2b8..1e86b1b82 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -24,6 +24,7 @@
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.Modules;
+import dagger.internal.Modules.ModuleWithAdapter;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
@@ -171,9 +172,13 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
           (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
       BindingsGroup overrideBindings = new OverridesBindings();
 
-      Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
-      for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
-        ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
+      ArrayList<ModuleWithAdapter> loadedModules = Modules.loadModules(plugin, modules);
+      int loadedModulesCount = loadedModules.size();
+      for (int moduleIndex = 0; moduleIndex < loadedModulesCount; moduleIndex++) {
+        ModuleWithAdapter loadedModule = loadedModules.get(moduleIndex);
+        @SuppressWarnings("unchecked")
+        ModuleAdapter<Object> moduleAdapter =
+            (ModuleAdapter<Object>) loadedModule.getModuleAdapter();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
         }
@@ -182,7 +187,7 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
         }
         try {
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-          moduleAdapter.getBindings(addTo, loadedModule.getValue());
+          moduleAdapter.getBindings(addTo, loadedModule.getModule());
         } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException(
               moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index d7990025f..edcb27b64 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -25,7 +25,7 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The object graph will
+ * method's return type is bound to its returned value. The object graph will
  * pass dependencies to the method as parameters.
  *
  * @author Bob Lee
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index 8b269f57f..4f8d3cf7d 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -16,9 +16,9 @@
  */
 package dagger.internal;
 
-
-import java.util.LinkedHashMap;
-import java.util.Map;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
 
 /**
  * Static helper for organizing modules.
@@ -31,38 +31,57 @@ private Modules() { }
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<ModuleAdapter<?>, Object> loadModules(Loader loader,
+  public static ArrayList<ModuleWithAdapter> loadModules(Loader loader,
       Object[] seedModulesOrClasses) {
-    Map<ModuleAdapter<?>, Object> seedAdapters =
-        new LinkedHashMap<ModuleAdapter<?>, Object>(seedModulesOrClasses.length);
-    for (int i = 0; i < seedModulesOrClasses.length; i++) {
-      if (seedModulesOrClasses[i] instanceof Class<?>) {
-        ModuleAdapter<?> adapter = loader.getModuleAdapter((Class<?>) seedModulesOrClasses[i]);
-        seedAdapters.put(adapter, adapter.newModule());
+    int seedModuleCount = seedModulesOrClasses.length;
+    ArrayList<ModuleWithAdapter> result = new ArrayList<ModuleWithAdapter>(seedModuleCount);
+    HashSet<Class<?>> visitedClasses = new HashSet<Class<?>>(seedModuleCount);
+    // Add all seed classes to visited classes right away, so that we won't instantiate modules for
+    // them in collectIncludedModulesRecursively
+    // Iterate over seedModulesOrClasses in reverse, so that if multiple instances/classes of the
+    // same module are provided, the later one is used (this matches previous behavior which some
+    // code came to depend on.)
+    for (int i = seedModuleCount-1; i >= 0; i--) {
+      Object moduleOrClass = seedModulesOrClasses[i];
+      if (moduleOrClass instanceof Class<?>) {
+        if (visitedClasses.add((Class<?>) moduleOrClass)) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter((Class<?>) moduleOrClass);
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleAdapter.newModule()));
+        }
       } else {
-        ModuleAdapter<?> adapter = loader.getModuleAdapter(seedModulesOrClasses[i].getClass());
-        seedAdapters.put(adapter, seedModulesOrClasses[i]);
+        if (visitedClasses.add(moduleOrClass.getClass())) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter(moduleOrClass.getClass());
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleOrClass));
+        }
       }
     }
+    int dedupedSeedModuleCount = result.size();
+    for (int i = 0; i < dedupedSeedModuleCount; i++) {
+      ModuleAdapter<?> seedAdapter = result.get(i).getModuleAdapter();
+      collectIncludedModulesRecursively(loader, seedAdapter, result, visitedClasses);
+    }
+    return result;
+  }
 
-    // Add the adapters that we have module instances for. This way we won't
-    // construct module objects when we have a user-supplied instance.
-    Map<ModuleAdapter<?>, Object> result =
-        new LinkedHashMap<ModuleAdapter<?>, Object>(seedAdapters);
+  /**
+   * Wrapper around a module adapter and an instance of the corresponding module.
+   */
+  public static class ModuleWithAdapter {
+    private final ModuleAdapter<?> moduleAdapter;
+    private final Object module;
 
-    // Next collect included modules
-    Map<Class<?>, ModuleAdapter<?>> transitiveInclusions =
-        new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-    for (ModuleAdapter<?> adapter : seedAdapters.keySet()) {
-      collectIncludedModulesRecursively(loader, adapter, transitiveInclusions);
+    ModuleWithAdapter(ModuleAdapter<?> moduleAdapter, Object module) {
+      this.moduleAdapter = moduleAdapter;
+      this.module = module;
     }
-    // and create them if necessary
-    for (ModuleAdapter<?> dependency : transitiveInclusions.values()) {
-      if (!result.containsKey(dependency)) {
-        result.put(dependency, dependency.newModule());
-      }
+
+    public ModuleAdapter<?> getModuleAdapter() {
+      return moduleAdapter;
+    }
+
+    public Object getModule() {
+      return module;
     }
-    return result;
   }
 
   /**
@@ -70,12 +89,13 @@ private Modules() { }
    * adapter}, and their includes recursively.
    */
   private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
-      Map<Class<?>, ModuleAdapter<?>> result) {
+      List<ModuleWithAdapter> result, HashSet<Class<?>> visitedClasses) {
     for (Class<?> include : adapter.includes) {
-      if (!result.containsKey(include)) {
+      if (!visitedClasses.contains(include)) {
         ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
-        result.put(include, includedModuleAdapter);
-        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
+        result.add(new ModuleWithAdapter(includedModuleAdapter, includedModuleAdapter.newModule()));
+        visitedClasses.add(include);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result, visitedClasses);
       }
     }
   }
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/AndroidManifest.xml
index e80464f4a..234406dfa 100644
--- a/examples/android-activity-graphs/AndroidManifest.xml
+++ b/examples/android-activity-graphs/AndroidManifest.xml
@@ -8,10 +8,10 @@
   <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
 
   <application
-      android:label="@string/app_name"
+      android:label="app_name"
       android:name=".DemoApplication">
     <activity
-        android:label="@string/app_name"
+        android:label="app_name"
         android:name=".ui.HomeActivity">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/AndroidManifest.xml
index cdf2399b9..53c83bfd3 100644
--- a/examples/android-simple/AndroidManifest.xml
+++ b/examples/android-simple/AndroidManifest.xml
@@ -8,10 +8,10 @@
   <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
 
   <application
-      android:label="@string/app_name"
+      android:label="app_name"
       android:name=".DemoApplication">
     <activity
-        android:label="@string/app_name"
+        android:label="app_name"
         android:name=".ui.HomeActivity">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
diff --git a/pom.xml b/pom.xml
index 9873ee301..c08015be8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -172,7 +172,7 @@
         <artifactId>maven-checkstyle-plugin</artifactId>
         <version>2.10</version>
         <configuration>
-          <failsOnError>true</failsOnError>
+          <failsOnError>false</failsOnError>
           <consoleOutput>true</consoleOutput>
           <configLocation>checkstyle.xml</configLocation>
         </configuration>
