diff --git a/BUILD b/BUILD
index 8becb3e7d..02e575aa6 100644
--- a/BUILD
+++ b/BUILD
@@ -65,7 +65,6 @@ jarjar_library(
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
-        "//java/dagger/internal/codegen/serialization",
         "//java/dagger/model:internal-proxies",
         "//java/dagger/errorprone",
         "@com_google_auto_auto_common//jar",
diff --git a/java/dagger/internal/ConfigureInitializationParameters.java b/java/dagger/internal/ConfigureInitializationParameters.java
deleted file mode 100644
index 1ca0fbb76..000000000
--- a/java/dagger/internal/ConfigureInitializationParameters.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import java.lang.annotation.Target;
-
-/**
- * Annotates a {@code configureInitialization()} method with {@code ComponentRequirement}s that it
- * accepts as parameters.
- */
-@Target(METHOD)
-public @interface ConfigureInitializationParameters {
-  /**
-   * The list of parameters.
-   *
-   * Each value is a {@link dagger.internal.codegen.serialization.ComponentRequirementProto}
-   * serialized in Base64.
-   */
-  String[] value() default {};
-}
diff --git a/java/dagger/internal/GenerationOptions.java b/java/dagger/internal/GenerationOptions.java
deleted file mode 100644
index 996cd1d89..000000000
--- a/java/dagger/internal/GenerationOptions.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Target;
-
-/**
- * Metadata annotation for base subcomponent implementations in ahead-of-time compilations. This
- * propagates any compiler options related to code generation so that later compilations can
- * recreate the model of the generated code of superclass implementations.
- */
-@Target(ElementType.TYPE)
-public @interface GenerationOptions {
-  boolean fastInit();
-}
diff --git a/java/dagger/internal/MissingBindingFactory.java b/java/dagger/internal/MissingBindingFactory.java
deleted file mode 100644
index 993d15047..000000000
--- a/java/dagger/internal/MissingBindingFactory.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-/**
- * A {@link Factory} that always throws on calls to {@link Factory#get()}. This is necessary in
- * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
- * Provider<T>} to a framework instance initialization that is pruned and no longer in the binding
- * graph, but was present in a superclass implementation. This class fulfills that requirement but
- * is still practically unusable.
- */
-public final class MissingBindingFactory<T> implements Factory<T> {
-  private static final MissingBindingFactory<Object> INSTANCE = new MissingBindingFactory<>();
-
-  private MissingBindingFactory() {}
-
-  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Factory<T> create() {
-    return (Factory) INSTANCE;
-  }
-
-  @Override
-  public T get() {
-    throw new AssertionError(
-        "This binding is not part of the final binding graph. The key was requested by a binding "
-            + "that was believed to possibly be part of the graph, but is no longer requested. "
-            + "If this exception is thrown, it is the result of a Dagger bug.");
-  }
-}
diff --git a/java/dagger/internal/ModifiableBinding.java b/java/dagger/internal/ModifiableBinding.java
deleted file mode 100644
index 1e658e42c..000000000
--- a/java/dagger/internal/ModifiableBinding.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-import java.lang.annotation.Target;
-
-/** Annotates methods that implement bindings that may be modified by subclass implementations. */
-@Target(METHOD)
-public @interface ModifiableBinding {
-  /** {@code ModifiableBindingType} of the binding. */
-  // TODO(ronshapiro): should this be a shared enum with dagger.internal.codegen?
-  String modifiableBindingType();
-
-  /** A {@link dagger.internal.codegen.serialization.BindingRequestProto} serialized in Base64. */
-  String bindingRequest();
-
-  /**
-   * For a multibinding, the keys of all contributions it depends on in this implementation.
-   */
-  String[] multibindingContributions() default {};
-}
diff --git a/java/dagger/internal/ModifiableModule.java b/java/dagger/internal/ModifiableModule.java
deleted file mode 100644
index 983321e85..000000000
--- a/java/dagger/internal/ModifiableModule.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-/**
- * Annotates methods that return {@linkplain dagger.Module modules} that may be modified by subclass
- * implementations.
- */
-public @interface ModifiableModule {
-  /** The serialized {@code ComponentRequirement} of this method's module. */
-  String value();
-}
diff --git a/java/dagger/internal/codegen/AnnotationProtoConverter.java b/java/dagger/internal/codegen/AnnotationProtoConverter.java
deleted file mode 100644
index e1350fe19..000000000
--- a/java/dagger/internal/codegen/AnnotationProtoConverter.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Maps.transformValues;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static javax.lang.model.util.ElementFilter.fieldsIn;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
-import dagger.internal.codegen.serialization.AnnotationProto;
-import dagger.internal.codegen.serialization.AnnotationValueProto;
-import java.util.List;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor8;
-
-/** Converts {@link AnnotationMirror}s to {@link AnnotationProto}s and vice-versa. */
-final class AnnotationProtoConverter {
-  private final TypeProtoConverter typeProtoConverter;
-
-  @Inject
-  AnnotationProtoConverter(TypeProtoConverter typeProtoConverter) {
-    this.typeProtoConverter = typeProtoConverter;
-  }
-
-  /** Translates an {@link AnnotationMirror} to a proto representation. */
-  static AnnotationProto toProto(AnnotationMirror annotationMirror) {
-    AnnotationProto.Builder builder = AnnotationProto.newBuilder();
-    builder.setAnnotationType(TypeProtoConverter.toProto(annotationMirror.getAnnotationType()));
-    getAnnotationValuesWithDefaults(annotationMirror)
-        .forEach(
-            (attribute, value) ->
-                builder.putValues(
-                    attribute.getSimpleName().toString(), annotationValueProto(value)));
-    return builder.build();
-  }
-
-  /** Creates an {@link AnnotationMirror} from its proto representation. */
-  AnnotationMirror fromProto(AnnotationProto annotation) {
-    return SimpleAnnotationMirror.of(
-        MoreTypes.asTypeElement(typeProtoConverter.fromProto(annotation.getAnnotationType())),
-        transformValues(annotation.getValuesMap(), AnnotationValueFromProto::new));
-  }
-
-  private static final AnnotationValueVisitor<
-          AnnotationValueProto.Builder, AnnotationValueProto.Builder>
-      ANNOTATION_VALUE_TO_PROTO =
-          new SimpleAnnotationValueVisitor8<
-              AnnotationValueProto.Builder, AnnotationValueProto.Builder>() {
-            @Override
-            public AnnotationValueProto.Builder visitAnnotation(
-                AnnotationMirror nestedAnnotation, AnnotationValueProto.Builder builder) {
-              return builder
-                  .setNestedAnnotation(toProto(nestedAnnotation))
-                  .setKind(AnnotationValueProto.Kind.ANNOTATION);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitBoolean(
-                boolean b, AnnotationValueProto.Builder builder) {
-              return builder.setBooleanValue(b).setKind(AnnotationValueProto.Kind.BOOLEAN);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitChar(
-                char c, AnnotationValueProto.Builder builder) {
-              return builder
-                  .setStringValue(String.valueOf(c))
-                  .setKind(AnnotationValueProto.Kind.CHAR);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitByte(
-                byte b, AnnotationValueProto.Builder builder) {
-              return builder.setIntValue(b).setKind(AnnotationValueProto.Kind.BYTE);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitShort(
-                short s, AnnotationValueProto.Builder builder) {
-              return builder.setIntValue(s).setKind(AnnotationValueProto.Kind.SHORT);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitInt(
-                int i, AnnotationValueProto.Builder builder) {
-              return builder.setIntValue(i).setKind(AnnotationValueProto.Kind.INT);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitFloat(
-                float f, AnnotationValueProto.Builder builder) {
-              return builder.setFloatValue(f).setKind(AnnotationValueProto.Kind.FLOAT);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitLong(
-                long l, AnnotationValueProto.Builder builder) {
-              return builder.setLongValue(l).setKind(AnnotationValueProto.Kind.LONG);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitDouble(
-                double d, AnnotationValueProto.Builder builder) {
-              return builder.setDoubleValue(d).setKind(AnnotationValueProto.Kind.DOUBLE);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitString(
-                String s, AnnotationValueProto.Builder builder) {
-              return builder.setStringValue(s).setKind(AnnotationValueProto.Kind.STRING);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitType(
-                TypeMirror t, AnnotationValueProto.Builder builder) {
-              return builder
-                  .setClassLiteral(TypeProtoConverter.toProto(t))
-                  .setKind(AnnotationValueProto.Kind.CLASS_LITERAL);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitEnumConstant(
-                VariableElement c, AnnotationValueProto.Builder builder) {
-              return builder
-                  .setEnumType(TypeProtoConverter.toProto(c.asType()))
-                  .setEnumName(c.getSimpleName().toString())
-                  .setKind(AnnotationValueProto.Kind.ENUM);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitArray(
-                List<? extends AnnotationValue> values, AnnotationValueProto.Builder builder) {
-              values.forEach(value -> builder.addArrayValues(annotationValueProto(value)));
-              return builder.setKind(AnnotationValueProto.Kind.ARRAY);
-            }
-
-            @Override
-            public AnnotationValueProto.Builder visitUnknown(
-                AnnotationValue av, AnnotationValueProto.Builder builder) {
-              throw new UnsupportedOperationException(av.toString());
-            }
-          };
-
-  /** Translates an {@link AnnotationValue} to a proto representation. */
-  private static AnnotationValueProto annotationValueProto(AnnotationValue annotationValue) {
-    return annotationValue
-        .accept(ANNOTATION_VALUE_TO_PROTO, AnnotationValueProto.newBuilder())
-        .build();
-  }
-
-  private class AnnotationValueFromProto implements AnnotationValue {
-    private final AnnotationValueProto proto;
-
-    AnnotationValueFromProto(AnnotationValueProto proto) {
-      this.proto = proto;
-    }
-
-    @Override
-    public Object getValue() {
-      switch (proto.getKind()) {
-        case BOOLEAN:
-          return proto.getBooleanValue();
-        case BYTE:
-          return (byte) proto.getIntValue();
-        case SHORT:
-          return (short) proto.getIntValue();
-        case CHAR:
-          return getCharValue();
-        case INT:
-          return proto.getIntValue();
-        case FLOAT:
-          return proto.getFloatValue();
-        case LONG:
-          return proto.getLongValue();
-        case DOUBLE:
-          return proto.getDoubleValue();
-        case STRING:
-          return proto.getStringValue();
-        case CLASS_LITERAL:
-          return typeProtoConverter.fromProto(proto.getClassLiteral());
-        case ENUM:
-          return getEnumConstant();
-        case ANNOTATION:
-          return fromProto(proto.getNestedAnnotation());
-        case ARRAY:
-          return getArrayValues();
-        case UNKNOWN:
-        case UNRECOGNIZED:
-          // fall through
-      }
-      throw new AssertionError(proto);
-    }
-
-    @Override
-    public <R, P> R accept(AnnotationValueVisitor<R, P> visitor, P passedValue) {
-      switch (proto.getKind()) {
-        case BOOLEAN:
-          return visitor.visitBoolean(proto.getBooleanValue(), passedValue);
-        case BYTE:
-          return visitor.visitByte((byte) proto.getIntValue(), passedValue);
-        case SHORT:
-          return visitor.visitShort((short) proto.getIntValue(), passedValue);
-        case CHAR:
-          return visitor.visitChar(getCharValue(), passedValue);
-        case INT:
-          return visitor.visitInt(proto.getIntValue(), passedValue);
-        case FLOAT:
-          return visitor.visitFloat(proto.getFloatValue(), passedValue);
-        case LONG:
-          return visitor.visitLong(proto.getLongValue(), passedValue);
-        case DOUBLE:
-          return visitor.visitDouble(proto.getDoubleValue(), passedValue);
-        case STRING:
-          return visitor.visitString((String) getValue(), passedValue);
-        case CLASS_LITERAL:
-          return visitor.visitType((TypeMirror) getValue(), passedValue);
-        case ENUM:
-          return visitor.visitEnumConstant((VariableElement) getValue(), passedValue);
-        case ANNOTATION:
-          return visitor.visitAnnotation((AnnotationMirror) getValue(), passedValue);
-        case ARRAY:
-          return visitor.visitArray(getArrayValues(), passedValue);
-        case UNKNOWN:
-        case UNRECOGNIZED:
-          // fall through
-      }
-      throw new AssertionError(proto);
-    }
-
-    private char getCharValue() {
-      checkState(proto.getKind().equals(AnnotationValueProto.Kind.CHAR));
-      return proto.getStringValue().charAt(0);
-    }
-
-    private VariableElement getEnumConstant() {
-      checkState(proto.getKind().equals(AnnotationValueProto.Kind.ENUM));
-      TypeMirror enumType = typeProtoConverter.fromProto(proto.getEnumType());
-      return fieldsIn(MoreTypes.asTypeElement(enumType).getEnclosedElements()).stream()
-          .filter(value -> value.getSimpleName().contentEquals(proto.getEnumName()))
-          .findFirst()
-          .get();
-    }
-
-    private ImmutableList<AnnotationValue> getArrayValues() {
-      checkState(proto.getKind().equals(AnnotationValueProto.Kind.ARRAY));
-      return proto.getArrayValuesList().stream()
-          .map(AnnotationValueFromProto::new)
-          .collect(toImmutableList());
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 824a72ef6..2a02a3dc4 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -48,7 +48,6 @@ CODEGEN_SHARED_DEPS = [
     "@google_bazel_common//third_party/java/jsr250_annotations",
     "@google_bazel_common//third_party/java/jsr330_inject",
     "//java/dagger:core",
-    "//java/dagger/internal/codegen/serialization",
     "//java/dagger/producers",
     "//java/dagger/model",
     "//java/dagger/spi",
@@ -80,7 +79,6 @@ java_library(
 java_library(
     name = "base",
     srcs = [
-        "AnnotationProtoConverter.java",
         "ClearableCache.java",
         "CompilerOptions.java",
         "ComponentAnnotation.java",
@@ -114,7 +112,6 @@ java_library(
         "SourceFileGenerationException.java",  # Used in :writing and :processor
         "SourceFileGenerator.java",  # Needed by InjectBindingRegistry in :binding and also :writing
         "TypeCheckingProcessingStep.java",
-        "TypeProtoConverter.java",
         "UniqueNameSet.java",
         "Util.java",
         "ValidationType.java",
@@ -276,7 +273,6 @@ java_library(
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementExpression.java",
         "ComponentRequirementExpressions.java",
-        "DeferredModifiableBindingExpression.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
@@ -286,7 +282,6 @@ java_library(
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
-        "GenerationCompilerOptions.java",
         "GwtCompatibility.java",
         "HjarSourceFileGenerator.java",
         "ImmediateFutureBindingExpression.java",
@@ -304,18 +299,11 @@ java_library(
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
-        "MissingBindingExpression.java",
-        "ModifiableAbstractMethodBindingExpression.java",
-        "ModifiableBindingExpressions.java",
-        "ModifiableBindingMethods.java",
-        "ModifiableBindingType.java",
-        "ModifiableConcreteMethodBindingExpression.java",
         "ModuleConstructorProxyGenerator.java",
         "ModuleGenerator.java",
         "ModuleProxies.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
-        "MultibindingExpression.java",
         "MultibindingFactoryCreationExpression.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
@@ -330,7 +318,6 @@ java_library(
         "ProducerFromProviderCreationExpression.java",
         "ProducerNodeInstanceBindingExpression.java",
         "ProviderInstanceBindingExpression.java",
-        "PrunedConcreteMethodBindingExpression.java",
         "SetBindingExpression.java",
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
@@ -365,8 +352,6 @@ java_library(
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "CurrentImplementationSubcomponent.java",
-        "DeserializedComponentImplementationBuilder.java",
-        "GenerationOptionsModule.java",
         "InjectBindingRegistryImpl.java",
         "InjectBindingRegistryModule.java",
         "InjectProcessingStep.java",
@@ -404,7 +389,6 @@ pom_file(
         ":binding_graph_validation",
         ":writing",
         ":validation",
-        "//java/dagger/internal/codegen/serialization",
         "//java/dagger/internal/codegen/javapoet",
     ],
 )
@@ -416,7 +400,6 @@ java_library(
     visibility = ["//visibility:private"],
     deps = [
         ":base",
-        ":binding",
         ":javac",
         ":processor",
         "//java/dagger:core",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 65200f7a5..aabd6c9e5 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -16,15 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
-
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.internal.codegen.javapoet.Expression;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import javax.lang.model.type.TypeMirror;
 
 /** A factory of code expressions used to access a single request for a binding in a component. */
 // TODO(user): Rename this to RequestExpression?
@@ -65,47 +60,4 @@ CodeBlock getComponentMethodImplementation(
         "return $L;",
         getDependencyExpressionForComponentMethod(componentMethod, component).codeBlock());
   }
-
-  /**
-   * Returns an expression for the implementation of a modifiable binding method for the given
-   * component.
-   */
-  CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod,
-      ComponentImplementation component,
-      DaggerTypes types) {
-    Expression dependencyExpression = getDependencyExpression(component.name());
-
-    // It's possible to have a case where a modifiable component method delegates to another
-    // binding method from an enclosing class that is not itself a component method. In that case,
-    // the enclosing class's method may return a publicly accessible type, but the nested class will
-    // have a return type that is defined by the component method. In that case, a downcast is
-    // necessary so that the return statement is valid.
-    //
-    // E.g.:
-    //
-    // public class DaggerAncestor implements Ancestor {
-    //   protected Object packagePrivateModifiable() { ... }
-    //
-    //   protected class LeafImpl extends DaggerLeaf {
-    //     @Override
-    //     public final PackagePrivateModifiable componentMethod() {
-    //       return (PackagePrivateModifiable) DaggerAncestor.this.packagePrivateModifiable();
-    //     }
-    //   }
-    // }
-    //
-    // DaggerAncestor.packagePrivateModifiable returns Object even though the actual instance's type
-    // is PackagePrivateModifiable. So a cast is necessary.
-    //
-    // This isn't necessary for getComponentMethodImplementation() because that's only used for
-    // non-modifiable bindings
-    TypeMirror returnType = modifiableBindingMethod.returnType();
-    if (!types.isAssignable(dependencyExpression.type(), returnType)
-       && isTypeAccessibleFrom(returnType, component.name().packageName())) {
-      dependencyExpression = dependencyExpression.castTo(returnType);
-    }
-
-    return CodeBlock.of("return $L;", dependencyExpression.codeBlock());
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index a2cc7990f..7a998aa86 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -21,7 +21,6 @@
 import static dagger.internal.codegen.DaggerGraphs.unreachableNodes;
 import static dagger.model.BindingKind.SUBCOMPONENT_CREATOR;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.graph.MutableNetwork;
@@ -33,7 +32,6 @@
 import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraphProxies;
-import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
@@ -81,18 +79,11 @@ private ComponentNode rootComponentNode(Network<Node, Edge> network) {
   private final class Traverser extends ComponentTreeTraverser {
     private final MutableNetwork<Node, Edge> network =
         NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();
-    private final boolean isRootSubcomponent;
-    private final boolean isFullBindingGraph;
-
-    private final ComponentPath rootComponentPath;
     private ComponentNode parentComponent;
     private ComponentNode currentComponent;
 
     Traverser(BindingGraph graph) {
       super(graph);
-      rootComponentPath = ComponentPath.create(ImmutableList.of(graph.componentTypeElement()));
-      isRootSubcomponent = graph.componentDescriptor().isSubcomponent();
-      isFullBindingGraph = graph.isFullBindingGraph();
     }
 
     @Override
@@ -220,12 +211,10 @@ private BindingNode bindingNode(
     }
 
     private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
-      // TODO(b/117833324): Revisit whether limiting missing binding nodes to the root component is
-      // necessary to limit the amount of missing binding nodes in the network, or if perhaps *all*
-      // missing binding nodes should be structured this way.
-      return BindingGraphProxies.missingBindingNode(
-          isRootSubcomponent && !isFullBindingGraph ? rootComponentPath : componentPath(),
-          dependencies.key());
+      // TODO(ronshapiro): Revisit whether missing binding nodes should all use the root component
+      // path, and the component(s) that have the missing bindings should be determined by the
+      // predecessors of missing binding nodes.
+      return BindingGraphProxies.missingBindingNode(componentPath(), dependencies.key());
     }
 
     private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index 27067aa27..0f49f005c 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -20,9 +20,6 @@
 
 import com.google.auto.value.AutoValue;
 import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.internal.codegen.serialization.BindingRequestProto;
-import dagger.internal.codegen.serialization.FrameworkTypeWrapper;
-import dagger.internal.codegen.serialization.RequestKindWrapper;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -101,25 +98,4 @@ final String kindName() {
             : frameworkType().get().frameworkClass().getSimpleName();
     return requestKindObject.toString();
   }
-
-  /** Returns {@code true} if this request can be satisfied by a production binding. */
-  final boolean canBeSatisfiedByProductionBinding() {
-    if (requestKind().isPresent()) {
-      return RequestKinds.canBeSatisfiedByProductionBinding(requestKind().get());
-    }
-    return frameworkType().get().equals(FrameworkType.PRODUCER_NODE);
-  }
-
-  /** Creates a proto representation of this binding request. */
-  BindingRequestProto toProto() {
-    BindingRequestProto.Builder builder =
-        BindingRequestProto.newBuilder().setKey(KeyFactory.toProto(key()));
-    if (frameworkType().isPresent()) {
-      builder.setFrameworkType(
-          FrameworkTypeWrapper.FrameworkType.valueOf(frameworkType().get().name()));
-    } else {
-      builder.setRequestKind(RequestKindWrapper.RequestKind.valueOf(requestKind().get().name()));
-    }
-    return builder.build();
-  }
 }
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index bc3cbf8f8..32e1c07b7 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.squareup.javapoet.AnnotationSpec;
-import dagger.internal.GenerationOptions;
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic;
 
@@ -64,23 +62,6 @@ final boolean doCheckForNulls() {
 
   abstract boolean headerCompilation();
 
-  abstract boolean aheadOfTimeSubcomponents();
-
-  /**
-   * Enables a testing configuration where all superclass {@link ComponentImplementation}s are
-   * derived from their serialized forms.
-   */
-  abstract boolean forceUseSerializedComponentImplementations();
-
-  /**
-   * If {@code true}, in {@link #aheadOfTimeSubcomponents()} mode, Dagger will emit metadata
-   * annotations to deserialize aspects of the {@link ComponentImplementation}.
-   *
-   * This should only be disabled in compile-testing tests that want to ignore the annotations when
-   * asserting on generated source.
-   */
-  abstract boolean emitModifiableMetadataAnnotations();
-
   abstract boolean useGradleIncrementalProcessing();
 
   /**
@@ -93,27 +74,4 @@ final boolean doCheckForNulls() {
   abstract Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind();
 
   abstract ValidationType explicitBindingConflictsWithInjectValidationType();
-
-  /**
-   * Creates a new {@link CompilerOptions} from the serialized {@link GenerationOptions} of a base
-   * component implementation.
-   */
-  final CompilerOptions withGenerationOptions(GenerationOptions generationOptions) {
-    return new ForwardingCompilerOptions(this) {
-      @Override
-      public boolean fastInit() {
-        return generationOptions.fastInit();
-      }
-    };
-  }
-
-  /**
-   * Returns a {@link GenerationOptions} annotation that serializes any options for this compilation
-   * that should be reused in future compilations.
-   */
-  final AnnotationSpec toGenerationOptionsAnnotation() {
-    return AnnotationSpec.builder(GenerationOptions.class)
-        .addMember("fastInit", "$L", fastInit())
-        .build();
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index b6b1ecdc2..0b5996384 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -22,17 +22,14 @@
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
-import static dagger.internal.codegen.RequestKinds.isDerivedFromProvider;
 import static dagger.internal.codegen.javapoet.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.javapoet.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.langmodel.Accessibility.isRawTypeAccessible;
-import static dagger.internal.codegen.langmodel.Accessibility.isRawTypePubliclyAccessible;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static dagger.model.BindingKind.MULTIBOUND_SET;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
@@ -74,7 +71,6 @@
   private final CompilerOptions compilerOptions;
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
-  private final ModifiableBindingExpressions modifiableBindingExpressions;
   private final Map<BindingRequest, BindingExpression> expressions = new HashMap<>();
 
   @Inject
@@ -87,7 +83,7 @@
       DaggerTypes types,
       DaggerElements elements,
       SourceVersion sourceVersion,
-      @GenerationCompilerOptions CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions) {
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
@@ -101,19 +97,6 @@
         new MembersInjectionMethods(componentImplementation, this, graph, elements, types);
     this.innerSwitchingProviders =
         new InnerSwitchingProviders(componentImplementation, this, types);
-    this.modifiableBindingExpressions =
-        new ModifiableBindingExpressions(
-            parent.map(cbe -> cbe.modifiableBindingExpressions),
-            this,
-            graph,
-            componentImplementation,
-            compilerOptions,
-            types);
-  }
-
-  /* Returns the {@link ModifiableBindingExpressions} for this component. */
-  ModifiableBindingExpressions modifiableBindingExpressions() {
-    return modifiableBindingExpressions;
   }
 
   /**
@@ -185,21 +168,6 @@ Expression getDependencyArgumentExpression(
     BindingRequest bindingRequest = bindingRequest(dependencyRequest);
     Expression dependencyExpression = getDependencyExpression(bindingRequest, requestingClass);
 
-    if (compilerOptions.aheadOfTimeSubcomponents()) {
-      TypeMirror requestedType =
-          bindingRequest.requestedType(dependencyRequest.key().type(), types);
-      // If dependencyExpression.type() has been erased to it's publicly accessible type in AOT,
-      // we must sometimes cast the expression so that it is usable in the current component. To do
-      // so, we check that without the cast the assignment would fail, that argument to this proxy
-      // method erased the type, and that the raw type of the requested type is actually accessible
-      // in the current class so that the cast is valid.
-      if (!types.isAssignable(dependencyExpression.type(), requestedType)
-          && !isRawTypePubliclyAccessible(requestedType)
-          && isRawTypeAccessible(requestedType, requestingClass.packageName())) {
-        return dependencyExpression.castTo(types.erasure(requestedType));
-      }
-    }
-
     if (dependencyRequest.kind().equals(RequestKind.INSTANCE)
         && !isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
         && isRawTypeAccessible(dependencyType, requestingClass.packageName())) {
@@ -224,13 +192,7 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
     CodeBlock methodBody =
         getBindingExpression(request)
             .getComponentMethodImplementation(componentMethod, componentImplementation);
-    if (!componentImplementation.superclassImplementation().isPresent()
-        && !modifiableBindingExpressions
-            .getModifiableBindingType(request)
-            .hasBaseClassImplementation()
-        && !componentImplementation.getModifiableBindingMethod(request).isPresent()) {
-      return method.addModifiers(ABSTRACT).build();
-    }
+
     return method.addCode(methodBody).build();
   }
 
@@ -239,30 +201,14 @@ BindingExpression getBindingExpression(BindingRequest request) {
     if (expressions.containsKey(request)) {
       return expressions.get(request);
     }
-    Optional<BindingExpression> expression =
-        modifiableBindingExpressions.maybeCreateModifiableBindingExpression(request);
-    if (!expression.isPresent()) {
-      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-      if (resolvedBindings != null
-          && !resolvedBindings.bindingsOwnedBy(graph.componentDescriptor()).isEmpty()) {
-        expression = Optional.of(createBindingExpression(resolvedBindings, request));
-      }
-    }
-    if (!expression.isPresent()
-        && compilerOptions.aheadOfTimeSubcomponents()
-        && request.requestKind().isPresent()
-        && isDerivedFromProvider(request.requestKind().get())) {
-      RequestKind requestKind = request.requestKind().get();
-      expression =
-          Optional.of(
-              new DerivedFromFrameworkInstanceBindingExpression(
-                  request.key(), FrameworkType.PROVIDER, requestKind, this, types));
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    if (resolvedBindings != null
+        && !resolvedBindings.bindingsOwnedBy(graph.componentDescriptor()).isEmpty()) {
+      BindingExpression expression = createBindingExpression(resolvedBindings, request);
+      expressions.put(request, expression);
+      return expression;
     }
 
-    if (expression.isPresent()) {
-      expressions.put(request, expression.get());
-      return expression.get();
-    }
     checkArgument(parent.isPresent(), "no expression found for %s", request);
     return parent.get().getBindingExpression(request);
   }
@@ -562,13 +508,11 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
 
       case MULTIBOUND_SET:
         return Optional.of(
-            new SetBindingExpression(
-                (ProvisionBinding) binding, componentImplementation, graph, this, types, elements));
+            new SetBindingExpression((ProvisionBinding) binding, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
-            new MapBindingExpression(
-                (ProvisionBinding) binding, componentImplementation, graph, this, types, elements));
+            new MapBindingExpression((ProvisionBinding) binding, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(
@@ -652,12 +596,7 @@ BindingExpression wrapInMethod(
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().firstMatchingComponentMethod(request);
 
-    if (modifiableBindingExpressions.getModifiableBindingType(request).isModifiable()
-        && (componentImplementation.superclassImplementation().isPresent()
-            || !matchingComponentMethod.isPresent())) {
-      return modifiableBindingExpressions.wrapInModifiableMethodBindingExpression(
-          request, resolvedBindings, methodImplementationStrategy, bindingExpression);
-    } else if (matchingComponentMethod.isPresent()) {
+    if (matchingComponentMethod.isPresent()) {
       ComponentMethodDescriptor componentMethod = matchingComponentMethod.get();
       return new ComponentMethodBindingExpression(
           request,
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
index a5eb68034..e355c100b 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -40,12 +40,6 @@ static ComponentCreatorImplementation create(
   /** The name of the creator implementation class. */
   abstract ClassName name();
 
-  /**
-   * All fields that are present in this implementation or its supertype.
-   *
-   * <p>In the case of ahead-of-time subcomponents, not all fields will necessarily be passed to
-   * the component's constructor (because, for example, it turns out that a particular module that
-   * the creator can set is actually inherited from an ancestor module).
-   */
+  /** All fields that are present in this implementation. */
   abstract ImmutableMap<ComponentRequirement, FieldSpec> fields();
 }
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 4f06b900a..32587ac73 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -26,10 +26,8 @@
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeSpecs.addSupertype;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -79,20 +77,6 @@
     Optional<ComponentCreatorDescriptor> creatorDescriptor =
         componentImplementation.componentDescriptor().creatorDescriptor();
 
-    if (componentImplementation.isAbstract()
-        && (hasNoSetterMethods(creatorDescriptor)
-            || componentImplementation.superclassImplementation().isPresent())) {
-      // 1. Factory-like creators (those with no setter methods) are only generated in concrete
-      //    components, because they only have a factory method and the factory method must call
-      //    a concrete component's constructor.
-      // 2. The component builder in ahead-of-time mode is generated with the base subcomponent
-      //    implementation, with the exception of the build method since that requires invoking the
-      //    constructor of a concrete component implementation. Intermediate component
-      //    implementations, because they still can't invoke the eventual constructor and have no
-      //    additional extensions to the builder, can ignore generating a builder implementation.
-      return Optional.empty();
-    }
-
     Builder builder =
         creatorDescriptor.isPresent()
             ? new BuilderForCreatorDescriptor(
@@ -101,11 +85,6 @@
     return Optional.of(builder.build());
   }
 
-  private static boolean hasNoSetterMethods(
-      Optional<ComponentCreatorDescriptor> creatorDescriptor) {
-    return creatorDescriptor.filter(descriptor -> descriptor.setterMethods().isEmpty()).isPresent();
-  }
-
   /** Base class for building a creator implementation. */
   private abstract class Builder {
     final ComponentImplementation componentImplementation;
@@ -124,7 +103,7 @@ private static boolean hasNoSetterMethods(
     ComponentCreatorImplementation build() {
       setModifiers();
       setSupertype();
-      this.fields = getOrAddFields();
+      this.fields = addFields();
       addConstructor();
       addSetterMethods();
       addFactoryMethod();
@@ -141,7 +120,7 @@ final ComponentDescriptor componentDescriptor() {
      * they must be passed.
      */
     final ImmutableSet<ComponentRequirement> componentConstructorRequirements() {
-      return componentImplementation.requirements();
+      return componentImplementation.graph().componentRequirements();
     }
 
     /** Returns the requirements that have setter methods on the creator type. */
@@ -174,7 +153,7 @@ private void setModifiers() {
       if (!componentImplementation.isNested()) {
         classBuilder.addModifiers(STATIC);
       }
-      classBuilder.addModifiers(componentImplementation.isAbstract() ? ABSTRACT : FINAL);
+      classBuilder.addModifiers(FINAL);
     }
 
     /** Returns the visibility modifier the generated class should have, if any. */
@@ -186,18 +165,8 @@ private void setModifiers() {
     /** Adds a constructor for the creator type, if needed. */
     protected abstract void addConstructor();
 
-    private ImmutableMap<ComponentRequirement, FieldSpec> getOrAddFields() {
-      // If a base implementation is present, any fields are already defined there and don't need to
-      // be created in this implementation.
-      return componentImplementation
-          .baseCreatorImplementation()
-          .map(ComponentCreatorImplementation::fields)
-          .orElseGet(this::addFields);
-    }
-
     private ImmutableMap<ComponentRequirement, FieldSpec> addFields() {
       // Fields in an abstract creator class need to be visible from subclasses.
-      Modifier modifier = componentImplementation.isAbstract() ? PROTECTED : PRIVATE;
       UniqueNameSet fieldNames = new UniqueNameSet();
       ImmutableMap<ComponentRequirement, FieldSpec> result =
           Maps.toMap(
@@ -206,7 +175,7 @@ private void setModifiers() {
                   FieldSpec.builder(
                           TypeName.get(requirement.type()),
                           fieldNames.getUniqueName(requirement.variableName()),
-                          modifier)
+                          PRIVATE)
                       .build());
       classBuilder.addFields(result.values());
       return result;
@@ -231,8 +200,6 @@ private void addSetterMethods() {
           return Optional.of(noopSetterMethod(requirement));
         case UNSETTABLE_REPEATED_MODULE:
           return Optional.of(repeatedModuleSetterMethod(requirement));
-        case IMPLEMENTED_IN_SUPERTYPE:
-          return Optional.empty();
       }
       throw new AssertionError();
     }
@@ -284,9 +251,7 @@ private MethodSpec maybeReturnThis(MethodSpec.Builder method) {
     }
 
     private void addFactoryMethod() {
-      if (!componentImplementation.isAbstract()) {
-        classBuilder.addMethod(factoryMethod());
-      }
+      classBuilder.addMethod(factoryMethod());
     }
 
     MethodSpec factoryMethod() {
@@ -301,11 +266,7 @@ MethodSpec factoryMethod() {
           .keySet()
           .forEach(
               requirement -> {
-                if (fields.containsKey(requirement)
-                    && componentConstructorRequirements().contains(requirement)) {
-                  // In AOT mode, there can be a field for a requirement even if the component's
-                  // constructor doesn't need it, because the base class for the creator was created
-                  // before the final graph for the component was known.
+                if (fields.containsKey(requirement)) {
                   FieldSpec field = fields.get(requirement);
                   addNullHandlingForField(requirement, field, factoryMethod);
                 } else if (factoryMethodParameters.containsKey(requirement)) {
@@ -399,23 +360,12 @@ private CodeBlock newModuleInstance(ComponentRequirement requirement) {
 
     @Override
     protected Optional<Modifier> visibility() {
-      if (componentImplementation.isAbstract()) {
-        // The component creator class of a top-level component implementation in ahead-of-time
-        // subcomponents mode must be public, not protected, because the creator's subclass will
-        // be a sibling of the component subclass implementation, not nested.
-        return Optional.of(componentImplementation.isNested() ? PROTECTED : PUBLIC);
-      }
       return Optional.of(PRIVATE);
     }
 
     @Override
     protected void setSupertype() {
-      if (componentImplementation.baseCreatorImplementation().isPresent()) {
-        // If an abstract base implementation for this creator exists, extend that class.
-        classBuilder.superclass(componentImplementation.baseCreatorImplementation().get().name());
-      } else {
-        addSupertype(classBuilder, creatorDescriptor.typeElement());
-      }
+      addSupertype(classBuilder, creatorDescriptor.typeElement());
     }
 
     @Override
@@ -446,20 +396,10 @@ private DeclaredType creatorType() {
     }
 
     private RequirementStatus requirementStatus(ComponentRequirement requirement) {
-      // In ahead-of-time subcomponents mode, all builder methods are defined at the base
-      // implementation. The only case where a method needs to be overridden is for a repeated
-      // module, which is unknown at the point when a base implementation is generated. We do this
-      // at the root for simplicity (and as an aside, repeated modules are never used in google
-      // as of 11/28/18, and thus the additional cost of including these methods at the root is
-      // negligible).
       if (isRepeatedModule(requirement)) {
         return RequirementStatus.UNSETTABLE_REPEATED_MODULE;
       }
 
-      if (hasBaseCreatorImplementation()) {
-        return RequirementStatus.IMPLEMENTED_IN_SUPERTYPE;
-      }
-
       return componentConstructorRequirements().contains(requirement)
           ? RequirementStatus.NEEDED
           : RequirementStatus.UNNEEDED;
@@ -481,11 +421,6 @@ private boolean isOwnedModule(ComponentRequirement requirement) {
       return graph.map(g -> g.ownedModuleTypes().contains(requirement.typeElement())).orElse(true);
     }
 
-    private boolean hasBaseCreatorImplementation() {
-      return !componentImplementation.isAbstract()
-          && componentImplementation.baseImplementation().isPresent();
-    }
-
     @Override
     protected MethodSpec.Builder setterMethodBuilder(ComponentRequirement requirement) {
       ExecutableElement supertypeMethod = creatorDescriptor.setterMethods().get(requirement);
@@ -578,12 +513,6 @@ protected void addConstructor() {
      * inherited from an ancestor component. Any setter method for it should throw an exception.
      */
     UNSETTABLE_REPEATED_MODULE,
-
-    /**
-     * The requirement is settable by the creator, but the setter method implementation already
-     * exists in a supertype.
-     */
-    IMPLEMENTED_IN_SUPERTYPE,
     ;
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 340da1443..c2a4a32e6 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -25,41 +25,26 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.serialization.ProtoSerialization.toAnnotationValue;
-import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Maps;
 import com.google.common.collect.MultimapBuilder;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.ConfigureInitializationParameters;
-import dagger.internal.ModifiableBinding;
-import dagger.internal.ModifiableModule;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.internal.codegen.javapoet.TypeSpecs;
-import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -98,13 +83,6 @@
     /** The component constructor. */
     CONSTRUCTOR,
 
-    /**
-     * In ahead-of-time subcomponents, this method coordinates the invocation of {@link
-     * #INITIALIZE_METHOD initialization methods} instead of constructors.
-     */
-    // TODO(b/117833324): try to merge this with other initialize() methods so it looks more natural
-    CONFIGURE_INITIALIZATION_METHOD,
-
     /** A builder method for the component. (Only used by the root component.) */
     BUILDER_METHOD,
 
@@ -123,13 +101,6 @@
     /** A static method that always returns an absent {@code Optional} value for the binding. */
     ABSENT_OPTIONAL_METHOD,
 
-    /**
-     * A method that encapsulates a modifiable binding. A binding is modifiable if it can change
-     * across implementations of a subcomponent. This is only relevant for ahead-of-time
-     * subcomponents.
-     */
-    MODIFIABLE_BINDING_METHOD,
-
     /**
      * The {@link dagger.producers.internal.CancellationListener#onProducerFutureCancelled(boolean)}
      * method for a production component.
@@ -153,43 +124,18 @@
     SUBCOMPONENT
   }
 
-  /**
-   * The method spec for a {@code configureInitialization} method plus details on the component
-   * requirements that its parameters are associated with.
-   */
-  @AutoValue
-  abstract static class ConfigureInitializationMethod {
-    /** Creates a new {@link ConfigureInitializationMethod}. */
-    static ConfigureInitializationMethod create(
-        MethodSpec spec, ImmutableSet<ComponentRequirement> parameters) {
-      return new AutoValue_ComponentImplementation_ConfigureInitializationMethod(spec, parameters);
-    }
-
-    /** The spec for the method. */
-    abstract MethodSpec spec();
-
-    /**
-     * The component requirements associated with the method's parameters, in the same order as the
-     * parameters.
-     */
-    abstract ImmutableSet<ComponentRequirement> parameters();
-  }
-
   private final CompilerOptions compilerOptions;
   private final ComponentDescriptor componentDescriptor;
-  private final Optional<BindingGraph> graph;
+  private final BindingGraph graph;
   private final ClassName name;
   private final NestingKind nestingKind;
-  private final boolean isAbstract;
-  private final Optional<ComponentImplementation> superclassImplementation;
   private Optional<ComponentCreatorImplementation> creatorImplementation;
   private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
-  private final Optional<SubcomponentNames> subcomponentNames;
+  private final SubcomponentNames subcomponentNames;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
-  private final Set<ComponentRequirement> componentRequirementParameters = new HashSet<>();
   private final List<CodeBlock> componentRequirementInitializations = new ArrayList<>();
   private final Map<ComponentRequirement, String> componentRequirementParameterNames =
       new HashMap<>();
@@ -201,19 +147,13 @@ static ConfigureInitializationMethod create(
   private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
-  private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
-  private final SetMultimap<BindingRequest, Key> multibindingContributionsMade =
-      LinkedHashMultimap.create();
-  private Optional<ConfigureInitializationMethod> configureInitializationMethod = Optional.empty();
-  private final Map<ComponentRequirement, String> modifiableModuleMethods = new LinkedHashMap<>();
 
   private ComponentImplementation(
       ComponentDescriptor componentDescriptor,
-      Optional<BindingGraph> graph,
+      BindingGraph graph,
       ClassName name,
       NestingKind nestingKind,
-      Optional<ComponentImplementation> superclassImplementation,
-      Optional<SubcomponentNames> subcomponentNames,
+      SubcomponentNames subcomponentNames,
       CompilerOptions compilerOptions,
       ImmutableSet<Modifier> modifiers) {
     checkName(name, nestingKind);
@@ -222,8 +162,6 @@ private ComponentImplementation(
     this.graph = graph;
     this.name = name;
     this.nestingKind = nestingKind;
-    this.isAbstract = modifiers.contains(ABSTRACT);
-    this.superclassImplementation = superclassImplementation;
     this.component = classBuilder(name);
     modifiers.forEach(component::addModifiers);
     this.subcomponentNames = subcomponentNames;
@@ -237,11 +175,10 @@ static ComponentImplementation topLevelComponentImplementation(
       CompilerOptions compilerOptions) {
     return new ComponentImplementation(
         graph.componentDescriptor(),
-        Optional.of(graph),
+        graph,
         name,
         NestingKind.TOP_LEVEL,
-        Optional.empty(), // superclass implementation
-        Optional.of(subcomponentNames),
+        subcomponentNames,
         compilerOptions,
         topLevelComponentImplementationModifiers(graph));
   }
@@ -258,43 +195,17 @@ static ComponentImplementation topLevelComponentImplementation(
   }
 
   /** Returns a component implementation that is a child of the current implementation. */
-  ComponentImplementation childComponentImplementation(
-      BindingGraph graph,
-      Optional<ComponentImplementation> superclassImplementation,
-      Modifier... modifiers) {
+  ComponentImplementation childComponentImplementation(BindingGraph graph, Modifier... modifiers) {
     return new ComponentImplementation(
         graph.componentDescriptor(),
-        Optional.of(graph),
+        graph,
         getSubcomponentName(graph.componentDescriptor()),
         NestingKind.MEMBER,
-        superclassImplementation,
         subcomponentNames,
         compilerOptions,
         ImmutableSet.copyOf(modifiers));
   }
 
-  /**
-   * Returns a component implementation that models a previously compiled class. This {@link
-   * ComponentImplementation} is not used for code generation itself; it is used to determine what
-   * methods need to be implemented in a subclass implementation.
-   */
-  static ComponentImplementation forDeserializedComponent(
-      ComponentDescriptor componentDescriptor,
-      ClassName name,
-      NestingKind nestingKind,
-      Optional<ComponentImplementation> superclassImplementation,
-      CompilerOptions compilerOptions) {
-    return new ComponentImplementation(
-        componentDescriptor,
-        Optional.empty(),
-        name,
-        nestingKind,
-        superclassImplementation,
-        Optional.empty(),
-        compilerOptions,
-        ImmutableSet.of(PUBLIC, ABSTRACT));
-  }
-
   // TODO(dpb): Just determine the nesting kind from the name.
   private static void checkName(ClassName name, NestingKind nestingKind) {
     switch (nestingKind) {
@@ -313,22 +224,11 @@ private static void checkName(ClassName name, NestingKind nestingKind) {
     }
   }
 
-  /**
-   * Returns {@code true} if this component implementation represents a component that has already
-   * been compiled. If this returns true, the implementation will have no {@link #graph
-   * BindingGraph}.
-   */
-  boolean isDeserializedImplementation() {
-    return !graph.isPresent();
-  }
-
   // TODO(ronshapiro): see if we can remove this method and instead inject it in the objects that
   // need it.
   /** Returns the binding graph for the component being generated. */
   BindingGraph graph() {
-    checkState(!isDeserializedImplementation(),
-        "A BindingGraph is not available for deserialized component implementations.");
-    return graph.get();
+    return graph;
   }
 
   /** Returns the descriptor for the component being generated. */
@@ -346,95 +246,6 @@ boolean isNested() {
     return nestingKind.isNested();
   }
 
-  /** Returns whether or not the implementation is abstract. */
-  boolean isAbstract() {
-    return isAbstract;
-  }
-
-  /** Returns the superclass implementation. */
-  Optional<ComponentImplementation> superclassImplementation() {
-    return superclassImplementation;
-  }
-
-  /**
-   * Returns the base implementation of this component in ahead-of-time subcomponents mode. If this
-   * is the base implementation, this returns {@link Optional#empty()}.
-   */
-  Optional<ComponentImplementation> baseImplementation() {
-    return superclassImplementation.isPresent()
-        ? Optional.of(Optionals.rootmostValue(this, c -> c.superclassImplementation))
-        : Optional.empty();
-  }
-
-  /**
-   * Returns the {@link #configureInitializationMethod()} of the nearest supertype that defines one,
-   * if any.
-   *
-   * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
-   */
-  Optional<ConfigureInitializationMethod> superConfigureInitializationMethod() {
-    for (Optional<ComponentImplementation> currentSuper = superclassImplementation;
-        currentSuper.isPresent();
-        currentSuper = currentSuper.get().superclassImplementation) {
-      if (currentSuper.get().configureInitializationMethod.isPresent()) {
-        return currentSuper.get().configureInitializationMethod;
-      }
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * The requirements for creating an instance of this component implementation type.
-   *
-   * <p>If this component implementation is concrete, these requirements will be in the order that
-   * the implementation's constructor takes them as parameters.
-   */
-  ImmutableSet<ComponentRequirement> requirements() {
-    // If the base implementation's creator is being generated in ahead-of-time-subcomponents
-    // mode, this uses the ComponentDescriptor's requirements() since Dagger doesn't know what
-    // modules may end being unused or owned by an ancestor component. Otherwise, we use the
-    // necessary component requirements.
-    // TODO(ronshapiro): can we remove the second condition here? Or, is it never going to be
-    // called, so we should enforce that invariant?
-    return isAbstract() && !superclassImplementation().isPresent()
-        ? componentDescriptor().requirements()
-        : graph().componentRequirements();
-  }
-
-  /**
-   * Returns the {@link MethodSpecKind#CONFIGURE_INITIALIZATION_METHOD} of this implementation if
-   * there is one.
-   *
-   * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
-   */
-  Optional<ConfigureInitializationMethod> configureInitializationMethod() {
-    return configureInitializationMethod;
-  }
-
-  /**
-   * Set's this component implementation's {@code configureInitialization()} method and {@linkplain
-   * #addMethod(MethodSpecKind, MethodSpec) adds the method}.
-   */
-  void setConfigureInitializationMethod(ConfigureInitializationMethod method) {
-    configureInitializationMethod = Optional.of(method);
-    addMethod(
-        MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD,
-        addConfigureInitializationMetadata(method));
-  }
-
-  private MethodSpec addConfigureInitializationMetadata(ConfigureInitializationMethod method) {
-    if (!shouldEmitModifiableMetadataAnnotations()) {
-      return method.spec();
-    }
-    AnnotationSpec.Builder annotation =
-        AnnotationSpec.builder(ConfigureInitializationParameters.class);
-    for (ComponentRequirement parameter : method.parameters()) {
-      annotation.addMember("value", toAnnotationValue(parameter.toProto()));
-    }
-
-    return method.spec().toBuilder().addAnnotation(annotation.build()).build();
-  }
-
   void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorImplementation) {
     checkState(
         this.creatorImplementation == null, "setCreatorImplementation has already been called");
@@ -446,14 +257,6 @@ void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorIm
     return creatorImplementation;
   }
 
-  /**
-   * Returns the {@link ComponentCreatorImplementation} defined in the base implementation for this
-   * component, if one exists.
-   */
-  Optional<ComponentCreatorImplementation> baseCreatorImplementation() {
-    return baseImplementation().flatMap(baseImpl -> baseImpl.creatorImplementation());
-  }
-
   /**
    * Returns the kind of this component's creator.
    *
@@ -496,15 +299,7 @@ String getSubcomponentCreatorSimpleName(Key key) {
   }
 
   private SubcomponentNames subcomponentNames() {
-    checkState(
-        subcomponentNames.isPresent(),
-        "SubcomponentNames is not available for deserialized component implementations.");
-    return subcomponentNames.get();
-  }
-
-  /** Returns the child implementation. */
-  Optional<ComponentImplementation> childImplementation(ComponentDescriptor child) {
-    return Optional.ofNullable(childImplementations.get(child.typeElement()));
+    return subcomponentNames;
   }
 
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
@@ -517,15 +312,6 @@ void addSupertype(TypeElement supertype) {
     TypeSpecs.addSupertype(component, supertype);
   }
 
-  /** Adds the given super class to the subcomponent. */
-  void addSuperclass(ClassName className) {
-    checkState(
-        superclassImplementation.isPresent(),
-        "Setting the superclass for component [%s] when there is no superclass implementation.",
-        name);
-    component.superclass(className);
-  }
-
   // TODO(dpb): Consider taking FieldSpec, and returning identical FieldSpec with unique name?
   /** Adds the given field to the component. */
   void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
@@ -548,107 +334,6 @@ void addAnnotation(AnnotationSpec annotation) {
     component.addAnnotation(annotation);
   }
 
-  /**
-   * Adds the given method to the component. In this case, the method represents an encapsulation of
-   * a modifiable binding between implementations of a subcomponent. This is only relevant for
-   * ahead-of-time subcomponents.
-   */
-  void addModifiableBindingMethod(
-      ModifiableBindingType type,
-      BindingRequest request,
-      TypeMirror returnType,
-      MethodSpec methodSpec,
-      boolean finalized) {
-    addModifiableMethod(
-        MethodSpecKind.MODIFIABLE_BINDING_METHOD, type, request, returnType, methodSpec, finalized);
-  }
-
-  /**
-   * Adds a component method that is modifiable to the component. In this case, the method
-   * represents an encapsulation of a modifiable binding between implementations of a subcomponent.
-   * This is only relevant for ahead-of-time subcomponents.
-   */
-  void addModifiableComponentMethod(
-      ModifiableBindingType type,
-      BindingRequest request,
-      TypeMirror returnType,
-      MethodSpec methodSpec,
-      boolean finalized) {
-    addModifiableMethod(
-        MethodSpecKind.COMPONENT_METHOD, type, request, returnType, methodSpec, finalized);
-  }
-
-  private void addModifiableMethod(
-      MethodSpecKind methodKind,
-      ModifiableBindingType type,
-      BindingRequest request,
-      TypeMirror returnType,
-      MethodSpec methodSpec,
-      boolean finalized) {
-    modifiableBindingMethods.addModifiableMethod(
-        type, request, returnType, methodSpec, finalized);
-    methodSpecsMap.put(methodKind, withModifiableBindingMetadata(methodSpec, type, request));
-  }
-
-  /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
-  void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
-    modifiableBindingMethods.addReimplementedMethod(method);
-    methodSpecsMap.put(
-        MethodSpecKind.MODIFIABLE_BINDING_METHOD,
-        withModifiableBindingMetadata(method.methodSpec(), method.type(), method.request()));
-  }
-
-  private MethodSpec withModifiableBindingMetadata(
-      MethodSpec method, ModifiableBindingType type, BindingRequest request) {
-    if (!shouldEmitModifiableMetadataAnnotations()) {
-      return method;
-    }
-    AnnotationSpec.Builder metadata =
-        AnnotationSpec.builder(ModifiableBinding.class)
-            .addMember("modifiableBindingType", "$S", type.name())
-            .addMember("bindingRequest", toAnnotationValue(request.toProto()));
-    for (Key multibindingContribution : multibindingContributionsMade.get(request)) {
-      metadata.addMember(
-          "multibindingContributions",
-          toAnnotationValue(KeyFactory.toProto(multibindingContribution)));
-    }
-    return method.toBuilder().addAnnotation(metadata.build()).build();
-  }
-
-  /** Add's a modifiable module method to this implementation. */
-  void addModifiableModuleMethod(ComponentRequirement module, MethodSpec method) {
-    registerModifiableModuleMethod(module, method.name);
-    methodSpecsMap.put(
-        MethodSpecKind.MODIFIABLE_BINDING_METHOD, withModifiableModuleMetadata(module, method));
-  }
-
-  /** Registers a modifiable module method with {@code name} for {@code module}. */
-  void registerModifiableModuleMethod(ComponentRequirement module, String name) {
-    checkArgument(module.kind().isModule());
-    checkState(modifiableModuleMethods.put(module, name) == null);
-  }
-
-  private MethodSpec withModifiableModuleMetadata(ComponentRequirement module, MethodSpec method) {
-    if (!shouldEmitModifiableMetadataAnnotations()) {
-      return method;
-    }
-    return method
-        .toBuilder()
-        .addAnnotation(
-            AnnotationSpec.builder(ModifiableModule.class)
-                .addMember("value", toAnnotationValue(module.toProto()))
-                .build())
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the generated component should include metadata annotations with
-   * information to deserialize this {@link ComponentImplementation} in future compilations.
-   */
-  boolean shouldEmitModifiableMetadataAnnotations() {
-    return isAbstract && compilerOptions.emitModifiableMetadataAnnotations();
-  }
-
   /** Adds the given type to the component. */
   void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
     typeSpecsMap.put(typeKind, typeSpec);
@@ -670,22 +355,6 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
-  /**
-   * Adds the given component requirement as one that should have a parameter in the component's
-   * initialization methods.
-   */
-  void addComponentRequirementParameter(ComponentRequirement requirement) {
-    componentRequirementParameters.add(requirement);
-  }
-
-  /**
-   * The set of component requirements that have parameters in the component's initialization
-   * methods.
-   */
-  ImmutableSet<ComponentRequirement> getComponentRequirementParameters() {
-    return ImmutableSet.copyOf(componentRequirementParameters);
-  }
-
   /** Adds the given code block that initializes a {@link ComponentRequirement}. */
   void addComponentRequirementInitialization(CodeBlock codeBlock) {
     componentRequirementInitializations.add(codeBlock);
@@ -724,11 +393,6 @@ private String uniqueMethodName(BindingRequest request, String bindingName) {
     return getUniqueMethodName(baseMethodName);
   }
 
-  /** Gets the parameter name to use for the given requirement for this component. */
-  String getParameterName(ComponentRequirement requirement) {
-    return getParameterName(requirement, requirement.variableName());
-  }
-
   /**
    * Gets the parameter name to use for the given requirement for this component, starting with the
    * given base name if no parameter name has already been selected for the requirement.
@@ -758,115 +422,18 @@ void claimMethodName(CharSequence name) {
    * {@link dagger.producers.internal.DelegateProducer} since the types of these initialized fields
    * have no interface type that we can write a proxy for.
    */
+  // TODO(cgdecker): can these be inlined with getInitializations() now that we've turned down
+  // ahead-of-time subcomponents?
   ImmutableList<CodeBlock> getComponentRequirementInitializations() {
     return ImmutableList.copyOf(componentRequirementInitializations);
   }
 
-  /**
-   * Returns whether or not this component has any {@linkplain #getInitializations() initilizations}
-   * or {@linkplain #getComponentRequirementInitializations() component requirement
-   * initializations}.
-   */
-  boolean hasInitializations() {
-    return !initializations.isEmpty() || !componentRequirementInitializations.isEmpty();
-  }
-
   /**
    * Returns the list of producer {@link Key}s that need cancellation statements in the cancellation
    * listener method.
    */
   ImmutableList<Key> getCancellableProducerKeys() {
-    Optional<ComponentImplementation> currentSuperImplementation = superclassImplementation;
-    Set<Key> cancelledKeysFromSuperclass = new HashSet<>();
-    while (currentSuperImplementation.isPresent()) {
-      cancelledKeysFromSuperclass.addAll(currentSuperImplementation.get().cancellableProducerKeys);
-      currentSuperImplementation = currentSuperImplementation.get().superclassImplementation;
-    }
-    return Sets.difference(cancellableProducerKeys, cancelledKeysFromSuperclass)
-        .immutableCopy()
-        .asList();
-  }
-
-  /**
-   * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
-   * superclasses.
-   */
-  ImmutableMap<BindingRequest, ModifiableBindingMethod> getModifiableBindingMethods() {
-    Map<BindingRequest, ModifiableBindingMethod> modifiableBindingMethodsBuilder =
-        new LinkedHashMap<>();
-    if (superclassImplementation.isPresent()) {
-      modifiableBindingMethodsBuilder.putAll(
-          Maps.filterValues(
-              superclassImplementation.get().getModifiableBindingMethods(),
-              // filters the modifiable methods of a superclass that are finalized in this component
-              method -> !modifiableBindingMethods.finalized(method)));
-    }
-    // replace superclass modifiable binding methods with any that are defined in this component
-    // implementation
-    modifiableBindingMethodsBuilder.putAll(modifiableBindingMethods.getNonFinalizedMethods());
-    return ImmutableMap.copyOf(modifiableBindingMethodsBuilder);
-  }
-
-  /**
-   * Returns the names of every modifiable method of this implementation and any superclass
-   * implementations.
-   */
-  ImmutableSet<String> getAllModifiableMethodNames() {
-    ImmutableSet.Builder<String> names = ImmutableSet.builder();
-    modifiableBindingMethods.allMethods().forEach(method -> names.add(method.methodSpec().name));
-    names.addAll(modifiableModuleMethods.values());
-    superclassImplementation.ifPresent(
-        superclass -> names.addAll(superclass.getAllModifiableMethodNames()));
-    return names.build();
-  }
-
-  /**
-   * Returns the {@link ModifiableBindingMethod} for this subcomponent for the given binding, if it
-   * exists.
-   */
-  Optional<ModifiableBindingMethod> getModifiableBindingMethod(BindingRequest request) {
-    Optional<ModifiableBindingMethod> method = modifiableBindingMethods.getMethod(request);
-    if (!method.isPresent() && superclassImplementation.isPresent()) {
-      return superclassImplementation.get().getModifiableBindingMethod(request);
-    }
-    return method;
-  }
-
-  /**
-   * Returns the {@link ModifiableBindingMethod} of a supertype for this method's {@code request},
-   * if one exists.
-   */
-  Optional<ModifiableBindingMethod> supertypeModifiableBindingMethod(BindingRequest request) {
-    return superclassImplementation()
-        .flatMap(superImplementation -> superImplementation.getModifiableBindingMethod(request));
-  }
-
-  /**
-   * Returns the names of modifiable module methods for this implementation and all inherited
-   * implementations, keyed by the corresponding module's {@link ComponentRequirement}.
-   */
-  ImmutableMap<ComponentRequirement, String> getAllModifiableModuleMethods() {
-    ImmutableMap.Builder<ComponentRequirement, String> methods = ImmutableMap.builder();
-    methods.putAll(modifiableModuleMethods);
-    superclassImplementation.ifPresent(
-        superclass -> methods.putAll(superclass.getAllModifiableModuleMethods()));
-    return methods.build();
-  }
-
-  /**
-   * Returns the name of the modifiable module method for {@code module} that is inherited in this
-   * implementation, or empty if none has been defined.
-   */
-  Optional<String> supertypeModifiableModuleMethodName(ComponentRequirement module) {
-    checkArgument(module.kind().isModule());
-    if (!superclassImplementation.isPresent()) {
-      return Optional.empty();
-    }
-    String methodName = superclassImplementation.get().modifiableModuleMethods.get(module);
-    if (methodName == null) {
-      return superclassImplementation.get().supertypeModifiableModuleMethodName(module);
-    }
-    return Optional.of(methodName);
+    return ImmutableList.copyOf(cancellableProducerKeys);
   }
 
   /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
@@ -877,53 +444,4 @@ boolean hasInitializations() {
     switchingProviderSupplier.stream().map(Supplier::get).forEach(component::addType);
     return component;
   }
-
-  /**
-   * Registers a {@ProvisionBinding} representing a multibinding as having been implemented in this
-   * component. Multibindings are modifiable across subcomponent implementations and this allows us
-   * to know whether a contribution has been made by a superclass implementation. This is only
-   * relevant for ahead-of-time subcomponents.
-   */
-  void registerImplementedMultibinding(
-      ContributionBinding multibinding, BindingRequest bindingRequest) {
-    checkArgument(multibinding.isSyntheticMultibinding());
-    // We register a multibinding as implemented each time we request the multibinding expression,
-    // so only modify the set of contributions once.
-    if (!multibindingContributionsMade.containsKey(bindingRequest)) {
-      registerImplementedMultibindingKeys(
-          bindingRequest,
-          multibinding.dependencies().stream().map(DependencyRequest::key).collect(toList()));
-    }
-  }
-
-  /**
-   * Registers the multibinding contributions represented by {@code keys} as having been implemented
-   * in this component. Multibindings are modifiable across subcomponent implementations and this
-   * allows us to know whether a contribution has been made by a superclass implementation. This is
-   * only relevant for ahead-of-time subcomponents.
-   */
-  void registerImplementedMultibindingKeys(BindingRequest bindingRequest, Iterable<Key> keys) {
-    multibindingContributionsMade.putAll(bindingRequest, keys);
-  }
-
-  /**
-   * Returns the set of multibinding contributions associated with all superclass implementations of
-   * a multibinding.
-   */
-  ImmutableSet<Key> superclassContributionsMade(BindingRequest bindingRequest) {
-    return superclassImplementation
-        .map(s -> s.getAllMultibindingContributions(bindingRequest))
-        .orElse(ImmutableSet.of());
-  }
-
-  /**
-   * Returns the set of multibinding contributions associated with all implementations of a
-   * multibinding.
-   */
-  private ImmutableSet<Key> getAllMultibindingContributions(BindingRequest bindingRequest) {
-    return ImmutableSet.copyOf(
-        Sets.union(
-            multibindingContributionsMade.get(bindingRequest),
-            superclassContributionsMade(bindingRequest)));
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 7579ac9ef..44d5cbe99 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -18,9 +18,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Predicates.in;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
@@ -30,18 +28,14 @@
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CONSTRUCTOR;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
-import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.MODIFIABLE_BINDING_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_CREATOR;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.javapoet.CodeBlocks.parameterNames;
-import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.producers.CancellationPolicy.Propagation.PROPAGATE;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -49,24 +43,17 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Sets;
-import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.ComponentDefinitionType;
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentImplementation.ConfigureInitializationMethod;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import dagger.internal.codegen.langmodel.DaggerElements;
@@ -130,19 +117,10 @@ final ComponentImplementation build() {
 
     getLocalAndInheritedMethods(graph.componentTypeElement(), types, elements)
         .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
-    componentImplementation
-        .superclassImplementation()
-        .ifPresent(
-            superclassImplementation -> {
-              superclassImplementation
-                  .getAllModifiableMethodNames()
-                  .forEach(componentImplementation::claimMethodName);
-            });
 
     addFactoryMethods();
     addInterfaceMethods();
     addChildComponents();
-    implementModifiableModuleMethods();
 
     addConstructorAndInitializationMethods();
 
@@ -150,30 +128,13 @@ final ComponentImplementation build() {
       addCancellationListenerImplementation();
     }
 
-    if (componentImplementation.isAbstract()
-        && !componentImplementation.baseImplementation().isPresent()) {
-      componentImplementation.addAnnotation(compilerOptions.toGenerationOptionsAnnotation());
-    }
-
-    if (componentImplementation.shouldEmitModifiableMetadataAnnotations()) {
-      componentImplementation.addAnnotation(
-          AnnotationSpec.builder(ComponentDefinitionType.class)
-              .addMember("value", "$T.class", graph.componentTypeElement())
-              .build());
-    }
-
     done = true;
     return componentImplementation;
   }
 
   /** Set the supertype for this generated class. */
   private void setSupertype() {
-    if (componentImplementation.superclassImplementation().isPresent()) {
-      componentImplementation.addSuperclass(
-          componentImplementation.superclassImplementation().get().name());
-    } else {
-      componentImplementation.addSupertype(graph.componentTypeElement());
-    }
+    componentImplementation.addSupertype(graph.componentTypeElement());
   }
 
   /**
@@ -195,36 +156,7 @@ protected void addInterfaceMethods() {
       ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
       MethodSpec methodSpec = bindingExpressions.getComponentMethod(anyOneMethod);
 
-      if (compilerOptions.aheadOfTimeSubcomponents()) {
-        addPossiblyModifiableInterfaceMethod(anyOneMethod, methodSpec);
-      } else {
-        componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
-      }
-    }
-  }
-
-  /**
-   * Adds a component interface method in ahead-of-time subcomponents mode. If the binding that
-   * implements the method is modifiable, registers the method.
-   */
-  private void addPossiblyModifiableInterfaceMethod(
-      ComponentMethodDescriptor methodDescriptor, MethodSpec implementedComponentMethod) {
-    if (methodDescriptor.dependencyRequest().isPresent()
-        && componentImplementation
-            .getModifiableBindingMethod(bindingRequest(methodDescriptor.dependencyRequest().get()))
-            .isPresent()) {
-      // If there are multiple component methods that are modifiable and for the same binding
-      // request, implement all but one in the base implementation to delegate to the one that
-      // will remain (and be registered) modifiable
-      checkState(componentImplementation.isAbstract() && !componentImplementation.isNested());
-      componentImplementation.addMethod(
-          COMPONENT_METHOD, implementedComponentMethod.toBuilder().addModifiers(FINAL).build());
-    } else {
-      // TODO(b/117833324): Can this class be the one to interface with ComponentImplementation
-      // instead of having it go through ModifiableBindingExpressions?
-      bindingExpressions
-          .modifiableBindingExpressions()
-          .addPossiblyModifiableComponentMethod(methodDescriptor, implementedComponentMethod);
+      componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
     }
   }
 
@@ -240,10 +172,6 @@ private void addCancellationListenerImplementation() {
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
             .addParameters(parameters);
-    if (componentImplementation.superclassImplementation().isPresent()) {
-      methodBuilder.addStatement(
-          "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
-    }
 
     ImmutableList<CodeBlock> cancellationStatements = cancellationStatements();
 
@@ -265,14 +193,6 @@ private void addCancellationListenerImplementation() {
     Optional<CodeBlock> cancelParentStatement = cancelParentStatement();
     cancelParentStatement.ifPresent(methodBuilder::addCode);
 
-    if (cancellationStatements.isEmpty()
-        && !cancelParentStatement.isPresent()
-        && componentImplementation.superclassImplementation().isPresent()) {
-      // Partial child implementations that have no new cancellations don't need to override
-      // the method just to call super().
-      return;
-    }
-
     componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
   }
 
@@ -307,39 +227,11 @@ private void addCancellationListenerImplementation() {
 
   protected Optional<CodeBlock> cancelParentStatement() {
     // Returns empty by default. Overridden in subclass(es) to add a statement if and only if the
-    // component being generated is a concrete subcomponent implementation with a parent that
-    // allows cancellation to propagate to it from subcomponents.
+    // component being generated has a parent that allows cancellation to propagate to it from
+    // subcomponents.
     return Optional.empty();
   }
 
-  /**
-   * For final components, reimplements all modifiable module methods that may have been modified.
-   */
-  private void implementModifiableModuleMethods() {
-    if (componentImplementation.isAbstract()) {
-      return;
-    }
-    componentImplementation
-        .getAllModifiableModuleMethods()
-        .forEach(this::implementModifiableModuleMethod);
-  }
-
-  private void implementModifiableModuleMethod(ComponentRequirement module, String methodName) {
-    // TODO(b/117833324): only reimplement methods for modules that were abstract or were repeated
-    // by an ancestor component.
-    componentImplementation.addMethod(
-        MODIFIABLE_BINDING_METHOD,
-        methodBuilder(methodName)
-            .addAnnotation(Override.class)
-            .addModifiers(PROTECTED)
-            .returns(TypeName.get(module.type()))
-            .addStatement(
-                componentRequirementExpressions
-                    .getExpression(module)
-                    .getModifiableModuleMethodExpression(componentImplementation.name()))
-            .build());
-  }
-
   private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
     return MethodSignature.forComponentMethod(
         method, MoreTypes.asDeclared(graph.componentTypeElement().asType()), types);
@@ -347,21 +239,15 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
 
   private void addChildComponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      // TODO(b/117833324): Can an abstract inner subcomponent implementation be elided if it's
-      // totally empty?
       componentImplementation.addChild(
           subgraph.componentDescriptor(), buildChildImplementation(subgraph));
     }
   }
 
   private ComponentImplementation buildChildImplementation(BindingGraph childGraph) {
-    ComponentImplementation childImplementation =
-        compilerOptions.aheadOfTimeSubcomponents()
-            ? abstractInnerSubcomponent(childGraph)
-            : concreteSubcomponent(childGraph);
     return topLevelImplementationComponent
         .currentImplementationSubcomponentBuilder()
-        .componentImplementation(childImplementation)
+        .componentImplementation(subcomponent(childGraph))
         .bindingGraph(childGraph)
         .parentBuilder(Optional.of(this))
         .parentBindingExpressions(Optional.of(bindingExpressions))
@@ -371,43 +257,18 @@ private ComponentImplementation buildChildImplementation(BindingGraph childGraph
         .build();
   }
 
-  /** Creates an inner abstract subcomponent implementation. */
-  private ComponentImplementation abstractInnerSubcomponent(BindingGraph childGraph) {
-    return componentImplementation.childComponentImplementation(
-        childGraph,
-        Optional.of(
-            componentImplementationFactory.findChildSuperclassImplementation(
-                childGraph.componentDescriptor(), componentImplementation)),
-        PROTECTED,
-        componentImplementation.isAbstract() ? ABSTRACT : FINAL);
-  }
-
-  /** Creates a concrete inner subcomponent implementation. */
-  private ComponentImplementation concreteSubcomponent(BindingGraph childGraph) {
-    return componentImplementation.childComponentImplementation(
-        childGraph,
-        Optional.empty(), // superclassImplementation
-        PRIVATE,
-        FINAL);
+  /** Creates an inner subcomponent implementation. */
+  private ComponentImplementation subcomponent(BindingGraph childGraph) {
+    return componentImplementation.childComponentImplementation(childGraph, PRIVATE, FINAL);
   }
 
   /** Creates and adds the constructor and methods needed for initializing the component. */
   private void addConstructorAndInitializationMethods() {
-    MethodSpec.Builder constructor = componentConstructorBuilder();
-    if (!componentImplementation.isAbstract()) {
-      implementInitializationMethod(constructor, initializationParameters());
-    } else if (componentImplementation.hasInitializations()) {
-      addConfigureInitializationMethod();
-    }
+    MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
+    implementInitializationMethod(constructor, initializationParameters());
     componentImplementation.addMethod(CONSTRUCTOR, constructor.build());
   }
 
-  /** Returns a builder for the component's constructor. */
-  private MethodSpec.Builder componentConstructorBuilder() {
-    return constructorBuilder()
-            .addModifiers(componentImplementation.isAbstract() ? PROTECTED : PRIVATE);
-  }
-
   /** Adds parameters and code to the given {@code initializationMethod}. */
   private void implementInitializationMethod(
       MethodSpec.Builder initializationMethod,
@@ -415,96 +276,9 @@ private void implementInitializationMethod(
     initializationMethod.addParameters(initializationParameters.values());
     initializationMethod.addCode(
         CodeBlocks.concat(componentImplementation.getComponentRequirementInitializations()));
-    componentImplementation
-        .superConfigureInitializationMethod()
-        .ifPresent(
-            superConfigureInitializationMethod ->
-                addSuperConfigureInitializationCall(
-                    initializationMethod,
-                    initializationParameters,
-                    superConfigureInitializationMethod));
     addInitializeMethods(initializationMethod, initializationParameters.values().asList());
   }
 
-  /** Creates and adds a {@code configureInitializatoin} method to the component. */
-  private void addConfigureInitializationMethod() {
-    MethodSpec.Builder method = configureInitializationMethodBuilder();
-    ImmutableMap<ComponentRequirement, ParameterSpec> parameters = initializationParameters();
-    implementInitializationMethod(method, parameters);
-    componentImplementation.setConfigureInitializationMethod(
-        ConfigureInitializationMethod.create(method.build(), parameters.keySet()));
-  }
-
-  /** Returns a builder for the component's {@code configureInitialization} method. */
-  private MethodSpec.Builder configureInitializationMethodBuilder() {
-    String methodName = componentImplementation.getUniqueMethodName("configureInitialization");
-    MethodSpec.Builder configureInitialization = methodBuilder(methodName).addModifiers(PROTECTED);
-    if (overridesSuperclassConfigureInitialization(configureInitialization.build())) {
-      configureInitialization.addAnnotation(Override.class);
-    }
-    return configureInitialization;
-  }
-
-  /**
-   * Returns whether or not the given method overrides a configureInitialization method from a
-   * superclass.
-   */
-  private boolean overridesSuperclassConfigureInitialization(MethodSpec method) {
-    for (Optional<ComponentImplementation> currentSuperImplementation =
-            componentImplementation.superclassImplementation();
-        currentSuperImplementation.isPresent();
-        currentSuperImplementation = currentSuperImplementation.get().superclassImplementation()) {
-      Optional<MethodSpec> superConfigureInitializationMethod =
-          currentSuperImplementation.get().configureInitializationMethod().map(m -> m.spec());
-      if (superConfigureInitializationMethod
-          .filter(superMethod -> haveSameSignature(method, superMethod))
-          .isPresent()) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  /** Returns whether or not methods {@code a} and {@code b} have the same signature. */
-  private boolean haveSameSignature(MethodSpec a, MethodSpec b) {
-    return a.name.equals(b.name) && types(a.parameters).equals(types(b.parameters));
-  }
-
-  private ImmutableList<TypeName> types(List<ParameterSpec> parameters) {
-    return parameters.stream().map(parameter -> parameter.type).collect(toImmutableList());
-  }
-
-  /**
-   * Adds a call to the superclass's {@code configureInitialization} method to the given {@code
-   * callingMethod}.
-   */
-  private void addSuperConfigureInitializationCall(
-      MethodSpec.Builder callingMethod,
-      ImmutableMap<ComponentRequirement, ParameterSpec> parameters,
-      ConfigureInitializationMethod superConfigureInitializationMethod) {
-    // This component's constructor may not have all of the parameters that the superclass's
-    // configureInitialization method takes, because the superclass configureInitialization method
-    // necessarily accepts things that it can't know whether will be needed or not. If they aren't
-    // needed (as is the case when the constructor doesn't have a parameter for the module), just
-    // pass null to super.configureInitialization for that parameter; it won't be used.
-    CodeBlock args =
-        superConfigureInitializationMethod.parameters().stream()
-            .map(
-                requirement ->
-                    parameters.containsKey(requirement)
-                        ? CodeBlock.of("$N", parameters.get(requirement))
-                        : CodeBlock.of("null"))
-            .collect(toParametersCodeBlock());
-
-    String qualifier =
-        haveSameSignature(callingMethod.build(), superConfigureInitializationMethod.spec())
-            ? "super."
-            : "";
-    callingMethod.addStatement(
-        qualifier + "$N($L)", superConfigureInitializationMethod.spec(), args);
-  }
-
   /**
    * Adds any necessary {@code initialize} methods to the component and adds calls to them to the
    * given {@code callingMethod}.
@@ -570,52 +344,23 @@ private void addInitializeMethods(
   }
 
   /**
-   * Returns the parameters for the constructor or {@code configureInitilization} method as a map
-   * from the requirement the parameter fulfills to the spec for the parameter.
+   * Returns the parameters for the constructor as a map from the requirement the parameter fulfills
+   * to the spec for the parameter.
    */
   private final ImmutableMap<ComponentRequirement, ParameterSpec> initializationParameters() {
     Map<ComponentRequirement, ParameterSpec> parameters;
     if (componentImplementation.componentDescriptor().hasCreator()) {
-      parameters =
-          Maps.toMap(componentImplementation.requirements(), ComponentRequirement::toParameterSpec);
-    } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
-      // If we're generating an abstract inner subcomponent, then we are not implementing module
-      // instance bindings and have no need for factory method parameters.
-      parameters = ImmutableMap.of();
+      parameters = Maps.toMap(graph.componentRequirements(), ComponentRequirement::toParameterSpec);
     } else if (graph.factoryMethod().isPresent()) {
       parameters = getFactoryMethodParameters(graph);
-    } else if (componentImplementation.isAbstract()) {
-      // If we're generating an abstract base implementation of a subcomponent it's acceptable to
-      // have neither a creator nor factory method.
-      parameters = ImmutableMap.of();
     } else {
       throw new AssertionError(
           "Expected either a component creator or factory method but found neither.");
     }
 
-    if (componentImplementation.isAbstract()) {
-      parameters = Maps.filterKeys(parameters, in(configureInitializationRequirements()));
-    }
     return renameParameters(parameters);
   }
 
-  /**
-   * Returns the set of requirements for the configureInitialization method: the parameters that are
-   * needed either for initializing a component requirement field or for calling the superclass's
-   * {@code configureInitialization} method.
-   */
-  private ImmutableSet<ComponentRequirement> configureInitializationRequirements() {
-    ImmutableSet<ComponentRequirement> initializationParameters =
-        componentImplementation.getComponentRequirementParameters();
-    ImmutableSet<ComponentRequirement> superConfigureInitializationRequirements =
-        componentImplementation
-            .superConfigureInitializationMethod()
-            .map(ConfigureInitializationMethod::parameters)
-            .orElse(ImmutableSet.of());
-    return Sets.union(initializationParameters, superConfigureInitializationRequirements)
-        .immutableCopy();
-  }
-
   /**
    * Renames the given parameters to guarantee their names do not conflict with fields in the
    * component to ensure that a parameter is never referenced where a reference to a field was
@@ -646,9 +391,7 @@ private ParameterSpec renameParameter(ParameterSpec parameter, String newName) {
   /** Builds a root component implementation. */
   static final class RootComponentImplementationBuilder extends ComponentImplementationBuilder {
     @Inject
-    RootComponentImplementationBuilder(ComponentImplementation componentImplementation) {
-      checkArgument(!componentImplementation.superclassImplementation().isPresent());
-    }
+    RootComponentImplementationBuilder() {}
 
     @Override
     protected void addCreatorClass(TypeSpec creator) {
@@ -694,8 +437,7 @@ protected void addFactoryMethods() {
             methodBuilder("create")
                 .returns(ClassName.get(super.graph.componentTypeElement()))
                 .addModifiers(PUBLIC, STATIC)
-                .addStatement(
-                    "return new $L().$L()", creatorKind.typeName(), factoryMethodName)
+                .addStatement("return new $L().$L()", creatorKind.typeName(), factoryMethodName)
                 .build());
       }
     }
@@ -717,10 +459,8 @@ private ClassName componentCreatorName() {
   }
 
   /**
-   * Builds a subcomponent implementation. If generating ahead-of-time subcomponents, this may be an
-   * abstract base class implementation, an abstract inner implementation, or a concrete
-   * implementation that extends an abstract base implementation. Otherwise it represents a private,
-   * inner, concrete, final implementation of a subcomponent which extends a user defined type.
+   * Builds a subcomponent implementation. Represents a private, inner, concrete, final
+   * implementation of a subcomponent which extends a user defined type.
    */
   static final class SubcomponentImplementationBuilder extends ComponentImplementationBuilder {
     final Optional<ComponentImplementationBuilder> parent;
@@ -743,12 +483,7 @@ protected void addCreatorClass(TypeSpec creator) {
 
     @Override
     protected void addFactoryMethods() {
-      // Only construct instances of subcomponents that have concrete implementations.
-      if (!componentImplementation.isAbstract()) {
-        // Use the parent's factory method to create this subcomponent if the
-        // subcomponent was not added via {@link dagger.Module#subcomponents()}.
-        graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
-      }
+      graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
     }
 
     private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
@@ -768,26 +503,6 @@ private DeclaredType parentType() {
       return asDeclared(parent.get().graph.componentTypeElement().asType());
     }
 
-    @Override
-    protected void addInterfaceMethods() {
-      if (componentImplementation.superclassImplementation().isPresent()) {
-        // Since we're overriding a subcomponent implementation we add to its implementation given
-        // an expanded binding graph.
-
-        ComponentImplementation superclassImplementation =
-            componentImplementation.superclassImplementation().get();
-        for (ModifiableBindingMethod superclassModifiableBindingMethod :
-            superclassImplementation.getModifiableBindingMethods().values()) {
-          bindingExpressions
-              .modifiableBindingExpressions()
-              .possiblyReimplementedMethod(superclassModifiableBindingMethod)
-              .ifPresent(componentImplementation::addImplementedModifiableBindingMethod);
-        }
-      } else {
-        super.addInterfaceMethods();
-      }
-    }
-
     @Override
     protected Optional<CodeBlock> cancelParentStatement() {
       if (!shouldPropagateCancellationToParent()) {
@@ -816,8 +531,8 @@ private boolean shouldPropagateCancellationToParent() {
   }
 
   /**
-   * Returns the map of {@link ComponentRequirement}s to {@link ParameterSpec}s for the
-   * given graph's factory method.
+   * Returns the map of {@link ComponentRequirement}s to {@link ParameterSpec}s for the given
+   * graph's factory method.
    */
   private static Map<ComponentRequirement, ParameterSpec> getFactoryMethodParameters(
       BindingGraph graph) {
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 9578ece0e..13de2f473 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -16,18 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static javax.tools.Diagnostic.Kind.WARNING;
 
-import com.squareup.javapoet.ClassName;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import dagger.internal.codegen.serialization.ProtoSerialization.InconsistentSerializedProtoException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
-import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.element.TypeElement;
@@ -38,36 +32,20 @@
   private final Map<TypeElement, ComponentImplementation> topLevelComponentCache = new HashMap<>();
   private final KeyFactory keyFactory;
   private final CompilerOptions compilerOptions;
-  private final BindingGraphFactory bindingGraphFactory;
   private final TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder;
-  private final DeserializedComponentImplementationBuilder
-      deserializedComponentImplementationBuilder;
-  private final DaggerElements elements;
-  private final Messager messager;
 
   @Inject
   ComponentImplementationFactory(
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
-      BindingGraphFactory bindingGraphFactory,
-      TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder,
-      DeserializedComponentImplementationBuilder deserializedComponentImplementationBuilder,
-      DaggerElements elements,
-      Messager messager) {
+      TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder) {
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
-    this.bindingGraphFactory = bindingGraphFactory;
     this.topLevelImplementationComponentBuilder = topLevelImplementationComponentBuilder;
-    this.deserializedComponentImplementationBuilder = deserializedComponentImplementationBuilder;
-    this.elements = elements;
-    this.messager = messager;
   }
 
   /**
    * Returns a top-level (non-nested) component implementation for a binding graph.
-   *
-   * @throws IllegalStateException if the binding graph is for a subcomponent and
-   *     ahead-of-time-subcomponents mode is not enabled
    */
   ComponentImplementation createComponentImplementation(BindingGraph bindingGraph) {
     return reentrantComputeIfAbsent(
@@ -97,62 +75,7 @@ private ComponentImplementation createComponentImplementationUncached(BindingGra
             .parentRequirementExpressions(Optional.empty())
             .build();
 
-    if (componentImplementation.isAbstract()) {
-      checkState(
-          compilerOptions.aheadOfTimeSubcomponents(),
-          "Calling 'componentImplementation()' on %s when not generating ahead-of-time "
-              + "subcomponents.",
-          bindingGraph.componentTypeElement());
-      return currentImplementationSubcomponent.subcomponentBuilder().build();
-    } else {
-      return currentImplementationSubcomponent.rootComponentBuilder().build();
-    }
-  }
-
-  /** Returns the superclass of the child nested within a superclass of the parent component. */
-  ComponentImplementation findChildSuperclassImplementation(
-      ComponentDescriptor child, ComponentImplementation parentImplementation) {
-    // If the current component has superclass implementations, a superclass may contain a
-    // reference to the child. Traverse this component's superimplementation hierarchy looking for
-    // the child's implementation. The child superclass implementation may not be present in the
-    // direct superclass implementations if the subcomponent builder was previously a pruned
-    // binding.
-    for (Optional<ComponentImplementation> parent = parentImplementation.superclassImplementation();
-        parent.isPresent();
-        parent = parent.get().superclassImplementation()) {
-      Optional<ComponentImplementation> superclass = parent.get().childImplementation(child);
-      if (superclass.isPresent()) {
-        return superclass.get();
-      }
-    }
-
-    if (compilerOptions.emitModifiableMetadataAnnotations()) {
-      ClassName childSuperclassName = componentName(child.typeElement());
-      TypeElement generatedChildSuperclassImplementation =
-          elements.getTypeElement(childSuperclassName);
-      if (generatedChildSuperclassImplementation != null) {
-        try {
-          return deserializedComponentImplementationBuilder.create(
-              child, generatedChildSuperclassImplementation);
-        } catch (InconsistentSerializedProtoException e) {
-          messager.printMessage(
-              WARNING,
-              String.format(
-                  "%s was compiled with a different version of Dagger than the version in this "
-                      + "compilation. To ensure the validity of Dagger's generated code, compile "
-                      + "all Dagger code with the same version.",
-                  child.typeElement().getQualifiedName()));
-        }
-      } else if (compilerOptions.forceUseSerializedComponentImplementations()) {
-        throw new TypeNotPresentException(childSuperclassName.toString(), null);
-      }
-    }
-
-    // Otherwise, the superclass implementation is top-level, so we must recreate the
-    // implementation object for the base implementation of the child by truncating the binding
-    // graph at the child.
-    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(child, false);
-    return createComponentImplementation(truncatedBindingGraph);
+    return currentImplementationSubcomponent.rootComponentBuilder().build();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 645c94f63..8643ab010 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import java.lang.annotation.Annotation;
 import java.util.HashMap;
@@ -135,7 +136,7 @@ private void processRootComponent(TypeElement component) {
     if (!isValid(componentDescriptor)) {
       return;
     }
-    if (!isFullBindingGraphValid(componentDescriptor)) {
+    if (!validateFullBindingGraph(componentDescriptor)) {
       return;
     }
     BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, false);
@@ -145,8 +146,7 @@ private void processRootComponent(TypeElement component) {
   }
 
   private void processSubcomponent(TypeElement subcomponent) {
-    if (!compilerOptions.aheadOfTimeSubcomponents()
-        && compilerOptions.fullBindingGraphValidationType(subcomponent).equals(NONE)) {
+    if (compilerOptions.fullBindingGraphValidationType(subcomponent).equals(NONE)) {
       return;
     }
     if (!isSubcomponentValid(subcomponent)) {
@@ -155,15 +155,7 @@ private void processSubcomponent(TypeElement subcomponent) {
     ComponentDescriptor subcomponentDescriptor =
         componentDescriptorFactory.subcomponentDescriptor(subcomponent);
     // TODO(dpb): ComponentDescriptorValidator for subcomponents, as we do for root components.
-    if (!isFullBindingGraphValid(subcomponentDescriptor)) {
-      return;
-    }
-    if (compilerOptions.aheadOfTimeSubcomponents()) {
-      BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor, false);
-      if (isValid(bindingGraph)) {
-        generateComponent(bindingGraph);
-      }
-    }
+    validateFullBindingGraph(subcomponentDescriptor);
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
@@ -233,7 +225,8 @@ private boolean isSubcomponentValid(Element subcomponentElement) {
     return subcomponentReport == null || subcomponentReport.isClean();
   }
 
-  private boolean isFullBindingGraphValid(ComponentDescriptor componentDescriptor) {
+  @CanIgnoreReturnValue
+  private boolean validateFullBindingGraph(ComponentDescriptor componentDescriptor) {
     if (compilerOptions
         .fullBindingGraphValidationType(componentDescriptor.typeElement())
         .equals(NONE)) {
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 541a4ab10..84ccb9afe 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -175,10 +175,6 @@ Builder testingPlugins(
           bindsInstanceProcessingStep,
           moduleProcessingStep,
           compilerOptions.headerCompilation()
-                  // Ahead Of Time subcomponents use the regular hjar filtering in
-                  // HjarSourceFileGenerator since they must retain protected implementation methods
-                  // between subcomponents
-                  && !compilerOptions.aheadOfTimeSubcomponents()
               ? componentHjarProcessingStep
               : componentProcessingStep,
           bindingMethodProcessingStep);
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 3bed5da57..71e2d586e 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -36,8 +36,6 @@
 import dagger.Provides;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.internal.codegen.serialization.ComponentRequirementProto;
-import dagger.internal.codegen.serialization.ComponentRequirementProto.BoundInstanceRequirement;
 import dagger.model.BindingKind;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
@@ -187,29 +185,6 @@ ParameterSpec toParameterSpec() {
     return ParameterSpec.builder(TypeName.get(type()), variableName()).build();
   }
 
-  /** Creates a proto representation of this requirement. */
-  ComponentRequirementProto toProto() {
-    switch (kind()) {
-      case DEPENDENCY:
-        return ComponentRequirementProto.newBuilder()
-            .setDependency(TypeProtoConverter.toProto(type()))
-            .build();
-      case MODULE:
-        return ComponentRequirementProto.newBuilder()
-            .setModule(TypeProtoConverter.toProto(type()))
-            .build();
-      case BOUND_INSTANCE:
-        return ComponentRequirementProto.newBuilder()
-            .setBoundInstance(
-                BoundInstanceRequirement.newBuilder()
-                    .setKey(KeyFactory.toProto(key().get()))
-                    .setNullable(overrideNullPolicy().equals(Optional.of(NullPolicy.ALLOW)))
-                    .setVariableName(variableName()))
-            .build();
-    }
-    throw new AssertionError(this);
-  }
-
   static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index 4ab58c926..b51baa55d 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -16,25 +16,18 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Suppliers.memoize;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
 import static dagger.internal.codegen.ModuleProxies.newModuleInstance;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
 
 import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import java.util.HashMap;
@@ -59,7 +52,6 @@
       componentRequirementExpressions = new HashMap<>();
   private final BindingGraph graph;
   private final ComponentImplementation componentImplementation;
-  private final CompilerOptions compilerOptions;
   private final DaggerElements elements;
 
   // TODO(ronshapiro): give ComponentImplementation a graph() method
@@ -68,12 +60,10 @@
       @ParentComponent Optional<ComponentRequirementExpressions> parent,
       BindingGraph graph,
       ComponentImplementation componentImplementation,
-      CompilerOptions compilerOptions,
       DaggerElements elements) {
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
-    this.compilerOptions = compilerOptions;
     this.elements = elements;
   }
 
@@ -101,31 +91,16 @@ CodeBlock getExpressionDuringInitialization(
   ComponentRequirementExpression getExpression(ComponentRequirement componentRequirement) {
     if (graph.componentRequirements().contains(componentRequirement)) {
       return componentRequirementExpressions.computeIfAbsent(
-          componentRequirement, this::createMethodOrField);
+          componentRequirement, this::createField);
     }
     if (parent.isPresent()) {
       return parent.get().getExpression(componentRequirement);
     }
 
-    if (componentRequirement.kind().isModule() && compilerOptions.aheadOfTimeSubcomponents()) {
-      return new PrunedModifiableModule(componentRequirement);
-    }
-
     throw new IllegalStateException(
         "no component requirement expression found for " + componentRequirement);
   }
 
-  /**
-   * If {@code requirement} is a module that may be owned by a future ancestor component, returns a
-   * modifiable module method. Otherwise, returns a field for {@code requirement}.
-   */
-  private ComponentRequirementExpression createMethodOrField(ComponentRequirement requirement) {
-    if (componentImplementation.isAbstract() && requirement.kind().isModule()) {
-      return new ModifiableModule(requirement);
-    }
-    return createField(requirement);
-  }
-
   /** Returns a field for a {@link ComponentRequirement}. */
   private ComponentRequirementExpression createField(ComponentRequirement requirement) {
     if (componentImplementation.componentDescriptor().hasCreator()) {
@@ -180,12 +155,8 @@ private MemberSelect addField() {
     }
 
     private FieldSpec createField() {
-      FieldSpec.Builder field =
-          FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE);
-      if (!componentImplementation.isAbstract()) {
-        field.addModifiers(FINAL);
-      }
-      return field.build();
+      return FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE, FINAL)
+          .build();
     }
 
     /** Returns the {@link CodeBlock} that initializes the component field during construction. */
@@ -227,7 +198,6 @@ private ComponentParameterField(
         ComponentImplementation componentImplementation,
         Optional<String> name) {
       super(componentRequirement, componentImplementation);
-      componentImplementation.addComponentRequirementParameter(componentRequirement);
       // Get the name that the component implementation will use for its parameter for the
       // requirement. If the given name is different than the name of the field created for the
       // requirement (as may be the case when the parameter name is derived from a user-written
@@ -258,77 +228,4 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
       return CodeBlock.of("this.$N = $L;", componentField, parameterName);
     }
   }
-
-  private final class ModifiableModule implements ComponentRequirementExpression {
-    private final ComponentRequirement module;
-    private final Supplier<MemberSelect> method = Suppliers.memoize(this::methodSelect);
-
-    private ModifiableModule(ComponentRequirement module) {
-      checkArgument(module.kind().isModule());
-      this.module = module;
-    }
-
-    @Override
-    public CodeBlock getExpression(ClassName requestingClass) {
-      return method.get().getExpressionFor(requestingClass);
-    }
-
-    private MemberSelect methodSelect() {
-      String methodName =
-          componentImplementation
-              .supertypeModifiableModuleMethodName(module)
-              .orElseGet(this::createMethod);
-      return MemberSelect.localMethod(componentImplementation.name(), methodName);
-    }
-
-    private String createMethod() {
-      String methodName =
-          UPPER_CAMEL.to(
-              LOWER_CAMEL,
-              componentImplementation.getUniqueMethodName(
-                  module.typeElement().getSimpleName().toString()));
-      MethodSpec.Builder methodBuilder =
-          methodBuilder(methodName)
-              .addModifiers(PROTECTED)
-              .returns(TypeName.get(module.type()));
-      // TODO(b/117833324): if the module is instantiable, we could provide an implementation here
-      // too. Then, if no ancestor ever repeats the module, there's nothing to do in subclasses.
-      if (graph.componentDescriptor().creatorDescriptor().isPresent()) {
-        methodBuilder.addStatement(
-            "return $L",
-            createField(module).getExpression(componentImplementation.name()));
-      } else {
-        methodBuilder.addModifiers(ABSTRACT);
-      }
-      componentImplementation.addModifiableModuleMethod(module, methodBuilder.build());
-      return methodName;
-    }
-  }
-
-  private static final class PrunedModifiableModule implements ComponentRequirementExpression {
-    private final ComponentRequirement module;
-
-    private PrunedModifiableModule(ComponentRequirement module) {
-      checkArgument(module.kind().isModule());
-      this.module = module;
-    }
-
-    @Override
-    public CodeBlock getExpression(ClassName requestingClass) {
-      throw new UnsupportedOperationException(module + " is pruned - it cannot be requested");
-    }
-
-    @Override
-    public CodeBlock getModifiableModuleMethodExpression(ClassName requestingClass) {
-      return CodeBlock.builder()
-          .add(
-              "// $L has been pruned from the final resolved binding graph. The result of this "
-                  + "method should never be used, but it may be called in an initialize() method "
-                  + "when creating a framework instance of a now-pruned binding. Those framework "
-                  + "instances should never be used.\n",
-              module.typeElement())
-          .add("return null")
-          .build();
-    }
-  }
 }
diff --git a/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java b/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
index c78d60d87..361e5a123 100644
--- a/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
+++ b/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
@@ -27,7 +27,7 @@
  * ComponentImplementation} instance. Each child {@link ComponentImplementation} will have its own
  * instance of {@link CurrentImplementationSubcomponent}.
  */
-@Subcomponent(modules = GenerationOptionsModule.class)
+@Subcomponent
 @PerComponentImplementation
 interface CurrentImplementationSubcomponent {
   RootComponentImplementationBuilder rootComponentBuilder();
diff --git a/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java b/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
deleted file mode 100644
index c41cf2c22..000000000
--- a/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import java.util.Optional;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link ModifiableAbstractMethodBindingExpression} for a binding that exists but is not ready to
- * be expressed in this compilation unit and should be deferred until a future compilation.
- * Generates a method that will be implemented in the future compilation.
- *
- * <p>A deferred modifiable binding expression is used when:
- *
- * <ul>
- *   <li>The generated code for a binding requires an instance of a type that is generated in the
- *       root component compilation unit.
- *   <li>A {@linkplain ModifiableBindingType#BINDS_METHOD_WITH_MISSING_DEPENDENCY {@code @Binds}
- *       method's dependency is missing} in a subcomponent.
- * </ul>
- */
-final class DeferredModifiableBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final ComponentImplementation componentImplementation;
-  private final ContributionBinding binding;
-  private final BindingRequest request;
-
-  DeferredModifiableBindingExpression(
-      ComponentImplementation componentImplementation,
-      ModifiableBindingType modifiableBindingType,
-      ContributionBinding binding,
-      BindingRequest request,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      DaggerTypes types) {
-    super(
-        componentImplementation,
-        modifiableBindingType,
-        request,
-        matchingModifiableBindingMethod,
-        matchingComponentMethod,
-        types);
-    this.componentImplementation = checkNotNull(componentImplementation);
-    this.binding = checkNotNull(binding);
-    this.request = checkNotNull(request);
-  }
-
-  @Override
-  String chooseMethodName() {
-    return componentImplementation.getUniqueMethodName(request);
-  }
-
-  @Override
-  protected TypeMirror contributedType() {
-    return binding.contributedType();
-  }
-}
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 4f2f622ea..b54579464 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
@@ -26,7 +25,6 @@
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import javax.lang.model.type.TypeMirror;
 
 /** A binding expression that depends on a framework instance. */
 final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
@@ -64,19 +62,6 @@ Expression getDependencyExpressionForComponentMethod(
     Expression frameworkInstance =
         componentBindingExpressions.getDependencyExpressionForComponentMethod(
             frameworkRequest, componentMethod, component);
-    Expression forRequestKind = frameworkType.to(requestKind, frameworkInstance, types);
-    TypeMirror rawReturnType = types.erasure(componentMethod.resolvedReturnType(types));
-    if (!types.isAssignable(forRequestKind.type(), rawReturnType)) {
-      checkState(
-          component.isAbstract(),
-          "FrameworkType.to() should always return an accessible type unless we're in "
-              + "ahead-of-time mode, where the framework instance type is erased since it's not "
-              + "publicly accessible, but the return type is accessible to the package. "
-              + "\n  Component: %s, method: %s",
-          component.name(),
-          componentMethod);
-      return forRequestKind.castTo(rawReturnType);
-    }
-    return forRequestKind;
+    return frameworkType.to(requestKind, frameworkInstance, types);
   }
 }
diff --git a/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java b/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java
deleted file mode 100644
index 45e99a8d4..000000000
--- a/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
-import static dagger.internal.codegen.serialization.ProtoSerialization.fromAnnotationValue;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.ComponentDefinitionType;
-import dagger.internal.ConfigureInitializationParameters;
-import dagger.internal.ModifiableBinding;
-import dagger.internal.ModifiableModule;
-import dagger.internal.codegen.ComponentImplementation.ConfigureInitializationMethod;
-import dagger.internal.codegen.serialization.BindingRequestProto;
-import dagger.internal.codegen.serialization.ComponentRequirementProto;
-import dagger.internal.codegen.serialization.FrameworkTypeWrapper;
-import dagger.internal.codegen.serialization.KeyProto;
-import dagger.model.Key;
-import dagger.model.RequestKind;
-import java.util.Optional;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Reconstructs {@link ComponentImplementation}s that have already been compiled. Uses metadata
- * annotations on the generated type and it's methods to reconstitute the equivalent {@link
- * ComponentImplementation} state.
- */
-final class DeserializedComponentImplementationBuilder {
-  private final CompilerOptions compilerOptions;
-  private final ComponentCreatorImplementationFactory componentCreatorImplementationFactory;
-  private final TypeProtoConverter typeProtoConverter;
-  private final KeyFactory keyFactory;
-
-  @Inject
-  DeserializedComponentImplementationBuilder(
-      CompilerOptions compilerOptions,
-      ComponentCreatorImplementationFactory componentCreatorImplementationFactory,
-      TypeProtoConverter typeProtoConverter,
-      KeyFactory keyFactory) {
-    this.compilerOptions = compilerOptions;
-    this.componentCreatorImplementationFactory = componentCreatorImplementationFactory;
-    this.typeProtoConverter = typeProtoConverter;
-    this.keyFactory = keyFactory;
-  }
-
-  /** Creates a new {@link ComponentImplementation} from a compiled component. */
-  ComponentImplementation create(ComponentDescriptor component, TypeElement generatedComponent) {
-    Optional<ComponentImplementation> superclassImplementation =
-        deserializedSuperclassImplementation(
-            component, MoreTypes.asTypeElement(generatedComponent.getSuperclass()));
-
-    ComponentImplementation componentImplementation =
-        ComponentImplementation.forDeserializedComponent(
-            component,
-            ClassName.get(generatedComponent),
-            generatedComponent.getNestingKind(),
-            superclassImplementation,
-            compilerOptions);
-
-    componentImplementation.setCreatorImplementation(
-        superclassImplementation.isPresent()
-            ? Optional.empty()
-            : componentCreatorImplementationFactory.create(
-                componentImplementation, Optional.empty()));
-
-    // TODO(b/117833324): Consider omitting superclass implementations, so that only one instance of
-    // ComponentImplementation needs to be created (in most cases, we don't care about nested levels
-    // of superclass implementations, except for the base implementation). If that's possible, use
-    // getLocalAndInheritedMethods instead of getEnclosedElements() here.
-    for (ExecutableElement method : methodsIn(generatedComponent.getEnclosedElements())) {
-      getAnnotationMirror(method, ModifiableBinding.class)
-          .asSet()
-          .forEach(
-              annotation ->
-                  addModifiableBindingMethod(componentImplementation, method, annotation));
-
-      getAnnotationMirror(method, ModifiableModule.class)
-          .asSet()
-          .forEach(
-              annotation -> addModifiableModuleMethod(componentImplementation, method, annotation));
-
-      getAnnotationMirror(method, ConfigureInitializationParameters.class)
-          .asSet()
-          .forEach(
-              annotation ->
-                  setConfigureInitializationMethod(componentImplementation, method, annotation));
-    }
-
-    for (TypeElement nestedType : typesIn(generatedComponent.getEnclosedElements())) {
-      addChildImplementation(component, componentImplementation, nestedType);
-    }
-
-    return componentImplementation;
-  }
-
-  private Optional<ComponentImplementation> deserializedSuperclassImplementation(
-      ComponentDescriptor component, TypeElement superclassElement) {
-    return isAnnotationPresent(superclassElement, ComponentDefinitionType.class)
-        ? Optional.of(create(component, superclassElement))
-        : Optional.empty();
-  }
-
-  private void addModifiableBindingMethod(
-      ComponentImplementation componentImplementation,
-      ExecutableElement method,
-      AnnotationMirror metadataAnnotation) {
-    ModifiableBindingType modifiableBindingType =
-        ModifiableBindingType.valueOf(
-            getAnnotationValue(metadataAnnotation, "modifiableBindingType").getValue().toString());
-
-    BindingRequest request =
-        parseBindingRequest(getAnnotationValue(metadataAnnotation, "bindingRequest"));
-
-    ImmutableList<Key> multibindingContributions =
-        asAnnotationValues(getAnnotationValue(metadataAnnotation, "multibindingContributions"))
-            .stream()
-            .map(this::parseKey)
-            .collect(toImmutableList());
-
-    componentImplementation.addModifiableBindingMethod(
-        modifiableBindingType,
-        request,
-        method.getReturnType(),
-        methodDeclaration(method),
-        method.getModifiers().contains(FINAL));
-    componentImplementation.registerImplementedMultibindingKeys(request, multibindingContributions);
-  }
-
-  private BindingRequest fromProto(BindingRequestProto bindingRequest) {
-    Key key = keyFactory.fromProto(bindingRequest.getKey());
-    return bindingRequest.getFrameworkType().equals(FrameworkTypeWrapper.FrameworkType.UNKNOWN)
-        ? bindingRequest(key, RequestKind.valueOf(bindingRequest.getRequestKind().name()))
-        : bindingRequest(key, FrameworkType.valueOf(bindingRequest.getFrameworkType().name()));
-  }
-
-  /**
-   * Returns a {@link MethodSpec} for a {@link
-   * dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod}. The method contents
-   * are not relevant since this represents a method that has already been compiled.
-   *
-   * <p>Ideally this could be {@code MethodSpec.overriding(method).build()}, but that doesn't work
-   * for {@code final} methods
-   */
-  private MethodSpec methodDeclaration(ExecutableElement method) {
-    return methodBuilder(method.getSimpleName().toString())
-        .addModifiers(method.getModifiers())
-        .returns(TypeName.get(method.getReturnType()))
-        .build();
-  }
-
-  private void addModifiableModuleMethod(
-      ComponentImplementation componentImplementation,
-      ExecutableElement method,
-      AnnotationMirror metadataAnnotation) {
-    ComponentRequirement moduleRequirement =
-        parseComponentRequirement(getAnnotationValue(metadataAnnotation, "value"));
-    componentImplementation.registerModifiableModuleMethod(
-        moduleRequirement, method.getSimpleName().toString());
-  }
-
-  private void setConfigureInitializationMethod(
-      ComponentImplementation componentImplementation,
-      ExecutableElement method,
-      AnnotationMirror metadataAnnotation) {
-    ImmutableSet<ComponentRequirement> parameters =
-        asAnnotationValues(getAnnotationValue(metadataAnnotation, "value")).stream()
-            .map(this::parseComponentRequirement)
-            .collect(toImmutableSet());
-
-    componentImplementation.setConfigureInitializationMethod(
-        ConfigureInitializationMethod.create(MethodSpec.overriding(method).build(), parameters));
-  }
-
-  private void addChildImplementation(
-      ComponentDescriptor component,
-      ComponentImplementation componentImplementation,
-      TypeElement nestedType) {
-    getAnnotationMirror(nestedType, ComponentDefinitionType.class)
-        .transform(annotation -> (TypeMirror) getAnnotationValue(annotation, "value").getValue())
-        .transform(MoreTypes::asTypeElement)
-        .asSet()
-        .forEach(
-            componentDefinitionType -> {
-              ComponentDescriptor child =
-                  component.childComponentsByElement().get(componentDefinitionType);
-              componentImplementation.addChild(child, create(child, nestedType));
-            });
-  }
-
-  private Key parseKey(AnnotationValue annotationValue) {
-    return keyFactory.fromProto(
-        fromAnnotationValue(annotationValue, KeyProto.getDefaultInstance()));
-  }
-
-  private BindingRequest parseBindingRequest(AnnotationValue annotationValue) {
-    return fromProto(
-        fromAnnotationValue(annotationValue, BindingRequestProto.getDefaultInstance()));
-  }
-
-  private ComponentRequirement parseComponentRequirement(AnnotationValue annotationValue) {
-    return fromProto(
-        fromAnnotationValue(annotationValue, ComponentRequirementProto.getDefaultInstance()));
-  }
-
-  private ComponentRequirement fromProto(ComponentRequirementProto proto) {
-    switch (proto.getRequirementCase()) {
-      case MODULE:
-        return ComponentRequirement.forModule(typeProtoConverter.fromProto(proto.getModule()));
-      case DEPENDENCY:
-        return ComponentRequirement.forDependency(
-            typeProtoConverter.fromProto(proto.getDependency()));
-      case BOUND_INSTANCE:
-        return ComponentRequirement.forBoundInstance(
-            keyFactory.fromProto(proto.getBoundInstance().getKey()),
-            proto.getBoundInstance().getNullable(),
-            proto.getBoundInstance().getVariableName());
-      case REQUIREMENT_NOT_SET:
-        // fall through
-    }
-    throw new AssertionError(proto);
-  }
-}
diff --git a/java/dagger/internal/codegen/ForwardingCompilerOptions.java b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
index 4a1deda59..5442f4d2f 100644
--- a/java/dagger/internal/codegen/ForwardingCompilerOptions.java
+++ b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
@@ -85,21 +85,6 @@ boolean headerCompilation() {
     return delegate.headerCompilation();
   }
 
-  @Override
-  boolean aheadOfTimeSubcomponents() {
-    return delegate.aheadOfTimeSubcomponents();
-  }
-
-  @Override
-  boolean forceUseSerializedComponentImplementations() {
-    return delegate.forceUseSerializedComponentImplementations();
-  }
-
-  @Override
-  boolean emitModifiableMetadataAnnotations() {
-    return delegate.emitModifiableMetadataAnnotations();
-  }
-
   @Override
   boolean useGradleIncrementalProcessing() {
     return delegate.useGradleIncrementalProcessing();
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index a3de08353..c0a555281 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -101,8 +101,7 @@ private void initializeField() {
         CodeBlock fieldInitialization = frameworkInstanceCreationExpression.creationExpression();
         CodeBlock initCode = CodeBlock.of("this.$N = $L;", getOrCreateField(), fieldInitialization);
 
-        if (isReplacingSuperclassFrameworkInstance()
-            || fieldInitializationState == InitializationState.DELEGATED) {
+        if (fieldInitializationState == InitializationState.DELEGATED) {
           codeBuilder.add(
               "$T.setDelegate($N, $L);", delegateType(), fieldSpec, fieldInitialization);
         } else {
@@ -150,38 +149,12 @@ private FieldSpec getOrCreateField() {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
 
-    if (isReplacingSuperclassFrameworkInstance()) {
-      // If a binding is modified in a subclass, the framework instance will be replaced in the
-      // subclass implementation. The superclass framework instance initialization will run first,
-      // however, and may refer to the modifiable binding method returning this type's modified
-      // framework instance before it is initialized, so we use a delegate factory as a placeholder
-      // until it has properly been initialized.
-      contributionField.initializer("new $T<>()", delegateType());
-    }
-
     fieldSpec = contributionField.build();
     componentImplementation.addField(FRAMEWORK_FIELD, fieldSpec);
 
     return fieldSpec;
   }
 
-  /**
-   * Returns true if this framework field is replacing a superclass's implementation of the
-   * framework field.
-   */
-  private boolean isReplacingSuperclassFrameworkInstance() {
-    return componentImplementation
-        .superclassImplementation()
-        .flatMap(
-            superclassImplementation ->
-                // TODO(b/117833324): can we constrain this further?
-                superclassImplementation.getModifiableBindingMethod(
-                    BindingRequest.bindingRequest(
-                        resolvedBindings.key(),
-                        isProvider() ? FrameworkType.PROVIDER : FrameworkType.PRODUCER_NODE)))
-        .isPresent();
-  }
-
   private Class<?> delegateType() {
     return isProvider() ? DelegateFactory.class : DelegateProducer.class;
   }
diff --git a/java/dagger/internal/codegen/GenerationCompilerOptions.java b/java/dagger/internal/codegen/GenerationCompilerOptions.java
deleted file mode 100644
index 1b14a7eb7..000000000
--- a/java/dagger/internal/codegen/GenerationCompilerOptions.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-/**
- * A {@link Qualifier} for bindings associated with the serialization/deserialization of {@link
- * dagger.internal.GenerationOptions}.
- */
-@Retention(RUNTIME)
-@Qualifier
-@interface GenerationCompilerOptions {}
diff --git a/java/dagger/internal/codegen/GenerationOptionsModule.java b/java/dagger/internal/codegen/GenerationOptionsModule.java
deleted file mode 100644
index aa3c46191..000000000
--- a/java/dagger/internal/codegen/GenerationOptionsModule.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.GenerationOptions;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import java.util.Optional;
-
-/** Adds bindings for serializing and rereading {@link GenerationOptions}. */
-@Module
-interface GenerationOptionsModule {
-  @Provides
-  @PerComponentImplementation
-  @GenerationCompilerOptions
-  static CompilerOptions generationOptions(
-      CompilerOptions defaultOptions,
-      ComponentImplementation componentImplementation,
-      DaggerElements elements) {
-    // Avoid looking up types that don't exist. Performance improves for large components.
-    if (!defaultOptions.aheadOfTimeSubcomponents()) {
-      return defaultOptions;
-    }
-    // Inspect the base implementation for the @GenerationOptions annotation. Even if
-    // componentImplementation is the base implementation, inspect it for the case where we are
-    // recomputing the ComponentImplementation from a previous compilation.
-    // TODO(b/117833324): consider adding a method that returns baseImplementation.orElse(this).
-    // The current state of the world is a little confusing and maybe not intuitive: the base
-    // implementation has no base implementation, but it _is_ a base implementation.
-    return Optional.of(componentImplementation.baseImplementation().orElse(componentImplementation))
-        .map(baseImplementation -> elements.getTypeElement(baseImplementation.name()))
-        // If this returns null, the type has not been generated yet and Optional will switch to an
-        // empty state. This means that we're currently generating componentImplementation, or that
-        // the base implementation is being generated in this round, and thus the options passed to
-        // this compilation are applicable
-        .map(typeElement -> typeElement.getAnnotation(GenerationOptions.class))
-        .map(defaultOptions::withGenerationOptions)
-        .orElse(defaultOptions);
-  }
-}
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index bc5b66e30..91d7991cc 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -100,21 +100,6 @@ boolean headerCompilation() {
         return false;
       }
 
-      @Override
-      boolean aheadOfTimeSubcomponents() {
-        return false;
-      }
-
-      @Override
-      boolean forceUseSerializedComponentImplementations() {
-        return false;
-      }
-
-      @Override
-      boolean emitModifiableMetadataAnnotations() {
-        return false;
-      }
-
       @Override
       boolean useGradleIncrementalProcessing() {
         return false;
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index b6ac27fca..b315cb879 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -39,7 +39,6 @@
 import dagger.BindsOptionalOf;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.internal.codegen.serialization.KeyProto;
 import dagger.model.Key;
 import dagger.model.Key.MultibindingContributionIdentifier;
 import dagger.model.RequestKind;
@@ -68,19 +67,11 @@
 final class KeyFactory {
   private final DaggerTypes types;
   private final DaggerElements elements;
-  private final TypeProtoConverter typeProtoConverter;
-  private final AnnotationProtoConverter annotationProtoConverter;
 
   @Inject
-  KeyFactory(
-      DaggerTypes types,
-      DaggerElements elements,
-      TypeProtoConverter typeProtoConverter,
-      AnnotationProtoConverter annotationProtoConverter) {
+  KeyFactory(DaggerTypes types, DaggerElements elements) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
-    this.typeProtoConverter = typeProtoConverter;
-    this.annotationProtoConverter = annotationProtoConverter;
   }
 
   private TypeMirror boxPrimitives(TypeMirror type) {
@@ -434,36 +425,4 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
             .type(extractKeyType(getRequestKind(optionalValueType), optionalValueType))
             .build());
   }
-
-  /** Translates a {@link Key} to a proto representation. */
-  static KeyProto toProto(Key key) {
-    KeyProto.Builder builder =
-        KeyProto.newBuilder().setType(TypeProtoConverter.toProto(key.type()));
-    key.qualifier().map(AnnotationProtoConverter::toProto).ifPresent(builder::setQualifier);
-    key.multibindingContributionIdentifier()
-        .ifPresent(
-            mci ->
-                builder
-                    .getMultibindingContributionIdentifierBuilder()
-                    .setModule(mci.module())
-                    .setBindingElement(mci.bindingElement()));
-    return builder.build();
-  }
-
-  /** Creates a {@link Key} from its proto representation. */
-  Key fromProto(KeyProto key) {
-    Key.Builder builder = Key.builder(typeProtoConverter.fromProto(key.getType()));
-    if (key.hasQualifier()) {
-      builder.qualifier(annotationProtoConverter.fromProto(key.getQualifier()));
-    }
-    if (key.hasMultibindingContributionIdentifier()) {
-      KeyProto.MultibindingContributionIdentifier multibindingContributionIdentifier =
-          key.getMultibindingContributionIdentifier();
-      builder.multibindingContributionIdentifier(
-          new MultibindingContributionIdentifier(
-              multibindingContributionIdentifier.getBindingElement(),
-              multibindingContributionIdentifier.getModule()));
-    }
-    return builder.build();
-  }
 }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index bc2cf4dc4..4acd3749e 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -36,12 +36,11 @@
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
-import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@link BindingExpression} for multibound maps. */
-final class MapBindingExpression extends MultibindingExpression {
+final class MapBindingExpression extends SimpleInvocationBindingExpression {
   /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
   private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
 
@@ -53,12 +52,11 @@
 
   MapBindingExpression(
       ProvisionBinding binding,
-      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(binding, componentImplementation);
+    super(binding);
     this.binding = binding;
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
@@ -72,14 +70,11 @@
   }
 
   @Override
-  protected Expression buildDependencyExpression(ClassName requestingClass) {
-    Optional<CodeBlock> superMethodCall = superMethodCall();
+  Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
-    if (isImmutableMapAvailable
-        && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS
-        && !superMethodCall.isPresent()) {
+    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
       return Expression.create(
           immutableMapType(),
           CodeBlock.builder()
@@ -115,12 +110,9 @@ protected Expression buildDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
         }
-        for (DependencyRequest dependency : getNewContributions(dependencies.keySet())) {
+        for (DependencyRequest dependency : dependencies.keySet()) {
           instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
         }
-        if (superMethodCall.isPresent()) {
-          instantiation.add(CodeBlock.of(".putAll($L)", superMethodCall.get()));
-        }
         return Expression.create(
             isImmutableMapAvailable ? immutableMapType() : binding.key().type(),
             instantiation.add(".build()").build());
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 187b792bb..e9cd1cfaf 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -70,10 +70,7 @@ public CodeBlock creationExpression() {
 
     builder.add("builder($L)", binding.dependencies().size());
 
-    superContributions()
-        .ifPresent(superContributions -> builder.add(".putAll($L)", superContributions));
-
-    for (DependencyRequest dependency : dependenciesToImplement()) {
+    for (DependencyRequest dependency : binding.dependencies()) {
       ContributionBinding contributionBinding =
           graph.contributionBindings().get(dependency.key()).contributionBinding();
       builder.add(
@@ -83,8 +80,6 @@ public CodeBlock creationExpression() {
     }
     builder.add(".build()");
 
-    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
-
     return builder.build();
   }
 }
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 2120e8063..952eae687 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
@@ -31,7 +30,6 @@
 import dagger.internal.DoubleCheck;
 import dagger.internal.MemoizedSentinel;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.RequestKind;
@@ -78,7 +76,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
       // TODO(b/121196706): use a less hacky approach to fix this bug
       Object unused = methodBody();
     }
-    
+
     addMethod();
     return Expression.create(
         returnType(),
@@ -87,28 +85,6 @@ Expression getDependencyExpression(ClassName requestingClass) {
             : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName()));
   }
 
-  @Override
-  final CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod,
-      ComponentImplementation component,
-      DaggerTypes types) {
-    // A matching modifiable binding method means that we have previously created the binding method
-    // and we are now implementing it. If there is no matching method we need to first create the
-    // method. We create the method by deferring to getDependencyExpression (defined above) via a
-    // call to super.getModifiableBindingMethodImplementation().
-    if (supertypeModifiableBindingMethod().isPresent()) {
-      checkState(
-          supertypeModifiableBindingMethod().get().fulfillsSameRequestAs(modifiableBindingMethod));
-      return methodBody();
-    }
-    return super.getModifiableBindingMethodImplementation(
-        modifiableBindingMethod, component, types);
-  }
-
-  protected final Optional<ModifiableBindingMethod> supertypeModifiableBindingMethod() {
-    return componentImplementation.supertypeModifiableBindingMethod(request);
-  }
-
   @Override
   Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor componentMethod,
       ComponentImplementation component) {
@@ -124,14 +100,6 @@ Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor c
   /** Returns the name of the method to call. */
   protected abstract String methodName();
 
-  /**
-   * Returns {@code true} if the method of this binding expression is modifiable and is not a
-   * component method.
-   */
-  protected boolean isModifiableImplementationMethod() {
-    return false;
-  }
-
   /** The method's body. */
   protected final CodeBlock methodBody() {
     return implementation(
@@ -178,15 +146,8 @@ protected TypeMirror returnType() {
       return matchingComponentMethod().get().resolvedReturnType(types);
     }
 
-    // If the component is abstract, this method may be overridden by another implementation in a
-    // different package for which requestedType is inaccessible. In order to make that method
-    // overridable, we use the publicly accessible type. If the method is private, we don't need to
-    // worry about this, and instead just need to check accessibility of the file we're about to
-    // write
     TypeMirror requestedType = request.requestedType(binding.contributedType(), types);
-    return isModifiableImplementationMethod()
-        ? types.publiclyAccessibleType(requestedType)
-        : types.accessibleType(requestedType, componentImplementation.name());
+    return types.accessibleType(requestedType, componentImplementation.name());
   }
 
   private Optional<ComponentMethodDescriptor> matchingComponentMethod() {
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
deleted file mode 100644
index 610d0525f..000000000
--- a/java/dagger/internal/codegen/MissingBindingExpression.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import java.util.Optional;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link ModifiableAbstractMethodBindingExpression} for a binding that is missing when generating
- * the abstract base class implementation of a subcomponent. The (unimplemented) method is added to
- * the {@link ComponentImplementation} when the dependency expression is requested. The method is
- * overridden when generating the implementation of an ancestor component.
- */
-final class MissingBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final ComponentImplementation componentImplementation;
-  private final BindingRequest request;
-
-  MissingBindingExpression(
-      ComponentImplementation componentImplementation,
-      BindingRequest request,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      DaggerTypes types) {
-    super(
-        componentImplementation,
-        ModifiableBindingType.MISSING,
-        request,
-        matchingModifiableBindingMethod,
-        matchingComponentMethod,
-        types);
-    this.componentImplementation = componentImplementation;
-    this.request = request;
-  }
-
-  @Override
-  String chooseMethodName() {
-    return componentImplementation.getUniqueMethodName(request);
-  }
-
-  @Override
-  protected TypeMirror contributedType() {
-    return request.key().type();
-  }
-}
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
deleted file mode 100644
index 412acae54..000000000
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PROTECTED;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.javapoet.Expression;
-import dagger.internal.codegen.langmodel.Accessibility;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import java.util.Optional;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A {@link BindingExpression} that invokes a method that encapsulates a binding that cannot be
- * satisfied when generating the abstract base class implementation of a subcomponent. The
- * (unimplemented) method is added to the {@link ComponentImplementation} when the dependency
- * expression is requested. The method is overridden when generating the implementation of an
- * ancestor component.
- */
-abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
-  private final ComponentImplementation componentImplementation;
-  private final ModifiableBindingType modifiableBindingType;
-  private final BindingRequest request;
-  private final Optional<ComponentMethodDescriptor> matchingComponentMethod;
-  private final DaggerTypes types;
-  private Optional<String> methodName;
-
-  ModifiableAbstractMethodBindingExpression(
-      ComponentImplementation componentImplementation,
-      ModifiableBindingType modifiableBindingType,
-      BindingRequest request,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      DaggerTypes types) {
-    this.componentImplementation = componentImplementation;
-    this.modifiableBindingType = modifiableBindingType;
-    this.request = request;
-    this.matchingComponentMethod = matchingComponentMethod;
-    this.types = types;
-    this.methodName =
-        initializeMethodName(matchingComponentMethod, matchingModifiableBindingMethod);
-  }
-
-  /**
-   * If this binding corresponds to an existing component method, or a known modifiable binding
-   * method, use them to initialize the method name, which is a signal to call the existing method
-   * rather than emit an abstract method.
-   */
-  private static Optional<String> initializeMethodName(
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
-    if (matchingComponentMethod.isPresent()) {
-      return Optional.of(matchingComponentMethod.get().methodElement().getSimpleName().toString());
-    }
-    if (matchingModifiableBindingMethod.isPresent()) {
-      return Optional.of(matchingModifiableBindingMethod.get().methodSpec().name);
-    }
-    return Optional.empty();
-  }
-
-  @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
-    addUnimplementedMethod();
-    return Expression.create(
-        returnType(),
-        componentImplementation.name().equals(requestingClass)
-            ? CodeBlock.of("$N()", methodName.get())
-            : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName.get()));
-  }
-
-  private void addUnimplementedMethod() {
-    if (!methodName.isPresent()) {
-      // Only add the method once in case of repeated references to the missing binding.
-      methodName = Optional.of(chooseMethodName());
-      TypeMirror returnType = returnType();
-      componentImplementation.addModifiableBindingMethod(
-          modifiableBindingType,
-          request,
-          returnType,
-          MethodSpec.methodBuilder(methodName.get())
-              .addModifiers(PROTECTED, ABSTRACT)
-              .returns(TypeName.get(returnType))
-              .build(),
-          false /* finalized */);
-    }
-  }
-
-  /**
-   * The return type of this abstract method expression:
-   *
-   * <ul>
-   *   <li>If there's a {@code matchingComponentMethod}, use its return type.
-   *   <li>Otherwise, use the {@linkplain DaggerTypes#publiclyAccessibleType(TypeMirror) publicly
-   *       accessible type} of the request. We can't use the {@linkplain
-   *       Accessibility#isTypeAccessibleFrom(TypeMirror, String) type accessible from the current
-   *       implementation's package} because a subclass implementation may be in a different package
-   *       from which the request type is not accessible.
-   * </ul>
-   */
-  private TypeMirror returnType() {
-    if (matchingComponentMethod.isPresent()) {
-      return matchingComponentMethod.get().resolvedReturnType(types);
-    }
-
-    TypeMirror requestedType = request.requestedType(contributedType(), types);
-    return types.publiclyAccessibleType(requestedType);
-  }
-
-  /**
-   * The {@link ContributionBinding#contributedType() type contributed} by the binding of this
-   * expression. For missing bindings, this will be the key type.
-   */
-  protected abstract TypeMirror contributedType();
-
-  /** Returns a unique 'getter' method name for the current component. */
-  abstract String chooseMethodName();
-}
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
deleted file mode 100644
index 76bcb8bc5..000000000
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
-import static java.util.stream.Collectors.toList;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.MethodSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentImplementation.MethodSpecKind;
-import dagger.internal.codegen.MethodBindingExpression.MethodImplementationStrategy;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.model.BindingKind;
-import dagger.model.DependencyRequest;
-import java.util.Optional;
-
-/**
- * A central repository of code expressions used to access modifiable bindings available to a
- * component. A binding is modifiable if it can be modified across implementations of a
- * subcomponent. This is only relevant for ahead-of-time subcomponents.
- */
-final class ModifiableBindingExpressions {
-  private final Optional<ModifiableBindingExpressions> parent;
-  private final ComponentBindingExpressions bindingExpressions;
-  private final BindingGraph graph;
-  private final ComponentImplementation componentImplementation;
-  private final CompilerOptions compilerOptions;
-  private final DaggerTypes types;
-
-  ModifiableBindingExpressions(
-      Optional<ModifiableBindingExpressions> parent,
-      ComponentBindingExpressions bindingExpressions,
-      BindingGraph graph,
-      ComponentImplementation componentImplementation,
-      CompilerOptions compilerOptions,
-      DaggerTypes types) {
-    this.parent = parent;
-    this.bindingExpressions = bindingExpressions;
-    this.graph = graph;
-    this.componentImplementation = componentImplementation;
-    this.compilerOptions = compilerOptions;
-    this.types = types;
-  }
-
-  /**
-   * Adds {@code method} to the component implementation. If the binding for the method is
-   * modifiable, also registers the relevant modifiable binding information.
-   */
-  void addPossiblyModifiableComponentMethod(
-      ComponentMethodDescriptor componentMethod, MethodSpec method) {
-    BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
-    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (modifiableBindingType.isModifiable()) {
-      componentImplementation.addModifiableComponentMethod(
-          modifiableBindingType,
-          request,
-          componentMethod.resolvedReturnType(types),
-          method,
-          newModifiableBindingWillBeFinalized(modifiableBindingType, request));
-    } else {
-      componentImplementation.addMethod(MethodSpecKind.COMPONENT_METHOD, method);
-    }
-  }
-
-  /**
-   * Returns the implementation of a modifiable binding method originally defined in a supertype
-   * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
-   * or should not be modified by the current binding graph.
-   */
-  Optional<ModifiableBindingMethod> possiblyReimplementedMethod(
-      ModifiableBindingMethod modifiableBindingMethod) {
-    checkState(componentImplementation.superclassImplementation().isPresent());
-    BindingRequest request = modifiableBindingMethod.request();
-    ModifiableBindingType newModifiableBindingType = getModifiableBindingType(request);
-    ModifiableBindingType oldModifiableBindingType = modifiableBindingMethod.type();
-    boolean modifiableBindingTypeChanged =
-        !newModifiableBindingType.equals(oldModifiableBindingType);
-
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    // Don't reimplement modifiable bindings that were perceived to be provision bindings in a
-    // superclass implementation but are now production bindings.
-    if ((modifiableBindingTypeChanged
-            // Optional bindings don't need the same treatment since the only transition they can
-            // make is empty -> present. In that case, the Producer<Optional<T>> will be overridden
-            // and the absentOptionalProvider() will be a dangling reference that is never attempted
-            // to be overridden.
-            || newModifiableBindingType.equals(ModifiableBindingType.MULTIBINDING))
-        && resolvedBindings != null
-        && resolvedBindings.bindingType().equals(BindingType.PRODUCTION)
-        && !request.canBeSatisfiedByProductionBinding()) {
-      return oldModifiableBindingType.hasBaseClassImplementation()
-          ? Optional.empty()
-          : Optional.of(
-              reimplementedMethod(
-                  modifiableBindingMethod,
-                  newModifiableBindingType,
-                  new PrunedConcreteMethodBindingExpression(),
-                  componentImplementation.isAbstract()));
-    }
-
-    if (modifiableBindingTypeChanged
-        && !newModifiableBindingType.hasBaseClassImplementation()
-        && (oldModifiableBindingType.hasBaseClassImplementation()
-            || componentImplementation.isAbstract())) {
-      // We don't want to override one abstract method with another one. However, If the component
-      // is not abstract (such as a transition from GENERATED_INSTANCE -> MISSING), we must provide
-      // an implementation like normal.
-      return Optional.empty();
-    }
-
-    if (modifiableBindingTypeChanged
-        || shouldModifyImplementation(newModifiableBindingType, request)) {
-      boolean markMethodFinal =
-          knownModifiableBindingWillBeFinalized(modifiableBindingMethod)
-              // no need to mark the method final if the component implementation will be final
-              && componentImplementation.isAbstract();
-      return Optional.of(
-          reimplementedMethod(
-              modifiableBindingMethod,
-              newModifiableBindingType,
-              bindingExpressions.getBindingExpression(request),
-              markMethodFinal));
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * Returns a new {@link ModifiableBindingMethod} that overrides {@code supertypeMethod} and is
-   * implemented with {@code bindingExpression}.
-   */
-  private ModifiableBindingMethod reimplementedMethod(
-      ModifiableBindingMethod supertypeMethod,
-      ModifiableBindingType newModifiableBindingType,
-      BindingExpression bindingExpression,
-      boolean markMethodFinal) {
-    MethodSpec baseMethod = supertypeMethod.methodSpec();
-    return supertypeMethod.reimplement(
-        newModifiableBindingType,
-        MethodSpec.methodBuilder(baseMethod.name)
-            .addModifiers(baseMethod.modifiers.contains(PUBLIC) ? PUBLIC : PROTECTED)
-            .addModifiers(markMethodFinal ? ImmutableSet.of(FINAL) : ImmutableSet.of())
-            .returns(baseMethod.returnType)
-            .addAnnotation(Override.class)
-            .addCode(
-                bindingExpression.getModifiableBindingMethodImplementation(
-                    supertypeMethod, componentImplementation, types))
-            .build(),
-        markMethodFinal);
-  }
-
-  /**
-   * Returns true if a modifiable binding method that was registered in a superclass implementation
-   * of this subcomponent should be marked as "finalized" if it is being overridden by this
-   * subcomponent implementation. "Finalized" means we should not attempt to modify the binding in
-   * any subcomponent subclass.
-   */
-  private boolean knownModifiableBindingWillBeFinalized(
-      ModifiableBindingMethod modifiableBindingMethod) {
-    ModifiableBindingType newModifiableBindingType =
-        getModifiableBindingType(modifiableBindingMethod.request());
-    if (!newModifiableBindingType.isModifiable()) {
-      // If a modifiable binding has become non-modifiable it is final by definition.
-      return true;
-    }
-    return modifiableBindingWillBeFinalized(
-        newModifiableBindingType,
-        shouldModifyImplementation(newModifiableBindingType, modifiableBindingMethod.request()));
-  }
-
-  /**
-   * Returns true if a newly discovered modifiable binding method, once it is defined in this
-   * subcomponent implementation, should be marked as "finalized", meaning we should not attempt to
-   * modify the binding in any subcomponent subclass.
-   */
-  private boolean newModifiableBindingWillBeFinalized(
-      ModifiableBindingType modifiableBindingType, BindingRequest request) {
-    return modifiableBindingWillBeFinalized(
-        modifiableBindingType, shouldModifyImplementation(modifiableBindingType, request));
-  }
-
-  /**
-   * Returns true if we shouldn't attempt to further modify a modifiable binding once we complete
-   * the implementation for the current subcomponent.
-   */
-  private boolean modifiableBindingWillBeFinalized(
-      ModifiableBindingType modifiableBindingType, boolean modifyingBinding) {
-    switch (modifiableBindingType) {
-      case MISSING:
-      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
-      case GENERATED_INSTANCE:
-      case OPTIONAL:
-      case INJECTION:
-        // Once we modify any of the above a single time, then they are finalized.
-        return modifyingBinding;
-      case MULTIBINDING:
-        return false;
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Building binding expression for unsupported ModifiableBindingType [%s].",
-                modifiableBindingType));
-    }
-  }
-
-  /**
-   * Creates a binding expression for a binding if it may be modified across implementations of a
-   * subcomponent.
-   */
-  Optional<BindingExpression> maybeCreateModifiableBindingExpression(BindingRequest request) {
-    ModifiableBindingType type = getModifiableBindingType(request);
-    if (!type.isModifiable()) {
-      return Optional.empty();
-    }
-    return Optional.of(createModifiableBindingExpression(type, request));
-  }
-
-  /** Creates a binding expression for a modifiable binding. */
-  private BindingExpression createModifiableBindingExpression(
-      ModifiableBindingType type, BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
-        componentImplementation.getModifiableBindingMethod(request);
-    Optional<ComponentMethodDescriptor> matchingComponentMethod =
-        graph.componentDescriptor().firstMatchingComponentMethod(request);
-    switch (type) {
-      case GENERATED_INSTANCE:
-        // If the subcomponent is abstract then we need to define an (un-implemented)
-        // DeferredModifiableBindingExpression.
-        if (componentImplementation.isAbstract()) {
-          return new DeferredModifiableBindingExpression(
-              componentImplementation,
-              type,
-              resolvedBindings.contributionBinding(),
-              request,
-              matchingModifiableBindingMethod,
-              matchingComponentMethod,
-              types);
-        }
-        // Otherwise return a concrete implementation.
-        return bindingExpressions.createBindingExpression(resolvedBindings, request);
-
-      case MISSING:
-        // If we need an expression for a missing binding and the current implementation is
-        // abstract, then we need an (un-implemented) MissingBindingExpression.
-        if (componentImplementation.isAbstract()) {
-          return new MissingBindingExpression(
-              componentImplementation,
-              request,
-              matchingModifiableBindingMethod,
-              matchingComponentMethod,
-              types);
-        }
-        // Otherwise we assume that it is valid to have a missing binding as it is part of a
-        // dependency chain that has been passively pruned.
-        // TODO(b/117833324): Identify pruned bindings when generating the subcomponent
-        // implementation in which the bindings are pruned. If we hold a reference to the binding
-        // graph used to generate a given implementation then we can compare a implementation's
-        // graph with its superclass implementation's graph to detect pruned dependency branches.
-        return new PrunedConcreteMethodBindingExpression();
-
-      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
-        checkState(componentImplementation.isAbstract());
-        return new DeferredModifiableBindingExpression(
-            componentImplementation,
-            type,
-            resolvedBindings.contributionBinding(),
-            request,
-            matchingModifiableBindingMethod,
-            matchingComponentMethod,
-            types);
-
-      case OPTIONAL:
-      case MULTIBINDING:
-      case INJECTION:
-        return bindingExpressions.wrapInMethod(
-            resolvedBindings,
-            request,
-            bindingExpressions.createBindingExpression(resolvedBindings, request));
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Building binding expression for unsupported ModifiableBindingType [%s].", type));
-    }
-  }
-
-  /**
-   * The reason why a binding may need to be modified across implementations of a subcomponent, if
-   * at all.
-   */
-  ModifiableBindingType getModifiableBindingType(BindingRequest request) {
-    if (!compilerOptions.aheadOfTimeSubcomponents()) {
-      return ModifiableBindingType.NONE;
-    }
-
-    // When generating a component the binding is not considered modifiable. Bindings are modifiable
-    // only across subcomponent implementations.
-    if (!componentImplementation.componentDescriptor().isSubcomponent()) {
-      return ModifiableBindingType.NONE;
-    }
-
-    if (request.requestKind().filter(RequestKinds::isDerivedFromProvider).isPresent()) {
-      return ModifiableBindingType.NONE;
-    }
-
-    if (resolvedInThisComponent(request)) {
-      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-      if (resolvedBindings.contributionBindings().isEmpty()) {
-        // TODO(ronshapiro): Confirm whether a resolved binding must have a single contribution
-        // binding.
-        return ModifiableBindingType.NONE;
-      }
-
-      ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (binding.requiresGeneratedInstance()) {
-        return ModifiableBindingType.GENERATED_INSTANCE;
-      }
-
-      if (binding.kind().equals(BindingKind.DELEGATE)
-          && graph
-              .contributionBindings()
-              .get(getOnlyElement(binding.dependencies()).key())
-              .isEmpty()) {
-        return ModifiableBindingType.BINDS_METHOD_WITH_MISSING_DEPENDENCY;
-      }
-
-      if (binding.kind().equals(BindingKind.OPTIONAL) && binding.dependencies().isEmpty()) {
-        // only empty optional bindings can be modified
-        return ModifiableBindingType.OPTIONAL;
-      }
-
-      if (binding.isSyntheticMultibinding()) {
-        return ModifiableBindingType.MULTIBINDING;
-      }
-
-      if (binding.kind().equals(BindingKind.INJECTION)) {
-        return ModifiableBindingType.INJECTION;
-      }
-    } else if (!resolvableBinding(request)) {
-      return ModifiableBindingType.MISSING;
-    }
-
-    return ModifiableBindingType.NONE;
-  }
-
-  /**
-   * Returns true if the current binding graph can, and should, modify a binding by overriding a
-   * modifiable binding method.
-   */
-  private boolean shouldModifyImplementation(
-      ModifiableBindingType modifiableBindingType, BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    if (request.requestKind().isPresent()) {
-      switch (request.requestKind().get()) {
-        case FUTURE:
-          // Futures backed by production bindings are always requested by a Producer.get() call, so
-          // if the binding is modifiable, the producer will be wrapped in a modifiable method and
-          // the future can refer to that  method; even if the producer binding is modified,
-          // getModifiableProducer().get() will never need to be modified. Furthermore, because
-          // cancellation is treated by wrapped producers, and those producers point to the
-          // modifiable producer wrapper methods, we never need or want to change the access of
-          // these wrapped producers for entry methods
-          //
-          // Futures backed by provision bindings are inlined and contain no wrapping producer, so
-          // if the binding is modifiable and is resolved as a provision binding in a superclass
-          // but later resolved as a production binding, we can't take the same shortcut as before.
-          Optional<ComponentImplementation> superclassImplementation =
-              componentImplementation.superclassImplementation();
-          if (superclassImplementation.isPresent()) {
-            if (superclassImplementation.get().isDeserializedImplementation()) {
-              // TODO(b/117833324): consider serializing the binding type so that we don't need to
-              // branch here. Or, instead, consider removing this optimization entirely if there
-              // aren't that many FUTURE entry point methods to justify the extra code.
-              break;
-            } else {
-              return bindingTypeChanged(request, resolvedBindings);
-            }
-          }
-          return false;
-
-        case LAZY:
-        case PROVIDER_OF_LAZY:
-          // Lazy and ProviderOfLazy are always created from a Provider, and therefore this request
-          // never needs to be modifiable. It will refer (via DoubleCheck.lazy() or
-          // ProviderOfLazy.create()) to the modifiable method and not the framework instance.
-          return false;
-
-        case MEMBERS_INJECTION:
-        case PRODUCED:
-          // MEMBERS_INJECTION has a completely different code path for binding expressions, and
-          // PRODUCED requests are only requestable in @Produces methods, which are hidden from
-          // generated components inside Producer factories
-          throw new AssertionError(request);
-
-        case INSTANCE:
-        case PROVIDER:
-        case PRODUCER:
-          // These may be modifiable, so run through the regular logic. They're spelled out
-          // explicitly so that ErrorProne will detect if a new enum value is created and missing
-          // from this list.
-          break;
-      }
-    }
-
-    switch (modifiableBindingType) {
-      case GENERATED_INSTANCE:
-        return !componentImplementation.isAbstract();
-
-      case MISSING:
-        // TODO(b/117833324): investigate beder@'s comment about having intermediate component
-        // ancestors satisfy missing bindings of their children with their own missing binding
-        // methods so that we can minimize the cases where we need to reach into doubly-nested
-        // descendant component implementations.
-
-        // Implement a missing binding if it is resolvable, or if we're generating a concrete
-        // subcomponent implementation. If a binding is still missing when the subcomponent
-        // implementation is concrete then it is assumed to be part of a dependency that would have
-        // been passively pruned when implementing the full component hierarchy.
-        return resolvableBinding(request) || !componentImplementation.isAbstract();
-
-      case BINDS_METHOD_WITH_MISSING_DEPENDENCY:
-        DependencyRequest dependency =
-            getOnlyElement(resolvedBindings.contributionBinding().dependencies());
-        return !graph.contributionBindings().get(dependency.key()).isEmpty();
-
-      case OPTIONAL:
-        // Only override optional binding methods if we have a non-empty binding.
-        return !resolvedBindings.contributionBinding().dependencies().isEmpty();
-
-      case MULTIBINDING:
-        // Only modify a multibinding if there are new contributions.
-        return !componentImplementation
-            .superclassContributionsMade(request)
-            .containsAll(
-                resolvedBindings.contributionBinding().dependencies().stream()
-                    .map(DependencyRequest::key)
-                    .collect(toList()));
-
-      case INJECTION:
-        return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
-
-      default:
-        throw new IllegalStateException(
-            String.format(
-                "Overriding modifiable binding method with unsupported ModifiableBindingType [%s].",
-                modifiableBindingType));
-    }
-  }
-
-  /**
-   * Returns {@code true} if the {@link BindingType} for {@code request} is not the same in this
-   * implementation and it's superclass implementation.
-   */
-  private boolean bindingTypeChanged(BindingRequest request, ResolvedBindings resolvedBindings) {
-    BindingGraph superclassGraph =
-        componentImplementation.superclassImplementation().get().graph();
-    ResolvedBindings superclassBindings = superclassGraph.resolvedBindings(request);
-    return superclassBindings != null
-        && resolvedBindings != null
-        && !superclassBindings.bindingType().equals(resolvedBindings.bindingType());
-  }
-
-  /**
-   * Returns true if the binding can be resolved by the graph for this component or any parent
-   * component.
-   */
-  private boolean resolvableBinding(BindingRequest request) {
-    for (ModifiableBindingExpressions expressions = this;
-        expressions != null;
-        expressions = expressions.parent.orElse(null)) {
-      if (expressions.resolvedInThisComponent(request)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** Returns true if the binding can be resolved by the graph for this component. */
-  private boolean resolvedInThisComponent(BindingRequest request) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
-    return resolvedBindings != null
-        && !resolvedBindings.bindingsOwnedBy(graph.componentDescriptor()).isEmpty();
-  }
-
-  /**
-   * Wraps a modifiable binding expression in a method that can be overridden in a subclass
-   * implementation.
-   */
-  BindingExpression wrapInModifiableMethodBindingExpression(
-      BindingRequest request,
-      ResolvedBindings resolvedBindings,
-      MethodImplementationStrategy methodImplementationStrategy,
-      BindingExpression wrappedBindingExpression) {
-    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    checkState(modifiableBindingType.isModifiable());
-    return new ModifiableConcreteMethodBindingExpression(
-        request,
-        resolvedBindings,
-        methodImplementationStrategy,
-        wrappedBindingExpression,
-        modifiableBindingType,
-        componentImplementation,
-        newModifiableBindingWillBeFinalized(modifiableBindingType, request),
-        types);
-  }
-}
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
deleted file mode 100644
index ead708df6..000000000
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Verify.verify;
-
-import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-import com.squareup.javapoet.MethodSpec;
-import java.util.Map;
-import java.util.Optional;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A registry for those methods which each wrap a binding whose definition may be modified across
- * each class in the class hierarchy implementing a subcomponent. Subcomponent implementations are
- * spread across a class hierarchy when generating ahead-of-time subcomponents. There is one
- * subcomponent implementation class for each of the subcomponent's ancestor components. An instance
- * of {@link ModifiableBindingMethod} is associated with a single class in this hierarchy. For a
- * given subcomponent implementation class we can use the {@link ModifiableBindingMethod}s of its
- * superclasses to know what binding methods to attempt to modify.
- */
-final class ModifiableBindingMethods {
-  private final Map<BindingRequest, ModifiableBindingMethod> methods = Maps.newLinkedHashMap();
-
-  /** Registers a new method encapsulating a modifiable binding. */
-  void addModifiableMethod(
-      ModifiableBindingType type,
-      BindingRequest request,
-      TypeMirror returnType,
-      MethodSpec method,
-      boolean finalized) {
-    // It's ok for the type to not be modifiable, since it could be overriding a previously
-    // modifiable method (such as with addReimplementedMethod).
-    addMethod(ModifiableBindingMethod.create(type, request, returnType, method, finalized));
-  }
-
-  /** Registers a reimplemented modifiable method. */
-  void addReimplementedMethod(ModifiableBindingMethod method) {
-    addMethod(method);
-  }
-
-  private void addMethod(ModifiableBindingMethod method) {
-    ModifiableBindingMethod previousMethod = methods.put(method.request(), method);
-    verify(
-        previousMethod == null,
-        "registering %s but %s is already registered for the same binding request",
-        method,
-        previousMethod);
-  }
-
-  /** Returns all {@link ModifiableBindingMethod}s that have not been marked as finalized. */
-  ImmutableMap<BindingRequest, ModifiableBindingMethod> getNonFinalizedMethods() {
-    return ImmutableMap.copyOf(Maps.filterValues(methods, m -> !m.finalized()));
-  }
-
-  /** Returns the {@link ModifiableBindingMethod} for the given binding if present. */
-  Optional<ModifiableBindingMethod> getMethod(BindingRequest request) {
-    return Optional.ofNullable(methods.get(request));
-  }
-
-  /** Returns all of the {@link ModifiableBindingMethod}s. */
-  ImmutableList<ModifiableBindingMethod> allMethods() {
-    return ImmutableList.copyOf(methods.values());
-  }
-
-  /** Whether a given binding has been marked as finalized. */
-  // TODO(ronshapiro): possibly rename this to something that indicates that the BindingRequest for
-  // `method` has been finalized in *this* component implementation?
-  boolean finalized(ModifiableBindingMethod method) {
-    ModifiableBindingMethod storedMethod = methods.get(method.request());
-    return storedMethod != null && storedMethod.finalized();
-  }
-
-  @AutoValue
-  abstract static class ModifiableBindingMethod {
-    private static ModifiableBindingMethod create(
-        ModifiableBindingType type,
-        BindingRequest request,
-        TypeMirror returnType,
-        MethodSpec methodSpec,
-        boolean finalized) {
-      return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
-          type, request, MoreTypes.equivalence().wrap(returnType), methodSpec, finalized);
-    }
-
-    /** Creates a {@ModifiableBindingMethod} that reimplements the current method. */
-    ModifiableBindingMethod reimplement(
-        ModifiableBindingType newModifiableBindingType,
-        MethodSpec newImplementation,
-        boolean finalized) {
-      return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
-          newModifiableBindingType, request(), returnTypeWrapper(), newImplementation, finalized);
-    }
-
-    abstract ModifiableBindingType type();
-
-    abstract BindingRequest request();
-
-    final TypeMirror returnType() {
-      return returnTypeWrapper().get();
-    }
-
-    abstract Equivalence.Wrapper<TypeMirror> returnTypeWrapper();
-
-    abstract MethodSpec methodSpec();
-
-    abstract boolean finalized();
-
-    /** Whether a {@link ModifiableBindingMethod} is for the same binding request. */
-    boolean fulfillsSameRequestAs(ModifiableBindingMethod other) {
-      return request().equals(other.request());
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
deleted file mode 100644
index 7e43ec159..000000000
--- a/java/dagger/internal/codegen/ModifiableBindingType.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-
-/**
- * A label for a binding indicating whether, and how, it may be redefined across implementations of
- * a subcomponent.
- *
- * <p>A subcomponent has multiple implementations only when generating ahead-of-time subcomponents.
- * Specifically, each subcomponent type in a component hierarchy is implemented as an abstract
- * class, and descendent components are implemented as abstract inner classes. A consequence of this
- * is that a given subcomponent has an implementation for each ancestor component. Each
- * implementation represents a different sub-binding-graph of the full subcomponent. A binding is
- * modifiable if it's definition may change depending on the characteristics of its ancestor
- * components.
- */
-enum ModifiableBindingType {
-  /** A binding that is not modifiable */
-  NONE,
-
-  /**
-   * A binding that is missing when generating the abstract base class implementation of a
-   * subcomponent.
-   */
-  MISSING,
-
-  /**
-   * A binding that requires an instance of a generated type. These binding are modifiable in the
-   * sense that they are encapsulated in a method when they are first required, possibly in an
-   * abstract implementation of a subcomponent, where, in general, no concrete instances of
-   * generated types are available, and the method is satisfied in a final concrete implementation.
-   */
-  GENERATED_INSTANCE,
-
-  /**
-   * Multibindings may have contributions come from any ancestor component. Therefore, each
-   * implementation of a subcomponent may have newly available contributions, and so the binding
-   * method is reimplemented with each subcomponent implementation.
-   */
-  MULTIBINDING,
-
-  /**
-   * A Optional binding that may be empty when looking at a partial binding graph, but bound to a
-   * value when considering the complete binding graph, thus modifiable across subcomponent
-   * implementations.
-   */
-  OPTIONAL,
-
-  /**
-   * If a binding is defined according to an {@code @Inject} annotated constructor on the object it
-   * is valid for that binding to be redefined a single time by an {@code @Provides} annotated
-   * module method. It is possible that the {@code @Provides} binding isn't available in a partial
-   * binding graph, but becomes available when considering a more complete binding graph, therefore
-   * such bindings are modifiable across subcomponent implementations.
-   */
-  INJECTION,
-
-  /**
-   * A {@link dagger.Binds} method whose dependency is {@link #MISSING}.
-   *
-   * <p>There's not much to do for @Binds bindings if the dependency is missing - at best, if the
-   * dependency is a weaker scope/unscoped, we save only a few lines that implement the scoping. But
-   * it's also possible, if the dependency is the same or stronger scope, that no extra code is
-   * necessary, in which case we'd be overriding a method that just returns another.
-   */
-  BINDS_METHOD_WITH_MISSING_DEPENDENCY,
-  ;
-
-  private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
-      ImmutableSet.of(NONE, INJECTION, MULTIBINDING, OPTIONAL);
-
-  boolean isModifiable() {
-    return !equals(NONE);
-  }
-
-  /**
-   * Returns true if the method encapsulating the modifiable binding should have a concrete
-   * implementation in the abstract base class for a subcomponent.
-   */
-  boolean hasBaseClassImplementation() {
-    return TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS.contains(this);
-  }
-}
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
deleted file mode 100644
index 907466b29..000000000
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-
-import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import java.util.Optional;
-
-/**
- * A binding expression that wraps a modifiable binding expression in a public, no-arg method.
- *
- * <p>Dependents of this binding expression will just call the modifiable binding method.
- */
-final class ModifiableConcreteMethodBindingExpression extends MethodBindingExpression {
-
-  private final BindingRequest request;
-  private final ModifiableBindingType modifiableBindingType;
-  private final ComponentImplementation componentImplementation;
-  private final boolean bindingCannotBeModified;
-  private Optional<String> methodName = Optional.empty();
-
-  ModifiableConcreteMethodBindingExpression(
-      BindingRequest request,
-      ResolvedBindings resolvedBindings,
-      MethodImplementationStrategy methodImplementationStrategy,
-      BindingExpression wrappedBindingExpression,
-      ModifiableBindingType modifiableBindingType,
-      ComponentImplementation componentImplementation,
-      boolean bindingCannotBeModified,
-      DaggerTypes types) {
-    super(
-        request,
-        resolvedBindings,
-        methodImplementationStrategy,
-        wrappedBindingExpression,
-        componentImplementation,
-        types);
-    this.request = checkNotNull(request);
-    this.modifiableBindingType = checkNotNull(modifiableBindingType);
-    this.componentImplementation = checkNotNull(componentImplementation);
-    this.bindingCannotBeModified = bindingCannotBeModified;
-  }
-
-  @Override
-  protected void addMethod() {
-    if (methodName.isPresent()) {
-      return;
-    }
-
-    if (supertypeModifiableBindingMethod().isPresent()) {
-      methodName = supertypeModifiableBindingMethod().map(method -> method.methodSpec().name);
-      return;
-    }
-
-    // Add the modifiable binding method to the component if we haven't already.
-    methodName = Optional.of(componentImplementation.getUniqueMethodName(request));
-    componentImplementation.addModifiableBindingMethod(
-        modifiableBindingType,
-        request,
-        returnType(),
-        methodBuilder(methodName.get())
-            .addModifiers(bindingCannotBeModified ? PRIVATE : PROTECTED)
-            .returns(TypeName.get(returnType()))
-            .addCode(methodBody())
-            .build(),
-        bindingCannotBeModified);
-  }
-
-  @Override
-  protected String methodName() {
-    checkState(methodName.isPresent(), "addMethod() must be called before methodName().");
-    return methodName.get();
-  }
-
-  @Override
-  protected boolean isModifiableImplementationMethod() {
-    return true;
-  }
-}
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
deleted file mode 100644
index ff74d57d7..000000000
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.javapoet.Expression;
-import dagger.model.DependencyRequest;
-import dagger.model.Key;
-import dagger.model.RequestKind;
-import java.util.Optional;
-import java.util.Set;
-
-/** An abstract base class for multibinding {@link BindingExpression}s. */
-abstract class MultibindingExpression extends SimpleInvocationBindingExpression {
-  private final ProvisionBinding binding;
-  private final ComponentImplementation componentImplementation;
-
-  MultibindingExpression(
-      ProvisionBinding binding, ComponentImplementation componentImplementation) {
-    super(binding);
-    this.binding = binding;
-    this.componentImplementation = componentImplementation;
-  }
-
-  @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
-    Expression expression = buildDependencyExpression(requestingClass);
-    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
-    return expression;
-  }
-
-  /**
-   * Returns an expression that evaluates to the value of a multibinding request for the given
-   * requesting class.
-   */
-  protected abstract Expression buildDependencyExpression(ClassName requestingClass);
-
-  /**
-   * Returns the subset of {@code dependencies} that represent multibinding contributions that were
-   * not included in a superclass implementation of this multibinding method. This is relevant only
-   * for ahead-of-time subcomponents. When not generating ahead-of-time subcomponents there is only
-   * one implementation of a multibinding expression and all {@link DependencyRequest}s from the
-   * argment are returned.
-   */
-  protected Set<DependencyRequest> getNewContributions(
-      ImmutableSet<DependencyRequest> dependencies) {
-    ImmutableSet<Key> superclassContributions = superclassContributions();
-    return Sets.filter(
-        dependencies, dependency -> !superclassContributions.contains(dependency.key()));
-  }
-
-  /**
-   * Returns the {@link CodeBlock} representing a call to a superclass implementation of the
-   * modifiable binding method that encapsulates this binding, if it exists. This is only possible
-   * when generating ahead-of-time subcomponents.
-   */
-  protected Optional<CodeBlock> superMethodCall() {
-    if (componentImplementation.superclassImplementation().isPresent()) {
-      Optional<ModifiableBindingMethod> method =
-          componentImplementation.getModifiableBindingMethod(bindingRequest());
-      if (method.isPresent()) {
-        if (!superclassContributions().isEmpty()) {
-          return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
-        }
-      }
-    }
-    return Optional.empty();
-  }
-
-  private BindingRequest bindingRequest() {
-    return BindingRequest.bindingRequest(binding.key(), RequestKind.INSTANCE);
-  }
-
-  private ImmutableSet<Key> superclassContributions() {
-    return componentImplementation.superclassContributionsMade(bindingRequest());
-  }
-}
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
index abe161a4a..fdbd2a073 100644
--- a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -17,16 +17,11 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
-import java.util.Optional;
 
 /** An abstract factory creation expression for multibindings. */
 abstract class MultibindingFactoryCreationExpression
@@ -58,23 +53,6 @@ protected final CodeBlock multibindingDependencyExpression(DependencyRequest dep
         : expression;
   }
 
-  protected final ImmutableSet<DependencyRequest> dependenciesToImplement() {
-    ImmutableSet<Key> alreadyImplementedKeys =
-        componentImplementation.superclassContributionsMade(bindingRequest());
-    return binding.dependencies().stream()
-        .filter(dependency -> !alreadyImplementedKeys.contains(dependency.key()))
-        .collect(toImmutableSet());
-  }
-
-  protected Optional<CodeBlock> superContributions() {
-    if (dependenciesToImplement().size() == binding.dependencies().size()) {
-      return Optional.empty();
-    }
-    ModifiableBindingMethod superMethod =
-        componentImplementation.getModifiableBindingMethod(bindingRequest()).get();
-    return Optional.of(CodeBlock.of("super.$N()", superMethod.methodSpec().name));
-  }
-
   /** The binding request for this framework instance. */
   protected final BindingRequest bindingRequest() {
     return BindingRequest.bindingRequest(binding.key(), binding.frameworkType());
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
index cf2475de7..6ea24033b 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
@@ -23,12 +23,10 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.FeatureStatus.DISABLED;
 import static dagger.internal.codegen.FeatureStatus.ENABLED;
-import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EMIT_MODIFIABLE_METADATA_ANNOTATIONS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FAST_INIT;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FLOATING_BINDS_METHODS;
-import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FORCE_USE_SERIALIZED_COMPONENT_IMPLEMENTATIONS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FORMAT_GENERATED_SOURCE;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM;
@@ -135,21 +133,6 @@ boolean warnIfInjectionFactoryNotGeneratedUpstream() {
     return isEnabled(WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM);
   }
 
-  @Override
-  boolean aheadOfTimeSubcomponents() {
-    return isEnabled(EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS);
-  }
-
-  @Override
-  boolean forceUseSerializedComponentImplementations() {
-    return isEnabled(FORCE_USE_SERIALIZED_COMPONENT_IMPLEMENTATIONS);
-  }
-
-  @Override
-  boolean emitModifiableMetadataAnnotations() {
-    return isEnabled(EMIT_MODIFIABLE_METADATA_ANNOTATIONS);
-  }
-
   @Override
   boolean useGradleIncrementalProcessing() {
     return isEnabled(USE_GRADLE_INCREMENTAL_PROCESSING);
@@ -199,6 +182,7 @@ private ProcessingEnvironmentCompilerOptions checkValid() {
     }
     noLongerRecognized(EXPERIMENTAL_ANDROID_MODE);
     noLongerRecognized(FLOATING_BINDS_METHODS);
+    noLongerRecognized(EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS);
     return this;
   }
 
diff --git a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
deleted file mode 100644
index 6eb92ac53..000000000
--- a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.MissingBindingFactory;
-import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
-import dagger.internal.codegen.javapoet.Expression;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.producers.internal.MissingBindingProducer;
-import java.util.Optional;
-
-/**
- * A {@link BindingExpression} that implements a method that encapsulates a binding that is not part
- * of the binding graph when generating a final concrete implementation of a subcomponent. The
- * implementation throws an exception. It is assumed that a binding may remain missing in a valid
- * binding graph, because it's possible for there to be dependencies that are passively pruned when
- * a non-leaf binding is re-defined (such as when {@code @Provides} bindings override
- * {@code @Inject} bindings).
- *
- * <p>This method should never be invoked. If it is the exception indicates an issue within Dagger
- * itself.
- */
-final class PrunedConcreteMethodBindingExpression extends BindingExpression {
-  private static final CodeBlock METHOD_IMPLEMENTATION =
-      CodeBlock.of(
-          "throw new $T($S);",
-          UnsupportedOperationException.class,
-          "This binding is not part of the final binding graph. The key was requested by a binding "
-              + "that was believed to possibly be part of the graph, but is no longer requested. "
-              + "If this exception is thrown, it is the result of a Dagger bug.");
-
-  PrunedConcreteMethodBindingExpression() {}
-
-  @Override
-  CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod,
-      ComponentImplementation component,
-      DaggerTypes types) {
-    Optional<FrameworkType> frameworkType = modifiableBindingMethod.request().frameworkType();
-    if (frameworkType.isPresent()) {
-      // If we make initializations replaceable, we can do away with these classes and this logic
-      // since the pruned framework instances will no longer be initialized
-      switch (frameworkType.get()) {
-        case PROVIDER:
-          return missingFrameworkInstance(MissingBindingFactory.class);
-        case PRODUCER_NODE:
-          return missingFrameworkInstance(MissingBindingProducer.class);
-      }
-      throw new AssertionError(frameworkType);
-    }
-    return METHOD_IMPLEMENTATION;
-  }
-
-  private static CodeBlock missingFrameworkInstance(Class<?> factoryClass) {
-    return CodeBlock.builder().addStatement("return $T.create()", factoryClass).build();
-  }
-
-  @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
-    throw new UnsupportedOperationException(
-        "Requesting a dependency expression for a pruned binding.");
-  }
-}
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index d2a833a79..0560718bd 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -31,12 +31,11 @@
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
-import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A binding expression for multibound sets. */
-final class SetBindingExpression extends MultibindingExpression {
+final class SetBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final ComponentBindingExpressions componentBindingExpressions;
@@ -45,12 +44,11 @@
 
   SetBindingExpression(
       ProvisionBinding binding,
-      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(binding, componentImplementation);
+    super(binding);
     this.binding = binding;
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
@@ -59,14 +57,11 @@
   }
 
   @Override
-  protected Expression buildDependencyExpression(ClassName requestingClass) {
-    Optional<CodeBlock> superMethodCall = superMethodCall();
+  Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
-    if (isImmutableSetAvailable
-        && binding.dependencies().stream().allMatch(this::isSingleValue)
-        && !superMethodCall.isPresent()) {
+    if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
       return Expression.create(
           immutableSetType(),
           CodeBlock.builder()
@@ -114,14 +109,11 @@ protected Expression buildDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
         }
-        for (DependencyRequest dependency : getNewContributions(binding.dependencies())) {
+        for (DependencyRequest dependency : binding.dependencies()) {
           String builderMethod = isSingleValue(dependency) ? "add" : "addAll";
           instantiation.add(
               ".$L($L)", builderMethod, getContributionExpression(dependency, requestingClass));
         }
-        if (superMethodCall.isPresent()) {
-          instantiation.add(CodeBlock.of(".addAll($L)", superMethodCall.get()));
-        }
         instantiation.add(".build()");
         return Expression.create(
             isImmutableSetAvailable ? immutableSetType() : binding.key().type(),
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 971209170..ee461371b 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -22,12 +22,9 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.model.DependencyRequest;
 import dagger.producers.Produced;
-import java.util.Optional;
 
 /** A factory creation expression for a multibound set. */
 final class SetFactoryCreationExpression extends MultibindingFactoryCreationExpression {
-
-  private final ComponentImplementation componentImplementation;
   private final BindingGraph graph;
   private final ContributionBinding binding;
 
@@ -38,7 +35,6 @@
       BindingGraph graph) {
     super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
-    this.componentImplementation = checkNotNull(componentImplementation);
     this.graph = checkNotNull(graph);
   }
 
@@ -60,17 +56,7 @@ public CodeBlock creationExpression() {
     String methodNameSuffix =
         binding.bindingType().equals(BindingType.PROVISION) ? "Provider" : "Producer";
 
-    Optional<CodeBlock> superContributions = superContributions();
-    if (superContributions.isPresent()) {
-      // TODO(b/117833324): consider decomposing the Provider<Set<Provider>> and adding the
-      // individual contributions separately from the collection contributions. Though this may
-      // actually not be doable/desirable if the super provider instance is a DelegateFactory or
-      // another internal type that is not SetFactory
-      builderMethodCalls.add(".addCollection$N($L)", methodNameSuffix, superContributions.get());
-      setProviders++;
-    }
-
-    for (DependencyRequest dependency : dependenciesToImplement()) {
+    for (DependencyRequest dependency : binding.dependencies()) {
       ContributionType contributionType =
           graph.contributionBindings().get(dependency.key()).contributionType();
       String methodNamePrefix;
@@ -96,8 +82,6 @@ public CodeBlock creationExpression() {
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
 
-    componentImplementation.registerImplementedMultibinding(binding, bindingRequest());
-
     return builder.add(".build()").build();
   }
 }
diff --git a/java/dagger/internal/codegen/TypeProtoConverter.java b/java/dagger/internal/codegen/TypeProtoConverter.java
deleted file mode 100644
index c703bd889..000000000
--- a/java/dagger/internal/codegen/TypeProtoConverter.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.MoreTypes;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.internal.codegen.serialization.TypeProto;
-import dagger.internal.codegen.serialization.TypeProto.PrimitiveKind;
-import javax.inject.Inject;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
-
-/** Converts {@link TypeMirror}s to {@link TypeProto}s and vice-versa. */
-final class TypeProtoConverter {
-  // TODO(ronshapiro): if DaggerTypes and DaggerElements become public, move this file to
-  // dagger.internal.codegen.serialization
-  private final DaggerTypes types;
-  private final DaggerElements elements;
-
-  @Inject
-  TypeProtoConverter(DaggerTypes types, DaggerElements elements) {
-    this.types = types;
-    this.elements = elements;
-  }
-
-  /** Translates a {@link TypeMirror} to a proto representation. */
-  static TypeProto toProto(TypeMirror type) {
-    TypeProto.Builder builder = TypeProto.newBuilder();
-    int arrayDimensions = 0;
-    while (type.getKind().equals(TypeKind.ARRAY)) {
-      type = MoreTypes.asArray(type).getComponentType();
-      arrayDimensions++;
-    }
-    builder.setArrayDimensions(arrayDimensions);
-    if (type.getKind().isPrimitive()) {
-      builder.setPrimitiveKind(PrimitiveKind.valueOf(type.getKind().name()));
-    } else if (type.getKind().equals(TypeKind.WILDCARD)) {
-      WildcardType wildcardType = MoreTypes.asWildcard(type);
-      TypeProto.Wildcard.Builder wildcardBuilder = TypeProto.Wildcard.newBuilder();
-      if (wildcardType.getExtendsBound() != null) {
-        wildcardBuilder.setExtendsBound(toProto(wildcardType.getExtendsBound()));
-      } else if (wildcardType.getSuperBound() != null) {
-        wildcardBuilder.setSuperBound(toProto(wildcardType.getSuperBound()));
-      }
-      builder.setWildcard(wildcardBuilder);
-    } else {
-      TypeElement typeElement = MoreTypes.asTypeElement(type);
-      DeclaredType declaredType = MoreTypes.asDeclared(type);
-      TypeMirror enclosingType = declaredType.getEnclosingType();
-      if (enclosingType.getKind().equals(TypeKind.NONE)) {
-        builder.setQualifiedName(typeElement.getQualifiedName().toString());
-      } else {
-        builder
-            .setEnclosingType(toProto(enclosingType))
-            .setSimpleName(typeElement.getSimpleName().toString());
-      }
-      declaredType.getTypeArguments().stream()
-          .map(TypeProtoConverter::toProto)
-          .forEachOrdered(builder::addTypeArguments);
-    }
-    return builder.build();
-  }
-
-  /** Creates an {@link TypeMirror} from its proto representation. */
-  TypeMirror fromProto(TypeProto type) {
-    if (type.hasWildcard()) {
-      return wildcardType(type.getWildcard());
-    }
-
-    TypeMirror[] typeArguments =
-        type.getTypeArgumentsList().stream().map(this::fromProto).toArray(TypeMirror[]::new);
-    TypeMirror typeMirror;
-    if (!type.getPrimitiveKind().equals(PrimitiveKind.UNKNOWN)) {
-      typeMirror = types.getPrimitiveType(TypeKind.valueOf(type.getPrimitiveKind().name()));
-    } else if (type.hasEnclosingType()) {
-      DeclaredType enclosingType = MoreTypes.asDeclared(fromProto(type.getEnclosingType()));
-      TypeElement typeElement =
-          typesIn(enclosingType.asElement().getEnclosedElements()).stream()
-              .filter(inner -> inner.getSimpleName().contentEquals(type.getSimpleName()))
-              .findFirst()
-              .get();
-      typeMirror = types.getDeclaredType(enclosingType, typeElement, typeArguments);
-    } else {
-      typeMirror =
-          types.getDeclaredType(elements.getTypeElement(type.getQualifiedName()), typeArguments);
-    }
-    for (int i = 0; i < type.getArrayDimensions(); i++) {
-      typeMirror = types.getArrayType(typeMirror);
-    }
-    return typeMirror;
-  }
-
-  private TypeMirror wildcardType(TypeProto.Wildcard wildcard) {
-    if (wildcard.hasExtendsBound()) {
-      return types.getWildcardType(fromProto(wildcard.getExtendsBound()), null);
-    } else if (wildcard.hasSuperBound()) {
-      return types.getWildcardType(null, fromProto(wildcard.getSuperBound()));
-    } else {
-      return types.getWildcardType(null, null);
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/serialization/BUILD b/java/dagger/internal/codegen/serialization/BUILD
deleted file mode 100644
index 2bc02b420..000000000
--- a/java/dagger/internal/codegen/serialization/BUILD
+++ /dev/null
@@ -1,41 +0,0 @@
-# Copyright (C) 2019 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#    Serialized forms of types used in the Dagger processor.
-
-package(default_visibility = ["//:src"])
-
-proto_library(
-    name = "serialization_proto",
-    srcs = ["serialization.proto"],
-    visibility = ["//visibility:private"],
-)
-
-java_proto_library(
-    name = "serialization_java_proto",
-    visibility = ["//visibility:private"],
-    deps = [":serialization_proto"],
-)
-
-java_library(
-    name = "serialization",
-    srcs = glob(["*.java"]),
-    exports = [":serialization_java_proto"],
-    deps = [
-        "@google_bazel_common//third_party/java/guava",
-        "@google_bazel_common//third_party/java/javapoet",
-        "@google_bazel_common//third_party/java/protobuf",
-    ],
-)
diff --git a/java/dagger/internal/codegen/serialization/ProtoSerialization.java b/java/dagger/internal/codegen/serialization/ProtoSerialization.java
deleted file mode 100644
index 1449e9d0b..000000000
--- a/java/dagger/internal/codegen/serialization/ProtoSerialization.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen.serialization;
-
-import static com.google.common.io.BaseEncoding.base64;
-
-import com.google.common.io.BaseEncoding;
-import com.google.protobuf.InvalidProtocolBufferException;
-import com.google.protobuf.Message;
-import com.squareup.javapoet.CodeBlock;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.util.SimpleAnnotationValueVisitor8;
-
-/**
- * Serializes and deserializes {@link Message}s using {@link BaseEncoding#base64()} for use in
- * annotation values.
- */
-public final class ProtoSerialization {
-  /** Returns a {@link CodeBlock} of {@code message} serialized as a String. */
-  public static CodeBlock toAnnotationValue(Message message) {
-    return CodeBlock.of("$S", base64().encode(message.toByteArray()));
-  }
-
-  /**
-   * Returns a {@link Message T} from the deserialized the String {@code value}.
-   *
-   * @throws IllegalArgumentException if {@code value} represents an {@link AnnotationValue} who's
-   *     type is not {@link String}
-   */
-  public static <T extends Message> T fromAnnotationValue(
-      AnnotationValue value, T defaultInstance) {
-    byte[] bytes = base64().decode(value.accept(STRING_VALUE, null));
-    Message message;
-    try {
-      message = defaultInstance.getParserForType().parseFrom(bytes);
-    } catch (InvalidProtocolBufferException e) {
-      throw new InconsistentSerializedProtoException(e);
-    }
-    @SuppressWarnings("unchecked") // guaranteed by proto API
-    T t = (T) message;
-    return t;
-  }
-
-  private static final AnnotationValueVisitor<String, Void> STRING_VALUE =
-      new SimpleAnnotationValueVisitor8<String, Void>() {
-        @Override
-        public String visitString(String s, Void ignored) {
-          return s;
-        }
-
-        @Override
-        protected String defaultAction(Object o, Void ignored) {
-          throw new IllegalArgumentException(o + " is not a String");
-        }
-      };
-
-  /**
-   * An exception thrown when the proto that's serialized in a compiled subcomponent implementation
-   * is from a different version than the current compiler's.
-   */
-  public static final class InconsistentSerializedProtoException extends RuntimeException {
-    InconsistentSerializedProtoException(Throwable cause) {
-      super(cause);
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/serialization/serialization.proto b/java/dagger/internal/codegen/serialization/serialization.proto
deleted file mode 100644
index e6c957765..000000000
--- a/java/dagger/internal/codegen/serialization/serialization.proto
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Serialized forms of types used in the Dagger processor. The wire format of
-// these types is not guaranteed to remain compatible over time; serialization
-// is only expected to function correctly within an individual version of the
-// Dagger processor.
-
-syntax = "proto3";
-
-package dagger.internal.codegen.serialization;
-option java_package = "dagger.internal.codegen.serialization";
-option java_multiple_files = true;
-
-// TODO(ronshapiro): consider exposing some of these in
-// dagger.model.serialization
-
-// Serialized form of `dagger.internal.codegen.BindingRequest`
-message BindingRequestProto {
-  KeyProto key = 1;
-  RequestKindWrapper.RequestKind request_kind = 2;
-  FrameworkTypeWrapper.FrameworkType framework_type = 3;
-}
-
-message RequestKindWrapper {
-  // Serialized form of `dagger.model.RequestKind`
-  enum RequestKind {
-    UNKNOWN = 0;
-    INSTANCE = 1;
-    PROVIDER = 2;
-    LAZY = 3;
-    PROVIDER_OF_LAZY = 4;
-    MEMBERS_INJECTION = 5;
-    PRODUCER = 6;
-    PRODUCED = 7;
-    FUTURE = 8;
-  }
-}
-
-message FrameworkTypeWrapper {
-  // Serialized form of `dagger.internal.codegen.FrameworkType`
-  enum FrameworkType {
-    UNKNOWN = 0;
-    PROVIDER = 1;
-    PRODUCER_NODE = 2;
-  }
-}
-
-// Serialized form of `dagger.model.Key`
-message KeyProto {
-  TypeProto type = 1;
-  AnnotationProto qualifier = 2;
-  MultibindingContributionIdentifier multibinding_contribution_identifier =
-      3;
-
-  // Serialized form of `dagger.model.Key.MultibindingContributionIdentifier`
-  message MultibindingContributionIdentifier {
-    string module = 1;
-    string binding_element = 2;
-  }
-}
-
-// Serialized form of `javax.lang.model.type.TypeMirror`
-message TypeProto {
-  PrimitiveKind primitive_kind = 1;
-
-  // The qualified name of the type. Absent if this is an inner type.
-  string qualified_name = 2;
-
-  // The enclosing type if this is an inner type, otherwise absent.
-  TypeProto enclosing_type = 3;
-
-  // Simple name of the type if this is an inner type, otherwise absent.
-  string simple_name = 4;
-
-  repeated TypeProto type_arguments = 5;
-
-  message Wildcard {
-    TypeProto extends_bound = 1;
-    TypeProto super_bound = 2;
-  }
-  Wildcard wildcard = 6;
-
-  int32 array_dimensions = 7;
-
-  // Kinds of primitive types
-  enum PrimitiveKind {
-    UNKNOWN = 0;
-    BOOLEAN = 1;
-    BYTE = 2;
-    SHORT = 3;
-    CHAR = 4;
-    INT = 5;
-    FLOAT = 6;
-    LONG = 7;
-    DOUBLE = 8;
-  }
-}
-
-// Serialized form of `javax.lang.model.element.AnnotationMirror`
-message AnnotationProto {
-  TypeProto annotation_type = 1;
-  map<string, AnnotationValueProto> values = 2;
-}
-
-// Serialized form of `javax.lang.model.element.AnnotationValue`
-message AnnotationValueProto {
-  Kind kind = 1;
-  bool boolean_value = 2;
-  int32 int_value = 3;
-  int64 long_value = 4;
-  float float_value = 5;
-  double double_value = 6;
-  string string_value = 7;
-  TypeProto class_literal = 8;
-  TypeProto enum_type = 9;
-  string enum_name = 10;
-  AnnotationProto nested_annotation = 11;
-
-  repeated AnnotationValueProto array_values = 12;
-
-  // The type of annotation value
-  enum Kind {
-    UNKNOWN = 0;
-    BOOLEAN = 1;
-    BYTE = 2;
-    SHORT = 3;
-    CHAR = 4;
-    INT = 5;
-    FLOAT = 6;
-    LONG = 7;
-    DOUBLE = 8;
-    STRING = 9;
-    CLASS_LITERAL = 10;
-    ENUM = 11;
-    ANNOTATION = 12;
-    ARRAY = 13;
-  }
-}
-
-// Serialized form of `dagger.internal.codegen.ComponentRequirement`
-message ComponentRequirementProto {
-  oneof requirement {
-    TypeProto dependency = 1;
-    TypeProto module = 2;
-    BoundInstanceRequirement bound_instance = 3;
-  }
-
-  message BoundInstanceRequirement {
-    KeyProto key = 1;
-    bool nullable = 2;
-    string variable_name = 3;
-  }
-}
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 75d750798..34e01a8d9 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -48,8 +48,8 @@
  *   <li>an entire component hierarchy rooted at a {@link dagger.Component} or {@link
  *       dagger.producers.ProductionComponent}
  *   <li>a partial component hierarchy rooted at a {@link dagger.Subcomponent} or {@link
- *       dagger.producers.ProductionSubcomponent} (only when {@code
- *       -Adagger.experimentalAheadOfTimeSubcomponents=enabled} is passed to the compiler)
+ *       dagger.producers.ProductionSubcomponent} (only when the value of {@code
+ *       -Adagger.fullBindingGraphValidation} is not {@code NONE})
  *   <li>the bindings installed by a {@link Module} or {@link dagger.producers.ProducerModule},
  *       including all subcomponents generated by {@link Module#subcomponents()} ()} and {@link
  *       dagger.producers.ProducerModule#subcomponents()} ()}
@@ -131,7 +131,7 @@ public final boolean isModuleBindingGraph() {
 
   /**
    * Returns {@code true} if the {@link #rootComponentNode()} is a subcomponent. This occurs in
-   * ahead-of-time-subcomponents mode.
+   * when {@code -Adagger.fullBindingGraphValidation} is used in a compilation with a subcomponent.
    *
    * @deprecated use {@link ComponentNode#isSubcomponent() rootComponentNode().isSubcomponent()}
    *     instead
diff --git a/java/dagger/producers/internal/MissingBindingProducer.java b/java/dagger/producers/internal/MissingBindingProducer.java
deleted file mode 100644
index 5721569a0..000000000
--- a/java/dagger/producers/internal/MissingBindingProducer.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.producers.internal;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
-
-/**
- * A {@link Producer} that always throws on calls to {@link Producer#get()}. This is necessary in
- * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
- * Producer<T>} to a framework instance initialization that is pruned and no longer in the binding
- * graph, but was present in a superclass implementation. This class fulfills that requirement but
- * is still practically unusable.
- */
-public final class MissingBindingProducer<T> extends AbstractProducer<T> {
-  private static final MissingBindingProducer<Object> INSTANCE = new MissingBindingProducer<>();
-
-  private MissingBindingProducer() {}
-
-  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Producer<T> create() {
-    return (Producer) INSTANCE;
-  }
-
-  @Override
-  protected ListenableFuture<T> compute() {
-    throw new AssertionError(
-        "This binding is not part of the final binding graph. The key was requested by a binding "
-            + "that was believed to possibly be part of the graph, but is no longer requested. "
-            + "If this exception is thrown, it is the result of a Dagger bug.");
-  }
-}
diff --git a/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java b/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java
deleted file mode 100644
index 20a89d4f3..000000000
--- a/javatests/dagger/functional/aot/DependsOnMissingArrayKey.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-
-/**
- * Regression test for an ahead-of-time subcomponents bug where generating the name for a missing
- * binding method for a key of an array type threw an exception.
- */
-final class DependsOnMissingArrayKey {
-  @Module
-  abstract static class ModuleArrayDependencies {
-    @Provides
-    static int dependsOnMissingArrayType(int[] primitive, Object[] object, String[][] doubleArray) {
-      return 0;
-    }
-  }
-
-  @Subcomponent(modules = ModuleArrayDependencies.class)
-  interface HasMissingArrayBindings {
-    int dependsOnMissingArrayType();
-  }
-}
diff --git a/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java b/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java
deleted file mode 100644
index ae6b3a4d2..000000000
--- a/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.StringKey;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * Tests that framework instances of map bindings are properly instantiated in ahead-of-time mode
- * when contributions are made in 3 or more implementations.
- */
-@RunWith(JUnit4.class)
-public final class MapFrameworkInstanceWithContributionsInMultipleImplementationsTest {
-  @Subcomponent(modules = LeafModule.class)
-  interface Leaf {
-    Provider<Map<String, String>> providerOfMapOfValues();
-    Provider<Map<String, Provider<String>>> providerOfMapOfProviders();
-  }
-
-  @Module
-  interface LeafModule {
-    @Provides
-    @IntoMap
-    @StringKey("a")
-    static String fromLeaf() {
-      return "a";
-    }
-  }
-
-  @Subcomponent(modules = AncestorModule.class)
-  interface Ancestor {
-    Leaf leaf();
-  }
-
-  @Module
-  interface AncestorModule {
-    @Provides
-    @IntoMap
-    @StringKey("b")
-    static String fromAncestor() {
-      return "b";
-    }
-  }
-
-  @Component(modules = RootModule.class)
-  interface Root {
-    Ancestor ancestor();
-  }
-
-  @Module
-  interface RootModule {
-    @Provides
-    @IntoMap
-    @StringKey("c")
-    static String fromRoot() {
-      return "c";
-    }
-  }
-
-  @Test
-  public void mapFactoryCanBeInstantiatedAcrossComponentImplementations() {
-    Leaf leaf =
-        DaggerMapFrameworkInstanceWithContributionsInMultipleImplementationsTest_Root.create()
-            .ancestor()
-            .leaf();
-    assertThat(leaf.providerOfMapOfValues().get()).hasSize(3);
-    assertThat(leaf.providerOfMapOfProviders().get()).hasSize(3);
-  }
-}
diff --git a/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java b/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java
deleted file mode 100644
index 1813ad2ae..000000000
--- a/javatests/dagger/functional/aot/MissingBindingReplacedWithGeneratedInstance.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Subcomponent;
-import javax.inject.Inject;
-
-/**
- * This class demonstrates a regression where a missing binding method was generated in a leaf
- * component and then satisfied in an ancestor with a generated instance binding. If the ancestor's
- * generated instance method had the same name as the formerly-missing binding method, Dagger would
- * generate code without a proper {@code DaggerOuter.this} reference:
- *
- * <pre>{@code
- * public class DaggerAncestor implements Ancestor {
- *   protected abstract Ancestor getAncestor();
- *
- *   protected abstract class LeafImpl extends DaggerLeaf {
- *     {@literal @Override}
- *     protected final Ancestor getAncestor() {
- *       return getAncestor();
- *       //     ^ should be DaggerAncestor.this.getAncestor()
- *     }
- *   }
- * }
- * }</pre>
- */
-final class MissingBindingReplacedWithGeneratedInstance {
-  @Subcomponent
-  interface Leaf {
-    DependsOnGeneratedInstance dependsOnGeneratedInstance();
-  }
-
-  static class DependsOnGeneratedInstance {
-    @Inject DependsOnGeneratedInstance(Ancestor generatedInstance) {}
-  }
-
-  @Subcomponent
-  interface Ancestor {
-    Leaf child();
-  }
-}
diff --git a/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java b/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java
deleted file mode 100644
index 7084f83af..000000000
--- a/javatests/dagger/functional/aot/ModifiedFrameworkInstancesTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class ModifiedFrameworkInstancesTest {
-  static class DependsOnModifiableBinding {
-    @Inject
-    DependsOnModifiableBinding(Set<Integer> modifiableDependency) {}
-  }
-
-  @Module
-  interface ChildModule {
-    @Provides
-    @IntoSet
-    static int contribution() {
-      return 1;
-    }
-  }
-
-  @Subcomponent(modules = ChildModule.class)
-  interface Child {
-    Provider<DependsOnModifiableBinding> frameworkInstanceWithModifiedDependency();
-  }
-
-  @Module
-  interface ParentModule {
-    @Provides
-    @IntoSet
-    static int contribution() {
-      return 2;
-    }
-  }
-
-  @Component(modules = ParentModule.class)
-  interface Parent {
-    Child child();
-  }
-
-  @Test
-  public void dependsOnModifiedFrameworkInstance() {
-    DaggerModifiedFrameworkInstancesTest_Parent.create()
-        .child()
-        .frameworkInstanceWithModifiedDependency()
-        // Ensure that modified framework instances that are dependencies to other framework 
-        // instances from superclass implementations are initialized correctly. This fixes a
-        // regression where a null instance would be passed to the superclass initialization, and
-        // then a NullPointerException would be thrown when the factory attempted to satisfy the
-        // dependency in get(). If get() succeeds, this test should pass.
-        .get();
-  }
-}
diff --git a/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java b/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
deleted file mode 100644
index 853e22b07..000000000
--- a/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class PrunedBindingDependedOnInSuperInitializationTest {
-  interface PrunedDependency {}
-
-  static class WillHavePrunedDependency {
-    @Inject WillHavePrunedDependency(PrunedDependency pruned) {}
-  }
-
-  @Subcomponent
-  interface Child {
-    Provider<WillHavePrunedDependency> frameworkInstance();
-  }
-
-  @Module
-  static class ParentModule {
-    @Provides
-    static WillHavePrunedDependency pruneDependency() {
-      return new WillHavePrunedDependency(new PrunedDependency() {});
-    }
-  }
-
-  @Component(modules = ParentModule.class)
-  interface Parent {
-    Child child();
-  }
-
-  @Test
-  public void prunedFrameworkInstanceBindingUsedInInitializationDoesntThrow() {
-    Parent parent = DaggerPrunedBindingDependedOnInSuperInitializationTest_Parent.create();
-    // This test ensures that pruned bindings that are used during unpruned initialization
-    // statements do not throw exceptions. If the subcomponent initialization succeeds, the test
-    // should pass
-    parent.child();
-  }
-}
diff --git a/javatests/dagger/functional/aot/PrunedFrameworkInstanceWithModuleInstanceTest.java b/javatests/dagger/functional/aot/PrunedFrameworkInstanceWithModuleInstanceTest.java
deleted file mode 100644
index f995789bf..000000000
--- a/javatests/dagger/functional/aot/PrunedFrameworkInstanceWithModuleInstanceTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class PrunedFrameworkInstanceWithModuleInstanceTest {
-  static class Pruned {}
-
-  static class InjectsPruned {
-    @Inject
-    InjectsPruned(Provider<Pruned> pruned) {}
-  }
-
-  @Module
-  static class InstanceStateModule {
-    @Provides
-    /* intentionally not static */ Pruned pruned() {
-      return new Pruned();
-    }
-  }
-
-  @Subcomponent(modules = InstanceStateModule.class)
-  interface LeafWithoutCreator {
-    InjectsPruned injectsPruned();
-  }
-
-  @Subcomponent(modules = InstanceStateModule.class)
-  interface LeafWithCreator {
-    InjectsPruned injectsPruned();
-
-    @Subcomponent.Builder
-    interface Builder {
-      Builder module(InstanceStateModule module);
-      LeafWithCreator build();
-    }
-  }
-
-  @Module
-  interface RootModule {
-    @Provides
-    static InjectsPruned pruneBindingWithInstanceState() {
-      return new InjectsPruned(null);
-    }
-  }
-
-  @Component(modules = RootModule.class)
-  interface Root {
-    LeafWithoutCreator leafWithoutCreator(InstanceStateModule pruned);
-    LeafWithCreator.Builder leafWithCreator();
-  }
-
-  @Test
-  public void prunedBindingWithModuleInstance_doesntThrowDuringInitialization() {
-    Root root = DaggerPrunedFrameworkInstanceWithModuleInstanceTest_Root.create();
-
-    Object unused = root.leafWithoutCreator(new InstanceStateModule()).injectsPruned();
-    unused = root.leafWithCreator().module(new InstanceStateModule()).build().injectsPruned();
-  }
-}
diff --git a/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java b/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java
deleted file mode 100644
index 2723ac0d0..000000000
--- a/javatests/dagger/functional/aot/ScopedBindsWithMissingDependency.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Binds;
-import dagger.Module;
-import dagger.Reusable;
-import dagger.Subcomponent;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.inject.Scope;
-
-/**
- * A regression test for ahead-of-time subcomponents mode where a scoped {@link Binds} method whose
- * dependency was missing in a partial subcomponent implementation threw an exception in the
- * processor.
- */
-final class ScopedBindsWithMissingDependency {
-
-  @Retention(RetentionPolicy.RUNTIME)
-  @Scope
-  @interface CustomScope {}
-
-  @Module
-  interface ScopedBindsWithMissingDependencyModule {
-    @Binds
-    @CustomScope
-    Object bindsCustomScopeToMissingDep(String missingDependency);
-
-    @Binds
-    @Reusable
-    CharSequence bindsReusableScopeToMissingDep(String missingDependency);
-  }
-
-  @CustomScope
-  @Subcomponent(modules = ScopedBindsWithMissingDependencyModule.class)
-  interface HasScopedBindsWithMissingDependency {
-    Object customScopedBindsWithMissingDependency();
-    CharSequence reusableScopedBindsWithMissingDependency();
-  }
-}
diff --git a/javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java b/javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java
deleted file mode 100644
index 689689cea..000000000
--- a/javatests/dagger/functional/aot/SubcomponentWithInaccessibleMissingBindingMethod.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Subcomponent;
-import dagger.functional.aot.sub.PublicTypeWithPackagePrivateMissingDep;
-import javax.inject.Provider;
-
-@Subcomponent
-interface SubcomponentWithInaccessibleMissingBindingMethod {
-  PublicTypeWithPackagePrivateMissingDep instance();
-  Provider<PublicTypeWithPackagePrivateMissingDep> frameworkInstance();
-}
diff --git a/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java b/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java
deleted file mode 100644
index 06cebb9b3..000000000
--- a/javatests/dagger/functional/aot/SubcomponentWithModifiedInaccessibleDependency.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot;
-
-import dagger.Subcomponent;
-import dagger.functional.aot.sub.BindsPackagePrivateModule;
-import dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod;
-
-/**
- * See {@link dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod}. This
- * subcomponent will induce a modified binding method for its single child for the key {@code
- * Optional<dagger.functional.aot.sub.PackagePrivate>}. When it tries to reimplement it, it must use
- * the publicly accessible type.
- */
-@Subcomponent(modules = BindsPackagePrivateModule.class)
-interface SubcomponentWithModifiedInaccessibleDependency {
-  SubcomponentWithInaccessibleOptionalBindingMethod child();
-}
diff --git a/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java b/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java
deleted file mode 100644
index 2eee3c996..000000000
--- a/javatests/dagger/functional/aot/sub/BindsPackagePrivateModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot.sub;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-public final class BindsPackagePrivateModule {
-  @Provides
-  static PackagePrivate packagePrivate() {
-    return new PackagePrivate();
-  }
-}
diff --git a/javatests/dagger/functional/aot/sub/PackagePrivate.java b/javatests/dagger/functional/aot/sub/PackagePrivate.java
deleted file mode 100644
index c629f6e32..000000000
--- a/javatests/dagger/functional/aot/sub/PackagePrivate.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot.sub;
-
-final class PackagePrivate {}
diff --git a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java
deleted file mode 100644
index b5ced6f61..000000000
--- a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateMissingDep.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot.sub;
-
-import javax.inject.Inject;
-
-public class PublicTypeWithPackagePrivateMissingDep {
-  @Inject
-  PublicTypeWithPackagePrivateMissingDep(PackagePrivate packagePrivate) {}
-}
diff --git a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java b/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java
deleted file mode 100644
index 1d697233e..000000000
--- a/javatests/dagger/functional/aot/sub/PublicTypeWithPackagePrivateOptionalDep.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot.sub;
-
-import java.util.Optional;
-import javax.inject.Inject;
-
-public class PublicTypeWithPackagePrivateOptionalDep {
-  @Inject
-  PublicTypeWithPackagePrivateOptionalDep(Optional<PackagePrivate> packagePrivateOptional) {}
-}
diff --git a/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java b/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java
deleted file mode 100644
index d908b1c28..000000000
--- a/javatests/dagger/functional/aot/sub/SubcomponentWithInaccessibleOptionalBindingMethod.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.aot.sub;
-
-import dagger.BindsOptionalOf;
-import dagger.Module;
-import dagger.Subcomponent;
-import dagger.functional.aot.sub.SubcomponentWithInaccessibleOptionalBindingMethod.ExposesModifiablePackagePrivateBindingModule;
-import javax.inject.Provider;
-
-/**
- * This component will generate a modifiable binding method for the key {@code
- * Optional<PackagePrivate>} as a dependency of {@link PublicTypeWithPackagePrivateOptionalDep}.
- * Even though this subcomponent implementation can refer to the parameterized type, a subclass
- * implementation in another package will not be able to, and thus the return type must be reduced
- * to the publicly accessible type. This is exhibited in {@link
- * dagger.functional.aot.SubcomponentWithModifiedInaccessibleDependency}.
- */
-@Subcomponent(modules = ExposesModifiablePackagePrivateBindingModule.class)
-public interface SubcomponentWithInaccessibleOptionalBindingMethod {
-  PublicTypeWithPackagePrivateOptionalDep instance();
-  Provider<PublicTypeWithPackagePrivateOptionalDep> frameworkInstance();
-
-  @Module
-  interface ExposesModifiablePackagePrivateBindingModule {
-    @BindsOptionalOf
-    PackagePrivate optional();
-  }
-}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
deleted file mode 100644
index 4625d8649..000000000
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
+++ /dev/null
@@ -1,2838 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
-import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
-import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
-import static dagger.internal.codegen.Compilers.compilerWithOptions;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
-import static dagger.internal.codegen.GeneratedLines.GENERATION_OPTIONS_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class AheadOfTimeSubcomponentsMultibindingsTest {
-  @Test
-  public void setMultibindings_contributionsInLeaf() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InLeaf> contributionsInLeaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeaf provideInLeaf() {",
-            "    return new InLeaf();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InLeaf> contributionsInLeaf() {",
-            "    return ImmutableSet.<InLeaf>of(",
-            "        LeafModule_ProvideInLeafFactory.provideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInAncestorOnly() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Set<InAncestor> contributionsInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Set<InAncestor> contributionsInAncestor();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InAncestor> provideInAncestors() {",
-            "    return ImmutableSet.of(new InAncestor(), new InAncestor());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InAncestor> contributionsInAncestor() {",
-            "      return ImmutableSet.<InAncestor>copyOf(",
-            "          AncestorModule_ProvideInAncestorsFactory.provideInAncestors());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideAnotherInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return ImmutableSet.<InEachSubcomponent>of(",
-            "        LeafModule_ProvideInLeafFactory.provideInLeaf(),",
-            "        LeafModule_ProvideAnotherInLeafFactory.provideAnotherInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InEachSubcomponent> provideInAncestor() {",
-            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return ImmutableSet.<InEachSubcomponent>builderWithExpectedSize(3)",
-            "          .addAll(AncestorModule_ProvideInAncestorFactory.provideInAncestor())",
-            "          .addAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InLeafAndGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeafAndGrandAncestor provideInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeafAndGrandAncestor provideAnotherInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "    return ImmutableSet.<InLeafAndGrandAncestor>of(",
-            "        LeafModule_ProvideInLeafFactory.provideInLeaf(),",
-            "        LeafModule_ProvideAnotherInLeafFactory.provideAnotherInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InLeafAndGrandAncestor> provideInGrandAncestor() {",
-            "    return ImmutableSet.of(new InLeafAndGrandAncestor(),",
-            "        new InLeafAndGrandAncestor());",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "      return ImmutableSet.<InLeafAndGrandAncestor>builderWithExpectedSize(3)",
-            "          .addAll(GrandAncestorModule_ProvideInGrandAncestorFactory",
-            "              .provideInGrandAncestor())",
-            "          .addAll(super.contributionsInLeafAndGrandAncestor())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void setMultibindings_nonComponentMethodDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(
-        filesToCompile, "InAllSubcomponents", "RequresInAllSubcomponentsSet");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  RequresInAllSubcomponentsSet requiresNonComponentMethod();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
-            "  }",
-            "",
-            "  @Provides",
-            "  static RequresInAllSubcomponentsSet providesRequresInAllSubcomponentsSet(",
-            "      Set<InAllSubcomponents> inAllSubcomponents) {",
-            "    return new RequresInAllSubcomponentsSet();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public RequresInAllSubcomponentsSet requiresNonComponentMethod() {",
-            "    return LeafModule_ProvidesRequresInAllSubcomponentsSetFactory",
-            "        .providesRequresInAllSubcomponentsSet(getSetOfInAllSubcomponents());",
-            "  }",
-            "",
-            "  protected Set getSetOfInAllSubcomponents() {",
-            "    return ImmutableSet.<InAllSubcomponents>of(",
-            "        LeafModule_ProvideInAllSubcomponentsFactory",
-            "            .provideInAllSubcomponents());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "      return new InAllSubcomponents();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected Set getSetOfInAllSubcomponents() {",
-            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .add(AncestorModule_ProvideInAllSubcomponentsFactory",
-            "              .provideInAllSubcomponents())",
-            "          .addAll(super.getSetOfInAllSubcomponents())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_newSubclass() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InAncestor", "RequiresInAncestorSet");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  RequiresInAncestorSet missingWithSetDependency();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract RequiresInAncestorSet missingWithSetDependency();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "",
-            "  @Provides",
-            "  static RequiresInAncestorSet provideRequiresInAncestorSet(",
-            "      Set<InAncestor> inAncestors) {",
-            "    return new RequiresInAncestorSet();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAncestor provideInAncestor() {",
-            "    return new InAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  private RequiresInAncestorSet getRequiresInAncestorSet() {",
-            "    return AncestorModule_ProvideRequiresInAncestorSetFactory",
-            "        .provideRequiresInAncestorSet(getSetOfInAncestor());",
-            "  }",
-            "",
-            "  protected Set getSetOfInAncestor() {",
-            "    return ImmutableSet.<InAncestor>of(",
-            "        AncestorModule_ProvideInAncestorFactory.provideInAncestor());",
-            "  }",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final RequiresInAncestorSet missingWithSetDependency() {",
-            "      return DaggerAncestor.this.getRequiresInAncestorSet();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(
-        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<Multibound> instance();",
-            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound contribution() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<Multibound> instance() {",
-            "    return ImmutableSet.<Multibound>of(",
-            "        LeafModule_ContributionFactory.contribution());",
-            "  }",
-            "",
-            "  @Override",
-            "  public abstract MissingInLeaf_WillDependOnFrameworkInstance",
-            "      willDependOnFrameworkInstance();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
-            "      Provider<Set<Multibound>> frameworkInstance) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Set<Multibound> multibinds();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() { ",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      this.setOfMultiboundProvider =",
-            "          SetFactory.<Multibound>builder(1, 0)",
-            "              .addProvider(LeafModule_ContributionFactory.create())",
-            "              .build();",
-            "    }",
-            "",
-            "    protected Provider getSetOfMultiboundProvider() {",
-            "      return setOfMultiboundProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
-            "        willDependOnFrameworkInstance() {",
-            "      return AncestorModule_ProvidedInAncestorFactory.providedInAncestor(",
-            "          getSetOfMultiboundProvider());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void missingMultibindingInLeaf_onlyContributionsInAncestor_notReModifiedInRoot() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Set<Object> set();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Set<Object> set();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Object onlyContribution() {",
-            "    return new Object();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<Object> set() {",
-            "      return ImmutableSet.<Object>of(",
-            "          AncestorModule_OnlyContributionFactory.onlyContribution());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf leaf() {",
-            "      return new LeafImpl();",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private LeafImpl() {}",
-            // This tests a regression case where Dagger used to reimplement Leaf.set(), even though
-            // there were no new contributions, because the state change from missing -> 
-            // multibinding wasn't properly recorded
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideAnotherInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.setOfInEachSubcomponentProvider =",
-            "        SetFactory.<InEachSubcomponent>builder(2, 0)",
-            "            .addProvider(LeafModule_ProvideInLeafFactory.create())",
-            "            .addProvider(LeafModule_ProvideAnotherInLeafFactory.create())",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
-            "    return setOfInEachSubcomponentProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InEachSubcomponent> provideInAncestor() {",
-            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider = ",
-            "        new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected void configureInitialization() {",
-            "      super.configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          setOfInEachSubcomponentProvider,",
-            "          SetFactory.<InEachSubcomponent>builder(0, 2)",
-            "              .addCollectionProvider(super.contributionsInEachSubcomponent())",
-            "              .addCollectionProvider(",
-            "                  AncestorModule_ProvideInAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
-            "      return setOfInEachSubcomponentProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeaf() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InLeaf> contributionsInLeaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InLeaf provideInLeaf() {",
-            "    return new InLeaf();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InLeaf> contributionsInLeaf() {",
-            "    return ImmutableMap.<String, InLeaf>of(",
-            "        \"leafmodule\",",
-            "        LeafModule_ProvideInLeafFactory.provideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInAncestorOnly() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Map<String, InAncestor> contributionsInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Map<String, InAncestor> contributionsInAncestor();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InAncestor provideInAncestor() {",
-            "    return new InAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InAncestor> contributionsInAncestor() {",
-            "      return ImmutableMap.<String, InAncestor>of(\"ancestormodule\",",
-            "          AncestorModule_ProvideInAncestorFactory.provideInAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return ImmutableMap.<String, InEachSubcomponent>of(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.provideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return ImmutableMap.<String, InEachSubcomponent>builderWithExpectedSize(2)",
-            "          .put(\"ancestormodule\",",
-            "              AncestorModule_ProvideInAncestorFactory.provideInAncestor())",
-            "          .putAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestor_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Map<String, InEachSubcomponent>> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<Map<String, InEachSubcomponent>> ",
-            "    mapOfStringAndInEachSubcomponentProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.mapOfStringAndInEachSubcomponentProvider =",
-            "        MapFactory.<String, InEachSubcomponent>builder(1)",
-            "            .put(\"leafmodule\", LeafModule_ProvideInLeafFactory.create())",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<Map<String, InEachSubcomponent>> ",
-            "      contributionsInEachSubcomponent() {",
-            "    return mapOfStringAndInEachSubcomponentProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<String, InEachSubcomponent>> ",
-            "      mapOfStringAndInEachSubcomponentProvider = new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected void configureInitialization() { ",
-            "      super.configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      DelegateFactory.setDelegate(",
-            "          mapOfStringAndInEachSubcomponentProvider,",
-            "          MapFactory.<String, InEachSubcomponent>builder(2)",
-            "              .putAll(super.contributionsInEachSubcomponent())",
-            "              .put(",
-            "                  \"ancestormodule\",",
-            "                  AncestorModule_ProvideInAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Map<String, InEachSubcomponent>> ",
-            "        contributionsInEachSubcomponent() {",
-            "      return mapOfStringAndInEachSubcomponentProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InLeafAndGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InLeafAndGrandAncestor provideInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.provideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"grandancestormodule\")",
-            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      public Map<String, InLeafAndGrandAncestor>",
-            "          contributionsInLeafAndGrandAncestor() {",
-            "        return",
-            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
-            "                .put(\"grandancestormodule\",",
-            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
-            "                        .provideInGrandAncestor())",
-            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
-            "                .build();",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Collections;",
-            "import java.util.Map",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return Collections.<String, InEachSubcomponent>singletonMap(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.provideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compileWithoutGuava(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapBuilder;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
-            "          .put(\"ancestormodule\",",
-            "              AncestorModule_ProvideInAncestorFactory.provideInAncestor())",
-            "          .putAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compileWithoutGuava(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(
-        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<Integer, Multibound> instance();",
-            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound contribution() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<Integer, Multibound> instance() {",
-            "    return ImmutableMap.<Integer, Multibound>of(",
-            "        111, LeafModule_ContributionFactory.contribution());",
-            "  }",
-            "",
-            "  @Override",
-            "  public abstract MissingInLeaf_WillDependOnFrameworkInstance",
-            "      willDependOnFrameworkInstance();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
-            "      Provider<Map<Integer, Multibound>> frameworkInstance) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Map<Integer, Multibound> multibinds();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() { ",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      this.mapOfIntegerAndMultiboundProvider =",
-            "          MapFactory.<Integer, Multibound>builder(1)",
-            "              .put(111, LeafModule_ContributionFactory.create())",
-            "              .build();",
-            "    }",
-            "",
-            "    protected Provider getMapOfIntegerAndMultiboundProvider() {",
-            "      return mapOfIntegerAndMultiboundProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
-            "        willDependOnFrameworkInstance() {",
-            "      return AncestorModule_ProvidedInAncestorFactory.providedInAncestor(",
-            "          getMapOfIntegerAndMultiboundProvider());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_set() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Set<Multibound> set();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<Multibound> set();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<Multibound> set() {",
-            "    return ImmutableSet.<Multibound>of();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<Multibound> set() {",
-            "      return ImmutableSet.<Multibound>of(",
-            "          AncestorModule_FromAncestorFactory.fromAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_set_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Set<Multibound> set();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Set<Multibound>> set();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Provider<Set<Multibound>> set() {",
-            "    return SetFactory.<Multibound>empty();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<Multibound>> setOfMultiboundProvider =",
-            "        new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          setOfMultiboundProvider,",
-            "          SetFactory.<Multibound>builder(1, 0)",
-            "              .addProvider(AncestorModule_FromAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Set<Multibound>> set() {",
-            "      return setOfMultiboundProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_map() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Map<Integer, Multibound> map();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<Integer, Multibound> map();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<Integer, Multibound> map() {",
-            "    return ImmutableMap.<Integer, Multibound>of();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<Integer, Multibound> map() {",
-            "      return ImmutableMap.<Integer, Multibound>of(",
-            "          111, AncestorModule_FromAncestorFactory.fromAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_map_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Map<Integer, Multibound> map();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Map<Integer, Multibound>> map();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Provider<Map<Integer, Multibound>> map() {",
-            "    return MapFactory.<Integer, Multibound>emptyMapProvider();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider =",
-            "        new DelegateFactory<>()",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          mapOfIntegerAndMultiboundProvider,",
-            "          MapFactory.<Integer, Multibound>builder(1)",
-            "              .put(111, AncestorModule_FromAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Map<Integer, Multibound>> map() {",
-            "      return mapOfIntegerAndMultiboundProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void bindsMissingDep_Multibindings() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Binds",
-            "  @IntoSet",
-            "  CharSequence bindsMultibindingWithMissingDep(String string);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<CharSequence> set();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<CharSequence> set() {",
-            "    return ImmutableSet.<CharSequence>of(getBindsMultibindingWithMissingDep());",
-            "  }",
-            "",
-            // The expected output here is subtle: the Key of
-            // LeafModule.bindsMultibindingWithMissingDep() is Set<CharSequence>, but the binding
-            // method should only be returning an individual CharSequence. Otherwise the
-            // ImmutableSet factory method above will fail.
-            "  protected abstract CharSequence getBindsMultibindingWithMissingDep();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void multibindingsAndFastInit() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "PackagePrivate");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "interface MultibindingModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  @LeafScope",
-            "  static PackagePrivate setContribution() {",
-            "    return new PackagePrivate();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(1)",
-            "  @LeafScope",
-            "  static PackagePrivate mapContribution() {",
-            "    return new PackagePrivate();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafScope",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "@interface LeafScope {}"),
-        JavaFileObjects.forSourceLines(
-            "test.UsesMultibindings",
-            "package test;",
-            "",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.inject.Inject;",
-            "",
-            "class UsesMultibindings {",
-            "  @Inject",
-            "  UsesMultibindings(Set<PackagePrivate> set, Map<Integer, PackagePrivate> map) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@LeafScope",
-            "@Subcomponent(modules = MultibindingModule.class)",
-            "interface Leaf {",
-            "  UsesMultibindings entryPoint();",
-            "}"));
-
-    Compilation compilation =
-        compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE, FAST_INIT_MODE)
-            .compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "@GenerationOptions(fastInit = true)",
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  private PackagePrivate getSetContribution() {",
-            "    Object local = setContribution;",
-            "    if (local instanceof MemoizedSentinel) {",
-            "      synchronized (local) {",
-            "        local = setContribution;",
-            "        if (local instanceof MemoizedSentinel) {",
-            "          local = MultibindingModule_SetContributionFactory.setContribution();",
-            "          setContribution = DoubleCheck.reentrantCheck(setContribution, local);",
-            "        }",
-            "      }",
-            "    }",
-            "    return (PackagePrivate) local;",
-            "  }",
-            "",
-            "  private PackagePrivate getMapContribution() {",
-            "    Object local = mapContribution;",
-            "    if (local instanceof MemoizedSentinel) {",
-            "      synchronized (local) {",
-            "        local = mapContribution;",
-            "        if (local instanceof MemoizedSentinel) {",
-            "          local = MultibindingModule_MapContributionFactory.mapContribution();",
-            "          mapContribution = DoubleCheck.reentrantCheck(mapContribution, local);",
-            "        }",
-            "      }",
-            "    }",
-            "    return (PackagePrivate) local;",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesMultibindings entryPoint() {",
-            "    return new UsesMultibindings(",
-            "        getSetOfPackagePrivate(), getMapOfIntegerAndPackagePrivate());",
-            "  }",
-            "",
-            "  protected Set getSetOfPackagePrivate() {",
-            "    return ImmutableSet.<PackagePrivate>of(getSetContribution());",
-            "  }",
-            "",
-            "  protected Map getMapOfIntegerAndPackagePrivate() {",
-            "    return ImmutableMap.<Integer, PackagePrivate>of(1, getMapContribution());",
-            "  }",
-            "}");
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-  }
-
-  // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
-  private void createSimplePackagePrivateClasses(
-      ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
-    for (String className : ancillaryClasses) {
-      filesBuilder.add(
-          JavaFileObjects.forSourceLines(
-              String.format("test.%s", className),
-              "package test;",
-              "",
-              String.format("class %s { }", className)));
-    }
-  }
-
-  private static Compilation compile(Iterable<JavaFileObject> files) {
-    return compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE).compile(files);
-  }
-
-  private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
-    return daggerCompiler()
-        .withOptions(
-            AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION))
-        .compile(files);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
deleted file mode 100644
index 7d3cc6343..000000000
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ /dev/null
@@ -1,5677 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
-import static dagger.internal.codegen.Compilers.compilerWithOptions;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
-import static dagger.internal.codegen.GeneratedLines.GENERATION_OPTIONS_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ObjectArrays;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class AheadOfTimeSubcomponentsTest {
-  private static final String PRUNED_METHOD_BODY =
-      "throw new UnsupportedOperationException(\"This binding is not part of the final binding "
-          + "graph. The key was requested by a binding that was believed to possibly be part of "
-          + "the graph, but is no longer requested. If this exception is thrown, it is the result "
-          + "of a Dagger bug.\");";
-
-  @Test
-  public void missingBindings_fromComponentMethod() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  MissingInLeaf missingFromComponentMethod();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract MissingInLeaf missingFromComponentMethod();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final MissingInLeaf missingFromComponentMethod() {",
-            "      return AncestorModule_SatisfiedInAncestorFactory.satisfiedInAncestor();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void missingBindings_dependsOnBindingWithMatchingComponentMethod() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  MissingInLeaf missingComponentMethod();",
-            "  DependsOnComponentMethod dependsOnComponentMethod();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.DependsOnComponentMethod",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class DependsOnComponentMethod {",
-            "  @Inject DependsOnComponentMethod(MissingInLeaf missingInLeaf) {}",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract MissingInLeaf missingComponentMethod();",
-            "",
-            "  @Override",
-            "  public DependsOnComponentMethod dependsOnComponentMethod() {",
-            "    return new DependsOnComponentMethod(missingComponentMethod());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void missingBindings_dependsOnMissingBinding() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  DependsOnMissingBinding dependsOnMissingBinding();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.DependsOnMissingBinding",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class DependsOnMissingBinding {",
-            "  @Inject DependsOnMissingBinding(MissingInLeaf missing) {}",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public DependsOnMissingBinding dependsOnMissingBinding() {",
-            "    return new DependsOnMissingBinding((MissingInLeaf) getMissingInLeaf());",
-            "  }",
-            "",
-            "  protected abstract Object getMissingInLeaf();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected final Object getMissingInLeaf() {",
-            "      return AncestorModule_SatisfiedInAncestorFactory.satisfiedInAncestor();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void missingBindings_satisfiedInGreatAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  DependsOnMissingBinding dependsOnMissingBinding();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.DependsOnMissingBinding",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class DependsOnMissingBinding {",
-            "  @Inject DependsOnMissingBinding(MissingInLeaf missing) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GreatAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = SatisfiesMissingBindingModule.class)",
-            "interface GreatAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.SatisfiesMissingBindingModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class SatisfiesMissingBindingModule {",
-            "  @Provides",
-            "  static MissingInLeaf satisfy() { return new MissingInLeaf(); }",
-            "}"));
-    // DaggerLeaf+DaggerAncestor generated types are ignored - they're not the focus of this test
-    // and are tested elsewhere
-    JavaFileObject generatedGreatAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGreatAncestor implements GreatAncestor {",
-            "  protected DaggerGreatAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      protected final Object getMissingInLeaf() {",
-            "        return SatisfiesMissingBindingModule_SatisfyFactory.satisfy();",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatAncestor")
-        .hasSourceEquivalentTo(generatedGreatAncestor);
-  }
-
-  @Test
-  public void moduleInstanceDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface Leaf {",
-            "  String string();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Provides String provideString() { return \"florp\"; }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return TestModule_ProvideStringFactory.provideString(testModule());",
-            "  }",
-            "",
-            "  protected abstract TestModule testModule();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf leaf() {",
-            "      return new LeafImpl();",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private final TestModule testModule;",
-            "",
-            "      private LeafImpl() {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "",
-            "      @Override",
-            "      protected TestModule testModule() {",
-            "        return testModule;",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void moduleInstanceDependency_withModuleParams() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface Leaf {",
-            "  int getInt();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  private int i;",
-            "",
-            "  TestModule(int i) {}",
-            "",
-            "  @Provides int provideInt() {",
-            "    return i++;",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public int getInt() {",
-            "    return testModule().provideInt();",
-            "  }",
-            "",
-            "  protected abstract TestModule testModule();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf(TestModule module);",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf leaf(TestModule module) {",
-            "      Preconditions.checkNotNull(module);",
-            "      return new LeafImpl(module);",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private final TestModule testModule;",
-            "",
-            "      private LeafImpl(TestModule module) {",
-            "        this.testModule = module;",
-            "      }",
-            "",
-            "      @Override",
-            "      protected TestModule testModule() {",
-            "        return testModule;",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void generatedInstanceBinding() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Leaf build();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf.Builder leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  @Override",
-            "  public abstract Leaf.Builder leaf();",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf.Builder leaf() {",
-            "      return new LeafBuilder();",
-            "    }",
-            "",
-            "    private final class LeafBuilder implements Leaf.Builder {",
-            "      @Override",
-            "      public Leaf build() {",
-            "        return new LeafImpl();",
-            "      }",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private LeafImpl() {}",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void prunedGeneratedInstanceBinding() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PrunedSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface PrunedSubcomponent {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    PrunedSubcomponent build();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InstallsPrunedSubcomponentModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module(subcomponents = PrunedSubcomponent.class)",
-            "interface InstallsPrunedSubcomponentModule {}"),
-        JavaFileObjects.forSourceLines(
-            "test.DependsOnPrunedSubcomponentBuilder",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class DependsOnPrunedSubcomponentBuilder {",
-            "  @Inject DependsOnPrunedSubcomponentBuilder(PrunedSubcomponent.Builder builder) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.MaybeLeaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = InstallsPrunedSubcomponentModule.class)",
-            "interface MaybeLeaf {",
-            "  DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder();",
-            "}"));
-    JavaFileObject generatedMaybeLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerMaybeLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerMaybeLeaf implements MaybeLeaf {",
-            "  protected DaggerMaybeLeaf() {}",
-            "",
-            "  @Override",
-            "  public DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder() {",
-            "    return new DependsOnPrunedSubcomponentBuilder(",
-            "        (PrunedSubcomponent.Builder) getPrunedSubcomponentBuilder());",
-            "  }",
-            "",
-            "  protected abstract Object getPrunedSubcomponentBuilder();",
-            "",
-            "  protected abstract class PrunedSubcomponentImpl extends DaggerPrunedSubcomponent {",
-            "    protected PrunedSubcomponentImpl() {}",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerMaybeLeaf")
-        .hasSourceEquivalentTo(generatedMaybeLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PrunesGeneratedInstanceModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "interface PrunesGeneratedInstanceModule {",
-            "  @Provides",
-            "  static DependsOnPrunedSubcomponentBuilder pruneGeneratedInstance() {",
-            "    return new DependsOnPrunedSubcomponentBuilder(null);",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = PrunesGeneratedInstanceModule.class)",
-            "interface Root {",
-            "  MaybeLeaf actuallyLeaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public MaybeLeaf actuallyLeaf() {",
-            "    return new MaybeLeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class MaybeLeafImpl extends DaggerMaybeLeaf {",
-            "    private MaybeLeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected Object getPrunedSubcomponentBuilder() {",
-            "      " + PRUNED_METHOD_BODY,
-            "    }",
-            "",
-            "    @Override",
-            "    public DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder() {",
-            "      return PrunesGeneratedInstanceModule_PruneGeneratedInstanceFactory",
-            "          .pruneGeneratedInstance();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void optionalBindings_boundAndSatisfiedInSameSubcomponent() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "SatisfiedInSub");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = {SubModule.class, BindsSatisfiedInSubModule.class})",
-            "interface Sub {",
-            "  Optional<SatisfiedInSub> satisfiedInSub();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.SubModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class SubModule {",
-            "  @BindsOptionalOf abstract SatisfiedInSub optionalSatisfiedInSub();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.BindsSatisfiedInSubModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class BindsSatisfiedInSubModule {",
-            "  @Provides static SatisfiedInSub provideSatisfiedInSub() {",
-            "      return new SatisfiedInSub();",
-            "  }",
-            "}"));
-    JavaFileObject generatedSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSub",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerSub implements Sub {",
-            "  protected DaggerSub() {}",
-            "",
-            "  @Override",
-            "  public Optional<SatisfiedInSub> satisfiedInSub() {",
-            "    return Optional.of(",
-            "        BindsSatisfiedInSubModule_ProvideSatisfiedInSubFactory",
-            "            .provideSatisfiedInSub());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSub")
-        .hasSourceEquivalentTo(generatedSubcomponent);
-  }
-
-  @Test
-  public void optionalBindings_satisfiedInAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "SatisfiedInAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Optional<SatisfiedInAncestor> satisfiedInAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class LeafModule {",
-            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
-            "    return Optional.<SatisfiedInAncestor>empty();",
-            "  }",
-            "}");
-    Compilation compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class AncestorModule {",
-            "  @Provides",
-            "  static SatisfiedInAncestor satisfiedInAncestor(){",
-            "    return new SatisfiedInAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
-            "      return Optional.of(AncestorModule_SatisfiedInAncestorFactory",
-            "          .satisfiedInAncestor());",
-            "    }",
-            "",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void optionalBindings_satisfiedInGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "SatisfiedInGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class LeafModule {",
-            "  @BindsOptionalOf",
-            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
-            "    return Optional.<SatisfiedInGrandAncestor>empty();",
-            "  }",
-            "}");
-    Compilation compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GreatAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GreatAncestorModule.class)",
-            "interface GreatAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GreatAncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class GreatAncestorModule {",
-            "  @Provides",
-            "  static SatisfiedInGrandAncestor satisfiedInGrandAncestor(){",
-            "    return new SatisfiedInGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedGreatAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGreatAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGreatAncestor implements GreatAncestor {",
-            "  protected DaggerGreatAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      public final Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
-            "        return Optional.of(",
-            "            GreatAncestorModule_SatisfiedInGrandAncestorFactory",
-            "                .satisfiedInGrandAncestor());",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGreatAncestor")
-        .hasSourceEquivalentTo(generatedGreatAncestor);
-  }
-
-  @Test
-  public void optionalBindings_nonComponentMethodDependencySatisfiedInAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(
-        filesToCompile, "SatisfiedInAncestor", "RequiresOptionalSatisfiedInAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  RequiresOptionalSatisfiedInAncestor requiresOptionalSatisfiedInAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import java.util.Optional;",
-            "",
-            "@Module",
-            "abstract class LeafModule {",
-            "  @Provides static RequiresOptionalSatisfiedInAncestor",
-            "      provideRequiresOptionalSatisfiedInAncestor(",
-            "          Optional<SatisfiedInAncestor> satisfiedInAncestor) {",
-            "    return new RequiresOptionalSatisfiedInAncestor();",
-            "  }",
-            "",
-            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public RequiresOptionalSatisfiedInAncestor",
-            "      requiresOptionalSatisfiedInAncestor() {",
-            "    return LeafModule_ProvideRequiresOptionalSatisfiedInAncestorFactory",
-            "        .provideRequiresOptionalSatisfiedInAncestor(",
-            "            getOptionalOfSatisfiedInAncestor());",
-            "  }",
-            "",
-            "  protected Optional getOptionalOfSatisfiedInAncestor() {",
-            "    return Optional.<SatisfiedInAncestor>empty();",
-            "  }",
-            "}");
-    Compilation compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class AncestorModule {",
-            "  @Provides",
-            "  static SatisfiedInAncestor satisfiedInAncestor(){",
-            "    return new SatisfiedInAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected final Optional getOptionalOfSatisfiedInAncestor() {",
-            "      return Optional.of(",
-            "          AncestorModule_SatisfiedInAncestorFactory.satisfiedInAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "SatisfiedInGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Optional;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Optional<SatisfiedInGrandAncestor> boundInAncestorSatisfiedInGrandAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Optional<SatisfiedInGrandAncestor>",
-            "      boundInAncestorSatisfiedInGrandAncestor();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class AncestorModule {",
-            "  @BindsOptionalOf",
-            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Optional<SatisfiedInGrandAncestor>",
-            "        boundInAncestorSatisfiedInGrandAncestor() {",
-            "      return Optional.<SatisfiedInGrandAncestor>empty();",
-            "    }",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides static SatisfiedInGrandAncestor provideSatisfiedInGrandAncestor() {",
-            "    return new SatisfiedInGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Optional;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      public final Optional<SatisfiedInGrandAncestor>",
-            "          boundInAncestorSatisfiedInGrandAncestor() {",
-            "        return Optional.of(",
-            "            GrandAncestorModule_ProvideSatisfiedInGrandAncestorFactory",
-            "                .provideSatisfiedInGrandAncestor());",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation =
-        compile(
-            filesToCompile.build()
-            , CompilerMode.JAVA7
-            );
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void provisionOverInjection_providedInAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ProvidedInAncestor",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class ProvidedInAncestor {",
-            "  @Inject",
-            "  ProvidedInAncestor(String string) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  ProvidedInAncestor injectedInLeaf();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public ProvidedInAncestor injectedInLeaf() {",
-            "    return new ProvidedInAncestor(getString());",
-            "  }",
-            "",
-            "  protected abstract String getString();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static ProvidedInAncestor provideProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(\"static\");",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final ProvidedInAncestor injectedInLeaf() {",
-            "      return AncestorModule_ProvideProvidedInAncestorFactory",
-            "          .provideProvidedInAncestor();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void provisionOverInjection_providedInGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ProvidedInGrandAncestor",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class ProvidedInGrandAncestor {",
-            "  @Inject",
-            "  ProvidedInGrandAncestor(String string) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  ProvidedInGrandAncestor injectedInLeaf();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public ProvidedInGrandAncestor injectedInLeaf() {",
-            "    return new ProvidedInGrandAncestor(getString());",
-            "  }",
-            "",
-            "  protected abstract String getString();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides",
-            "  static ProvidedInGrandAncestor provideProvidedInGrandAncestor() {",
-            "    return new ProvidedInGrandAncestor(\"static\");",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      public final ProvidedInGrandAncestor injectedInLeaf() {",
-            "        return GrandAncestorModule_ProvideProvidedInGrandAncestorFactory",
-            "            .provideProvidedInGrandAncestor();",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void provisionOverInjection_indirectDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ProvidedInAncestor",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class ProvidedInAncestor {",
-            "  @Inject",
-            "  ProvidedInAncestor(String string) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InjectedInLeaf",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectedInLeaf {",
-            "  @Inject",
-            "  InjectedInLeaf(ProvidedInAncestor providedInAncestor) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  InjectedInLeaf injectedInLeaf();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public InjectedInLeaf injectedInLeaf() {",
-            "    return new InjectedInLeaf((ProvidedInAncestor) getProvidedInAncestor());",
-            "  }",
-            "",
-            "  protected abstract String getString();",
-            "",
-            "  protected Object getProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(getString());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static ProvidedInAncestor provideProvidedInAncestor() {",
-            "    return new ProvidedInAncestor(\"static\");",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected final Object getProvidedInAncestor() {",
-            "      return AncestorModule_ProvideProvidedInAncestorFactory",
-            "          .provideProvidedInAncestor();",
-            "    }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void provisionOverInjection_prunedIndirectDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "PrunedDependency");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.InjectsPrunedDependency",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsPrunedDependency {",
-            "  @Inject",
-            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
-            "",
-            "  private InjectsPrunedDependency() { }",
-            "",
-            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  InjectsPrunedDependency injectsPrunedDependency();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
-            "  }",
-            "",
-            "  protected abstract Object getPrunedDependency();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class RootModule {",
-            "  @Provides",
-            "  static InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency.create();",
-            "  }",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf leaf() {",
-            "    return new LeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    @Deprecated",
-            "    public Builder rootModule(RootModule rootModule) {",
-            "      Preconditions.checkNotNull(rootModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected Object getPrunedDependency() {",
-            "      " + PRUNED_METHOD_BODY,
-            "    }",
-            "",
-            "    @Override",
-            "    public InjectsPrunedDependency injectsPrunedDependency() {",
-            "      return RootModule_InjectsPrunedDependencyFactory",
-            "          .injectsPrunedDependency();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void provisionOverInjection_prunedDirectDependency_prunedInConcreteImplementation() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        // The binding for PrunedDependency will always exist, but will change from
-        // ModifiableBindingType.INJECTION to ModifiableBindingType.MISSING. We should correctly
-        // ignore this change leave the modifiable binding method alone
-        JavaFileObjects.forSourceLines(
-            "test.PrunedDependency",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class PrunedDependency {",
-            "  @Inject PrunedDependency() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InjectsPrunedDependency",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsPrunedDependency {",
-            "  @Inject",
-            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
-            "",
-            "  private InjectsPrunedDependency() { }",
-            "",
-            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  InjectsPrunedDependency injectsPrunedDependency();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
-            "  }",
-            "",
-            "  protected Object getPrunedDependency() {",
-            "    return new PrunedDependency();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class RootModule {",
-            "  @Provides",
-            "  static InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency.create();",
-            "  }",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf leaf() {",
-            "    return new LeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    @Deprecated",
-            "    public Builder rootModule(RootModule rootModule) {",
-            "      Preconditions.checkNotNull(rootModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public InjectsPrunedDependency injectsPrunedDependency() {",
-            "      return RootModule_InjectsPrunedDependencyFactory",
-            "          .injectsPrunedDependency();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void provisionOverInjection_prunedDirectDependency_prunedInAbstractImplementation() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        // The binding for PrunedDependency will always exist, but will change from
-        // ModifiableBindingType.INJECTION to ModifiableBindingType.MISSING. We should correctly
-        // ignore this change leave the modifiable binding method alone
-        JavaFileObjects.forSourceLines(
-            "test.PrunedDependency",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class PrunedDependency {",
-            "  @Inject PrunedDependency() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InjectsPrunedDependency",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsPrunedDependency {",
-            "  @Inject",
-            "  InjectsPrunedDependency(PrunedDependency prunedDependency) {}",
-            "",
-            "  private InjectsPrunedDependency() { }",
-            "",
-            "  static InjectsPrunedDependency create() { return new InjectsPrunedDependency(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  InjectsPrunedDependency injectsPrunedDependency();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
-            "  }",
-            "",
-            "  protected Object getPrunedDependency() {",
-            "    return new PrunedDependency();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency.create();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final InjectsPrunedDependency injectsPrunedDependency() {",
-            "      return AncestorModule_InjectsPrunedDependencyFactory",
-            "          .injectsPrunedDependency();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf leaf() {",
-            "      return new LeafImpl();",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private LeafImpl() {}",
-            // even though DaggerAncestor.LeafImpl.getPrunedDependency() was
-            // ModifiableBindingType.MISSING, it doesn't need to be reimplemented because there was
-            // a base implementation
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void productionSubcomponentAndModifiableFrameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Response", "ResponseDependency");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProductionSubcomponent;",
-            "import java.util.Set;",
-            "",
-            "@ProductionSubcomponent(modules = ResponseProducerModule.class)",
-            "interface Leaf {",
-            "  ListenableFuture<Set<Response>> responses();",
-            "",
-            "  @ProductionSubcomponent.Builder",
-            "  interface Builder {",
-            "    Leaf build();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.ResponseProducerModule",
-            "package test;",
-            "",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class ResponseProducerModule {",
-            "  @Produces",
-            "  @IntoSet",
-            "  static Response response(ResponseDependency responseDependency) {",
-            "    return new Response();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.internal.SetProducer;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.Set;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
-            "  private Producer<Set<Response>> responsesEntryPoint;",
-            "  private Producer<Response> responseProducer;",
-            "  private Producer<Set<Response>> setOfResponseProducer;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.responseProducer =",
-            "        ResponseProducerModule_ResponseFactory.create(",
-            "            getProductionImplementationExecutorProvider(),",
-            "            getProductionComponentMonitorProvider(),",
-            "            getResponseDependencyProducer());",
-            "    this.setOfResponseProducer =",
-            "        SetProducer.<Response>builder(1, 0)",
-            "            .addProducer(responseProducer).build();",
-            "    this.responsesEntryPoint =",
-            "        Producers.entryPointViewOf(getSetOfResponseProducer(), this);",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<Set<Response>> responses() {",
-            "    return responsesEntryPoint.get();",
-            "  }",
-            "",
-            "  protected abstract Provider<Executor>",
-            "      getProductionImplementationExecutorProvider();",
-            "",
-            "  protected abstract Provider<ProductionComponentMonitor>",
-            "      getProductionComponentMonitorProvider();",
-            "",
-            "  protected abstract Producer getResponseDependencyProducer();",
-            "",
-            "  protected Producer getSetOfResponseProducer() {",
-            "    return setOfResponseProducer;",
-            "  }",
-            "",
-            "  @Override",
-            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
-            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
-            "  }",
-            "}");
-
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ExecutorModule",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.MoreExecutors;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@Module",
-            "final class ExecutorModule {",
-            "  @Provides",
-            "  @Production",
-            "  static Executor executor() {",
-            "    return MoreExecutors.directExecutor();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProductionComponent;",
-            "",
-            "@ProductionComponent(",
-            "  modules = {",
-            "      ExecutorModule.class,",
-            "      ResponseDependencyProducerModule.class,",
-            "      RootMultibindingModule.class,",
-            "  })",
-            "interface Root {",
-            "  Leaf.Builder leaf();",
-            "",
-            "  @ProductionComponent.Builder",
-            "  interface Builder {",
-            "    Root build();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.ResponseDependencyProducerModule",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class ResponseDependencyProducerModule {",
-            "  @Produces",
-            "  static ListenableFuture<ResponseDependency> responseDependency() {",
-            "    return Futures.immediateFuture(new ResponseDependency());",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.RootMultibindingModule",
-            "package test;",
-            "",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class RootMultibindingModule {",
-            "  @Produces",
-            "  @IntoSet",
-            "  static Response response() {",
-            "    return new Response();",
-            "  }",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.InstanceFactory;",
-            "import dagger.internal.SetFactory;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.DelegateProducer;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.internal.SetProducer;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.Set;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root, CancellationListener {",
-            "  private Provider<Executor> productionImplementationExecutorProvider;",
-            "  private Provider<Root> rootProvider;",
-            "  private Provider<ProductionComponentMonitor> monitorProvider;",
-            "  private Producer<ResponseDependency> responseDependencyProducer;",
-            "  private Producer<Response> responseProducer;",
-            "",
-            "  private DaggerRoot() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  public static Root.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.productionImplementationExecutorProvider =",
-            "        DoubleCheck.provider((Provider) ExecutorModule_ExecutorFactory.create());",
-            "    this.rootProvider = InstanceFactory.create((Root) this);",
-            "    this.monitorProvider =",
-            "        DoubleCheck.provider(",
-            "            Root_MonitoringModule_MonitorFactory.create(",
-            "                rootProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
-            "    this.responseDependencyProducer =",
-            "        ResponseDependencyProducerModule_ResponseDependencyFactory.create(",
-            "            productionImplementationExecutorProvider, monitorProvider);",
-            "    this.responseProducer =",
-            "        RootMultibindingModule_ResponseFactory.create(",
-            "            productionImplementationExecutorProvider, monitorProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf.Builder leaf() {",
-            "    return new LeafBuilder();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(responseProducer, mayInterruptIfRunning);",
-            "    Producers.cancel(responseDependencyProducer, mayInterruptIfRunning);",
-            "  }",
-            "",
-            "  private static final class Builder implements Root.Builder {",
-            "    @Override",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  private final class LeafBuilder implements Leaf.Builder {",
-            "    @Override",
-            "    public Leaf build() {",
-            "      return new LeafImpl();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf implements CancellationListener {",
-            "    private Producer<Set<Response>> setOfResponseProducer = new DelegateProducer<>();",
-            "",
-            "    private LeafImpl() {",
-            "      configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateProducer.setDelegate(",
-            "          setOfResponseProducer,",
-            "          SetProducer.<Response>builder(1, 1)",
-            "              .addCollectionProducer(super.getSetOfResponseProducer())",
-            "              .addProducer(DaggerRoot.this.responseProducer)",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Provider<Executor> getProductionImplementationExecutorProvider() {",
-            "      return DaggerRoot.this.productionImplementationExecutorProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Provider<ProductionComponentMonitor>",
-            "        getProductionComponentMonitorProvider() {",
-            "      return DaggerRoot.this.monitorProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Producer getResponseDependencyProducer() {",
-            "      return DaggerRoot.this.responseDependencyProducer;",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Producer getSetOfResponseProducer() {",
-            "      return setOfResponseProducer;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void lazyOfModifiableBinding() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.Subcomponent;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Lazy<MissingInLeaf> lazy();",
-            "  Provider<Lazy<MissingInLeaf>> providerOfLazy();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.ProviderOfLazy;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Lazy<MissingInLeaf> lazy() {",
-            "    return DoubleCheck.lazy(getMissingInLeafProvider());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<Lazy<MissingInLeaf>> providerOfLazy() {",
-            "    return ProviderOfLazy.create(getMissingInLeafProvider());",
-            "  }",
-            "",
-            "  protected abstract Provider getMissingInLeafProvider();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected final Provider getMissingInLeafProvider() {",
-            "      return AncestorModule_SatisfiedInAncestorFactory.create();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void missingBindingAccessInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(
-        filesToCompile, "Missing", "DependsOnMissing", "ProvidedInAncestor_InducesSetBinding");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.Provides;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  static DependsOnMissing test(",
-            "      Missing missing,",
-            "      Provider<Missing> missingProvider,",
-            "      ProvidedInAncestor_InducesSetBinding missingInLeaf) {",
-            "    return new DependsOnMissing();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Object unresolvedSetBinding(",
-            "      Missing missing, Provider<Missing> missingProvider) {",
-            "    return new Object();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  DependsOnMissing instance();",
-            "  Provider<DependsOnMissing> frameworkInstance();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<DependsOnMissing> testProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.testProvider =",
-            "        LeafModule_TestFactory.create(",
-            "            getMissingProvider(), getProvidedInAncestor_InducesSetBindingProvider());",
-            "  }",
-            "",
-            "  @Override",
-            "  public DependsOnMissing instance() {",
-            "    return LeafModule_TestFactory.test(",
-            // TODO(b/117833324): remove these unnecessary casts
-            "        (Missing) getMissing(),",
-            "        getMissingProvider(),",
-            "        (ProvidedInAncestor_InducesSetBinding)",
-            "            getProvidedInAncestor_InducesSetBinding());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<DependsOnMissing> frameworkInstance() {",
-            "    return testProvider;",
-            "  }",
-            "",
-            "  protected abstract Object getMissing();",
-            "  protected abstract Provider getMissingProvider();",
-            "  protected abstract Object getProvidedInAncestor_InducesSetBinding();",
-            "  protected abstract Provider getProvidedInAncestor_InducesSetBindingProvider();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.Provides;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static ProvidedInAncestor_InducesSetBinding providedInAncestor(",
-            "      Set<Object> setThatInducesMissingBindingInChildSubclassImplementation) {",
-            "    return new ProvidedInAncestor_InducesSetBinding();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Object setContribution() {",
-            "    return new Object();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Object> unresolvedSetBindingProvider;",
-            "    private Provider<Set<Object>> setOfObjectProvider;",
-            "    private Provider<ProvidedInAncestor_InducesSetBinding> ",
-            "        providedInAncestorProvider = ",
-            "            new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected void configureInitialization() {",
-            "      super.configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    private Object getUnresolvedSetBinding() {",
-            "      return LeafModule_UnresolvedSetBindingFactory.unresolvedSetBinding(",
-            // TODO(b/117833324): remove this unnecessary cast
-            "          (Missing) getMissing(), getMissingProvider());",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.unresolvedSetBindingProvider =",
-            "          LeafModule_UnresolvedSetBindingFactory.create(getMissingProvider());",
-            "      this.setOfObjectProvider =",
-            "          SetFactory.<Object>builder(2, 0)",
-            "              .addProvider(AncestorModule_SetContributionFactory.create())",
-            "              .addProvider(unresolvedSetBindingProvider)",
-            "              .build();",
-            "      DelegateFactory.setDelegate(",
-            "          providedInAncestorProvider,",
-            "          AncestorModule_ProvidedInAncestorFactory.create(getSetOfObjectProvider()));",
-            "    }",
-            "",
-            "    protected Set<Object> getSetOfObject() {",
-            "      return ImmutableSet.<Object>of(",
-            "          AncestorModule_SetContributionFactory.setContribution(),",
-            "          getUnresolvedSetBinding());",
-            "    }",
-            "",
-            "    @Override",
-            "    protected final Object getProvidedInAncestor_InducesSetBinding() {",
-            "      return AncestorModule_ProvidedInAncestorFactory.providedInAncestor(",
-            "          getSetOfObject());",
-            "    }",
-            "",
-            "    protected Provider<Set<Object>> getSetOfObjectProvider() {",
-            "      return setOfObjectProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    protected final Provider getProvidedInAncestor_InducesSetBindingProvider() {",
-            "      return providedInAncestorProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void subcomponentBuilders() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "InducesDependenciesOnBuilderFields");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  private final Object object;",
-            "",
-            "  LeafModule(Object object) {",
-            "    this.object = object;",
-            "  }",
-            "",
-            "  @Provides",
-            "  Object fromModule() {",
-            "    return object;",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingsModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "interface MultibindingsModule {",
-            "  @Binds",
-            "  @IntoSet",
-            "  String string(String string);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Subcomponent;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = {LeafModule.class, MultibindingsModule.class})",
-            "interface Leaf {",
-            "  int bindsInstance();",
-            "  Object fromModule();",
-            "  InducesDependenciesOnBuilderFields inducesDependenciesOnBuilderFields();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    @BindsInstance Builder bindsInstance(int boundInstance);",
-            "    @BindsInstance Builder inducedInSubclass(String induced);",
-            "    Builder module(LeafModule module);",
-            "",
-            "    Leaf build();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Integer bindsInstance;",
-            "  private LeafModule leafModule;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization(",
-            "      LeafModule leafModuleParam, Integer bindsInstanceParam) {",
-            "    this.bindsInstance = bindsInstanceParam;",
-            "    this.leafModule = leafModuleParam;",
-            "  }",
-            "",
-            "  @Override",
-            "  public int bindsInstance() {",
-            "    return bindsInstance;",
-            "  }",
-            "",
-            "  @Override",
-            "  public Object fromModule() {",
-            "    return LeafModule_FromModuleFactory.fromModule(leafModule());",
-            "  }",
-            "",
-            "  @Override",
-            "  public abstract InducesDependenciesOnBuilderFields",
-            "      inducesDependenciesOnBuilderFields();",
-            "",
-            "  protected LeafModule leafModule() {",
-            "    return leafModule;",
-            "  }",
-            "",
-            "  public abstract static class Builder implements Leaf.Builder {",
-            "    protected Integer bindsInstance;",
-            "    protected String inducedInSubclass;",
-            "    protected LeafModule leafModule;",
-            "",
-            "    @Override",
-            "    public Builder bindsInstance(int boundInstance) {",
-            "      this.bindsInstance = Preconditions.checkNotNull(boundInstance);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder inducedInSubclass(String induced) {",
-            "      this.inducedInSubclass = Preconditions.checkNotNull(induced);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder module(LeafModule module) {",
-            "      this.leafModule = Preconditions.checkNotNull(module);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = MultibindingInducingModule.class)",
-            "interface Ancestor {",
-            "  Leaf.Builder leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingInducingModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import dagger.Provides;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface MultibindingInducingModule {",
-            "  @Provides",
-            "  static InducesDependenciesOnBuilderFields induce(",
-            "      Set<String> multibindingWithBuilderFieldDeps) { ",
-            "    return new InducesDependenciesOnBuilderFields();",
-            "  }",
-            "",
-            "  @Multibinds",
-            "  Set<String> multibinding();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  @Override",
-            "  public abstract Leaf.Builder leaf();",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private String inducedInSubclass;",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization(",
-            "        LeafModule leafModule,",
-            "        Integer bindsInstance,",
-            "        String inducedInSubclassParam) {",
-            "      this.inducedInSubclass = inducedInSubclassParam;",
-            "      configureInitialization(leafModule, bindsInstance);",
-            "    }",
-            "",
-            "    protected Set<String> getSetOfString() {",
-            "      return ImmutableSet.<String>of(inducedInSubclass);",
-            "    }",
-            "",
-            "    @Override",
-            "    public final InducesDependenciesOnBuilderFields",
-            "        inducesDependenciesOnBuilderFields() {",
-            "      return MultibindingInducingModule_InduceFactory.induce(getSetOfString());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Ancestor ancestor() {",
-            "    return new AncestorImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    private AncestorImpl() {}",
-            "",
-            "    @Override",
-            "    public Leaf.Builder leaf() {",
-            "      return new LeafBuilder();",
-            "    }",
-            "",
-            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
-            "      @Override",
-            "      public Leaf build() {",
-            // TODO(b/117833324): Can we stick the validations into a method on the base class
-            // builder so that the contents of this method are just call to that and then new
-            // FooImpl? But repeated modules may make this more complicated, since those *should*
-            // be null
-            "        Preconditions.checkBuilderRequirement(bindsInstance, Integer.class);",
-            "        Preconditions.checkBuilderRequirement(inducedInSubclass, String.class);",
-            "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
-            "        return new LeafImpl(leafModule, bindsInstance, inducedInSubclass);",
-            "      }",
-            "    }",
-            "",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private final LeafModule leafModule;",
-            "",
-            "      private LeafImpl(",
-            "          LeafModule leafModuleParam,",
-            "          Integer bindsInstance,",
-            "          String inducedInSubclass) {",
-            "        this.leafModule = leafModuleParam;",
-            "        configureInitialization(leafModuleParam, bindsInstance, inducedInSubclass);",
-            "      }",
-            "",
-            "      @Override",
-            "      protected LeafModule leafModule() {",
-            "        return leafModule;",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Used", "Unused");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.ModuleWithUsedBinding",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ModuleWithUsedBinding {",
-            "  @Provides",
-            "  Used used() {",
-            "    return new Used();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.ModuleWithUnusedBinding",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ModuleWithUnusedBinding {",
-            "  @Provides",
-            "  Unused unused() {",
-            "    return new Unused();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = {ModuleWithUsedBinding.class, ModuleWithUnusedBinding.class})",
-            "interface Leaf {",
-            "  Used used();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder setUsed(ModuleWithUsedBinding module);",
-            "    Builder setUnused(ModuleWithUnusedBinding module);",
-            "    Leaf build();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private ModuleWithUsedBinding moduleWithUsedBinding;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization(",
-            "      ModuleWithUsedBinding moduleWithUsedBindingParam) {",
-            "    this.moduleWithUsedBinding = moduleWithUsedBindingParam;",
-            "  }",
-            "",
-            "  @Override",
-            "  public Used used() {",
-            "    return ModuleWithUsedBinding_UsedFactory.used(",
-            "        moduleWithUsedBinding());",
-            "  }",
-            "",
-            "  protected ModuleWithUsedBinding moduleWithUsedBinding() {",
-            "    return moduleWithUsedBinding;",
-            "  }",
-            "",
-            "  public abstract static class Builder implements Leaf.Builder {",
-            "    protected ModuleWithUsedBinding moduleWithUsedBinding;",
-            "    protected ModuleWithUnusedBinding moduleWithUnusedBinding;",
-            "",
-            "    @Override",
-            "    public Builder setUsed(ModuleWithUsedBinding module) {",
-            "      this.moduleWithUsedBinding = Preconditions.checkNotNull(module);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder setUnused(ModuleWithUnusedBinding module) {",
-            "      this.moduleWithUnusedBinding = Preconditions.checkNotNull(module);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  Leaf.Builder leaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf.Builder leaf() {",
-            "    return new LeafBuilder();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
-            "    @Override",
-            "    public Leaf build() {",
-            "      if (moduleWithUsedBinding == null) {",
-            "        this.moduleWithUsedBinding = new ModuleWithUsedBinding();",
-            "      }",
-            // ModuleWithUnusedBinding is not verified since it's not used
-            "      return new LeafImpl(moduleWithUsedBinding);",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private final ModuleWithUsedBinding moduleWithUsedBinding;",
-            "",
-            "    private LeafImpl(ModuleWithUsedBinding moduleWithUsedBindingParam) {",
-            "      this.moduleWithUsedBinding = moduleWithUsedBindingParam;",
-            "      configureInitialization(moduleWithUsedBindingParam);",
-            "    }",
-            "",
-            "    @Override",
-            "    protected ModuleWithUsedBinding moduleWithUsedBinding() {",
-            "      return moduleWithUsedBinding;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void subcomponentBuilders_repeatedModule() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RepeatedModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class RepeatedModule {",
-            "  @Provides",
-            "  int i() {",
-            "    return 1;",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = RepeatedModule.class)",
-            "interface Leaf {",
-            "  int i();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder repeatedModule(RepeatedModule repeatedModule);",
-            "    Leaf build();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private RepeatedModule repeatedModule;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization(RepeatedModule repeatedModuleParam) {",
-            "    this.repeatedModule = repeatedModuleParam;",
-            "  }",
-            "",
-            "  @Override",
-            "  public int i() {",
-            "    return repeatedModule().i();",
-            "  }",
-            "",
-            "  protected RepeatedModule repeatedModule() {",
-            "    return repeatedModule;",
-            "  }",
-            "",
-            "  public abstract static class Builder implements Leaf.Builder {",
-            "    protected RepeatedModule repeatedModule;",
-            "",
-            "    @Override",
-            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
-            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RepeatedModule.class)",
-            "interface Root {",
-            "  Leaf.Builder leaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private final RepeatedModule repeatedModule;",
-            "",
-            "  private DaggerRoot(RepeatedModule repeatedModuleParam) {",
-            "    this.repeatedModule = repeatedModuleParam;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf.Builder leaf() {",
-            "    return new LeafBuilder();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private RepeatedModule repeatedModule;",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
-            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Root build() {",
-            "      if (repeatedModule == null) {",
-            "        this.repeatedModule = new RepeatedModule();",
-            "      }",
-            "      return new DaggerRoot(repeatedModule);",
-            "    }",
-            "  }",
-            "",
-            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
-            "    @Override",
-            "    public LeafBuilder repeatedModule(RepeatedModule repeatedModule) {",
-            "      throw new UnsupportedOperationException(",
-            "        String.format(",
-            "          \"%s cannot be set because it is inherited from the enclosing component\",",
-            "          RepeatedModule.class.getCanonicalName()));",
-            "    }",
-            "",
-            "    @Override",
-            "    public Leaf build() {",
-            "      return new LeafImpl();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {",
-            "      configureInitialization(null);",
-            "    }",
-            "",
-            "    @Override",
-            "    protected RepeatedModule repeatedModule() {",
-            "      return DaggerRoot.this.repeatedModule;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void bindsWithMissingDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Binds;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Binds Object missingBindsDependency(MissingInLeaf missing);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Object bindsWithMissingDependencyInLeaf();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Object bindsWithMissingDependencyInLeaf();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.MissingInLeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "interface MissingInLeafModule {",
-            "  @Provides",
-            "  static MissingInLeaf boundInRoot() {",
-            "    return new MissingInLeaf();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = MissingInLeafModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf leaf() {",
-            "    return new LeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Object bindsWithMissingDependencyInLeaf() {",
-            "      return MissingInLeafModule_BoundInRootFactory.boundInRoot();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void bindsWithMissingDependency_pruned() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "MissingInLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Binds;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Binds Object missingBindsDependency(MissingInLeaf missing);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.DependsOnBindsWithMissingDep",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class DependsOnBindsWithMissingDep {",
-            "  @Inject DependsOnBindsWithMissingDep(Object bindsWithMissingDep) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep() {",
-            "    return new DependsOnBindsWithMissingDep(getObject());",
-            "  }",
-            "",
-            "  protected abstract Object getObject();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PrunesInjectConstructorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "interface PrunesInjectConstructorModule {",
-            "  @Provides",
-            "  static DependsOnBindsWithMissingDep pruneInjectConstructor() {",
-            "    return new DependsOnBindsWithMissingDep(new Object());",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = PrunesInjectConstructorModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf leaf() {",
-            "    return new LeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected Object getObject() {",
-            "      " + PRUNED_METHOD_BODY,
-            "    }",
-            "",
-            "    @Override",
-            "    public DependsOnBindsWithMissingDep DependsOnBindsWithMissingDep() {",
-            "      return PrunesInjectConstructorModule_PruneInjectConstructorFactory",
-            "          .pruneInjectConstructor();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void modifiedProducerFromProvider() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "DependsOnModifiedProducerFromProvider");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "import dagger.Provides;",
-            "import java.util.Set;",
-            "",
-            "@ProducerModule",
-            "interface LeafModule {",
-            "  @Produces",
-            "  static DependsOnModifiedProducerFromProvider dependsOnModified(Set<String> set) {",
-            "    return new DependsOnModifiedProducerFromProvider();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.ProductionSubcomponent;",
-            "import java.util.Set;",
-            "",
-            "@ProductionSubcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Producer<DependsOnModifiedProducerFromProvider>",
-            "      dependsOnModifiedProducerFromProvider();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.Set;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
-            "  private Producer<DependsOnModifiedProducerFromProvider>",
-            "      dependsOnModifiedProducerFromProviderEntryPoint;",
-            "  private Producer<DependsOnModifiedProducerFromProvider> dependsOnModifiedProducer;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.dependsOnModifiedProducer =",
-            "        LeafModule_DependsOnModifiedFactory.create(",
-            "            getProductionImplementationExecutorProvider(),",
-            "            getProductionComponentMonitorProvider(),",
-            "            getSetOfStringProducer());",
-            "    this.dependsOnModifiedProducerFromProviderEntryPoint =",
-            "        Producers.entryPointViewOf(dependsOnModifiedProducer, this);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Producer<DependsOnModifiedProducerFromProvider> ",
-            "      dependsOnModifiedProducerFromProvider() {",
-            "    return dependsOnModifiedProducerFromProviderEntryPoint;",
-            "  }",
-            "",
-            "  protected abstract Provider<Executor> ",
-            "      getProductionImplementationExecutorProvider();",
-            "",
-            "  protected abstract Provider<ProductionComponentMonitor>",
-            "      getProductionComponentMonitorProvider();",
-            "",
-            "  protected abstract Producer<Set<String>> getSetOfStringProducer();",
-            "",
-            "  @Override",
-            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "    Producers.cancel(dependsOnModifiedProducer, mayInterruptIfRunning);",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.producers.Production;",
-            "import java.util.Set;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@Module",
-            "interface RootModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static String induceModificationInLeaf() {",
-            "    return new String();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @Production",
-            "  static Executor productionExecutor() {",
-            "    return null;",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.InstanceFactory;",
-            "import dagger.internal.SetFactory;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.CancellationListener;",
-            "import dagger.producers.internal.DelegateProducer;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.Set;",
-            "import java.util.concurrent.Executor;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private DaggerRoot() {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Root create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Leaf leaf() {",
-            "    return new LeafImpl();",
-            "  }",
-            "",
-            "  static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Root build() {",
-            "      return new DaggerRoot();",
-            "    }",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf implements CancellationListener {",
-            "    private Provider<Executor> productionImplementationExecutorProvider =",
-            "        new DelegateFactory<>();",
-            "    private Provider<Leaf> leafProvider;",
-            "    private Provider<ProductionComponentMonitor> monitorProvider =",
-            "        new DelegateFactory<>();",
-            "    private Provider<Set<String>> setOfStringProvider;",
-            "    private Producer<Set<String>> setOfStringProducer = new DelegateProducer<>();",
-            "",
-            "    private LeafImpl() {",
-            "      configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          productionImplementationExecutorProvider,",
-            "          DoubleCheck.provider(",
-            "              (Provider) RootModule_ProductionExecutorFactory.create()));",
-            "      this.leafProvider = InstanceFactory.create((Leaf) this);",
-            "      DelegateFactory.setDelegate(",
-            "          monitorProvider,",
-            "          DoubleCheck.provider(",
-            "              Leaf_MonitoringModule_MonitorFactory.create(",
-            "                  leafProvider,",
-            "                  getSetOfProductionComponentMonitorFactoryProvider())));",
-            "      this.setOfStringProvider =",
-            "          SetFactory.<String>builder(1, 0)",
-            "              .addProvider(RootModule_InduceModificationInLeafFactory.create())",
-            "              .build();",
-            "      DelegateProducer.setDelegate(",
-            "          setOfStringProducer,",
-            "          Producers.producerFromProvider(getSetOfStringProvider()));",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Provider<Executor> getProductionImplementationExecutorProvider() {",
-            "      return productionImplementationExecutorProvider;",
-            "    }",
-            "",
-            "    protected Provider<Set<ProductionComponentMonitor.Factory>> ",
-            "        getSetOfProductionComponentMonitorFactoryProvider() {",
-            "      return SetFactory.<ProductionComponentMonitor.Factory>empty();",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Provider<ProductionComponentMonitor> ",
-            "        getProductionComponentMonitorProvider() {",
-            "      return monitorProvider;",
-            "    }",
-            "",
-            "    protected Provider<Set<String>> getSetOfStringProvider() {",
-            "      return setOfStringProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Producer<Set<String>> getSetOfStringProducer() {",
-            "      return setOfStringProducer;",
-            "    }",
-            "",
-            "    @Override",
-            "    public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "      super.onProducerFutureCancelled(mayInterruptIfRunning);",
-            "      Producers.cancel(getSetOfStringProducer(), mayInterruptIfRunning);",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .hasSourceEquivalentTo(generatedRoot);
-  }
-
-  @Test
-  public void modifiableBindingMethods_namesDedupedAcrossImplementations() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "foo.Thing",
-            "package foo;",
-            "", // force multi-line format
-            "public interface Thing extends CharSequence {}"),
-        JavaFileObjects.forSourceLines(
-            "bar.Thing",
-            "package bar;",
-            "", // force multi-line format
-            "public interface Thing extends Runnable {}"),
-        JavaFileObjects.forSourceLines(
-            "test.WillInduceSetOfRunnable",
-            "package test;",
-            "", // force multi-line format
-            "class WillInduceSetOfRunnable {}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Provides",
-            "  static CharSequence depOnFooThing(foo.Thing thing) {",
-            "    return thing.toString();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Runnable depOnBarThing(bar.Thing thing) {",
-            "    return () -> {};",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  CharSequence inducesFoo();",
-            "  WillInduceSetOfRunnable willInduceSetOfRunnable();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            "import foo.Thing;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public CharSequence inducesFoo() {",
-            "    return LeafModule_DepOnFooThingFactory.depOnFooThing(getThing());",
-            "  }",
-            "",
-            "  @Override",
-            "  public abstract WillInduceSetOfRunnable willInduceSetOfRunnable();",
-            "",
-            "  protected abstract Thing getThing();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static WillInduceSetOfRunnable induce(Set<Runnable> set) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Set<Runnable> runnables();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import bar.Thing;",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    private Runnable getDepOnBarThing() {",
-            "      return LeafModule_DepOnBarThingFactory.depOnBarThing(getThing2());",
-            "    }",
-            "",
-            "    protected abstract Thing getThing2();",
-            "",
-            "    protected Set<Runnable> getSetOfRunnable() {",
-            "      return ImmutableSet.<Runnable>of(getDepOnBarThing());",
-            "    }",
-            "",
-            "    @Override",
-            "    public final WillInduceSetOfRunnable willInduceSetOfRunnable() {",
-            "      return AncestorModule_InduceFactory.induce(getSetOfRunnable());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  /**
-   * This test verifies that Dagger can find the appropriate child subcomponent
-   * super-implementation, even if it is not enclosed in the current component's
-   * super-implementation. This can happen if a subcomponent is installed with a module's {@code
-   * subcomponents} attribute, but the binding is not accessed in a super-implementation. To exhibit
-   * this, we use multibindings that reference the pruned subcomponent, but make the multibinding
-   * also unresolved in the base implementation. An ancestor component defines a binding that
-   * depends on the multibinding, which induces the previously unresolved multibinding
-   * contributions, which itself induces the previously unresolved subcomponent.
-   */
-  @Test
-  public void subcomponentInducedFromAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Inducer");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.InducedSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface InducedSubcomponent {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    InducedSubcomponent build();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.MaybeLeaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = InducedSubcomponentModule.class)",
-            "interface MaybeLeaf {",
-            "  Inducer inducer();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.MaybeLeaf",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module(subcomponents = InducedSubcomponent.class)",
-            "interface InducedSubcomponentModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Object inducedSet(InducedSubcomponent.Builder builder) {",
-            "    return new Object();",
-            "  }",
-            "}"));
-
-    JavaFileObject generatedMaybeLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerMaybeLeaf implements MaybeLeaf {",
-            "  protected DaggerMaybeLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract Inducer inducer();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerMaybeLeaf")
-        .hasSourceEquivalentTo(generatedMaybeLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static Inducer inducer(Set<Object> set) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Set<Object> set();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  MaybeLeaf noLongerLeaf();",
-            "}"));
-
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.GenerationOptions;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class MaybeLeafImpl extends DaggerMaybeLeaf {",
-            "    protected MaybeLeafImpl() {}",
-            "",
-            "    private Object getInducedSet() {",
-            "      return InducedSubcomponentModule_InducedSetFactory.inducedSet(",
-            // TODO(b/117833324): remove this unnecessary cast
-            "          (InducedSubcomponent.Builder) getInducedSubcomponentBuilder());",
-            "    }",
-            "",
-            "    protected abstract Object getInducedSubcomponentBuilder();",
-            "",
-            "    protected Set<Object> getSetOfObject() {",
-            "      return ImmutableSet.<Object>of(getInducedSet());",
-            "    }",
-            "",
-            "    @Override",
-            "    public final Inducer inducer() {",
-            "      return AncestorModule_InducerFactory.inducer(getSetOfObject());",
-            "    }",
-            "",
-            "    protected abstract class InducedSubcomponentImpl extends",
-            "        DaggerInducedSubcomponent {",
-            //       ^ Note that this is DaggerInducedSubcomponent, not
-            //         DaggerMaybeLeaf.InducedSubcomponentImpl
-            "      protected InducedSubcomponentImpl() {}",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void rootScopedAtInjectConstructor_effectivelyMissingInSubcomponent() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "ProvidesMethodRootScoped");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootScope",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "public @interface RootScope {}"),
-        JavaFileObjects.forSourceLines(
-            "test.AtInjectRootScoped",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "@RootScope",
-            "class AtInjectRootScoped {",
-            "  @Inject AtInjectRootScoped() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  AtInjectRootScoped shouldBeEffectivelyMissingInLeaf();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public abstract AtInjectRootScoped shouldBeEffectivelyMissingInLeaf();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@RootScope",
-            "@Component",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    @Override",
-            "    public AtInjectRootScoped shouldBeEffectivelyMissingInLeaf() {",
-            "      return DaggerRoot.this.atInjectRootScopedProvider.get();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  @Test
-  public void prunedModuleWithInstanceState() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Pruned");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Modified",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Modified {",
-            "  @Inject Modified(Pruned pruned) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  Pruned pruned() {",
-            "    return new Pruned();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Modified modified();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Modified modified() {",
-            "    return new Modified(LeafModule_PrunedFactory.pruned(leafModule()));",
-            "  }",
-            "",
-            "  protected abstract LeafModule leafModule();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class RootModule {",
-            "  @Provides",
-            "  static Modified modified() {",
-            "    return new Modified(null);",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    @Override",
-            "    public Modified modified() {",
-            "      return RootModule_ModifiedFactory.modified();",
-            "    }",
-            "",
-            "    @Override",
-            "    protected LeafModule leafModule() {",
-            "      return null;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  @Test
-  public void modifiableCycles() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class A {",
-            "  @Inject A(B b) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "class B {",
-            "  @Inject B(Provider<A> a) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Provider<A> frameworkInstanceCycle();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.GenerationOptions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<A> aProvider;",
-            "  private Provider<B> bProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.aProvider = new DelegateFactory<>();",
-            "    this.bProvider = B_Factory.create(frameworkInstanceCycle());",
-            "    DelegateFactory.setDelegate(aProvider, A_Factory.create(getBProvider()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<A> frameworkInstanceCycle() {",
-            "    return aProvider;",
-            "  }",
-            "",
-            "  protected Provider getBProvider() {",
-            "    return bProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  /**
-   * This tests a regression case where the component builder in the base implementation used one
-   * set of disambiguated names from all of the {@link ComponentDescriptor#requirements()}, and the
-   * final implementation used a different set of disambiguated names from the resolved {@link
-   * BindingGraph#componentRequirements()}. This resulted in generated output that didn't compile,
-   * as the builder implementation attempted to use the new names in validation, which didn't line
-   * up with the old names.
-   */
-  @Test
-  public void componentBuilderFields_consistencyAcrossImplementations() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "a.Mod",
-            "package a;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Named;",
-            "",
-            "@Module",
-            "public class Mod {",
-            "  @Provides",
-            "  @Named(\"a\")",
-            "  int i() { return 0; }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "b.Mod",
-            "package b;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Named;",
-            "",
-            "@Module",
-            "public class Mod {",
-            "  @Provides",
-            "  @Named(\"b\")",
-            "  int i() { return 0; }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "c.Mod",
-            "package c;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Named;",
-            "",
-            "@Module",
-            "public class Mod {",
-            "  @Provides",
-            "  @Named(\"c\")",
-            "  int i() { return 0; }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.HasUnusedModuleLeaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import javax.inject.Named;",
-            "",
-            "@Subcomponent(modules = {a.Mod.class, b.Mod.class, c.Mod.class})",
-            "interface HasUnusedModuleLeaf {",
-            "  @Named(\"a\") int a();",
-            // b omitted intentionally
-            "  @Named(\"c\") int c();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder setAMod(a.Mod mod);",
-            "    Builder setBMod(b.Mod mod);",
-            "    Builder setCMod(c.Mod mod);",
-            "    HasUnusedModuleLeaf build();",
-            "  }",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import a.Mod;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerHasUnusedModuleLeaf implements HasUnusedModuleLeaf {",
-            "  public abstract static class Builder implements HasUnusedModuleLeaf.Builder {",
-            "    protected Mod mod;",
-            "    protected b.Mod mod2;",
-            "    protected c.Mod mod3;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerHasUnusedModuleLeaf")
-        .containsElementsIn(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Root {",
-            "  HasUnusedModuleLeaf.Builder leaf();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import a.Mod;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  private final class HasUnusedModuleLeafBuilder",
-            "      extends DaggerHasUnusedModuleLeaf.Builder {",
-            "    @Override",
-            "    public HasUnusedModuleLeaf build() {",
-            "      if (mod == null) {",
-            "        this.mod = new Mod();",
-            "      }",
-            // Before this regression was fixed, `mod3` was instead `mod2`, since the `b.Mod` was
-            // pruned from the graph and did not need validation.
-            "      if (mod3 == null) {",
-            "        this.mod3 = new c.Mod();",
-            "      }",
-            "      return new HasUnusedModuleLeafImpl(mod, mod3);",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  @Test
-  public void dependencyExpressionCasting() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PublicType",
-            "package test;",
-            "", //
-            "public class PublicType {}"),
-        JavaFileObjects.forSourceLines(
-            "test.ModifiableNonPublicSubclass",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class ModifiableNonPublicSubclass extends PublicType {",
-            "  @Inject ModifiableNonPublicSubclass() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Parameterized",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Parameterized<T extends PublicType> {",
-            "  @Inject Parameterized(T t) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Parameterized<ModifiableNonPublicSubclass> parameterizedWithNonPublicSubtype();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  @Override",
-            "  public Parameterized<ModifiableNonPublicSubclass> ",
-            "      parameterizedWithNonPublicSubtype() {",
-            "    return Parameterized_Factory.newInstance(",
-            "        (ModifiableNonPublicSubclass) getModifiableNonPublicSubclass());",
-            "  }",
-            "",
-            "  protected Object getModifiableNonPublicSubclass() {",
-            "    return new ModifiableNonPublicSubclass();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-  }
-
-  @Test
-  public void multipleComponentMethodsForSameBindingRequest() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  String string1();",
-            "  String string2();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  @Override",
-            "  public final String string2() {",
-            "    return string1();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "interface RootModule {",
-            "  @Provides",
-            "  static String string() {",
-            "    return new String();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public String string1() {",
-            "      return RootModule_StringFactory.string();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  @Test
-  public void boundInstanceUsedOnlyInInitialize() {
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Subcomponent;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent",
-            "interface Sub {",
-            "  Provider<String> stringProvider();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    @BindsInstance",
-            "    Builder string(String string);",
-            "    Sub build();",
-            "  }",
-            "}");
-
-    JavaFileObject generated  =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.internal.InstanceFactory;",
-            "import dagger.internal.Preconditions;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerSub implements Sub {",
-            "  private Provider<String> stringProvider;",
-            "",
-            "  protected DaggerSub() {}",
-            "",
-            "  protected void configureInitialization(String stringParam) {",
-            "    initialize(stringParam);",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final String stringParam) {",
-            "    this.stringProvider = InstanceFactory.create(stringParam);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<String> stringProvider() {",
-            "    return stringProvider;",
-            "  }",
-            "}");
-
-    Compilation compilation = compile(ImmutableList.of(subcomponent));
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSub")
-        .containsElementsIn(generated);
-  }
-
-  @Test
-  public void packagePrivate_derivedFromFrameworkInstance_ComponentMethod() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PackagePrivate",
-            "package test;",
-            "",
-            "import dagger.Reusable;",
-            "import javax.inject.Inject;",
-            "",
-            "@Reusable", // Use @Reusable to force a framework field
-            "class PackagePrivate {",
-            "  @Inject PackagePrivate() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  PackagePrivate packagePrivate();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<PackagePrivate> packagePrivateProvider;",
-            "",
-            "  @Override",
-            "  public PackagePrivate packagePrivate() {",
-            "    return (PackagePrivate) getPackagePrivateProvider().get();",
-            "  }",
-            "",
-            "  protected Provider getPackagePrivateProvider() {",
-            "    return packagePrivateProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-  }
-
-  @Test
-  public void castModifiableMethodAccessedInFinalImplementation() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "PackagePrivate");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.PublicBaseType",
-            "package test;",
-            "", //
-            "public class PublicBaseType {}"),
-        JavaFileObjects.forSourceLines(
-            "test.PackagePrivateSubtype",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            // Force this to be a modifiable binding resolved in the ancestor even though the
-            // binding is requested in the leaf.
-            "@AncestorScope",
-            "class PackagePrivateSubtype extends PublicBaseType {",
-            "  @Inject PackagePrivateSubtype() {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorScope",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope @interface AncestorScope {}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Binds PublicBaseType publicBaseType(PackagePrivateSubtype subtype);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.InjectsOptionalOfModifiable",
-            "package test;",
-            "",
-            "import java.util.Optional;",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsOptionalOfModifiable {",
-            "  @Inject InjectsOptionalOfModifiable(",
-            "      Optional<PublicBaseType> optionalOfModifiable) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  InjectsOptionalOfModifiable injectsOptionalOfModifiable();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected abstract Optional<PublicBaseType> getOptionalOfPublicBaseType();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.InjectsPackagePrivateSubtype",
-            "package test;",
-            "",
-            "import java.util.Optional;",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsPackagePrivateSubtype {",
-            "  @Inject InjectsPackagePrivateSubtype(",
-            //     Force a modifiable binding method for PackagePrivateSubtype in Ancestor. The
-            //     final Leaf implementation will refer to this method, but will need to cast it
-            //     since the PackagePrivateSubtype is accessible from the current package, but the
-            //     method returns Object
-            "      PackagePrivateSubtype packagePrivateSubtype) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static PackagePrivateSubtype packagePrivateSubtype() {",
-            "    return new PackagePrivateSubtype();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@AncestorScope",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  InjectsPackagePrivateSubtype injectsPackagePrivateSubtype();",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected Object getPackagePrivateSubtype() {",
-            "    return getPackagePrivateSubtypeProvider().get();",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .containsElementsIn(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface RootModule {",
-            "  @BindsOptionalOf",
-            "  PublicBaseType optionalPublicBaseType();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = RootModule.class)",
-            "interface Root {",
-            "  Ancestor ancestor();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root {",
-            "  protected final class AncestorImpl extends DaggerAncestor {",
-            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      @Override",
-            "      protected Optional<PublicBaseType> getOptionalOfPublicBaseType() {",
-            "        return Optional.of(",
-            "            (PublicBaseType) AncestorImpl.this.getPackagePrivateSubtype());",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  @Test
-  public void injectInLeaf_ProductionInRoot() {
-    // most of this is also covered in ProducesMethodShadowsInjectConstructorTest, but this test
-    // asserts that the correct PrunedConcreteBindingExpression is used
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createSimplePackagePrivateClasses(filesToCompile, "Dependency", "Missing");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Injected",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Injected {",
-            "  @Inject Injected(Dependency dependency, Missing missing) {}",
-            "",
-            "  Injected(Dependency dependency) {}",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "interface LeafModule {",
-            "  @Produces",
-            "  static Object dependsOnInjectReplacedWithProduces(Injected injected) {",
-            "    return new Object();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Producer<Object> objectProducer();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            GENERATION_OPTIONS_ANNOTATION,
-            GENERATED_CODE_ANNOTATIONS,
-            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.injectedProvider = Injected_Factory.create(",
-            "        getDependencyProvider(), getMissingProvider());",
-            "    this.injectedProducer = Producers.producerFromProvider(getInjectedProvider());",
-            "    this.dependsOnInjectReplacedWithProducesProducer =",
-            "        LeafModule_DependsOnInjectReplacedWithProducesFactory.create(",
-            "            getProductionImplementationExecutorProvider(),",
-            "            getProductionComponentMonitorProvider(),",
-            "            getInjectedProducer());",
-            "    this.objectProducerEntryPoint =",
-            "        Producers.entryPointViewOf(",
-            "            dependsOnInjectReplacedWithProducesProducer, this);",
-            "  }",
-            "",
-            "  protected abstract Provider getDependencyProvider();",
-            "  protected abstract Provider getMissingProvider();",
-            "",
-            "  protected Provider getInjectedProvider() {",
-            "    return injectedProvider;",
-            "  }",
-            "",
-            "  protected Producer getInjectedProducer() {",
-            "    return injectedProducer;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .containsElementsIn(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.RootModule",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.MoreExecutors;",
-            "import dagger.Provides;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@ProducerModule",
-            "interface RootModule {",
-            "  @Produces",
-            "  static Injected replaceInjectWithProduces(Dependency dependency) {",
-            "    return new Injected(dependency);",
-            "  }",
-            "",
-            "  @Produces",
-            "  static Dependency dependency() {",
-            "    return new Dependency();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @Production",
-            "  static Executor executor() {",
-            "    return MoreExecutors.directExecutor();",
-            "  }",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Root",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionComponent;",
-            "",
-            "@ProductionComponent(modules = RootModule.class)",
-            "interface Root {",
-            "  Leaf leaf();",
-            "}"));
-
-    JavaFileObject generatedRoot =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerRoot",
-            "package test;",
-            "",
-            GENERATED_CODE_ANNOTATIONS,
-            "final class DaggerRoot implements Root, CancellationListener {",
-            "  private Producer<Dependency> dependencyProducer;",
-            "  private Producer<Injected> replaceInjectWithProducesProducer;",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.productionImplementationExecutorProvider =",
-            "        DoubleCheck.provider((Provider) RootModule_ExecutorFactory.create());",
-            "    this.rootProvider = InstanceFactory.create((Root) this);",
-            "    this.monitorProvider =",
-            "        DoubleCheck.provider(",
-            "            Root_MonitoringModule_MonitorFactory.create(",
-            "                rootProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
-            "    this.dependencyProducer =",
-            "        RootModule_DependencyFactory.create(",
-            "            productionImplementationExecutorProvider, monitorProvider);",
-            "    this.replaceInjectWithProducesProducer =",
-            "        RootModule_ReplaceInjectWithProducesFactory.create(",
-            "            productionImplementationExecutorProvider,",
-            "            monitorProvider,",
-            "            dependencyProducer);",
-            "  }",
-            "",
-            "  protected final class LeafImpl extends DaggerLeaf",
-            "      implements CancellationListener {",
-            "    @Override",
-            "    protected Provider getDependencyProvider() {",
-            "      return MissingBindingFactory.create();",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Provider getMissingProvider() {",
-            "      return MissingBindingFactory.create();",
-            "    }",
-            "",
-            "    @Override",
-            "    protected Producer getInjectedProducer() {",
-            "      return DaggerRoot.this.replaceInjectWithProducesProducer;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerRoot")
-        .containsElementsIn(generatedRoot);
-  }
-
-  // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
-  private void createSimplePackagePrivateClasses(
-      ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
-    for (String className : ancillaryClasses) {
-      filesBuilder.add(
-          JavaFileObjects.forSourceLines(
-              String.format("test.%s", className),
-              "package test;",
-              "",
-              String.format("class %s { }", className)));
-    }
-  }
-
-  private static Compilation compile(Iterable<JavaFileObject> files, CompilerMode... modes) {
-    return compilerWithOptions(
-            ObjectArrays.concat(
-                new CompilerMode[] {AHEAD_OF_TIME_SUBCOMPONENTS_MODE}, modes, CompilerMode.class))
-        .compile(files);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java b/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java
deleted file mode 100644
index fda58599f..000000000
--- a/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.auto.common.AnnotationMirrors;
-import com.google.testing.compile.CompilationRule;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.lang.model.element.AnnotationMirror;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests {@link TypeProtoConverter}. */
-@RunWith(JUnit4.class)
-public class AnnotationProtoConverterTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private DaggerElements elements;
-  private DaggerTypes types;
-  private AnnotationProtoConverter annotationProtoConverter;
-
-  @Before
-  public void setUp() {
-    this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
-    this.types = new DaggerTypes(compilationRule.getTypes(), elements);
-    this.annotationProtoConverter =
-        new AnnotationProtoConverter(new TypeProtoConverter(types, elements));
-  }
-
-  @Retention(RetentionPolicy.RUNTIME)
-  @interface TestAnnotation {
-    byte b();
-    boolean bool();
-    short s();
-    char c();
-    int i();
-    long l();
-    double d();
-    float f();
-
-    String string();
-    RetentionPolicy enumValue();
-    Class<?> classValue();
-    HasDefaults[] nestedAnnotations();
-  }
-
-  @Retention(RetentionPolicy.RUNTIME)
-  @interface HasDefaults {
-    int value() default 2;
-  }
-
-  @TestAnnotation(
-      b = 1,
-      bool = true,
-      s = 2,
-      c = 'c',
-      i = 4,
-      l = 5,
-      d = 6.0d,
-      f = 7.0f,
-      string = "hello, world",
-      enumValue = RetentionPolicy.CLASS,
-      classValue = AnnotationProtoConverter.class,
-      nestedAnnotations = {@HasDefaults, @HasDefaults(8)})
-  static class TestSubject {}
-
-  @Test
-  public void conversion() {
-    AnnotationMirror actual =
-        getOnlyElement(elements.getTypeElement(TestSubject.class).getAnnotationMirrors());
-    AnnotationMirror translated =
-        annotationProtoConverter.fromProto(AnnotationProtoConverter.toProto(actual));
-    assertThat(AnnotationMirrors.equivalence().equivalent(actual, translated)).isTrue();
-  }
-}
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index ad214ff57..d213aa91c 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -35,7 +35,6 @@ GenJavaTests(
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
-        "//java/dagger/internal/codegen/serialization",
         "//java/dagger/model",
         "//java/dagger/model/testing",
         "//java/dagger/producers",
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index 23aa3127a..86ce53d13 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -23,9 +23,6 @@
 enum CompilerMode {
   DEFAULT_MODE,
   FAST_INIT_MODE("-Adagger.fastInit=enabled"),
-  AHEAD_OF_TIME_SUBCOMPONENTS_MODE(
-      "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
-      "-Adagger.emitModifiableMetadataAnnotations=disabled"),
   JAVA7("-source", "7", "-target", "7"),
   ;
 
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index d526ec944..ee369538e 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -64,9 +64,7 @@
   @Before public void setUp() {
     this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
     this.types = new DaggerTypes(compilationRule.getTypes(), elements);
-    TypeProtoConverter typeProtoConverter = new TypeProtoConverter(types, elements);
-    this.keyFactory = new KeyFactory(
-        types, elements, typeProtoConverter, new AnnotationProtoConverter(typeProtoConverter));
+    this.keyFactory = new KeyFactory(types, elements);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
diff --git a/javatests/dagger/internal/codegen/TypeProtoConverterTest.java b/javatests/dagger/internal/codegen/TypeProtoConverterTest.java
deleted file mode 100644
index 8c8628cfd..000000000
--- a/javatests/dagger/internal/codegen/TypeProtoConverterTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2019 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertWithMessage;
-import static javax.lang.model.util.ElementFilter.fieldsIn;
-
-import com.google.testing.compile.CompilationRule;
-import dagger.internal.Factory;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import dagger.internal.codegen.langmodel.DaggerTypes;
-import dagger.internal.codegen.serialization.TypeProto;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.type.TypeMirror;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests {@link TypeProtoConverter}. */
-@RunWith(JUnit4.class)
-public class TypeProtoConverterTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private DaggerElements elements;
-  private DaggerTypes types;
-  private TypeProtoConverter typeProtoConverter;
-
-  @Before
-  public void setUp() {
-    this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
-    this.types = new DaggerTypes(compilationRule.getTypes(), elements);
-    this.typeProtoConverter = new TypeProtoConverter(types, elements);
-  }
-
-  static class Outer<O> {
-    @SuppressWarnings("ClassCanBeStatic") // We want to specifically test inner classes
-    class Inner<I> {}
-  }
-
-  @SuppressWarnings({"rawtypes", "unused"})
-  static class TypeMirrorConversionSubjects {
-    private Map rawMap;
-    private List<String> listOfString;
-    private List<HashMap<String, Integer>> listOfHashMapOfStringToInteger;
-    private Map<HashMap<String, Integer>, Set<Factory>> mapOfHashMapOfStringToIntegerToSetOfFactory;
-    private Map<HashMap<String, Integer>, Set<Factory>>[][]
-        arrayOfArrayOfMapOfHashMapOfStringToIntegerToSetOfFactory;
-    private Map<HashMap<?, Integer>, ?> mapOfHashMapOfWildcardToIntegerToWildcard;
-    private List<? extends String> listOfWildcardExtendsString;
-    private List<? extends Set<? super String>> listOfWildcardExtendsSetOfWildcardSuperString;
-    private Outer<Object>.Inner<Integer> outerOfObjectDotInnerOfInteger;
-    private List<int[]> listOfIntArray;
-    private List<? extends CharSequence[]> listOfWildcardExtendsCharSequenceArray;
-  }
-
-  @Test
-  public void typeMirrorProtoConversions() {
-    assertProtoConversionEquality(fieldType("rawMap"));
-    assertProtoConversionEquality(fieldType("listOfString"));
-    assertProtoConversionEquality(fieldType("listOfHashMapOfStringToInteger"));
-    assertProtoConversionEquality(fieldType("mapOfHashMapOfStringToIntegerToSetOfFactory"));
-    assertProtoConversionEquality(
-        fieldType("arrayOfArrayOfMapOfHashMapOfStringToIntegerToSetOfFactory"));
-    assertProtoConversionEquality(fieldType("mapOfHashMapOfWildcardToIntegerToWildcard"));
-    assertProtoConversionEquality(fieldType("listOfWildcardExtendsString"));
-    assertProtoConversionEquality(fieldType("listOfWildcardExtendsSetOfWildcardSuperString"));
-    assertProtoConversionEquality(fieldType("outerOfObjectDotInnerOfInteger"));
-    assertProtoConversionEquality(fieldType("listOfIntArray"));
-    assertProtoConversionEquality(fieldType("listOfWildcardExtendsCharSequenceArray"));
-  }
-
-  private TypeMirror fieldType(String fieldName) {
-    return fieldsIn(
-            elements.getTypeElement(TypeMirrorConversionSubjects.class).getEnclosedElements())
-        .stream()
-        .filter(field -> field.getSimpleName().contentEquals(fieldName))
-        .findFirst()
-        .get()
-        .asType();
-  }
-
-  /**
-   * Converts {@link TypeMirror} to a {@link dagger.internal.codegen.serialization.TypeProto} and
-   * back to a {@link TypeMirror}. Asserts that the round-trip conversion is lossless.
-   */
-  private void assertProtoConversionEquality(TypeMirror typeMirror) {
-    TypeProto toProto = TypeProtoConverter.toProto(typeMirror);
-    TypeMirror fromProto = typeProtoConverter.fromProto(toProto);
-    assertWithMessage("expected: %s\nactual  : %s", typeMirror, fromProto)
-        .that(types.isSameType(typeMirror, fromProto))
-        .isTrue();
-  }
-}
diff --git a/test_defs.bzl b/test_defs.bzl
index 15ab299f3..f4aca57b7 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -17,15 +17,6 @@
 # The key will be appended to the generated test names to ensure uniqueness.
 BUILD_VARIANTS = {
     "FastInit": ["-Adagger.fastInit=enabled"],
-    "AheadOfTimeSubcomponents": ["-Adagger.experimentalAheadOfTimeSubcomponents=enabled"],
-    "FastInitAndAheadOfTimeSubcomponents": [
-        "-Adagger.fastInit=enabled",
-        "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
-    ],
-    "AheadOfTimeSubcomponents_ForceUseSerializedComponentImplementations": [
-        "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
-        "-Adagger.forceUseSerializedComponentImplementations=enabled",
-    ],
 }
 
 # TODO(ronshapiro): convert this to use bazel_common
