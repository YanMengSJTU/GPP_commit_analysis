diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 7ac1d1804..8b0ffc20e 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -412,22 +412,22 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
   private BindingExpression provisionBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
     switch (requestKind) {
-      case PRODUCER:
-        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
-
       case INSTANCE:
         return instanceBindingExpression(resolvedBindings);
 
-      case FUTURE:
-        return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
+      case PROVIDER:
+        return providerBindingExpression(resolvedBindings);
 
       case LAZY:
       case PRODUCED:
       case PROVIDER_OF_LAZY:
         return new DerivedFromProviderBindingExpression(resolvedBindings, requestKind, this, types);
 
-      case PROVIDER:
-        return providerBindingExpression(resolvedBindings);
+      case PRODUCER:
+        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
+
+      case FUTURE:
+        return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
 
       case MEMBERS_INJECTION:
         throw new IllegalArgumentException();
@@ -436,6 +436,35 @@ private BindingExpression provisionBindingExpression(
     throw new AssertionError();
   }
 
+  /**
+   * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
+   *
+   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
+   * cached} can use a {@link DelegateBindingExpression}.
+   *
+   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
+   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
+   * case, just use that Provider directly).
+   *
+   * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
+   */
+  private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
+    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
+        && !needsCaching(resolvedBindings)) {
+      return new DelegateBindingExpression(
+          resolvedBindings, RequestKind.PROVIDER, this, types, elements);
+    } else if (compilerOptions.experimentalAndroidMode()
+        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
+        && !(instanceBindingExpression(resolvedBindings)
+        instanceof DerivedFromProviderBindingExpression)) {
+      return wrapInMethod(
+          resolvedBindings,
+          RequestKind.PROVIDER,
+          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
+    }
+    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
+  }
+
   /**
    * Returns a binding expression that uses a {@link dagger.producers.Producer} field for a
    * provision binding.
@@ -592,35 +621,6 @@ private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings
             && !requiresReleasableReferences(resolvedBindings));
   }
 
-  /**
-   * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
-   *
-   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
-   * cached} can use a {@link DelegateBindingExpression}.
-   *
-   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
-   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
-   * case, just use that Provider directly).
-   *
-   * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
-   */
-  private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
-        && !needsCaching(resolvedBindings)) {
-      return new DelegateBindingExpression(
-          resolvedBindings, RequestKind.PROVIDER, this, types, elements);
-    } else if (compilerOptions.experimentalAndroidMode()
-        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
-        && !(instanceBindingExpression(resolvedBindings)
-            instanceof DerivedFromProviderBindingExpression)) {
-      return wrapInMethod(
-          resolvedBindings,
-          RequestKind.PROVIDER,
-          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
-    }
-    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
-  }
-
   /**
    * Returns a binding expression that uses a given one as the body of a method that users call. If
    * a component provision method matches it, it will be the method implemented. If not, a new
