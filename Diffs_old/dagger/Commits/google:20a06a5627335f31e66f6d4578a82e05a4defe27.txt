diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
deleted file mode 100644
index 578fb5ffa..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import java.lang.annotation.Annotation;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with a component or production component
- * as part of the {@link ComponentProcessor}.
- */
-abstract class AbstractComponentProcessingStep implements ProcessingStep {
-
-  private final Class<? extends Annotation> componentAnnotation;
-  private final Messager messager;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
-  private final BindingGraphValidator bindingGraphValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
-  private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
-
-  AbstractComponentProcessingStep(
-      Class<? extends Annotation> componentAnnotation,
-      Messager messager,
-      ComponentHierarchyValidator componentHierarchyValidator,
-      BindingGraphValidator bindingGraphValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    this.componentAnnotation = componentAnnotation;
-    this.messager = messager;
-    this.componentHierarchyValidator = componentHierarchyValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
-    this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
-  }
-
-  @Override
-  public final ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    ComponentElementValidator componentElementValidator =
-        componentElementValidator(elementsByAnnotation);
-    for (Element element : elementsByAnnotation.get(componentAnnotation)) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      try {
-        if (componentElementValidator.validateComponent(componentTypeElement, messager)) {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.forComponent(componentTypeElement);
-          ValidationReport<TypeElement> hierarchyReport =
-              componentHierarchyValidator.validate(componentDescriptor);
-          hierarchyReport.printMessagesTo(messager);
-          if (hierarchyReport.isClean()) {
-            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            ValidationReport<TypeElement> graphReport =
-                bindingGraphValidator.validate(bindingGraph);
-            graphReport.printMessagesTo(messager);
-            if (graphReport.isClean()) {
-              generateComponent(bindingGraph);
-            }
-          }
-        }
-      } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentTypeElement);
-      }
-    }
-    return rejectedElements.build();
-  }
-
-  private void generateComponent(BindingGraph bindingGraph) {
-    try {
-      componentGenerator.generate(bindingGraph);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
-  }
-
-  /**
-   * Returns an object that can validate a type element annotated with the component type.
-   */
-  protected abstract ComponentElementValidator componentElementValidator(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
-
-  /**
-   * Validates a component type element.
-   */
-  protected static abstract class ComponentElementValidator {
-    /**
-     * Validates a component type element. Prints any messages about the element to
-     * {@code messager}.
-     *
-     * @throws TypeNotPresentException if any type required to validate the component cannot be
-     *     found
-     */
-    abstract boolean validateComponent(TypeElement componentTypeElement, Messager messager);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index ba96ebfd3..fb9515486 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -51,21 +51,22 @@
 class BuilderValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
 
-  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
+  BuilderValidator(Elements elements, Types types) {
     this.elements = elements;
     this.types = types;
-    this.componentType = componentType;
   }
 
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
+
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
-    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
+    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
 
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 650fb9dcc..608a8dd56 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -18,12 +18,14 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Lazy;
@@ -99,6 +101,25 @@
       return Optional.fromNullable(getOnlyElement(kinds, null));
     }
 
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #builderAnnotationType() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
+
     Kind(
         Class<? extends Annotation> annotationType,
         Class<? extends Annotation> builderType,
@@ -116,9 +137,58 @@
       return builderType;
     }
 
+    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
+        case PRODUCTION_COMPONENT:
+          return Sets.immutableEnumSet(
+              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
+        default:
+          throw new AssertionError(this);
+      }
+    }
+
+    ImmutableSet<Kind> subcomponentKinds() {
+      switch (this) {
+        case COMPONENT:
+        case SUBCOMPONENT:
+          return ImmutableSet.of(SUBCOMPONENT);
+        case PRODUCTION_COMPONENT:
+          return ImmutableSet.of();
+        default:
+          throw new AssertionError();
+      }
+    }
+
     boolean isTopLevel() {
       return isTopLevel;
     }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.annotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
+      return TO_ANNOTATION_TYPE;
+    }
+
+    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
+        new Function<Kind, Class<? extends Annotation>>() {
+          @Override
+          public Class<? extends Annotation> apply(Kind kind) {
+            return kind.builderAnnotationType();
+          }
+        };
+
+    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
+      return TO_BUILDER_ANNOTATION_TYPE;
+    }
   }
 
   abstract Kind kind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 39b21ca32..fdc53d569 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,115 +17,160 @@
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
+import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic.Kind;
 
 /**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link Component} annotation
+ * A {@link ProcessingStep} that is responsible for dealing with a component or production component
  * as part of the {@link ComponentProcessor}.
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep extends AbstractComponentProcessingStep {
+final class ComponentProcessingStep implements ProcessingStep {
+  private final ComponentDescriptor.Kind componentKind;
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentValidator subcomponentValidator;
-  private final BuilderValidator componentBuilderValidator;
-  private final BuilderValidator subcomponentBuilderValidator;
+  private final BuilderValidator builderValidator;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
 
   ComponentProcessingStep(
+      ComponentDescriptor.Kind componentKind,
       Messager messager,
       ComponentValidator componentValidator,
       ComponentValidator subcomponentValidator,
-      BuilderValidator componentBuilderValidator,
-      BuilderValidator subcomponentBuilderValidator,
+      BuilderValidator builderValidator,
       ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
-    super(
-        Component.class,
-        messager,
-        componentHierarchyValidator,
-        bindingGraphValidator,
-        componentDescriptorFactory,
-        bindingGraphFactory,
-        componentGenerator);
+    this.componentKind = componentKind;
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.subcomponentValidator = subcomponentValidator;
-    this.componentBuilderValidator = componentBuilderValidator;
-    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+    this.builderValidator = builderValidator;
+    this.componentHierarchyValidator = componentHierarchyValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
-        Subcomponent.class, Subcomponent.Builder.class);
+    return ImmutableSet.of(
+        Component.class,
+        Component.Builder.class,
+        ProductionComponent.class,
+        ProductionComponent.Builder.class,
+        Subcomponent.class,
+        Subcomponent.Builder.class);
   }
 
   @Override
-  protected ComponentElementValidator componentElementValidator(
+  public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
-    final Set<Element> subcomponentBuilderElements =
-        elementsByAnnotation.get(Subcomponent.Builder.class);
-    final Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
-        processSubcomponentBuilders(subcomponentBuilderElements);
-    final Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
-    final Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
+
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processBuilders(elementsByAnnotation.get(componentKind.builderAnnotationType()));
+    Set<Element> subcomponentBuilderElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                .toSet());
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+        processBuilders(subcomponentBuilderElements);
+    Set<Element> subcomponentElements =
+        getElementsFromAnnotations(
+            elementsByAnnotation,
+            FluentIterable.from(componentKind.subcomponentKinds())
+                .transform(ComponentDescriptor.Kind.toAnnotationType())
+                .toSet());
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-    return new ComponentElementValidator() {
-      @Override
-      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+
+    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      try {
         ComponentValidationReport validationReport =
             componentValidator.validate(
                 componentTypeElement, subcomponentElements, subcomponentBuilderElements);
         validationReport.report().printMessagesTo(messager);
-        return isClean(
+        if (isClean(
             validationReport,
             builderReportsByComponent,
             reportsBySubcomponent,
-            builderReportsBySubcomponent);
+            builderReportsBySubcomponent)) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(componentTypeElement);
+          ValidationReport<TypeElement> hierarchyReport =
+              componentHierarchyValidator.validate(componentDescriptor);
+          hierarchyReport.printMessagesTo(messager);
+          if (hierarchyReport.isClean()) {
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            ValidationReport<TypeElement> graphReport =
+                bindingGraphValidator.validate(bindingGraph);
+            graphReport.printMessagesTo(messager);
+            if (graphReport.isClean()) {
+              generateComponent(bindingGraph);
+            }
+          }
+        }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentTypeElement);
       }
-    };
+    }
+    return rejectedElements.build();
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
-      Set<? extends Element> componentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : componentBuilderElements) {
-      ValidationReport<TypeElement> report =
-          componentBuilderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
+  private void generateComponent(BindingGraph bindingGraph) {
+    try {
+      componentGenerator.generate(bindingGraph);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
     }
-    return builderReportsByComponent;
   }
 
-  private Map<Element, ValidationReport<TypeElement>> processSubcomponentBuilders(
-      Set<? extends Element> subcomponentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
-    for (Element element : subcomponentBuilderElements) {
+  private ImmutableSet<Element> getElementsFromAnnotations(
+      final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
+      ImmutableSet<Class<? extends Annotation>> annotations) {
+    return ImmutableSet.copyOf(
+        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processBuilders(
+      Set<? extends Element> builderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : builderElements) {
       ValidationReport<TypeElement> report =
-          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+          builderValidator.validate(MoreElements.asType(element));
       report.printMessagesTo(messager);
-      builderReportsBySubcomponent.put(element, report);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
     }
-    return builderReportsBySubcomponent;
+    return builderReportsByComponent;
   }
 
   private Map<Element, ValidationReport<TypeElement>> processSubcomponents(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 46571b889..c5fd2fd5e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -20,11 +20,6 @@
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -93,35 +88,17 @@ public SourceVersion getSupportedSourceVersion() {
         privateMemberValidationType(processingEnv).diagnosticKind().get(),
         staticMemberValidationType(processingEnv).diagnosticKind().get());
     ModuleValidator moduleValidator =
-        new ModuleValidator(
-            types,
-            elements,
-            methodSignatureFormatter,
-            Module.class,
-            ImmutableList.<Class<? extends Annotation>>of(Module.class),
-            Provides.class);
-    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
-    BuilderValidator componentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
-    BuilderValidator subcomponentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
-    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
-        types, moduleValidator, subcomponentBuilderValidator);
-    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
-        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
+        new ModuleValidator(types, elements, methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+            elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator =
-        new ModuleValidator(
-            types,
-            elements,
-            methodSignatureFormatter,
-            ProducerModule.class,
-            ImmutableList.of(Module.class, ProducerModule.class),
-            Produces.class);
+    ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
-    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
-    BuilderValidator productionComponentBuilderValidator =
-        new BuilderValidator(elements, types, ComponentDescriptor.Kind.PRODUCTION_COMPONENT);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -194,11 +171,11 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             factoryGenerator),
         new ComponentProcessingStep(
+            ComponentDescriptor.Kind.COMPONENT,
             messager,
             componentValidator,
             subcomponentValidator,
-            componentBuilderValidator,
-            subcomponentBuilderValidator,
+            builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
@@ -206,14 +183,16 @@ public SourceVersion getSupportedSourceVersion() {
             componentGenerator),
         new ProducerModuleProcessingStep(
             messager,
-            producerModuleValidator,
+            moduleValidator,
             producesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
-        new ProductionComponentProcessingStep(
+        new ComponentProcessingStep(
+            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
-            productionComponentValidator,
-            productionComponentBuilderValidator,
+            componentValidator,
+            subcomponentValidator,
+            builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index a9e82a8cf..0be4686a9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -19,6 +19,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -26,8 +27,7 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Module;
-import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -56,14 +56,14 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * Performs superficial validation of the contract of the {@link Component} annotation.
+ * Performs superficial validation of the contract of the {@link Component} and
+ * {@link ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
 final class ComponentValidator {
   private final Elements elements;
   private final Types types;
-  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
@@ -74,7 +74,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = this;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -87,7 +86,6 @@ private ComponentValidator(Elements elements,
       BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
-    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
     this.subcomponentValidator = subcomponentValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
@@ -98,21 +96,15 @@ static ComponentValidator createForComponent(Elements elements,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(
+        elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
   static ComponentValidator createForSubcomponent(Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
-    return new ComponentValidator(elements,
-        types,
-        moduleValidator,
-        subcomponentBuilderValidator);
+    return new ComponentValidator(elements, types, moduleValidator, subcomponentBuilderValidator);
   }
 
   @AutoValue
@@ -130,20 +122,23 @@ public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
+    ComponentDescriptor.Kind componentKind =
+        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
+
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
       builder.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
-              componentType.annotationType().getSimpleName()),
+              componentKind.annotationType().getSimpleName()),
           subject);
     }
 
     ImmutableList<DeclaredType> builders =
-        enclosedBuilders(subject, componentType.builderAnnotationType());
+        enclosedBuilders(subject, componentKind.builderAnnotationType());
     if (builders.size() > 1) {
       builder.addError(
-          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
@@ -164,12 +159,23 @@ public ComponentValidationReport validate(final TypeElement subject,
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
         Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotation(returnType, Subcomponent.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toAnnotationType())
+                    .toSet());
         Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotation(returnType, Subcomponent.Builder.class);
+            checkForAnnotations(
+                returnType,
+                FluentIterable.from(componentKind.subcomponentKinds())
+                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                    .toSet());
         if (subcomponentAnnotation.isPresent()) {
           referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(builder,
+          validateSubcomponentMethod(
+              builder,
+              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
+                  .get(),
               method,
               parameters,
               parameterTypes,
@@ -224,9 +230,10 @@ public ComponentValidationReport validate(final TypeElement subject,
     }
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentType.annotationType()).get();
+        getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
+    moduleValidator.validateReferencedModules(
+        subject, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -247,7 +254,9 @@ public ComponentValidationReport validate(final TypeElement subject,
         builder.build());
   }
 
-  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+  private void validateSubcomponentMethod(
+      final ValidationReport.Builder<TypeElement> builder,
+      final ComponentDescriptor.Kind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -268,18 +277,26 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     for (int i = 0; i < parameterTypes.size(); i++) {
       VariableElement parameter = parameters.get(i);
       TypeMirror parameterType = parameterTypes.get(i);
-      Optional<TypeElement> moduleType = parameterType.accept(
-          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
-            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-              return Optional.absent();
-            }
+      Optional<TypeElement> moduleType =
+          parameterType.accept(
+              new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+                @Override
+                protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+                  return Optional.absent();
+                }
 
-            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
-                  ? Optional.of(MoreTypes.asTypeElement(t))
-                  : Optional.<TypeElement>absent();
-            }
-          }, null);
+                @Override
+                public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
+                    if (MoreElements.isAnnotationPresent(
+                        t.asElement(), moduleKind.moduleAnnotation())) {
+                      return Optional.of(MoreTypes.asTypeElement(t));
+                    }
+                  }
+                  return Optional.absent();
+                }
+              },
+              null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
           builder.addError(
@@ -328,18 +345,27 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
-      final Class<? extends Annotation> annotation) {
-    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-      @Override
-      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-        return Optional.absent();
-      }
+  private Optional<AnnotationMirror> checkForAnnotations(
+      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
+    return type.accept(
+        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+          @Override
+          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+            return Optional.absent();
+          }
 
-      @Override
-      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
-      }
-    }, null);
+          @Override
+          public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+            for (Class<? extends Annotation> annotation : annotations) {
+              Optional<AnnotationMirror> mirror =
+                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
+              if (mirror.isPresent()) {
+                return mirror;
+              }
+            }
+            return Optional.absent();
+          }
+        },
+        null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c938af2c3..58a75e5f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,14 +1,18 @@
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
@@ -19,6 +23,7 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
@@ -51,6 +56,59 @@
 
   abstract DefaultCreationStrategy defaultCreationStrategy();
 
+  enum Kind {
+    MODULE(
+        Module.class, Provides.class, ImmutableSet.of(Module.class)),
+    PRODUCER_MODULE(
+        ProducerModule.class,
+        Produces.class,
+        ImmutableSet.of(Module.class, ProducerModule.class));
+
+    private final Class<? extends Annotation> moduleAnnotation;
+    private final Class<? extends Annotation> methodAnnotation;
+    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #moduleAnnotation() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
+    }
+
+    Kind(
+        Class<? extends Annotation> moduleAnnotation,
+        Class<? extends Annotation> methodAnnotation,
+        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
+      this.moduleAnnotation = moduleAnnotation;
+      this.methodAnnotation = methodAnnotation;
+      this.includesTypes = includesTypes;
+    }
+
+    Class<? extends Annotation> moduleAnnotation() {
+      return moduleAnnotation;
+    }
+
+    Class<? extends Annotation> methodAnnotation() {
+      return methodAnnotation;
+    }
+
+    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
+      return includesTypes;
+    }
+  }
+
   static final class Factory {
     private final Elements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 8b0c9a217..9bb5fd1b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -70,46 +70,37 @@
 final class ModuleValidator {
   private final Types types;
   private final Elements elements;
-  private final Class<? extends Annotation> moduleClass;
-  private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
-  private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
-      Types types,
-      Elements elements,
-      MethodSignatureFormatter methodSignatureFormatter,
-      Class<? extends Annotation> moduleClass,
-      ImmutableList<Class<? extends Annotation>> includedModuleClasses,
-      Class<? extends Annotation> methodClass) {
+      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
-    this.moduleClass = moduleClass;
-    this.includedModuleClasses = includedModuleClasses;
-    this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, methodClass)) {
+      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
 
-    validateModuleVisibility(subject, builder);
-    validateMethodsWithSameName(builder, bindingMethodsByName);
+    validateModuleVisibility(subject, moduleKind, builder);
+    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
-      validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+      validateProvidesOverrides(
+          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
     validateModifiers(subject, builder);
-    validateReferencedModules(subject, builder);
+    validateReferencedModules(subject, moduleKind, builder);
 
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
@@ -125,6 +116,7 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
+      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -132,7 +124,8 @@ private void validateMethodsWithSameName(
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
-              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+              String.format(
+                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
               offendingMethod);
         }
       }
@@ -140,11 +133,27 @@ private void validateMethodsWithSameName(
   }
 
   private void validateReferencedModules(
-      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
+      TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
+      ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject,  builder, includedTypes);
+    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
+  }
+
+  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    return FluentIterable.from(validModuleKinds)
+        .transformAndConcat(
+            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
+              @Override
+              public Set<? extends Class<? extends Annotation>> apply(
+                  ModuleDescriptor.Kind moduleKind) {
+                return moduleKind.includesTypes();
+              }
+            })
+        .toSet();
   }
 
   /**
@@ -153,7 +162,11 @@ private void validateReferencedModules(
   void validateReferencedModules(
       final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes) {
+      ImmutableList<TypeMirror> includedTypes,
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
+        includedModuleClasses(validModuleKinds);
+
     for (TypeMirror includedType : includedTypes) {
       includedType.accept(
           new SimpleTypeVisitor6<Void, Void>() {
@@ -215,6 +228,7 @@ public String apply(
 
   private void validateProvidesOverrides(
       TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
@@ -251,13 +265,13 @@ private void validateProvidesOverrides(
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                    methodClass.getSimpleName(),
+                    moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
-        if (isAnnotationPresent(superclassMethod, methodClass)) {
+        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {
           for (ExecutableElement method : allMethodsByName.get(name)) {
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
@@ -265,7 +279,7 @@ private void validateProvidesOverrides(
               builder.addError(
                   String.format(
                       METHOD_OVERRIDES_PROVIDES_METHOD,
-                      methodClass.getSimpleName(),
+                      moduleKind.methodAnnotation().getSimpleName(),
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
@@ -276,7 +290,9 @@ private void validateProvidesOverrides(
     }
   }
 
-  private void validateModuleVisibility(final TypeElement moduleElement,
+  private void validateModuleVisibility(
+      final TypeElement moduleElement,
+      ModuleDescriptor.Kind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
@@ -293,18 +309,24 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case MEMBER:
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
-          ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
-              getAnnotationMirror(moduleElement, moduleClass).get()))
-                  .transform(new Function<TypeMirror, Element>() {
-                    @Override public Element apply(TypeMirror input) {
-                      return types.asElement(input);
-                    }
-                  })
-                  .filter(new Predicate<Element>() {
-                    @Override public boolean apply(Element input) {
-                      return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                    }
-                  })
+          ImmutableSet<Element> nonPublicModules =
+              FluentIterable.from(
+                      getModuleIncludes(
+                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
+                  .transform(
+                      new Function<TypeMirror, Element>() {
+                        @Override
+                        public Element apply(TypeMirror input) {
+                          return types.asElement(input);
+                        }
+                      })
+                  .filter(
+                      new Predicate<Element>() {
+                        @Override
+                        public boolean apply(Element input) {
+                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                        }
+                      })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
deleted file mode 100644
index 0581b1bb1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import com.google.common.collect.SetMultimap;
-import dagger.producers.ProductionComponent;
-import java.lang.annotation.Annotation;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
- * annotation as part of the {@link ComponentProcessor}.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
-  private final Messager messager;
-  private final ProductionComponentValidator componentValidator;
-  private final BuilderValidator componentBuilderValidator;
-
-  ProductionComponentProcessingStep(
-      Messager messager,
-      ProductionComponentValidator componentValidator,
-      BuilderValidator componentBuilderValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
-      BindingGraphValidator bindingGraphValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory,
-      BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
-    super(
-        ProductionComponent.class,
-        messager,
-        componentHierarchyValidator,
-        bindingGraphValidator,
-        componentDescriptorFactory,
-        bindingGraphFactory,
-        componentGenerator);
-    this.messager = messager;
-    this.componentValidator = componentValidator;
-    this.componentBuilderValidator = componentBuilderValidator;
-  }
-
-  @Override
-  public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(
-        ProductionComponent.class, ProductionComponent.Builder.class);
-  }
-
-  // TODO(beder): Move common logic into the AbstractComponentProcessingStep when implementing
-  // production subcomponents.
-  @Override
-  protected ComponentElementValidator componentElementValidator(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
-        processComponentBuilders(elementsByAnnotation.get(ProductionComponent.Builder.class));
-    return new ComponentElementValidator() {
-      @Override
-      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
-        ValidationReport<TypeElement> validationReport =
-            componentValidator.validate(componentTypeElement);
-        validationReport.printMessagesTo(messager);
-        if (!validationReport.isClean()) {
-          return false;
-        }
-        ValidationReport<?> builderReport = builderReportsByComponent.get(componentTypeElement);
-        return builderReport == null || builderReport.isClean();
-      }
-    };
-  }
-
-  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
-      Set<? extends Element> componentBuilderElements) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : componentBuilderElements) {
-      ValidationReport<TypeElement> report =
-          componentBuilderValidator.validate(MoreElements.asType(element));
-      report.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), report);
-    }
-    return builderReportsByComponent;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
deleted file mode 100644
index 2e2291d34..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
-import dagger.Module;
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-
-/**
- * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
- *
- * @author Jesse Beder
- */
-final class ProductionComponentValidator {
-  ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
-
-    if (!subject.getKind().equals(INTERFACE)
-        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addError(
-          "@ProductionComponent may only be applied to an interface or abstract class", subject);
-    }
-
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, ProductionComponent.class).get();
-    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-
-    // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(
-          new SimpleTypeVisitor6<Void, Void>() {
-            @Override
-            protected Void defaultAction(TypeMirror mirror, Void p) {
-              builder.addError(mirror + " is not a valid module type.", subject);
-              return null;
-            }
-
-            @Override
-            public Void visitDeclared(DeclaredType t, Void p) {
-              checkState(t.getTypeArguments().isEmpty());
-              TypeElement moduleElement = MoreElements.asType(t.asElement());
-              if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
-                  && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
-                builder.addError(
-                    moduleElement.getQualifiedName()
-                        + " is listed as a module, but is not annotated with @Module or"
-                        + " @ProducerModule",
-                    subject);
-              }
-              return null;
-            }
-          },
-          null);
-    }
-
-    return builder.build();
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index a8e39b28a..5564e52ca 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -78,10 +78,11 @@
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is not annotated with @Module or @ProducerModule");
+        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test public void simpleComponent() {
