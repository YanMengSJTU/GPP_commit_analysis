diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index a0768671f..8628417f0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -74,6 +75,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
@@ -85,7 +87,6 @@
 import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.Util.asDeclaredType;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -479,7 +480,7 @@ private Snippet initializeMapBinding(
           ClassName.fromClass(MapFactory.class),
           memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
     } else {
-      DeclaredType mapType = Util.asDeclaredType(firstBinding.key().type());
+      DeclaredType mapType = asDeclared(firstBinding.key().type());
       TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
       TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
       StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
@@ -600,8 +601,8 @@ public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
 
   private boolean isNonProviderMap(Binding binding) {
     TypeMirror bindingType = binding.key().type();
-    return Util.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
-        && !Util.isTypeOf(Provider.class, asDeclaredType(bindingType).getTypeArguments().get(1));
+    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
   }
 
   private boolean hasNoArgsConstructor(TypeElement type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index a59a01fec..4a9cb8868 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
@@ -86,7 +87,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(Util.asDeclaredType(binding.key().type()))
+
+        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
         : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index ffd55ff77..0510730c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -237,10 +237,10 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      if (Util.isTypeOf(Map.class, possibleMapKey.type())) {
-        DeclaredType declaredMapType = Util.asDeclaredType(possibleMapKey.type());
+      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
+        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
         TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!Util.isTypeOf(Provider.class, mapValueType)) {
+        if (!MoreTypes.isTypeOf(Provider.class, mapValueType)) {
           DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
           DeclaredType providerType = types.getDeclaredType(getProviderElement(), mapValueType);
           TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, providerType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index c38a6eec2..77ea7b2f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.Iterables;
 import java.util.List;
 import java.util.Map;
@@ -26,17 +27,10 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.NoType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
 /**
@@ -48,8 +42,8 @@
    * includes such a construction
    */
   public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
-    checkState(isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return asDeclaredType(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
   }
 
   // TODO(user): Consider an object that holds and exposes the various parts of a Map type.
@@ -57,7 +51,7 @@ public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
    * returns the value type for a {@link Map} type like Map<K, V>}.
    */
   public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
-    checkState(isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
     List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
     return mapArgs.get(1);
   }
@@ -66,9 +60,9 @@ public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
    * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
   public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
-    checkState(isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
     List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return asDeclaredType(mapArgs.get(0));
+    return MoreTypes.asDeclared(mapArgs.get(0));
   }
 
   /**
@@ -101,78 +95,5 @@ protected TypeElement defaultAction(Object o, Void v) {
     return keyTypeElement;
   }
 
-  // TODO(user): move to MoreTypes
-  /**
-   * Returns a {@link DeclaredType} if the {@link TypeMirror} represents a declared type such
-   * as a class, interface, or enum.
-   */
-  static DeclaredType asDeclaredType(TypeMirror type) {
-    return type.accept(new SimpleTypeVisitor6<DeclaredType, Void>() {
-      @Override protected DeclaredType defaultAction(TypeMirror type, Void ignored) {
-        throw new IllegalStateException(type + " is not a DeclaredType.");
-      }
-
-      @Override public DeclaredType visitDeclared(DeclaredType type, Void ignored) {
-        return type;
-      }
-    }, null);
-  }
-
-  // TODO(user): move to MoreTypes
-  /**
-   * Returns true if the raw type underlying the given {@link TypeMirror} represents the
-   * same raw type as the given {@link Class} and throws an IllegalArgumentException if the
-   * {@link TypeMirror} does not represent a type that can be referenced by a {@link Class}
-   */
-  static boolean isTypeOf(final Class<?> clazz, TypeMirror type) {
-    checkNotNull(clazz);
-    checkNotNull(type);
-    return type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror type, Void ignored) {
-        throw new IllegalArgumentException(type + " cannot be represented as a Class<?>.");
-      }
-
-      @Override public Boolean visitNoType(NoType noType, Void p) {
-        if (noType.getKind().equals(TypeKind.VOID)) {
-          return clazz.equals(Void.TYPE);
-        }
-        throw new IllegalArgumentException(noType + " cannot be represented as a Class<?>.");
-      }
-
-      @Override public Boolean visitPrimitive(PrimitiveType type, Void p) {
-        switch (type.getKind()) {
-          case BOOLEAN:
-            return clazz.equals(Boolean.TYPE);
-          case BYTE:
-            return clazz.equals(Byte.TYPE);
-          case CHAR:
-            return clazz.equals(Character.TYPE);
-          case DOUBLE:
-            return clazz.equals(Double.TYPE);
-          case FLOAT:
-            return clazz.equals(Float.TYPE);
-          case INT:
-            return clazz.equals(Integer.TYPE);
-          case LONG:
-            return clazz.equals(Long.TYPE);
-          case SHORT:
-            return clazz.equals(Short.TYPE);
-          default:
-            throw new IllegalArgumentException(type + " cannot be represented as a Class<?>.");
-        }
-      }
-
-      @Override public Boolean visitArray(ArrayType array, Void p) {
-        return clazz.isArray()
-            && isTypeOf(clazz.getComponentType(), array.getComponentType());
-      }
-
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        TypeElement typeElement = MoreElements.asType(type.asElement());
-        return typeElement.getQualifiedName().contentEquals(clazz.getCanonicalName());
-      }
-    }, null);
-  }
-
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/UtilTest.java b/compiler/src/test/java/dagger/internal/codegen/UtilTest.java
deleted file mode 100644
index 8c3dad7b5..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/UtilTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.Iterables;
-import com.google.testing.compile.CompilationRule;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assert_;
-
-/**
- * Tests {@link Util}.
- */
-@RunWith(JUnit4.class)
-public class UtilTest {
-
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-
-  @Before public void setUp() {
-    this.elements = compilationRule.getElements();
-  }
-
-  private interface TestType {}
-
-  @Test public void isTypeOf_DeclaredType() {
-    assertThat(Util.isTypeOf(TestType.class, typeElementFor(TestType.class).asType()))
-        .named("mirror represents the TestType")
-        .isTrue();
-    assertThat(Util.isTypeOf(String.class, typeElementFor(TestType.class).asType()))
-        .named("mirror does not represent a String")
-        .isFalse();
-  }
-
-  private interface ArrayType {
-    String[] array();
-  }
-
-  @Test public void isTypeOf_ArrayType() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(ArrayType.class));
-    assertThat(Util.isTypeOf(new String[] {}.getClass(), type))
-        .named("array mirror represents an array Class object")
-        .isTrue();
-  }
-
-  private interface PrimitiveBoolean {
-    boolean method();
-  }
-
-  @Test public void isTypeOf_PrimitiveBoolean() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveBoolean.class));
-    assertThat(Util.isTypeOf(Boolean.TYPE, type)).named("mirror of a boolean").isTrue();
-  }
-
-  private interface PrimitiveByte {
-    byte method();
-  }
-
-  @Test public void isTypeOf_PrimitiveByte() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveByte.class));
-    assertThat(Util.isTypeOf(Byte.TYPE, type)).named("mirror of a byte").isTrue();
-  }
-
-  private interface PrimitiveChar {
-    char method();
-  }
-
-  @Test public void isTypeOf_PrimitiveChar() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveChar.class));
-    assertThat(Util.isTypeOf(Character.TYPE, type)).named("mirror of a char").isTrue();
-  }
-
-  private interface PrimitiveDouble {
-    double method();
-  }
-
-  @Test public void isTypeOf_PrimitiveDouble() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveDouble.class));
-    assertThat(Util.isTypeOf(Double.TYPE, type)).named("mirror of a double").isTrue();
-  }
-
-  private interface PrimitiveFloat {
-    float method();
-  }
-
-  @Test public void isTypeOf_PrimitiveFloat() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveFloat.class));
-    assertThat(Util.isTypeOf(Float.TYPE, type)).named("mirror of a float").isTrue();
-  }
-
-  private interface PrimitiveInt {
-    int method();
-  }
-
-  @Test public void isTypeOf_PrimitiveInt() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveInt.class));
-    assertThat(Util.isTypeOf(Integer.TYPE, type)).named("mirror of a int").isTrue();
-  }
-
-  private interface PrimitiveLong {
-    long method();
-  }
-
-  @Test public void isTypeOf_PrimitiveLong() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveLong.class));
-    assertThat(Util.isTypeOf(Long.TYPE, type)).named("mirror of a long").isTrue();
-  }
-
-  private interface PrimitiveShort {
-    short method();
-  }
-
-  @Test public void isTypeOf_PrimitiveShort() {
-    TypeMirror type = extractReturnTypeFromHolder(typeElementFor(PrimitiveShort.class));
-    assertThat(Util.isTypeOf(Short.TYPE, type)).named("mirror of a short").isTrue();
-  }
-
-  private interface PrimitiveVoid {
-    void method();
-  }
-
-  @Test public void isTypeOf_void() {
-    TypeMirror primitive = extractReturnTypeFromHolder(typeElementFor(PrimitiveVoid.class));
-    assertThat(Util.isTypeOf(Void.TYPE, primitive)).named("mirror of a void").isTrue();
-  }
-
-  private interface DeclaredVoid {
-    Void method();
-  }
-
-  @Test public void isTypeOf_Void() {
-    TypeMirror declared = extractReturnTypeFromHolder(typeElementFor(DeclaredVoid.class));
-    assertThat(Util.isTypeOf(Void.class, declared)).named("mirror of a void").isTrue();
-  }
-
-  @Test public void isTypeOf_fail() {
-    TypeMirror method =
-        getOnlyElement(typeElementFor(DeclaredVoid.class).getEnclosedElements()).asType();
-    try {
-      Util.isTypeOf(String.class, method);
-      assert_().fail();
-    } catch (IllegalArgumentException expected) {}
-  }
-
-  // Utility methods for this test.
-
-  private TypeMirror extractReturnTypeFromHolder(TypeElement typeElement) {
-    Element element = Iterables.getOnlyElement(typeElement.getEnclosedElements());
-    TypeMirror arrayType = MoreElements.asExecutable(element).getReturnType();
-    return arrayType;
-  }
-
-  private TypeElement typeElementFor(Class<?> clazz) {
-    return elements.getTypeElement(clazz.getCanonicalName());
-  }
-}
